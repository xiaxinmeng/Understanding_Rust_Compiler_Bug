{"sha": "cf1381c1d000a24f95be7d53c4318c18c2daddbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMTM4MWMxZDAwMGEyNGY5NWJlN2Q1M2M0MzE4YzE4YzJkYWRkYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T00:46:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-26T00:46:16Z"}, "message": "auto merge of #15789 : steveklabnik/rust/guide_pointers, r=cmr\n\nThis is super, super WIP, but I'm going to go get lunch for a while, and figured I'd toss my work up here in case anyone wants to see my work as I do it.\r\n\r\nThis contains a new introductory section explaining the basics of pointers, and some pitfalls that Rust attempts to solve. I'd be interested in hearing how my explanation is, as well as if this belongs here. Pointers are such a crucial concept, I don't mind having a beginners' section on them in the main docs, even though our main audience is supposed to understand them already. Reasonable people may disagree, however.", "tree": {"sha": "8c04097c7494e4ab96c91e5e3f24341d4640bf90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c04097c7494e4ab96c91e5e3f24341d4640bf90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf1381c1d000a24f95be7d53c4318c18c2daddbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1381c1d000a24f95be7d53c4318c18c2daddbb", "html_url": "https://github.com/rust-lang/rust/commit/cf1381c1d000a24f95be7d53c4318c18c2daddbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf1381c1d000a24f95be7d53c4318c18c2daddbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92c97059ff6fe728d47d7fd2c06a658fd12957d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/92c97059ff6fe728d47d7fd2c06a658fd12957d0", "html_url": "https://github.com/rust-lang/rust/commit/92c97059ff6fe728d47d7fd2c06a658fd12957d0"}, {"sha": "377b2508f2771156620f8be49940c88565f9af1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/377b2508f2771156620f8be49940c88565f9af1a", "html_url": "https://github.com/rust-lang/rust/commit/377b2508f2771156620f8be49940c88565f9af1a"}], "stats": {"total": 865, "additions": 603, "deletions": 262}, "files": [{"sha": "5ec16e852a5f94917ae4e3cdea15e1643e3fec2d", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 603, "deletions": 262, "changes": 865, "blob_url": "https://github.com/rust-lang/rust/blob/cf1381c1d000a24f95be7d53c4318c18c2daddbb/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/cf1381c1d000a24f95be7d53c4318c18c2daddbb/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=cf1381c1d000a24f95be7d53c4318c18c2daddbb", "patch": "@@ -5,408 +5,749 @@ are also one of the more confusing topics for newcomers to Rust. They can also\n be confusing for people coming from other languages that support pointers, such\n as C++. This guide will help you understand this important topic.\n \n-# You don't actually need pointers, use references\n-\n-I have good news for you: you probably don't need to care about pointers,\n-especially as you're getting started. Think of it this way: Rust is a language\n-that emphasizes safety. Pointers, as the joke goes, are very pointy: it's easy\n-to accidentally stab yourself. Therefore, Rust is made in a way such that you\n-don't need them very often.\n-\n-\"But guide!\" you may cry. \"My co-worker wrote a function that looks like this:\n-\n-~~~rust\n-fn succ(x: &int) -> int { *x + 1 }\n-~~~\n-\n-So I wrote this code to try it out:\n-\n-~~~rust{.ignore}\n-fn main() {\n-    let number = 5;\n-    let succ_number = succ(number);\n-    println!(\"{}\", succ_number);\n+Be sceptical of non-reference pointers in Rust: use them for a deliberate\n+purpose, not just to make the compiler happy. Each pointer type comes with an\n+explanation about when they are appropriate to use. Default to references\n+unless you're in one of those specific situations.\n+\n+You may be interested in the [cheat sheet](#cheat-sheet), which gives a quick\n+overview of the types, names, and purpose of the various pointers.\n+\n+# An introduction\n+\n+If you aren't familiar with the concept of pointers, here's a short\n+introduction.  Pointers are a very fundamental concept in systems programming\n+languages, so it's important to understand them.\n+\n+## Pointer Basics\n+\n+When you create a new variable binding, you're giving a name to a value that's\n+stored at a particular location on the stack. (If you're not familiar with the\n+\"heap\" vs. \"stack\", please check out [this Stack Overflow\n+question](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap),\n+as the rest of this guide assumes you know the difference.) Like this:\n+\n+```{rust}\n+let x = 5i;\n+let y = 8i;\n+```\n+| location | value |\n+|----------|-------|\n+| 0xd3e030 | 5\t   |\n+| 0xd3e028 | 8     |\n+\n+We're making up memory locations here, they're just sample values. Anyway, the\n+point is that `x`, the name we're using for our variable, corresponds to the\n+memory location `0xd3e030`, and the value at that location is `5`. When we\n+refer to `x`, we get the corresponding value. Hence, `x` is `5`.\n+\n+Let's introduce a pointer. In some languages, there is just one type of\n+'pointer,' but in Rust, we have many types. In this case, we'll use a Rust\n+**reference**, which is the simplest kind of pointer.\n+\n+```{rust}\n+let x = 5i;\n+let y = 8i;\n+let z = &y;\n+```\n+|location | value    |\n+|-------- |----------|\n+|0xd3e030 | 5        |\n+|0xd3e028 | 8        |\n+|0xd3e020 | 0xd3e028 |\n+\n+See the difference? Rather than contain a value, the value of a pointer is a\n+location in memory. In this case, the location of `y`. `x` and `y` have the\n+type `int`, but `z` has the type `&int`. We can print this location using the\n+`{:p}` format string:\n+\n+```{rust}\n+let x = 5i;\n+let y = 8i;\n+let z = &y;\n+\n+println!(\"{:p}\", z);\n+```\n+\n+This would print `0xd3e028`, with our fictional memory addresses.\n+\n+Because `int` and `&int` are different types, we can't, for example, add them\n+together:\n+\n+```{rust,ignore}\n+let x = 5i;\n+let y = 8i;\n+let z = &y;\n+\n+println!(\"{}\", x + z);\n+```\n+\n+This gives us an error:\n+\n+```{notrust,ignore}\n+hello.rs:6:24: 6:25 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)\n+hello.rs:6     println!(\"{}\", x + z);\n+                                  ^\n+```\n+\n+We can **dereference** the pointer by using the `*` operator. Dereferencing a\n+pointer means accessing the value at the location stored in the pointer. This\n+will work:\n+\n+```{rust}\n+let x = 5i;\n+let y = 8i;\n+let z = &y;\n+\n+println!(\"{}\", x + *z);\n+```\n+\n+It prints `13`.\n+\n+That's it! That's all pointers are: they point to some memory location. Not\n+much else to them. Now that we've discussed the 'what' of pointers, let's\n+talk about the 'why.'\n+\n+## Pointer uses\n+\n+Rust's pointers are quite useful, but in different ways than in other systems\n+languages. We'll talk about best practices for Rust pointers later in\n+the guide, but here are some ways that pointers are useful in other languages:\n+\n+In C, strings are a pointer to a list of `char`s, ending with a null byte.\n+The only way to use strings is to get quite familiar with pointers.\n+\n+Pointers are useful to point to memory locations that are not on the stack. For\n+example, our example used two stack variables, so we were able to give them\n+names. But if we allocated some heap memory, we wouldn't have that name\n+available.  In C, `malloc` is used to allocate heap memory, and it returns a\n+pointer.\n+\n+As a more general variant of the previous two points, any time you have a\n+structure that can change in size, you need a pointer. You can't tell at\n+compile time how much memory to allocate, so you've gotta use a pointer to\n+point at the memory where it will be allocated, and deal with it at run time.\n+\n+Pointers are useful in languages that are pass-by-value, rather than\n+pass-by-reference. Basically, languages can make two choices (this is made\n+up syntax, it's not Rust):\n+\n+```{notrust,ignore}\n+fn foo(x) {\n+    x = 5\n }\n-~~~\n-\n-And now I get an error:\n-\n-~~~text\n-error: mismatched types: expected `&int` but found `<generic integer #0>` (expected &-ptr but found integral variable)\n-~~~\n-\n-What gives? It needs a pointer! Therefore I have to use pointers!\"\n-\n-Turns out, you don't. All you need is a reference. Try this on for size:\n \n-~~~rust\n-# fn succ(x: &int) -> int { *x + 1 }\n fn main() {\n-    let number = 5;\n-    let succ_number = succ(&number);\n-    println!(\"{}\", succ_number);\n+    i = 1\n+    foo(i)\n+    // what is the value of i here?\n }\n-~~~\n+```\n \n-It's that easy! One extra little `&` there. This code will run, and print `6`.\n+In languages that are pass-by-value, `foo` will get a copy of `i`, and so\n+the original version of `i` is not modified. At the comment, `i` will still be\n+`1`. In a language that is pass-by-reference, `foo` will get a reference to `i`,\n+and therefore, can change its value. At the comment, `i` will be `5`.\n \n-That's all you need to know. Your co-worker could have written the function\n-like this:\n+So what do pointers have to do with this? Well, since pointers point to a\n+location in memory...\n \n-~~~rust\n-fn succ(x: int) -> int { x + 1 }\n+```{notrust,ignore}\n+fn foo(&int x) {\n+    *x = 5\n+}\n \n fn main() {\n-    let number = 5;\n-    let succ_number = succ(number);\n-    println!(\"{}\", succ_number);\n+    i = 1\n+    foo(&i)\n+    // what is the value of i here?\n }\n-~~~\n-\n-No pointers even needed. Then again, this is a simple example. I assume that\n-your real-world `succ` function is more complicated, and maybe your co-worker\n-had a good reason for `x` to be a pointer of some kind. In that case, references\n-are your best friend. Don't worry about it, life is too short.\n-\n-However.\n-\n-Here are the use-cases for pointers. I've prefixed them with the name of the\n-pointer that satisfies that use-case:\n+```\n \n-1. Owned: `Box<Trait>` must be a pointer, because you don't know the size of the\n-object, so indirection is mandatory.\n+Even in a language which is pass by value, `i` will be `5` at the comment. You\n+see, because the argument `x` is a pointer, we do send a copy over to `foo`,\n+but because it points at a memory location, which we then assign to, the\n+original value is still changed. This pattern is called\n+'pass-reference-by-value.' Tricky!\n \n-2. Owned: You need a recursive data structure. These can be infinite sized, so\n-indirection is mandatory.\n+## Common pointer problems\n \n-3. Owned: A very, very, very rare situation in which you have a *huge* chunk of\n-data that you wish to pass to many methods. Passing a pointer will make this\n-more efficient. If you're coming from another language where this technique is\n-common, such as C++, please read \"A note...\" below.\n+We've talked about pointers, and we've sung their praises. So what's the\n+downside? Well, Rust attempts to mitigate each of these kinds of problems,\n+but here are problems with pointers in other languages:\n \n-4. Reference: You're writing a function, and you need a pointer, but you don't\n-care about its ownership. If you make the argument a reference, callers\n-can send in whatever kind they want.\n+Uninitialized pointers can cause a problem. For example, what does this program\n+do?\n \n-5. Shared: You need to share data among tasks. You can achieve that via the\n-`Rc` and `Arc` types.\n+```{notrust,ignore}\n+&int x;\n+*x = 5; // whoops!\n+```\n \n-Five exceptions. That's it. Otherwise, you shouldn't need them. Be sceptical\n-of pointers in Rust: use them for a deliberate purpose, not just to make the\n-compiler happy.\n+Who knows? We just declare a pointer, but don't point it at anything, and then\n+set the memory location that it points at to be `5`. But which location? Nobody\n+knows. This might be harmless, and it might be catastrophic.\n \n-## A note for those proficient in pointers\n+When you combine pointers and functions, it's easy to accidentally invalidate\n+the memory the pointer is pointing to. For example:\n \n-If you're coming to Rust from a language like C or C++, you may be used to\n-passing things by reference, or passing things by pointer. In some languages,\n-like Java, you can't even have objects without a pointer to them. Therefore, if\n-you were writing this Rust code:\n+```{notrust,ignore}\n+fn make_pointer(): &int {\n+    x = 5;\n \n-~~~rust\n-# fn transform(p: Point) -> Point { p }\n-#[deriving(Show)]\n-struct Point {\n-    x: int,\n-    y: int,\n+    return &x;\n }\n \n fn main() {\n-    let p0 = Point { x: 5, y: 10};\n-    let p1 = transform(p0);\n-    println!(\"{}\", p1);\n+    &int i = make_pointer();\n+    *i = 5; // uh oh!\n }\n+```\n \n-~~~\n+`x` is local to the `make_pointer` function, and therefore, is invalid as soon\n+as `make_pointer` returns. But we return a pointer to its memory location, and\n+so back in `main`, we try to use that pointer, and it's a very similar\n+situation to our first one. Setting invalid memory locations is bad.\n \n-I think you'd implement `transform` like this:\n+As one last example of a big problem with pointers, **aliasing** can be an\n+issue. Two pointers are said to alias when they point at the same location\n+in memory. Like this:\n \n-~~~rust\n-# struct Point {\n-#     x: int,\n-#     y: int,\n-# }\n-# let p0 = Point { x: 5, y: 10};\n-fn transform(p: &Point) -> Point {\n-    Point { x: p.x + 1, y: p.y + 1}\n+```{notrust,ignore}\n+fn mutate(&int i, int j) {\n+    *i = j;\n }\n \n-// and change this:\n-let p1 = transform(&p0);\n-~~~\n+fn main() {\n+  x = 5;\n+  y = &x;\n+  z = &x; //y and z are aliased\n \n-This does work, but you don't need to create those references! The better way to write this is simply:\n \n-~~~rust\n-#[deriving(Show)]\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n+  run_in_new_thread(mutate, y, 1);\n+  run_in_new_thread(mutate, z, 100);\n \n-fn transform(p: Point) -> Point {\n-    Point { x: p.x + 1, y: p.y + 1}\n+  // what is the value of x here?\n }\n+```\n \n-fn main() {\n-    let p0 = Point { x: 5, y: 10};\n-    let p1 = transform(p0);\n-    println!(\"{}\", p1);\n-}\n-~~~\n+In this made-up example, `run_in_new_thread` spins up a new thread, and calls\n+the given function name with its arguments. Since we have two threads, and\n+they're both operating on aliases to `x`, we can't tell which one finishes\n+first, and therefore, the value of `x` is actually non-deterministic. Worse,\n+what if one of them had invalidated the memory location they pointed to? We'd\n+have the same problem as before, where we'd be setting an invalid location.\n \n-But won't this be inefficient? Well, that's a complicated question, but it's\n-important to know that Rust, like C and C++, store aggregate data types\n-'unboxed,' whereas languages like Java and Ruby store these types as 'boxed.'\n-For smaller structs, this way will be more efficient. For larger ones, it may\n-be less so. But don't reach for that pointer until you must! Make sure that the\n-struct is large enough by performing some tests before you add in the\n-complexity of pointers.\n+## Conclusion\n \n-# Owned Pointers\n+That's a basic overview of pointers as a general concept. As we alluded to\n+before, Rust has different kinds of pointers, rather than just one, and\n+mitigates all of the problems that we talked about, too. This does mean that\n+Rust pointers are slightly more complicated than in other languages, but\n+it's worth it to not have the problems that simple pointers have.\n \n-Owned pointers are the conceptually simplest kind of pointer in Rust. A rough\n-approximation of owned pointers follows:\n+# References\n \n-1. Only one owned pointer may exist to a particular place in memory. It may be\n-borrowed from that owner, however.\n+The most basic type of pointer that Rust has is called a 'reference.' Rust\n+references look like this:\n \n-2. The Rust compiler uses static analysis to determine where the pointer is in\n-scope, and handles allocating and de-allocating that memory. Owned pointers are\n-not garbage collected.\n+```{rust}\n+let x = 5i;\n+let y = &x;\n \n-These two properties make for three use cases.\n+println!(\"{}\", *y);\n+println!(\"{:p}\", y);\n+println!(\"{}\", y);\n+```\n \n-## References to Traits\n+We'd say \"`y` is a reference to `x`.\" The first `println!` prints out the\n+value of `y`'s referent by using the dereference operator, `*`. The second\n+one prints out the memory location that `y` points to, by using the pointer\n+format string. The third `println!` *also* prints out the value of `y`'s\n+referent, because `println!` will automatically dereference it for us.\n \n-Traits must be referenced through a pointer, because the struct that implements\n-the trait may be a different size than a different struct that implements the\n-trait. Therefore, unboxed traits don't make any sense, and aren't allowed.\n+Here's a function that takes a reference:\n \n-## Recursive Data Structures\n+```{rust}\n+fn succ(x: &int) -> int { *x + 1 }\n+```\n \n-Sometimes, you need a recursive data structure. The simplest is known as a 'cons list':\n+You can also use `&` as an operator to create a reference, so we can\n+call this function in two different ways:\n \n-~~~rust\n-#[deriving(Show)]\n-enum List<T> {\n-    Nil,\n-    Cons(T, Box<List<T>>),\n-}\n+```{rust}\n+fn succ(x: &int) -> int { *x + 1 }\n \n fn main() {\n-    let list: List<int> = Cons(1, box Cons(2, box Cons(3, box Nil)));\n-    println!(\"{}\", list);\n-}\n-~~~\n-\n-This prints:\n-\n-~~~text\n-Cons(1, box Cons(2, box Cons(3, box Nil)))\n-~~~\n \n-The inner lists _must_ be an owned pointer, because we can't know how many\n-elements are in the list. Without knowing the length, we don't know the size,\n-and therefore require the indirection that pointers offer.\n+    let x = 5i;\n+    let y = &x;\n \n-## Efficiency\n-\n-This should almost never be a concern, but because creating an owned pointer\n-boxes its value, it therefore makes referring to the value the size of the box.\n-This may make passing an owned pointer to a function less expensive than\n-passing the value itself. Don't worry yourself with this case until you've\n-proved that it's an issue through benchmarks.\n-\n-For example, this will work:\n-\n-~~~rust\n-struct Point {\n-    x: int,\n-    y: int,\n+    println!(\"{}\", succ(y));\n+    println!(\"{}\", succ(&x));\n }\n+```\n \n-fn main() {\n-    let a = Point { x: 10, y: 20 };\n-    spawn(proc() {\n-        println!(\"{}\", a.x);\n-    });\n-}\n-~~~\n+Both of these `println!`s will print out `6`.\n \n-This struct is tiny, so it's fine. If `Point` were large, this would be more\n-efficient:\n+Of course, if this were real code, we wouldn't bother with the reference, and\n+just write:\n \n-~~~rust\n-struct Point {\n-    x: int,\n-    y: int,\n-}\n+```{rust}\n+fn succ(x: int) -> int { x + 1 }\n+```\n \n-fn main() {\n-    let a = box Point { x: 10, y: 20 };\n-    spawn(proc() {\n-        println!(\"{}\", a.x);\n-    });\n-}\n-~~~\n+References are immutable by default:\n \n-Now it'll be copying a pointer-sized chunk of memory rather than the whole\n-struct.\n+```{rust,ignore}\n+let x = 5i;\n+let y = &x;\n \n-# References\n+*y = 5; // error: cannot assign to immutable dereference of `&`-pointer `*y`\n+```\n \n-References are the third major kind of pointer Rust supports. They are\n-simultaneously the simplest and the most complicated kind. Let me explain:\n-references are considered 'borrowed' because they claim no ownership over the\n-data they're pointing to. They're just borrowing it for a while. So in that\n-sense, they're simple: just keep whatever ownership the data already has. For\n-example:\n-\n-~~~rust\n-struct Point {\n-    x: f32,\n-    y: f32,\n-}\n+They can be made mutable with `mut`, but only if its referent is also mutable.\n+This works:\n \n-fn compute_distance(p1: &Point, p2: &Point) -> f32 {\n-    let x_d = p1.x - p2.x;\n-    let y_d = p1.y - p2.y;\n+```{rust}\n+let mut x = 5i;\n+let y = &mut x;\n+```\n \n-    (x_d * x_d + y_d * y_d).sqrt()\n-}\n+This does not:\n \n-fn main() {\n-    let origin =    &Point { x: 0.0, y: 0.0 };\n-    let p1     = box Point { x: 5.0, y: 3.0 };\n+```{rust,ignore}\n+let x = 5i;\n+let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable\n+```\n \n-    println!(\"{}\", compute_distance(origin, &*p1));\n-}\n-~~~\n+Immutable pointers are allowed to alias:\n \n-This prints `5.83095189`. You can see that the `compute_distance` function\n-takes in two references, a reference to a value on the stack, and a reference\n-to a value in a box.\n-Of course, if this were a real program, we wouldn't have any of these pointers,\n-they're just there to demonstrate the concepts.\n+```{rust}\n+let x = 5i;\n+let y = &x;\n+let z = &x;\n+```\n \n-So how is this hard? Well, because we're ignoring ownership, the compiler needs\n-to take great care to make sure that everything is safe. Despite their complete\n-safety, a reference's representation at runtime is the same as that of\n-an ordinary pointer in a C program. They introduce zero overhead. The compiler\n-does all safety checks at compile time.\n+Mutable ones, however, are not:\n \n-This theory is called 'region pointers' and you can read more about it\n-[here](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n-Region pointers evolved into what we know today as 'lifetimes'.\n+```{rust,ignore}\n+let x = 5i;\n+let y = &mut x;\n+let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time\n+```\n+\n+Despite their complete safety, a reference's representation at runtime is the\n+same as that of an ordinary pointer in a C program. They introduce zero\n+overhead. The compiler does all safety checks at compile time. The theory that\n+allows for this was originally called **region pointers**. Region pointers\n+evolved into what we know today as **lifetimes**.\n \n Here's the simple explanation: would you expect this code to compile?\n \n-~~~rust{.ignore}\n+```{rust,ignore}\n fn main() {\n     println!(\"{}\", x);\n     let x = 5;\n }\n-~~~\n+```\n \n Probably not. That's because you know that the name `x` is valid from where\n it's declared to when it goes out of scope. In this case, that's the end of\n the `main` function. So you know this code will cause an error. We call this\n duration a 'lifetime'. Let's try a more complex example:\n \n-~~~rust\n+```{rust}\n fn main() {\n-    let mut x = box 5i;\n+    let x = &mut 5i;\n+\n     if *x < 10 {\n         let y = &x;\n+\n         println!(\"Oh no: {}\", y);\n         return;\n     }\n+\n     *x -= 1;\n+\n     println!(\"Oh no: {}\", x);\n }\n-~~~\n+```\n \n Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however,\n is able to determine that that pointer will go out of scope without `x` being\n mutated, and therefore, lets us pass. This wouldn't work:\n \n-~~~rust{.ignore}\n+```{rust,ignore}\n fn main() {\n-    let mut x = box 5i;\n+    let x = &mut 5i;\n+\n     if *x < 10 {\n         let y = &x;\n         *x -= 1;\n \n         println!(\"Oh no: {}\", y);\n         return;\n     }\n+\n     *x -= 1;\n+\n     println!(\"Oh no: {}\", x);\n }\n-~~~\n+```\n \n It gives this error:\n \n-~~~text\n+```{notrust,ignore}\n test.rs:5:8: 5:10 error: cannot assign to `*x` because it is borrowed\n test.rs:5         *x -= 1;\n                   ^~\n test.rs:4:16: 4:18 note: borrow of `*x` occurs here\n test.rs:4         let y = &x;\n                           ^~\n-~~~\n+```\n \n As you might guess, this kind of analysis is complex for a human, and therefore\n hard for a computer, too! There is an entire [guide devoted to references\n and lifetimes](guide-lifetimes.html) that goes into lifetimes in\n great detail, so if you want the full details, check that out.\n \n+## Best practices\n+\n+In general, prefer stack allocation over heap allocation. Using references to\n+stack allocated information is preferred whenever possible. Therefore,\n+references are the default pointer type you should use, unless you have\n+specific reason to use a different type. The other types of pointers cover when\n+they're appropriate to use in their own best practices sections.\n+\n+Use references when you want to use a pointer, but do not want to take ownership.\n+References just borrow ownership, which is more polite if you don't need the\n+ownership. In other words, prefer:\n+\n+```{rust}\n+fn succ(x: &int) -> int { *x + 1 }\n+```\n+\n+to\n+\n+```{rust}\n+fn succ(x: Box<int>) -> int { *x + 1 }\n+```\n+\n+As a corollary to that rule, references allow you to accept a wide variety of\n+other pointers, and so are useful so that you don't have to write a number\n+of variants per pointer. In other words, prefer:\n+\n+```{rust}\n+fn succ(x: &int) -> int { *x + 1 }\n+```\n+\n+to\n+\n+```{rust}\n+fn box_succ(x: Box<int>) -> int { *x + 1 }\n+\n+fn rc_succ(x: std::rc::Rc<int>) -> int { *x + 1 }\n+```\n+\n+# Boxes\n+\n+`Box<T>` is Rust's 'boxed pointer' type. Boxes provide the simplest form of\n+heap allocation in Rust. Creating a box looks like this:\n+\n+```{rust}\n+let x = box(std::boxed::HEAP) 5i;\n+```\n+\n+`box` is a keyword that does 'placement new,' which we'll talk about in a bit.\n+`box` will be useful for creating a number of heap-allocated types, but is not\n+quite finished yet. In the meantime, `box`'s type defaults to\n+`std::boxed::HEAP`, and so you can leave it off:\n+\n+```{rust}\n+let x = box 5i;\n+```\n+\n+As you might assume from the `HEAP`, boxes are heap allocated. They are\n+deallocated automatically by Rust when they go out of scope:\n+\n+```{rust}\n+{\n+    let x = box 5i;\n+\n+    // stuff happens\n+\n+} // x is destructed and its memory is free'd here\n+```\n+\n+However, boxes do _not_ use reference counting or garbage collection. Boxes are\n+what's called an **affine type**. This means that the Rust compiler, at compile\n+time, determines when the box comes into and goes out of scope, and inserts the\n+appropriate calls there. Furthermore, boxes are a specific kind of affine type,\n+known as a **region**. You can read more about regions [in this paper on the\n+Cyclone programming\n+language](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf).\n+\n+You don't need to fully grok the theory of affine types or regions to grok\n+boxes, though. As a rough approximation, you can treat this Rust code:\n+\n+```{rust}\n+{\n+    let x = box 5i;\n+\n+    // stuff happens\n+}\n+```\n+\n+As being similar to this C code:\n+\n+```{notrust,ignore}\n+{\n+    int *x;\n+    x = (int *)malloc(sizeof(int));\n+\n+    // stuff happens\n+\n+    free(x);\n+}\n+```\n+\n+Of course, this is a 10,000 foot view. It leaves out destructors, for example.\n+But the general idea is correct: you get the semantics of `malloc`/`free`, but\n+with some improvements:\n+\n+1. It's impossible to allocate the incorrect amount of memory, because Rust\n+   figures it out from the types.\n+2. You cannot forget to `free` memory you've allocated, because Rust does it\n+   for you.\n+3. Rust ensures that this `free` happens at the right time, when it is truly\n+   not used. Use-after-free is not possible.\n+4. Rust enforces that no other writeable pointers alias to this heap memory,\n+   which means writing to an invalid pointer is not possible.\n+\n+See the section on references or the [lifetimes guide](guide-lifetimes.html)\n+for more detail on how lifetimes work.\n+\n+Using boxes and references together is very common. For example:\n+\n+```{rust}\n+fn add_one(x: &int) -> int {\n+    *x + 1\n+}\n+\n+fn main() {\n+    let x = box 5i;\n+\n+    println!(\"{}\", add_one(&*x));\n+}\n+```\n+\n+In this case, Rust knows that `x` is being 'borrowed' by the `add_one()`\n+function, and since it's only reading the value, allows it.\n+\n+We can borrow `x` multiple times, as long as it's not simultaneous:\n+\n+```{rust}\n+fn add_one(x: &int) -> int {\n+    *x + 1\n+}\n+\n+fn main() {\n+    let x = box 5i;\n+\n+    println!(\"{}\", add_one(&*x));\n+    println!(\"{}\", add_one(&*x));\n+    println!(\"{}\", add_one(&*x));\n+}\n+```\n+\n+Or as long as it's not a mutable borrow. This will error:\n+\n+```{rust,ignore}\n+fn add_one(x: &mut int) -> int {\n+    *x + 1\n+}\n+\n+fn main() {\n+    let x = box 5i;\n+\n+    println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference \n+                                  // of `&`-pointer as mutable\n+}\n+```\n+\n+Notice we changed the signature of `add_one()` to request a mutable reference.\n+\n+# Best practices\n+\n+Boxes are appropriate to use in two situations: Recursive data structures,\n+and occasionally, when returning data.\n+\n+## Recursive data structures\n+\n+Sometimes, you need a recursive data structure. The simplest is known as a\n+'cons list':\n+\n+\n+```{rust}\n+#[deriving(Show)]\n+enum List<T> {\n+    Cons(T, Box<List<T>>),\n+    Nil,\n+}\n+\n+fn main() {\n+    let list: List<int> = Cons(1, box Cons(2, box Cons(3, box Nil)));\n+    println!(\"{}\", list);\n+}\n+```\n+\n+This prints:\n+\n+```{notrust,ignore}\n+Cons(1, box Cons(2, box Cons(3, box Nil)))\n+```\n+\n+The reference to another `List` inside of the `Cons` enum variant must be a box,\n+because we don't know the length of the list. Because we don't know the length,\n+we don't know the size, and therefore, we need to heap allocate our list.\n+\n+Working with recursive or other unknown-sized data structures is the primary\n+use-case for boxes.\n+\n+## Returning data\n+\n+This is important enough to have its own section entirely. The TL;DR is this:\n+you don't generally want to return pointers, even when you might in a language\n+like C or C++.\n+\n+See [Returning Pointers](#returning-pointers) below for more.\n+\n+# Rc and Arc\n+\n+This part is coming soon.\n+\n+## Best practices\n+\n+This part is coming soon.\n+\n+# Gc\n+\n+The `Gc<T>` type exists for historical reasons, and is [still used\n+internally](https://github.com/rust-lang/rust/issues/7929) by the compiler.\n+It is not even a 'real' garbage collected type at the moment.\n+\n+In the future, Rust may have a real garbage collected type, and so it\n+has not yet been removed for that reason.\n+\n+## Best practices\n+\n+There is currently no legitimate use case for the `Gc<T>` type.\n+\n+# Raw Pointers\n+\n+This part is coming soon.\n+\n+## Best practices\n+\n+This part is coming soon.\n+\n # Returning Pointers\n \n-We've talked a lot about functions that accept various kinds of pointers, but\n-what about returning them? In general, it is better to let the caller decide\n-how to use a function's output, instead of assuming a certain type of pointer\n-is best.\n+In many languages with pointers, you'd return a pointer from a function\n+so as to avoid a copying a large data structure. For example:\n \n-What does that mean? Don't do this:\n+```{rust}\n+struct BigStruct {\n+    one: int,\n+    two: int,\n+    // etc\n+    one_hundred: int,\n+}\n \n-~~~rust\n-fn foo(x: Box<int>) -> Box<int> {\n+fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n     return box *x;\n }\n \n fn main() {\n-    let x = box 5;\n+    let x = box BigStruct {\n+        one: 1,\n+        two: 2,\n+        one_hundred: 100,\n+    };\n+\n     let y = foo(x);\n }\n-~~~\n+```\n+\n+The idea is that by passing around a box, you're only copying a pointer, rather\n+than the hundred `int`s that make up the `BigStruct`.\n \n-Do this:\n+This is an antipattern in Rust. Instead, write this:\n \n-~~~rust\n-fn foo(x: Box<int>) -> int {\n+```{rust}\n+struct BigStruct {\n+    one: int,\n+    two: int,\n+    // etc\n+    one_hundred: int,\n+}\n+\n+fn foo(x: Box<BigStruct>) -> BigStruct {\n     return *x;\n }\n \n fn main() {\n-    let x = box 5;\n+    let x = box BigStruct {\n+        one: 1,\n+        two: 2,\n+        one_hundred: 100,\n+    };\n+\n     let y = box foo(x);\n }\n-~~~\n+```\n \n-This gives you flexibility, without sacrificing performance.\n+This gives you flexibility without sacrificing performance.\n \n You may think that this gives us terrible performance: return a value and then\n immediately box it up ?! Isn't that the worst of both worlds? Rust is smarter\n-than that. There is no copy in this code. `main` allocates enough room for the\n-`box int`, passes a pointer to that memory into `foo` as `x`, and then `foo` writes\n-the value straight into that pointer. This writes the return value directly into\n+than that. There is no copy in this code. main allocates enough room for the\n+`box , passes a pointer to that memory into foo as x, and then foo writes the\n+value straight into that pointer. This writes the return value directly into\n the allocated box.\n \n-This is important enough that it bears repeating: pointers are not for optimizing\n-returning values from your code. Allow the caller to choose how they want to\n-use your output.\n+This is important enough that it bears repeating: pointers are not for\n+optimizing returning values from your code. Allow the caller to choose how they\n+want to use your output.\n+\n+# Creating your own Pointers\n+\n+This part is coming soon.\n+\n+## Best practices\n+\n+This part is coming soon.\n+\n+# Cheat Sheet\n+\n+Here's a quick rundown of Rust's pointer types:\n+\n+| Type         | Name                | Summary                                   |\n+|--------------|---------------------|-------------------------------------------|\n+| `&T`         | Reference           | Allows one or more references to read `T` |\n+| `&mut T`     | Mutable Reference   | Allows a single reference to              |\n+|              |                     | read and write `T`                        |\n+| `Box<T>`     | Box                 | Heap allocated `T` with a single owner    |\n+|              |                     | that may read and write `T`.              |\n+| `Rc<T>`      | \"arr cee\" pointer   | Heap allocated `T` with many readers      |\n+| `Arc<T>`     | Arc pointer         | Same as above, but safe sharing across    |\n+|              |                     | threads                                   |\n+| `*const T`   | Raw pointer         | Unsafe read access to `T`                 |\n+| `*mut T`     | Mutable raw pointer | Unsafe read and write access to `T`       |\n \n-# Related Resources\n+# Related resources\n \n+* [API documentation for Box](std/boxed/index.html)\n * [Lifetimes guide](guide-lifetimes.html)\n+* [Cyclone paper on regions](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), which inspired Rust's lifetime system"}]}