{"sha": "8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZDA4ZGRkOTJmNDlkYWFiMWE0ZDYwYTQyZmM3NjgyZmQ0ZDI3NzA=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-03-28T14:49:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-28T14:49:25Z"}, "message": "Merge pull request #2562 from topecongiro/issue-2196\n\nCombine simple heuristics for function calls and array", "tree": {"sha": "1ef3c185f283b2bb14dcc9b75f993d98b4199cfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ef3c185f283b2bb14dcc9b75f993d98b4199cfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJau6t1CRBK7hj4Ov3rIwAAdHIIACVGJ+M8RKsfGJXs/3PMHU0c\n/ZnnLlhPfNZSgu0fI7HnZKQqkaqLZxa+IlA+/EiPggnDA27Z4i+RM5luSIvG3M1X\n8iVoUfy3WLNyEhJ37M0q+U8Q7o42laf7EqK5YIzl+vKsm+EZLh1/TKNKibwVRk1V\nKg/Gks2Ph66RzrFn88fiTKNI79jxxQN7EEGN7+FV9LYy4MBtOdwVXAgwwxspqS4V\nXd/+IyuQ02y33Fz1LhsHghP+zUDYU6HwTjGSlneBYhJNR28+VhKj2+A6V0oxCVJP\nIsCIbq+LO36wcOIJsgyvpmXq8vOW1GbMWmUvMpch9wsEiT762qry9uaH/b9O2wM=\n=+xuw\n-----END PGP SIGNATURE-----\n", "payload": "tree 1ef3c185f283b2bb14dcc9b75f993d98b4199cfd\nparent 0f55350c7d7658cc0701b1b8b83ab7d72591bc43\nparent 48424ea7654bbf1a0b3d747be05b45f799c7e28d\nauthor Nick Cameron <nrc@ncameron.org> 1522248565 +0200\ncommitter GitHub <noreply@github.com> 1522248565 +0200\n\nMerge pull request #2562 from topecongiro/issue-2196\n\nCombine simple heuristics for function calls and array "}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "html_url": "https://github.com/rust-lang/rust/commit/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f55350c7d7658cc0701b1b8b83ab7d72591bc43", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f55350c7d7658cc0701b1b8b83ab7d72591bc43", "html_url": "https://github.com/rust-lang/rust/commit/0f55350c7d7658cc0701b1b8b83ab7d72591bc43"}, {"sha": "48424ea7654bbf1a0b3d747be05b45f799c7e28d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48424ea7654bbf1a0b3d747be05b45f799c7e28d", "html_url": "https://github.com/rust-lang/rust/commit/48424ea7654bbf1a0b3d747be05b45f799c7e28d"}], "stats": {"total": 482, "additions": 189, "deletions": 293}, "files": [{"sha": "13c7acaed4f141f3266b9167710fa7d7d1263189", "filename": "Configurations.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -1688,7 +1688,8 @@ Number of spaces per tab\n fn lorem() {\n     let ipsum = dolor();\n     let sit = vec![\n-        \"amet consectetur adipiscing elit amet consectetur adipiscing elit amet consectetur.\",\n+        \"amet consectetur adipiscing elit amet\",\n+        \"consectetur adipiscing elit amet consectetur.\",\n     ];\n }\n ```\n@@ -1699,7 +1700,8 @@ fn lorem() {\n fn lorem() {\n   let ipsum = dolor();\n   let sit = vec![\n-    \"amet consectetur adipiscing elit amet consectetur adipiscing elit amet consectetur.\",\n+    \"amet consectetur adipiscing elit amet\",\n+    \"consectetur adipiscing elit amet consectetur.\",\n   ];\n }\n ```"}, {"sha": "20ba0118f5f35d96a62522bba51d0c359892d034", "filename": "src/closures.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -127,13 +127,11 @@ fn rewrite_closure_with_block(\n     }\n \n     let block = ast::Block {\n-        stmts: vec![\n-            ast::Stmt {\n-                id: ast::NodeId::new(0),\n-                node: ast::StmtKind::Expr(ptr::P(body.clone())),\n-                span: body.span,\n-            },\n-        ],\n+        stmts: vec![ast::Stmt {\n+            id: ast::NodeId::new(0),\n+            node: ast::StmtKind::Expr(ptr::P(body.clone())),\n+            span: body.span,\n+        }],\n         id: ast::NodeId::new(0),\n         rules: ast::BlockCheckMode::Default,\n         span: body.span,\n@@ -300,13 +298,7 @@ pub fn rewrite_last_closure(\n             _ => body,\n         };\n         let (prefix, extra_offset) = rewrite_closure_fn_decl(\n-            capture,\n-            movability,\n-            fn_decl,\n-            body,\n-            expr.span,\n-            context,\n-            shape,\n+            capture, movability, fn_decl, body, expr.span, context, shape,\n         )?;\n         // If the closure goes multi line before its body, do not overflow the closure.\n         if prefix.contains('\\n') {"}, {"sha": "14ba8d0f7a0878c7e301a6bf579c3139b59351eb", "filename": "src/expr.rs", "status": "modified", "additions": 19, "deletions": 149, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -13,6 +13,7 @@ use std::cmp::min;\n \n use config::lists::*;\n use syntax::codemap::{BytePos, CodeMap, Span};\n+use syntax::parse::token::DelimToken;\n use syntax::{ast, ptr};\n \n use chains::rewrite_chain;\n@@ -64,14 +65,13 @@ pub fn format_expr(\n \n     let expr_rw = match expr.node {\n         ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n+            \"\",\n             &ptr_vec_to_ref_vec(expr_vec),\n-            mk_sp(\n-                context.snippet_provider.span_after(expr.span, \"[\"),\n-                expr.span.hi(),\n-            ),\n+            expr.span,\n             context,\n             shape,\n-            false,\n+            None,\n+            None,\n         ),\n         ast::ExprKind::Lit(ref l) => rewrite_literal(context, l, shape),\n         ast::ExprKind::Call(ref callee, ref args) => {\n@@ -173,13 +173,7 @@ pub fn format_expr(\n         },\n         ast::ExprKind::Closure(capture, movability, ref fn_decl, ref body, _) => {\n             closures::rewrite_closure(\n-                capture,\n-                movability,\n-                fn_decl,\n-                body,\n-                expr.span,\n-                context,\n-                shape,\n+                capture, movability, fn_decl, body, expr.span, context, shape,\n             )\n         }\n         ast::ExprKind::Try(..)\n@@ -422,147 +416,23 @@ where\n }\n \n pub fn rewrite_array<T: Rewrite + Spanned + ToExpr>(\n+    name: &str,\n     exprs: &[&T],\n     span: Span,\n     context: &RewriteContext,\n     shape: Shape,\n-    trailing_comma: bool,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+    delim_token: Option<DelimToken>,\n ) -> Option<String> {\n-    let bracket_size = if context.config.spaces_within_parens_and_brackets() {\n-        2 // \"[ \"\n-    } else {\n-        1 // \"[\"\n-    };\n-\n-    let nested_shape = match context.config.indent_style() {\n-        IndentStyle::Block => shape\n-            .block()\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config)\n-            .sub_width(1)?,\n-        IndentStyle::Visual => shape\n-            .visual_indent(bracket_size)\n-            .sub_width(bracket_size * 2)?,\n-    };\n-\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        exprs.iter(),\n-        \"]\",\n-        \",\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| item.rewrite(context, nested_shape),\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    ).collect::<Vec<_>>();\n-\n-    if items.is_empty() {\n-        if context.config.spaces_within_parens_and_brackets() {\n-            return Some(\"[ ]\".to_string());\n-        } else {\n-            return Some(\"[]\".to_string());\n-        }\n-    }\n-\n-    let tactic = array_tactic(context, shape, nested_shape, exprs, &items, bracket_size);\n-    let ends_with_newline = tactic.ends_with_newline(context.config.indent_style());\n-\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro() && !exprs.is_empty() {\n-            let ends_with_bracket = context.snippet(span).ends_with(']');\n-            let bracket_offset = if ends_with_bracket { 1 } else { 0 };\n-            let snippet = context.snippet(mk_sp(span.lo(), span.hi() - BytePos(bracket_offset)));\n-            let last_char_index = snippet.rfind(|c: char| !c.is_whitespace())?;\n-            if &snippet[last_char_index..last_char_index + 1] == \",\" {\n-                SeparatorTactic::Always\n-            } else {\n-                SeparatorTactic::Never\n-            }\n-        } else if context.config.indent_style() == IndentStyle::Visual {\n-            SeparatorTactic::Never\n-        } else {\n-            SeparatorTactic::Vertical\n-        },\n-        separator_place: SeparatorPlace::Back,\n-        shape: nested_shape,\n-        ends_with_newline,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-    let list_str = write_list(&items, &fmt)?;\n-\n-    let result = if context.config.indent_style() == IndentStyle::Visual\n-        || tactic == DefinitiveListTactic::Horizontal\n-    {\n-        if context.config.spaces_within_parens_and_brackets() && !list_str.is_empty() {\n-            format!(\"[ {} ]\", list_str)\n-        } else {\n-            format!(\"[{}]\", list_str)\n-        }\n-    } else {\n-        format!(\n-            \"[{}{}{}]\",\n-            nested_shape.indent.to_string_with_newline(context.config),\n-            list_str,\n-            shape.block().indent.to_string_with_newline(context.config)\n-        )\n-    };\n-\n-    Some(result)\n-}\n-\n-fn array_tactic<T: Rewrite + Spanned + ToExpr>(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    nested_shape: Shape,\n-    exprs: &[&T],\n-    items: &[ListItem],\n-    bracket_size: usize,\n-) -> DefinitiveListTactic {\n-    let has_long_item = items\n-        .iter()\n-        .any(|li| li.item.as_ref().map(|s| s.len() > 10).unwrap_or(false));\n-\n-    match context.config.indent_style() {\n-        IndentStyle::Block => {\n-            let tactic = match shape.width.checked_sub(2 * bracket_size) {\n-                Some(width) => {\n-                    let tactic = ListTactic::LimitedHorizontalVertical(\n-                        context.config.width_heuristics().array_width,\n-                    );\n-                    definitive_tactic(items, tactic, Separator::Comma, width)\n-                }\n-                None => DefinitiveListTactic::Vertical,\n-            };\n-            if tactic == DefinitiveListTactic::Vertical && !has_long_item\n-                && is_every_expr_simple(exprs)\n-            {\n-                DefinitiveListTactic::Mixed\n-            } else {\n-                tactic\n-            }\n-        }\n-        IndentStyle::Visual => {\n-            if has_long_item || items.iter().any(ListItem::is_multiline) {\n-                definitive_tactic(\n-                    items,\n-                    ListTactic::LimitedHorizontalVertical(\n-                        context.config.width_heuristics().array_width,\n-                    ),\n-                    Separator::Comma,\n-                    nested_shape.width,\n-                )\n-            } else {\n-                DefinitiveListTactic::Mixed\n-            }\n-        }\n-    }\n+    overflow::rewrite_with_square_brackets(\n+        context,\n+        name,\n+        exprs,\n+        shape,\n+        span,\n+        force_separator_tactic,\n+        delim_token,\n+    )\n }\n \n fn rewrite_empty_block(\n@@ -1489,7 +1359,7 @@ fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+pub fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n     lists\n         .iter()\n         .all(|arg| arg.to_expr().map_or(false, is_simple_expr))"}, {"sha": "402f7ab507ab7148df6adb6ceded5bd805c27857", "filename": "src/format-diff/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fformat-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fformat-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat-diff%2Fmain.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -261,7 +261,7 @@ fn scan_simple_git_diff() {\n             Range {\n                 file: \"src/ir/traversal.rs\".to_owned(),\n                 range: [35, 43],\n-            }\n+            },\n         ]\n     );\n }"}, {"sha": "05b1a7ce2963be91e8575f935ecf49fb3b741877", "filename": "src/lists.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -101,7 +101,7 @@ impl ListItem {\n                 .map_or(false, |s| s.contains('\\n'))\n     }\n \n-    pub fn has_comment(&self) -> bool {\n+    pub fn has_single_line_comment(&self) -> bool {\n         self.pre_comment\n             .as_ref()\n             .map_or(false, |comment| comment.trim_left().starts_with(\"//\"))\n@@ -110,6 +110,10 @@ impl ListItem {\n                 .map_or(false, |comment| comment.trim_left().starts_with(\"//\"))\n     }\n \n+    pub fn has_comment(&self) -> bool {\n+        self.pre_comment.is_some() || self.post_comment.is_some()\n+    }\n+\n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n         ListItem {\n             pre_comment: None,\n@@ -164,7 +168,7 @@ where\n     let pre_line_comments = items\n         .clone()\n         .into_iter()\n-        .any(|item| item.as_ref().has_comment());\n+        .any(|item| item.as_ref().has_single_line_comment());\n \n     let limit = match tactic {\n         _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n@@ -266,11 +270,15 @@ where\n                     result.push_str(indent_str);\n                     line_len = 0;\n                     if formatting.ends_with_newline {\n-                        if last {\n-                            separate = true;\n-                        } else {\n-                            trailing_separator = true;\n-                        }\n+                        trailing_separator = true;\n+                    }\n+                }\n+\n+                if last && formatting.ends_with_newline {\n+                    match formatting.trailing_separator {\n+                        SeparatorTactic::Always => separate = true,\n+                        SeparatorTactic::Vertical if result.contains('\\n') => separate = true,\n+                        _ => (),\n                     }\n                 }\n "}, {"sha": "3ad801c5feab282db012a9fa80258eb831db23e1", "filename": "src/macros.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -45,14 +45,6 @@ use utils::{format_visibility, mk_sp, wrap_str};\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n \n-// FIXME: use the enum from libsyntax?\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-enum MacroStyle {\n-    Parens,\n-    Brackets,\n-    Braces,\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum MacroPosition {\n     Item,\n@@ -61,16 +53,6 @@ pub enum MacroPosition {\n     Pat,\n }\n \n-impl MacroStyle {\n-    fn opener(&self) -> &'static str {\n-        match *self {\n-            MacroStyle::Parens => \"(\",\n-            MacroStyle::Brackets => \"[\",\n-            MacroStyle::Braces => \"{\",\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub enum MacroArg {\n     Expr(ptr::P<ast::Expr>),\n@@ -177,7 +159,7 @@ pub fn rewrite_macro_inner(\n     let macro_name = rewrite_macro_name(&mac.node.path, extra_ident);\n \n     let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {\n-        MacroStyle::Brackets\n+        DelimToken::Bracket\n     } else {\n         original_style\n     };\n@@ -186,12 +168,13 @@ pub fn rewrite_macro_inner(\n     let has_comment = contains_comment(context.snippet(mac.span));\n     if ts.is_empty() && !has_comment {\n         return match style {\n-            MacroStyle::Parens if position == MacroPosition::Item => {\n+            DelimToken::Paren if position == MacroPosition::Item => {\n                 Some(format!(\"{}();\", macro_name))\n             }\n-            MacroStyle::Parens => Some(format!(\"{}()\", macro_name)),\n-            MacroStyle::Brackets => Some(format!(\"{}[]\", macro_name)),\n-            MacroStyle::Braces => Some(format!(\"{}{{}}\", macro_name)),\n+            DelimToken::Paren => Some(format!(\"{}()\", macro_name)),\n+            DelimToken::Bracket => Some(format!(\"{}[]\", macro_name)),\n+            DelimToken::Brace => Some(format!(\"{}{{}}\", macro_name)),\n+            _ => unreachable!(),\n         };\n     }\n     // Format well-known macros which cannot be parsed as a valid AST.\n@@ -207,7 +190,7 @@ pub fn rewrite_macro_inner(\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n \n-    if MacroStyle::Braces != style {\n+    if DelimToken::Brace != style {\n         loop {\n             match parse_macro_arg(&mut parser) {\n                 Some(arg) => arg_vec.push(arg),\n@@ -250,7 +233,7 @@ pub fn rewrite_macro_inner(\n     }\n \n     match style {\n-        MacroStyle::Parens => {\n+        DelimToken::Paren => {\n             // Format macro invocation as function call, preserve the trailing\n             // comma because not all macros support them.\n             overflow::rewrite_with_parens(\n@@ -270,10 +253,10 @@ pub fn rewrite_macro_inner(\n                 _ => rw,\n             })\n         }\n-        MacroStyle::Brackets => {\n-            let mac_shape = shape.offset_left(macro_name.len())?;\n+        DelimToken::Bracket => {\n             // Handle special case: `vec![expr; expr]`\n             if vec_with_semi {\n+                let mac_shape = shape.offset_left(macro_name.len())?;\n                 let (lbr, rbr) = if context.config.spaces_within_parens_and_brackets() {\n                     (\"[ \", \" ]\")\n                 } else {\n@@ -305,31 +288,42 @@ pub fn rewrite_macro_inner(\n                 // If we are rewriting `vec!` macro or other special macros,\n                 // then we can rewrite this as an usual array literal.\n                 // Otherwise, we must preserve the original existence of trailing comma.\n-                if FORCED_BRACKET_MACROS.contains(&macro_name.as_str()) {\n+                let macro_name = &macro_name.as_str();\n+                let mut force_trailing_comma = if trailing_comma {\n+                    Some(SeparatorTactic::Always)\n+                } else {\n+                    Some(SeparatorTactic::Never)\n+                };\n+                if FORCED_BRACKET_MACROS.contains(macro_name) {\n                     context.inside_macro.replace(false);\n-                    trailing_comma = false;\n+                    if context.use_block_indent() {\n+                        force_trailing_comma = Some(SeparatorTactic::Vertical);\n+                    };\n                 }\n                 // Convert `MacroArg` into `ast::Expr`, as `rewrite_array` only accepts the latter.\n-                let sp = mk_sp(\n-                    context\n-                        .snippet_provider\n-                        .span_after(mac.span, original_style.opener()),\n-                    mac.span.hi() - BytePos(1),\n-                );\n                 let arg_vec = &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>()[..];\n-                let rewrite = rewrite_array(arg_vec, sp, context, mac_shape, trailing_comma)?;\n+                let rewrite = rewrite_array(\n+                    macro_name,\n+                    arg_vec,\n+                    mac.span,\n+                    context,\n+                    shape,\n+                    force_trailing_comma,\n+                    Some(original_style),\n+                )?;\n                 let comma = match position {\n                     MacroPosition::Item => \";\",\n                     _ => \"\",\n                 };\n \n-                Some(format!(\"{}{}{}\", macro_name, rewrite, comma))\n+                Some(format!(\"{}{}\", rewrite, comma))\n             }\n         }\n-        MacroStyle::Braces => {\n+        DelimToken::Brace => {\n             // Skip macro invocations with braces, for now.\n             indent_macro_snippet(context, context.snippet(mac.span), shape.indent)\n         }\n+        _ => unreachable!(),\n     }\n }\n \n@@ -1010,18 +1004,18 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n     }\n }\n \n-fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n+fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> DelimToken {\n     let snippet = context.snippet(mac.span);\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n     let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n     let brace_pos = snippet.find_uncommented(\"{\").unwrap_or(usize::max_value());\n \n     if paren_pos < bracket_pos && paren_pos < brace_pos {\n-        MacroStyle::Parens\n+        DelimToken::Paren\n     } else if bracket_pos < brace_pos {\n-        MacroStyle::Brackets\n+        DelimToken::Bracket\n     } else {\n-        MacroStyle::Braces\n+        DelimToken::Brace\n     }\n }\n "}, {"sha": "6383d032273bdf4e4bcab637137b8d5ffd9f9417", "filename": "src/overflow.rs", "status": "modified", "additions": 74, "deletions": 18, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -14,10 +14,11 @@\n use config::lists::*;\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::parse::token::DelimToken;\n \n use closures;\n use codemap::SpanUtils;\n-use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n+use expr::{is_every_expr_simple, is_nested_call, maybe_get_args_offset, ToExpr};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n@@ -26,6 +27,8 @@ use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_\n \n use std::cmp::min;\n \n+const SHORT_ITEM_THRESHOLD: usize = 10;\n+\n pub fn rewrite_with_parens<T>(\n     context: &RewriteContext,\n     ident: &str,\n@@ -48,6 +51,7 @@ where\n         \")\",\n         item_max_width,\n         force_separator_tactic,\n+        None,\n     ).rewrite(shape)\n }\n \n@@ -71,6 +75,38 @@ where\n         \">\",\n         context.config.max_width(),\n         None,\n+        None,\n+    ).rewrite(shape)\n+}\n+\n+pub fn rewrite_with_square_brackets<T>(\n+    context: &RewriteContext,\n+    name: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+    delim_token: Option<DelimToken>,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    let (lhs, rhs) = match delim_token {\n+        Some(DelimToken::Paren) => (\"(\", \")\"),\n+        Some(DelimToken::Brace) => (\"{\", \"}\"),\n+        _ => (\"[\", \"]\"),\n+    };\n+    Context::new(\n+        context,\n+        items,\n+        name,\n+        shape,\n+        span,\n+        lhs,\n+        rhs,\n+        context.config.width_heuristics().array_width,\n+        force_separator_tactic,\n+        Some((\"[\", \"]\")),\n     ).rewrite(shape)\n }\n \n@@ -86,6 +122,7 @@ struct Context<'a, T: 'a> {\n     item_max_width: usize,\n     one_line_width: usize,\n     force_separator_tactic: Option<SeparatorTactic>,\n+    custom_delims: Option<(&'a str, &'a str)>,\n }\n \n impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n@@ -99,6 +136,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         suffix: &'static str,\n         item_max_width: usize,\n         force_separator_tactic: Option<SeparatorTactic>,\n+        custom_delims: Option<(&'a str, &'a str)>,\n     ) -> Context<'a, T> {\n         // 2 = `( `, 1 = `(`\n         let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n@@ -135,6 +173,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             item_max_width,\n             one_line_width,\n             force_separator_tactic,\n+            custom_delims,\n         }\n     }\n \n@@ -183,6 +222,15 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n         }\n     }\n \n+    fn default_tactic(&self, list_items: &[ListItem]) -> DefinitiveListTactic {\n+        definitive_tactic(\n+            list_items,\n+            ListTactic::LimitedHorizontalVertical(self.item_max_width),\n+            Separator::Comma,\n+            self.one_line_width,\n+        )\n+    }\n+\n     fn try_overflow_last_item(&self, list_items: &mut Vec<ListItem>) -> DefinitiveListTactic {\n         // 1 = \"(\"\n         let combine_arg_with_callee = self.items.len() == 1 && self.items[0].to_expr().is_some()\n@@ -258,26 +306,16 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                     .last()\n                     .and_then(|last_item| last_item.rewrite(self.context, self.nested_shape));\n \n-                let default_tactic = || {\n-                    definitive_tactic(\n-                        &*list_items,\n-                        ListTactic::LimitedHorizontalVertical(self.item_max_width),\n-                        Separator::Comma,\n-                        self.one_line_width,\n-                    )\n-                };\n-\n                 // Use horizontal layout for a function with a single argument as long as\n                 // everything fits in a single line.\n-                if self.items.len() == 1\n-                && self.one_line_width != 0 // Vertical layout is forced.\n-                && !list_items[0].has_comment()\n+                // `self.one_line_width == 0` means vertical layout is forced.\n+                if self.items.len() == 1 && self.one_line_width != 0 && !list_items[0].has_comment()\n                     && !list_items[0].inner_as_ref().contains('\\n')\n                     && ::lists::total_item_width(&list_items[0]) <= self.one_line_width\n                 {\n                     tactic = DefinitiveListTactic::Horizontal;\n                 } else {\n-                    tactic = default_tactic();\n+                    tactic = self.default_tactic(list_items);\n \n                     if tactic == DefinitiveListTactic::Vertical {\n                         if let Some((all_simple, num_args_before)) =\n@@ -302,6 +340,8 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                             if one_line {\n                                 tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n                             };\n+                        } else if is_every_expr_simple(self.items) && no_long_items(list_items) {\n+                            tactic = DefinitiveListTactic::Mixed;\n                         }\n                     }\n                 }\n@@ -340,13 +380,20 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n                 tactic\n             } else if !self.context.use_block_indent() {\n                 SeparatorTactic::Never\n+            } else if tactic == DefinitiveListTactic::Mixed {\n+                // We are using mixed layout because everything did not fit within a single line.\n+                SeparatorTactic::Always\n             } else {\n                 self.context.config.trailing_comma()\n             },\n             separator_place: SeparatorPlace::Back,\n             shape: self.nested_shape,\n-            ends_with_newline: self.context.use_block_indent()\n-                && tactic == DefinitiveListTactic::Vertical,\n+            ends_with_newline: match tactic {\n+                DefinitiveListTactic::Vertical | DefinitiveListTactic::Mixed => {\n+                    self.context.use_block_indent()\n+                }\n+                _ => false,\n+            },\n             preserve_newline: false,\n             config: self.context.config,\n         };\n@@ -364,6 +411,10 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             ..shape\n         };\n \n+        let (prefix, suffix) = match self.custom_delims {\n+            Some((lhs, rhs)) => (lhs, rhs),\n+            _ => (self.prefix, self.suffix),\n+        };\n         let paren_overhead = paren_overhead(self.context);\n         let fits_one_line = items_str.len() + paren_overhead <= shape.width;\n         let extend_width = if items_str.is_empty() {\n@@ -382,7 +433,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             self.ident.len() + items_str.len() + 2 + indent_str.len() + nested_indent_str.len(),\n         );\n         result.push_str(self.ident);\n-        result.push_str(self.prefix);\n+        result.push_str(prefix);\n         if !self.context.use_block_indent()\n             || (self.context.inside_macro() && !items_str.contains('\\n') && fits_one_line)\n             || (is_extendable && extend_width <= shape.width)\n@@ -401,7 +452,7 @@ impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n             }\n             result.push_str(&indent_str);\n         }\n-        result.push_str(self.suffix);\n+        result.push_str(suffix);\n         result\n     }\n \n@@ -489,3 +540,8 @@ fn shape_from_indent_style(\n         }\n     }\n }\n+\n+fn no_long_items(list: &[ListItem]) -> bool {\n+    list.iter()\n+        .all(|item| !item.has_comment() && item.inner_as_ref().len() <= SHORT_ITEM_THRESHOLD)\n+}"}, {"sha": "d5c97b95560daed89097e90335c1ccc21e4fec4a", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -221,18 +221,16 @@ mod test {\n         let diff = make_diff(src, dest, 1);\n         assert_eq!(\n             diff,\n-            vec![\n-                Mismatch {\n-                    line_number: 2,\n-                    line_number_orig: 2,\n-                    lines: vec![\n-                        Context(\"two\".to_owned()),\n-                        Resulting(\"three\".to_owned()),\n-                        Expected(\"trois\".to_owned()),\n-                        Context(\"four\".to_owned()),\n-                    ],\n-                },\n-            ]\n+            vec![Mismatch {\n+                line_number: 2,\n+                line_number_orig: 2,\n+                lines: vec![\n+                    Context(\"two\".to_owned()),\n+                    Resulting(\"three\".to_owned()),\n+                    Expected(\"trois\".to_owned()),\n+                    Context(\"four\".to_owned()),\n+                ],\n+            }]\n         );\n     }\n \n@@ -274,13 +272,11 @@ mod test {\n         let diff = make_diff(src, dest, 0);\n         assert_eq!(\n             diff,\n-            vec![\n-                Mismatch {\n-                    line_number: 3,\n-                    line_number_orig: 3,\n-                    lines: vec![Resulting(\"three\".to_owned()), Expected(\"trois\".to_owned())],\n-                },\n-            ]\n+            vec![Mismatch {\n+                line_number: 3,\n+                line_number_orig: 3,\n+                lines: vec![Resulting(\"three\".to_owned()), Expected(\"trois\".to_owned())],\n+            }]\n         );\n     }\n \n@@ -291,13 +287,11 @@ mod test {\n         let diff = make_diff(src, dest, 1);\n         assert_eq!(\n             diff,\n-            vec![\n-                Mismatch {\n-                    line_number: 5,\n-                    line_number_orig: 5,\n-                    lines: vec![Context(\"five\".to_owned()), Expected(\"\".to_owned())],\n-                },\n-            ]\n+            vec![Mismatch {\n+                line_number: 5,\n+                line_number_orig: 5,\n+                lines: vec![Context(\"five\".to_owned()), Expected(\"\".to_owned())],\n+            }]\n         );\n     }\n }"}, {"sha": "3b73247f7f8872cd578da5c85ffdb17dbe1cf9fb", "filename": "tests/lib.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flib.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -540,19 +540,17 @@ fn rustfmt_diff_make_diff_tests() {\n     let diff = make_diff(\"a\\nb\\nc\\nd\", \"a\\ne\\nc\\nd\", 3);\n     assert_eq!(\n         diff,\n-        vec![\n-            Mismatch {\n-                line_number: 1,\n-                line_number_orig: 1,\n-                lines: vec![\n-                    DiffLine::Context(\"a\".into()),\n-                    DiffLine::Resulting(\"b\".into()),\n-                    DiffLine::Expected(\"e\".into()),\n-                    DiffLine::Context(\"c\".into()),\n-                    DiffLine::Context(\"d\".into()),\n-                ],\n-            },\n-        ]\n+        vec![Mismatch {\n+            line_number: 1,\n+            line_number_orig: 1,\n+            lines: vec![\n+                DiffLine::Context(\"a\".into()),\n+                DiffLine::Resulting(\"b\".into()),\n+                DiffLine::Expected(\"e\".into()),\n+                DiffLine::Context(\"c\".into()),\n+                DiffLine::Context(\"d\".into()),\n+            ],\n+        }]\n     );\n }\n "}, {"sha": "d3e3cad5ebbd7c4e227e609af56c44088fa4bbc2", "filename": "tests/target/chains.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -233,10 +233,7 @@ impl Foo {\n                         if let Some(mi) = attr.meta() {\n                             if let Some(value) = mi.value_str() {\n                                 doc_strings.push(DocFragment::Include(\n-                                    line,\n-                                    attr.span,\n-                                    filename,\n-                                    contents,\n+                                    line, attr.span, filename, contents,\n                                 ));\n                             }\n                         }"}, {"sha": "2bec429e8c82cb2e92d349e072259629a98d27b6", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -114,19 +114,7 @@ fn function_calls() {\n \n fn macros() {\n     baz!(\n-        do_not,\n-        add,\n-        trailing,\n-        commas,\n-        inside,\n-        of,\n-        function,\n-        like,\n-        macros,\n-        even,\n-        if_they,\n-        are,\n-        long\n+        do_not, add, trailing, commas, inside, of, function, like, macros, even, if_they, are, long\n     );\n \n     baz!(one_item_macro_which_is_also_loooooooooooooooooooooooooooooooooooooooooooooooong);"}, {"sha": "fe565f4c1540bf4e082881427ab173659587794b", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dd08ddd92f49daab1a4d60a42fc7682fd4d2770/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=8dd08ddd92f49daab1a4d60a42fc7682fd4d2770", "patch": "@@ -218,10 +218,7 @@ fn issue355() {\n         xc => vec![1, 2],       // comment\n         yc => vec![3; 4],       // comment\n         yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(\n-            aaaaaaaaaa,\n-            bbbbbbbbbb,\n-            cccccccccc,\n-            dddddddddd,\n+            aaaaaaaaaa, bbbbbbbbbb, cccccccccc, dddddddddd,\n         ),\n     }\n }"}]}