{"sha": "3031720d8fe850073ff3cf9509ae22eb2d2a3978", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMzE3MjBkOGZlODUwMDczZmYzY2Y5NTA5YWUyMmViMmQyYTM5Nzg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-22T18:57:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-22T18:57:49Z"}, "message": "Rollup merge of #66587 - matthewjasper:handle-static-as-const, r=oli-obk\n\nHandle statics in MIR as const pointers\n\nThis is the first PR towards the goal of removing `PlaceBase::Static`. In this PR:\n\n* Statics are lowered to dereferencing a const pointer.\n* The temporaries holding such pointers are tracked in MIR, for the most part this is only used for diagnostics. There are two exceptions:\n    * The borrow checker has some checks for thread-locals that directly use this data.\n    * Const checking will suppress \"cannot dereference raw pointer\" diagnostics for pointers to `static mut`/`extern static`. This is to maintain the current behaviour (12 tests fail otherwise).\n\nThe following are left to future PRs (I think that @spastorino will be working on the first 3):\n\n* Applying the same treatments to promoted statics.\n* Removing `PlaceBase::Static`.\n* Replacing `PlaceBase` with `Local`.\n* Moving the ever growing collection of metadata that we have for diagnostics in MIR passes somewhere more appropriate.\n\nr? @oli-obk", "tree": {"sha": "fb0ef7a3a051598c54d5eed9e7b90ee1e3f9e8b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb0ef7a3a051598c54d5eed9e7b90ee1e3f9e8b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3031720d8fe850073ff3cf9509ae22eb2d2a3978", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2C+uCRBK7hj4Ov3rIwAAdHIIAFtpiefjeHPib/xX9JCzP+Ft\nQGtxYPsgKl39t8/tVXVmduzQlTFl1Eh+eD5Gt61CpO4MVaVCPLHcx8yEH9WPsJOl\n4htz0YpbMob1/fGY0biFYyvSdejf03ofxKVBh0dZGAmW/JBH8dEzyVDImeglD//f\nfWtSFxed2yOqHME8fdoJTw6XHeOE99aHbTlr3MruB3KE9CeEA/+GMAy7oB0kxfrS\njB6XDTbFKLe7RMPLJLV/slTwBZdBSfAWF+SPkAyzVNDDBgkekAw2l8kIOar79yEQ\ns0oAIjF6tnoQG5yT6qjKx0EjAXuCDZSvbeXPx7EeeXsZBaVyEK8skfWsA87LkhE=\n=0S5w\n-----END PGP SIGNATURE-----\n", "payload": "tree fb0ef7a3a051598c54d5eed9e7b90ee1e3f9e8b6\nparent c66b508137c296699bae56fb40bc180c61dfa175\nparent bccc59a8e6e25c2b63308e77f853c6f23782e631\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1574449069 +0100\ncommitter GitHub <noreply@github.com> 1574449069 +0100\n\nRollup merge of #66587 - matthewjasper:handle-static-as-const, r=oli-obk\n\nHandle statics in MIR as const pointers\n\nThis is the first PR towards the goal of removing `PlaceBase::Static`. In this PR:\n\n* Statics are lowered to dereferencing a const pointer.\n* The temporaries holding such pointers are tracked in MIR, for the most part this is only used for diagnostics. There are two exceptions:\n    * The borrow checker has some checks for thread-locals that directly use this data.\n    * Const checking will suppress \"cannot dereference raw pointer\" diagnostics for pointers to `static mut`/`extern static`. This is to maintain the current behaviour (12 tests fail otherwise).\n\nThe following are left to future PRs (I think that @spastorino will be working on the first 3):\n\n* Applying the same treatments to promoted statics.\n* Removing `PlaceBase::Static`.\n* Replacing `PlaceBase` with `Local`.\n* Moving the ever growing collection of metadata that we have for diagnostics in MIR passes somewhere more appropriate.\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3031720d8fe850073ff3cf9509ae22eb2d2a3978", "html_url": "https://github.com/rust-lang/rust/commit/3031720d8fe850073ff3cf9509ae22eb2d2a3978", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3031720d8fe850073ff3cf9509ae22eb2d2a3978/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66b508137c296699bae56fb40bc180c61dfa175", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66b508137c296699bae56fb40bc180c61dfa175", "html_url": "https://github.com/rust-lang/rust/commit/c66b508137c296699bae56fb40bc180c61dfa175"}, {"sha": "bccc59a8e6e25c2b63308e77f853c6f23782e631", "url": "https://api.github.com/repos/rust-lang/rust/commits/bccc59a8e6e25c2b63308e77f853c6f23782e631", "html_url": "https://github.com/rust-lang/rust/commit/bccc59a8e6e25c2b63308e77f853c6f23782e631"}], "stats": {"total": 885, "additions": 488, "deletions": 397}, "files": [{"sha": "bd793fd07bf22e00ad04a9ccf8016778f281bd09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -7,7 +7,7 @@\n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir;\n-use crate::mir::interpret::{PanicInfo, Scalar};\n+use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -292,7 +292,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 None\n             } else {\n                 Some(local)\n@@ -305,7 +305,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 Some(local)\n             } else {\n                 None\n@@ -319,7 +319,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if decl.is_user_variable.is_some() && decl.mutability == Mutability::Mut {\n+            if decl.is_user_variable() && decl.mutability == Mutability::Mut {\n                 Some(local)\n             } else {\n                 None\n@@ -333,7 +333,7 @@ impl<'tcx> Body<'tcx> {\n         (1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if (decl.is_user_variable.is_some() || index < self.arg_count + 1)\n+            if (decl.is_user_variable() || index < self.arg_count + 1)\n                 && decl.mutability == Mutability::Mut\n             {\n                 Some(local)\n@@ -689,14 +689,8 @@ pub struct LocalDecl<'tcx> {\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// `Some(binding_mode)` if this corresponds to a user-declared local variable.\n-    ///\n-    /// This is solely used for local diagnostics when generating\n-    /// warnings/errors when compiling the current crate, and\n-    /// therefore it need not be visible across crates. pnkfelix\n-    /// currently hypothesized we *need* to wrap this in a\n-    /// `ClearCrossCrate` as long as it carries as `HirId`.\n-    pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n+    pub local_info: LocalInfo<'tcx>,\n \n     /// `true` if this is an internal local.\n     ///\n@@ -721,6 +715,7 @@ pub struct LocalDecl<'tcx> {\n     /// then it is a temporary created for evaluation of some\n     /// subexpression of some block's tail expression (with no\n     /// intervening statement context).\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub is_block_tail: Option<BlockTailInfo>,\n \n     /// The type of this local.\n@@ -730,6 +725,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub user_ty: UserTypeProjections,\n \n     /// The name of the local, used in debuginfo and pretty-printing.\n@@ -824,6 +820,21 @@ pub struct LocalDecl<'tcx> {\n     pub visibility_scope: SourceScope,\n }\n \n+/// Extra information about a local that's used for diagnostics.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum LocalInfo<'tcx> {\n+    /// A user-defined local variable or function parameter\n+    ///\n+    /// The `BindingForm` is solely used for local diagnostics when generating\n+    /// warnings/errors when compiling the current crate, and therefore it need\n+    /// not be visible across crates.\n+    User(ClearCrossCrate<BindingForm<'tcx>>),\n+    /// A temporary created that references the static with the given `DefId`.\n+    StaticRef { def_id: DefId, is_thread_local: bool },\n+    /// Any other temporary, the return place, or an anonymous function parameter.\n+    Other,\n+}\n+\n impl<'tcx> LocalDecl<'tcx> {\n     /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n@@ -832,15 +843,17 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - `let x = ...`,\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n+            LocalInfo::User(\n+                ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)),\n+            ) => true,\n \n             _ => false,\n         }\n@@ -850,26 +863,54 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n \n             _ => false,\n         }\n     }\n \n+    /// Returns `true` if this variable is a named variable or function\n+    /// parameter declared by the user.\n+    #[inline]\n+    pub fn is_user_variable(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::User(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if this is a reference to a variable bound in a `match`\n     /// expression that is used to access said variable for the guard of the\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_static(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_thread_local(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { is_thread_local, .. } => is_thread_local,\n             _ => false,\n         }\n     }\n@@ -918,7 +959,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n             is_block_tail: None,\n         }\n     }\n@@ -937,7 +978,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             internal: false,\n             is_block_tail: None,\n             name: None, // FIXME maybe we do want some name here?\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n         }\n     }\n }\n@@ -2341,6 +2382,24 @@ pub struct Constant<'tcx> {\n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n+impl Constant<'tcx> {\n+    pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n+        match self.literal.val.try_to_scalar() {\n+            Some(Scalar::Ptr(ptr)) => match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                Some(GlobalAlloc::Static(def_id)) => Some(def_id),\n+                Some(_) => None,\n+                None => {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP, \"MIR cannot contain dangling const pointers\",\n+                    );\n+                    None\n+                },\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// A collection of projections into user types.\n ///\n /// They are projections because a binding can occur a part of a"}, {"sha": "fc0e77aab43a4d9a38cebb573df5d6ba3475679c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -691,7 +691,7 @@ macro_rules! make_mir_visitor {\n                     source_info,\n                     visibility_scope,\n                     internal: _,\n-                    is_user_variable: _,\n+                    local_info: _,\n                     is_block_tail: _,\n                 } = local_decl;\n "}, {"sha": "27891be6b82c5e45093cc7c9c6cac7c52c040cb8", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -5,17 +5,40 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasTyCtxt};\n use syntax::source_map::Span;\n use crate::traits::*;\n+use crate::mir::operand::OperandRef;\n \n use super::FunctionCx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn eval_mir_constant_to_operand(\n+        &mut self,\n+        bx: &mut Bx,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n+        match constant.literal.val {\n+            ty::ConstKind::Unevaluated(def_id, substs)\n+                if self.cx.tcx().is_static(def_id) => {\n+                    assert!(substs.is_empty(), \"we don't support generic statics yet\");\n+                    let static_ = bx.get_static(def_id);\n+                    // we treat operands referring to statics as if they were `&STATIC` instead\n+                    let ptr_ty = self.cx.tcx().mk_mut_ptr(self.monomorphize(&constant.literal.ty));\n+                    let layout = bx.layout_of(ptr_ty);\n+                    Ok(OperandRef::from_immediate_or_packed_pair(bx, static_, layout))\n+                }\n+            _ => {\n+                let val = self.eval_mir_constant(constant)?;\n+                Ok(OperandRef::from_const(bx, val))\n+            }\n+        }\n+    }\n+\n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n-            ty::ConstKind::Unevaluated(def_id, ref substs) => {\n-                let substs = self.monomorphize(substs);\n+            ty::ConstKind::Unevaluated(def_id, substs) => {\n+                let substs = self.monomorphize(&substs);\n                 let instance = ty::Instance::resolve(\n                     self.cx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs,\n                 ).unwrap();"}, {"sha": "310b8aeb4db09d3de5830959c55dae1f72f9fcd5", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -465,8 +465,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                self.eval_mir_constant(constant)\n-                    .map(|c| OperandRef::from_const(bx, c))\n+                self.eval_mir_constant_to_operand(bx, constant)\n                     .unwrap_or_else(|err| {\n                         match err {\n                             // errored or at least linted"}, {"sha": "943234319906a28ea54cf6391604ef7e0567eb5f", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -189,8 +189,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         location: mir::Location,\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-            if borrowed_place.ignore_borrow(\n-                self.tcx, self.body, &self.locals_state_at_exit) {\n+            if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n+                debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n             }\n "}, {"sha": "3595312f3f41b41bfa13e92a5d8838a032c2a60f", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -3,8 +3,8 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n-    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceBase,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -744,6 +744,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 projection: root_place_projection,\n             }, borrow_span));\n \n+        if let PlaceBase::Local(local) = borrow.borrowed_place.base {\n+            if self.body.local_decls[local].is_ref_to_thread_local() {\n+                let err = self.report_thread_local_value_does_not_live_long_enough(\n+                    drop_span,\n+                    borrow_span,\n+                );\n+                err.buffer(&mut self.errors_buffer);\n+                return;\n+            }\n+        };\n+\n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n             self.classify_drop_access_kind(borrow.borrowed_place.as_ref())\n         {\n@@ -770,9 +781,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             explanation\n         );\n         let err = match (place_desc, explanation) {\n-            (Some(_), _) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n             //\n@@ -1509,19 +1517,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // place being assigned later.\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n-                is_user_variable: Some(ClearCrossCrate::Clear),\n+                local_info: LocalInfo::User(ClearCrossCrate::Clear),\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable:\n-                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: None,\n-                        ..\n-                    }))),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: None,\n+                    ..\n+                }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                local_info: LocalInfo::StaticRef { .. },\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 ..\n             })\n             | None => (self.describe_place(place.as_ref()), assigned_span),"}, {"sha": "3835503b0ef35fdf8597ad6e40e2ca75ed22cbc9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::hir::GeneratorKind;\n use rustc::mir::{\n-    AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n+    AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n     Static, StaticKind, Terminator, TerminatorKind,\n };\n@@ -12,7 +12,6 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n-use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -178,6 +177,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                self.append_place_to_string(\n+                    PlaceRef {\n+                        base: &PlaceBase::Local(local),\n+                        projection: &[],\n+                    },\n+                    buf,\n+                    autoderef,\n+                    &including_downcast,\n+                )?;\n+            },\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                let local_info = &self.body.local_decls[local].local_info;\n+                if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                    buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n+                } else {\n+                    unreachable!();\n+                }\n+            },\n             PlaceRef {\n                 base,\n                 projection: [proj_base @ .., elem],\n@@ -208,32 +232,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 )?;\n                             } else {\n                                 match (proj_base, base) {\n-                                    ([], PlaceBase::Local(local)) => {\n-                                        if self.body.local_decls[*local].is_ref_for_guard() {\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        } else {\n-                                            // FIXME deduplicate this and the _ => body below\n-                                            buf.push_str(&\"*\");\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        }\n-                                    }\n-\n                                     _ => {\n                                         buf.push_str(&\"*\");\n                                         self.append_place_to_string(\n@@ -440,30 +438,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Checks if a place is a thread-local static.\n-    pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n-        if let PlaceRef {\n-            base: PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                def_id,\n-                ..\n-            }),\n-            projection: [],\n-        } = place_ref {\n-            let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n-\n-            debug!(\n-                \"is_place_thread_local: attrs={:?} is_thread_local={:?}\",\n-                attrs, is_thread_local\n-            );\n-            is_thread_local\n-        } else {\n-            debug!(\"is_place_thread_local: no\");\n-            false\n-        }\n-    }\n-\n     /// Add a note that a type does not implement `Copy`\n     pub(super) fn note_type_does_not_implement_copy(\n         &self,"}, {"sha": "90e39286ec84d02d41479625d11b490abdfc0468", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -308,7 +308,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| mbcx.body.local_decls[*local].is_user_variable.is_none())\n+        .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n@@ -1287,7 +1287,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 match place.as_local() {\n-                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                    Some(local) if !self.body.local_decls[local].is_user_variable() => {\n                         if self.body.local_decls[local].ty.is_mutable_ptr() {\n                             // The variable will be marked as mutable by the borrow.\n                             return;\n@@ -1399,34 +1399,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let root_place = self.prefixes(place.as_ref(), PrefixSet::All).last().unwrap();\n+        let deref = [ProjectionElem::Deref];\n+        let mut root_place = PlaceRef { base: &place.base, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(..),\n-                ..\n-            }) => {\n+            PlaceBase::Static(_) => {\n                 (true, false)\n             }\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                ..\n-            }) => {\n-                // Thread-locals might be dropped after the function exits, but\n-                // \"true\" statics will never be.\n-                (true, self.is_place_thread_local(root_place))\n-            }\n-            PlaceBase::Local(_) => {\n-                // Locals are always dropped at function exit, and if they\n-                // have a destructor it would've been called already.\n-                (false, self.locals_are_invalidated_at_exit)\n+            PlaceBase::Local(local) => {\n+                if self.body.local_decls[*local].is_ref_to_thread_local() {\n+                    // Thread-locals might be dropped after the function exits\n+                    // We have to dereference the outer reference because\n+                    // borrows don't conflict behind shared references.\n+                    root_place.projection = &deref;\n+                    (true, true)\n+                } else {\n+                    (false, self.locals_are_invalidated_at_exit)\n+                }\n             }\n         };\n "}, {"sha": "b1f63d729ba9b027ce5fb0fe79d51e9f4c0b7a5e", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -104,13 +104,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                            opt_match_place: Some((ref opt_match_place, match_span)),\n-                            binding_mode: _,\n-                            opt_ty_info: _,\n-                            pat_span: _,\n-                        }))) = local_decl.is_user_variable\n-                        {\n+                        if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm {\n+                                opt_match_place: Some((ref opt_match_place, match_span)),\n+                                binding_mode: _,\n+                                opt_ty_info: _,\n+                                pat_span: _,\n+                            },\n+                        ))) = local_decl.local_info {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n                                 grouped_errors,\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n-                        self.report_cannot_move_from_static(original_path, span)\n+                        unreachable!();\n                     }\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => {\n                         self.report_cannot_move_from_borrowed_content(\n@@ -272,12 +273,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_empty() {\n+        let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: &place.projection[..1],\n+                projection: &[ProjectionElem::Deref],\n             };\n \n             format!(\n@@ -327,6 +328,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     \"variables bound in patterns cannot be moved from \\\n                      until after the end of the pattern guard\");\n                 return err;\n+            } else if decl.is_ref_to_static() {\n+                return self.report_cannot_move_from_static(move_place, span);\n             }\n         }\n \n@@ -508,12 +511,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let Some(\n+            if let LocalInfo::User(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n                     ..\n                 }))\n-            ) = bind_to.is_user_variable {\n+            ) = bind_to.local_info {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {\n                     if pat_snippet.starts_with('&') {"}, {"sha": "404684c07a09c6a45805e10ab3534fcdda8b8c14", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 53, "deletions": 71, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1,9 +1,7 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n-use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n-};\n+use rustc::mir::{self, Body, ClearCrossCrate, Local, LocalInfo, Location};\n+use rustc::mir::{Mutability, Place, PlaceRef, PlaceBase, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_index::vec::Idx;\n use syntax_pos::Span;\n@@ -76,6 +74,31 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                reason = \", as it is immutable for the pattern guard\".to_string();\n+            }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                if access_place.projection.len() == 1 {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = String::new();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let local_info = &self.body.local_decls[local].local_info;\n+                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                        let static_name = &self.infcx.tcx.item_name(def_id);\n+                        reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                    } else {\n+                        bug!(\"is_ref_to_static return true, but not ref to static?\");\n+                    }\n+                }\n+            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., ProjectionElem::Deref],\n@@ -101,15 +124,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n-                } else if {\n-                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, proj_base) {\n-                        self.body.local_decls[*local].is_ref_for_guard()\n-                    } else {\n-                        false\n-                    }\n-                } {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n@@ -133,37 +147,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(..),\n-                        ..\n-                    }),\n-                projection: [],\n-            } => unreachable!(),\n-\n-            PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static,\n-                        def_id,\n-                        ..\n-                    }),\n-                projection: [],\n-            } => {\n-                if let PlaceRef {\n-                    base: &PlaceBase::Static(_),\n-                    projection: &[],\n-                } = access_place.as_ref() {\n-                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n-                    reason = String::new();\n-                } else {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.infcx.tcx.item_name(*def_id);\n-                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n-                }\n+                base: PlaceBase::Static(_),\n+                ..\n             }\n-\n-            PlaceRef {\n+            | PlaceRef {\n                 base: _,\n                 projection: [.., ProjectionElem::Index(_)],\n             }\n@@ -257,15 +244,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n-                    if let ClearCrossCrate::Set(\n+                    if let LocalInfo::User(ClearCrossCrate::Set(\n                         mir::BindingForm::ImplicitSelf(kind)\n-                    ) = local_decl.is_user_variable.as_ref().unwrap() {\n+                    )) = local_decl.local_info {\n                         // Check if the user variable is a `&mut self` and we can therefore\n                         // suggest removing the `&mut`.\n                         //\n                         // Deliberately fall into this case for all implicit self types,\n                         // so that we don't fall in to the next case with them.\n-                        *kind == mir::ImplicitSelfKind::MutRef\n+                        kind == mir::ImplicitSelfKind::MutRef\n                     } else if Some(kw::SelfLower) == local_decl.name {\n                         // Otherwise, check if the name is the self kewyord - in which case\n                         // we have an explicit self. Do the same thing in this case and check\n@@ -360,16 +347,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if {\n-                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n-                    self.body.local_decls[*local].is_user_variable\n-                {\n-                    true\n-                } else {\n-                    false\n-                }\n-            } =>\n-            {\n+            } if self.body.local_decls[*local].is_ref_for_guard() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -384,38 +362,42 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_user_variable.is_some() =>\n+            } if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n-                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = match local_decl.local_info {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByValue(_),\n-                        opt_ty_info,\n-                        ..\n-                    })) => Some(suggest_ampmut(\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByValue(_),\n+                            opt_ty_info,\n+                            ..\n+                        },\n+                    ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n                         self.body,\n                         *local,\n                         local_decl,\n-                        *opt_ty_info,\n+                        opt_ty_info,\n                     )),\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByReference(_),\n-                        ..\n-                    })) => {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByReference(_),\n+                            ..\n+                        },\n+                    ))) => {\n                         let pattern_span = local_decl.source_info.span;\n                         suggest_ref_mut(self.infcx.tcx, pattern_span)\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n+                    LocalInfo::User(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n \n-                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n+                    _ => unreachable!(),\n                 };\n \n                 let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {"}, {"sha": "99bcfa9bc25995a3babf96a08d11565e51b14463", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1387,7 +1387,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1693,7 +1693,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,"}, {"sha": "c62de2af55f449c5218f7df0cfdf04b0861bbebf", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Body, Place, PlaceBase, Mutability, Static, StaticKind};\n+use rustc::mir::{Body, Place, PlaceBase, Mutability};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -25,7 +25,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        let ignore = match self.base {\n+        let local = match self.base {\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -34,45 +34,56 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             //\n             // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n             // so we don't have to worry about mutation while borrowed.\n-            PlaceBase::Local(index) => {\n+            PlaceBase::Local(local) => {\n                 match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::AllAreInvalidated => local,\n                     LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n-                            body.local_decls[index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+                        let ignore = !has_storage_dead_or_moved.contains(local) &&\n+                            body.local_decls[local].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", local, ignore);\n+                        if ignore {\n+                            return true;\n+                        } else {\n+                            local\n+                        }\n                     }\n                 }\n             }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                false,\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                tcx.is_mutable_static(def_id)\n-            }\n+            PlaceBase::Static(_) => return true,\n         };\n \n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) = ty.kind {\n-                    // For both derefs of raw pointers and `&T`\n-                    // references, the original path is `Copy` and\n-                    // therefore not significant.  In particular,\n-                    // there is nothing the user can do to the\n-                    // original path that would invalidate the\n-                    // newly created reference -- and if there\n-                    // were, then the user could have copied the\n-                    // original path into a new variable and\n-                    // borrowed *that* one, leaving the original\n-                    // path unborrowed.\n-                    return true;\n+                match ty.kind {\n+                    ty::Ref(_, _, hir::Mutability::Immutable) if i == 0 => {\n+                        // For references to thread-local statics, we do need\n+                        // to track the borrow.\n+                        if body.local_decls[local].is_ref_to_thread_local() {\n+                            continue;\n+                        }\n+                        return true;\n+                    }\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+                        // For both derefs of raw pointers and `&T`\n+                        // references, the original path is `Copy` and\n+                        // therefore not significant.  In particular,\n+                        // there is nothing the user can do to the\n+                        // original path that would invalidate the\n+                        // newly created reference -- and if there\n+                        // were, then the user could have copied the\n+                        // original path into a new variable and\n+                        // borrowed *that* one, leaving the original\n+                        // path unborrowed.\n+                        return true;\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n-        ignore\n+        false\n     }\n }"}, {"sha": "6db7ec65096ec1fc3777cad4ef50306a2ae2f117", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -45,6 +45,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     literal,\n                 }\n             },\n+            ExprKind::StaticRef { literal, .. } => {\n+                Constant {\n+                    span,\n+                    user_ty: None,\n+                    literal,\n+                }\n+            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "f66f1cb73666afdb428db5791c0e37cdb6da55d4", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -197,13 +197,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(place_builder)\n             }\n-            ExprKind::StaticRef { id } => block.and(PlaceBuilder::from(\n-                PlaceBase::Static(Box::new(Static {\n-                    ty: expr.ty,\n-                    kind: StaticKind::Static,\n-                    def_id: id,\n-                }))\n-            )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let source = this.hir.mirror(source);\n@@ -292,6 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::Call { .. } => {"}, {"sha": "37eb0cc9d961e78a637d3d8d3a91e3f52fc2acdd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -270,6 +270,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 resume.and(this.unit_rvalue())\n             }\n             ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n@@ -288,7 +289,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::StaticRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 // these do not have corresponding `Rvalue` variants,"}, {"sha": "4dad9ab498f63c06a5959b5a3f94255074f1f61b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -6,6 +6,7 @@ use crate::hair::*;\n use rustc::hir;\n use rustc::middle::region;\n use rustc::mir::*;\n+use syntax_pos::symbol::sym;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n@@ -63,6 +64,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(tail_info) = this.block_context.currently_in_block_tail() {\n                 local_decl = local_decl.block_tail(tail_info);\n             }\n+            if let ExprKind::StaticRef { def_id, .. } = expr.kind {\n+                let is_thread_local = this.hir.tcx().has_attr(def_id, sym::thread_local);\n+                local_decl.local_info = LocalInfo::StaticRef {def_id, is_thread_local };\n+            }\n             this.local_decls.push(local_decl)\n         };\n         let temp_place = &Place::from(temp);"}, {"sha": "270a1a6447435361555bcf3deed948b2ae45e62a", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -40,7 +40,6 @@ impl Category {\n             | ExprKind::Index { .. }\n             | ExprKind::SelfRef\n             | ExprKind::VarRef { .. }\n-            | ExprKind::StaticRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),\n \n@@ -66,7 +65,8 @@ impl Category {\n             | ExprKind::Yield { .. }\n             | ExprKind::InlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n-            ExprKind::Literal { .. } => Some(Category::Constant),\n+            ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. } => Some(Category::Constant),\n \n             ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "e991181189f412bc8c7fc2974f5013a2ffeae748", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         source_info,\n                         visibility_scope: source_info.scope,\n                         internal: true,\n-                        is_user_variable: None,\n+                        local_info: LocalInfo::Other,\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n@@ -384,7 +384,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Avoid creating a temporary\n             ExprKind::VarRef { .. } |\n             ExprKind::SelfRef |\n-            ExprKind::StaticRef { .. } |\n             ExprKind::PlaceTypeAscription { .. } |\n             ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n@@ -426,6 +425,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Tuple { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     // should be handled above"}, {"sha": "ada547aa39c9e70f5920072b162220bbfbc9fa08", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     opt_match_place: Some((ref mut match_place, _)),\n                     ..\n-                }))) = self.local_decls[local].is_user_variable\n+                }))) = self.local_decls[local].local_info\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -1734,16 +1734,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             visibility_scope,\n             internal: false,\n             is_block_tail: None,\n-            is_user_variable: Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode,\n-                // hypothetically, `visit_bindings` could try to unzip\n-                // an outermost hir::Ty as we descend, matching up\n-                // idents in pat; but complex w/ unclear UI payoff.\n-                // Instead, just abandon providing diagnostic info.\n-                opt_ty_info: None,\n-                opt_match_place,\n-                pat_span,\n-            }))),\n+            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                VarBindingForm {\n+                    binding_mode,\n+                    // hypothetically, `visit_bindings` could try to unzip\n+                    // an outermost hir::Ty as we descend, matching up\n+                    // idents in pat; but complex w/ unclear UI payoff.\n+                    // Instead, just abandon providing diagnostic info.\n+                    opt_ty_info: None,\n+                    opt_match_place,\n+                    pat_span,\n+                },\n+            ))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         let locals = if has_guard.0 {\n@@ -1758,7 +1760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope,\n                 internal: false,\n                 is_block_tail: None,\n-                is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {\n                 ref_for_guard,"}, {"sha": "6b458cc244c9e3195564c8cdd060c1206baf8964", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -820,7 +820,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope: source_info.scope,\n                 name,\n                 internal: false,\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 is_block_tail: None,\n             });\n         }\n@@ -855,17 +855,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].is_user_variable =\n+                        self.local_decls[local].local_info =\n                             if let Some(kind) = self_binding {\n-                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n+                                LocalInfo::User(ClearCrossCrate::Set(\n+                                    BindingForm::ImplicitSelf(*kind),\n+                                ))\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n-                                Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                                    binding_mode,\n-                                    opt_ty_info,\n-                                    opt_match_place: Some((Some(place.clone()), span)),\n-                                    pat_span: span,\n-                                })))\n+                                LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                                    VarBindingForm {\n+                                        binding_mode,\n+                                        opt_ty_info,\n+                                        opt_match_place: Some((Some(place.clone()), span)),\n+                                        pat_span: span,\n+                                    },\n+                                )))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }"}, {"sha": "402e5aeacbf245acb264ef3b5f12522b37a19e70", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -209,7 +209,9 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n             if place.projection.is_empty() {\n-                trans.kill_all(other_borrows_of_local);\n+                if !self.body.local_decls[local].is_ref_to_static() {\n+                    trans.kill_all(other_borrows_of_local);\n+                }\n                 return;\n             }\n "}, {"sha": "de50755616bb0b7d0b592219017a10b5767433bb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -5,7 +5,7 @@ use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_index::vec::Idx;\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n-use rustc::mir::interpret::{GlobalId, ErrorHandled};\n+use rustc::mir::interpret::{GlobalId, ErrorHandled, Scalar};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, PointerCast};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -961,7 +961,29 @@ fn convert_path_expr<'a, 'tcx>(\n             }\n         }\n \n-        Res::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n+        // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n+        // a constant reference (or constant raw pointer for `static mut`) in MIR\n+        Res::Def(DefKind::Static, id) => {\n+            let ty = cx.tcx.type_of(id);\n+            let ty = if cx.tcx.is_mutable_static(id) {\n+                cx.tcx.mk_mut_ptr(ty)\n+            } else if cx.tcx.is_foreign_item(id) {\n+                cx.tcx.mk_imm_ptr(ty)\n+            } else {\n+                cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_static, ty)\n+            };\n+            let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n+            let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+            ExprKind::Deref { arg: Expr {\n+                ty,\n+                temp_lifetime,\n+                span: expr.span,\n+                kind: ExprKind::StaticRef {\n+                    literal: ty::Const::from_scalar(cx.tcx, Scalar::Ptr(ptr.into()), ty),\n+                    def_id: id,\n+                }\n+            }.to_ref() }\n+        },\n \n         Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n "}, {"sha": "47644d9ba83725c511a800c5a07b2a5521ce48fb", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -208,9 +208,6 @@ pub enum ExprKind<'tcx> {\n     },\n     /// first argument, used for self in a closure\n     SelfRef,\n-    StaticRef {\n-        id: DefId,\n-    },\n     Borrow {\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n@@ -267,6 +264,14 @@ pub enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A literal containing the address of a `static`.\n+    ///\n+    /// This is only distinguished from `Literal` so that we can register some\n+    /// info for diagnostics.\n+    StaticRef {\n+        literal: &'tcx Const<'tcx>,\n+        def_id: DefId,\n+    },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsmInner,\n         outputs: Vec<ExprRef<'tcx>>,"}, {"sha": "17f5e3d4e47a982a990117e2cb680e505da784da", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -152,7 +152,7 @@ fn temp_decl(mutability: Mutability, ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other,\n         is_block_tail: None,\n     }\n }"}, {"sha": "9ed1ca740b8e727e94853f61dc622743d94156a9", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n+use rustc::hir::def_id::DefId;\n use syntax_pos::DUMMY_SP;\n \n use super::{ConstKind, Item as ConstCx};\n@@ -32,7 +33,7 @@ pub trait Qualif {\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n \n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _def_id: DefId) -> bool {\n         // FIXME(eddyb) should we do anything here for value properties?\n         false\n     }\n@@ -86,18 +87,9 @@ pub trait Qualif {\n                 projection: [],\n             } => per_local(*local),\n             PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }),\n+                base: PlaceBase::Static(_),\n                 projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(static_),\n-                projection: [],\n-            } => {\n-                Self::in_static(cx, static_)\n-            },\n             PlaceRef {\n                 base: _,\n                 projection: [.., _],\n@@ -115,7 +107,9 @@ pub trait Qualif {\n             Operand::Move(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n \n             Operand::Constant(ref constant) => {\n-                if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n+                if let Some(static_) = constant.check_static_ptr(cx.tcx) {\n+                    Self::in_static(cx, static_)\n+                } else if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)"}, {"sha": "bee37f69a5ec5640a6c8ab09637e310da058ac3e", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1,6 +1,6 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::HirId;\n+use rustc::hir::{HirId, def_id::DefId};\n use rustc::middle::lang_items;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n@@ -288,6 +288,15 @@ impl Validator<'a, 'mir, 'tcx> {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n+\n+    fn check_static(&mut self, def_id: DefId, span: Span) -> CheckOpResult {\n+        let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+        if is_thread_local {\n+            self.check_op_spanned(ops::ThreadLocalAccess, span)\n+        } else {\n+            self.check_op_spanned(ops::StaticAccess, span)\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -408,17 +417,21 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match place_base {\n             PlaceBase::Local(_) => {}\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n+            PlaceBase::Static(_) => {\n                 bug!(\"Promotion must be run after const validation\");\n             }\n+        }\n+    }\n \n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n-                if is_thread_local {\n-                    self.check_op(ops::ThreadLocalAccess);\n-                } else if self.const_kind() != ConstKind::Static || !context.is_mutating_use() {\n-                    self.check_op(ops::StaticAccess);\n-                }\n+    fn visit_operand(\n+        &mut self,\n+        op: &Operand<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_operand(op, location);\n+        if let Operand::Constant(c) = op {\n+            if let Some(def_id) = c.check_static_ptr(self.tcx) {\n+                self.check_static(def_id, self.span);\n             }\n         }\n     }\n@@ -497,14 +510,24 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    self.check_op(ops::MutDeref);\n-                }\n-\n                 let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n+                    if proj_base.is_empty() {\n+                        if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n+                            let decl = &self.body.local_decls[*local];\n+                            if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                                let span = decl.source_info.span;\n+                                self.check_static(def_id, span);\n+                                return;\n+                            }\n+                        }\n+                    }\n                     self.check_op(ops::RawPtrDeref);\n                 }\n+\n+                if context.is_mutating_use() {\n+                    self.check_op(ops::MutDeref);\n+                }\n             }\n \n             ProjectionElem::ConstantIndex {..} |"}, {"sha": "b7cc4e9fcf66cb772cfe199f12c833343c358014", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -206,25 +206,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // Locals are safe.\n             }\n             PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n+                bug!(\"unsafety checking should happen before promotion\");\n             }\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\n-                        \"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing \\\n-                        violations or data races will cause undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    self.require_unsafe(\n-                        \"use of extern static\",\n-                        \"extern statics are not controlled by the Rust type system: \\\n-                        invalid data, aliasing violations or data races will cause \\\n-                        undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                }\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n+                bug!(\"StaticKind::Static should not exist\");\n             }\n         }\n \n@@ -264,11 +249,31 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n             let old_source_info = self.source_info;\n             if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n-                if self.body.local_decls[*local].internal {\n+                let decl = &self.body.local_decls[*local];\n+                if decl.internal {\n                     // Internal locals are used in the `move_val_init` desugaring.\n                     // We want to check unsafety against the source info of the\n                     // desugaring, rather than the source info of the RHS.\n                     self.source_info = self.body.local_decls[*local].source_info;\n+                } else if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                    if self.tcx.is_mutable_static(def_id) {\n+                        self.require_unsafe(\n+                            \"use of mutable static\",\n+                            \"mutable statics can be mutated by multiple threads: aliasing \\\n+                        violations or data races will cause undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    } else if self.tcx.is_foreign_item(def_id) {\n+                        self.require_unsafe(\n+                            \"use of extern static\",\n+                            \"extern statics are not controlled by the Rust type system: \\\n+                        invalid data, aliasing violations or data races will cause \\\n+                        undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    }\n                 }\n             }\n             let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;"}, {"sha": "524b6b087908ce4b7ac57ac5e5e0ba79cac3a6f8", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -432,7 +432,7 @@ fn replace_result_variable<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     let new_ret_local = Local::new(body.local_decls.len());\n     body.local_decls.push(new_ret);\n@@ -967,7 +967,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n \n     make_generator_state_argument_indirect(tcx, def_id, &mut body);\n@@ -985,7 +985,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type"}, {"sha": "86ecfbb4fbea59af92f71b2bb0bf1ca70ba89b5d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -512,34 +512,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 projection: [],\n             } => self.validate_local(*local),\n             PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted { .. },\n-                    ..\n-                }),\n+                base: PlaceBase::Static(_),\n                 projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Static,\n-                    def_id,\n-                    ..\n-                }),\n-                projection: [],\n-            } => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n-                if !is_static {\n-                    return Err(Unpromotable);\n-                }\n-\n-                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n-                if is_thread_local {\n-                    return Err(Unpromotable);\n-                }\n-\n-                Ok(())\n-            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., elem],\n@@ -584,7 +559,23 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             // The qualifs for a constant (e.g. `HasMutInterior`) are checked in\n             // `validate_rvalue` upon access.\n-            Operand::Constant(_) => Ok(()),\n+            Operand::Constant(c) => {\n+                if let Some(def_id) = c.check_static_ptr(self.tcx) {\n+                    // Only allow statics (not consts) to refer to other statics.\n+                    // FIXME(eddyb) does this matter at all for promotion?\n+                    let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                    if !is_static {\n+                        return Err(Unpromotable);\n+                    }\n+\n+                    let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+                    if is_thread_local {\n+                        return Err(Unpromotable);\n+                    }\n+                }\n+\n+                Ok(())\n+            },\n         }\n     }\n "}, {"sha": "65fc7cd20439d55c703337707a3cba8dc233405b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -249,7 +249,10 @@ fn check_operand(\n         Operand::Move(place) | Operand::Copy(place) => {\n             check_place(tcx, place, span, def_id, body)\n         }\n-        Operand::Constant(_) => Ok(()),\n+        Operand::Constant(c) => match c.check_static_ptr(tcx) {\n+            Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+            None => Ok(()),\n+        },\n     }\n }\n \n@@ -285,13 +288,7 @@ fn check_place(\n         }\n     }\n \n-    match place.base {\n-        PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-            Err((span, \"cannot access `static` items in const fn\".into()))\n-        }\n-        PlaceBase::Local(_)\n-        | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n-    }\n+    Ok(())\n }\n \n /// Returns whether `allow_internal_unstable(..., <feature_gate>, ...)` is present."}, {"sha": "d14ec0397166f05cf2f9df071e8cc4e1ce227d26", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -10,10 +10,12 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _2 = (FOO: u8);\n+//      _3 = const Scalar(AllocId(0).0x0) : &u8;\n+//      _2 = (*_3);\n //      ...\n-//      _3 = (FOO: u8);\n-//      _1 = Add(move _2, move _3);\n+//      _5 = const Scalar(AllocId(0).0x0) : &u8;\n+//      _4 = (*_5);\n+//      _1 = Add(move _2, move _4);\n //      ...\n //  }\n // END rustc.main.ConstProp.before.mir\n@@ -22,8 +24,8 @@ fn main() {\n //      ...\n //      _2 = const 2u8;\n //      ...\n-//      _3 = const 2u8;\n-//      _1 = Add(move _2, move _3);\n+//      _4 = const 2u8;\n+//      _1 = Add(move _2, move _4);\n //      ...\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "2d4175ea8eb7da4c4af5bbd19768664e08e89683", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -11,10 +11,10 @@ LL |     Y\n    |     ^\n \n error[E0013]: constant functions cannot refer to statics, use a constant instead\n-  --> $DIR/const-fn-not-safe-for-const.rs:25:5\n+  --> $DIR/const-fn-not-safe-for-const.rs:25:6\n    |\n LL |     &Y\n-   |     ^^\n+   |      ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cb1663ed22f9593fca18305b0100b9d0308e8f96", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -116,10 +116,10 @@ LL | const fn foo25() -> u32 { BAR }\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n-  --> $DIR/min_const_fn.rs:91:36\n+  --> $DIR/min_const_fn.rs:91:37\n    |\n LL | const fn foo26() -> &'static u32 { &BAR }\n-   |                                    ^^^^\n+   |                                     ^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable"}, {"sha": "0efb6bfd10a1707034db4289b0e41bef5e1eeef8", "filename": "src/test/ui/consts/projection_qualif.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -4,20 +4,20 @@ error[E0017]: references in constants may only refer to immutable values\n LL |         let b: *mut u32 = &mut a;\n    |                           ^^^^^^ constants require immutable values\n \n-error[E0019]: constant contains unimplemented expression type\n+error[E0658]: dereferencing raw pointers in constants is unstable\n   --> $DIR/projection_qualif.rs:7:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/51911\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n-error[E0658]: dereferencing raw pointers in constants is unstable\n+error[E0019]: constant contains unimplemented expression type\n   --> $DIR/projection_qualif.rs:7:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/51911\n-   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8d875d37d85f9ceeb143ba1fe1c7a8620372c9ec", "filename": "src/test/ui/issues/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const C1: &'static mut [usize] = &mut [];\n    |                                  ^^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/issue-17718-const-bad-values.rs:5:41\n+error[E0013]: constants cannot refer to statics, use a constant instead\n+  --> $DIR/issue-17718-const-bad-values.rs:5:46\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^ constants require immutable values\n+   |                                              ^\n \n-error[E0013]: constants cannot refer to statics, use a constant instead\n+error[E0017]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^\n+   |                                         ^^^^^^ constants require immutable values\n \n error: aborting due to 3 previous errors\n "}, {"sha": "27aad9c03cebea8c02834171349fbe9fb42d2e4b", "filename": "src/test/ui/issues/issue-17718-references.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1,8 +1,8 @@\n error[E0013]: constants cannot refer to statics, use a constant instead\n-  --> $DIR/issue-17718-references.rs:9:28\n+  --> $DIR/issue-17718-references.rs:9:29\n    |\n LL | const T2: &'static usize = &S;\n-   |                            ^^\n+   |                             ^\n \n error[E0013]: constants cannot refer to statics, use a constant instead\n   --> $DIR/issue-17718-references.rs:14:19"}, {"sha": "d58822f16eb35b419d092ea65b9c0cc37d6041cd", "filename": "src/test/ui/issues/issue-18118-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -1,8 +1,8 @@\n error[E0013]: constants cannot refer to statics, use a constant instead\n-  --> $DIR/issue-18118-2.rs:4:9\n+  --> $DIR/issue-18118-2.rs:4:10\n    |\n LL |         &p\n-   |         ^^\n+   |          ^\n \n error: aborting due to previous error\n "}, {"sha": "313d39de36b6a98d6f156642c9049a109c4f1d0d", "filename": "src/test/ui/thread-local-in-ctfe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -8,14 +8,12 @@ static B: u32 = A;\n \n static C: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR thread-local variable borrowed past end of function\n \n const D: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const E: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR thread-local variable borrowed past end of function\n \n const fn f() -> u32 {\n     A"}, {"sha": "9890597b7bd5bc23e95ab4908324c337f243f3f4", "filename": "src/test/ui/thread-local-in-ctfe.stderr", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3031720d8fe850073ff3cf9509ae22eb2d2a3978/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr?ref=3031720d8fe850073ff3cf9509ae22eb2d2a3978", "patch": "@@ -5,45 +5,28 @@ LL | static B: u32 = A;\n    |                 ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:9:18\n+  --> $DIR/thread-local-in-ctfe.rs:9:19\n    |\n LL | static C: &u32 = &A;\n-   |                  ^^\n-\n-error[E0712]: thread-local variable borrowed past end of function\n-  --> $DIR/thread-local-in-ctfe.rs:9:18\n-   |\n-LL | static C: &u32 = &A;\n-   |                  ^^- end of enclosing function is here\n-   |                  |\n-   |                  thread-local variables cannot be borrowed beyond the end of the function\n+   |                   ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:13:16\n+  --> $DIR/thread-local-in-ctfe.rs:12:16\n    |\n LL | const D: u32 = A;\n    |                ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:16:17\n-   |\n-LL | const E: &u32 = &A;\n-   |                 ^^\n-\n-error[E0712]: thread-local variable borrowed past end of function\n-  --> $DIR/thread-local-in-ctfe.rs:16:17\n+  --> $DIR/thread-local-in-ctfe.rs:15:18\n    |\n LL | const E: &u32 = &A;\n-   |                 ^^- end of enclosing function is here\n-   |                 |\n-   |                 thread-local variables cannot be borrowed beyond the end of the function\n+   |                  ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:21:5\n+  --> $DIR/thread-local-in-ctfe.rs:19:5\n    |\n LL |     A\n    |     ^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0712`."}]}