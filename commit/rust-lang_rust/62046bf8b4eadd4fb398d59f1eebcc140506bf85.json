{"sha": "62046bf8b4eadd4fb398d59f1eebcc140506bf85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMDQ2YmY4YjRlYWRkNGZiMzk4ZDU5ZjFlZWJjYzE0MDUwNmJmODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-23T16:08:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-23T16:08:53Z"}, "message": "Auto merge of #1814 - RalfJung:rustup, r=RalfJung\n\navoid unnecessary RefCell calls\n\nBlocked on https://github.com/rust-lang/rust/pull/85599", "tree": {"sha": "fa79a3681b6c9a0dfd1ad9250075d9cd91fb5d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa79a3681b6c9a0dfd1ad9250075d9cd91fb5d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62046bf8b4eadd4fb398d59f1eebcc140506bf85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62046bf8b4eadd4fb398d59f1eebcc140506bf85", "html_url": "https://github.com/rust-lang/rust/commit/62046bf8b4eadd4fb398d59f1eebcc140506bf85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62046bf8b4eadd4fb398d59f1eebcc140506bf85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf7e4b9df68c8b72e556667927c50574eeaac4cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7e4b9df68c8b72e556667927c50574eeaac4cc", "html_url": "https://github.com/rust-lang/rust/commit/cf7e4b9df68c8b72e556667927c50574eeaac4cc"}, {"sha": "a03f700fc9380e881d95c62a1e5fd7b49f1dc743", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03f700fc9380e881d95c62a1e5fd7b49f1dc743", "html_url": "https://github.com/rust-lang/rust/commit/a03f700fc9380e881d95c62a1e5fd7b49f1dc743"}], "stats": {"total": 171, "additions": 102, "deletions": 69}, "files": [{"sha": "31d26ea43e46e3fa9c6c8b15c1b981fd662fabfc", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -1 +1 @@\n-6e92fb409816c65cd0a78a1fbcc71e2fbabdf50a\n+0f8cd43ee8c3614e04b5c624dd8a45758d7023da"}, {"sha": "45159ef4c07c371c26e0a5651cc9e35f9c93cbbd", "filename": "src/data_race.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -598,7 +598,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         // of the time, based on `rate`.\n         let rate = this.memory.extra.cmpxchg_weak_failure_rate;\n         let cmpxchg_success = eq.to_bool()?\n-            && (!can_fail_spuriously || this.memory.extra.rng.borrow_mut().gen::<f64>() < rate);\n+            && (!can_fail_spuriously || this.memory.extra.rng.get_mut().gen::<f64>() < rate);\n         let res = Immediate::ScalarPair(\n             old.to_scalar_or_uninit(),\n             Scalar::from_bool(cmpxchg_success).into(),\n@@ -647,7 +647,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         place: &MPlaceTy<'tcx, Tag>,\n         atomic: AtomicWriteOp,\n     ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_ref();\n+        let this = self.eval_context_mut();\n         this.validate_atomic_op(\n             place,\n             atomic,\n@@ -672,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         use AtomicRwOp::*;\n         let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n         let release = matches!(atomic, Release | AcqRel | SeqCst);\n-        let this = self.eval_context_ref();\n+        let this = self.eval_context_mut();\n         this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n             if acquire {\n                 memory.load_acquire(clocks, index)?;\n@@ -690,7 +690,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Update the data-race detector for an atomic fence on the current thread.\n     fn validate_atomic_fence(&mut self, atomic: AtomicFenceOp) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             data_race.maybe_perform_sync_operation(move |index, mut clocks| {\n                 log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n \n@@ -771,7 +771,7 @@ impl VClockAlloc {\n     }\n \n     fn reset_clocks(&mut self, offset: Size, len: Size) {\n-        let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n+        let alloc_ranges = self.alloc_ranges.get_mut();\n         for (_, range) in alloc_ranges.iter_mut(offset, len) {\n             // Reset the portion of the range\n             *range = MemoryCellClocks::new(0, VectorIdx::MAX_INDEX);\n@@ -1025,6 +1025,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         if let Some(data_race) = &this.memory.extra.data_race {\n             if data_race.multi_threaded.get() {\n                 // Load and log the atomic operation.\n+                // Note that atomic loads are possible even from read-only allocations, so `get_alloc_extra_mut` is not an option.\n                 let place_ptr = place.ptr.assert_ptr();\n                 let size = place.layout.size;\n                 let alloc_meta =\n@@ -1105,6 +1106,7 @@ struct ThreadExtraState {\n /// Global data-race detection state, contains the currently\n /// executing thread as well as the vector-clocks associated\n /// with each of the threads.\n+// FIXME: it is probably better to have one large RefCell, than to have so many small ones.\n #[derive(Debug, Clone)]\n pub struct GlobalState {\n     /// Set to true once the first additional\n@@ -1158,7 +1160,7 @@ impl GlobalState {\n     /// Create a new global state, setup with just thread-id=0\n     /// advanced to timestamp = 1.\n     pub fn new() -> Self {\n-        let global_state = GlobalState {\n+        let mut global_state = GlobalState {\n             multi_threaded: Cell::new(false),\n             vector_clocks: RefCell::new(IndexVec::new()),\n             vector_info: RefCell::new(IndexVec::new()),\n@@ -1172,9 +1174,9 @@ impl GlobalState {\n         // Setup the main-thread since it is not explicitly created:\n         // uses vector index and thread-id 0, also the rust runtime gives\n         // the main-thread a name of \"main\".\n-        let index = global_state.vector_clocks.borrow_mut().push(ThreadClockSet::default());\n-        global_state.vector_info.borrow_mut().push(ThreadId::new(0));\n-        global_state.thread_info.borrow_mut().push(ThreadExtraState {\n+        let index = global_state.vector_clocks.get_mut().push(ThreadClockSet::default());\n+        global_state.vector_info.get_mut().push(ThreadId::new(0));\n+        global_state.thread_info.get_mut().push(ThreadExtraState {\n             vector_index: Some(index),\n             thread_name: Some(\"main\".to_string().into_boxed_str()),\n             termination_vector_clock: None,\n@@ -1221,7 +1223,7 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&self, thread: ThreadId) {\n+    pub fn thread_created(&mut self, thread: ThreadId) {\n         let current_index = self.current_index();\n \n         // Increment the number of active threads.\n@@ -1241,12 +1243,12 @@ impl GlobalState {\n         let created_index = if let Some(reuse_index) = self.find_vector_index_reuse_candidate() {\n             // Now re-configure the re-use candidate, increment the clock\n             // for the new sync use of the vector.\n-            let mut vector_clocks = self.vector_clocks.borrow_mut();\n+            let vector_clocks = self.vector_clocks.get_mut();\n             vector_clocks[reuse_index].increment_clock(reuse_index);\n \n             // Locate the old thread the vector was associated with and update\n             // it to represent the new thread instead.\n-            let mut vector_info = self.vector_info.borrow_mut();\n+            let vector_info = self.vector_info.get_mut();\n             let old_thread = vector_info[reuse_index];\n             vector_info[reuse_index] = thread;\n \n@@ -1258,7 +1260,7 @@ impl GlobalState {\n         } else {\n             // No vector re-use candidates available, instead create\n             // a new vector index.\n-            let mut vector_info = self.vector_info.borrow_mut();\n+            let vector_info = self.vector_info.get_mut();\n             vector_info.push(thread)\n         };\n \n@@ -1268,7 +1270,7 @@ impl GlobalState {\n         thread_info[thread].vector_index = Some(created_index);\n \n         // Create a thread clock set if applicable.\n-        let mut vector_clocks = self.vector_clocks.borrow_mut();\n+        let vector_clocks = self.vector_clocks.get_mut();\n         if created_index == vector_clocks.next_index() {\n             vector_clocks.push(ThreadClockSet::default());\n         }\n@@ -1289,9 +1291,9 @@ impl GlobalState {\n     /// Hook on a thread join to update the implicit happens-before relation\n     /// between the joined thread and the current thread.\n     #[inline]\n-    pub fn thread_joined(&self, current_thread: ThreadId, join_thread: ThreadId) {\n-        let mut clocks_vec = self.vector_clocks.borrow_mut();\n-        let thread_info = self.thread_info.borrow();\n+    pub fn thread_joined(&mut self, current_thread: ThreadId, join_thread: ThreadId) {\n+        let clocks_vec = self.vector_clocks.get_mut();\n+        let thread_info = self.thread_info.get_mut();\n \n         // Load the vector clock of the current thread.\n         let current_index = thread_info[current_thread]\n@@ -1329,9 +1331,9 @@ impl GlobalState {\n \n         // If the thread is marked as terminated but not joined\n         // then move the thread to the re-use set.\n-        let mut termination = self.terminated_threads.borrow_mut();\n+        let termination = self.terminated_threads.get_mut();\n         if let Some(index) = termination.remove(&join_thread) {\n-            let mut reuse = self.reuse_candidates.borrow_mut();\n+            let reuse = self.reuse_candidates.get_mut();\n             reuse.insert(index);\n         }\n     }\n@@ -1344,28 +1346,28 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&self) {\n+    pub fn thread_terminated(&mut self) {\n         let current_index = self.current_index();\n \n         // Increment the clock to a unique termination timestamp.\n-        let mut vector_clocks = self.vector_clocks.borrow_mut();\n+        let vector_clocks = self.vector_clocks.get_mut();\n         let current_clocks = &mut vector_clocks[current_index];\n         current_clocks.increment_clock(current_index);\n \n         // Load the current thread id for the executing vector.\n-        let vector_info = self.vector_info.borrow();\n+        let vector_info = self.vector_info.get_mut();\n         let current_thread = vector_info[current_index];\n \n         // Load the current thread metadata, and move to a terminated\n         // vector state. Setting up the vector clock all join operations\n         // will use.\n-        let mut thread_info = self.thread_info.borrow_mut();\n+        let thread_info = self.thread_info.get_mut();\n         let current = &mut thread_info[current_thread];\n         current.termination_vector_clock = Some(current_clocks.clock.clone());\n \n         // Add this thread as a candidate for re-use after a thread join\n         // occurs.\n-        let mut termination = self.terminated_threads.borrow_mut();\n+        let termination = self.terminated_threads.get_mut();\n         termination.insert(current_thread, current_index);\n \n         // Reduce the number of active threads, now that a thread has\n@@ -1392,9 +1394,9 @@ impl GlobalState {\n     /// the thread name is used for improved diagnostics\n     /// during a data-race.\n     #[inline]\n-    pub fn thread_set_name(&self, thread: ThreadId, name: String) {\n+    pub fn thread_set_name(&mut self, thread: ThreadId, name: String) {\n         let name = name.into_boxed_str();\n-        let mut thread_info = self.thread_info.borrow_mut();\n+        let thread_info = self.thread_info.get_mut();\n         thread_info[thread].thread_name = Some(name);\n     }\n "}, {"sha": "e866868d729fa20b37826ca485730cc601ddce8b", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -119,8 +119,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // `lo.col` is 0-based - add 1 to make it 1-based for the caller.\n         let colno: u32 = lo.col.0 as u32 + 1;\n \n-        let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into());\n-        let filename_alloc = this.allocate_str(&filename, MiriMemoryKind::Rust.into());\n+        // These are \"mutable\" allocations as we consider them to be owned by the callee.\n+        let name_alloc = this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+        let filename_alloc =\n+            this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut);\n         let lineno_alloc = Scalar::from_u32(lineno);\n         let colno_alloc = Scalar::from_u32(colno);\n "}, {"sha": "06a434727b5fc3a9ff35b5af1b83f25cd19ac989", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -13,6 +13,7 @@\n \n use log::trace;\n \n+use rustc_ast::Mutability;\n use rustc_middle::{mir, ty};\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::PanicStrategy;\n@@ -169,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         // First arg: message.\n-        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into());\n+        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not);\n \n         // Call the lang item.\n         let panic = this.tcx.lang_items().panic_fn().unwrap();"}, {"sha": "4725cd9fc3c813feec5f0579e096a98519580e84", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -58,7 +58,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };"}, {"sha": "3e176d94b9902e29206eb784f3eb3d42041a0173", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -457,14 +457,29 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        global: &GlobalState,\n-        f: impl Fn(Pointer<Tag>, &mut Stack, &GlobalState) -> InterpResult<'tcx>,\n+        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n             let mut cur_ptr = ptr;\n             cur_ptr.offset = offset;\n-            f(cur_ptr, stack, &*global)?;\n+            f(cur_ptr, stack)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Call `f` on every stack in the range.\n+    fn for_each_mut(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+        f: impl Fn(Pointer<Tag>, &mut Stack) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let stacks = self.stacks.get_mut();\n+        for (offset, stack) in stacks.iter_mut(ptr.offset, size) {\n+            let mut cur_ptr = ptr;\n+            cur_ptr.offset = offset;\n+            f(cur_ptr, stack)?;\n         }\n         Ok(())\n     }\n@@ -516,9 +531,8 @@ impl Stacks {\n         extra: &MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, &*extra.borrow(), |ptr, stack, global| {\n-            stack.access(AccessKind::Read, ptr, global)\n-        })\n+        let global = &*extra.borrow();\n+        self.for_each(ptr, size, move |ptr, stack| stack.access(AccessKind::Read, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -529,9 +543,8 @@ impl Stacks {\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| {\n-            stack.access(AccessKind::Write, ptr, global)\n-        })\n+        let global = extra.get_mut();\n+        self.for_each_mut(ptr, size, move |ptr, stack| stack.access(AccessKind::Write, ptr, global))\n     }\n \n     #[inline(always)]\n@@ -542,7 +555,8 @@ impl Stacks {\n         extra: &mut MemoryExtra,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n-        self.for_each(ptr, size, extra.get_mut(), |ptr, stack, global| stack.dealloc(ptr, global))\n+        let global = extra.get_mut();\n+        self.for_each_mut(ptr, size, move |ptr, stack| stack.dealloc(ptr, global))\n     }\n }\n \n@@ -558,6 +572,18 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         new_tag: Tag,\n         protect: bool,\n     ) -> InterpResult<'tcx> {\n+        // Nothing to do for ZSTs.\n+        if size == Size::ZERO {\n+            trace!(\n+                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n+                kind,\n+                new_tag,\n+                place.ptr,\n+                place.layout.ty,\n+            );\n+            return Ok(());\n+        }\n+\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         let ptr = place.ptr.assert_ptr();\n@@ -571,12 +597,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n-        // Get the allocation. We need both the allocation and the MemoryExtra, so we cannot use `&mut`.\n-        // FIXME: make `get_alloc_extra_mut` also return `&mut MemoryExtra`.\n-        let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n-        let stacked_borrows =\n-            extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n-        let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -588,6 +608,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Shared references and *const are a whole different kind of game, the\n                 // permission is not uniform across the entire range!\n                 // We need a frozen-sensitive reborrow.\n+                // We have to use shared references to alloc/memory_extra here since\n+                // `visit_freeze_sensitive` needs to access the global state.\n+                let extra = this.memory.get_alloc_extra(ptr.alloc_id)?;\n+                let stacked_borrows =\n+                    extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n+                let global = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow();\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen {\n@@ -596,15 +622,21 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Permission::SharedReadWrite\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    stacked_borrows.for_each(cur_ptr, size, &*global, |cur_ptr, stack, global| {\n-                        stack.grant(cur_ptr, item, global)\n+                    stacked_borrows.for_each(cur_ptr, size, |cur_ptr, stack| {\n+                        stack.grant(cur_ptr, item, &*global)\n                     })\n                 });\n             }\n         };\n+        // Here we can avoid `borrow()` calls because we have mutable references.\n+        // Note that this asserts that the allocation is mutable -- but since we are creating a\n+        // mutable pointer, that seems reasonable.\n+        let (alloc_extra, memory_extra) = this.memory.get_alloc_extra_mut(ptr.alloc_id)?;\n+        let stacked_borrows =\n+            alloc_extra.stacked_borrows.as_mut().expect(\"we should have Stacked Borrows data\");\n+        let global = memory_extra.stacked_borrows.as_mut().unwrap().get_mut();\n         let item = Item { perm, tag: new_tag, protector };\n-        stacked_borrows\n-            .for_each(ptr, size, &*global, |ptr, stack, global| stack.grant(ptr, item, global))\n+        stacked_borrows.for_each_mut(ptr, size, |ptr, stack| stack.grant(ptr, item, global))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -631,16 +663,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We can see dangling ptrs in here e.g. after a Box's `Unique` was\n         // updated using \"self.0 = ...\" (can happen in Box::from_raw) so we cannot ICE; see miri#1050.\n         let place = this.mplace_access_checked(place, Some(Align::from_bytes(1).unwrap()))?;\n-        // Nothing to do for ZSTs. We use `is_bits` here because we *do* need to retag even ZSTs\n-        // when there actually is a tag (to avoid inheriting a tag that would let us access more\n-        // than 0 bytes).\n-        if size == Size::ZERO && place.ptr.is_bits() {\n-            return Ok(*val);\n-        }\n \n         // Compute new borrow.\n         let new_tag = {\n-            let mut mem_extra = this.memory.extra.stacked_borrows.as_ref().unwrap().borrow_mut();\n+            let mem_extra = this.memory.extra.stacked_borrows.as_mut().unwrap().get_mut();\n             match kind {\n                 // Give up tracking for raw pointers.\n                 RefKind::Raw { .. } if !mem_extra.track_raw => Tag::Untagged,"}, {"sha": "7ee18bb7f80e28ce8cdcb02ca20fcd091c0d5a91", "filename": "src/thread.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn join_thread(\n         &mut self,\n         joined_thread_id: ThreadId,\n-        data_race: &Option<data_race::GlobalState>,\n+        data_race: Option<&mut data_race::GlobalState>,\n     ) -> InterpResult<'tcx> {\n         if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n             throw_ub_format!(\"trying to join a detached or already joined thread\");\n@@ -436,7 +436,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Wakes up threads joining on the active one and deallocates thread-local statics.\n     /// The `AllocId` that can now be freed is returned.\n-    fn thread_terminated(&mut self, data_race: &Option<data_race::GlobalState>) -> Vec<AllocId> {\n+    fn thread_terminated(\n+        &mut self,\n+        mut data_race: Option<&mut data_race::GlobalState>,\n+    ) -> Vec<AllocId> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -452,14 +455,14 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             });\n         }\n         // Set the thread into a terminated state in the data-race detector\n-        if let Some(data_race) = data_race {\n+        if let Some(ref mut data_race) = data_race {\n             data_race.thread_terminated();\n         }\n         // Check if we need to unblock any threads.\n         for (i, thread) in self.threads.iter_enumerated_mut() {\n             if thread.state == ThreadState::BlockedOnJoin(self.active_thread) {\n                 // The thread has terminated, mark happens-before edge to joining thread\n-                if let Some(data_race) = data_race {\n+                if let Some(ref mut data_race) = data_race {\n                     data_race.thread_joined(i, self.active_thread);\n                 }\n                 trace!(\"unblocking {:?} because {:?} terminated\", i, self.active_thread);\n@@ -584,7 +587,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn create_thread(&mut self) -> ThreadId {\n         let this = self.eval_context_mut();\n         let id = this.machine.threads.create_thread();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             data_race.thread_created(id);\n         }\n         id\n@@ -599,8 +602,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.memory.extra.data_race;\n-        this.machine.threads.join_thread(joined_thread_id, data_race)?;\n+        this.machine.threads.join_thread(joined_thread_id, this.memory.extra.data_race.as_mut())?;\n         Ok(())\n     }\n \n@@ -664,7 +666,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn set_active_thread_name(&mut self, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();\n-        if let Some(data_race) = &this.memory.extra.data_race {\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n             if let Ok(string) = String::from_utf8(new_thread_name.clone()) {\n                 data_race.thread_set_name(this.machine.threads.active_thread, string);\n             }\n@@ -759,8 +761,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn thread_terminated(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let data_race = &this.memory.extra.data_race;\n-        for alloc_id in this.machine.threads.thread_terminated(data_race) {\n+        for alloc_id in this.machine.threads.thread_terminated(this.memory.extra.data_race.as_mut())\n+        {\n             let ptr = this.memory.global_base_pointer(alloc_id.into())?;\n             this.memory.deallocate(ptr, None, MiriMemoryKind::Tls.into())?;\n         }"}, {"sha": "55a7f816c0340fcd463deefcdc4e8db9664c39e2", "filename": "tests/compile-fail/stacked_borrows/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62046bf8b4eadd4fb398d59f1eebcc140506bf85/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62046bf8b4eadd4fb398d59f1eebcc140506bf85/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=62046bf8b4eadd4fb398d59f1eebcc140506bf85", "patch": "@@ -3,6 +3,6 @@ static X: usize = 5;\n #[allow(mutable_transmutes)]\n fn main() {\n     let _x = unsafe {\n-        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR borrow stack\n+        std::mem::transmute::<&usize, &mut usize>(&X) //~ ERROR writing to alloc0 which is read-only\n     };\n }"}]}