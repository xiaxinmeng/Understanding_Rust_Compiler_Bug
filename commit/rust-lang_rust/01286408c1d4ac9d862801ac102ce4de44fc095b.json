{"sha": "01286408c1d4ac9d862801ac102ce4de44fc095b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMjg2NDA4YzFkNGFjOWQ4NjI4MDFhYzEwMmNlNGRlNDRmYzA5NWI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-19T23:57:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-02-28T19:37:59Z"}, "message": "Account for arbitrary self types in E0599", "tree": {"sha": "a8bda7752acd9a00d3df68817a214c8066def7b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8bda7752acd9a00d3df68817a214c8066def7b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01286408c1d4ac9d862801ac102ce4de44fc095b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01286408c1d4ac9d862801ac102ce4de44fc095b", "html_url": "https://github.com/rust-lang/rust/commit/01286408c1d4ac9d862801ac102ce4de44fc095b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01286408c1d4ac9d862801ac102ce4de44fc095b/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "392d853589721ffef1f32181d6c3959f0284e4fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/392d853589721ffef1f32181d6c3959f0284e4fb", "html_url": "https://github.com/rust-lang/rust/commit/392d853589721ffef1f32181d6c3959f0284e4fb"}], "stats": {"total": 77, "additions": 60, "deletions": 17}, "files": [{"sha": "cfd6356b0a1579def18e5df275ff9c7f3d43ef21", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=01286408c1d4ac9d862801ac102ce4de44fc095b", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::intravisit;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n+use rustc_span::symbol::kw;\n use rustc_span::{source_map, FileName, Span};\n use syntax::ast;\n use syntax::util::lev_distance;\n@@ -893,6 +894,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let type_is_local = self.type_derefs_to_local(span, rcvr_ty, source);\n \n+        let mut arbitrary_rcvr = vec![];\n         // There are no traits implemented, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n         // legal to implement.\n@@ -909,12 +911,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && self\n                         .associated_item(info.def_id, item_name, Namespace::ValueNS)\n                         .filter(|item| {\n+                            if let ty::AssocKind::Method = item.kind {\n+                                let id = self.tcx.hir().as_local_hir_id(item.def_id);\n+                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                    kind: hir::TraitItemKind::Method(fn_sig, method),\n+                                    ..\n+                                })) = id.map(|id| self.tcx.hir().get(id))\n+                                {\n+                                    let self_first_arg = match method {\n+                                        hir::TraitMethod::Required([ident, ..]) => {\n+                                            ident.name == kw::SelfLower\n+                                        }\n+                                        hir::TraitMethod::Provided(body_id) => {\n+                                            match &self.tcx.hir().body(*body_id).params[..] {\n+                                                [hir::Param {\n+                                                    pat:\n+                                                        hir::Pat {\n+                                                            kind:\n+                                                                hir::PatKind::Binding(\n+                                                                    _,\n+                                                                    _,\n+                                                                    ident,\n+                                                                    ..,\n+                                                                ),\n+                                                            ..\n+                                                        },\n+                                                    ..\n+                                                }, ..] => ident.name == kw::SelfLower,\n+                                                _ => false,\n+                                            }\n+                                        }\n+                                        _ => false,\n+                                    };\n+\n+                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                        && self_first_arg\n+                                    {\n+                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                            arbitrary_rcvr.push(ty.span);\n+                                        }\n+                                        return false;\n+                                    }\n+                                }\n+                            }\n                             // We only want to suggest public or local traits (#45781).\n                             item.vis == ty::Visibility::Public || info.def_id.is_local()\n                         })\n                         .is_some()\n             })\n             .collect::<Vec<_>>();\n+        for span in &arbitrary_rcvr {\n+            err.span_label(\n+                *span,\n+                \"the method might not be found because of this arbitrary self type\",\n+            );\n+        }\n \n         if !candidates.is_empty() {\n             // Sort from most relevant to least relevant."}, {"sha": "93aaf4b9d823758dd83840a8fb5327e79e228613", "filename": "src/test/ui/issues/issue-5153.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fissues%2Fissue-5153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fissues%2Fissue-5153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5153.stderr?ref=01286408c1d4ac9d862801ac102ce4de44fc095b", "patch": "@@ -1,13 +1,11 @@\n error[E0599]: no method named `foo` found for reference `&dyn Foo` in the current scope\n   --> $DIR/issue-5153.rs:10:27\n    |\n-LL | trait Foo {\n-   | --------- `Foo` defines an item `foo`, perhaps you need to implement it\n+LL |     fn foo(self: Box<Self>);\n+   |                  --------- the method might not be found because of this arbitrary self type\n ...\n LL |     (&5isize as &dyn Foo).foo();\n    |                           ^^^ method not found in `&dyn Foo`\n-   |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n \n error: aborting due to previous error\n "}, {"sha": "021aa8670f78f7b46027091c63ea6c4e008247fb", "filename": "src/test/ui/object-pointer-types.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fobject-pointer-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fobject-pointer-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-pointer-types.stderr?ref=01286408c1d4ac9d862801ac102ce4de44fc095b", "patch": "@@ -1,24 +1,20 @@\n error[E0599]: no method named `owned` found for reference `&dyn Foo` in the current scope\n   --> $DIR/object-pointer-types.rs:11:7\n    |\n-LL | trait Foo {\n-   | --------- `Foo` defines an item `owned`, perhaps you need to implement it\n+LL |     fn owned(self: Box<Self>);\n+   |                    --------- the method might not be found because of this arbitrary self type\n ...\n LL |     x.owned();\n    |       ^^^^^ method not found in `&dyn Foo`\n-   |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n \n error[E0599]: no method named `owned` found for mutable reference `&mut dyn Foo` in the current scope\n   --> $DIR/object-pointer-types.rs:17:7\n    |\n-LL | trait Foo {\n-   | --------- `Foo` defines an item `owned`, perhaps you need to implement it\n+LL |     fn owned(self: Box<Self>);\n+   |                    --------- the method might not be found because of this arbitrary self type\n ...\n LL |     x.owned();\n    |       ^^^^^ method not found in `&mut dyn Foo`\n-   |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n \n error[E0599]: no method named `managed` found for struct `std::boxed::Box<(dyn Foo + 'static)>` in the current scope\n   --> $DIR/object-pointer-types.rs:23:7"}, {"sha": "37873031da3e982ad9847868c3023f2e0d9ea917", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01286408c1d4ac9d862801ac102ce4de44fc095b/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr?ref=01286408c1d4ac9d862801ac102ce4de44fc095b", "patch": "@@ -2,16 +2,14 @@ error[E0599]: no method named `foo` found for struct `A` in the current scope\n   --> $DIR/point-at-arbitrary-self-type-trait-method.rs:9:7\n    |\n LL | trait B { fn foo(self: Box<Self>); }\n-   | -------      --- the method is available for `std::boxed::Box<A>` here\n-   | |\n-   | `B` defines an item `foo`, perhaps you need to implement it\n+   |              ---       --------- the method might not be found because of this arbitrary self type\n+   |              |\n+   |              the method is available for `std::boxed::Box<A>` here\n LL | struct A;\n    | --------- method `foo` not found for this\n ...\n LL |     A.foo()\n    |       ^^^ method not found in `A`\n-   |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n \n error: aborting due to previous error\n "}]}