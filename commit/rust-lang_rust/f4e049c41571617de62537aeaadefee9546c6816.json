{"sha": "f4e049c41571617de62537aeaadefee9546c6816", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZTA0OWM0MTU3MTYxN2RlNjI1MzdhZWFhZGVmZWU5NTQ2YzY4MTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T05:15:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T05:21:31Z"}, "message": "rustc: Thread a statement context through the typechecker; use it for generating variable IDs. 40% typechecking speedup.", "tree": {"sha": "44f2f4d346fea9167b692c9c359f436055e7e277", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44f2f4d346fea9167b692c9c359f436055e7e277"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4e049c41571617de62537aeaadefee9546c6816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e049c41571617de62537aeaadefee9546c6816", "html_url": "https://github.com/rust-lang/rust/commit/f4e049c41571617de62537aeaadefee9546c6816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4e049c41571617de62537aeaadefee9546c6816/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49b90d37eddc0b1fc518f44ce9bc7eafcde77ba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/49b90d37eddc0b1fc518f44ce9bc7eafcde77ba4", "html_url": "https://github.com/rust-lang/rust/commit/49b90d37eddc0b1fc518f44ce9bc7eafcde77ba4"}], "stats": {"total": 988, "additions": 527, "deletions": 461}, "files": [{"sha": "8dee831ffbda212f0edbd0494ff7ff10b4b6dae1", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 527, "deletions": 461, "changes": 988, "blob_url": "https://github.com/rust-lang/rust/blob/f4e049c41571617de62537aeaadefee9546c6816/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4e049c41571617de62537aeaadefee9546c6816/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f4e049c41571617de62537aeaadefee9546c6816", "patch": "@@ -69,7 +69,6 @@ type crate_ctxt = rec(session::session sess,\n                       @ty_item_table item_items,\n                       mutable vec[obj_info] obj_infos,\n                       @fn_purity_table fn_purity_table,\n-                      mutable int next_var_id,\n                       unify_cache unify_cache,\n                       mutable uint cache_hits,\n                       mutable uint cache_misses,\n@@ -81,9 +80,23 @@ type fn_ctxt = rec(ty::t ret_ty,\n                    @ty_table locals,\n                    @crate_ctxt ccx);\n \n+type stmt_ctxt = rec(@fn_ctxt fcx,\n+                     mutable int next_var_id,\n+                     mutable vec[uint] fixups);\n+\n // Used for ast_ty_to_ty() below.\n type ty_getter = fn(&ast::def_id) -> ty::ty_param_count_and_ty;\n \n+// Creates a statement context and passes it to the given thunk, then runs\n+// fixups. This function has the signature it does so that the caller can\n+// never forget to run fixups!\n+fn with_stmt_ctxt(&@fn_ctxt fcx, fn(&@stmt_ctxt) f) {\n+    let vec[uint] fixups = [];\n+    auto scx = @rec(fcx=fcx, mutable next_var_id=0, mutable fixups=fixups);\n+    f(scx);\n+    // TODO: run fixups\n+}\n+\n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n@@ -182,33 +195,36 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast::span sp, &ast::def defn)\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n+fn instantiate_path(&@stmt_ctxt scx,\n+                    &ast::path pth,\n+                    &ty_param_count_and_ty tpt,\n                     &span sp) -> ty_param_substs_opt_and_ty {\n     auto ty_param_count = tpt._0;\n-    auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n+    auto t = bind_params_in_type(scx.fcx.ccx.tcx, tpt._1);\n \n     auto ty_substs_opt;\n     auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n         let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_substs_len) {\n-            ty_substs += [ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i))];\n+            ty_substs += [ast_ty_to_ty_crate(scx.fcx.ccx,\n+                                             pth.node.types.(i))];\n             i += 1u;\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n \n         if (ty_param_count == 0u) {\n-            fcx.ccx.sess.span_err(sp, \"this item does not take type \" +\n-                                  \"parameters\");\n+            scx.fcx.ccx.sess.span_err(sp, \"this item does not take type \" +\n+                                      \"parameters\");\n             fail;\n         }\n     } else {\n         // We will acquire the type parameters through unification.\n         let vec[ty::t] ty_substs = [];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            ty_substs += [next_ty_var(fcx.ccx)];\n+            ty_substs += [next_ty_var(scx)];\n             i += 1u;\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n@@ -1182,39 +1198,39 @@ mod Pushdown {\n     // TODO: enforce this via a predicate.\n     // TODO: This function is incomplete.\n \n-    fn pushdown_expr(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e) {\n-        be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n+    fn pushdown_expr(&@stmt_ctxt scx, &ty::t expected, &@ast::expr e) {\n+        be pushdown_expr_full(scx, expected, e, NO_AUTODEREF);\n     }\n \n-    fn pushdown_expr_full(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e,\n+    fn pushdown_expr_full(&@stmt_ctxt scx, &ty::t expected, &@ast::expr e,\n                           autoderef_kind adk) {\n         alt (e.node) {\n             case (ast::expr_vec(?es_0, ?mut, ?ann)) {\n                 // TODO: enforce mutability\n \n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_vec(?mt)) {\n                         for (@ast::expr e_0 in es_0) {\n-                            pushdown_expr(fcx, mt.ty, e_0);\n+                            pushdown_expr(scx, mt.ty, e_0);\n                         }\n                     }\n                     case (_) {\n                         log_err \"vec expr doesn't have a vec type!\";\n                         fail;\n                     }\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_tup(?es_0, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_tup(?mts)) {\n                         auto i = 0u;\n                         for (ast::elt elt_0 in es_0) {\n-                            pushdown_expr(fcx, mts.(i).ty, elt_0.expr);\n+                            pushdown_expr(scx, mts.(i).ty, elt_0.expr);\n                             i += 1u;\n                         }\n                     }\n@@ -1223,21 +1239,21 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n \n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_rec(?field_mts)) {\n                         alt (base_0) {\n                             case (none[@ast::expr]) {\n                                 auto i = 0u;\n                                 for (ast::field field_0 in fields_0) {\n                                     assert (str::eq(field_0.ident,\n                                                     field_mts.(i).ident));\n-                                    pushdown_expr(fcx,\n+                                    pushdown_expr(scx,\n                                                   field_mts.(i).mt.ty,\n                                                   field_0.expr);\n                                     i += 1u;\n@@ -1252,7 +1268,7 @@ mod Pushdown {\n                                     for (ty::field ft in field_mts) {\n                                         if (str::eq(field_0.ident,\n                                                     ft.ident)) {\n-                                            pushdown_expr(fcx, ft.mt.ty,\n+                                            pushdown_expr(scx, ft.mt.ty,\n                                                           field_0.expr);\n                                         }\n                                     }\n@@ -1265,125 +1281,125 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_bind(?sube, ?es, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n                 // cases where e is an expression that could *possibly*\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_self_method(?id, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                       ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand::autoderef.\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_lit(?lit, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                pushdown_block(fcx, expected, then_0);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                pushdown_block(scx, expected, then_0);\n \n                 alt (else_0) {\n                     case (none[@ast::expr]) { /* no-op */ }\n                     case (some[@ast::expr](?e_0)) {\n-                        pushdown_expr(fcx, expected, e_0);\n+                        pushdown_expr(scx, expected, e_0);\n                     }\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_while(?cond, ?bloc, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_block(?bloc, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                pushdown_expr(fcx, expected, lhs_0);\n-                pushdown_expr(fcx, expected, rhs_0);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                pushdown_expr(scx, expected, lhs_0);\n+                pushdown_expr(scx, expected, rhs_0);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                pushdown_expr(fcx, expected, lhs_0);\n-                pushdown_expr(fcx, expected, rhs_0);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                pushdown_expr(scx, expected, lhs_0);\n+                pushdown_expr(scx, expected, rhs_0);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_index(?base, ?index, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             case (ast::expr_path(?pth, ?ann)) {\n-                auto tp_substs_0 = ty::ann_to_type_params(fcx.ccx.node_types,\n-                                                          ann);\n-                auto t_0 = ann_to_type(fcx.ccx.node_types, ann);\n+                auto tp_substs_0 =\n+                    ty::ann_to_type_params(scx.fcx.ccx.node_types, ann);\n+                auto t_0 = ann_to_type(scx.fcx.ccx.node_types, ann);\n \n-                auto result_0 = Demand::full(fcx, e.span, expected, t_0,\n+                auto result_0 = Demand::full(scx.fcx, e.span, expected, t_0,\n                                              tp_substs_0, adk);\n                 auto t = result_0._1;\n \n                 // Fill in the type parameter substitutions if they weren't\n                 // provided by the programmer.\n                 auto ty_params_opt;\n-                alt (ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.node_types,\n-                                                           ann)._0) {\n+                alt (ty::ann_to_ty_param_substs_opt_and_ty\n+                        (scx.fcx.ccx.node_types, ann)._0) {\n                     case (none[vec[ty::t]]) {\n                         ty_params_opt = none[vec[ty::t]];\n                     }\n@@ -1392,12 +1408,13 @@ mod Pushdown {\n                     }\n                 }\n \n-                write_type(fcx.ccx.node_types, ann.id, tup(ty_params_opt, t));\n+                write_type(scx.fcx.ccx.node_types, ann.id,\n+                           tup(ty_params_opt, t));\n             }\n             case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast::expr_fail(_))  { /* no-op */ }\n@@ -1411,62 +1428,65 @@ mod Pushdown {\n             case (ast::expr_assert(_,_)) { /* no-op */ }\n \n             case (ast::expr_port(?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_chan(?es, ?ann)) {\n-                auto t = Demand::simple(fcx, e.span, expected,\n-                                        ann_to_type(fcx.ccx.node_types, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n+                auto t = Demand::simple(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann));\n+                alt (struct(scx.fcx.ccx.tcx, t)) {\n                     case (ty::ty_chan(?subty)) {\n-                        auto pt = ty::mk_port(fcx.ccx.tcx, subty);\n-                        pushdown_expr(fcx, pt, es);\n+                        auto pt = ty::mk_port(scx.fcx.ccx.tcx, subty);\n+                        pushdown_expr(scx, pt, es);\n                     }\n                     case (_) {\n                         log \"chan expr doesn't have a chan type!\";\n                         fail;\n                     }\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n                 auto t = expected;\n                 for (ast::arm arm_0 in arms_0) {\n-                    pushdown_block(fcx, expected, arm_0.block);\n-                    auto bty = block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                    pushdown_block(scx, expected, arm_0.block);\n+                    auto bty = block_ty(scx.fcx.ccx.tcx,\n+                                        scx.fcx.ccx.node_types,\n                                         arm_0.block);\n-                    t = Demand::simple(fcx, e.span, t, bty);\n+                    t = Demand::simple(scx.fcx, e.span, t, bty);\n                 }\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (ast::expr_recv(?lval, ?expr, ?ann)) {\n-                pushdown_expr(fcx, next_ty_var(fcx.ccx), lval);\n-                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lval);\n-                pushdown_expr(fcx, ty::mk_port(fcx.ccx.tcx, t), expr);\n+                pushdown_expr(scx, next_ty_var(scx), lval);\n+                auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 lval);\n+                pushdown_expr(scx, ty::mk_port(scx.fcx.ccx.tcx, t), expr);\n             }\n \n             case (ast::expr_send(?lval, ?expr, ?ann)) {\n-                pushdown_expr(fcx, next_ty_var(fcx.ccx), expr);\n-                auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n-                pushdown_expr(fcx, ty::mk_chan(fcx.ccx.tcx, t), lval);\n+                pushdown_expr(scx, next_ty_var(scx), expr);\n+                auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 expr);\n+                pushdown_expr(scx, ty::mk_chan(scx.fcx.ccx.tcx, t), lval);\n             }\n \n             case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?ann)) {\n                 // NB: we call 'Demand::autoderef' and pass in adk only in\n                 // cases where e is an expression that could *possibly*\n                 // produce a box; things like expr_binary or expr_bind can't,\n                 // so there's no need.\n-                auto t = Demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.node_types, ann), adk);\n-                write_type_only(fcx.ccx.node_types, ann.id, t);\n+                auto t = Demand::autoderef(scx.fcx, e.span, expected,\n+                    ann_to_type(scx.fcx.ccx.node_types, ann), adk);\n+                write_type_only(scx.fcx.ccx.node_types, ann.id, t);\n             }\n \n             case (_) {\n-                fcx.ccx.sess.span_unimpl(e.span,\n+                scx.fcx.ccx.sess.span_unimpl(e.span,\n                     #fmt(\"type unification for expression variant: %s\",\n                          util::common::expr_to_str(e)));\n                 fail;\n@@ -1475,17 +1495,17 @@ mod Pushdown {\n     }\n \n     // Push-down over typed blocks.\n-    fn pushdown_block(&@fn_ctxt fcx, &ty::t expected, &ast::block bloc) {\n+    fn pushdown_block(&@stmt_ctxt scx, &ty::t expected, &ast::block bloc) {\n         alt (bloc.node.expr) {\n             case (some[@ast::expr](?e_0)) {\n-                pushdown_expr(fcx, expected, e_0);\n-                write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n+                pushdown_expr(scx, expected, e_0);\n+                write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                bloc.node.a.id);\n             }\n             case (none[@ast::expr]) {\n-                Demand::simple(fcx, bloc.span, expected,\n-                               ty::mk_nil(fcx.ccx.tcx));\n-                write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n+                Demand::simple(scx.fcx, bloc.span, expected,\n+                               ty::mk_nil(scx.fcx.ccx.tcx));\n+                write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                bloc.node.a.id);\n             }\n         }\n@@ -1615,35 +1635,35 @@ fn check_lit(@crate_ctxt ccx, &@ast::lit lit) -> ty::t {\n     fail; // not reached\n }\n \n-fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n+fn check_pat(&@stmt_ctxt scx, &@ast::pat pat) {\n     alt (pat.node) {\n         case (ast::pat_wild(?ann)) {\n-            auto typ = next_ty_var(fcx.ccx);\n-            write_type_only(fcx.ccx.node_types, ann.id, typ);\n+            auto typ = next_ty_var(scx);\n+            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_lit(?lt, ?ann)) {\n-            auto typ = check_lit(fcx.ccx, lt);\n-            write_type_only(fcx.ccx.node_types, ann.id, typ);\n+            auto typ = check_lit(scx.fcx.ccx, lt);\n+            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_bind(?id, ?def_id, ?a)) {\n-            auto typ = next_ty_var(fcx.ccx);\n+            auto typ = next_ty_var(scx);\n             auto ann = triv_ann(a.id, typ);\n-            write_type_only(fcx.ccx.node_types, ann.id, typ);\n+            write_type_only(scx.fcx.ccx.node_types, ann.id, typ);\n         }\n         case (ast::pat_tag(?p, ?subpats, ?old_ann)) {\n             auto vdef = ast::variant_def_ids\n-                (fcx.ccx.tcx.def_map.get(old_ann.id));\n-            auto t = ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                          fcx.ccx.type_cache, vdef._1)._1;\n+                (scx.fcx.ccx.tcx.def_map.get(old_ann.id));\n+            auto t = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n+                                          scx.fcx.ccx.type_cache, vdef._1)._1;\n             auto len = vec::len[ast::ident](p.node.idents);\n             auto last_id = p.node.idents.(len - 1u);\n \n-            auto tpt = ty::lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n-                                           fcx.ccx.type_cache, vdef._0);\n+            auto tpt = ty::lookup_item_type(scx.fcx.ccx.sess, scx.fcx.ccx.tcx,\n+                                            scx.fcx.ccx.type_cache, vdef._0);\n \n-            auto path_tpot = instantiate_path(fcx, p, tpt, pat.span);\n+            auto path_tpot = instantiate_path(scx, p, tpt, pat.span);\n \n-            alt (struct(fcx.ccx.tcx, t)) {\n+            alt (struct(scx.fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n                 case (ty::ty_fn(_, ?args, ?tag_ty)) {\n                     auto arg_len = vec::len[arg](args);\n@@ -1656,15 +1676,15 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n                                        uint::to_str(arg_len, 10u) +\n                                        \" field(s)\";\n \n-                        fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        scx.fcx.ccx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n                     }\n \n                     for (@ast::pat subpat in subpats) {\n-                        check_pat(fcx, subpat);\n+                        check_pat(scx, subpat);\n                     }\n \n-                    write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n+                    write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n                 }\n \n                 // Nullary variants have tag types.\n@@ -1678,11 +1698,11 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat) {\n                                        uint::to_str(subpats_len, 10u) +\n                                        \" field(s)\";\n \n-                        fcx.ccx.sess.span_err(pat.span, err_msg);\n+                        scx.fcx.ccx.sess.span_err(pat.span, err_msg);\n                         fail;   // TODO: recover\n                     }\n \n-                    write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n+                    write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n                 }\n             }\n         }\n@@ -1750,230 +1770,243 @@ fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) -> () {\n     }\n }\n \n-fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n+fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n     //fcx.ccx.sess.span_warn(expr.span, \"typechecking expr \" +\n     //                       util::common::expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(&@fn_ctxt fcx, &@ast::expr f,\n+    fn check_call_or_bind(&@stmt_ctxt scx, &@ast::expr f,\n                           &vec[option::t[@ast::expr]] args) {\n \n         // Check the function.\n-        check_expr(fcx, f);\n+        check_expr(scx, f);\n \n         // Check the arguments and generate the argument signature.\n         let vec[option::t[@ast::expr]] args_0 = [];\n         let vec[arg] arg_tys_0 = [];\n         for (option::t[@ast::expr] a_opt in args) {\n             alt (a_opt) {\n                 case (some[@ast::expr](?a)) {\n-                    check_expr(fcx, a);\n-                    auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, a);\n+                    check_expr(scx, a);\n+                    auto typ = expr_ty(scx.fcx.ccx.tcx,\n+                                       scx.fcx.ccx.node_types, a);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n                 case (none[@ast::expr]) {\n-                    auto typ = next_ty_var(fcx.ccx);\n+                    auto typ = next_ty_var(scx);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n             }\n         }\n \n-        auto rt_0 = next_ty_var(fcx.ccx);\n+        auto rt_0 = next_ty_var(scx);\n         auto t_0;\n-        alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                         f))) {\n+        alt (struct(scx.fcx.ccx.tcx,\n+                    expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f))) {\n             case (ty::ty_fn(?proto, _, _))   {\n-                t_0 = ty::mk_fn(fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n+                t_0 = ty::mk_fn(scx.fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n             }\n             case (ty::ty_native_fn(?abi, _, _))   {\n-                t_0 = ty::mk_native_fn(fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n+                t_0 = ty::mk_native_fn(scx.fcx.ccx.tcx, abi, arg_tys_0, rt_0);\n             }\n             case (?u) {\n-                fcx.ccx.sess.span_err(f.span,\n-                \"check_call_or_bind(): fn expr doesn't have fn type,\"\n-                + \" instead having: \" +\n-                ty_to_str(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx,\n-                                               fcx.ccx.node_types, f)));\n+                scx.fcx.ccx.sess.span_err(f.span,\n+                    \"check_call_or_bind(): fn expr doesn't have fn type,\"\n+                    + \" instead having: \" +\n+                    ty_to_str(scx.fcx.ccx.tcx,\n+                              expr_ty(scx.fcx.ccx.tcx,\n+                                      scx.fcx.ccx.node_types, f)));\n                 fail;\n             }\n         }\n \n         // Unify the callee and arguments.\n-        auto tpt_0 = ty::expr_ty_params_and_ty(fcx.ccx.tcx,\n-                                               fcx.ccx.node_types, f);\n-        auto tpt_1 = Demand::full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n-                                 NO_AUTODEREF);\n-        replace_expr_type(fcx.ccx.node_types, f, tpt_1);\n+        auto tpt_0 = ty::expr_ty_params_and_ty(scx.fcx.ccx.tcx,\n+                                               scx.fcx.ccx.node_types, f);\n+        auto tpt_1 = Demand::full(scx.fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n+                                  NO_AUTODEREF);\n+        replace_expr_type(scx.fcx.ccx.node_types, f, tpt_1);\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(&@fn_ctxt fcx, &@ast::expr lhs, &@ast::expr rhs,\n+    fn check_assignment(&@stmt_ctxt scx, &@ast::expr lhs, &@ast::expr rhs,\n                         &ast::ann a) {\n-        check_expr(fcx, lhs);\n-        check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n-        auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n+        check_expr(scx, lhs);\n+        check_expr(scx, rhs);\n+        auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, lhs);\n+        auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, rhs);\n \n-        Pushdown::pushdown_expr(fcx, rhs_t0, lhs);\n-        auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n-        Pushdown::pushdown_expr(fcx, lhs_t1, rhs);\n-        auto rhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n+        Pushdown::pushdown_expr(scx, rhs_t0, lhs);\n+        auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, lhs);\n+        Pushdown::pushdown_expr(scx, lhs_t1, rhs);\n+        auto rhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, rhs);\n \n         auto ann = triv_ann(a.id, rhs_t1);\n-        write_type_only(fcx.ccx.node_types, a.id, rhs_t1);\n+        write_type_only(scx.fcx.ccx.node_types, a.id, rhs_t1);\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(&@fn_ctxt fcx, &@ast::expr f, &vec[@ast::expr] args) {\n+    fn check_call(&@stmt_ctxt scx, &@ast::expr f, &vec[@ast::expr] args) {\n         let vec[option::t[@ast::expr]] args_opt_0 = [];\n         for (@ast::expr arg in args) {\n             args_opt_0 += [some[@ast::expr](arg)];\n         }\n \n         // Call the generic checker.\n-        check_call_or_bind(fcx, f, args_opt_0);\n+        check_call_or_bind(scx, f, args_opt_0);\n     }\n \n     alt (expr.node) {\n         case (ast::expr_lit(?lit, ?a)) {\n-            auto typ = check_lit(fcx.ccx, lit);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = check_lit(scx.fcx.ccx, lit);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n-            check_expr(fcx, lhs);\n-            check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n-            auto rhs_t0 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n+            check_expr(scx, lhs);\n+            check_expr(scx, rhs);\n+            auto lhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  lhs);\n+            auto rhs_t0 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  rhs);\n \n             // FIXME: Binops have a bit more subtlety than this.\n-            Pushdown::pushdown_expr_full(fcx, rhs_t0, lhs, AUTODEREF_OK);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n-            Pushdown::pushdown_expr_full(fcx, lhs_t1, rhs, AUTODEREF_OK);\n+            Pushdown::pushdown_expr_full(scx, rhs_t0, lhs, AUTODEREF_OK);\n+            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  lhs);\n+            Pushdown::pushdown_expr_full(scx, lhs_t1, rhs, AUTODEREF_OK);\n \n-            auto t = strip_boxes(fcx.ccx.tcx, lhs_t0);\n+            auto t = strip_boxes(scx.fcx.ccx.tcx, lhs_t0);\n             alt (binop) {\n-                case (ast::eq) { t = ty::mk_bool(fcx.ccx.tcx); }\n-                case (ast::lt) { t = ty::mk_bool(fcx.ccx.tcx); }\n-                case (ast::le) { t = ty::mk_bool(fcx.ccx.tcx); }\n-                case (ast::ne) { t = ty::mk_bool(fcx.ccx.tcx); }\n-                case (ast::ge) { t = ty::mk_bool(fcx.ccx.tcx); }\n-                case (ast::gt) { t = ty::mk_bool(fcx.ccx.tcx); }\n+                case (ast::eq) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n+                case (ast::lt) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n+                case (ast::le) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n+                case (ast::ne) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n+                case (ast::ge) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n+                case (ast::gt) { t = ty::mk_bool(scx.fcx.ccx.tcx); }\n                 case (_) { /* fall through */ }\n             }\n \n-            write_type_only(fcx.ccx.node_types, a.id, t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n         }\n \n         case (ast::expr_unary(?unop, ?oper, ?a)) {\n-            check_expr(fcx, oper);\n+            check_expr(scx, oper);\n \n-            auto oper_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, oper);\n+            auto oper_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  oper);\n             alt (unop) {\n                 case (ast::box(?mut)) {\n-                    oper_t = ty::mk_box(fcx.ccx.tcx, rec(ty=oper_t, mut=mut));\n+                    oper_t = ty::mk_box(scx.fcx.ccx.tcx,\n+                                        rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast::deref) {\n-                    alt (struct(fcx.ccx.tcx, oper_t)) {\n+                    alt (struct(scx.fcx.ccx.tcx, oper_t)) {\n                         case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n                         case (_) {\n-                            fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"dereferencing non-box type: \"\n-                                 + ty_to_str(fcx.ccx.tcx, oper_t));\n+                                 + ty_to_str(scx.fcx.ccx.tcx, oper_t));\n                         }\n                     }\n                 }\n-                case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n+                case (_) { oper_t = strip_boxes(scx.fcx.ccx.tcx, oper_t); }\n             }\n \n-            write_type_only(fcx.ccx.node_types, a.id, oper_t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, oper_t);\n         }\n \n         case (ast::expr_path(?pth, ?old_ann)) {\n-            auto t = ty::mk_nil(fcx.ccx.tcx);\n-            auto defn = fcx.ccx.tcx.def_map.get(old_ann.id);\n+            auto t = ty::mk_nil(scx.fcx.ccx.tcx);\n+            auto defn = scx.fcx.ccx.tcx.def_map.get(old_ann.id);\n \n-            auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n+            auto tpt = ty_param_count_and_ty_for_def(scx.fcx, expr.span,\n+                                                     defn);\n \n             if (ty::def_has_ty_params(defn)) {\n-                auto path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n-                write_type(fcx.ccx.node_types, old_ann.id, path_tpot);\n+                auto path_tpot = instantiate_path(scx, pth, tpt, expr.span);\n+                write_type(scx.fcx.ccx.node_types, old_ann.id, path_tpot);\n                 ret;\n             }\n \n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error.\n             if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-                fcx.ccx.sess.span_err(expr.span, \"this kind of value does \" +\n-                                      \"not take type parameters\");\n+                scx.fcx.ccx.sess.span_err(expr.span,\n+                    \"this kind of value does not take type parameters\");\n                 fail;\n             }\n \n-            write_type_only(fcx.ccx.node_types, old_ann.id, tpt._1);\n+            write_type_only(scx.fcx.ccx.node_types, old_ann.id, tpt._1);\n         }\n \n         case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n-            check_expr(fcx, expanded);\n-            auto t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expanded);\n-            write_type_only(fcx.ccx.node_types, a.id, t);\n+            check_expr(scx, expanded);\n+            auto t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                             expanded);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n         }\n \n         case (ast::expr_fail(?a)) {\n-            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_break(?a)) {\n-            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_cont(?a)) {\n-            write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_ret(?expr_opt, ?a)) {\n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n-                    auto nil = ty::mk_nil(fcx.ccx.tcx);\n-                    if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n+                    auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n+                    if (!are_compatible(scx.fcx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n-                        fcx.ccx.sess.err(\"ret; in function \"\n-                                         + \"returning non-nil\");\n+                        scx.fcx.ccx.sess.err(\"ret; in function \" +\n+                            \"returning non-nil\");\n                     }\n \n-                    write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+                    write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                   a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n-                    check_expr(fcx, e);\n-                    Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n+                    check_expr(scx, e);\n+                    Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write_bot_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+                    write_bot_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                   a.id);\n                 }\n             }\n         }\n \n         case (ast::expr_put(?expr_opt, ?a)) {\n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n \n             alt (expr_opt) {\n                 case (none[@ast::expr]) {\n-                    auto nil = ty::mk_nil(fcx.ccx.tcx);\n-                    if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n+                    auto nil = ty::mk_nil(scx.fcx.ccx.tcx);\n+                    if (!are_compatible(scx.fcx, scx.fcx.ret_ty, nil)) {\n                         // TODO: span_err\n-                        fcx.ccx.sess.err(\"put; in function \"\n-                                         + \"putting non-nil\");\n+                        scx.fcx.ccx.sess.span_err(expr.span,\n+                            \"put; in iterator yielding non-nil\");\n                     }\n \n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+                    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                   a.id);\n                 }\n \n                 case (some[@ast::expr](?e)) {\n-                    check_expr(fcx, e);\n-                    Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n+                    check_expr(scx, e);\n+                    Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-                    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+                    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                   a.id);\n                 }\n             }\n         }\n@@ -1982,245 +2015,258 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // FIXME: prove instead of assert\n             assert (ast::is_call_expr(e));\n \n-            check_expr(fcx, e);\n-            Pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n+            check_expr(scx, e);\n+            Pushdown::pushdown_expr(scx, scx.fcx.ret_ty, e);\n \n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_log(?l, ?e, ?a)) {\n-            auto expr_t = check_expr(fcx, e);\n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            auto expr_t = check_expr(scx, e);\n+            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_check(?e, ?a)) {\n-            check_expr(fcx, e);\n-            Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx),\n-                           expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e));\n+            check_expr(scx, e);\n+            Demand::simple(scx.fcx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n+                expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e));\n             /* e must be a call expr where all arguments are either\n              literals or slots */\n             alt (e.node) {\n                 case (ast::expr_call(?operator, ?operands, _)) {\n                     alt (operator.node) {\n                         case (ast::expr_path(?oper_name, ?ann)) {\n                             auto d_id;\n-                            alt (fcx.ccx.tcx.def_map.get(ann.id)) {\n+                            alt (scx.fcx.ccx.tcx.def_map.get(ann.id)) {\n                                 case (ast::def_fn(?_d_id)) { d_id = _d_id; }\n                             }\n                             for (@ast::expr operand in operands) {\n                                 if (! ast::is_constraint_arg(operand)) {\n-                                    fcx.ccx.sess.span_err(expr.span,\n+                                    scx.fcx.ccx.sess.span_err(expr.span,\n                                        \"Constraint args must be \"\n                                      + \"slot variables or literals\");\n                                 }\n                             }\n \n-                            require_pure_function(fcx.ccx, d_id, expr.span);\n+                            require_pure_function(scx.fcx.ccx, d_id,\n+                                                  expr.span);\n \n-                            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types,\n+                            write_nil_type(scx.fcx.ccx.tcx,\n+                                           scx.fcx.ccx.node_types,\n                                            a.id);\n                         }\n                         case (_) {\n-                           fcx.ccx.sess.span_err(expr.span,\n+                           scx.fcx.ccx.sess.span_err(expr.span,\n                              \"In a constraint, expected the constraint name \"\n                            + \"to be an explicit name\");\n                         }\n                     }\n                 }\n                 case (_) {\n-                    fcx.ccx.sess.span_err(expr.span,\n-                        \"Check on non-predicate\");\n+                    scx.fcx.ccx.sess.span_err(expr.span,\n+                        \"check on non-predicate\");\n                 }\n             }\n         }\n \n         case (ast::expr_assert(?e, ?a)) {\n-            check_expr(fcx, e);\n-            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n-            Demand::simple(fcx, expr.span, ty::mk_bool(fcx.ccx.tcx), ety);\n+            check_expr(scx, e);\n+            auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n+            Demand::simple(scx.fcx, expr.span, ty::mk_bool(scx.fcx.ccx.tcx),\n+                           ety);\n \n-            write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, a.id);\n+            write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, a.id);\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, lhs, rhs, a);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            check_assignment(scx, lhs, rhs, a);\n         }\n \n         case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, lhs, rhs, a);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n+            check_assignment(scx, lhs, rhs, a);\n         }\n \n         case (ast::expr_send(?lhs, ?rhs, ?a)) {\n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n \n-            check_expr(fcx, lhs);\n-            check_expr(fcx, rhs);\n-            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n+            check_expr(scx, lhs);\n+            check_expr(scx, rhs);\n+            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 rhs);\n \n-            auto chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n-            Pushdown::pushdown_expr(fcx, chan_t, lhs);\n+            auto chan_t = ty::mk_chan(scx.fcx.ccx.tcx, rhs_t);\n+            Pushdown::pushdown_expr(scx, chan_t, lhs);\n             auto item_t;\n-            auto lhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n-            alt (struct(fcx.ccx.tcx, lhs_t)) {\n+            auto lhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 lhs);\n+            alt (struct(scx.fcx.ccx.tcx, lhs_t)) {\n                 case (ty::ty_chan(?it)) { item_t = it; }\n                 case (_) { fail; }\n             }\n-            Pushdown::pushdown_expr(fcx, item_t, rhs);\n+            Pushdown::pushdown_expr(scx, item_t, rhs);\n \n-            write_type_only(fcx.ccx.node_types, a.id, chan_t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, chan_t);\n         }\n \n         case (ast::expr_recv(?lhs, ?rhs, ?a)) {\n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n \n-            check_expr(fcx, lhs);\n-            check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, lhs);\n+            check_expr(scx, lhs);\n+            check_expr(scx, rhs);\n+            auto lhs_t1 = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  lhs);\n \n-            auto port_t = ty::mk_port(fcx.ccx.tcx, lhs_t1);\n-            Pushdown::pushdown_expr(fcx, port_t, rhs);\n+            auto port_t = ty::mk_port(scx.fcx.ccx.tcx, lhs_t1);\n+            Pushdown::pushdown_expr(scx, port_t, rhs);\n             auto item_t;\n-            auto rhs_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, rhs);\n-            alt (struct(fcx.ccx.tcx, rhs_t)) {\n+            auto rhs_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 rhs);\n+            alt (struct(scx.fcx.ccx.tcx, rhs_t)) {\n                 case (ty::ty_port(?it)) { item_t = it; }\n                 case (_) { fail; }\n             }\n-            Pushdown::pushdown_expr(fcx, item_t, lhs);\n+            Pushdown::pushdown_expr(scx, item_t, lhs);\n \n-            write_type_only(fcx.ccx.node_types, a.id, item_t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, item_t);\n         }\n \n         case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n-            check_expr(fcx, cond);\n-            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n+            check_expr(scx, cond);\n+            Pushdown::pushdown_expr(scx, ty::mk_bool(scx.fcx.ccx.tcx),\n+                                    cond);\n \n-            check_block(fcx, thn);\n-            auto thn_t = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, thn);\n+            check_block(scx, thn);\n+            auto thn_t = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  thn);\n \n             auto elsopt_t;\n             alt (elsopt) {\n                 case (some[@ast::expr](?els)) {\n-                    check_expr(fcx, els);\n-                    Pushdown::pushdown_expr(fcx, thn_t, els);\n-                    elsopt_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, els);\n+                    check_expr(scx, els);\n+                    Pushdown::pushdown_expr(scx, thn_t, els);\n+                    elsopt_t = expr_ty(scx.fcx.ccx.tcx,\n+                                       scx.fcx.ccx.node_types, els);\n                 }\n                 case (none[@ast::expr]) {\n-                    elsopt_t = ty::mk_nil(fcx.ccx.tcx);\n+                    elsopt_t = ty::mk_nil(scx.fcx.ccx.tcx);\n                 }\n             }\n \n-            Pushdown::pushdown_block(fcx, elsopt_t, thn);\n+            Pushdown::pushdown_block(scx, elsopt_t, thn);\n \n-            write_type_only(fcx.ccx.node_types, a.id, elsopt_t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, elsopt_t);\n         }\n \n         case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n-            check_decl_local(fcx, decl);\n-            check_expr(fcx, seq);\n-            check_block(fcx, body);\n+            check_decl_local(scx.fcx, decl);\n+            check_expr(scx, seq);\n+            check_block(scx, body);\n \n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_for_each(?decl, ?seq, ?body, ?a)) {\n-            check_decl_local(fcx, decl);\n-            check_expr(fcx, seq);\n-            check_block(fcx, body);\n+            check_decl_local(scx.fcx, decl);\n+            check_expr(scx, seq);\n+            check_block(scx, body);\n \n-            auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_while(?cond, ?body, ?a)) {\n-            check_expr(fcx, cond);\n-            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n-            check_block(fcx, body);\n+            check_expr(scx, cond);\n+            Pushdown::pushdown_expr(scx, ty::mk_bool(scx.fcx.ccx.tcx), cond);\n+            check_block(scx, body);\n \n-            auto typ = ty::mk_nil(fcx.ccx.tcx);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_do_while(?body, ?cond, ?a)) {\n-            check_expr(fcx, cond);\n-            Pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n-            check_block(fcx, body);\n+            check_expr(scx, cond);\n+            Pushdown::pushdown_expr(scx, ty::mk_bool(scx.fcx.ccx.tcx), cond);\n+            check_block(scx, body);\n \n-            auto typ = block_ty(fcx.ccx.tcx, fcx.ccx.node_types, body);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                body);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_alt(?expr, ?arms, ?a)) {\n-            check_expr(fcx, expr);\n+            check_expr(scx, expr);\n \n             // Typecheck the patterns first, so that we get types for all the\n             // bindings.\n-            auto pattern_ty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n+            auto pattern_ty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                      expr);\n \n             let vec[@ast::pat] pats = [];\n             for (ast::arm arm in arms) {\n-                check_pat(fcx, arm.pat);\n-                pattern_ty = Demand::simple(fcx, arm.pat.span, pattern_ty,\n-                    pat_ty(fcx.ccx.tcx, fcx.ccx.node_types, arm.pat));\n+                check_pat(scx, arm.pat);\n+                pattern_ty = Demand::simple(scx.fcx, arm.pat.span, pattern_ty,\n+                    pat_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, arm.pat));\n                 pats += [arm.pat];\n             }\n \n             for (@ast::pat pat in pats) {\n-                Pushdown::pushdown_pat(fcx, pattern_ty, pat);\n+                Pushdown::pushdown_pat(scx.fcx, pattern_ty, pat);\n             }\n \n             // Now typecheck the blocks.\n-            auto result_ty = next_ty_var(fcx.ccx);\n+            auto result_ty = next_ty_var(scx);\n \n             let vec[ast::block] blocks = [];\n             for (ast::arm arm in arms) {\n-                check_block(fcx, arm.block);\n+                check_block(scx, arm.block);\n \n-                auto bty = block_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                auto bty = block_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                     arm.block);\n-                result_ty = Demand::simple(fcx, arm.block.span, result_ty,\n+                result_ty = Demand::simple(scx.fcx, arm.block.span, result_ty,\n                                            bty);\n             }\n \n             auto i = 0u;\n             for (ast::block bloc in blocks) {\n-                Pushdown::pushdown_block(fcx, result_ty, bloc);\n+                Pushdown::pushdown_block(scx, result_ty, bloc);\n             }\n \n-            Pushdown::pushdown_expr(fcx, pattern_ty, expr);\n+            Pushdown::pushdown_expr(scx, pattern_ty, expr);\n \n-            write_type_only(fcx.ccx.node_types, a.id, result_ty);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, result_ty);\n         }\n \n         case (ast::expr_block(?b, ?a)) {\n-            check_block(fcx, b);\n+            check_block(scx, b);\n             alt (b.node.expr) {\n                 case (some[@ast::expr](?expr)) {\n-                    auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n-                    write_type_only(fcx.ccx.node_types, a.id, typ);\n+                    auto typ = expr_ty(scx.fcx.ccx.tcx,\n+                                       scx.fcx.ccx.node_types, expr);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n                 }\n                 case (none[@ast::expr]) {\n-                    auto typ = ty::mk_nil(fcx.ccx.tcx);\n-                    write_type_only(fcx.ccx.node_types, a.id, typ);\n+                    auto typ = ty::mk_nil(scx.fcx.ccx.tcx);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n                 }\n             }\n         }\n \n         case (ast::expr_bind(?f, ?args, ?a)) {\n             // Call the generic checker.\n-            check_call_or_bind(fcx, f, args);\n+            check_call_or_bind(scx, f, args);\n \n             // Pull the argument and return types out.\n             auto proto_1;\n             let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n-            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n-            alt (struct(fcx.ccx.tcx, fty)) {\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2244,23 +2290,23 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n \n-            auto t_1 = ty::mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            write_type_only(fcx.ccx.node_types, a.id, t_1);\n+            auto t_1 = ty::mk_fn(scx.fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, t_1);\n         }\n \n         case (ast::expr_call(?f, ?args, ?a)) {\n             /* here we're kind of hosed, as f can be any expr\n              need to restrict it to being an explicit expr_path if we're\n             inside a pure function, and need an environment mapping from\n             function name onto purity-designation */\n-            require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n+            require_pure_call(scx.fcx.ccx, scx.fcx.purity, f, expr.span);\n \n-            check_call(fcx, f, args);\n+            check_call(scx, f, args);\n \n             // Pull the return type out of the type of the function.\n-            auto rt_1 = ty::mk_nil(fcx.ccx.tcx);  // FIXME: typestate botch\n-            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n-            alt (struct(fcx.ccx.tcx, fty)) {\n+            auto rt_1 = ty::mk_nil(scx.fcx.ccx.tcx); // FIXME: typestate botch\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(_,_,?rt))           { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n                 case (_) {\n@@ -2269,50 +2315,51 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n \n-            write_type_only(fcx.ccx.node_types, a.id, rt_1);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, rt_1);\n         }\n \n         case (ast::expr_self_method(?id, ?a)) {\n-            auto t = ty::mk_nil(fcx.ccx.tcx);\n+            auto t = ty::mk_nil(scx.fcx.ccx.tcx);\n             let ty::t this_obj_ty;\n \n-            auto oinfo_opt = get_obj_info(fcx.ccx);\n+            auto oinfo_opt = get_obj_info(scx.fcx.ccx);\n             auto this_obj_id = option::get[obj_info](oinfo_opt).this_obj;\n-            this_obj_ty = ty::lookup_item_type(fcx.ccx.sess,\n-                fcx.ccx.tcx, fcx.ccx.type_cache, this_obj_id)._1;\n+            this_obj_ty = ty::lookup_item_type(scx.fcx.ccx.sess,\n+                scx.fcx.ccx.tcx, scx.fcx.ccx.type_cache, this_obj_id)._1;\n \n             // Grab this method's type out of the current object type.\n-            alt (struct(fcx.ccx.tcx, this_obj_ty)) {\n+            alt (struct(scx.fcx.ccx.tcx, this_obj_ty)) {\n                 case (ty::ty_obj(?methods)) {\n                     for (ty::method method in methods) {\n                         if (method.ident == id) {\n-                            t = ty::method_ty_to_fn_ty(fcx.ccx.tcx, method);\n+                            t = ty::method_ty_to_fn_ty(scx.fcx.ccx.tcx,\n+                                                       method);\n                         }\n                     }\n                 }\n                 case (_) { fail; }\n             }\n \n-            write_type_only(fcx.ccx.node_types, a.id, t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, t);\n \n-            require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n+            require_impure(scx.fcx.ccx.sess, scx.fcx.purity, expr.span);\n         }\n \n         case (ast::expr_spawn(_, _, ?f, ?args, ?a)) {\n-            check_call(fcx, f, args);\n+            check_call(scx, f, args);\n \n             // Check the return type\n-            auto fty = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, f);\n-            alt (struct(fcx.ccx.tcx, fty)) {\n+            auto fty = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, f);\n+            alt (struct(scx.fcx.ccx.tcx, fty)) {\n                 case (ty::ty_fn(_,_,?rt)) {\n-                    alt (struct(fcx.ccx.tcx, rt)) {\n+                    alt (struct(scx.fcx.ccx.tcx, rt)) {\n                         case (ty::ty_nil) {\n                             // This is acceptable\n                         }\n                         case (_) {\n                             auto err = \"non-nil return type in \"\n                                 + \"spawned function\";\n-                            fcx.ccx.sess.span_err(expr.span, err);\n+                            scx.fcx.ccx.sess.span_err(expr.span, err);\n                             fail;\n                         }\n                     }\n@@ -2321,71 +2368,74 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             // FIXME: Other typechecks needed\n \n-            auto typ = ty::mk_task(fcx.ccx.tcx);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_task(scx.fcx.ccx.tcx);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_cast(?e, ?t, ?a)) {\n-            check_expr(fcx, e);\n-            auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n+            check_expr(scx, e);\n+            auto t_1 = ast_ty_to_ty_crate(scx.fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n-            if (! (type_is_scalar(fcx.ccx.tcx,\n-                    expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e)) &&\n-                    type_is_scalar(fcx.ccx.tcx, t_1))) {\n-                fcx.ccx.sess.span_err(expr.span,\n+            if (! (type_is_scalar(scx.fcx.ccx.tcx,\n+                    expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e)) &&\n+                    type_is_scalar(scx.fcx.ccx.tcx, t_1))) {\n+                scx.fcx.ccx.sess.span_err(expr.span,\n                     \"non-scalar cast: \" +\n-                    ty_to_str(fcx.ccx.tcx,\n-                              expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e)) +\n-                    \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n+                    ty_to_str(scx.fcx.ccx.tcx,\n+                        expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e)) +\n+                    \" as \" + ty_to_str(scx.fcx.ccx.tcx, t_1));\n             }\n \n-            write_type_only(fcx.ccx.node_types, a.id, t_1);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, t_1);\n         }\n \n         case (ast::expr_vec(?args, ?mut, ?a)) {\n             let ty::t t;\n             if (vec::len[@ast::expr](args) == 0u) {\n-                t = next_ty_var(fcx.ccx);\n+                t = next_ty_var(scx);\n             } else {\n-                check_expr(fcx, args.(0));\n-                t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, args.(0));\n+                check_expr(scx, args.(0));\n+                t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                            args.(0));\n             }\n \n             for (@ast::expr e in args) {\n-                check_expr(fcx, e);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n-                Demand::simple(fcx, expr.span, t, expr_t);\n+                check_expr(scx, e);\n+                auto expr_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                      e);\n+                Demand::simple(scx.fcx, expr.span, t, expr_t);\n             }\n \n-            auto typ = ty::mk_vec(fcx.ccx.tcx, rec(ty=t, mut=mut));\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_vec(scx.fcx.ccx.tcx, rec(ty=t, mut=mut));\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_tup(?elts, ?a)) {\n             let vec[ty::mt] elts_mt = [];\n \n             for (ast::elt e in elts) {\n-                check_expr(fcx, e.expr);\n-                auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e.expr);\n+                check_expr(scx, e.expr);\n+                auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                   e.expr);\n                 elts_mt += [rec(ty=ety, mut=e.mut)];\n             }\n \n-            auto typ = ty::mk_tup(fcx.ccx.tcx, elts_mt);\n-            write_type_only(fcx.ccx.node_types, a.id, typ);\n+            auto typ = ty::mk_tup(scx.fcx.ccx.tcx, elts_mt);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n         }\n \n         case (ast::expr_rec(?fields, ?base, ?a)) {\n \n             alt (base) {\n                 case (none[@ast::expr]) { /* no-op */}\n-                case (some[@ast::expr](?b_0)) { check_expr(fcx, b_0); }\n+                case (some[@ast::expr](?b_0)) { check_expr(scx, b_0); }\n             }\n \n             let vec[field] fields_t = [];\n \n             for (ast::field f in fields) {\n-                check_expr(fcx, f.expr);\n-                auto expr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n+                check_expr(scx, f.expr);\n+                auto expr_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n                                       f.expr);\n \n                 auto expr_mt = rec(ty=expr_t, mut=f.mut);\n@@ -2394,39 +2444,39 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             alt (base) {\n                 case (none[@ast::expr]) {\n-                    auto typ = ty::mk_rec(fcx.ccx.tcx, fields_t);\n-                    write_type_only(fcx.ccx.node_types, a.id, typ);\n+                    auto typ = ty::mk_rec(scx.fcx.ccx.tcx, fields_t);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n                 }\n \n                 case (some[@ast::expr](?bexpr)) {\n-                    check_expr(fcx, bexpr);\n-                    auto bexpr_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                           bexpr);\n+                    check_expr(scx, bexpr);\n+                    auto bexpr_t = expr_ty(scx.fcx.ccx.tcx,\n+                                           scx.fcx.ccx.node_types, bexpr);\n \n                     let vec[field] base_fields = [];\n \n-                    alt (struct(fcx.ccx.tcx, bexpr_t)) {\n+                    alt (struct(scx.fcx.ccx.tcx, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n-                            fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"record update non-record base\");\n                         }\n                     }\n \n-                    write_type_only(fcx.ccx.node_types, a.id, bexpr_t);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, bexpr_t);\n \n                     for (ty::field f in fields_t) {\n                         auto found = false;\n                         for (ty::field bf in base_fields) {\n                             if (str::eq(f.ident, bf.ident)) {\n-                                Demand::simple(fcx, expr.span, f.mt.ty,\n-                                              bf.mt.ty);\n+                                Demand::simple(scx.fcx, expr.span, f.mt.ty,\n+                                               bf.mt.ty);\n                                 found = true;\n                             }\n                         }\n                         if (!found) {\n-                            fcx.ccx.sess.span_err\n+                            scx.fcx.ccx.sess.span_err\n                                 (expr.span,\n                                  \"unknown field in record update: \"\n                                  + f.ident);\n@@ -2437,124 +2487,146 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         }\n \n         case (ast::expr_field(?base, ?field, ?a)) {\n-            check_expr(fcx, base);\n-            auto base_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base);\n-            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n-            alt (struct(fcx.ccx.tcx, base_t)) {\n+            check_expr(scx, base);\n+            auto base_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  base);\n+            base_t = strip_boxes(scx.fcx.ccx.tcx, base_t);\n+            alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_tup(?args)) {\n-                    let uint ix = ty::field_num(fcx.ccx.sess,\n-                                               expr.span, field);\n+                    let uint ix = ty::field_num(scx.fcx.ccx.sess,\n+                                                expr.span, field);\n                     if (ix >= vec::len[ty::mt](args)) {\n-                        fcx.ccx.sess.span_err(expr.span,\n-                                              \"bad index on tuple\");\n+                        scx.fcx.ccx.sess.span_err(expr.span,\n+                                                  \"bad index on tuple\");\n                     }\n-                    write_type_only(fcx.ccx.node_types, a.id,\n+                    write_type_only(scx.fcx.ccx.node_types, a.id,\n                                     args.(ix).ty);\n                 }\n \n                 case (ty::ty_rec(?fields)) {\n-                    let uint ix = ty::field_idx(fcx.ccx.sess,\n+                    let uint ix = ty::field_idx(scx.fcx.ccx.sess,\n                                                 expr.span, field, fields);\n                     if (ix >= vec::len[typeck::field](fields)) {\n-                        fcx.ccx.sess.span_err(expr.span,\n+                        scx.fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    write_type_only(fcx.ccx.node_types, a.id,\n+                    write_type_only(scx.fcx.ccx.node_types, a.id,\n                                     fields.(ix).mt.ty);\n                 }\n \n                 case (ty::ty_obj(?methods)) {\n-                    let uint ix = ty::method_idx(fcx.ccx.sess,\n+                    let uint ix = ty::method_idx(scx.fcx.ccx.sess,\n                                                  expr.span, field, methods);\n                     if (ix >= vec::len[typeck::method](methods)) {\n-                        fcx.ccx.sess.span_err(expr.span,\n-                                              \"bad index on obj\");\n+                        scx.fcx.ccx.sess.span_err(expr.span,\n+                                                  \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n-                    auto t = ty::mk_fn(fcx.ccx.tcx, meth.proto,\n+                    auto t = ty::mk_fn(scx.fcx.ccx.tcx, meth.proto,\n                                        meth.inputs, meth.output);\n-                    write_type_only(fcx.ccx.node_types, a.id, t);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, t);\n                 }\n \n                 case (_) {\n-                    fcx.ccx.sess.span_unimpl(expr.span,\n+                    scx.fcx.ccx.sess.span_unimpl(expr.span,\n                         \"base type for expr_field in typeck::check_expr: \" +\n-                        ty_to_str(fcx.ccx.tcx, base_t));\n+                        ty_to_str(scx.fcx.ccx.tcx, base_t));\n                 }\n             }\n         }\n \n         case (ast::expr_index(?base, ?idx, ?a)) {\n-            check_expr(fcx, base);\n-            auto base_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, base);\n-            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n-\n-            check_expr(fcx, idx);\n-            auto idx_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, idx);\n-            alt (struct(fcx.ccx.tcx, base_t)) {\n+            check_expr(scx, base);\n+            auto base_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                  base);\n+            base_t = strip_boxes(scx.fcx.ccx.tcx, base_t);\n+\n+            check_expr(scx, idx);\n+            auto idx_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types,\n+                                 idx);\n+            alt (struct(scx.fcx.ccx.tcx, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n-                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n-                        fcx.ccx.sess.span_err\n+                    if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n+                        scx.fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n-                             + ty_to_str(fcx.ccx.tcx, idx_t));\n+                             + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n                     }\n-                    write_type_only(fcx.ccx.node_types, a.id, mt.ty);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, mt.ty);\n                 }\n                 case (ty::ty_str) {\n-                    if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n-                        fcx.ccx.sess.span_err\n+                    if (! type_is_integral(scx.fcx.ccx.tcx, idx_t)) {\n+                        scx.fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of str index: \"\n-                             + ty_to_str(fcx.ccx.tcx, idx_t));\n+                             + ty_to_str(scx.fcx.ccx.tcx, idx_t));\n                     }\n-                    auto typ = ty::mk_mach(fcx.ccx.tcx, common::ty_u8);\n-                    write_type_only(fcx.ccx.node_types, a.id, typ);\n+                    auto typ = ty::mk_mach(scx.fcx.ccx.tcx, common::ty_u8);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, typ);\n                 }\n                 case (_) {\n-                    fcx.ccx.sess.span_err\n+                    scx.fcx.ccx.sess.span_err\n                         (expr.span,\n                          \"vector-indexing bad type: \"\n-                         + ty_to_str(fcx.ccx.tcx, base_t));\n+                         + ty_to_str(scx.fcx.ccx.tcx, base_t));\n                 }\n             }\n         }\n \n         case (ast::expr_port(?a)) {\n-            auto t = next_ty_var(fcx.ccx);\n-            auto pt = ty::mk_port(fcx.ccx.tcx, t);\n-            write_type_only(fcx.ccx.node_types, a.id, pt);\n+            auto t = next_ty_var(scx);\n+            auto pt = ty::mk_port(scx.fcx.ccx.tcx, t);\n+            write_type_only(scx.fcx.ccx.node_types, a.id, pt);\n         }\n \n         case (ast::expr_chan(?x, ?a)) {\n-            check_expr(fcx, x);\n-            auto port_t = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, x);\n-            alt (struct(fcx.ccx.tcx, port_t)) {\n+            check_expr(scx, x);\n+            auto port_t = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, x);\n+            alt (struct(scx.fcx.ccx.tcx, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n-                    auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n-                    write_type_only(fcx.ccx.node_types, a.id, ct);\n+                    auto ct = ty::mk_chan(scx.fcx.ccx.tcx, subtype);\n+                    write_type_only(scx.fcx.ccx.node_types, a.id, ct);\n                 }\n                 case (_) {\n-                    fcx.ccx.sess.span_err(expr.span,\n-                        \"bad port type: \" + ty_to_str(fcx.ccx.tcx, port_t));\n+                    scx.fcx.ccx.sess.span_err(expr.span,\n+                        \"bad port type: \" +\n+                        ty_to_str(scx.fcx.ccx.tcx, port_t));\n                 }\n             }\n         }\n \n-        case (_) { fcx.ccx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n+        case (_) {\n+            scx.fcx.ccx.sess.unimpl(\"expr type in typeck::check_expr\");\n+        }\n     }\n }\n \n-fn next_ty_var(&@crate_ctxt ccx) -> ty::t {\n-    auto t = ty::mk_var(ccx.tcx, ccx.next_var_id);\n-    ccx.next_var_id += 1;\n+fn next_ty_var(&@stmt_ctxt scx) -> ty::t {\n+    auto t = ty::mk_var(scx.fcx.ccx.tcx, scx.next_var_id);\n+    scx.next_var_id += 1;\n     ret t;\n }\n \n fn get_obj_info(&@crate_ctxt ccx) -> option::t[obj_info] {\n     ret vec::last[obj_info](ccx.obj_infos);\n }\n \n+fn check_decl_initializer(&@stmt_ctxt scx, &ast::def_id lid,\n+                          &ast::initializer init) {\n+    check_expr(scx, init.expr);\n+\n+    auto lty = ty::mk_local(scx.fcx.ccx.tcx, lid);\n+    alt (init.op) {\n+        case (ast::init_assign) {\n+            Pushdown::pushdown_expr(scx, lty, init.expr);\n+        }\n+        case (ast::init_recv) {\n+            auto port_ty = ty::mk_port(scx.fcx.ccx.tcx, lty);\n+            Pushdown::pushdown_expr(scx, port_ty, init.expr);\n+        }\n+    }\n+}\n+\n fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n     alt (decl.node) {\n         case (ast::decl_local(?local)) {\n@@ -2578,17 +2650,8 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n             auto initopt = local.init;\n             alt (local.init) {\n                 case (some[ast::initializer](?init)) {\n-                    check_expr(fcx, init.expr);\n-                    auto lty = ty::mk_local(fcx.ccx.tcx, local.id);\n-                    alt (init.op) {\n-                        case (ast::init_assign) {\n-                            Pushdown::pushdown_expr(fcx, lty, init.expr);\n-                        }\n-                        case (ast::init_recv) {\n-                            auto port_ty = ty::mk_port(fcx.ccx.tcx, lty);\n-                            Pushdown::pushdown_expr(fcx, port_ty, init.expr);\n-                        }\n-                    }\n+                    with_stmt_ctxt(fcx,\n+                        bind check_decl_initializer(_, local.id, init));\n                 }\n                 case (_) { /* fall through */  }\n             }\n@@ -2598,6 +2661,12 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n     }\n }\n \n+fn check_and_pushdown_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n+    check_expr(scx, expr);\n+    auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, expr);\n+    Pushdown::pushdown_expr(scx, ety, expr);\n+}\n+\n fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n     auto node_id;\n     alt (stmt.node) {\n@@ -2610,41 +2679,38 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n         }\n         case (ast::stmt_expr(?expr,?a)) {\n             node_id = a.id;\n-\n-            check_expr(fcx, expr);\n-            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, expr);\n-            Pushdown::pushdown_expr(fcx, ety, expr);\n+            with_stmt_ctxt(fcx, bind check_and_pushdown_expr(_, expr));\n         }\n     }\n \n     write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, node_id);\n }\n \n-fn check_block(&@fn_ctxt fcx, &ast::block block) {\n-    for (@ast::stmt s in block.node.stmts) { check_stmt(fcx, s); }\n+fn check_block(&@stmt_ctxt scx, &ast::block block) {\n+    for (@ast::stmt s in block.node.stmts) { check_stmt(scx.fcx, s); }\n \n     alt (block.node.expr) {\n         case (none[@ast::expr]) { /* empty */ }\n         case (some[@ast::expr](?e)) {\n-            check_expr(fcx, e);\n-            auto ety = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, e);\n-            Pushdown::pushdown_expr(fcx, ety, e);\n+            check_expr(scx, e);\n+            auto ety = expr_ty(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, e);\n+            Pushdown::pushdown_expr(scx, ety, e);\n         }\n     }\n \n-    write_nil_type(fcx.ccx.tcx, fcx.ccx.node_types, block.node.a.id);\n+    write_nil_type(scx.fcx.ccx.tcx, scx.fcx.ccx.node_types, block.node.a.id);\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n-    // FIXME: this is kinda a kludge; we manufacture a fake \"function context\"\n-    // for checking the initializer expression.\n+    // FIXME: this is kinda a kludge; we manufacture a fake function context\n+    // and statement context for checking the initializer expression.\n     auto rty = ann_to_type(ccx.node_types, ann);\n     let @fn_ctxt fcx = @rec(ret_ty = rty,\n                             purity = ast::pure_fn,\n                             locals = @common::new_def_hash[ty::t](),\n                             ccx = ccx);\n-    check_expr(fcx, e);\n-    Pushdown::pushdown_expr(fcx, rty, e);\n+\n+    with_stmt_ctxt(fcx, bind check_and_pushdown_expr(_, e));\n }\n \n fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n@@ -2677,7 +2743,8 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n                             ccx = ccx);\n \n     // TODO: Make sure the type of the block agrees with the function type.\n-    check_block(fcx, body);\n+    with_stmt_ctxt(fcx, bind check_block(_, body));\n+\n     alt (decl.purity) {\n         case (ast::pure_fn) {\n             // per the previous comment, this just checks that the declared\n@@ -2797,7 +2864,6 @@ fn check_crate(&ty::ctxt tcx, &@ast::crate crate) -> typecheck_result {\n                     item_items=result._1,\n                     mutable obj_infos=obj_infos,\n                     fn_purity_table=fpt,\n-                    mutable next_var_id=0,\n                     unify_cache=unify_cache,\n                     mutable cache_hits=0u,\n                     mutable cache_misses=0u,"}]}