{"sha": "8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "node_id": "C_kwDOAAsO6NoAKDhiZmM4YmM1ZTAyMTBkYWJkMjk3NmVkYWQ1YmYyODVhOTZkY2IzNjA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-20T20:10:18Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-11-07T19:14:04Z"}, "message": "Lint `needless_collect` on non-std collection types", "tree": {"sha": "0e662336a1e381462695686c6d648bac7b45d0bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e662336a1e381462695686c6d648bac7b45d0bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "html_url": "https://github.com/rust-lang/rust/commit/8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0dcb862c60c87c55f4e34c2ecce8914ffe3c4c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0dcb862c60c87c55f4e34c2ecce8914ffe3c4c7", "html_url": "https://github.com/rust-lang/rust/commit/b0dcb862c60c87c55f4e34c2ecce8914ffe3c4c7"}], "stats": {"total": 559, "additions": 408, "deletions": 151}, "files": [{"sha": "ac61b4377885b8cfd2a179c901ee844be0cd8aef", "filename": "clippy_lints/src/methods/collapsible_str_replace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcollapsible_str_replace.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n         // If the parent node's `to` argument is the same as the `to` argument\n         // of the last replace call in the current chain, don't lint as it was already linted\n         if let Some(parent) = get_parent_expr(cx, expr)\n-            && let Some((\"replace\", _, [current_from, current_to], _)) = method_call(parent)\n+            && let Some((\"replace\", _, [current_from, current_to], _, _)) = method_call(parent)\n             && eq_expr_value(cx, to, current_to)\n             && from_kind == cx.typeck_results().expr_ty(current_from).peel_refs().kind()\n         {\n@@ -48,7 +48,7 @@ fn collect_replace_calls<'tcx>(\n     let mut from_args = VecDeque::new();\n \n     let _: Option<()> = for_each_expr(expr, |e| {\n-        if let Some((\"replace\", _, [from, to], _)) = method_call(e) {\n+        if let Some((\"replace\", _, [from, to], _, _)) = method_call(e) {\n             if eq_expr_value(cx, to_arg, to) && cx.typeck_results().expr_ty(from).peel_refs().is_char() {\n                 methods.push_front(e);\n                 from_args.push_front(from);\n@@ -78,7 +78,7 @@ fn check_consecutive_replace_calls<'tcx>(\n         .collect();\n     let app = Applicability::MachineApplicable;\n     let earliest_replace_call = replace_methods.methods.front().unwrap();\n-    if let Some((_, _, [..], span_lo)) = method_call(earliest_replace_call) {\n+    if let Some((_, _, [..], span_lo, _)) = method_call(earliest_replace_call) {\n         span_lint_and_sugg(\n             cx,\n             COLLAPSIBLE_STR_REPLACE,"}, {"sha": "8b798fdb12fc921aba5a02a1bbe51a1fefd5da41", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -59,10 +59,8 @@ pub(super) fn check(\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n         if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n-        if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);\n         if let Some(iter_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-        if cx.tcx.trait_of_item(collect_id) == Some(iter_trait_id);\n         if cx.tcx.trait_of_item(take_id) == Some(iter_trait_id);\n         if let Some(repeat_kind) = parse_repeat_arg(cx, repeat_arg);\n         let ctxt = collect_expr.span.ctxt();"}, {"sha": "a0300d278709d7e82ab20a5928d6ec74e4d6c8e0", "filename": "clippy_lints/src/methods/map_collect_result_unit.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_collect_result_unit.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_trait_method;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n@@ -11,18 +10,10 @@ use rustc_span::symbol::sym;\n \n use super::MAP_COLLECT_RESULT_UNIT;\n \n-pub(super) fn check(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    iter: &hir::Expr<'_>,\n-    map_fn: &hir::Expr<'_>,\n-    collect_recv: &hir::Expr<'_>,\n-) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, iter: &hir::Expr<'_>, map_fn: &hir::Expr<'_>) {\n+    // return of collect `Result<(),_>`\n+    let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n     if_chain! {\n-        // called on Iterator\n-        if is_trait_method(cx, collect_recv, sym::Iterator);\n-        // return of collect `Result<(),_>`\n-        let collect_ret_ty = cx.typeck_results().expr_ty(expr);\n         if is_type_diagnostic_item(cx, collect_ret_ty, sym::Result);\n         if let ty::Adt(_, substs) = collect_ret_ty.kind();\n         if let Some(result_t) = substs.types().next();"}, {"sha": "1c0bbe086f7c88374b7c5fd84b88d155ebcc57ee", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -3296,11 +3296,11 @@ impl_lint_pass!(Methods => [\n /// Extracts a method call name, args, and `Span` of the method name.\n fn method_call<'tcx>(\n     recv: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span)> {\n-    if let ExprKind::MethodCall(path, receiver, args, _) = recv.kind {\n+) -> Option<(&'tcx str, &'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>], Span, Span)> {\n+    if let ExprKind::MethodCall(path, receiver, args, call_span) = recv.kind {\n         if !args.iter().any(|e| e.span.from_expansion()) && !receiver.span.from_expansion() {\n             let name = path.ident.name.as_str();\n-            return Some((name, receiver, args, path.ident.span));\n+            return Some((name, receiver, args, path.ident.span, call_span));\n         }\n     }\n     None\n@@ -3341,8 +3341,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             },\n             _ => (),\n         }\n-\n-        needless_collect::check(expr, cx);\n     }\n \n     #[allow(clippy::too_many_lines)]\n@@ -3488,7 +3486,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, recv, args, span)) = method_call(expr) {\n+        if let Some((name, recv, args, span, call_span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3507,28 +3505,31 @@ impl Methods {\n                 (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n                 (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n                 (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n-                (\"collect\", []) => match method_call(recv) {\n-                    Some((name @ (\"cloned\" | \"copied\"), recv2, [], _)) => {\n-                        iter_cloned_collect::check(cx, name, expr, recv2);\n-                    },\n-                    Some((\"map\", m_recv, [m_arg], _)) => {\n-                        map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n-                    },\n-                    Some((\"take\", take_self_arg, [take_arg], _)) => {\n-                        if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n-                            manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n-                        }\n-                    },\n-                    _ => {},\n+                (\"collect\", []) if is_trait_method(cx, expr, sym::Iterator) => {\n+                    needless_collect::check(cx, span, expr, recv, call_span);\n+                    match method_call(recv) {\n+                        Some((name @ (\"cloned\" | \"copied\"), recv2, [], _, _)) => {\n+                            iter_cloned_collect::check(cx, name, expr, recv2);\n+                        },\n+                        Some((\"map\", m_recv, [m_arg], _, _)) => {\n+                            map_collect_result_unit::check(cx, expr, m_recv, m_arg);\n+                        },\n+                        Some((\"take\", take_self_arg, [take_arg], _, _)) => {\n+                            if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n+                                manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n                 },\n                 (\"count\", []) if is_trait_method(cx, expr, sym::Iterator) => match method_call(recv) {\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n-                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _)) => {\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, true, false),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), recv2, [], _, _)) => {\n                         iter_count::check(cx, expr, recv2, name2);\n                     },\n-                    Some((\"map\", _, [arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                    Some((\"filter\", recv2, [arg], _)) => bytecount::check(cx, expr, recv2, arg),\n-                    Some((\"bytes\", recv2, [], _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n+                    Some((\"map\", _, [arg], _, _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    Some((\"filter\", recv2, [arg], _, _)) => bytecount::check(cx, expr, recv2, arg),\n+                    Some((\"bytes\", recv2, [], _, _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n                 (\"drain\", [arg]) => {\n@@ -3540,8 +3541,8 @@ impl Methods {\n                     }\n                 },\n                 (\"expect\", [_]) => match method_call(recv) {\n-                    Some((\"ok\", recv, [], _)) => ok_expect::check(cx, expr, recv),\n-                    Some((\"err\", recv, [], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    Some((\"ok\", recv, [], _, _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", recv, [], err_span, _)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n                     _ => expect_used::check(cx, expr, recv, false, self.allow_expect_in_tests),\n                 },\n                 (\"expect_err\", [_]) => expect_used::check(cx, expr, recv, true, self.allow_expect_in_tests),\n@@ -3561,13 +3562,13 @@ impl Methods {\n                     flat_map_option::check(cx, expr, arg, span);\n                 },\n                 (\"flatten\", []) => match method_call(recv) {\n-                    Some((\"map\", recv, [map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n+                    Some((\"map\", recv, [map_arg], map_span, _)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, true),\n                     _ => {},\n                 },\n                 (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n                 (\"for_each\", [_]) => {\n-                    if let Some((\"inspect\", _, [_], span2)) = method_call(recv) {\n+                    if let Some((\"inspect\", _, [_], span2, _)) = method_call(recv) {\n                         inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n@@ -3587,12 +3588,12 @@ impl Methods {\n                     iter_on_single_or_empty_collections::check(cx, expr, name, recv);\n                 },\n                 (\"join\", [join_arg]) => {\n-                    if let Some((\"collect\", _, _, span)) = method_call(recv) {\n+                    if let Some((\"collect\", _, _, span, _)) = method_call(recv) {\n                         unnecessary_join::check(cx, expr, recv, join_arg, span);\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2, _)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3604,13 +3605,13 @@ impl Methods {\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n                     if name == \"map\" {\n                         map_clone::check(cx, expr, recv, m_arg, self.msrv);\n-                        if let Some((map_name @ (\"iter\" | \"into_iter\"), recv2, _, _)) = method_call(recv) {\n+                        if let Some((map_name @ (\"iter\" | \"into_iter\"), recv2, _, _, _)) = method_call(recv) {\n                             iter_kv_map::check(cx, map_name, expr, recv2, m_arg);\n                         }\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2,_)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3630,7 +3631,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3643,10 +3644,10 @@ impl Methods {\n                     }\n                 },\n                 (\"nth\", [n_arg]) => match method_call(recv) {\n-                    Some((\"bytes\", recv2, [], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                    Some((\"cloned\", recv2, [], _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n-                    Some((\"iter\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                    Some((\"iter_mut\", recv2, [], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    Some((\"bytes\", recv2, [], _, _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", recv2, [], _, _)) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n+                    Some((\"iter\", recv2, [], _, _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", recv2, [], _, _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n                     _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n                 },\n                 (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n@@ -3711,7 +3712,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2, _)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3734,13 +3735,13 @@ impl Methods {\n                 },\n                 (\"unwrap\", []) => {\n                     match method_call(recv) {\n-                        Some((\"get\", recv, [get_arg], _)) => {\n+                        Some((\"get\", recv, [get_arg], _, _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, false);\n                         },\n-                        Some((\"get_mut\", recv, [get_arg], _)) => {\n+                        Some((\"get_mut\", recv, [get_arg], _, _)) => {\n                             get_unwrap::check(cx, expr, recv, get_arg, true);\n                         },\n-                        Some((\"or\", recv, [or_arg], or_span)) => {\n+                        Some((\"or\", recv, [or_arg], or_span, _)) => {\n                             or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n                         },\n                         _ => {},\n@@ -3749,19 +3750,19 @@ impl Methods {\n                 },\n                 (\"unwrap_err\", []) => unwrap_used::check(cx, expr, recv, true, self.allow_unwrap_in_tests),\n                 (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _)) => {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), lhs, [rhs], _, _)) => {\n                         manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"map\", m_recv, [m_arg], span)) => {\n+                    Some((\"map\", m_recv, [m_arg], span, _)) => {\n                         option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n-                    Some((\"then_some\", t_recv, [t_arg], _)) => {\n+                    Some((\"then_some\", t_recv, [t_arg], _, _)) => {\n                         obfuscated_if_else::check(cx, expr, t_recv, t_arg, u_arg);\n                     },\n                     _ => {},\n                 },\n                 (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                    Some((\"map\", recv, [map_arg], _))\n+                    Some((\"map\", recv, [map_arg], _, _))\n                         if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n                     _ => {\n                         unwrap_or_else_default::check(cx, expr, recv, u_arg);\n@@ -3782,7 +3783,7 @@ impl Methods {\n }\n \n fn check_is_some_is_none(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, is_some: bool) {\n-    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span)) = method_call(recv) {\n+    if let Some((name @ (\"find\" | \"position\" | \"rposition\"), f_recv, [arg], span, _)) = method_call(recv) {\n         search_is_some::check(cx, expr, name, is_some, f_recv, arg, recv, span);\n     }\n }"}, {"sha": "b088e642e0e9acd258e5e422ce1984d08b06d226", "filename": "clippy_lints/src/methods/needless_collect.rs", "status": "modified", "additions": 139, "deletions": 84, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fneedless_collect.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -3,94 +3,99 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::higher;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local, path_to_local_id, CaptureKind};\n-use if_chain::if_chain;\n+use clippy_utils::ty::{is_type_diagnostic_item, make_normalized_projection, make_projection};\n+use clippy_utils::{\n+    can_move_expr_to_closure, get_enclosing_block, get_parent_node, is_trait_method, path_to_local, path_to_local_id,\n+    CaptureKind,\n+};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n+use rustc_hir::{\n+    BindingAnnotation, Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind,\n+};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_span::sym;\n-use rustc_span::Span;\n+use rustc_middle::ty::{self, AssocKind, EarlyBinder, GenericArg, GenericArgKind, Ty};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span, Symbol};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n-pub(super) fn check<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    check_needless_collect_direct_usage(expr, cx);\n-    check_needless_collect_indirect_usage(expr, cx);\n-}\n-fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method, receiver, args, _) = expr.kind;\n-        if let ExprKind::MethodCall(chain_method, ..) = receiver.kind;\n-        if chain_method.ident.name == sym!(collect) && is_trait_method(cx, receiver, sym::Iterator);\n-        then {\n-            let ty = cx.typeck_results().expr_ty(receiver);\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let is_empty_sugg = \"next().is_none()\".to_string();\n-            let method_name = method.ident.name.as_str();\n-            let sugg = if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n-                        is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n-                        is_type_diagnostic_item(cx, ty, sym::LinkedList) ||\n-                        is_type_diagnostic_item(cx, ty, sym::BinaryHeap) {\n-                match method_name {\n-                    \"len\" => \"count()\".to_string(),\n-                    \"is_empty\" => is_empty_sugg,\n-                    \"contains\" => {\n-                        let contains_arg = snippet_with_applicability(cx, args[0].span, \"??\", &mut applicability);\n-                        let (arg, pred) = contains_arg\n-                            .strip_prefix('&')\n-                            .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                        format!(\"any(|{arg}| x == {pred})\")\n-                    }\n-                    _ => return,\n-                }\n-            }\n-            else if is_type_diagnostic_item(cx, ty, sym::BTreeMap) ||\n-                is_type_diagnostic_item(cx, ty, sym::HashMap) {\n-                match method_name {\n-                    \"is_empty\" => is_empty_sugg,\n-                    _ => return,\n-                }\n-            }\n-            else {\n-                return;\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_COLLECT,\n-                chain_method.ident.span.with_hi(expr.span.hi()),\n-                NEEDLESS_COLLECT_MSG,\n-                \"replace with\",\n-                sugg,\n-                applicability,\n-            );\n-        }\n-    }\n-}\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    name_span: Span,\n+    collect_expr: &'tcx Expr<'_>,\n+    iter_expr: &'tcx Expr<'tcx>,\n+    call_span: Span,\n+) {\n+    if let Some(parent) = get_parent_node(cx.tcx, collect_expr.hir_id) {\n+        match parent {\n+            Node::Expr(parent) => {\n+                if let ExprKind::MethodCall(name, _, args @ ([] | [_]), _) = parent.kind {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let name = name.ident.as_str();\n+                    let collect_ty = cx.typeck_results().expr_ty(collect_expr);\n \n-fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    if let ExprKind::Block(block, _) = expr.kind {\n-        for stmt in block.stmts {\n-            if_chain! {\n-                if let StmtKind::Local(local) = stmt.kind;\n-                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n-                if let Some(init_expr) = local.init;\n-                if let ExprKind::MethodCall(method_name, iter_source, [], ..) = init_expr.kind;\n-                if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                let ty = cx.typeck_results().expr_ty(init_expr);\n-                if is_type_diagnostic_item(cx, ty, sym::Vec) ||\n-                    is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n-                    is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n-                    is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                let iter_ty = cx.typeck_results().expr_ty(iter_source);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty));\n-                if let [iter_call] = &*iter_calls;\n-                then {\n+                    let sugg: String = match name {\n+                        \"len\" => {\n+                            if let Some(adt) = collect_ty.ty_adt_def()\n+                                && matches!(\n+                                    cx.tcx.get_diagnostic_name(adt.did()),\n+                                    Some(sym::Vec | sym::VecDeque | sym::LinkedList | sym::BinaryHeap)\n+                                )\n+                            {\n+                                \"count()\".into()\n+                            } else {\n+                                return;\n+                            }\n+                        },\n+                        \"is_empty\"\n+                            if is_is_empty_sig(cx, parent.hir_id)\n+                                && iterates_same_ty(cx, cx.typeck_results().expr_ty(iter_expr), collect_ty) =>\n+                        {\n+                            \"next().is_none()\".into()\n+                        },\n+                        \"contains\" => {\n+                            if is_contains_sig(cx, parent.hir_id, iter_expr)\n+                                && let Some(arg) = args.first()\n+                            {\n+                                let (span, prefix) = if let ExprKind::AddrOf(_, _, arg) = arg.kind {\n+                                    (arg.span, \"\")\n+                                } else {\n+                                    (arg.span, \"*\")\n+                                };\n+                                let snip = snippet_with_applicability(cx, span, \"??\", &mut app);\n+                                format!(\"any(|x| x == {prefix}{snip})\")\n+                            } else {\n+                                return;\n+                            }\n+                        },\n+                        _ => return,\n+                    };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        call_span.with_hi(parent.span.hi()),\n+                        NEEDLESS_COLLECT_MSG,\n+                        \"replace with\",\n+                        sugg,\n+                        app,\n+                    );\n+                }\n+            },\n+            Node::Local(l) => {\n+                if let PatKind::Binding(BindingAnnotation::NONE | BindingAnnotation::MUT, id, _, None)\n+                    = l.pat.kind\n+                    && let ty = cx.typeck_results().expr_ty(collect_expr)\n+                    && [sym::Vec, sym::VecDeque, sym::BinaryHeap, sym::LinkedList].into_iter()\n+                        .any(|item| is_type_diagnostic_item(cx, ty, item))\n+                    && let iter_ty = cx.typeck_results().expr_ty(iter_expr)\n+                    && let Some(block) = get_enclosing_block(cx, l.hir_id)\n+                    && let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty))\n+                    && let [iter_call] = &*iter_calls\n+                {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n                         id,\n@@ -102,32 +107,82 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     }\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n-                    let mut span = MultiSpan::from_span(method_name.ident.span);\n+                    let mut span = MultiSpan::from_span(name_span);\n                     span.push_span_label(iter_call.span, \"the iterator could be used here instead\");\n                     span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,\n-                        init_expr.hir_id,\n+                        collect_expr.hir_id,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         |diag| {\n-                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_expr, \"..\"), iter_call.get_iter_method(cx));\n                             diag.multipart_suggestion(\n                                 iter_call.get_suggestion_text(),\n                                 vec![\n-                                    (stmt.span, String::new()),\n+                                    (l.span, String::new()),\n                                     (iter_call.span, iter_replacement)\n                                 ],\n                                 Applicability::MaybeIncorrect,\n                             );\n                         },\n                     );\n                 }\n-            }\n+            },\n+            _ => (),\n         }\n     }\n }\n \n+/// Checks if the given method call matches the expected signature of `([&[mut]] self) -> bool`\n+fn is_is_empty_sig(cx: &LateContext<'_>, call_id: HirId) -> bool {\n+    cx.typeck_results().type_dependent_def_id(call_id).map_or(false, |id| {\n+        let sig = cx.tcx.fn_sig(id).skip_binder();\n+        sig.inputs().len() == 1 && sig.output().is_bool()\n+    })\n+}\n+\n+/// Checks if `<iter_ty as Iterator>::Item` is the same as `<collect_ty as IntoIter>::Item`\n+fn iterates_same_ty<'tcx>(cx: &LateContext<'tcx>, iter_ty: Ty<'tcx>, collect_ty: Ty<'tcx>) -> bool {\n+    let item = Symbol::intern(\"Item\");\n+    if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+        && let Some(into_iter_trait) = cx.tcx.get_diagnostic_item(sym::IntoIterator)\n+        && let Some(iter_item_ty) = make_normalized_projection(cx.tcx, cx.param_env, iter_trait, item, [iter_ty])\n+        && let Some(into_iter_item_proj) = make_projection(cx.tcx, into_iter_trait, item, [collect_ty])\n+        && let Ok(into_iter_item_ty) = cx.tcx.try_normalize_erasing_regions(\n+            cx.param_env,\n+            cx.tcx.mk_projection(into_iter_item_proj.item_def_id, into_iter_item_proj.substs)\n+        )\n+    {\n+        iter_item_ty == into_iter_item_ty\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks if the given method call matches the expected signature of\n+/// `([&[mut]] self, &<iter_ty as Iterator>::Item) -> bool`\n+fn is_contains_sig(cx: &LateContext<'_>, call_id: HirId, iter_expr: &Expr<'_>) -> bool {\n+    let typeck = cx.typeck_results();\n+    if let Some(id) = typeck.type_dependent_def_id(call_id)\n+        && let sig = cx.tcx.fn_sig(id)\n+        && sig.skip_binder().output().is_bool()\n+        && let [_, search_ty] = *sig.skip_binder().inputs()\n+        && let ty::Ref(_, search_ty, Mutability::Not) = *cx.tcx.erase_late_bound_regions(sig.rebind(search_ty)).kind()\n+        && let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+        && let Some(iter_item) = cx.tcx\n+            .associated_items(iter_trait)\n+            .find_by_name_and_kind(cx.tcx, Ident::with_dummy_span(Symbol::intern(\"Item\")), AssocKind::Type, iter_trait)\n+        && let substs = cx.tcx.mk_substs([GenericArg::from(typeck.expr_ty_adjusted(iter_expr))].into_iter())\n+        && let proj_ty = cx.tcx.mk_projection(iter_item.def_id, substs)\n+        && let Ok(item_ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, proj_ty)\n+    {\n+        item_ty == EarlyBinder(search_ty).subst(cx.tcx, cx.typeck_results().node_substs(call_id))\n+    } else {\n+        false\n+    }\n+}\n+\n struct IterFunction {\n     func: IterFunctionKind,\n     span: Span,"}, {"sha": "a022aac4bfee514ca4975ba089d13b0153a91096", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 132, "deletions": 2, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -13,8 +13,9 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n-    Region, RegionKind, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n+    self, AdtDef, AssocKind, Binder, BoundRegion, DefIdTree, FnSig, GenericParamDefKind, IntTy, ParamEnv, Predicate,\n+    PredicateKind, ProjectionTy, Region, RegionKind, SubstsRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable,\n+    TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n@@ -938,3 +939,132 @@ pub fn approx_ty_size<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> u64 {\n         (Err(_), _) => 0,\n     }\n }\n+\n+/// Makes the projection type for the named associated type in the given impl or trait impl.\n+///\n+/// This function is for associated types which are \"known\" to exist, and as such, will only return\n+/// `None` when debug assertions are disabled in order to prevent ICE's. With debug assertions\n+/// enabled this will check that the named associated type exists, the correct number of\n+/// substitutions are given, and that the correct kinds of substitutions are given (lifetime,\n+/// constant or type). This will not check if type normalization would succeed.\n+pub fn make_projection<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    container_id: DefId,\n+    assoc_ty: Symbol,\n+    substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+) -> Option<ProjectionTy<'tcx>> {\n+    fn helper<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        container_id: DefId,\n+        assoc_ty: Symbol,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Option<ProjectionTy<'tcx>> {\n+        let Some(assoc_item) = tcx\n+            .associated_items(container_id)\n+            .find_by_name_and_kind(tcx, Ident::with_dummy_span(assoc_ty), AssocKind::Type, container_id)\n+        else {\n+            debug_assert!(false, \"type `{assoc_ty}` not found in `{container_id:?}`\");\n+            return None;\n+        };\n+        #[cfg(debug_assertions)]\n+        {\n+            let generics = tcx.generics_of(assoc_item.def_id);\n+            let generic_count = generics.parent_count + generics.params.len();\n+            let params = generics\n+                .parent\n+                .map_or([].as_slice(), |id| &*tcx.generics_of(id).params)\n+                .iter()\n+                .chain(&generics.params)\n+                .map(|x| &x.kind);\n+\n+            debug_assert!(\n+                generic_count == substs.len(),\n+                \"wrong number of substs for `{:?}`: found `{}` expected `{}`.\\n\\\n+                    note: the expected parameters are: {:#?}\\n\\\n+                    the given arguments are: `{:#?}`\",\n+                assoc_item.def_id,\n+                substs.len(),\n+                generic_count,\n+                params.map(GenericParamDefKind::descr).collect::<Vec<_>>(),\n+                substs,\n+            );\n+\n+            if let Some((idx, (param, arg))) = params\n+                .clone()\n+                .zip(substs.iter().map(GenericArg::unpack))\n+                .enumerate()\n+                .find(|(_, (param, arg))| {\n+                    !matches!(\n+                        (param, arg),\n+                        (GenericParamDefKind::Lifetime, GenericArgKind::Lifetime(_))\n+                            | (GenericParamDefKind::Type { .. }, GenericArgKind::Type(_))\n+                            | (GenericParamDefKind::Const { .. }, GenericArgKind::Const(_))\n+                    )\n+                })\n+            {\n+                debug_assert!(\n+                    false,\n+                    \"mismatched subst type at index {}: expected a {}, found `{:?}`\\n\\\n+                        note: the expected parameters are {:#?}\\n\\\n+                        the given arguments are {:#?}\",\n+                    idx,\n+                    param.descr(),\n+                    arg,\n+                    params.map(GenericParamDefKind::descr).collect::<Vec<_>>(),\n+                    substs,\n+                );\n+            }\n+        }\n+\n+        Some(ProjectionTy {\n+            substs,\n+            item_def_id: assoc_item.def_id,\n+        })\n+    }\n+    helper(\n+        tcx,\n+        container_id,\n+        assoc_ty,\n+        tcx.mk_substs(substs.into_iter().map(Into::into)),\n+    )\n+}\n+\n+/// Normalizes the named associated type in the given impl or trait impl.\n+///\n+/// This function is for associated types which are \"known\" to be valid with the given\n+/// substitutions, and as such, will only return `None` when debug assertions are disabled in order\n+/// to prevent ICE's. With debug assertions enabled this will check that that type normalization\n+/// succeeds as well as everything checked by `make_projection`.\n+pub fn make_normalized_projection<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    container_id: DefId,\n+    assoc_ty: Symbol,\n+    substs: impl IntoIterator<Item = impl Into<GenericArg<'tcx>>>,\n+) -> Option<Ty<'tcx>> {\n+    fn helper<'tcx>(tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: ProjectionTy<'tcx>) -> Option<Ty<'tcx>> {\n+        #[cfg(debug_assertions)]\n+        if let Some((i, subst)) = ty\n+            .substs\n+            .iter()\n+            .enumerate()\n+            .find(|(_, subst)| subst.has_late_bound_regions())\n+        {\n+            debug_assert!(\n+                false,\n+                \"substs contain late-bound region at index `{i}` which can't be normalized.\\n\\\n+                    use `TyCtxt::erase_late_bound_regions`\\n\\\n+                    note: subst is `{subst:#?}`\",\n+            );\n+            return None;\n+        }\n+        match tcx.try_normalize_erasing_regions(param_env, tcx.mk_projection(ty.item_def_id, ty.substs)) {\n+            Ok(ty) => Some(ty),\n+            Err(e) => {\n+                debug_assert!(false, \"failed to normalize type `{ty}`: {e:#?}\");\n+                None\n+            },\n+        }\n+    }\n+    helper(tcx, param_env, make_projection(tcx, container_id, assoc_ty, substs)?)\n+}"}, {"sha": "2659ad384885e6a3e8efaea935716376a05e8667", "filename": "tests/ui/needless_collect.fixed", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.fixed?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -33,4 +33,33 @@ fn main() {\n     // `BinaryHeap` doesn't have `contains` method\n     sample.iter().count();\n     sample.iter().next().is_none();\n+\n+    // Don't lint string from str\n+    let _ = [\"\", \"\"].into_iter().collect::<String>().is_empty();\n+\n+    let _ = sample.iter().next().is_none();\n+    let _ = sample.iter().any(|x| x == &0);\n+\n+    struct VecWrapper<T>(Vec<T>);\n+    impl<T> core::ops::Deref for VecWrapper<T> {\n+        type Target = Vec<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> IntoIterator for VecWrapper<T> {\n+        type IntoIter = <Vec<T> as IntoIterator>::IntoIter;\n+        type Item = <Vec<T> as IntoIterator>::Item;\n+        fn into_iter(self) -> Self::IntoIter {\n+            self.0.into_iter()\n+        }\n+    }\n+    impl<T> FromIterator<T> for VecWrapper<T> {\n+        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+            Self(Vec::from_iter(iter))\n+        }\n+    }\n+\n+    let _ = sample.iter().next().is_none();\n+    let _ = sample.iter().any(|x| x == &0);\n }"}, {"sha": "535ec82982b13bcf45493412a527dfc38a886343", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -33,4 +33,33 @@ fn main() {\n     // `BinaryHeap` doesn't have `contains` method\n     sample.iter().collect::<BinaryHeap<_>>().len();\n     sample.iter().collect::<BinaryHeap<_>>().is_empty();\n+\n+    // Don't lint string from str\n+    let _ = [\"\", \"\"].into_iter().collect::<String>().is_empty();\n+\n+    let _ = sample.iter().collect::<HashSet<_>>().is_empty();\n+    let _ = sample.iter().collect::<HashSet<_>>().contains(&&0);\n+\n+    struct VecWrapper<T>(Vec<T>);\n+    impl<T> core::ops::Deref for VecWrapper<T> {\n+        type Target = Vec<T>;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    impl<T> IntoIterator for VecWrapper<T> {\n+        type IntoIter = <Vec<T> as IntoIterator>::IntoIter;\n+        type Item = <Vec<T> as IntoIterator>::Item;\n+        fn into_iter(self) -> Self::IntoIter {\n+            self.0.into_iter()\n+        }\n+    }\n+    impl<T> FromIterator<T> for VecWrapper<T> {\n+        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n+            Self(Vec::from_iter(iter))\n+        }\n+    }\n+\n+    let _ = sample.iter().collect::<VecWrapper<_>>().is_empty();\n+    let _ = sample.iter().collect::<VecWrapper<_>>().contains(&&0);\n }"}, {"sha": "584d2a1d8356f945292672f16fdb32f758b4da79", "filename": "tests/ui/needless_collect.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8bfc8bc5e0210dabd2976edad5bf285a96dcb360/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=8bfc8bc5e0210dabd2976edad5bf285a96dcb360", "patch": "@@ -66,5 +66,29 @@ error: avoid using `collect()` when not needed\n LL |     sample.iter().collect::<BinaryHeap<_>>().is_empty();\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n \n-error: aborting due to 11 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:40:27\n+   |\n+LL |     let _ = sample.iter().collect::<HashSet<_>>().is_empty();\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:41:27\n+   |\n+LL |     let _ = sample.iter().collect::<HashSet<_>>().contains(&&0);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == &0)`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:63:27\n+   |\n+LL |     let _ = sample.iter().collect::<VecWrapper<_>>().is_empty();\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect.rs:64:27\n+   |\n+LL |     let _ = sample.iter().collect::<VecWrapper<_>>().contains(&&0);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == &0)`\n+\n+error: aborting due to 15 previous errors\n "}]}