{"sha": "29ee5e25d1096f142729ea44c1286e50823762e8", "node_id": "C_kwDOAAsO6NoAKDI5ZWU1ZTI1ZDEwOTZmMTQyNzI5ZWE0NGMxMjg2ZTUwODIzNzYyZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-18T22:48:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-18T22:48:23Z"}, "message": "Auto merge of #8440 - Jarcho:transmute_undefined, r=Manishearth\n\nSome more fixes for `transmute_undefined_repr`\n\nchangelog: Fix transmuting a struct containing a pointer into a pointer in `transmute_undefined_repr`\nchangelog: Allow various forms of type erasure in `transmute_undefined_repr`", "tree": {"sha": "4cbd60e74ca3f54014ed4b849bbc85cd73d7f502", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cbd60e74ca3f54014ed4b849bbc85cd73d7f502"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29ee5e25d1096f142729ea44c1286e50823762e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29ee5e25d1096f142729ea44c1286e50823762e8", "html_url": "https://github.com/rust-lang/rust/commit/29ee5e25d1096f142729ea44c1286e50823762e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29ee5e25d1096f142729ea44c1286e50823762e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73367f8768f7ebffe3bba9c5b94813c2bb5c045f", "url": "https://api.github.com/repos/rust-lang/rust/commits/73367f8768f7ebffe3bba9c5b94813c2bb5c045f", "html_url": "https://github.com/rust-lang/rust/commit/73367f8768f7ebffe3bba9c5b94813c2bb5c045f"}, {"sha": "d28d19d74cfc94921efa06dffb1d3752d507f9dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d28d19d74cfc94921efa06dffb1d3752d507f9dd", "html_url": "https://github.com/rust-lang/rust/commit/d28d19d74cfc94921efa06dffb1d3752d507f9dd"}], "stats": {"total": 289, "additions": 196, "deletions": 93}, "files": [{"sha": "a4ef1344ab9511beb75790081393d1e456c98040", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_hir_ty_cfg_dependant;\n+use clippy_utils::ty::is_c_void;\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, GenericArg};\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::sym;\n \n use super::CAST_PTR_ALIGNMENT;\n \n@@ -62,19 +62,3 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_f\n         }\n     }\n }\n-\n-/// Check if the given type is either `core::ffi::c_void` or\n-/// one of the platform specific `libc::<platform>::c_void` of libc.\n-fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind() {\n-        let names = cx.get_def_path(adt.did);\n-\n-        if names.is_empty() {\n-            return false;\n-        }\n-        if names[0] == sym::libc || names[0] == sym::core && *names.last().unwrap() == sym!(c_void) {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "b6cc1676b0086ad3ae34f12837f9047e2d613ba7", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -1,5 +1,6 @@\n use super::TRANSMUTE_UNDEFINED_REPR;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::ty::is_c_void;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, Subst};\n@@ -18,33 +19,55 @@ pub(super) fn check<'tcx>(\n \n     while from_ty != to_ty {\n         match reduce_refs(cx, e.span, from_ty, to_ty) {\n-            ReducedTys::FromFatPtr { unsized_ty, .. } => {\n-                span_lint_and_then(\n-                    cx,\n-                    TRANSMUTE_UNDEFINED_REPR,\n-                    e.span,\n-                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                    |diag| {\n-                        if from_ty_orig.peel_refs() != unsized_ty {\n-                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                        }\n-                    },\n-                );\n-                return true;\n+            ReducedTys::FromFatPtr {\n+                unsized_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, to_sub_ty) {\n+                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::Ref(to_sub_ty) => {\n+                    from_ty = unsized_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if from_ty_orig.peel_refs() != unsized_ty {\n+                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n             },\n-            ReducedTys::ToFatPtr { unsized_ty, .. } => {\n-                span_lint_and_then(\n-                    cx,\n-                    TRANSMUTE_UNDEFINED_REPR,\n-                    e.span,\n-                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                    |diag| {\n-                        if to_ty_orig.peel_refs() != unsized_ty {\n-                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                        }\n-                    },\n-                );\n-                return true;\n+            ReducedTys::ToFatPtr {\n+                unsized_ty,\n+                from_ty: from_sub_ty,\n+            } => match reduce_ty(cx, from_sub_ty) {\n+                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::Ref(from_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = unsized_ty;\n+                    continue;\n+                },\n+                _ => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if to_ty_orig.peel_refs() != unsized_ty {\n+                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n             },\n             ReducedTys::ToPtr {\n                 from_ty: from_sub_ty,\n@@ -100,7 +123,8 @@ pub(super) fn check<'tcx>(\n                 from_ty: from_sub_ty,\n                 to_ty: to_sub_ty,\n             } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::IntArray | ReducedTy::TypeErasure, _)\n+                | (_, ReducedTy::IntArray | ReducedTy::TypeErasure) => return false,\n                 (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n                     span_lint_and_then(\n                         cx,\n@@ -182,13 +206,14 @@ pub(super) fn check<'tcx>(\n }\n \n enum ReducedTys<'tcx> {\n-    FromFatPtr { unsized_ty: Ty<'tcx> },\n-    ToFatPtr { unsized_ty: Ty<'tcx> },\n+    FromFatPtr { unsized_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    ToFatPtr { unsized_ty: Ty<'tcx>, from_ty: Ty<'tcx> },\n     ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n     FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n     Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n }\n \n+/// Remove references so long as both types are references.\n fn reduce_refs<'tcx>(\n     cx: &LateContext<'tcx>,\n     span: Span,\n@@ -208,12 +233,12 @@ fn reduce_refs<'tcx>(\n             (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n-                ReducedTys::FromFatPtr { unsized_ty }\n+                ReducedTys::FromFatPtr { unsized_ty, to_ty }\n             },\n             (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n-                ReducedTys::ToFatPtr { unsized_ty }\n+                ReducedTys::ToFatPtr { unsized_ty, from_ty }\n             },\n             (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n                 ReducedTys::FromPtr { from_ty, to_ty }\n@@ -227,13 +252,23 @@ fn reduce_refs<'tcx>(\n }\n \n enum ReducedTy<'tcx> {\n+    /// The type can be used for type erasure.\n+    TypeErasure,\n+    /// The type is a struct containing either zero non-zero sized fields, or multiple non-zero\n+    /// sized fields with a defined order.\n     OrderedFields(Ty<'tcx>),\n+    /// The type is a struct containing multiple non-zero sized fields with no defined order.\n     UnorderedFields(Ty<'tcx>),\n+    /// The type is a reference to the contained type.\n     Ref(Ty<'tcx>),\n-    Other(Ty<'tcx>),\n+    /// The type is an array of a primitive integer type. These can be used as storage for a value\n+    /// of another type.\n     IntArray,\n+    /// Any other type.\n+    Other(Ty<'tcx>),\n }\n \n+/// Reduce structs containing a single non-zero sized field to it's contained type.\n fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx> {\n     loop {\n         ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n@@ -243,6 +278,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 ty = sub_ty;\n                 continue;\n             },\n+            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n             ty::Tuple(args) => {\n                 let mut iter = args.iter().map(GenericArg::expect_ty);\n                 let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n@@ -261,7 +297,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n                 let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::OrderedFields(ty);\n+                    return ReducedTy::TypeErasure;\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n@@ -273,7 +309,12 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     ReducedTy::UnorderedFields(ty)\n                 }\n             },\n-            ty::Ref(..) | ty::RawPtr(_) => ReducedTy::Ref(ty),\n+            ty::Adt(def, _) if def.is_enum() && (def.variants.is_empty() || is_c_void(cx, ty)) => {\n+                ReducedTy::TypeErasure\n+            },\n+            ty::Foreign(_) => ReducedTy::TypeErasure,\n+            ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n+            ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n             _ => ReducedTy::Other(ty),\n         };\n     }"}, {"sha": "5b37a1de8ed865eeba3e93810a5578ec5ac5f41b", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -1,6 +1,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n+#![feature(let_chains)]\n #![feature(once_cell)]\n #![feature(rustc_private)]\n #![recursion_limit = \"512\"]"}, {"sha": "6c9ba64525a74fec4a7f1eba1a654cd5e956ba93", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -572,3 +572,17 @@ pub fn get_discriminant_value(tcx: TyCtxt<'_>, adt: &'_ AdtDef, i: VariantIdx) -\n         },\n     }\n }\n+\n+/// Check if the given type is either `core::ffi::c_void`, `std::os::raw::c_void`, or one of the\n+/// platform specific `libc::<platform>::c_void` types in libc.\n+pub fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    if let ty::Adt(adt, _) = ty.kind()\n+        && let &[krate, .., name] = &*cx.get_def_path(adt.did)\n+        && let sym::libc | sym::core | sym::std = krate\n+        && name.as_str() == \"c_void\"\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "b163d6056343d5b34e2e57f520c083a629db24ed", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -1,5 +1,8 @@\n #![warn(clippy::transmute_undefined_repr)]\n-#![allow(clippy::unit_arg)]\n+#![allow(clippy::unit_arg, clippy::transmute_ptr_to_ref)]\n+\n+use core::ffi::c_void;\n+use core::mem::{size_of, transmute};\n \n fn value<T>() -> T {\n     unimplemented!()\n@@ -14,35 +17,75 @@ struct Ty2C<T, U>(T, U);\n \n fn main() {\n     unsafe {\n-        let _: () = core::mem::transmute(value::<Empty>());\n-        let _: Empty = core::mem::transmute(value::<()>());\n+        let _: () = transmute(value::<Empty>());\n+        let _: Empty = transmute(value::<()>());\n \n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n-        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: Ty<u32> = transmute(value::<u32>());\n+        let _: Ty<u32> = transmute(value::<u32>());\n \n-        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n \n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n \n-        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n \n-        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n-        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+        let _: Ty<&()> = transmute(value::<&()>());\n+        let _: &() = transmute(value::<Ty<&()>>());\n \n-        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+        let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n \n-        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n-        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+        let _: Ty<usize> = transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n \n-        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+        let _: Ty<[u8; 8]> = transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n \n         // issue #8417\n-        let _: Ty2C<Ty2<u32, i32>, ()> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n-        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<Ty2<u32, i32>, ()>>()); // Ok, Ty2 types are the same\n+        let _: Ty2C<Ty2<u32, i32>, ()> = transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+        let _: Ty2<u32, i32> = transmute(value::<Ty2C<Ty2<u32, i32>, ()>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+        let _: *mut Ty2<u32, u32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Ok, Ty2 types are the same\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<*mut Ty2<u32, u32>>()); // Ok, Ty2 types are the same\n+\n+        let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+        let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: *const () = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const ()>()); // Ok, reverse type erasure\n+\n+        let _: *const c_void = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const c_void>()); // Ok, reverse type erasure\n+\n+        enum Erase {}\n+        let _: *const Erase = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase>()); // Ok, reverse type erasure\n+\n+        struct Erase2(\n+            [u8; 0],\n+            core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,\n+        );\n+        let _: *const Erase2 = transmute(value::<Ty<&Ty2<u32, f32>>>()); // Ok, type erasure\n+        let _: Ty<&Ty2<u32, f32>> = transmute(value::<*const Erase2>()); // Ok, reverse type erasure\n+\n+        let _: *const () = transmute(value::<&&[u8]>()); // Ok, type erasure\n+        let _: &&[u8] = transmute(value::<*const ()>()); // Ok, reverse type erasure\n+\n+        let _: *mut c_void = transmute(value::<&mut &[u8]>()); // Ok, type erasure\n+        let _: &mut &[u8] = transmute(value::<*mut c_void>()); // Ok, reverse type erasure\n+\n+        let _: [u8; size_of::<&[u8]>()] = transmute(value::<&[u8]>()); // Ok, transmute to byte array\n+        let _: &[u8] = transmute(value::<[u8; size_of::<&[u8]>()]>()); // Ok, transmute from byte array\n+\n+        let _: [usize; 2] = transmute(value::<&[u8]>()); // Ok, transmute to int array\n+        let _: &[u8] = transmute(value::<[usize; 2]>()); // Ok, transmute from int array\n+\n+        let _: *const [u8] = transmute(value::<Box<[u8]>>()); // Ok\n+        let _: Box<[u8]> = transmute(value::<*mut [u8]>()); // Ok\n     }\n }"}, {"sha": "42d544fc954c5b31034bb0dc2f0ace0f16ee1444", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/29ee5e25d1096f142729ea44c1286e50823762e8/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/29ee5e25d1096f142729ea44c1286e50823762e8/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=29ee5e25d1096f142729ea44c1286e50823762e8", "patch": "@@ -1,44 +1,64 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:23:33\n+  --> $DIR/transmute_undefined_repr.rs:26:33\n    |\n-LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:24:32\n+  --> $DIR/transmute_undefined_repr.rs:27:32\n    |\n-LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:29:32\n+  --> $DIR/transmute_undefined_repr.rs:32:32\n    |\n-LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:30:36\n+  --> $DIR/transmute_undefined_repr.rs:33:36\n    |\n-LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: transmute to `&Ty2<u32, f32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:35:33\n+error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:38:33\n    |\n-LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:39:37\n+   |\n+LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: transmute from `&Ty2<u32, f32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:36:37\n+error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:56:45\n    |\n-LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:57:37\n+   |\n+LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n "}]}