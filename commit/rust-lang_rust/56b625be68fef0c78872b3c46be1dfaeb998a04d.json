{"sha": "56b625be68fef0c78872b3c46be1dfaeb998a04d", "node_id": "C_kwDOAAsO6NoAKDU2YjYyNWJlNjhmZWYwYzc4ODcyYjNjNDZiZTFkZmFlYjk5OGEwNGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-11T04:07:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-11T04:07:17Z"}, "message": "Auto merge of #101482 - joboet:netbsd_parker, r=sanxiyn\n\nOptimize thread parking on NetBSD\n\nAs the futex syscall is not present in the latest stable release, NetBSD cannot use the efficient thread parker and locks Linux uses. Currently, it therefore relies on a pthread-based parker, consisting of a mutex and semaphore which protect a state variable. NetBSD however has more efficient syscalls available: [`_lwp_park`](https://man.netbsd.org/_lwp_park.2) and [`_lwp_unpark`](https://man.netbsd.org/_lwp_unpark.2). These already provide the exact semantics of `thread::park` and `Thread::unpark`, but work with thread ids. In `std`, this ID is here stored in an atomic state variable, which is also used to optimize cases were the parking token is already available at the time `thread::park` is called.\n\nr? `@m-ou-se`", "tree": {"sha": "bab01e6a9fac987fd02cc0ff2aae8b35b6f75d41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab01e6a9fac987fd02cc0ff2aae8b35b6f75d41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56b625be68fef0c78872b3c46be1dfaeb998a04d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56b625be68fef0c78872b3c46be1dfaeb998a04d", "html_url": "https://github.com/rust-lang/rust/commit/56b625be68fef0c78872b3c46be1dfaeb998a04d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56b625be68fef0c78872b3c46be1dfaeb998a04d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf", "html_url": "https://github.com/rust-lang/rust/commit/abd4d2ef0d23553c1d21b90d3b1353e3a42e1edf"}, {"sha": "81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/81b11ed6984f4cac4d2d8579dc0f694de024bb5a", "html_url": "https://github.com/rust-lang/rust/commit/81b11ed6984f4cac4d2d8579dc0f694de024bb5a"}], "stats": {"total": 148, "additions": 136, "deletions": 12}, "files": [{"sha": "e2453580dc72a62ffa3d2c60870426969de5e487", "filename": "library/std/src/sys/unix/thread_parker/mod.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fmod.rs?ref=56b625be68fef0c78872b3c46be1dfaeb998a04d", "patch": "@@ -0,0 +1,21 @@\n+//! Thread parking on systems without futex support.\n+\n+#![cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"fuchsia\",\n+)))]\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"netbsd\")] {\n+        mod netbsd;\n+        pub use netbsd::Parker;\n+    } else {\n+        mod pthread;\n+        pub use pthread::Parker;\n+    }\n+}"}, {"sha": "7657605b52f0d99d70db8599d5cb5d5b32d86be2", "filename": "library/std/src/sys/unix/thread_parker/netbsd.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fnetbsd.rs?ref=56b625be68fef0c78872b3c46be1dfaeb998a04d", "patch": "@@ -0,0 +1,113 @@\n+use crate::ffi::{c_int, c_void};\n+use crate::pin::Pin;\n+use crate::ptr::{null, null_mut};\n+use crate::sync::atomic::{\n+    AtomicU64,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::time::Duration;\n+use libc::{_lwp_self, clockid_t, lwpid_t, time_t, timespec, CLOCK_MONOTONIC};\n+\n+extern \"C\" {\n+    fn ___lwp_park60(\n+        clock_id: clockid_t,\n+        flags: c_int,\n+        ts: *mut timespec,\n+        unpark: lwpid_t,\n+        hint: *const c_void,\n+        unparkhint: *const c_void,\n+    ) -> c_int;\n+    fn _lwp_unpark(lwp: lwpid_t, hint: *const c_void) -> c_int;\n+}\n+\n+/// The thread is not parked and the token is not available.\n+///\n+/// Zero cannot be a valid LWP id, since it is used as empty value for the unpark\n+/// argument in _lwp_park.\n+const EMPTY: u64 = 0;\n+/// The token is available. Do not park anymore.\n+const NOTIFIED: u64 = u64::MAX;\n+\n+pub struct Parker {\n+    /// The parker state. Contains either one of the two state values above or the LWP\n+    /// id of the parked thread.\n+    state: AtomicU64,\n+}\n+\n+impl Parker {\n+    pub unsafe fn new(parker: *mut Parker) {\n+        parker.write(Parker { state: AtomicU64::new(EMPTY) })\n+    }\n+\n+    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        // If the token has already been made available, we can skip\n+        // a bit of work, so check for it here.\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let parked = _lwp_self() as u64;\n+            let hint = self.state.as_mut_ptr().cast();\n+            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n+                // Loop to guard against spurious wakeups.\n+                loop {\n+                    ___lwp_park60(0, 0, null_mut(), 0, hint, null());\n+                    if self.state.load(Acquire) == NOTIFIED {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // At this point, the change to NOTIFIED has always been observed with acquire\n+        // ordering, so we can just use a relaxed store here (instead of a swap).\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // Does not actually need `unsafe` or `Pin`, but the pthread implementation does.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let parked = _lwp_self() as u64;\n+            let hint = self.state.as_mut_ptr().cast();\n+            let mut timeout = timespec {\n+                // Saturate so that the operation will definitely time out\n+                // (even if it is after the heat death of the universe).\n+                tv_sec: dur.as_secs().try_into().ok().unwrap_or(time_t::MAX),\n+                tv_nsec: dur.subsec_nanos().into(),\n+            };\n+\n+            if self.state.compare_exchange(EMPTY, parked, Relaxed, Acquire).is_ok() {\n+                // Timeout needs to be mutable since it is modified on NetBSD 9.0 and\n+                // above.\n+                ___lwp_park60(CLOCK_MONOTONIC, 0, &mut timeout, 0, hint, null());\n+                // Use a swap to get acquire ordering even if the token was set after\n+                // the timeout occurred.\n+                self.state.swap(EMPTY, Acquire);\n+                return;\n+            }\n+        }\n+\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // Does not actually need `Pin`, but the pthread implementation does.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+        if !matches!(state, EMPTY | NOTIFIED) {\n+            let lwp = state as lwpid_t;\n+            let hint = self.state.as_mut_ptr().cast();\n+\n+            // If the parking thread terminated and did not actually park, this will\n+            // probably return an error, which is OK. In the worst case, another\n+            // thread has received the same LWP id. It will then receive a spurious\n+            // wakeup, but those are allowable per the API contract. The same reasoning\n+            // applies if a timeout occurred before this call, but the state was not\n+            // yet reset.\n+\n+            // SAFETY:\n+            // The syscall has no invariants to hold. Only unsafe because it is an\n+            // extern function.\n+            unsafe {\n+                _lwp_unpark(lwp, hint);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3dfc0026ed1a43a219c51c870c5d402944913789", "filename": "library/std/src/sys/unix/thread_parker/pthread.rs", "status": "renamed", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b625be68fef0c78872b3c46be1dfaeb998a04d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs?ref=56b625be68fef0c78872b3c46be1dfaeb998a04d", "patch": "@@ -1,15 +1,5 @@\n //! Thread parking without `futex` using the `pthread` synchronization primitives.\n \n-#![cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    all(target_os = \"emscripten\", target_feature = \"atomics\"),\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"fuchsia\",\n-)))]\n-\n use crate::cell::UnsafeCell;\n use crate::marker::PhantomPinned;\n use crate::pin::Pin;\n@@ -59,8 +49,8 @@ unsafe fn wait_timeout(\n         target_os = \"espidf\"\n     ))]\n     let (now, dur) = {\n-        use super::time::SystemTime;\n         use crate::cmp::min;\n+        use crate::sys::time::SystemTime;\n \n         // OSX implementation of `pthread_cond_timedwait` is buggy\n         // with super long durations. When duration is greater than\n@@ -85,7 +75,7 @@ unsafe fn wait_timeout(\n         target_os = \"espidf\"\n     )))]\n     let (now, dur) = {\n-        use super::time::Timespec;\n+        use crate::sys::time::Timespec;\n \n         (Timespec::now(libc::CLOCK_MONOTONIC), dur)\n     };", "previous_filename": "library/std/src/sys/unix/thread_parker.rs"}]}