{"sha": "1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMjRhNTkxZGQ0M2M1M2RlN2UzZjE2ZWZmOWY2NzQ2OWNmN2E1MmI=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-04-26T21:22:45Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-05-14T18:30:22Z"}, "message": "Remove rustc_llvm dependency from rustc_metadata\n\nMove the code for loading metadata from rlibs and dylibs from\nrustc_metadata into rustc_trans, and introduce a trait to avoid\nintroducing a direct dependency on rustc_trans.\n\nThis means rustc_metadata is no longer rebuilt when LLVM changes.", "tree": {"sha": "0e531f937a46e86789bd395f9085ce3bf656d555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e531f937a46e86789bd395f9085ce3bf656d555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "html_url": "https://github.com/rust-lang/rust/commit/1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/comments", "author": null, "committer": null, "parents": [{"sha": "9f15631c36665911eb8e6f594ebcfe93e65a461c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f15631c36665911eb8e6f594ebcfe93e65a461c", "html_url": "https://github.com/rust-lang/rust/commit/9f15631c36665911eb8e6f594ebcfe93e65a461c"}], "stats": {"total": 495, "additions": 276, "deletions": 219}, "files": [{"sha": "bd9fda42570fde504b0a6ef30d4c03d0893dbc5d", "filename": "src/Cargo.lock", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -316,6 +316,14 @@ name = \"open\"\n version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"owning_ref\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n@@ -442,6 +450,7 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n@@ -626,13 +635,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n@@ -734,6 +743,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n@@ -820,6 +830,11 @@ dependencies = [\n name = \"serialize\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"std\"\n version = \"0.0.0\"\n@@ -1015,6 +1030,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca313f1862c7ec3e0dfe8ace9fa91b1d9cb5c84ace3d00f5ec4216238e93c167\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n+\"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n \"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n \"checksum pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1058d7bb927ca067656537eec4e02c2b4b70eaaa129664c5b90c111e20326f41\"\n@@ -1026,6 +1042,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684ce48436d6465300c9ea783b6b14c4361d6b8dcbb1375b486a69cc19e2dfb0\"\n \"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n \"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n+\"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n \"checksum term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07b6c1ac5b3fffd75073276bca1ceed01f67a28537097a2a9539e116e50fb21a\"\n \"checksum thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4437c97558c70d129e40629a5b385b3fb1ffac301e63941335e4d354081ec14a\""}, {"sha": "3c762e43e9aa6e8e7c118e24518f53691f3b1f19", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -13,6 +13,7 @@ arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "c979677ff717c277d6a120cd21b566ad52633a84", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -54,6 +54,7 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n+extern crate owning_ref;\n extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;"}, {"sha": "a68aca4600054ac2ba3e9d87b7df727ad2d0f09b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -36,8 +36,9 @@ use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n \n use std::any::Any;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -201,11 +202,33 @@ impl EncodedMetadataHashes {\n     }\n }\n \n+/// The backend's way to give the crate store access to the metadata in a library.\n+/// Note that it returns the raw metadata bytes stored in the library file, whether\n+/// it is compressed, uncompressed, some weird mix, etc.\n+/// rmeta files are backend independent and not handled here.\n+///\n+/// At the time of this writing, there is only one backend and one way to store\n+/// metadata in library -- this trait just serves to decouple rustc_metadata from\n+/// the archive reader, which depends on LLVM.\n+pub trait MetadataLoader {\n+    fn get_rlib_metadata(&self,\n+                         target: &Target,\n+                         filename: &Path)\n+                         -> Result<ErasedBoxRef<[u8]>, String>;\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String>;\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader;\n+\n     // item info\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n@@ -275,8 +298,6 @@ pub trait CrateStore {\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str;\n-    fn metadata_section_name(&self, target: &Target) -> &str;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n@@ -413,8 +434,6 @@ impl CrateStore for DummyCrateStore {\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n-    fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n@@ -427,6 +446,9 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+\n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n }\n \n pub trait CrateLoader {"}, {"sha": "2dab680ad45aa581599368b2da5d8505b9f92120", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -204,7 +204,7 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n@@ -409,7 +409,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph));\n+                let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n@@ -558,7 +558,11 @@ impl RustcDefaultCalls {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target.target, path, &mut v).unwrap();\n+                    locator::list_file_metadata(&sess.target.target,\n+                                                path,\n+                                                sess.cstore.metadata_loader(),\n+                                                &mut v)\n+                            .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n                 &Input::Str { .. } => {"}, {"sha": "be4f64b7109c5cddce87905362bd293027e04688", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{CodeExtent, RegionMaps};\n@@ -104,7 +105,7 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,"}, {"sha": "f47788ee036dc5e312d4a05754a3f4b0cd8c7143", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -11,13 +11,13 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "dc7be42e452cb357352c9d9bbb8b9e41ebdc8bcb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -393,6 +393,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n+                metadata_loader: &*self.cstore.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).or_else(|| {\n@@ -554,6 +555,7 @@ impl<'a> CrateLoader<'a> {\n             rejected_via_filename: vec![],\n             should_match_name: true,\n             is_proc_macro: None,\n+            metadata_loader: &*self.cstore.metadata_loader,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {\n             if !is_cross {"}, {"sha": "d2ad6d0ab344999a00dbf6375cda9e8b45bb51b2", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -11,21 +11,20 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use locator;\n use schema::{self, Tracked};\n \n use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{DepKind, ExternCrate};\n+use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use flate::Bytes;\n+use owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -43,11 +42,7 @@ pub use cstore_impl::provide;\n // own crate numbers.\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub enum MetadataBlob {\n-    Inflated(Bytes),\n-    Archive(locator::ArchiveMetadata),\n-    Raw(Vec<u8>),\n-}\n+pub struct MetadataBlob(pub ErasedBoxRef<[u8]>);\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n /// See `imported_filemaps()` for more information.\n@@ -103,10 +98,11 @@ pub struct CStore {\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n+    pub metadata_loader: Box<MetadataLoader>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph) -> CStore {\n+    pub fn new(dep_graph: &DepGraph, metadata_loader: Box<MetadataLoader>) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n@@ -116,6 +112,7 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n+            metadata_loader: metadata_loader,\n         }\n     }\n "}, {"sha": "1a2298d3fb1bacc2fb534674e3bf33dff9d5ba34", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -10,12 +10,11 @@\n \n use cstore;\n use encoder;\n-use locator;\n use schema;\n \n use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            ExternCrate, NativeLibrary, LinkMeta,\n+                            ExternCrate, NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def;\n use rustc::middle::lang_items;\n@@ -38,7 +37,6 @@ use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n use rustc::hir::svh::Svh;\n-use rustc_back::target::Target;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -135,6 +133,10 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(krate)\n     }\n \n+    fn metadata_loader(&self) -> &MetadataLoader {\n+        &*self.metadata_loader\n+    }\n+\n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_visibility(def.index)\n@@ -420,17 +422,6 @@ impl CrateStore for cstore::CStore {\n     {\n         self.get_used_link_args().borrow().clone()\n     }\n-\n-    fn metadata_filename(&self) -> &str\n-    {\n-        locator::METADATA_FILENAME\n-    }\n-\n-    fn metadata_section_name(&self, target: &Target) -> &str\n-    {\n-        locator::meta_section_name(target)\n-    }\n-\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n@@ -522,4 +513,4 @@ impl CrateStore for cstore::CStore {\n         drop(visible_parent_map);\n         self.visible_parent_map.borrow()\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "c734b9f411c2fb05ef112595893544fefacd1f5f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -77,11 +77,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n-        match *self {\n-            MetadataBlob::Inflated(ref vec) => vec,\n-            MetadataBlob::Archive(ref ar) => ar.as_slice(),\n-            MetadataBlob::Raw(ref vec) => vec,\n-        }\n+        &self.0\n     }\n }\n "}, {"sha": "e3d9e5ac74a062a6a53e5fa9909651117d726858", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -37,6 +37,7 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving\n+extern crate owning_ref;\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n extern crate proc_macro;\n@@ -46,7 +47,6 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n-extern crate rustc_llvm;\n \n mod diagnostics;\n "}, {"sha": "34b07af9f01f439cf84e551c5ff5cd629b6bcf98", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 61, "deletions": 164, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -224,15 +224,12 @@ use creader::Library;\n use schema::{METADATA_HEADER, rustc_version};\n \n use rustc::hir::svh::Svh;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n-use rustc::util::common;\n use rustc::util::nodemap::FxHashMap;\n \n-use rustc_llvm as llvm;\n-use rustc_llvm::{False, ObjectFile, mk_section_iter};\n-use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -243,11 +240,10 @@ use std::fmt;\n use std::fs::{self, File};\n use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n-use std::ptr;\n-use std::slice;\n use std::time::Instant;\n \n use flate;\n+use owning_ref::{ErasedBoxRef, OwningRef};\n \n pub struct CrateMismatch {\n     path: PathBuf,\n@@ -272,12 +268,7 @@ pub struct Context<'a> {\n     pub rejected_via_filename: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n     pub is_proc_macro: Option<bool>,\n-}\n-\n-pub struct ArchiveMetadata {\n-    _archive: ArchiveRO,\n-    // points into self._archive\n-    data: *const [u8],\n+    pub metadata_loader: &'a MetadataLoader,\n }\n \n pub struct CratePaths {\n@@ -287,8 +278,6 @@ pub struct CratePaths {\n     pub rmeta: Option<PathBuf>,\n }\n \n-pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n-\n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n@@ -596,20 +585,21 @@ impl<'a> Context<'a> {\n         let mut err: Option<DiagnosticBuilder> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n-                Ok(blob) => {\n-                    if let Some(h) = self.crate_matches(&blob, &lib) {\n-                        (h, blob)\n-                    } else {\n-                        info!(\"metadata mismatch\");\n+            let (hash, metadata) =\n+                match get_metadata_section(self.target, flavor, &lib, self.metadata_loader) {\n+                    Ok(blob) => {\n+                        if let Some(h) = self.crate_matches(&blob, &lib) {\n+                            (h, blob)\n+                        } else {\n+                            info!(\"metadata mismatch\");\n+                            continue;\n+                        }\n+                    }\n+                    Err(err) => {\n+                        info!(\"no metadata found: {}\", err);\n                         continue;\n                     }\n-                }\n-                Err(err) => {\n-                    info!(\"no metadata found: {}\", err);\n-                    continue;\n-                }\n-            };\n+                };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n                 let mut e = struct_span_err!(self.sess,\n@@ -833,50 +823,14 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n     err.note(&format!(\"crate name: {}\", name));\n }\n \n-impl ArchiveMetadata {\n-    fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data = {\n-            let section = ar.iter()\n-                .filter_map(|s| s.ok())\n-                .find(|sect| sect.name() == Some(METADATA_FILENAME));\n-            match section {\n-                Some(s) => s.data() as *const [u8],\n-                None => {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    return None;\n-                }\n-            }\n-        };\n-\n-        Some(ArchiveMetadata {\n-            _archive: ar,\n-            data: data,\n-        })\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        unsafe { &*self.data }\n-    }\n-}\n-\n-fn verify_decompressed_encoding_version(blob: &MetadataBlob,\n-                                        filename: &Path)\n-                                        -> Result<(), String> {\n-    if !blob.is_compatible() {\n-        Err((format!(\"incompatible metadata version found: '{}'\",\n-                     filename.display())))\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(target: &Target,\n                         flavor: CrateFlavor,\n-                        filename: &Path)\n+                        filename: &Path,\n+                        loader: &MetadataLoader)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n-    let ret = get_metadata_section_imp(target, flavor, filename);\n+    let ret = get_metadata_section_imp(target, flavor, filename, loader);\n     info!(\"reading {:?} => {:?}\",\n           filename.file_name().unwrap(),\n           start.elapsed());\n@@ -885,118 +839,61 @@ fn get_metadata_section(target: &Target,\n \n fn get_metadata_section_imp(target: &Target,\n                             flavor: CrateFlavor,\n-                            filename: &Path)\n+                            filename: &Path,\n+                            loader: &MetadataLoader)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if flavor == CrateFlavor::Rlib {\n-        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n-        // internally to read the file. We also avoid even using a memcpy by\n-        // just keeping the archive along while the metadata is in use.\n-        let archive = match ArchiveRO::open(filename) {\n-            Some(ar) => ar,\n-            None => {\n-                debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\", filename.display()));\n+    let raw_bytes: ErasedBoxRef<[u8]> = match flavor {\n+        CrateFlavor::Rlib => loader.get_rlib_metadata(target, filename)?,\n+        CrateFlavor::Dylib => {\n+            let buf = loader.get_dylib_metadata(target, filename)?;\n+            // The header is uncompressed\n+            let header_len = METADATA_HEADER.len();\n+            debug!(\"checking {} bytes of metadata-version stamp\", header_len);\n+            let header = &buf[..cmp::min(header_len, buf.len())];\n+            if header != METADATA_HEADER {\n+                return Err(format!(\"incompatible metadata version found: '{}'\",\n+                                   filename.display()));\n             }\n-        };\n-        return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n-            None => Err(format!(\"failed to read rlib metadata: '{}'\", filename.display())),\n-            Some(blob) => {\n-                verify_decompressed_encoding_version(&blob, filename)?;\n-                Ok(blob)\n-            }\n-        };\n-    } else if flavor == CrateFlavor::Rmeta {\n-        let mut file = File::open(filename).map_err(|_|\n-            format!(\"could not open file: '{}'\", filename.display()))?;\n-        let mut buf = vec![];\n-        file.read_to_end(&mut buf).map_err(|_|\n-            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n-        let blob = MetadataBlob::Raw(buf);\n-        verify_decompressed_encoding_version(&blob, filename)?;\n-        return Ok(blob);\n-    }\n-    unsafe {\n-        let buf = common::path2cstr(filename);\n-        let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-        if mb as isize == 0 {\n-            return Err(format!(\"error reading library: '{}'\", filename.display()));\n-        }\n-        let of = match ObjectFile::new(mb) {\n-            Some(of) => of,\n-            _ => {\n-                return Err((format!(\"provided path not an object file: '{}'\", filename.display())))\n-            }\n-        };\n-        let si = mk_section_iter(of.llof);\n-        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let mut name_buf = ptr::null();\n-            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n-            let name = String::from_utf8(name).unwrap();\n-            debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(target) == name {\n-                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n-                let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = METADATA_HEADER.len();\n-                debug!(\"checking {} bytes of metadata-version stamp\", vlen);\n-                let minsz = cmp::min(vlen, csz);\n-                let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == METADATA_HEADER;\n-                if !version_ok {\n-                    return Err((format!(\"incompatible metadata version found: '{}'\",\n-                                        filename.display())));\n-                }\n \n-                let cvbuf1 = cvbuf.offset(vlen as isize);\n-                debug!(\"inflating {} bytes of compressed metadata\", csz - vlen);\n-                let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n-                match flate::inflate_bytes(bytes) {\n-                    Ok(inflated) => {\n-                        let blob = MetadataBlob::Inflated(inflated);\n-                        verify_decompressed_encoding_version(&blob, filename)?;\n-                        return Ok(blob);\n-                    }\n-                    Err(_) => {}\n+            // Header is okay -> inflate the actual metadata\n+            let compressed_bytes = &buf[header_len..];\n+            debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n+            match flate::inflate_bytes(compressed_bytes) {\n+                Ok(inflated) => {\n+                    let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n+                    buf.map_owner_box().erase_owner()\n+                }\n+                Err(_) => {\n+                    return Err(format!(\"failed to decompress metadata: {}\", filename.display()));\n                 }\n             }\n-            llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        Err(format!(\"metadata not found: '{}'\", filename.display()))\n-    }\n-}\n-\n-pub fn meta_section_name(target: &Target) -> &'static str {\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, that's another good question...\n-\n-    if target.options.is_like_osx {\n-        \"__DATA,.rustc\"\n+        CrateFlavor::Rmeta => {\n+            let mut file = File::open(filename).map_err(|_|\n+                format!(\"could not open file: '{}'\", filename.display()))?;\n+            let mut buf = vec![];\n+            file.read_to_end(&mut buf).map_err(|_|\n+                format!(\"failed to read rmeta metadata: '{}'\", filename.display()))?;\n+            OwningRef::new(buf).map_owner_box().erase_owner()\n+        }\n+    };\n+    let blob = MetadataBlob(raw_bytes);\n+    if blob.is_compatible() {\n+        Ok(blob)\n     } else {\n-        \".rustc\"\n+        Err(format!(\"incompatible metadata version found: '{}'\", filename.display()))\n     }\n }\n \n-pub fn read_meta_section_name(_target: &Target) -> &'static str {\n-    \".rustc\"\n-}\n-\n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) -> io::Result<()> {\n+pub fn list_file_metadata(target: &Target,\n+                          path: &Path,\n+                          loader: &MetadataLoader,\n+                          out: &mut io::Write)\n+                          -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1005,7 +902,7 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path) {\n+    match get_metadata_section(target, flavor, path, loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "4ccc85257f3c990ba313df23fa87a9de43476721", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -12,6 +12,7 @@ test = false\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "902065c8688d0d808fb6c2c29d25c82d8bbd219a", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -20,6 +20,7 @@ use std::str;\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n+use metadata::METADATA_FILENAME;\n use rustc::session::Session;\n \n pub struct ArchiveConfig<'a> {\n@@ -158,11 +159,9 @@ impl<'a> ArchiveBuilder<'a> {\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n-        let metadata_filename =\n-            self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, move |fname: &str| {\n-            if fname.ends_with(bc_ext) || fname == metadata_filename {\n+            if fname.ends_with(bc_ext) || fname == METADATA_FILENAME {\n                 return true\n             }\n "}, {"sha": "b8aabef65a984adf76c8364ba0337797460ee009", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -13,6 +13,7 @@ use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n+use metadata::METADATA_FILENAME;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n@@ -521,7 +522,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(sess.cstore.metadata_filename());\n+            let metadata = tmpdir.join(METADATA_FILENAME);\n             emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n@@ -1141,8 +1142,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         archive.update_symbols();\n \n         for f in archive.src_files() {\n-            if f.ends_with(\"bytecode.deflate\") ||\n-                f == sess.cstore.metadata_filename() {\n+            if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }\n@@ -1217,8 +1217,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(\"bytecode.deflate\") ||\n-                   f == sess.cstore.metadata_filename() {\n+                if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }"}, {"sha": "437ced85b2e4ad48ec97d7186ea54f5d50820764", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -34,6 +34,7 @@ use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n+use metadata;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n use middle::cstore::EncodedMetadata;\n@@ -778,8 +779,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name =\n-            tcx.sess.cstore.metadata_section_name(&tcx.sess.target.target);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n         let name = CString::new(section_name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "15a1b32a5fd58c5b413a76e52719bb6d8b71fc76", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -45,6 +45,7 @@ use syntax_pos::symbol::Symbol;\n \n extern crate flate;\n extern crate libc;\n+extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n@@ -70,6 +71,8 @@ pub use rustc::util;\n pub use base::trans_crate;\n pub use back::symbol_names::provide;\n \n+pub use metadata::LlvmMetadataLoader;\n+\n pub mod back {\n     pub use rustc::hir::svh;\n \n@@ -120,6 +123,7 @@ mod declare;\n mod glue;\n mod intrinsic;\n mod machine;\n+mod metadata;\n mod meth;\n mod mir;\n mod monomorphize;"}, {"sha": "2c0148dfbb371851958c0e4b0c10464818ab0b65", "filename": "src/librustc_trans/metadata.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc_back::target::Target;\n+use llvm;\n+use llvm::{False, ObjectFile, mk_section_iter};\n+use llvm::archive_ro::ArchiveRO;\n+\n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use std::path::Path;\n+use std::ptr;\n+use std::slice;\n+\n+pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n+\n+pub struct LlvmMetadataLoader;\n+\n+impl MetadataLoader for LlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n+        // internally to read the file. We also avoid even using a memcpy by\n+        // just keeping the archive along while the metadata is in use.\n+        let archive = ArchiveRO::open(filename)\n+            .map(|ar| OwningRef::new(box ar))\n+            .ok_or_else(|| {\n+                            debug!(\"llvm didn't like `{}`\", filename.display());\n+                            format!(\"failed to read rlib metadata: '{}'\", filename.display())\n+                        })?;\n+        let buf: OwningRef<_, [u8]> = archive\n+            .try_map(|ar| {\n+                ar.iter()\n+                    .filter_map(|s| s.ok())\n+                    .find(|sect| sect.name() == Some(METADATA_FILENAME))\n+                    .map(|s| s.data())\n+                    .ok_or_else(|| {\n+                                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                                    format!(\"failed to read rlib metadata: '{}'\",\n+                                            filename.display())\n+                                })\n+            })?;\n+        Ok(buf.erase_owner())\n+    }\n+\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String> {\n+        unsafe {\n+            let buf = common::path2cstr(filename);\n+            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n+            if mb as isize == 0 {\n+                return Err(format!(\"error reading library: '{}'\", filename.display()));\n+            }\n+            let of = ObjectFile::new(mb)\n+                .map(|of| OwningRef::new(box of))\n+                .ok_or_else(|| format!(\"provided path not an object file: '{}'\",\n+                                        filename.display()))?;\n+            let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n+            Ok(buf.erase_owner())\n+        }\n+    }\n+}\n+\n+fn search_meta_section<'a>(of: &'a ObjectFile,\n+                           target: &Target,\n+                           filename: &Path)\n+                           -> Result<&'a [u8], String> {\n+    unsafe {\n+        let si = mk_section_iter(of.llof);\n+        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+            let mut name_buf = ptr::null();\n+            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n+            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n+            let name = String::from_utf8(name).unwrap();\n+            debug!(\"get_metadata_section: name {}\", name);\n+            if read_metadata_section_name(target) == name {\n+                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n+                // The buffer is valid while the object file is around\n+                let buf: &'a [u8] = slice::from_raw_parts(cbuf as *const u8, csz);\n+                return Ok(buf);\n+            }\n+            llvm::LLVMMoveToNextSection(si.llsi);\n+        }\n+    }\n+    Err(format!(\"metadata not found: '{}'\", filename.display()))\n+}\n+\n+pub fn metadata_section_name(target: &Target) -> &'static str {\n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, that's another good question...\n+\n+    if target.options.is_like_osx {\n+        \"__DATA,.rustc\"\n+    } else {\n+        \".rustc\"\n+    }\n+}\n+\n+fn read_metadata_section_name(_target: &Target) -> &'static str {\n+    \".rustc\"\n+}"}, {"sha": "d41e9931409697b07bed00517353f7b27579b3c1", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -138,7 +139,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n     );"}, {"sha": "0600ae5b66e7e5b1530025454e245d767e84c484", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -34,6 +34,7 @@ use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n@@ -81,7 +82,7 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n     );\n@@ -229,7 +230,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n     );"}, {"sha": "74ecdab33725bb2dc9234f150118031c365bc972", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a24a591dd43c53de7e3f16eff9f67469cf7a52b/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=1a24a591dd43c53de7e3f16eff9f67469cf7a52b", "patch": "@@ -15,6 +15,7 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n+extern crate rustc_trans;\n extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n@@ -58,7 +59,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, Box::new(rustc_trans::LlvmMetadataLoader)));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)"}]}