{"sha": "f46bc12199dc88b88bd826f49d5c5af6e9caf727", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NmJjMTIxOTlkYzg4Yjg4YmQ4MjZmNDlkNWM1YWY2ZTljYWY3Mjc=", "commit": {"author": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-11T21:25:58Z"}, "committer": {"name": "Mikhail Rakhmanov", "email": "rakhmanov.m@gmail.com", "date": "2020-06-11T21:25:58Z"}, "message": "Add more patterns and keywords", "tree": {"sha": "1784e7fe8a7fa53e9d1704b782272c45ff23db66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1784e7fe8a7fa53e9d1704b782272c45ff23db66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f46bc12199dc88b88bd826f49d5c5af6e9caf727", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f46bc12199dc88b88bd826f49d5c5af6e9caf727", "html_url": "https://github.com/rust-lang/rust/commit/f46bc12199dc88b88bd826f49d5c5af6e9caf727", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f46bc12199dc88b88bd826f49d5c5af6e9caf727/comments", "author": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcrakhman", "id": 16068868, "node_id": "MDQ6VXNlcjE2MDY4ODY4", "avatar_url": "https://avatars.githubusercontent.com/u/16068868?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcrakhman", "html_url": "https://github.com/mcrakhman", "followers_url": "https://api.github.com/users/mcrakhman/followers", "following_url": "https://api.github.com/users/mcrakhman/following{/other_user}", "gists_url": "https://api.github.com/users/mcrakhman/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcrakhman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcrakhman/subscriptions", "organizations_url": "https://api.github.com/users/mcrakhman/orgs", "repos_url": "https://api.github.com/users/mcrakhman/repos", "events_url": "https://api.github.com/users/mcrakhman/events{/privacy}", "received_events_url": "https://api.github.com/users/mcrakhman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb4004fdb8f4cef602581d1fb35e515748d586cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4004fdb8f4cef602581d1fb35e515748d586cb", "html_url": "https://github.com/rust-lang/rust/commit/eb4004fdb8f4cef602581d1fb35e515748d586cb"}], "stats": {"total": 114, "additions": 59, "deletions": 55}, "files": [{"sha": "50f003949add102f06305c23b9388b9b6e397aee", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=f46bc12199dc88b88bd826f49d5c5af6e9caf727", "patch": "@@ -62,7 +62,7 @@ fn add_keyword(\n pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     add_keyword(ctx, acc, \"fn\", \"fn $0() {}\", ctx.is_new_item || ctx.block_expr_parent);\n     add_keyword(ctx, acc, \"type\", \"type \", ctx.is_new_item || ctx.block_expr_parent);\n-    add_keyword(ctx, acc, \"fn\", \"fn $0() {}\", ctx.is_new_item || ctx.block_expr_parent);\n+    add_keyword(ctx, acc, \"use\", \"fn $0() {}\", ctx.is_new_item || ctx.block_expr_parent);\n     add_keyword(ctx, acc, \"impl\", \"impl $0 {}\", ctx.is_new_item);\n     add_keyword(ctx, acc, \"trait\", \"impl $0 {}\", ctx.is_new_item);\n     add_keyword(ctx, acc, \"enum\", \"enum $0 {}\", ctx.is_new_item && !ctx.after_unsafe);\n@@ -72,7 +72,6 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     add_keyword(ctx, acc, \"loop\", \"loop {$0}\", ctx.block_expr_parent);\n     add_keyword(ctx, acc, \"while\", \"while $0 {}\", ctx.block_expr_parent);\n     add_keyword(ctx, acc, \"let\", \"let \", ctx.after_if || ctx.block_expr_parent);\n-    add_keyword(ctx, acc, \"let\", \"let \", ctx.after_if || ctx.block_expr_parent);\n     add_keyword(ctx, acc, \"else\", \"else {$0}\", ctx.after_if);\n     add_keyword(ctx, acc, \"else if\", \"else if $0 {}\", ctx.after_if);\n     add_keyword(ctx, acc, \"mod\", \"mod $0 {}\", ctx.is_new_item || ctx.block_expr_parent);\n@@ -88,6 +87,8 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     add_keyword(ctx, acc, \"break\", \"break;\", ctx.in_loop_body && ctx.can_be_stmt);\n     add_keyword(ctx, acc, \"continue\", \"continue\", ctx.in_loop_body && !ctx.can_be_stmt);\n     add_keyword(ctx, acc, \"break\", \"break\", ctx.in_loop_body && !ctx.can_be_stmt);\n+    add_keyword(ctx, acc, \"pub\", \"pub \", ctx.is_new_item && !ctx.inside_trait);\n+    add_keyword(ctx, acc, \"where\", \"where \", ctx.trait_as_prev_sibling || ctx.impl_as_prev_sibling);\n     complete_use_tree_keyword(acc, ctx);\n \n     let fn_def = match &ctx.function_syntax {"}, {"sha": "e579e2ee2fe364801d7638055b552d61a04f5d70", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=f46bc12199dc88b88bd826f49d5c5af6e9caf727", "patch": "@@ -12,8 +12,8 @@ use ra_syntax::{\n use ra_text_edit::Indel;\n \n use super::patterns::{\n-    goes_after_unsafe, has_bind_pat_parent, has_block_expr_parent, has_ref_pat_parent,\n-    is_in_loop_body,\n+    goes_after_unsafe, has_bind_pat_parent, has_block_expr_parent, has_impl_as_prev_sibling,\n+    has_ref_pat_parent, has_trait_as_prev_sibling, inside_trait, is_in_loop_body,\n };\n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n use test_utils::mark;\n@@ -69,6 +69,9 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) bind_pat_parent: bool,\n     pub(super) ref_pat_parent: bool,\n     pub(super) in_loop_body: bool,\n+    pub(super) inside_trait: bool,\n+    pub(super) trait_as_prev_sibling: bool,\n+    pub(super) impl_as_prev_sibling: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -132,6 +135,9 @@ impl<'a> CompletionContext<'a> {\n             ref_pat_parent: false,\n             bind_pat_parent: false,\n             block_expr_parent: false,\n+            inside_trait: false,\n+            trait_as_prev_sibling: false,\n+            impl_as_prev_sibling: false,\n         };\n \n         let mut original_file = original_file.syntax().clone();\n@@ -210,6 +216,9 @@ impl<'a> CompletionContext<'a> {\n         self.bind_pat_parent = has_bind_pat_parent(syntax_element.clone());\n         self.ref_pat_parent = has_ref_pat_parent(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n+        self.inside_trait = inside_trait(syntax_element.clone());\n+        self.impl_as_prev_sibling = has_impl_as_prev_sibling(syntax_element.clone());\n+        self.trait_as_prev_sibling = has_trait_as_prev_sibling(syntax_element.clone());\n     }\n \n     fn fill("}, {"sha": "31d32ccd9be89e532cdc23b39020fa9dda367a59", "filename": "crates/ra_ide/src/completion/patterns.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f46bc12199dc88b88bd826f49d5c5af6e9caf727/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=f46bc12199dc88b88bd826f49d5c5af6e9caf727", "patch": "@@ -3,48 +3,47 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode,\n+    SyntaxNode, SyntaxToken,\n };\n \n pub(crate) fn inside_impl(element: SyntaxElement) -> bool {\n-    let node = match element {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-    node.ancestors().find(|it| it.kind() == IMPL_DEF).is_some()\n+    element.ancestors().find(|it| it.kind() == IMPL_DEF).is_some()\n+}\n+\n+pub(crate) fn inside_trait(element: SyntaxElement) -> bool {\n+    element.ancestors().find(|it| it.kind() == TRAIT_DEF).is_some()\n }\n \n pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n-    let node = match element {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-    node.ancestors().find(|it| it.kind() == BIND_PAT).is_some()\n+    element.ancestors().find(|it| it.kind() == BIND_PAT).is_some()\n }\n \n pub(crate) fn has_ref_pat_parent(element: SyntaxElement) -> bool {\n-    let node = match element {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-    node.ancestors().find(|it| it.kind() == REF_PAT).is_some()\n+    element.ancestors().find(|it| it.kind() == REF_PAT).is_some()\n }\n \n pub(crate) fn goes_after_unsafe(element: SyntaxElement) -> bool {\n-    if let Some(token) = previous_non_triva_element(element).and_then(|it| it.into_token()) {\n-        if token.kind() == UNSAFE_KW {\n-            return true;\n-        }\n-    }\n-    false\n+    element\n+        .into_token()\n+        .and_then(|it| previous_non_trivia_token(it))\n+        .filter(|it| it.kind() == UNSAFE_KW)\n+        .is_some()\n }\n \n pub(crate) fn has_block_expr_parent(element: SyntaxElement) -> bool {\n-    not_same_range_parent(element).filter(|it| it.kind() == BLOCK_EXPR).is_some()\n+    not_same_range_ancestor(element).filter(|it| it.kind() == BLOCK_EXPR).is_some()\n }\n \n pub(crate) fn has_item_list_parent(element: SyntaxElement) -> bool {\n-    not_same_range_parent(element).filter(|it| it.kind() == ITEM_LIST).is_some()\n+    not_same_range_ancestor(element).filter(|it| it.kind() == ITEM_LIST).is_some()\n+}\n+\n+pub(crate) fn has_trait_as_prev_sibling(element: SyntaxElement) -> bool {\n+    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == TRAIT_DEF).is_some()\n+}\n+\n+pub(crate) fn has_impl_as_prev_sibling(element: SyntaxElement) -> bool {\n+    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == IMPL_DEF).is_some()\n }\n \n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n@@ -73,20 +72,30 @@ pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n     false\n }\n \n-fn not_same_range_parent(element: SyntaxElement) -> Option<SyntaxNode> {\n-    let node = match element {\n-        NodeOrToken::Node(node) => node,\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-    let range = node.text_range();\n-    node.ancestors().take_while(|it| it.text_range() == range).last().and_then(|it| it.parent())\n+fn not_same_range_ancestor(element: SyntaxElement) -> Option<SyntaxNode> {\n+    element\n+        .ancestors()\n+        .take_while(|it| it.text_range() == element.text_range())\n+        .last()\n+        .and_then(|it| it.parent())\n }\n \n-fn previous_non_triva_element(element: SyntaxElement) -> Option<SyntaxElement> {\n-    // trying to get first non triva sibling if we have one\n+fn previous_non_trivia_token(token: SyntaxToken) -> Option<SyntaxToken> {\n+    let mut token = token.prev_token();\n+    while let Some(inner) = token.clone() {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            token = inner.prev_token();\n+        }\n+    }\n+    None\n+}\n+\n+fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<SyntaxElement> {\n     let token_sibling = non_trivia_sibling(element.clone(), Direction::Prev);\n-    let mut wrapped = if let Some(sibling) = token_sibling {\n-        sibling\n+    if let Some(sibling) = token_sibling {\n+        Some(sibling)\n     } else {\n         // if not trying to find first ancestor which has such a sibling\n         let node = match element {\n@@ -98,21 +107,6 @@ fn previous_non_triva_element(element: SyntaxElement) -> Option<SyntaxElement> {\n         let prev_sibling_node = top_node.ancestors().find(|it| {\n             non_trivia_sibling(NodeOrToken::Node(it.to_owned()), Direction::Prev).is_some()\n         })?;\n-        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)?\n-    };\n-    // TODO: Check if this can be simplified\n-    // Matklad: I think you can avoid this loop if you use SyntaxToken::prev_token -- unlike prev_sibling_or_token, it works across parents.\n-    // traversing the tree down to get the last token or node, i.e. the closest one\n-    loop {\n-        if let Some(token) = wrapped.as_token() {\n-            return Some(NodeOrToken::Token(token.clone()));\n-        } else {\n-            let new = wrapped.as_node().and_then(|n| n.last_child_or_token());\n-            if new.is_some() {\n-                wrapped = new.unwrap().clone();\n-            } else {\n-                return Some(wrapped);\n-            }\n-        }\n+        non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)\n     }\n }"}]}