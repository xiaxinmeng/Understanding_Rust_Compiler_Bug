{"sha": "96b228835ad3a9b366e572ffb4d3cebee60d0f56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YjIyODgzNWFkM2E5YjM2NmU1NzJmZmI0ZDNjZWJlZTYwZDBmNTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-09T04:36:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-05-09T15:17:46Z"}, "message": "trans: Always lower to `frem`\n\nLong ago LLVM unfortunately didn't handle the 32-bit MSVC case of `frem` where\nit can't be lowered to `fmodf` because that symbol doesn't exist. That was since\nfixed in http://reviews.llvm.org/D12099 (landed as r246615) and was released in\nwhat appears to be LLVM 3.8. Now that we're using that branch of LLVM let's\nremove our own hacks and help LLVM optimize a little better by giving it\nknowledge about what we're doing.", "tree": {"sha": "b3eaebe44fb7bd483fcaa3cf0b79bd217f3058f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3eaebe44fb7bd483fcaa3cf0b79bd217f3058f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96b228835ad3a9b366e572ffb4d3cebee60d0f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96b228835ad3a9b366e572ffb4d3cebee60d0f56", "html_url": "https://github.com/rust-lang/rust/commit/96b228835ad3a9b366e572ffb4d3cebee60d0f56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96b228835ad3a9b366e572ffb4d3cebee60d0f56/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae42a471c13eec8a6470d0845f46f1606d50742", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae42a471c13eec8a6470d0845f46f1606d50742", "html_url": "https://github.com/rust-lang/rust/commit/cae42a471c13eec8a6470d0845f46f1606d50742"}], "stats": {"total": 79, "additions": 2, "deletions": 77}, "files": [{"sha": "a583c9adae68ae43a2979212ab03295c89a58009", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/96b228835ad3a9b366e572ffb4d3cebee60d0f56/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b228835ad3a9b366e572ffb4d3cebee60d0f56/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=96b228835ad3a9b366e572ffb4d3cebee60d0f56", "patch": "@@ -63,7 +63,6 @@ use cleanup::{self, CleanupMethods, DropHintMethods};\n use common::*;\n use datum::*;\n use debuginfo::{self, DebugLoc, ToDebugLoc};\n-use declare;\n use glue;\n use machine;\n use tvec;\n@@ -1591,7 +1590,6 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n {\n     let _icx = push_ctxt(\"trans_scalar_binop\");\n \n-    let tcx = bcx.tcx();\n     let lhs_t = lhs.ty;\n     assert!(!lhs_t.is_simd());\n     let is_float = lhs_t.is_fp();\n@@ -1654,42 +1652,7 @@ fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       hir::BiRem => {\n         if is_float {\n-            // LLVM currently always lowers the `frem` instructions appropriate\n-            // library calls typically found in libm. Notably f64 gets wired up\n-            // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n-            // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n-            // instead just an inline function in a header that goes up to a\n-            // f64, uses `fmod`, and then comes back down to a f32.\n-            //\n-            // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n-            // still unconditionally lower frem instructions over 32-bit floats\n-            // to a call to `fmodf`. To work around this we special case MSVC\n-            // 32-bit float rem instructions and instead do the call out to\n-            // `fmod` ourselves.\n-            //\n-            // Note that this is currently duplicated with src/libcore/ops.rs\n-            // which does the same thing, and it would be nice to perhaps unify\n-            // these two implementations on day! Also note that we call `fmod`\n-            // for both 32 and 64-bit floats because if we emit any FRem\n-            // instruction at all then LLVM is capable of optimizing it into a\n-            // 32-bit FRem (which we're trying to avoid).\n-            let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n-                           tcx.sess.target.target.arch == \"x86\";\n-            if use_fmod {\n-                let f64t = Type::f64(bcx.ccx());\n-                let fty = Type::func(&[f64t, f64t], &f64t);\n-                let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty);\n-                if lhs_t == tcx.types.f32 {\n-                    let lhs = FPExt(bcx, lhs, f64t);\n-                    let rhs = FPExt(bcx, rhs, f64t);\n-                    let res = Call(bcx, llfn, &[lhs, rhs], binop_debug_loc);\n-                    FPTrunc(bcx, res, Type::f32(bcx.ccx()))\n-                } else {\n-                    Call(bcx, llfn, &[lhs, rhs], binop_debug_loc)\n-                }\n-            } else {\n-                FRem(bcx, lhs, rhs, binop_debug_loc)\n-            }\n+            FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx,"}, {"sha": "0d1c2c32ec5349a8e2cf3302f5cd060f9e852fe8", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/96b228835ad3a9b366e572ffb4d3cebee60d0f56/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96b228835ad3a9b366e572ffb4d3cebee60d0f56/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=96b228835ad3a9b366e572ffb4d3cebee60d0f56", "patch": "@@ -19,10 +19,8 @@ use callee::Callee;\n use common::{self, C_uint, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n-use declare;\n use adt;\n use machine;\n-use type_::Type;\n use type_of;\n use tvec;\n use value::Value;\n@@ -529,43 +527,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx.udiv(lhs, rhs)\n             },\n             mir::BinOp::Rem => if is_float {\n-                // LLVM currently always lowers the `frem` instructions appropriate\n-                // library calls typically found in libm. Notably f64 gets wired up\n-                // to `fmod` and f32 gets wired up to `fmodf`. Inconveniently for\n-                // us, 32-bit MSVC does not actually have a `fmodf` symbol, it's\n-                // instead just an inline function in a header that goes up to a\n-                // f64, uses `fmod`, and then comes back down to a f32.\n-                //\n-                // Although LLVM knows that `fmodf` doesn't exist on MSVC, it will\n-                // still unconditionally lower frem instructions over 32-bit floats\n-                // to a call to `fmodf`. To work around this we special case MSVC\n-                // 32-bit float rem instructions and instead do the call out to\n-                // `fmod` ourselves.\n-                //\n-                // Note that this is currently duplicated with src/libcore/ops.rs\n-                // which does the same thing, and it would be nice to perhaps unify\n-                // these two implementations one day! Also note that we call `fmod`\n-                // for both 32 and 64-bit floats because if we emit any FRem\n-                // instruction at all then LLVM is capable of optimizing it into a\n-                // 32-bit FRem (which we're trying to avoid).\n-                let tcx = bcx.tcx();\n-                let use_fmod = tcx.sess.target.target.options.is_like_msvc &&\n-                    tcx.sess.target.target.arch == \"x86\";\n-                if use_fmod {\n-                    let f64t = Type::f64(bcx.ccx());\n-                    let fty = Type::func(&[f64t, f64t], &f64t);\n-                    let llfn = declare::declare_cfn(bcx.ccx(), \"fmod\", fty);\n-                    if input_ty == tcx.types.f32 {\n-                        let lllhs = bcx.fpext(lhs, f64t);\n-                        let llrhs = bcx.fpext(rhs, f64t);\n-                        let llres = bcx.call(llfn, &[lllhs, llrhs], None);\n-                        bcx.fptrunc(llres, Type::f32(bcx.ccx()))\n-                    } else {\n-                        bcx.call(llfn, &[lhs, rhs], None)\n-                    }\n-                } else {\n-                    bcx.frem(lhs, rhs)\n-                }\n+                bcx.frem(lhs, rhs)\n             } else if is_signed {\n                 bcx.srem(lhs, rhs)\n             } else {"}]}