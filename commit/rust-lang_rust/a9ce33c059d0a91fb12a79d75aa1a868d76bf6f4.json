{"sha": "a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2UzM2MwNTlkMGE5MWZiMTJhNzlkNzVhYTFhODY4ZDc2YmY2ZjQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-01T09:22:42Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-09-01T09:22:42Z"}, "message": "Account for arbitrary self types in E0599", "tree": {"sha": "78444237d968dd400ef36e50af43d6e3c3a673d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78444237d968dd400ef36e50af43d6e3c3a673d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "html_url": "https://github.com/rust-lang/rust/commit/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba38ac27e2ade309f4c2504a6d6cd3556972a28", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba38ac27e2ade309f4c2504a6d6cd3556972a28", "html_url": "https://github.com/rust-lang/rust/commit/fba38ac27e2ade309f4c2504a6d6cd3556972a28"}], "stats": {"total": 170, "additions": 144, "deletions": 26}, "files": [{"sha": "f355e231914d2bef5da3f399dd4d0fcc9bb9f8d4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -2402,6 +2402,24 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_generic_adt(def_id, ty)\n     }\n \n+    #[inline]\n+    pub fn mk_pin(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(lang_items::PinTypeLangItem, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n+    #[inline]\n+    pub fn mk_rc(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(lang_items::Rc, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n+    #[inline]\n+    pub fn mk_arc(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let def_id = self.require_lang_item(lang_items::Arc, None);\n+        self.mk_generic_adt(def_id, ty)\n+    }\n+\n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);"}, {"sha": "efff8bcdacbcf2bc6a12ed8b58cfc89925fe5e00", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -12,7 +12,7 @@ use crate::check::fatally_break_rust;\n use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n-use crate::check::method::SelfSource;\n+use crate::check::method::{probe, SelfSource};\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::FxHashMap;\n use crate::astconv::AstConv as _;\n@@ -775,35 +775,65 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n-        let method = match self.lookup_method(rcvr_t,\n-                                              segment,\n-                                              span,\n-                                              expr,\n-                                              rcvr) {\n+        let try_alt_rcvr = |err: &mut DiagnosticBuilder<'_>, new_rcvr_t| {\n+            if let Ok(pick) = self.lookup_probe(\n+                span,\n+                segment.ident,\n+                new_rcvr_t,\n+                rcvr,\n+                probe::ProbeScope::AllTraits,\n+            ) {\n+                err.span_label(\n+                    pick.item.ident.span,\n+                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                );\n+            }\n+        };\n+\n+        let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n             Ok(method) => {\n                 self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n                 if segment.ident.name != kw::Invalid {\n-                    self.report_method_error(span,\n-                                             rcvr_t,\n-                                             segment.ident,\n-                                             SelfSource::MethodCall(rcvr),\n-                                             error,\n-                                             Some(args));\n+                    if let Some(mut err) = self.report_method_error(\n+                        span,\n+                        rcvr_t,\n+                        segment.ident,\n+                        SelfSource::MethodCall(rcvr),\n+                        error,\n+                        Some(args),\n+                    ) {\n+                        if let ty::Adt(..) = rcvr_t.sty {\n+                            // Try alternative arbitrary self types that could fulfill this call.\n+                            // FIXME: probe for all types that *could* be arbitrary self-types, not\n+                            // just this whitelist.\n+                            let box_rcvr_t = self.tcx.mk_box(rcvr_t);\n+                            try_alt_rcvr(&mut err, box_rcvr_t);\n+                            let pin_rcvr_t = self.tcx.mk_pin(rcvr_t);\n+                            try_alt_rcvr(&mut err, pin_rcvr_t);\n+                            let arc_rcvr_t = self.tcx.mk_arc(rcvr_t);\n+                            try_alt_rcvr(&mut err, arc_rcvr_t);\n+                            let rc_rcvr_t = self.tcx.mk_rc(rcvr_t);\n+                            try_alt_rcvr(&mut err, rc_rcvr_t);\n+                        }\n+                        err.emit();\n+                    }\n                 }\n                 Err(())\n             }\n         };\n \n         // Call the generic checker.\n-        self.check_method_argument_types(span,\n-                                         expr.span,\n-                                         method,\n-                                         &args[1..],\n-                                         DontTupleArguments,\n-                                         expected)\n+        self.check_method_argument_types(\n+            span,\n+            expr.span,\n+            method,\n+            &args[1..],\n+            DontTupleArguments,\n+            expected,\n+        )\n     }\n \n     fn check_expr_cast(\n@@ -1466,8 +1496,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let struct_variant_def = def.non_enum_variant();\n             let field_names = self.available_field_names(struct_variant_def);\n             if !field_names.is_empty() {\n-                err.note(&format!(\"available fields are: {}\",\n-                                    self.name_series_display(field_names)));\n+                err.note(&format!(\n+                    \"available fields are: {}\",\n+                    self.name_series_display(field_names),\n+                ));\n             }\n         }\n     }"}, {"sha": "1509c0f8a219601d66cc51f8d021f2c6f0c56a48", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(result.callee)\n     }\n \n-    fn lookup_probe(\n+    pub fn lookup_probe(\n         &self,\n         span: Span,\n         method_name: ast::Ident,"}, {"sha": "72e6f5971596092ab92b2fa39819ee86265089eb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -69,12 +69,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         source: SelfSource<'b>,\n         error: MethodError<'tcx>,\n         args: Option<&'tcx [hir::Expr]>,\n-    ) {\n+    ) -> Option<DiagnosticBuilder<'_>> {\n         let orig_span = span;\n         let mut span = span;\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n-            return;\n+            return None;\n         }\n \n         let print_disambiguation_help = |\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => {}\n                         }\n                         err.emit();\n-                        return;\n+                        return None;\n                     } else {\n                         span = item_name.span;\n                         let mut err = struct_span_err!(\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                err.emit();\n+                return Some(err);\n             }\n \n             MethodError::Ambiguity(sources) => {\n@@ -573,6 +573,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 bug!(\"no return type expectations but got BadReturnType\")\n             }\n         }\n+        None\n     }\n \n     fn suggest_use_candidates(&self,"}, {"sha": "2d9cacea68f31e74bdaf4795cfbb76837603c16f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -3580,7 +3580,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     SelfSource::QPath(qself),\n                     error,\n                     None,\n-                );\n+                ).map(|mut e| e.emit());\n             }\n             result\n         });"}, {"sha": "002b60f9f258dd41ee32f038363a4bb9efbe0db5", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -49,6 +49,14 @@ LL | use foo::Bar;\n error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::boxed::Box<&char>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:32:43\n    |\n+LL |         fn method(&self) {}\n+   |            ------\n+   |            |\n+   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&char>>>` here\n+...\n LL |     std::rc::Rc::new(&mut Box::new(&'a')).method();\n    |                                           ^^^^^^\n    |"}, {"sha": "0f7deeacad29278c31be5a36d1e6ceaefafb9d73", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -0,0 +1,9 @@\n+struct A;\n+\n+impl A {\n+    fn foo(self: Box<Self>) {}\n+}\n+\n+fn main() {\n+    A.foo(); //~ ERROR E0599\n+}"}, {"sha": "06dad7caa6735eb99a9bf19f1e578ae2f0008dcb", "filename": "src/test/ui/self/point-at-arbitrary-self-type-method.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-method.stderr?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `foo` found for type `A` in the current scope\n+  --> $DIR/point-at-arbitrary-self-type-method.rs:8:7\n+   |\n+LL | struct A;\n+   | --------- method `foo` not found for this\n+...\n+LL |     fn foo(self: Box<Self>) {}\n+   |        --- the method is available for `std::boxed::Box<A>` here\n+...\n+LL |     A.foo();\n+   |       ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "53d992771186f152d30e9e422902a4ec728b04d7", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.rs?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -0,0 +1,10 @@\n+trait B { fn foo(self: Box<Self>); }\n+struct A;\n+\n+impl B for A {\n+    fn foo(self: Box<Self>) {}\n+}\n+\n+fn main() {\n+    A.foo() //~ ERROR E0599\n+}"}, {"sha": "90cd3b807458014d8acc1d724c1d92775e439f09", "filename": "src/test/ui/self/point-at-arbitrary-self-type-trait-method.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fpoint-at-arbitrary-self-type-trait-method.stderr?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -0,0 +1,18 @@\n+error[E0599]: no method named `foo` found for type `A` in the current scope\n+  --> $DIR/point-at-arbitrary-self-type-trait-method.rs:9:7\n+   |\n+LL | trait B { fn foo(self: Box<Self>); }\n+   |              --- the method is available for `std::boxed::Box<A>` here\n+LL | struct A;\n+   | --------- method `foo` not found for this\n+...\n+LL |     A.foo()\n+   |       ^^^\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+   = note: the following trait defines an item `foo`, perhaps you need to implement it:\n+           candidate #1: `B`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "ce2919c8e77417c9eb0e000b62709679bc14c3b7", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=a9ce33c059d0a91fb12a79d75aa1a868d76bf6f4", "patch": "@@ -17,6 +17,13 @@ error[E0599]: no method named `b` found for type `S` in the current scope\n LL | struct S;\n    | --------- method `b` not found for this\n ...\n+LL |         fn b(&self) { }\n+   |            -\n+   |            |\n+   |            the method is available for `std::boxed::Box<S>` here\n+   |            the method is available for `std::sync::Arc<S>` here\n+   |            the method is available for `std::rc::Rc<S>` here\n+...\n LL |     S.b();\n    |       ^\n    |"}]}