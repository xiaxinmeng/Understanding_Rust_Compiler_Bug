{"sha": "a933de83989471ac444a13d62996d30621542654", "node_id": "C_kwDOAAsO6NoAKGE5MzNkZTgzOTg5NDcxYWM0NDRhMTNkNjI5OTZkMzA2MjE1NDI2NTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-01T18:05:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-01T18:05:57Z"}, "message": "Auto merge of #96582 - petrochenkov:finalize, r=cjgillot\n\nresolve: Cleanup path resolution finalization\n\nSome cleanup after https://github.com/rust-lang/rust/pull/95255 and https://github.com/rust-lang/rust/pull/95405.\nr? `@cjgillot`", "tree": {"sha": "58a8619bfd782b7c423fa8f55f073cf897e6f571", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a8619bfd782b7c423fa8f55f073cf897e6f571"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a933de83989471ac444a13d62996d30621542654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a933de83989471ac444a13d62996d30621542654", "html_url": "https://github.com/rust-lang/rust/commit/a933de83989471ac444a13d62996d30621542654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a933de83989471ac444a13d62996d30621542654/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eda7642bd284d3d2bc6a1d57b68e2ef2b65e062", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eda7642bd284d3d2bc6a1d57b68e2ef2b65e062", "html_url": "https://github.com/rust-lang/rust/commit/6eda7642bd284d3d2bc6a1d57b68e2ef2b65e062"}, {"sha": "7841247ca9d344ee253a07f356348445ec2965e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7841247ca9d344ee253a07f356348445ec2965e9", "html_url": "https://github.com/rust-lang/rust/commit/7841247ca9d344ee253a07f356348445ec2965e9"}], "stats": {"total": 320, "additions": 122, "deletions": 198}, "files": [{"sha": "7485dd51863b712998b1bc8faae0b7af3846a7ef", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -298,7 +298,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    if finalize { Finalize::SimplePath(id, path.span) } else { Finalize::No },\n+                    finalize.then(|| Finalize::new(id, path.span)),\n                     None,\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {"}, {"sha": "7d40ecb18b74742d6311f44d85f4423a91b6a4ca", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -417,15 +417,12 @@ impl<'a> Resolver<'a> {\n \n     crate fn lint_if_path_starts_with_module(\n         &mut self,\n-        finalize: Finalize,\n+        finalize: Option<Finalize>,\n         path: &[Segment],\n         second_binding: Option<&NameBinding<'_>>,\n     ) {\n-        let (diag_id, diag_span) = match finalize {\n-            Finalize::No => return,\n-            Finalize::SimplePath(id, path_span) => (id, path_span),\n-            Finalize::UsePath { root_id, root_span, .. } => (root_id, root_span),\n-            Finalize::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n+        let Some(Finalize { node_id, root_span, .. }) = finalize else {\n+            return;\n         };\n \n         let first_name = match path.get(0) {\n@@ -463,11 +460,11 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let diag = BuiltinLintDiagnostics::AbsPathWithModule(diag_span);\n+        let diag = BuiltinLintDiagnostics::AbsPathWithModule(root_span);\n         self.lint_buffer.buffer_lint_with_diagnostic(\n             ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            diag_id,\n-            diag_span,\n+            node_id,\n+            root_span,\n             \"absolute paths must start with `self`, `super`, \\\n              `crate`, or an external crate name in the 2018 edition\",\n             diag,\n@@ -1503,7 +1500,6 @@ impl<'a> Resolver<'a> {\n                 &parent_scope,\n                 None,\n                 false,\n-                false,\n                 None,\n             ) {\n                 let desc = match binding.res() {\n@@ -1811,7 +1807,7 @@ impl<'a> Resolver<'a> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n         module: Option<ModuleOrUniformRoot<'a>>,\n         i: usize,\n         ident: Ident,\n@@ -1863,8 +1859,7 @@ impl<'a> Resolver<'a> {\n                         ns_to_try,\n                         parent_scope,\n                         None,\n-                        false,\n-                        unusable_binding,\n+                        ignore_binding,\n                     ).ok()\n                 } else if let Some(ribs) = ribs\n                     && let Some(TypeNS | ValueNS) = opt_ns\n@@ -1873,9 +1868,9 @@ impl<'a> Resolver<'a> {\n                         ident,\n                         ns_to_try,\n                         parent_scope,\n-                        Finalize::No,\n+                        None,\n                         &ribs[ns_to_try],\n-                        unusable_binding,\n+                        ignore_binding,\n                     ) {\n                         // we found a locally-imported or available item/module\n                         Some(LexicalScopeBinding::Item(binding)) => Some(binding),\n@@ -1889,8 +1884,7 @@ impl<'a> Resolver<'a> {\n                         parent_scope,\n                         None,\n                         false,\n-                        false,\n-                        unusable_binding,\n+                        ignore_binding,\n                     ).ok()\n                 };\n                 if let Some(binding) = binding {\n@@ -1921,9 +1915,9 @@ impl<'a> Resolver<'a> {\n                     ident,\n                     ValueNS,\n                     parent_scope,\n-                    Finalize::No,\n+                    None,\n                     &ribs[ValueNS],\n-                    unusable_binding,\n+                    ignore_binding,\n                 )\n             } else {\n                 None"}, {"sha": "18ce359524da27fc555a304c1ccb00a599cf2e94", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 52, "deletions": 87, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -279,9 +279,9 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n+        finalize: Option<Finalize>,\n         ribs: &[Rib<'a>],\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let orig_ident = ident;\n@@ -302,7 +302,6 @@ impl<'a> Resolver<'a> {\n         let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n-        let finalize = finalize_full.path_span();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n@@ -316,7 +315,7 @@ impl<'a> Resolver<'a> {\n                     i,\n                     rib_ident,\n                     *res,\n-                    finalize,\n+                    finalize.map(|finalize| finalize.path_span),\n                     *original_rib_ident_def,\n                     ribs,\n                 )));\n@@ -344,8 +343,7 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 parent_scope,\n                 finalize,\n-                false,\n-                unusable_binding,\n+                ignore_binding,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -354,12 +352,11 @@ impl<'a> Resolver<'a> {\n         }\n         self.early_resolve_ident_in_lexical_scope(\n             orig_ident,\n-            ScopeSet::Late(ns, module, finalize_full.node_id()),\n+            ScopeSet::Late(ns, module, finalize.map(|finalize| finalize.node_id)),\n             parent_scope,\n             finalize,\n             finalize.is_some(),\n-            false,\n-            unusable_binding,\n+            ignore_binding,\n         )\n         .ok()\n         .map(LexicalScopeBinding::Item)\n@@ -376,10 +373,9 @@ impl<'a> Resolver<'a> {\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n+        finalize: Option<Finalize>,\n         force: bool,\n-        last_import_segment: bool,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         bitflags::bitflags! {\n             struct Flags: u8 {\n@@ -499,8 +495,7 @@ impl<'a> Resolver<'a> {\n                             ns,\n                             parent_scope,\n                             finalize,\n-                            last_import_segment,\n-                            unusable_binding,\n+                            ignore_binding,\n                         );\n                         match binding {\n                             Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n@@ -522,8 +517,7 @@ impl<'a> Resolver<'a> {\n                             adjusted_parent_scope,\n                             !matches!(scope_set, ScopeSet::Late(..)),\n                             finalize,\n-                            last_import_segment,\n-                            unusable_binding,\n+                            ignore_binding,\n                         );\n                         match binding {\n                             Ok(binding) => {\n@@ -608,8 +602,7 @@ impl<'a> Resolver<'a> {\n                                 ns,\n                                 parent_scope,\n                                 None,\n-                                last_import_segment,\n-                                unusable_binding,\n+                                ignore_binding,\n                             ) {\n                                 if use_prelude || this.is_builtin_macro(binding.res()) {\n                                     result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n@@ -731,7 +724,7 @@ impl<'a> Resolver<'a> {\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, false, None)\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, None, None)\n             .map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -742,23 +735,11 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        // We are resolving a last import segment during import validation.\n-        last_import_segment: bool,\n-        // This binding should be ignored during in-module resolution, so that we don't get\n-        // \"self-confirming\" import resolutions during import validation.\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(\n-            module,\n-            ident,\n-            ns,\n-            parent_scope,\n-            finalize,\n-            last_import_segment,\n-            unusable_binding,\n-        )\n-        .map_err(|(determinacy, _)| determinacy)\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, finalize, ignore_binding)\n+            .map_err(|(determinacy, _)| determinacy)\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -768,9 +749,8 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        last_import_segment: bool,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let tmp_parent_scope;\n         let mut adjusted_parent_scope = parent_scope;\n@@ -796,8 +776,7 @@ impl<'a> Resolver<'a> {\n             adjusted_parent_scope,\n             false,\n             finalize,\n-            last_import_segment,\n-            unusable_binding,\n+            ignore_binding,\n         )\n     }\n \n@@ -808,9 +787,8 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        finalize: Option<Span>,\n-        last_import_segment: bool,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n             module,\n@@ -819,8 +797,7 @@ impl<'a> Resolver<'a> {\n             parent_scope,\n             false,\n             finalize,\n-            last_import_segment,\n-            unusable_binding,\n+            ignore_binding,\n         )\n         .map_err(|(determinacy, _)| determinacy)\n     }\n@@ -835,9 +812,10 @@ impl<'a> Resolver<'a> {\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n-        finalize: Option<Span>,\n-        last_import_segment: bool,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        // This binding should be ignored during in-module resolution, so that we don't get\n+        // \"self-confirming\" import resolutions during import validation and checking.\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n@@ -849,8 +827,7 @@ impl<'a> Resolver<'a> {\n                     parent_scope,\n                     finalize,\n                     finalize.is_some(),\n-                    last_import_segment,\n-                    unusable_binding,\n+                    ignore_binding,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -890,8 +867,7 @@ impl<'a> Resolver<'a> {\n                     parent_scope,\n                     finalize,\n                     finalize.is_some(),\n-                    last_import_segment,\n-                    unusable_binding,\n+                    ignore_binding,\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -901,19 +877,15 @@ impl<'a> Resolver<'a> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(path_span) = finalize {\n+        if let Some(Finalize { path_span, report_private, .. }) = finalize {\n             // If the primary binding is unusable, search further and return the shadowed glob\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n             let binding = [resolution.binding, resolution.shadowed_glob]\n                 .into_iter()\n-                .filter_map(|binding| match (binding, unusable_binding) {\n-                    (Some(binding), Some(unusable_binding))\n-                        if ptr::eq(binding, unusable_binding) =>\n-                    {\n-                        None\n-                    }\n+                .filter_map(|binding| match (binding, ignore_binding) {\n+                    (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n                 })\n                 .next();\n@@ -922,14 +894,14 @@ impl<'a> Resolver<'a> {\n             };\n \n             if !self.is_accessible_from(binding.vis, parent_scope.module) {\n-                if last_import_segment {\n-                    return Err((Determined, Weak::No));\n-                } else {\n+                if report_private {\n                     self.privacy_errors.push(PrivacyError {\n                         ident,\n                         binding,\n                         dedup_span: path_span,\n                     });\n+                } else {\n+                    return Err((Determined, Weak::No));\n                 }\n             }\n \n@@ -960,10 +932,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            if let Some(unusable_binding) = unusable_binding {\n-                if ptr::eq(binding, unusable_binding) {\n-                    return Err((Determined, Weak::No));\n-                }\n+            if let Some(ignored) = ignore_binding && ptr::eq(binding, ignored) {\n+                return Err((Determined, Weak::No));\n             }\n             let usable = this.is_accessible_from(binding.vis, parent_scope.module);\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n@@ -996,8 +966,7 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 &single_import.parent_scope,\n                 None,\n-                last_import_segment,\n-                unusable_binding,\n+                ignore_binding,\n             ) {\n                 Err(Determined) => continue,\n                 Ok(binding)\n@@ -1073,8 +1042,7 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 adjusted_parent_scope,\n                 None,\n-                last_import_segment,\n-                unusable_binding,\n+                ignore_binding,\n             );\n \n             match result {\n@@ -1371,7 +1339,7 @@ impl<'a> Resolver<'a> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, Finalize::No, None, None)\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, None, None, None)\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1380,24 +1348,23 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        finalize: Finalize,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, unusable_binding)\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, ignore_binding)\n     }\n \n     crate fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        finalize_full: Finalize,\n+        finalize: Option<Finalize>,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize_full);\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize);\n \n-        let finalize = finalize_full.path_span();\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n@@ -1497,8 +1464,7 @@ impl<'a> Resolver<'a> {\n                         ns,\n                         parent_scope,\n                         finalize,\n-                        false,\n-                        unusable_binding,\n+                        ignore_binding,\n                     )\n                 } else if let Some(ribs) = ribs\n                     && let Some(TypeNS | ValueNS) = opt_ns\n@@ -1507,9 +1473,9 @@ impl<'a> Resolver<'a> {\n                         ident,\n                         ns,\n                         parent_scope,\n-                        finalize_full,\n+                        finalize,\n                         &ribs[ns],\n-                        unusable_binding,\n+                        ignore_binding,\n                     ) {\n                         // we found a locally-imported or available item/module\n                         Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -1525,8 +1491,7 @@ impl<'a> Resolver<'a> {\n                         parent_scope,\n                         finalize,\n                         finalize.is_some(),\n-                        false,\n-                        unusable_binding,\n+                        ignore_binding,\n                     )\n                 };\n                 FindBindingResult::Binding(binding)\n@@ -1566,7 +1531,7 @@ impl<'a> Resolver<'a> {\n                     } else if res == Res::Err {\n                         return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+                        self.lint_if_path_starts_with_module(finalize, path, second_binding);\n                         return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res,\n                             path.len() - i - 1,\n@@ -1599,7 +1564,7 @@ impl<'a> Resolver<'a> {\n                             opt_ns,\n                             parent_scope,\n                             ribs,\n-                            unusable_binding,\n+                            ignore_binding,\n                             module,\n                             i,\n                             ident,\n@@ -1609,7 +1574,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.lint_if_path_starts_with_module(finalize_full, path, second_binding);\n+        self.lint_if_path_starts_with_module(finalize, path, second_binding);\n \n         PathResult::Module(match module {\n             Some(module) => module,"}, {"sha": "ef06ec356bd688af46940980d700c6860e52a180", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -545,7 +545,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ns,\n                         &import.parent_scope,\n                         None,\n-                        false,\n                         None,\n                     );\n                     import.vis.set(orig_vis);\n@@ -589,22 +588,18 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-        let unusable_binding = match &import.kind {\n+        let ignore_binding = match &import.kind {\n             ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n-        let finalize = Finalize::UsePath {\n-            root_id: import.root_id,\n-            root_span: import.root_span,\n-            path_span: import.span,\n-        };\n+        let finalize = Finalize::with_root_span(import.root_id, import.span, import.root_span);\n         let path_res = self.r.resolve_path(\n             &import.module_path,\n             None,\n             &import.parent_scope,\n-            finalize,\n-            unusable_binding,\n+            Some(finalize),\n+            ignore_binding,\n         );\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         import.vis.set(orig_vis);\n@@ -685,7 +680,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(finalize, &full_path, None);\n+                    self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n@@ -720,8 +715,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     ident,\n                     ns,\n                     &import.parent_scope,\n-                    Some(import.span),\n-                    true,\n+                    Some(Finalize { report_private: false, ..finalize }),\n                     target_bindings[ns].get(),\n                 );\n                 import.vis.set(orig_vis);\n@@ -781,8 +775,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ident,\n                         ns,\n                         &import.parent_scope,\n-                        Some(import.span),\n-                        false,\n+                        Some(finalize),\n                         None,\n                     );\n                     if binding.is_ok() {\n@@ -948,7 +941,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n-                    this.lint_if_path_starts_with_module(finalize, &full_path, Some(binding));\n+                    this.lint_if_path_starts_with_module(Some(finalize), &full_path, Some(binding));\n                 }\n             });\n         }\n@@ -1003,7 +996,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     &import.parent_scope,\n                     None,\n                     false,\n-                    false,\n                     target_bindings[ns].get(),\n                 ) {\n                     Ok(other_binding) => {"}, {"sha": "ca89f61032221d8071f5f389c49e4fd8374043f2", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -578,7 +578,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     .resolve_ident_in_lexical_scope(\n                         self_ty,\n                         TypeNS,\n-                        Finalize::SimplePath(ty.id, ty.span),\n+                        Some(Finalize::new(ty.id, ty.span)),\n                         None,\n                     )\n                     .map_or(Res::Err, |d| d.res());\n@@ -958,7 +958,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ident,\n             ns,\n             &self.parent_scope,\n-            Finalize::No,\n+            None,\n             &self.ribs[ns],\n             None,\n         )\n@@ -968,24 +968,24 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n-        finalize: Finalize,\n-        unusable_binding: Option<&'a NameBinding<'a>>,\n+        finalize: Option<Finalize>,\n+        ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n             finalize,\n             &self.ribs[ns],\n-            unusable_binding,\n+            ignore_binding,\n         )\n     }\n \n     fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        finalize: Finalize,\n+        finalize: Option<Finalize>,\n     ) -> PathResult<'a> {\n         self.r.resolve_path_with_ribs(\n             path,\n@@ -1299,11 +1299,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         partial_res: PartialRes,\n         path: &[Segment],\n         source: PathSource<'_>,\n-        finalize: Finalize,\n+        path_span: Span,\n     ) {\n-        let Some(path_span) = finalize.path_span() else {\n-            return;\n-        };\n         let proj_start = path.len() - partial_res.unresolved_segments();\n         for (i, segment) in path.iter().enumerate() {\n             if segment.has_lifetime_args {\n@@ -1576,8 +1573,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n-                        if let Some(LexicalScopeBinding::Res(..)) = self\n-                            .resolve_ident_in_lexical_scope(ident, ns, Finalize::No, Some(binding))\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n+                            self.resolve_ident_in_lexical_scope(ident, ns, None, Some(binding))\n                         {\n                             report_error(self, ns);\n                         }\n@@ -1979,7 +1976,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 None,\n                 &path,\n                 PathSource::Trait(AliasPossibility::No),\n-                Finalize::SimplePath(trait_ref.ref_id, trait_ref.path.span),\n+                Finalize::new(trait_ref.ref_id, trait_ref.path.span),\n             );\n             if let Some(def_id) = res.base_res().opt_def_id() {\n                 new_id = Some(def_id);\n@@ -2653,7 +2650,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             qself,\n             &Segment::from_path(path),\n             source,\n-            Finalize::SimplePath(id, path.span),\n+            Finalize::new(id, path.span),\n         );\n     }\n \n@@ -2672,8 +2669,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         );\n         let ns = source.namespace();\n \n-        let (id, path_span) =\n-            finalize.node_id_and_path_span().expect(\"unexpected speculative resolution\");\n+        let Finalize { node_id, path_span, .. } = finalize;\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n                 let (err, candidates) =\n@@ -2787,7 +2783,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n                     let traits = self.traits_in_scope(item_name, ns);\n-                    self.r.trait_map.insert(id, traits);\n+                    self.r.trait_map.insert(node_id, traits);\n                 }\n \n                 if PrimTy::from_name(path[0].ident.name).is_some() {\n@@ -2796,7 +2792,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n                     std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, Some(ns), Finalize::No)\n+                        self.resolve_path(&std_path, Some(ns), None)\n                     {\n                         // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n@@ -2823,8 +2819,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         if !matches!(source, PathSource::TraitItem(..)) {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.r.record_partial_res(id, partial_res);\n-            self.resolve_elided_lifetimes_in_path(id, partial_res, path, source, finalize);\n+            self.r.record_partial_res(node_id, partial_res);\n+            self.resolve_elided_lifetimes_in_path(node_id, partial_res, path, source, path_span);\n         }\n \n         partial_res\n@@ -2932,21 +2928,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // the trait (the slice upto and including\n             // `qself.position`). And then we recursively resolve that,\n             // but with `qself` set to `None`.\n-            //\n-            // However, setting `qself` to none (but not changing the\n-            // span) loses the information about where this path\n-            // *actually* appears, so for the purposes of the crate\n-            // lint we pass along information that this is the trait\n-            // name from a fully qualified path, and this also\n-            // contains the full span (the `Finalize::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let partial_res = self.smart_resolve_path_fragment(\n                 None,\n                 &path[..=qself.position],\n                 PathSource::TraitItem(ns),\n-                finalize.node_id_and_path_span().map_or(Finalize::No, |(qpath_id, path_span)| {\n-                    Finalize::QPathTrait { qpath_id, qpath_span: qself.path_span, path_span }\n-                }),\n+                Finalize::with_root_span(finalize.node_id, finalize.path_span, qself.path_span),\n             );\n \n             // The remaining segments (the `C` in our example) will\n@@ -2958,7 +2945,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), finalize) {\n+        let result = match self.resolve_path(&path, Some(ns), Some(finalize)) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PartialRes::new(module.res().unwrap())\n@@ -2996,10 +2983,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             && result.base_res() != Res::Err\n             && path[0].ident.name != kw::PathRoot\n             && path[0].ident.name != kw::DollarCrate\n-            && let Some((id, path_span)) = finalize.node_id_and_path_span()\n         {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), Finalize::No) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), None) {\n                     PathResult::NonModule(path_res) => path_res.base_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n@@ -3009,7 +2995,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n             if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.r.lint_buffer.buffer_lint(lint, id, path_span, \"unnecessary qualification\")\n+                self.r.lint_buffer.buffer_lint(\n+                    lint,\n+                    finalize.node_id,\n+                    finalize.path_span,\n+                    \"unnecessary qualification\",\n+                )\n             }\n         }\n "}, {"sha": "3076cc1131700d8df6f0f4707f37023d54fffe95", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -3,7 +3,7 @@ use crate::late::lifetimes::{ElisionFailureInfo, LifetimeContext};\n use crate::late::{AliasPossibility, LateResolutionVisitor, RibKind};\n use crate::late::{LifetimeBinderKind, LifetimeRibKind};\n use crate::path_names_to_string;\n-use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n use rustc_ast::visit::FnKind;\n@@ -189,7 +189,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), Finalize::No) {\n+                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), None) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n                     _ => None,\n                 }\n@@ -648,7 +648,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let crate::PathSource::TraitItem(_) = source {\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, None, Finalize::No)\n+                self.resolve_path(mod_path, None, None)\n             {\n                 let resolutions = self.r.resolutions(module).borrow();\n                 let targets: Vec<_> =\n@@ -1362,7 +1362,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, Some(TypeNS), Finalize::No)\n+                self.resolve_path(mod_path, Some(TypeNS), None)\n             {\n                 self.r.add_module_candidates(module, &mut names, &filter_fn);\n             }"}, {"sha": "2e625fc1b4f7b4ff732f31c82c8edb7dc45ade8d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -2044,42 +2044,27 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum Finalize {\n-    /// Do not issue the lint.\n-    No,\n-\n-    /// This lint applies to some arbitrary path; e.g., `impl ::foo::Bar`.\n-    /// In this case, we can take the span of that path.\n-    SimplePath(NodeId, Span),\n-\n-    /// This lint comes from a `use` statement. In this case, what we\n-    /// care about really is the *root* `use` statement; e.g., if we\n-    /// have nested things like `use a::{b, c}`, we care about the\n-    /// `use a` part.\n-    UsePath { root_id: NodeId, root_span: Span, path_span: Span },\n-\n-    /// This is the \"trait item\" from a fully qualified path. For example,\n-    /// we might be resolving  `X::Y::Z` from a path like `<T as X::Y>::Z`.\n-    /// The `path_span` is the span of the to the trait itself (`X::Y`).\n-    QPathTrait { qpath_id: NodeId, qpath_span: Span, path_span: Span },\n+struct Finalize {\n+    /// Node ID for linting.\n+    node_id: NodeId,\n+    /// Span of the whole path or some its characteristic fragment.\n+    /// E.g. span of `b` in `foo::{a, b, c}`, or full span for regular paths.\n+    path_span: Span,\n+    /// Span of the path start, suitable for prepending something to to it.\n+    /// E.g. span of `foo` in `foo::{a, b, c}`, or full span for regular paths.\n+    root_span: Span,\n+    /// Whether to report privacy errors or silently return \"no resolution\" for them,\n+    /// similarly to speculative resolution.\n+    report_private: bool,\n }\n \n impl Finalize {\n-    fn node_id_and_path_span(&self) -> Option<(NodeId, Span)> {\n-        match *self {\n-            Finalize::No => None,\n-            Finalize::SimplePath(id, path_span)\n-            | Finalize::UsePath { root_id: id, path_span, .. }\n-            | Finalize::QPathTrait { qpath_id: id, path_span, .. } => Some((id, path_span)),\n-        }\n-    }\n-\n-    fn node_id(&self) -> Option<NodeId> {\n-        self.node_id_and_path_span().map(|(id, _)| id)\n+    fn new(node_id: NodeId, path_span: Span) -> Finalize {\n+        Finalize::with_root_span(node_id, path_span, path_span)\n     }\n \n-    fn path_span(&self) -> Option<Span> {\n-        self.node_id_and_path_span().map(|(_, path_span)| path_span)\n+    fn with_root_span(node_id: NodeId, path_span: Span, root_span: Span) -> Finalize {\n+        Finalize { node_id, path_span, root_span, report_private: true }\n     }\n }\n "}, {"sha": "19a9c1b99fc47f897d2701fc90d0be3312b4b442", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a933de83989471ac444a13d62996d30621542654/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=a933de83989471ac444a13d62996d30621542654", "patch": "@@ -604,7 +604,6 @@ impl<'a> Resolver<'a> {\n                 parent_scope,\n                 None,\n                 force,\n-                false,\n                 None,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n@@ -673,7 +672,7 @@ impl<'a> Resolver<'a> {\n                 &path,\n                 Some(MacroNS),\n                 &parent_scope,\n-                Finalize::SimplePath(ast::CRATE_NODE_ID, path_span),\n+                Some(Finalize::new(ast::CRATE_NODE_ID, path_span)),\n                 None,\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n@@ -708,9 +707,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(kind),\n                 &parent_scope,\n-                Some(ident.span),\n+                Some(Finalize::new(ast::CRATE_NODE_ID, ident.span)),\n                 true,\n-                false,\n                 None,\n             ) {\n                 Ok(binding) => {\n@@ -751,9 +749,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(MacroKind::Attr),\n                 &parent_scope,\n-                Some(ident.span),\n+                Some(Finalize::new(ast::CRATE_NODE_ID, ident.span)),\n                 true,\n-                false,\n                 None,\n             );\n         }"}]}