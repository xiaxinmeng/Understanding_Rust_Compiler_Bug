{"sha": "e4d6307c633c954971f3ca7876d4f29f3fe83614", "node_id": "C_kwDOAAsO6NoAKGU0ZDYzMDdjNjMzYzk1NDk3MWYzY2E3ODc2ZDRmMjlmM2ZlODM2MTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T15:02:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T15:02:10Z"}, "message": "Auto merge of #104292 - GuillaumeGomez:fix-missing-reexports-doc-comments, r=notriddle\n\nFix missing reexports' doc comments\n\nFixes #81893.\n\nThe issue was that an import directly \"links\" to the target without the intermediate imports. Unfortunately, to fix this bug we need to go through them one by one. To do so, I take the import path direct parent (so `b` in `a::b::c`) and then look for `c` into it.\n\nr? `@notriddle`", "tree": {"sha": "5001030a5fec579adf7f90e43c20bee5421337ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5001030a5fec579adf7f90e43c20bee5421337ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4d6307c633c954971f3ca7876d4f29f3fe83614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d6307c633c954971f3ca7876d4f29f3fe83614", "html_url": "https://github.com/rust-lang/rust/commit/e4d6307c633c954971f3ca7876d4f29f3fe83614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4d6307c633c954971f3ca7876d4f29f3fe83614/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd7977c850d9ce06f1dd2bebb40db8cc2224a51", "html_url": "https://github.com/rust-lang/rust/commit/afd7977c850d9ce06f1dd2bebb40db8cc2224a51"}, {"sha": "0839d39570d651e74b78a6cbe61eba02e07b6c2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0839d39570d651e74b78a6cbe61eba02e07b6c2a", "html_url": "https://github.com/rust-lang/rust/commit/0839d39570d651e74b78a6cbe61eba02e07b6c2a"}], "stats": {"total": 128, "additions": 121, "deletions": 7}, "files": [{"sha": "c2f78fd5950f7148417f6aaba58cdd30210413b5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 87, "deletions": 7, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e4d6307c633c954971f3ca7876d4f29f3fe83614/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d6307c633c954971f3ca7876d4f29f3fe83614/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e4d6307c633c954971f3ca7876d4f29f3fe83614", "patch": "@@ -1942,6 +1942,79 @@ fn clean_bare_fn_ty<'tcx>(\n     BareFunctionDecl { unsafety: bare_fn.unsafety, abi: bare_fn.abi, decl, generic_params }\n }\n \n+/// This visitor is used to go through only the \"top level\" of a item and not enter any sub\n+/// item while looking for a given `Ident` which is stored into `item` if found.\n+struct OneLevelVisitor<'hir> {\n+    map: rustc_middle::hir::map::Map<'hir>,\n+    item: Option<&'hir hir::Item<'hir>>,\n+    looking_for: Ident,\n+    target_hir_id: hir::HirId,\n+}\n+\n+impl<'hir> OneLevelVisitor<'hir> {\n+    fn new(map: rustc_middle::hir::map::Map<'hir>, target_hir_id: hir::HirId) -> Self {\n+        Self { map, item: None, looking_for: Ident::empty(), target_hir_id }\n+    }\n+\n+    fn reset(&mut self, looking_for: Ident) {\n+        self.looking_for = looking_for;\n+        self.item = None;\n+    }\n+}\n+\n+impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n+    type NestedFilter = rustc_middle::hir::nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.map\n+    }\n+\n+    fn visit_item(&mut self, item: &'hir hir::Item<'hir>) {\n+        if self.item.is_none()\n+            && item.ident == self.looking_for\n+            && matches!(item.kind, hir::ItemKind::Use(_, _))\n+            || item.hir_id() == self.target_hir_id\n+        {\n+            self.item = Some(item);\n+        }\n+    }\n+}\n+\n+/// Because a `Use` item directly links to the imported item, we need to manually go through each\n+/// import one by one. To do so, we go to the parent item and look for the `Ident` into it. Then,\n+/// if we found the \"end item\" (the imported one), we stop there because we don't need its\n+/// documentation. Otherwise, we repeat the same operation until we find the \"end item\".\n+fn get_all_import_attributes<'hir>(\n+    mut item: &hir::Item<'hir>,\n+    tcx: TyCtxt<'hir>,\n+    target_hir_id: hir::HirId,\n+    attributes: &mut Vec<ast::Attribute>,\n+) {\n+    let hir_map = tcx.hir();\n+    let mut visitor = OneLevelVisitor::new(hir_map, target_hir_id);\n+    // If the item is an import and has at least a path with two parts, we go into it.\n+    while let hir::ItemKind::Use(path, _) = item.kind &&\n+        path.segments.len() > 1 &&\n+        let hir::def::Res::Def(_, def_id) = path.segments[path.segments.len() - 2].res\n+    {\n+        if let Some(hir::Node::Item(parent_item)) = hir_map.get_if_local(def_id) {\n+            // We add the attributes from this import into the list.\n+            attributes.extend_from_slice(hir_map.attrs(item.hir_id()));\n+            // We get the `Ident` we will be looking for into `item`.\n+            let looking_for = path.segments[path.segments.len() - 1].ident;\n+            visitor.reset(looking_for);\n+            hir::intravisit::walk_item(&mut visitor, parent_item);\n+            if let Some(i) = visitor.item {\n+                item = i;\n+            } else {\n+                break;\n+            }\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n@@ -2023,13 +2096,20 @@ fn clean_maybe_renamed_item<'tcx>(\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n-        if let Some(import_id) = import_id {\n-            let (attrs, cfg) = inline::merge_attrs(\n-                cx,\n-                Some(cx.tcx.parent_module(import_id).to_def_id()),\n-                inline::load_attrs(cx, def_id),\n-                Some(inline::load_attrs(cx, cx.tcx.hir().local_def_id(import_id).to_def_id())),\n-            );\n+\n+        let mut extra_attrs = Vec::new();\n+        if let Some(hir::Node::Item(use_node)) =\n+            import_id.and_then(|hir_id| cx.tcx.hir().find(hir_id))\n+        {\n+            // We get all the various imports' attributes.\n+            get_all_import_attributes(use_node, cx.tcx, item.hir_id(), &mut extra_attrs);\n+        }\n+\n+        if !extra_attrs.is_empty() {\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n+            let attrs = Attributes::from_ast(&extra_attrs);\n+            let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+\n             vec![Item::from_def_id_and_attrs_and_parts(\n                 def_id,\n                 Some(name),"}, {"sha": "1daae49cde9d056cfbc76d18c520057c2a119450", "filename": "src/test/rustdoc/multiple-import-levels.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4d6307c633c954971f3ca7876d4f29f3fe83614/src%2Ftest%2Frustdoc%2Fmultiple-import-levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d6307c633c954971f3ca7876d4f29f3fe83614/src%2Ftest%2Frustdoc%2Fmultiple-import-levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmultiple-import-levels.rs?ref=e4d6307c633c954971f3ca7876d4f29f3fe83614", "patch": "@@ -0,0 +1,34 @@\n+// The goal of this test is to ensure that the attributes of all imports are taken into\n+// account.\n+\n+#![crate_name = \"foo\"]\n+\n+mod a {\n+    /// 1\n+    pub struct Type;\n+}\n+\n+mod b {\n+    /// 2\n+    pub use crate::a::Type;\n+}\n+\n+mod c {\n+    /// 3\n+    pub use crate::b::Type;\n+    /// 4\n+    pub use crate::b::Type as Woof;\n+}\n+\n+// @has 'foo/struct.Type.html'\n+// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'foo 2 1'\n+/// foo\n+pub use b::Type;\n+// @has 'foo/struct.Whatever.html'\n+// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'whatever 3 2 1'\n+/// whatever\n+pub use c::Type as Whatever;\n+// @has 'foo/struct.Woof.html'\n+// @has - '//*[@class=\"rustdoc-toggle top-doc\"]/*[@class=\"docblock\"]' 'a dog 4 2 1'\n+/// a dog\n+pub use c::Woof;"}]}