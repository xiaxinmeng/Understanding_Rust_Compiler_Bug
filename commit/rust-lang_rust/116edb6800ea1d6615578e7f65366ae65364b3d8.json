{"sha": "116edb6800ea1d6615578e7f65366ae65364b3d8", "node_id": "C_kwDOAAsO6NoAKDExNmVkYjY4MDBlYTFkNjYxNTU3OGU3ZjY1MzY2YWU2NTM2NGIzZDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T03:22:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-29T03:22:47Z"}, "message": "Auto merge of #98542 - jackh726:coinductive-wf, r=oli-obk\n\nMake empty bounds lower to `WellFormed` and make `WellFormed` coinductive\n\nr? rust-lang/types", "tree": {"sha": "771faa6deda034169f91a304e2392489fefa2bc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/771faa6deda034169f91a304e2392489fefa2bc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/116edb6800ea1d6615578e7f65366ae65364b3d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/116edb6800ea1d6615578e7f65366ae65364b3d8", "html_url": "https://github.com/rust-lang/rust/commit/116edb6800ea1d6615578e7f65366ae65364b3d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/116edb6800ea1d6615578e7f65366ae65364b3d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126e3df4065623802eda752e79839d1b6fde59be", "url": "https://api.github.com/repos/rust-lang/rust/commits/126e3df4065623802eda752e79839d1b6fde59be", "html_url": "https://github.com/rust-lang/rust/commit/126e3df4065623802eda752e79839d1b6fde59be"}, {"sha": "bd298adcd472256cef028b37e34ee1965eaf81a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd298adcd472256cef028b37e34ee1965eaf81a3", "html_url": "https://github.com/rust-lang/rust/commit/bd298adcd472256cef028b37e34ee1965eaf81a3"}], "stats": {"total": 156, "additions": 130, "deletions": 26}, "files": [{"sha": "f5e323e2bc40ef864ec6e0c14077a455214ebfbf", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -154,6 +154,7 @@ where\n                 }\n                 ControlFlow::CONTINUE\n             }\n+            ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }"}, {"sha": "4223cdb5dbb184b84058380cec189f25074bf311", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 100, "deletions": 15, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -488,20 +488,93 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n-                    self.infcx,\n-                    obligation.param_env,\n-                    obligation.cause.body_id,\n-                    obligation.recursion_depth + 1,\n-                    arg,\n-                    obligation.cause.span,\n-                ) {\n-                    Some(mut obligations) => {\n-                        self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                        self.evaluate_predicates_recursively(previous_stack, obligations)\n+                ty::PredicateKind::WellFormed(arg) => {\n+                    // So, there is a bit going on here. First, `WellFormed` predicates\n+                    // are coinductive, like trait predicates with auto traits.\n+                    // This means that we need to detect if we have recursively\n+                    // evaluated `WellFormed(X)`. Otherwise, we would run into\n+                    // a \"natural\" overflow error.\n+                    //\n+                    // Now, the next question is whether we need to do anything\n+                    // special with caching. Considering the following tree:\n+                    // - `WF(Foo<T>)`\n+                    //   - `Bar<T>: Send`\n+                    //     - `WF(Foo<T>)`\n+                    //   - `Foo<T>: Trait`\n+                    // In this case, the innermost `WF(Foo<T>)` should return\n+                    // `EvaluatedToOk`, since it's coinductive. Then if\n+                    // `Bar<T>: Send` is resolved to `EvaluatedToOk`, it can be\n+                    // inserted into a cache (because without thinking about `WF`\n+                    // goals, it isn't in a cycle). If `Foo<T>: Trait` later doesn't\n+                    // hold, then `Bar<T>: Send` shouldn't hold. Therefore, we\n+                    // *do* need to keep track of coinductive cycles.\n+\n+                    let cache = previous_stack.cache;\n+                    let dfn = cache.next_dfn();\n+\n+                    for stack_arg in previous_stack.cache.wf_args.borrow().iter().rev() {\n+                        if stack_arg.0 != arg {\n+                            continue;\n+                        }\n+                        debug!(\"WellFormed({:?}) on stack\", arg);\n+                        if let Some(stack) = previous_stack.head {\n+                            // Okay, let's imagine we have two different stacks:\n+                            //   `T: NonAutoTrait -> WF(T) -> T: NonAutoTrait`\n+                            //   `WF(T) -> T: NonAutoTrait -> WF(T)`\n+                            // Because of this, we need to check that all\n+                            // predicates between the WF goals are coinductive.\n+                            // Otherwise, we can say that `T: NonAutoTrait` is\n+                            // true.\n+                            // Let's imagine we have a predicate stack like\n+                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto\n+                            // depth   ^1                    ^2                 ^3\n+                            // and the current predicate is `WF(T)`. `wf_args`\n+                            // would contain `(T, 1)`. We want to check all\n+                            // trait predicates greater than `1`. The previous\n+                            // stack would be `T: Auto`.\n+                            let cycle = stack.iter().take_while(|s| s.depth > stack_arg.1);\n+                            let tcx = self.tcx();\n+                            let cycle =\n+                                cycle.map(|stack| stack.obligation.predicate.to_predicate(tcx));\n+                            if self.coinductive_match(cycle) {\n+                                stack.update_reached_depth(stack_arg.1);\n+                                return Ok(EvaluatedToOk);\n+                            } else {\n+                                return Ok(EvaluatedToRecur);\n+                            }\n+                        }\n+                        return Ok(EvaluatedToOk);\n                     }\n-                    None => Ok(EvaluatedToAmbig),\n-                },\n+\n+                    match wf::obligations(\n+                        self.infcx,\n+                        obligation.param_env,\n+                        obligation.cause.body_id,\n+                        obligation.recursion_depth + 1,\n+                        arg,\n+                        obligation.cause.span,\n+                    ) {\n+                        Some(mut obligations) => {\n+                            self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+\n+                            cache.wf_args.borrow_mut().push((arg, previous_stack.depth()));\n+                            let result =\n+                                self.evaluate_predicates_recursively(previous_stack, obligations);\n+                            cache.wf_args.borrow_mut().pop();\n+\n+                            let result = result?;\n+\n+                            if !result.must_apply_modulo_regions() {\n+                                cache.on_failure(dfn);\n+                            }\n+\n+                            cache.on_completion(dfn);\n+\n+                            Ok(result)\n+                        }\n+                        None => Ok(EvaluatedToAmbig),\n+                    }\n+                }\n \n                 ty::PredicateKind::TypeOutlives(pred) => {\n                     // A global type with no late-bound regions can only\n@@ -718,6 +791,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?fresh_trait_pred);\n \n+        // If a trait predicate is in the (local or global) evaluation cache,\n+        // then we know it holds without cycles.\n         if let Some(result) = self.check_evaluation_cache(param_env, fresh_trait_pred) {\n             debug!(?result, \"CACHE HIT\");\n             return Ok(result);\n@@ -921,7 +996,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// - it also appears in the backtrace at some position `X`,\n     /// - all the predicates at positions `X..` between `X` and the top are\n     ///   also defaulted traits.\n-    pub fn coinductive_match<I>(&mut self, mut cycle: I) -> bool\n+    pub(crate) fn coinductive_match<I>(&mut self, mut cycle: I) -> bool\n     where\n         I: Iterator<Item = ty::Predicate<'tcx>>,\n     {\n@@ -931,6 +1006,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n             ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::WellFormed(_) => true,\n             _ => false,\n         };\n         debug!(?predicate, ?result, \"coinductive_predicate\");\n@@ -2410,6 +2486,15 @@ struct ProvisionalEvaluationCache<'tcx> {\n     ///   all cache values whose DFN is >= 4 -- in this case, that\n     ///   means the cached value for `F`.\n     map: RefCell<FxHashMap<ty::PolyTraitPredicate<'tcx>, ProvisionalEvaluation>>,\n+\n+    /// The stack of args that we assume to be true because a `WF(arg)` predicate\n+    /// is on the stack above (and because of wellformedness is coinductive).\n+    /// In an \"ideal\" world, this would share a stack with trait predicates in\n+    /// `TraitObligationStack`. However, trait predicates are *much* hotter than\n+    /// `WellFormed` predicates, and it's very likely that the additional matches\n+    /// will have a perf effect. The value here is the well-formed `GenericArg`\n+    /// and the depth of the trait predicate *above* that well-formed predicate.\n+    wf_args: RefCell<Vec<(ty::GenericArg<'tcx>, usize)>>,\n }\n \n /// A cache value for the provisional cache: contains the depth-first\n@@ -2423,7 +2508,7 @@ struct ProvisionalEvaluation {\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n     fn default() -> Self {\n-        Self { dfn: Cell::new(0), map: Default::default() }\n+        Self { dfn: Cell::new(0), map: Default::default(), wf_args: Default::default() }\n     }\n }\n "}, {"sha": "2453d3a692aa16f69eb0617e5798604133e32a96", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -106,8 +106,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 ty::PredicateKind::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ),\n-                ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n+                ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+                    ty::GenericArgKind::Type(ty) => chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    ),\n+                    // FIXME(chalk): we need to change `WellFormed` in Chalk to take a `GenericArg`\n+                    _ => chalk_ir::DomainGoal::WellFormed(chalk_ir::WellFormed::Ty(\n+                        interner.tcx.types.unit.lower_into(interner),\n+                    )),\n+                },\n+                ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)"}, {"sha": "ae48211d52ddba8587534fbf7992f24c4d552236", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -44,16 +44,21 @@ fn compute_implied_outlives_bounds<'tcx>(\n \n     // Sometimes when we ask what it takes for T: WF, we get back that\n     // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Currently (at least) these resulting\n-    // predicates are always guaranteed to be a subset of the original\n-    // type, so we need not fear non-termination.\n+    // process it next. Because the resulting predicates aren't always\n+    // guaranteed to be a subset of the original type, so we need to store the\n+    // WF args we've computed in a set.\n+    let mut checked_wf_args = rustc_data_structures::stable_set::FxHashSet::default();\n     let mut wf_args = vec![ty.into()];\n \n     let mut implied_bounds = vec![];\n \n     let mut fulfill_cx = FulfillmentContext::new();\n \n     while let Some(arg) = wf_args.pop() {\n+        if !checked_wf_args.insert(arg) {\n+            continue;\n+        }\n+\n         // Compute the obligations for `arg` to be well-formed. If `arg` is\n         // an unresolved inference variable, just substituted an empty set\n         // -- because the return type here is going to be things we *add*"}, {"sha": "ed3b9f2db1f8e88ac1972fd7b60027d87b462806", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -206,6 +206,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                     relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n                         && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n                 }\n+                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n+                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n+                }\n                 _ => predicate == p,\n             }\n         };"}, {"sha": "7fe36781cf4940fe971cd37cf30d725c83494545", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -1807,6 +1807,12 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, mut span: Span, id: hir::HirI\n     let implied_obligations = traits::elaborate_predicates_with_span(fcx.tcx, predicates_with_span);\n \n     for obligation in implied_obligations {\n+        // We lower empty bounds like `Vec<dyn Copy>:` as\n+        // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n+        // regular WF checking\n+        if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+            continue;\n+        }\n         let pred = obligation.predicate;\n         // Match the existing behavior.\n         if pred.is_global() && !pred.has_late_bound_regions() {"}, {"sha": "a0cbb7c2c5ae50b35a8c5b485d914af9e023e01f", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -2264,12 +2264,8 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::Binder::bind_with_vars(\n-                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                                ty,\n-                                re_root_empty,\n-                            )),\n+                            ty::PredicateKind::WellFormed(ty.into()),\n                             bound_vars,\n                         );\n                         predicates.insert((predicate.to_predicate(tcx), span));"}, {"sha": "12467001271fd060822f14ead12ac8bef766d7ff", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/116edb6800ea1d6615578e7f65366ae65364b3d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/116edb6800ea1d6615578e7f65366ae65364b3d8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=116edb6800ea1d6615578e7f65366ae65364b3d8", "patch": "@@ -293,10 +293,10 @@ impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n             ty::PredicateKind::TypeOutlives(pred) => pred.clean(cx),\n             ty::PredicateKind::Projection(pred) => Some(pred.clean(cx)),\n             ty::PredicateKind::ConstEvaluatable(..) => None,\n+            ty::PredicateKind::WellFormed(..) => None,\n \n             ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::WellFormed(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::ConstEquate(..)"}]}