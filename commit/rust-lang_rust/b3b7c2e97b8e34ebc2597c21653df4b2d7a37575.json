{"sha": "b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYjdjMmU5N2I4ZTM0ZWJjMjU5N2MyMTY1M2RmNGIyZDdhMzc1NzU=", "commit": {"author": {"name": "root", "email": "root@localhost", "date": "2014-08-23T10:30:08Z"}, "committer": {"name": "root", "email": "root@localhost", "date": "2014-08-23T11:49:19Z"}, "message": "core: Separate failure formatting in str methods slice, slice_to, slice_from\n\nUse a separate inline-never function to format failure message for\nstr::slice() errors.\n\nUsing strcat's idea, this makes sure no formatting code from failure is\ninlined when str::slice() is inlined. The number of `unreachable` being\ninlined when usingi `.slice()` drops from 5 to just 1.", "tree": {"sha": "1353cdc9d2cc4cdfd2e523610c6acf0b4ed3e451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1353cdc9d2cc4cdfd2e523610c6acf0b4ed3e451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "html_url": "https://github.com/rust-lang/rust/commit/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575/comments", "author": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "committer": {"login": "invalid-email-address", "id": 148100, "node_id": "MDQ6VXNlcjE0ODEwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/148100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/invalid-email-address", "html_url": "https://github.com/invalid-email-address", "followers_url": "https://api.github.com/users/invalid-email-address/followers", "following_url": "https://api.github.com/users/invalid-email-address/following{/other_user}", "gists_url": "https://api.github.com/users/invalid-email-address/gists{/gist_id}", "starred_url": "https://api.github.com/users/invalid-email-address/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/invalid-email-address/subscriptions", "organizations_url": "https://api.github.com/users/invalid-email-address/orgs", "repos_url": "https://api.github.com/users/invalid-email-address/repos", "events_url": "https://api.github.com/users/invalid-email-address/events{/privacy}", "received_events_url": "https://api.github.com/users/invalid-email-address/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58bb603ea74a388d7a4dafc0c78f214a46301505", "url": "https://api.github.com/repos/rust-lang/rust/commits/58bb603ea74a388d7a4dafc0c78f214a46301505", "html_url": "https://github.com/rust-lang/rust/commit/58bb603ea74a388d7a4dafc0c78f214a46301505"}], "stats": {"total": 42, "additions": 31, "deletions": 11}, "files": [{"sha": "1ba958cd211faba9552a8b9dddccb672678f7d26", "filename": "src/libcore/str.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b7c2e97b8e34ebc2597c21653df4b2d7a37575/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b3b7c2e97b8e34ebc2597c21653df4b2d7a37575", "patch": "@@ -1705,6 +1705,13 @@ pub trait StrSlice<'a> {\n     fn utf16_units(&self) -> Utf16CodeUnits<'a>;\n }\n \n+#[inline(never)]\n+fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+    assert!(begin <= end);\n+    fail!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n+          begin, end, s);\n+}\n+\n impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n@@ -1808,22 +1815,34 @@ impl<'a> StrSlice<'a> for &'a str {\n \n     #[inline]\n     fn slice(&self, begin: uint, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(begin) && self.is_char_boundary(end),\n-                \"index {} and/or {} in `{}` do not lie on character boundary\", begin,\n-                end, *self);\n-        unsafe { raw::slice_bytes(*self, begin, end) }\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if begin <= end &&\n+           self.is_char_boundary(begin) &&\n+           self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, begin, end) }\n+        } else {\n+            slice_error_fail(*self, begin, end)\n+        }\n     }\n \n     #[inline]\n     fn slice_from(&self, begin: uint) -> &'a str {\n-        self.slice(begin, self.len())\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(begin) {\n+            unsafe { raw::slice_unchecked(*self, begin, self.len()) }\n+        } else {\n+            slice_error_fail(*self, begin, self.len())\n+        }\n     }\n \n     #[inline]\n     fn slice_to(&self, end: uint) -> &'a str {\n-        assert!(self.is_char_boundary(end), \"index {} in `{}` does not lie on \\\n-                a character boundary\", end, *self);\n-        unsafe { raw::slice_bytes(*self, 0, end) }\n+        // is_char_boundary checks that the index is in [0, .len()]\n+        if self.is_char_boundary(end) {\n+            unsafe { raw::slice_unchecked(*self, 0, end) }\n+        } else {\n+            slice_error_fail(*self, 0, end)\n+        }\n     }\n \n     fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n@@ -1898,9 +1917,10 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n-        if index > self.len() { return false; }\n-        let b = self.as_bytes()[index];\n-        return b < 128u8 || b >= 192u8;\n+        match self.as_bytes().get(index) {\n+            None => false,\n+            Some(&b) => b < 128u8 || b >= 192u8,\n+        }\n     }\n \n     #[inline]"}]}