{"sha": "e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyOTRmZDVlY2JkMDk3ZTM0M2RjMzFiM2RmMjdiYmY4MWRiZWE2ZGU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-01T16:42:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-01T16:42:26Z"}, "message": "convert AdtDef::destructor to on-demand\n\nThis removes the Cell from AdtDef. Also, moving destructor validity\nchecking to on-demand (forced during item-type checking) ensures that\ninvalid destructors can't cause ICEs.\n\nFixes #38868.\nFixes #40132.", "tree": {"sha": "ef3da9f703eca05bf752fda09598014b06796192", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef3da9f703eca05bf752fda09598014b06796192"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "html_url": "https://github.com/rust-lang/rust/commit/e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1cb9ba221e5cb0070ac82c6a234af11e4240680", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1cb9ba221e5cb0070ac82c6a234af11e4240680", "html_url": "https://github.com/rust-lang/rust/commit/e1cb9ba221e5cb0070ac82c6a234af11e4240680"}], "stats": {"total": 262, "additions": 133, "deletions": 129}, "files": [{"sha": "6a70dce35c9b60e0684fe05ef904958245e3b154", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -79,8 +79,6 @@ pub enum DepNode<D: Clone + Debug> {\n     Variance,\n     WfCheck(D),\n     TypeckItemType(D),\n-    Dropck,\n-    DropckImpl(D),\n     UnusedTraitCheck,\n     CheckConst(D),\n     Privacy,\n@@ -112,6 +110,7 @@ pub enum DepNode<D: Clone + Debug> {\n     ItemSignature(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n+    AdtDestructor(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n     TypeckTables(D),\n@@ -223,7 +222,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             EntryPoint => Some(EntryPoint),\n             CheckEntryFn => Some(CheckEntryFn),\n             Variance => Some(Variance),\n-            Dropck => Some(Dropck),\n             UnusedTraitCheck => Some(UnusedTraitCheck),\n             Privacy => Some(Privacy),\n             Reachability => Some(Reachability),\n@@ -250,7 +248,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             CoherenceOrphanCheck(ref d) => op(d).map(CoherenceOrphanCheck),\n             WfCheck(ref d) => op(d).map(WfCheck),\n             TypeckItemType(ref d) => op(d).map(TypeckItemType),\n-            DropckImpl(ref d) => op(d).map(DropckImpl),\n             CheckConst(ref d) => op(d).map(CheckConst),\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n@@ -266,6 +263,7 @@ impl<D: Clone + Debug> DepNode<D> {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n             }\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n+            AdtDestructor(ref d) => op(d).map(AdtDestructor),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n             TypeckTables(ref d) => op(d).map(TypeckTables),\n@@ -297,4 +295,3 @@ impl<D: Clone + Debug> DepNode<D> {\n /// them even in the absence of a tcx.)\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct WorkProductId(pub String);\n-"}, {"sha": "fcfdda8721f52fdcf6fec65c7d8e8aad2cf962fd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -333,6 +333,7 @@ define_maps! { <'tcx>\n \n     pub trait_def: ItemSignature(DefId) -> &'tcx ty::TraitDef,\n     pub adt_def: ItemSignature(DefId) -> &'tcx ty::AdtDef,\n+    pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n \n     /// Maps from def-id of a type or region parameter to its"}, {"sha": "9c1b425857fb624ea91e71a77458374fc736b6d7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 33, "deletions": 59, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -1291,17 +1291,31 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct Destructor {\n+    /// The def-id of the destructor method\n+    pub did: DefId,\n+    /// Invoking the destructor of a dtorck type during usual cleanup\n+    /// (e.g. the glue emitted for stack unwinding) requires all\n+    /// lifetimes in the type-structure of `adt` to strictly outlive\n+    /// the adt value itself.\n+    ///\n+    /// If `adt` is not dtorck, then the adt's destructor can be\n+    /// invoked even when there are lifetimes in the type-structure of\n+    /// `adt` that do not strictly outlive the adt value itself.\n+    /// (This allows programs to make cyclic structures without\n+    /// resorting to unasfe means; see RFCs 769 and 1238).\n+    pub is_dtorck: bool,\n+}\n+\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n         const IS_ENUM             = 1 << 0,\n-        const IS_DTORCK           = 1 << 1, // is this a dtorck type?\n-        const IS_DTORCK_VALID     = 1 << 2,\n-        const IS_PHANTOM_DATA     = 1 << 3,\n-        const IS_FUNDAMENTAL      = 1 << 4,\n-        const IS_UNION            = 1 << 5,\n-        const IS_BOX              = 1 << 6,\n-        const IS_DTOR_VALID       = 1 << 7,\n+        const IS_PHANTOM_DATA     = 1 << 1,\n+        const IS_FUNDAMENTAL      = 1 << 2,\n+        const IS_UNION            = 1 << 3,\n+        const IS_BOX              = 1 << 4,\n     }\n }\n \n@@ -1343,8 +1357,7 @@ pub struct FieldDef {\n pub struct AdtDef {\n     pub did: DefId,\n     pub variants: Vec<VariantDef>,\n-    destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>,\n+    flags: AdtFlags,\n     pub repr: ReprOptions,\n }\n \n@@ -1436,32 +1449,24 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         AdtDef {\n             did: did,\n             variants: variants,\n-            flags: Cell::new(flags),\n-            destructor: Cell::new(None),\n+            flags: flags,\n             repr: repr,\n         }\n     }\n \n-    fn calculate_dtorck(&'gcx self, tcx: TyCtxt) {\n-        if tcx.is_adt_dtorck(self) {\n-            self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n-        }\n-        self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n-    }\n-\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n     }\n \n     #[inline]\n     pub fn is_union(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_UNION)\n+        self.flags.intersects(AdtFlags::IS_UNION)\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_ENUM)\n+        self.flags.intersects(AdtFlags::IS_ENUM)\n     }\n \n     /// Returns the kind of the ADT - Struct or Enum.\n@@ -1497,29 +1502,26 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n     pub fn is_dtorck(&'gcx self, tcx: TyCtxt) -> bool {\n-        if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n-            self.calculate_dtorck(tcx)\n-        }\n-        self.flags.get().intersects(AdtFlags::IS_DTORCK)\n+        self.destructor(tcx).map_or(false, |d| d.is_dtorck)\n     }\n \n     /// Returns whether this type is #[fundamental] for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_FUNDAMENTAL)\n+        self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     /// Returns true if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_PHANTOM_DATA)\n+        self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns true if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        self.flags.get().intersects(AdtFlags::IS_BOX)\n+        self.flags.intersects(AdtFlags::IS_BOX)\n     }\n \n     /// Returns whether this type has a destructor.\n@@ -1579,38 +1581,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n-        if self.flags.get().intersects(AdtFlags::IS_DTOR_VALID) {\n-            return self.destructor.get();\n-        }\n-\n-        let dtor = self.destructor_uncached(tcx);\n-        self.destructor.set(dtor);\n-        self.flags.set(self.flags.get() | AdtFlags::IS_DTOR_VALID);\n-\n-        dtor\n-    }\n-\n-    fn destructor_uncached(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<DefId> {\n-        let drop_trait = if let Some(def_id) = tcx.lang_items.drop_trait() {\n-            def_id\n-        } else {\n-            return None;\n-        };\n-\n-        queries::coherent_trait::get(tcx, DUMMY_SP, (LOCAL_CRATE, drop_trait));\n-\n-        let mut dtor = None;\n-        let ty = tcx.item_type(self.did);\n-        tcx.lookup_trait_def(drop_trait).for_each_relevant_impl(tcx, ty, |def_id| {\n-            if let Some(item) = tcx.associated_items(def_id).next() {\n-                dtor = Some(item.def_id);\n-            }\n-        });\n-\n-        dtor\n-    }\n-\n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                          -> impl Iterator<Item=ConstInt> + 'a {\n         let repr_type = self.repr.discr_type();\n@@ -1632,6 +1602,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         })\n     }\n \n+    pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {\n+        queries::adt_destructor::get(tcx, DUMMY_SP, self.did)\n+    }\n+\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///"}, {"sha": "be1582066e393c4b99b6884e6b8f9a5c9dbe85ab", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -10,7 +10,7 @@\n \n //! misc. type-system utilities too small to deserve their own file\n \n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as hir_map;\n@@ -20,6 +20,7 @@ use ty::{ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n+use util::common::ErrorReported;\n use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n@@ -32,7 +33,7 @@ use std::hash::Hash;\n use std::intrinsics;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use hir;\n \n@@ -346,22 +347,33 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         hasher.finish()\n     }\n \n-    /// Returns true if this ADT is a dtorck type.\n-    ///\n-    /// Invoking the destructor of a dtorck type during usual cleanup\n-    /// (e.g. the glue emitted for stack unwinding) requires all\n-    /// lifetimes in the type-structure of `adt` to strictly outlive\n-    /// the adt value itself.\n-    ///\n-    /// If `adt` is not dtorck, then the adt's destructor can be\n-    /// invoked even when there are lifetimes in the type-structure of\n-    /// `adt` that do not strictly outlive the adt value itself.\n-    /// (This allows programs to make cyclic structures without\n-    /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n-        let dtor_method = match adt.destructor(self) {\n+    /// Calculate the destructor of a given type.\n+    pub fn calculate_dtor(\n+        self,\n+        adt_did: DefId,\n+        validate: &mut FnMut(Self, DefId) -> Result<(), ErrorReported>\n+    ) -> Option<ty::Destructor> {\n+        let drop_trait = if let Some(def_id) = self.lang_items.drop_trait() {\n+            def_id\n+        } else {\n+            return None;\n+        };\n+\n+        ty::queries::coherent_trait::get(self, DUMMY_SP, (LOCAL_CRATE, drop_trait));\n+\n+        let mut dtor_did = None;\n+        let ty = self.item_type(adt_did);\n+        self.lookup_trait_def(drop_trait).for_each_relevant_impl(self, ty, |impl_did| {\n+            if let Some(item) = self.associated_items(impl_did).next() {\n+                if let Ok(()) = validate(self, impl_did) {\n+                    dtor_did = Some(item.def_id);\n+                }\n+            }\n+        });\n+\n+        let dtor_did = match dtor_did {\n             Some(dtor) => dtor,\n-            None => return false\n+            None => return None\n         };\n \n         // RFC 1238: if the destructor method is tagged with the\n@@ -373,7 +385,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Such access can be in plain sight (e.g. dereferencing\n         // `*foo.0` of `Foo<'a>(&'a u32)`) or indirectly hidden\n         // (e.g. calling `foo.0.clone()` of `Foo<T:Clone>`).\n-        return !self.has_attr(dtor_method, \"unsafe_destructor_blind_to_params\");\n+        let is_dtorck = !self.has_attr(dtor_did, \"unsafe_destructor_blind_to_params\");\n+        Some(ty::Destructor { did: dtor_did, is_dtorck: is_dtorck })\n     }\n \n     pub fn closure_base_def_id(&self, def_id: DefId) -> DefId {"}, {"sha": "de53c91ba2d8fd60e21230711fcd63023e130f31", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -76,6 +76,10 @@ provide! { <'tcx> tcx, def_id, cdata\n         tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx))\n     }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n+    adt_destructor => {\n+        let _ = cdata;\n+        tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n+    }\n     variances => { Rc::new(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => {\n         let mut result = vec![];"}, {"sha": "632762857ef37c3d0c984d0ca9de672899c57289", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -753,12 +753,12 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n     // If the type implements Drop, also add a translation item for the\n     // monomorphized Drop::drop() implementation.\n-    let destructor_did = match ty.sty {\n+    let destructor = match ty.sty {\n         ty::TyAdt(def, _) => def.destructor(scx.tcx()),\n         _ => None\n     };\n \n-    if let (Some(destructor_did), false) = (destructor_did, ty.is_box()) {\n+    if let (Some(destructor), false) = (destructor, ty.is_box()) {\n         use rustc::ty::ToPolyTraitRef;\n \n         let drop_trait_def_id = scx.tcx()\n@@ -778,9 +778,9 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             _ => bug!()\n         };\n \n-        if should_trans_locally(scx.tcx(), destructor_did) {\n+        if should_trans_locally(scx.tcx(), destructor.did) {\n             let trans_item = create_fn_trans_item(scx,\n-                                                  destructor_did,\n+                                                  destructor.did,\n                                                   substs,\n                                                   scx.tcx().intern_substs(&[]));\n             output.push(trans_item);"}, {"sha": "35ebd67b5f8c19f8555d615397b976676d960588", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -265,7 +265,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n                 traits::VtableImpl(data) => data,\n                 _ => bug!(\"dtor for {:?} is not an impl???\", t)\n             };\n-            let dtor_did = def.destructor(tcx).unwrap();\n+            let dtor_did = def.destructor(tcx).unwrap().did;\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;"}, {"sha": "90d2a15cf08637f4b94ae961aaeed13cdde50fb6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -17,6 +17,7 @@ use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, Reveal};\n+use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n use syntax::ast;\n@@ -40,7 +41,8 @@ use syntax_pos::Span;\n ///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n ///\n pub fn check_drop_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 drop_impl_did: DefId) -> Result<(), ()> {\n+                                 drop_impl_did: DefId)\n+                                 -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.item_type(drop_impl_did);\n     let dtor_predicates = tcx.item_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n@@ -72,7 +74,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     drop_impl_did: DefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId)\n-    -> Result<(), ()>\n+    -> Result<(), ErrorReported>\n {\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n     let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n@@ -106,14 +108,14 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n                                \"Use same sequence of generic type and region \\\n                                 parameters that is on the struct/enum definition\")\n                     .emit();\n-                return Err(());\n+                return Err(ErrorReported);\n             }\n         }\n \n         if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n             // this could be reached when we get lazy normalization\n             infcx.report_fulfillment_errors(errors);\n-            return Err(());\n+            return Err(ErrorReported);\n         }\n \n         let free_regions = FreeRegionMap::new();\n@@ -130,8 +132,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n     dtor_predicates: &ty::GenericPredicates<'tcx>,\n     self_type_did: DefId,\n     self_to_impl_substs: &Substs<'tcx>)\n-    -> Result<(), ()>\n+    -> Result<(), ErrorReported>\n {\n+    let mut result = Ok(());\n \n     // Here is an example, analogous to that from\n     // `compare_impl_method`.\n@@ -207,13 +210,11 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n                            \"The same requirement must be part of \\\n                             the struct/enum definition\")\n                 .emit();\n+            result = Err(ErrorReported);\n         }\n     }\n \n-    if tcx.sess.has_errors() {\n-        return Err(());\n-    }\n-    Ok(())\n+    result\n }\n \n /// check_safety_of_destructor_if_necessary confirms that the type\n@@ -556,7 +557,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             // attributes attached to the impl's generics.\n             let dtor_method = adt_def.destructor(tcx)\n                 .expect(\"dtorck type without destructor impossible\");\n-            let method = tcx.associated_item(dtor_method);\n+            let method = tcx.associated_item(dtor_method.did);\n             let impl_def_id = method.container.id();\n             let revised_ty = revise_self_ty(tcx, adt_def, impl_def_id, substs);\n             return DropckKind::RevisedSelf(revised_ty);"}, {"sha": "7ff0e45ceceaec8360b90b8f998106a545b57cee", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -609,31 +609,12 @@ pub fn check_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult\n     })\n }\n \n-pub fn check_drop_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CompileResult {\n-    tcx.sess.track_errors(|| {\n-        let _task = tcx.dep_graph.in_task(DepNode::Dropck);\n-        let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => tcx.lookup_trait_def(id), None => { return }\n-        };\n-        drop_trait.for_each_impl(tcx, |drop_impl_did| {\n-            let _task = tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n-            if drop_impl_did.is_local() {\n-                match dropck::check_drop_impl(tcx, drop_impl_did) {\n-                    Ok(()) => {}\n-                    Err(()) => {\n-                        assert!(tcx.sess.has_errors());\n-                    }\n-                }\n-            }\n-        });\n-    })\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_tables,\n         closure_type,\n         closure_kind,\n+        adt_destructor,\n         ..*providers\n     };\n }\n@@ -652,6 +633,12 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.item_tables(def_id).closure_kinds[&node_id]\n }\n \n+fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            def_id: DefId)\n+                            -> Option<ty::Destructor> {\n+    tcx.calculate_dtor(def_id, &mut dropck::check_drop_impl)\n+}\n+\n fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> &'tcx ty::TypeckTables<'tcx> {\n@@ -901,17 +888,22 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           id: ast::NodeId,\n                           span: Span) {\n     let def_id = tcx.hir.local_def_id(id);\n+    let def = tcx.lookup_adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n \n-    if tcx.lookup_adt_def(def_id).repr.simd {\n+    if def.repr.simd {\n         check_simd(tcx, span, def_id);\n     }\n }\n \n fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          id: ast::NodeId,\n                          span: Span) {\n-    check_representable(tcx, span, tcx.hir.local_def_id(id));\n+    let def_id = tcx.hir.local_def_id(id);\n+    let def = tcx.lookup_adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n+    check_representable(tcx, span, def_id);\n }\n \n pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n@@ -926,10 +918,10 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n         tcx.item_tables(tcx.hir.local_def_id(it.id));\n       }\n       hir::ItemEnum(ref enum_definition, _) => {\n-        check_enum_variants(tcx,\n-                            it.span,\n-                            &enum_definition.variants,\n-                            it.id);\n+        check_enum(tcx,\n+                   it.span,\n+                   &enum_definition.variants,\n+                   it.id);\n       }\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(.., ref impl_item_refs) => {\n@@ -1322,12 +1314,13 @@ pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId\n }\n \n #[allow(trivial_numeric_casts)]\n-pub fn check_enum_variants<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     sp: Span,\n-                                     vs: &'tcx [hir::Variant],\n-                                     id: ast::NodeId) {\n+pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            sp: Span,\n+                            vs: &'tcx [hir::Variant],\n+                            id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(id);\n     let def = tcx.lookup_adt_def(def_id);\n+    def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() && tcx.has_attr(def_id, \"repr\") {\n         struct_span_err!("}, {"sha": "df1c94dc19b59eb761a9bae3697bf9fff3517b48", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -322,8 +322,6 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n     time(time_passes, \"item-bodies checking\", || check::check_item_bodies(tcx))?;\n \n-    time(time_passes, \"drop-impl checking\", || check::check_drop_impls(tcx))?;\n-\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n "}, {"sha": "c7e1da7094f2b4562970f4fc2c89c25c0db05c76", "filename": "src/test/compile-fail/issue-38868.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Ftest%2Fcompile-fail%2Fissue-38868.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e294fd5ecbd097e343dc31b3df27bbf81dbea6de/src%2Ftest%2Fcompile-fail%2Fissue-38868.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-38868.rs?ref=e294fd5ecbd097e343dc31b3df27bbf81dbea6de", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct List<T> {\n+    head: T,\n+}\n+\n+impl Drop for List<i32> { //~ ERROR E0366\n+    fn drop(&mut self) {\n+        panic!()\n+    }\n+}\n+\n+fn main() {\n+    List { head: 0 };\n+}"}]}