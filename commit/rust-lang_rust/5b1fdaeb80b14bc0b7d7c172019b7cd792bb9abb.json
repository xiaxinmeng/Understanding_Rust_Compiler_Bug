{"sha": "5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMWZkYWViODBiMTRiYzBiN2Q3YzE3MjAxOWI3Y2Q3OTJiYjlhYmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-25T09:41:24Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:28Z"}, "message": "rustc_trans: use more of the trans::mir and ty::layout APIs throughout.", "tree": {"sha": "a7b4ccad6fb4f8b406d54c4b23df6b78355f6d5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7b4ccad6fb4f8b406d54c4b23df6b78355f6d5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "html_url": "https://github.com/rust-lang/rust/commit/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "260c41b4b808fd9995f23ce1eb7d820f49254c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/260c41b4b808fd9995f23ce1eb7d820f49254c85", "html_url": "https://github.com/rust-lang/rust/commit/260c41b4b808fd9995f23ce1eb7d820f49254c85"}], "stats": {"total": 1591, "additions": 706, "deletions": 885}, "files": [{"sha": "d51c25ba6d389c35dfa08f36fd2161e9e6696e4f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -1700,6 +1700,10 @@ impl<'a, 'tcx> Layout {\n         }\n     }\n \n+    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n+        (self.size(cx), self.align(cx))\n+    }\n+\n     /// Returns alignment before repr alignment is applied\n     pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n         match *self {\n@@ -2201,6 +2205,11 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for LayoutCx<'a, 'tcx> {\n \n impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn for_variant(&self, variant_index: usize) -> Self {\n+        let is_enum = match self.ty.sty {\n+            ty::TyAdt(def, _) => def.is_enum(),\n+            _ => false\n+        };\n+        assert!(is_enum);\n         TyLayout {\n             variant_index: Some(variant_index),\n             ..*self\n@@ -2214,13 +2223,26 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn field_count(&self) -> usize {\n         // Handle enum/union through the type rather than Layout.\n         if let ty::TyAdt(def, _) = self.ty.sty {\n-            let v = self.variant_index.unwrap_or(0);\n-            if def.variants.is_empty() {\n-                assert_eq!(v, 0);\n-                return 0;\n+            let v = if def.is_enum() {\n+                if def.variants.is_empty() {\n+                    return 0;\n+                }\n+                match self.variant_index {\n+                    None => match *self.layout {\n+                        // Discriminant field for enums (where applicable).\n+                        General { .. } => return 1,\n+                        _ if def.variants.len() > 1 => return 0,\n+\n+                        // Enums with one variant behave like structs.\n+                        _ => 0\n+                    },\n+                    Some(v) => v\n+                }\n             } else {\n-                return def.variants[v].fields.len();\n-            }\n+                0\n+            };\n+\n+            return def.variants[v].fields.len();\n         }\n \n         match *self.layout {\n@@ -2248,7 +2270,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n-    pub fn field_type<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+    fn field_type_unnormalized<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n         let tcx = cx.tcx();\n \n         let ptr_field_type = |pointee: Ty<'tcx>| {\n@@ -2314,7 +2336,25 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                def.variants[self.variant_index.unwrap_or(0)].fields[i].ty(tcx, substs)\n+                let v = if def.is_enum() {\n+                    match self.variant_index {\n+                        None => match *self.layout {\n+                            // Discriminant field for enums (where applicable).\n+                            General { discr, .. } => {\n+                                return [discr.to_ty(tcx, false)][i];\n+                            }\n+                            _ if def.variants.len() > 1 => return [][i],\n+\n+                            // Enums with one variant behave like structs.\n+                            _ => 0\n+                        },\n+                        Some(v) => v\n+                    }\n+                } else {\n+                    0\n+                };\n+\n+                def.variants[v].fields[i].ty(tcx, substs)\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n@@ -2324,11 +2364,15 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         }\n     }\n \n+    pub fn field_type<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+        cx.normalize_projections(self.field_type_unnormalized(cx, i))\n+    }\n+\n     pub fn field<C: LayoutTyper<'tcx>>(&self,\n                                        cx: C,\n                                        i: usize)\n                                        -> C::TyLayout {\n-        cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n+        cx.layout_of(self.field_type(cx, i))\n     }\n }\n "}, {"sha": "04041488016c544fbdd40a2751f4ea0b25a6ad2b", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -30,6 +30,7 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n+use mir::lvalue::LvalueRef;\n use type_::Type;\n use type_of;\n \n@@ -570,20 +571,20 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: LvalueRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n             let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n-            base::call_memcpy(bcx, dst, val, llsz, self.layout.align(ccx));\n+            base::call_memcpy(bcx, dst.llval, val, llsz, self.layout.align(ccx));\n         } else if let Some(ty) = self.cast {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst, ty.llvm_type(ccx).ptr_to());\n+                let cast_dst = bcx.pointercast(dst.llval, ty.llvm_type(ccx).ptr_to());\n                 bcx.store(val, cast_dst, Some(self.layout.align(ccx)));\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -610,22 +611,20 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n-                                  bcx.pointercast(dst, Type::i8p(ccx)),\n+                                  bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n                                   C_usize(ccx, self.layout.size(ccx).bytes()),\n                                   self.layout.align(ccx).min(ty.align(ccx)));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n             }\n         } else {\n-            if self.layout.ty == ccx.tcx().types.bool {\n-                val = bcx.zext(val, Type::i8(ccx));\n-            }\n-            bcx.store(val, dst, None);\n+            val = base::from_immediate(bcx, val);\n+            bcx.store(val, dst.llval, None);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: LvalueRef<'tcx>) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }"}, {"sha": "2383b372865101eb71ad462be58755b1279bb0f9", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 40, "deletions": 66, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -42,10 +42,9 @@\n //!   taken to it, implementing them for Rust seems difficult.\n \n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, Align, HasDataLayout, LayoutTyper, Size};\n+use rustc::ty::layout::{self, Align, HasDataLayout, LayoutTyper, Size, TyLayout};\n \n use context::CrateContext;\n-use monomorphize;\n use type_::Type;\n use type_of;\n \n@@ -75,15 +74,25 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         | layout::UntaggedUnion { .. } | layout::RawNullablePointer { .. } => { }\n         layout::Univariant { ..}\n         | layout::StructWrappedNullablePointer { .. } => {\n-            let (nonnull_variant_index, nonnull_variant, packed) = match *l {\n-                layout::Univariant { ref variant, .. } => (0, variant, variant.packed),\n+            let (variant_layout, variant) = match *l {\n+                layout::Univariant { ref variant, .. } => {\n+                    let is_enum = if let ty::TyAdt(def, _) = t.sty {\n+                        def.is_enum()\n+                    } else {\n+                        false\n+                    };\n+                    if is_enum {\n+                        (l.for_variant(0), variant)\n+                    } else {\n+                        (l, variant)\n+                    }\n+                }\n                 layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } =>\n-                    (nndiscr, nonnull, nonnull.packed),\n+                    (l.for_variant(nndiscr as usize), nonnull),\n                 _ => unreachable!()\n             };\n-            llty.set_struct_body(&struct_llfields(cx, t, nonnull_variant_index as usize,\n-                                                  nonnull_variant, None),\n-                                 packed)\n+            llty.set_struct_body(&struct_llfields(cx, variant_layout, variant, None),\n+                                 variant.packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n     }\n@@ -97,22 +106,18 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *l {\n         layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let (def, substs) = match t.sty {\n-                ty::TyAdt(d, s) => (d, s),\n-                _ => bug!(\"{} is not an ADT\", t)\n-            };\n-            let nnty = monomorphize::field_ty(cx.tcx(), substs,\n-                &def.variants[nndiscr as usize].fields[0]);\n-            if let layout::Scalar { value: layout::Pointer, .. } = *cx.layout_of(nnty) {\n+            let nnfield = l.for_variant(nndiscr as usize).field(cx, 0);\n+            if let layout::Scalar { value: layout::Pointer, .. } = *nnfield {\n                 Type::i8p(cx)\n             } else {\n-                type_of::type_of(cx, nnty)\n+                type_of::type_of(cx, nnfield.ty)\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, t, nndiscr as usize, nonnull, None),\n+                    Type::struct_(cx, &struct_llfields(cx, l.for_variant(nndiscr as usize),\n+                                                       nonnull, None),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -123,7 +128,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         layout::Univariant { ref variant, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, t, 0, &variant, None),\n+                    Type::struct_(cx, &struct_llfields(cx, l, &variant, None),\n                                   variant.packed)\n                 }\n                 Some(name) => {\n@@ -199,61 +204,30 @@ fn union_fill(cx: &CrateContext, size: Size, align: Align) -> Type {\n }\n \n /// Double an index to account for padding.\n-pub fn memory_index_to_gep(index: usize) -> usize {\n+pub fn memory_index_to_gep(index: u64) -> u64 {\n     index * 2\n }\n \n-/// Lookup `Struct::memory_index`, double it to account for padding.\n-pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n-    memory_index_to_gep(variant.memory_index[index] as usize)\n-}\n-\n pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 t: Ty<'tcx>,\n-                                 variant_index: usize,\n+                                 layout: TyLayout<'tcx>,\n                                  variant: &layout::Struct,\n                                  discr: Option<Ty<'tcx>>) -> Vec<Type> {\n-    let field_count = match t.sty {\n-        ty::TyAdt(ref def, _) if def.variants.len() == 0 => return vec![],\n-        ty::TyAdt(ref def, _) => {\n-            discr.is_some() as usize + def.variants[variant_index].fields.len()\n-        },\n-        ty::TyTuple(fields, _) => fields.len(),\n-        ty::TyClosure(def_id, substs) => {\n-            if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n-            substs.upvar_tys(def_id, cx.tcx()).count()\n-        },\n-        ty::TyGenerator(def_id, substs, _) => {\n-            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n-            substs.field_tys(def_id, cx.tcx()).count()\n-        },\n-        _ => bug!(\"{} is not a type that can have fields.\", t)\n-    };\n+    let field_count = (discr.is_some() as usize) + layout.field_count();\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut first_field = true;\n     let mut offset = Size::from_bytes(0);\n     let mut result: Vec<Type> = Vec::with_capacity(field_count * 2);\n     let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n-        (i, match t.sty {\n-            ty::TyAdt(..) if i == 0 && discr.is_some() => discr.unwrap(),\n-            ty::TyAdt(ref def, ref substs) => {\n-                monomorphize::field_ty(cx.tcx(), substs,\n-                    &def.variants[variant_index].fields[i as usize - discr.is_some() as usize])\n-            },\n-            ty::TyTuple(fields, _) => fields[i as usize],\n-            ty::TyClosure(def_id, substs) => {\n-                substs.upvar_tys(def_id, cx.tcx()).nth(i).unwrap()\n-            },\n-            ty::TyGenerator(def_id, substs, _) => {\n-                let ty = substs.field_tys(def_id, cx.tcx()).nth(i).unwrap();\n-                cx.tcx().normalize_associated_type(&ty)\n-            },\n-            _ => bug!()\n-        }, variant.offsets[i as usize])\n+        let ty = if i == 0 && discr.is_some() {\n+            cx.layout_of(discr.unwrap())\n+        } else {\n+            layout.field(cx, i - discr.is_some() as usize)\n+        };\n+        (i, ty, variant.offsets[i as usize])\n     });\n-    for (index, ty, target_offset) in field_iter {\n-        debug!(\"struct_llfields: {} ty: {} offset: {:?} target_offset: {:?}\",\n-            index, ty, offset, target_offset);\n+    for (index, field, target_offset) in field_iter {\n+        debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n+            index, field, offset, target_offset);\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n         if first_field {\n@@ -263,19 +237,19 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             result.push(Type::array(&Type::i8(cx), padding.bytes()));\n             debug!(\"    padding before: {:?}\", padding);\n         }\n-        let llty = type_of::in_memory_type_of(cx, ty);\n+        let llty = type_of::in_memory_type_of(cx, field.ty);\n         result.push(llty);\n-        let layout = cx.layout_of(ty);\n+\n         if variant.packed {\n             assert_eq!(padding.bytes(), 0);\n         } else {\n-            let field_align = layout.align(cx);\n+            let field_align = field.align(cx);\n             assert!(field_align.abi() <= variant.align.abi(),\n                     \"non-packed type has field with larger align ({}): {:#?}\",\n                     field_align.abi(), variant);\n         }\n-        let target_size = layout.size(&cx.tcx().data_layout);\n-        offset = target_offset + target_size;\n+\n+        offset = target_offset + field.size(cx);\n     }\n     if variant.sized && field_count > 0 {\n         if offset > variant.stride() {"}, {"sha": "e6199df62d345703601bc503d4fd003ab7282c12", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -11,16 +11,16 @@\n //! # Translation of inline assembly.\n \n use llvm::{self, ValueRef};\n-use base;\n use common::*;\n use type_of;\n use type_::Type;\n use builder::Builder;\n \n use rustc::hir;\n use rustc::ty::Ty;\n+use rustc::ty::layout::Align;\n \n-use mir::lvalue::Alignment;\n+use mir::lvalue::{LvalueRef, Alignment};\n \n use std::ffi::CString;\n use syntax::ast::AsmDialect;\n@@ -40,16 +40,17 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     let mut indirect_outputs = vec![];\n     for (i, (out, &(val, ty))) in ia.outputs.iter().zip(&outputs).enumerate() {\n         let val = if out.is_rw || out.is_indirect {\n-            Some(base::load_ty(bcx, val, Alignment::Packed, ty))\n+            Some(LvalueRef::new_sized(val, ty,\n+                Alignment::Packed(Align::from_bytes(1, 1).unwrap())).load(bcx))\n         } else {\n             None\n         };\n         if out.is_rw {\n-            inputs.push(val.unwrap());\n+            inputs.push(val.unwrap().immediate());\n             ext_constraints.push(i.to_string());\n         }\n         if out.is_indirect {\n-            indirect_outputs.push(val.unwrap());\n+            indirect_outputs.push(val.unwrap().immediate());\n         } else {\n             output_types.push(type_of::type_of(bcx.ccx, ty));\n         }\n@@ -107,7 +108,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     // Again, based on how many outputs we have\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n     for (i, (_, &(val, _))) in outputs.enumerate() {\n-        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i) };\n+        let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i as u64) };\n         bcx.store(v, val, None);\n     }\n "}, {"sha": "91f7bf39f1a6b89f2983a72d8c9dd1f36ae7bc3a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 34, "deletions": 135, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -48,15 +48,14 @@ use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n-use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n use attributes;\n use builder::Builder;\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_undef, C_array};\n+use common::{C_struct_in_context, C_array};\n use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -66,14 +65,13 @@ use debuginfo;\n use declare;\n use meth;\n use mir;\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n use symbol_names_test;\n use time_graph;\n use trans_item::{TransItem, BaseTransItemExt, TransItemExt, DefPathBasedNames};\n use type_::Type;\n use type_of;\n-use value::Value;\n use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n@@ -90,7 +88,7 @@ use syntax::attr;\n use rustc::hir;\n use syntax::ast;\n \n-use mir::lvalue::Alignment;\n+use mir::operand::{OperandRef, OperandValue};\n \n pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n pub use rustc_trans_utils::trans_item::linkage_by_name;\n@@ -125,14 +123,6 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-pub fn get_meta(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    bcx.struct_gep(fat_ptr, abi::FAT_PTR_EXTRA)\n-}\n-\n-pub fn get_dataptr(bcx: &Builder, fat_ptr: ValueRef) -> ValueRef {\n-    bcx.struct_gep(fat_ptr, abi::FAT_PTR_ADDR)\n-}\n-\n pub fn bin_op_to_icmp_predicate(op: hir::BinOp_,\n                                 signed: bool)\n                                 -> llvm::IntPredicate {\n@@ -257,25 +247,29 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                     src: &LvalueRef<'tcx>,\n-                                     dst: &LvalueRef<'tcx>) {\n+                                     src: LvalueRef<'tcx>,\n+                                     dst: LvalueRef<'tcx>) {\n     let src_ty = src.ty.to_ty(bcx.tcx());\n     let dst_ty = dst.ty.to_ty(bcx.tcx());\n     let coerce_ptr = || {\n-        let (base, info) = if common::type_is_fat_ptr(bcx.ccx, src_ty) {\n-            // fat-ptr to fat-ptr unsize preserves the vtable\n-            // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n-            // So we need to pointercast the base to ensure\n-            // the types match up.\n-            let (base, info) = load_fat_ptr(bcx, src.llval, src.alignment, src_ty);\n-            let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n-            let base = bcx.pointercast(base, llcast_ty);\n-            (base, info)\n-        } else {\n-            let base = load_ty(bcx, src.llval, src.alignment, src_ty);\n-            unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+        let (base, info) = match src.load(bcx).val {\n+            OperandValue::Pair(base, info) => {\n+                // fat-ptr to fat-ptr unsize preserves the vtable\n+                // i.e. &'a fmt::Debug+Send => &'a fmt::Debug\n+                // So we need to pointercast the base to ensure\n+                // the types match up.\n+                let llcast_ty = type_of::fat_ptr_base_ty(bcx.ccx, dst_ty);\n+                (bcx.pointercast(base, llcast_ty), info)\n+            }\n+            OperandValue::Immediate(base) => {\n+                unsize_thin_ptr(bcx, base, src_ty, dst_ty)\n+            }\n+            OperandValue::Ref(..) => bug!()\n         };\n-        store_fat_ptr(bcx, base, info, dst.llval, dst.alignment, dst_ty);\n+        OperandRef {\n+            val: OperandValue::Pair(base, info),\n+            ty: dst_ty\n+        }.store(bcx, dst);\n     };\n     match (&src_ty.sty, &dst_ty.sty) {\n         (&ty::TyRef(..), &ty::TyRef(..)) |\n@@ -287,32 +281,25 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             coerce_ptr()\n         }\n \n-        (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+        (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            let src_fields = def_a.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_a, f)\n-            });\n-            let dst_fields = def_b.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_b, f)\n-            });\n+            for i in 0..def_a.variants[0].fields.len() {\n+                let src_f = src.project_field(bcx, i);\n+                let dst_f = dst.project_field(bcx, i);\n+\n+                let src_f_ty = src_f.ty.to_ty(bcx.tcx());\n+                let dst_f_ty = dst_f.ty.to_ty(bcx.tcx());\n \n-            let iter = src_fields.zip(dst_fields).enumerate();\n-            for (i, (src_fty, dst_fty)) in iter {\n-                if type_is_zero_size(bcx.ccx, dst_fty) {\n+                if type_is_zero_size(bcx.ccx, dst_f_ty) {\n                     continue;\n                 }\n \n-                let (src_f, src_f_align) = src.trans_field_ptr(bcx, i);\n-                let (dst_f, dst_f_align) = dst.trans_field_ptr(bcx, i);\n-                if src_fty == dst_fty {\n-                    memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n+                if src_f_ty == dst_f_ty {\n+                    memcpy_ty(bcx, dst_f.llval, src_f.llval, src_f_ty,\n+                        (src_f.alignment | dst_f.alignment).non_abi());\n                 } else {\n-                    coerce_unsized_into(\n-                        bcx,\n-                        &LvalueRef::new_sized_ty(src_f, src_fty, src_f_align),\n-                        &LvalueRef::new_sized_ty(dst_f, dst_fty, dst_f_align)\n-                    );\n+                    coerce_unsized_into(bcx, src_f, dst_f);\n                 }\n             }\n         }\n@@ -385,94 +372,6 @@ pub fn call_assume<'a, 'tcx>(b: &Builder<'a, 'tcx>, val: ValueRef) {\n     b.call(assume_intrinsic, &[val], None);\n }\n \n-/// Helper for loading values from memory. Does the necessary conversion if the in-memory type\n-/// differs from the type used for SSA values. Also handles various special cases where the type\n-/// gives us better information about what we are loading.\n-pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef,\n-                         alignment: Alignment, t: Ty<'tcx>) -> ValueRef {\n-    let ccx = b.ccx;\n-    if type_is_zero_size(ccx, t) {\n-        return C_undef(type_of::type_of(ccx, t));\n-    }\n-\n-    unsafe {\n-        let global = llvm::LLVMIsAGlobalVariable(ptr);\n-        if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-            let val = llvm::LLVMGetInitializer(global);\n-            if !val.is_null() {\n-                if t.is_bool() {\n-                    return llvm::LLVMConstTrunc(val, Type::i1(ccx).to_ref());\n-                }\n-                return val;\n-            }\n-        }\n-    }\n-\n-    if t.is_bool() {\n-        b.trunc(b.load_range_assert(ptr, 0, 2, llvm::False, alignment.to_align()),\n-                Type::i1(ccx))\n-    } else if t.is_char() {\n-        // a char is a Unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        b.load_range_assert(ptr, 0, 0x10FFFF + 1, llvm::False, alignment.to_align())\n-    } else if (t.is_region_ptr() || t.is_box() || t.is_fn())\n-        && !common::type_is_fat_ptr(ccx, t)\n-    {\n-        b.load_nonnull(ptr, alignment.to_align())\n-    } else {\n-        b.load(ptr, alignment.to_align())\n-    }\n-}\n-\n-/// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n-/// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef,\n-                          dst_align: Alignment, t: Ty<'tcx>) {\n-    debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n-\n-    if common::type_is_fat_ptr(cx.ccx, t) {\n-        let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n-        let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n-        store_fat_ptr(cx, lladdr, llextra, dst, dst_align, t);\n-    } else {\n-        cx.store(from_immediate(cx, v), dst, dst_align.to_align());\n-    }\n-}\n-\n-pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n-                               data: ValueRef,\n-                               extra: ValueRef,\n-                               dst: ValueRef,\n-                               dst_align: Alignment,\n-                               _ty: Ty<'tcx>) {\n-    // FIXME: emit metadata\n-    cx.store(data, get_dataptr(cx, dst), dst_align.to_align());\n-    cx.store(extra, get_meta(cx, dst), dst_align.to_align());\n-}\n-\n-pub fn load_fat_ptr<'a, 'tcx>(\n-    b: &Builder<'a, 'tcx>, src: ValueRef, alignment: Alignment, t: Ty<'tcx>\n-) -> (ValueRef, ValueRef) {\n-    let ptr = get_dataptr(b, src);\n-    let ptr = if t.is_region_ptr() || t.is_box() {\n-        b.load_nonnull(ptr, alignment.to_align())\n-    } else {\n-        b.load(ptr, alignment.to_align())\n-    };\n-\n-    let meta = get_meta(b, src);\n-    let meta_ty = val_ty(meta);\n-    // If the 'meta' field is a pointer, it's a vtable, so use load_nonnull\n-    // instead\n-    let meta = if meta_ty.element_type().kind() == llvm::TypeKind::Pointer {\n-        b.load_nonnull(meta, None)\n-    } else {\n-        b.load(meta, None)\n-    };\n-\n-    (ptr, meta)\n-}\n-\n pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     if val_ty(val) == Type::i1(bcx.ccx) {\n         bcx.zext(val, Type::i8(bcx.ccx))"}, {"sha": "6ad12a13eca7ad3938af3884ac8a0323a2915489", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -625,25 +625,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    // Simple wrapper around GEP that takes an array of ints and wraps them\n-    // in C_i32()\n-    #[inline]\n-    pub fn gepi(&self, base: ValueRef, ixs: &[usize]) -> ValueRef {\n-        // Small vector optimization. This should catch 100% of the cases that\n-        // we care about.\n-        if ixs.len() < 16 {\n-            let mut small_vec = [ C_i32(self.ccx, 0); 16 ];\n-            for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs) {\n-                *small_vec_e = C_i32(self.ccx, ix as i32);\n-            }\n-            self.inbounds_gep(base, &small_vec[..ixs.len()])\n-        } else {\n-            let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n-            self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, &v)\n-        }\n-    }\n-\n     pub fn inbounds_gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n@@ -652,8 +633,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: usize) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"structgep\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n         }\n@@ -959,16 +941,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: usize) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n     pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: usize) -> ValueRef {\n+                       idx: u64) -> ValueRef {\n         self.count_insn(\"insertvalue\");\n+        assert_eq!(idx as c_uint as u64, idx);\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n                                        noname())"}, {"sha": "109c111efa95fca3ad0e34a138800ac185f8bd35", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 55, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -22,7 +22,6 @@ use base;\n use builder::Builder;\n use consts;\n use declare;\n-use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::traits;\n@@ -68,66 +67,21 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     }\n }\n \n-/// Returns Some([a, b]) if the type has a pair of fields with types a and b.\n-pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n-                                  -> Option<[Ty<'tcx>; 2]> {\n-    match ty.sty {\n-        ty::TyAdt(adt, substs) => {\n-            assert_eq!(adt.variants.len(), 1);\n-            let fields = &adt.variants[0].fields;\n-            if fields.len() != 2 {\n-                return None;\n-            }\n-            Some([monomorphize::field_ty(ccx.tcx(), substs, &fields[0]),\n-                  monomorphize::field_ty(ccx.tcx(), substs, &fields[1])])\n-        }\n-        ty::TyClosure(def_id, substs) => {\n-            let mut tys = substs.upvar_tys(def_id, ccx.tcx());\n-            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n-                if tys.next().is_some() {\n-                    None\n-                } else {\n-                    Some([first_ty, second_ty])\n-                }\n-            }))\n-        }\n-        ty::TyGenerator(def_id, substs, _) => {\n-            let mut tys = substs.field_tys(def_id, ccx.tcx());\n-            tys.next().and_then(|first_ty| tys.next().and_then(|second_ty| {\n-                if tys.next().is_some() {\n-                    None\n-                } else {\n-                    Some([first_ty, second_ty])\n-                }\n-            }))\n-        }\n-        ty::TyTuple(tys, _) => {\n-            if tys.len() != 2 {\n-                return None;\n-            }\n-            Some([tys[0], tys[1]])\n-        }\n-        _ => None\n-    }\n-}\n-\n /// Returns true if the type is represented as a pair of immediates.\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n-    match *ccx.layout_of(ty) {\n+    let layout = ccx.layout_of(ty);\n+    match *layout {\n         Layout::FatPointer { .. } => true,\n         Layout::Univariant { ref variant, .. } => {\n             // There must be only 2 fields.\n             if variant.offsets.len() != 2 {\n                 return false;\n             }\n \n-            match type_pair_fields(ccx, ty) {\n-                Some([a, b]) => {\n-                    type_is_immediate(ccx, a) && type_is_immediate(ccx, b)\n-                }\n-                None => false\n-            }\n+            // The two fields must be both immediates.\n+            type_is_immediate(ccx, layout.field_type(ccx, 0)) &&\n+            type_is_immediate(ccx, layout.field_type(ccx, 1))\n         }\n         _ => false\n     }\n@@ -356,13 +310,14 @@ pub fn C_bytes_in_context(llcx: ContextRef, bytes: &[u8]) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(v: ValueRef, i: usize) -> ValueRef {\n+pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n     unsafe {\n-        let us = &[i as c_uint];\n+        assert_eq!(idx as c_uint as u64, idx);\n+        let us = &[idx as c_uint];\n         let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n \n-        debug!(\"const_get_elt(v={:?}, i={}, r={:?})\",\n-               Value(v), i, Value(r));\n+        debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n+               Value(v), idx, Value(r));\n \n         r\n     }"}, {"sha": "2869ddb6e220efe5811de42857f3acfca66917b9", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -30,10 +30,9 @@ use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n use rustc::ich::Fingerprint;\n-use monomorphize;\n use common::{self, CrateContext};\n use rustc::ty::{self, AdtKind, Ty};\n-use rustc::ty::layout::{self, Align, LayoutTyper, Size};\n+use rustc::ty::layout::{self, Align, LayoutTyper, Size, TyLayout};\n use rustc::session::{Session, config};\n use rustc::util::nodemap::FxHashMap;\n use rustc::util::common::path2cstr;\n@@ -932,7 +931,6 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n struct StructMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n \n@@ -960,12 +958,11 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             } else {\n                 f.name.to_string()\n             };\n-            let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n-\n-            let (size, align) = cx.size_and_align_of(fty);\n+            let field = layout.field(cx, i);\n+            let (size, align) = field.size_and_align(cx);\n             MemberDescription {\n                 name,\n-                type_metadata: type_metadata(cx, fty, self.span),\n+                type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: offsets[i],\n                 size,\n                 align,\n@@ -983,8 +980,8 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n \n-    let (struct_def_id, variant, substs) = match struct_type.sty {\n-        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+    let (struct_def_id, variant) = match struct_type.sty {\n+        ty::TyAdt(def, _) => (def.did, def.struct_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\")\n     };\n \n@@ -1004,7 +1001,6 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         StructMDF(StructMemberDescriptionFactory {\n             ty: struct_type,\n             variant,\n-            substs,\n             span,\n         })\n     )\n@@ -1075,20 +1071,20 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n+    layout: TyLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        self.variant.fields.iter().map(|field| {\n-            let fty = monomorphize::field_ty(cx.tcx(), self.substs, field);\n-            let (size, align) = cx.size_and_align_of(fty);\n+        self.variant.fields.iter().enumerate().map(|(i, f)| {\n+            let field = self.layout.field(cx, i);\n+            let (size, align) = field.size_and_align(cx);\n             MemberDescription {\n-                name: field.name.to_string(),\n-                type_metadata: type_metadata(cx, fty, self.span),\n+                name: f.name.to_string(),\n+                type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: Size::from_bytes(0),\n                 size,\n                 align,\n@@ -1105,8 +1101,8 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     -> RecursiveTypeDescription<'tcx> {\n     let union_name = compute_debuginfo_type_name(cx, union_type, false);\n \n-    let (union_def_id, variant, substs) = match union_type.sty {\n-        ty::TyAdt(def, substs) => (def.did, def.struct_variant(), substs),\n+    let (union_def_id, variant) = match union_type.sty {\n+        ty::TyAdt(def, _) => (def.did, def.struct_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\")\n     };\n \n@@ -1124,8 +1120,8 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         union_metadata_stub,\n         UnionMDF(UnionMemberDescriptionFactory {\n+            layout: cx.layout_of(union_type),\n             variant,\n-            substs,\n             span,\n         })\n     )\n@@ -1142,7 +1138,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n-    type_rep: &'tcx layout::Layout,\n+    type_rep: TyLayout<'tcx>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1153,11 +1149,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n-        let substs = match self.enum_type.sty {\n-            ty::TyAdt(def, ref s) if def.adt_kind() == AdtKind::Enum => s,\n-            _ => bug!(\"{} is not an enum\", self.enum_type)\n-        };\n-        match *self.type_rep {\n+        match *self.type_rep.layout {\n             layout::General { ref variants, .. } => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n@@ -1169,6 +1161,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n+                                                  i,\n                                                   &adt.variants[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n@@ -1200,6 +1193,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               variant,\n+                                              0,\n                                               &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n@@ -1223,19 +1217,19 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     ]\n                 }\n             }\n-            layout::RawNullablePointer { nndiscr: non_null_variant_index, .. } => {\n+            layout::RawNullablePointer { nndiscr, .. } => {\n                 // As far as debuginfo is concerned, the pointer this enum\n                 // represents is still wrapped in a struct. This is to make the\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n+                let non_null_variant = &adt.variants[nndiscr as usize];\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n-                let nnty = monomorphize::field_ty(cx.tcx(), &substs, &non_null_variant.fields[0]);\n-                let (size, align) = cx.size_and_align_of(nnty);\n-                let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n+                let nnfield = self.type_rep.for_variant(nndiscr as usize).field(cx, 0);\n+                let (size, align) = nnfield.size_and_align(cx);\n+                let non_null_type_metadata = type_metadata(cx, nnfield.ty, self.span);\n \n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n@@ -1264,7 +1258,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Now we can create the metadata of the artificial struct\n                 let artificial_struct_metadata =\n                     composite_type_metadata(cx,\n-                                            nnty,\n+                                            nnfield.ty,\n                                             &non_null_variant_name,\n                                             unique_type_id,\n                                             &[sole_struct_member_description],\n@@ -1274,8 +1268,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = adt.variants[null_variant_index].name;\n+                let null_variant_name = adt.variants[(1 - nndiscr) as usize].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n                                                 null_variant_name);\n@@ -1301,6 +1294,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n+                                          nndiscr as usize,\n                                           &adt.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n@@ -1386,31 +1380,25 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &'tcx layout::Struct,\n+                                   variant_index: usize,\n                                    variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n                                    -> (DICompositeType, MemberDescriptionFactory<'tcx>) {\n-    let substs = match enum_type.sty {\n-        ty::TyAdt(def, s) if def.adt_kind() == AdtKind::Enum => s,\n-        ref t @ _ => bug!(\"{:#?} is not an enum\", t)\n-    };\n-\n-    let maybe_discr_and_signed: Option<(layout::Integer, bool)> = match *cx.layout_of(enum_type) {\n-        layout::CEnum {discr, ..} => Some((discr, true)),\n-        layout::General{discr, ..} => Some((discr, false)),\n-        layout::Univariant { .. }\n-        | layout::RawNullablePointer { .. }\n-        | layout::StructWrappedNullablePointer { .. } => None,\n-        ref l @ _ => bug!(\"This should be unreachable. Type is {:#?} layout is {:#?}\", enum_type, l)\n+    let layout = cx.layout_of(enum_type);\n+    let maybe_discr = match *layout {\n+        layout::General { .. } => Some(layout.field_type(cx, 0)),\n+        _ => None,\n     };\n \n-    let mut field_tys = variant.fields.iter().map(|f| {\n-        monomorphize::field_ty(cx.tcx(), &substs, f)\n+    let layout = layout.for_variant(variant_index);\n+    let mut field_tys = (0..layout.field_count()).map(|i| {\n+        layout.field_type(cx, i)\n     }).collect::<Vec<_>>();\n \n-    if let Some((discr, signed)) = maybe_discr_and_signed {\n-        field_tys.insert(0, discr.to_ty(cx.tcx(), signed));\n+    if let Some(discr) = maybe_discr {\n+        field_tys.insert(0, discr);\n     }\n \n     // Could do some consistency checks here: size, align, field count, discr type\n@@ -1560,7 +1548,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n     };\n \n-    let (enum_type_size, enum_type_align) = cx.size_and_align_of(enum_type);\n+    let (enum_type_size, enum_type_align) = type_rep.size_and_align(cx);\n \n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new(\n@@ -1588,7 +1576,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_metadata,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n-            type_rep: type_rep.layout,\n+            type_rep,\n             discriminant_type_metadata,\n             containing_scope,\n             file_metadata,"}, {"sha": "9152a1febdf738db850d64460100df5867047436", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -19,7 +19,6 @@ use common::*;\n use llvm::{ValueRef};\n use llvm;\n use meth;\n-use monomorphize;\n use rustc::ty::layout::LayoutTyper;\n use rustc::ty::{self, Ty};\n use value::Value;\n@@ -38,7 +37,19 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     }\n     assert!(!info.is_null());\n     match t.sty {\n-        ty::TyAdt(..) | ty::TyTuple(..) => {\n+        ty::TyDynamic(..) => {\n+            // load size/align from vtable\n+            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n+        }\n+        ty::TySlice(_) | ty::TyStr => {\n+            let unit = t.sequence_element_type(bcx.tcx());\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            let (size, align) = bcx.ccx.size_and_align_of(unit);\n+            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n+             C_usize(bcx.ccx, align.abi()))\n+        }\n+        _ => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n@@ -63,14 +74,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let field_ty = match t.sty {\n-                ty::TyAdt(def, substs) => {\n-                    let last_field = def.struct_variant().fields.last().unwrap();\n-                    monomorphize::field_ty(bcx.tcx(), substs, last_field)\n-                },\n-                ty::TyTuple(tys, _) => tys.last().unwrap(),\n-                _ => unreachable!(),\n-            };\n+            let field_ty = layout.field_type(ccx, layout.field_count() - 1);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -113,18 +117,5 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             (size, align)\n         }\n-        ty::TyDynamic(..) => {\n-            // load size/align from vtable\n-            (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n-        }\n-        ty::TySlice(_) | ty::TyStr => {\n-            let unit = t.sequence_element_type(bcx.tcx());\n-            // The info in this case is the length of the str, so the size is that\n-            // times the unit size.\n-            let (size, align) = bcx.ccx.size_and_align_of(unit);\n-            (bcx.mul(info, C_usize(bcx.ccx, size.bytes())),\n-             C_usize(bcx.ccx, align.abi()))\n-        }\n-        _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }\n }"}, {"sha": "2f0e86b8cac5231a6365570e58815de7cc9af160", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -13,8 +13,9 @@\n use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n-use abi::{Abi, FnType};\n+use abi::{self, Abi, FnType};\n use mir::lvalue::{LvalueRef, Alignment};\n+use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n use declare;\n@@ -105,6 +106,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     let name = &*tcx.item_name(def_id);\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n+    let result = LvalueRef::new_sized(llresult, ret_ty, Alignment::AbiAligned);\n \n     let simple = get_simple_intrinsic(ccx, name);\n     let llval = match name {\n@@ -238,9 +240,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n         \"volatile_store\" => {\n             let tp_ty = substs.type_at(0);\n+            let dst = LvalueRef::new_sized(llargs[0], tp_ty, Alignment::AbiAligned);\n             if type_is_fat_ptr(bcx.ccx, tp_ty) {\n-                bcx.volatile_store(llargs[1], get_dataptr(bcx, llargs[0]));\n-                bcx.volatile_store(llargs[2], get_meta(bcx, llargs[0]));\n+                bcx.volatile_store(llargs[1], dst.project_field(bcx, abi::FAT_PTR_ADDR).llval);\n+                bcx.volatile_store(llargs[2], dst.project_field(bcx, abi::FAT_PTR_EXTRA).llval);\n             } else {\n                 let val = if fn_ty.args[1].is_indirect() {\n                     bcx.load(llargs[1], None)\n@@ -250,7 +253,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     }\n                     from_immediate(bcx, llargs[1])\n                 };\n-                let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n+                let ptr = bcx.pointercast(dst.llval, val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n                     llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty).abi() as u32);\n@@ -306,11 +309,14 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             let llfn = bcx.ccx.get_intrinsic(&intrinsic);\n \n                             // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n-                            let result = bcx.extract_value(val, 0);\n-                            let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(ccx));\n-                            bcx.store(result, bcx.struct_gep(llresult, 0), None);\n-                            bcx.store(overflow, bcx.struct_gep(llresult, 1), None);\n+                            let pair = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n+                            let val = bcx.extract_value(pair, 0);\n+                            let overflow = bcx.zext(bcx.extract_value(pair, 1), Type::bool(ccx));\n+\n+                            let dest = result.project_field(bcx, 0);\n+                            bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                            let dest = result.project_field(bcx, 1);\n+                            bcx.store(overflow, dest.llval, dest.alignment.non_abi());\n \n                             return;\n                         },\n@@ -373,7 +379,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"discriminant_value\" => {\n             let val_ty = substs.type_at(0);\n-            let adt_val = LvalueRef::new_sized_ty(llargs[0], val_ty, Alignment::AbiAligned);\n+            let adt_val = LvalueRef::new_sized(llargs[0], val_ty, Alignment::AbiAligned);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     adt_val.trans_get_discr(bcx, ret_ty)\n@@ -446,12 +452,15 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     let ty = substs.type_at(0);\n                     if int_type_width_signed(ty, ccx).is_some() {\n                         let weak = if split[1] == \"cxchgweak\" { llvm::True } else { llvm::False };\n-                        let val = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n+                        let pair = bcx.atomic_cmpxchg(llargs[0], llargs[1], llargs[2], order,\n                             failorder, weak);\n-                        let result = bcx.extract_value(val, 0);\n-                        let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n-                        bcx.store(result, bcx.struct_gep(llresult, 0), None);\n-                        bcx.store(success, bcx.struct_gep(llresult, 1), None);\n+                        let val = bcx.extract_value(pair, 0);\n+                        let success = bcx.zext(bcx.extract_value(pair, 1), Type::bool(bcx.ccx));\n+\n+                        let dest = result.project_field(bcx, 0);\n+                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n+                        let dest = result.project_field(bcx, 1);\n+                        bcx.store(success, dest.llval, dest.alignment.non_abi());\n                         return;\n                     } else {\n                         return invalid_monomorphization(ty);\n@@ -589,10 +598,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = LvalueRef::new_sized_ty(llarg, arg_type, Alignment::AbiAligned);\n+                        let arg = LvalueRef::new_sized(llarg, arg_type, Alignment::AbiAligned);\n                         (0..contents.len()).map(|i| {\n-                            let (ptr, align) = arg.trans_field_ptr(bcx, i);\n-                            bcx.load(ptr, align.to_align())\n+                            arg.project_field(bcx, i).load(bcx).immediate()\n                         }).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n@@ -654,11 +662,9 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     assert!(!flatten);\n \n                     for i in 0..elems.len() {\n-                        let val = bcx.extract_value(val, i);\n-                        let lval = LvalueRef::new_sized_ty(llresult, ret_ty,\n-                                                           Alignment::AbiAligned);\n-                        let (dest, align) = lval.trans_field_ptr(bcx, i);\n-                        bcx.store(val, dest, align.to_align());\n+                        let dest = result.project_field(bcx, i);\n+                        let val = bcx.extract_value(val, i as u64);\n+                        bcx.store(val, dest.llval, dest.alignment.non_abi());\n                     }\n                     return;\n                 }\n@@ -672,7 +678,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n             bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n-            store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n+            OperandRef {\n+                val: OperandValue::Immediate(llval),\n+                ty: ret_ty\n+            }.unpack_if_pair(bcx).store(bcx, result);\n         }\n     }\n }\n@@ -1071,7 +1080,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(vector, i);\n+                let val = const_get_elt(vector, i as u64);\n                 match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);"}, {"sha": "2776125bd82884bb06b1c01497cee65c82c87ade", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -143,7 +143,6 @@ mod partitioning;\n mod symbol_names_test;\n mod time_graph;\n mod trans_item;\n-mod tvec;\n mod type_;\n mod type_of;\n mod value;"}, {"sha": "2289adb01ea6b05c0d030c63a2e678cd0f6bde46", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -21,22 +21,22 @@ use rustc::ty::layout::HasDataLayout;\n use debuginfo;\n \n #[derive(Copy, Clone, Debug)]\n-pub struct VirtualIndex(usize);\n+pub struct VirtualIndex(u64);\n \n pub const DESTRUCTOR: VirtualIndex = VirtualIndex(0);\n pub const SIZE: VirtualIndex = VirtualIndex(1);\n pub const ALIGN: VirtualIndex = VirtualIndex(2);\n \n impl<'a, 'tcx> VirtualIndex {\n     pub fn from_index(index: usize) -> Self {\n-        VirtualIndex(index + 3)\n+        VirtualIndex(index as u64 + 3)\n     }\n \n     pub fn get_fn(self, bcx: &Builder<'a, 'tcx>, llvtable: ValueRef) -> ValueRef {\n         // Load the data pointer from the object.\n         debug!(\"get_fn({:?}, {:?})\", Value(llvtable), self);\n \n-        let ptr = bcx.load_nonnull(bcx.gepi(llvtable, &[self.0]), None);\n+        let ptr = bcx.load_nonnull(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> VirtualIndex {\n         debug!(\"get_int({:?}, {:?})\", Value(llvtable), self);\n \n         let llvtable = bcx.pointercast(llvtable, Type::isize(bcx.ccx).ptr_to());\n-        let ptr = bcx.load(bcx.gepi(llvtable, &[self.0]), None);\n+        let ptr = bcx.load(bcx.inbounds_gep(llvtable, &[C_usize(bcx.ccx, self.0)]), None);\n         // Vtable loads are invariant\n         bcx.set_invariant_load(ptr);\n         ptr"}, {"sha": "cedc78cf9460d3b3cfd96935c1ad9445d2278b6b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 49, "deletions": 67, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -12,19 +12,18 @@ use llvm::{self, ValueRef, BasicBlockRef};\n use rustc::middle::lang_items;\n use rustc::middle::const_val::{ConstEvalErr, ConstInt, ErrKind};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, LayoutTyper};\n+use rustc::ty::layout::LayoutTyper;\n use rustc::traits;\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt;\n use base;\n use callee;\n use builder::Builder;\n use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use meth;\n use monomorphize;\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n use type_::Type;\n \n use syntax::symbol::Symbol;\n@@ -173,13 +172,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bcx.cleanup_ret(cleanup_pad, None);\n                 } else {\n                     let slot = self.get_personality_slot(&bcx);\n-\n-                    let (lp0ptr, align) = slot.trans_field_ptr(&bcx, 0);\n-                    let lp0 = bcx.load(lp0ptr, align.to_align());\n-\n-                    let (lp1ptr, align) = slot.trans_field_ptr(&bcx, 1);\n-                    let lp1 = bcx.load(lp1ptr, align.to_align());\n-\n+                    let lp0 = slot.project_field(&bcx, 0).load(&bcx).immediate();\n+                    let lp1 = slot.project_field(&bcx, 1).load(&bcx).immediate();\n                     slot.storage_dead(&bcx);\n \n                     if !bcx.sess().target.target.options.custom_unwind_resume {\n@@ -240,9 +234,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\", None);\n-                            self.store_operand(&bcx, llscratch, None, op);\n-                            llscratch\n+                            let scratch = LvalueRef::alloca(&bcx, ret.layout.ty, \"ret\");\n+                            op.store(&bcx, scratch);\n+                            scratch.llval\n                         }\n                         Ref(llval, align) => {\n                             assert_eq!(align, Alignment::AbiAligned,\n@@ -257,7 +251,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n                     if let Ref(llval, align) = op.val {\n-                        base::load_ty(&bcx, llval, align, op.ty)\n+                        bcx.load(llval, align.non_abi())\n                     } else {\n                         op.pack_if_pair(&bcx).immediate()\n                     }\n@@ -558,8 +552,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         ReturnDest::Nothing => {\n                             (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n                         }\n-                        ReturnDest::IndirectOperand(dst, _) => (dst.llval, &llargs[..]),\n-                        ReturnDest::Store(dst) => (dst, &llargs[..]),\n+                        ReturnDest::IndirectOperand(dst, _) |\n+                        ReturnDest::Store(dst) => (dst.llval, &llargs[..]),\n                         ReturnDest::DirectOperand(_) =>\n                             bug!(\"Cannot use direct operand with an intrinsic call\")\n                     };\n@@ -650,36 +644,37 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n-                    self.store_operand(bcx, llscratch, None, op);\n-                    (llscratch, Alignment::AbiAligned, true)\n+                    let scratch = LvalueRef::alloca(bcx, arg.layout.ty, \"arg\");\n+                    op.store(bcx, scratch);\n+                    (scratch.llval, Alignment::AbiAligned, true)\n                 } else {\n                     (op.pack_if_pair(bcx).immediate(), Alignment::AbiAligned, false)\n                 }\n             }\n-            Ref(llval, align @ Alignment::Packed) if arg.is_indirect() => {\n+            Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n                 // `foo(packed.large_field)`. We can't pass the (unaligned) field directly. I\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\", None);\n-                base::memcpy_ty(bcx, llscratch, llval, op.ty, align.to_align());\n-                (llscratch, Alignment::AbiAligned, true)\n+                let scratch = LvalueRef::alloca(bcx, arg.layout.ty, \"arg\");\n+                base::memcpy_ty(bcx, scratch.llval, llval, op.ty, align.non_abi());\n+                (scratch.llval, Alignment::AbiAligned, true)\n             }\n             Ref(llval, align) => (llval, align, true)\n         };\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n             if arg.layout.ty == bcx.tcx().types.bool {\n-                // We store bools as i8 so we need to truncate to i1.\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n-                llval = bcx.trunc(llval, Type::i1(bcx.ccx));\n+                // We store bools as i8 so we need to truncate to i1.\n+                llval = base::to_immediate(bcx, llval, arg.layout.ty);\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n-                                 align.min_with(Some(arg.layout.align(bcx.ccx))));\n+                                 (align | Alignment::Packed(arg.layout.align(bcx.ccx)))\n+                                    .non_abi());\n             } else {\n-                llval = bcx.load(llval, align.to_align());\n+                llval = bcx.load(llval, align.non_abi());\n             }\n         }\n \n@@ -705,38 +700,28 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval, align) => {\n+                let tuple_ptr = LvalueRef::new_sized(llval, tuple.ty, align);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty, align);\n-                    let (ptr, align) = ptr.trans_field_ptr(bcx, n);\n-                    let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-                        let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, align, ty);\n-                        Pair(lldata, llextra)\n+                    let field_ptr = tuple_ptr.project_field(bcx, n);\n+                    let op = if common::type_is_fat_ptr(bcx.ccx, ty) {\n+                        field_ptr.load(bcx)\n                     } else {\n                         // trans_argument will load this if it needs to\n-                        Ref(ptr, align)\n-                    };\n-                    let op = OperandRef {\n-                        val,\n-                        ty,\n+                        OperandRef {\n+                            val: Ref(field_ptr.llval, field_ptr.alignment),\n+                            ty\n+                        }\n                     };\n                     self.trans_argument(bcx, op, llargs, fn_ty, next_idx, llfn, def);\n                 }\n \n             }\n             Immediate(llval) => {\n-                let l = bcx.ccx.layout_of(tuple.ty);\n-                let v = if let layout::Univariant { ref variant, .. } = *l {\n-                    variant\n-                } else {\n-                    bug!(\"Not a tuple.\");\n-                };\n+                let layout = bcx.ccx.layout_of(tuple.ty);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = bcx.extract_value(\n-                        llval, adt::struct_llfields_index(v, n));\n+                    let mut elem = bcx.extract_value(llval, layout.llvm_field_index(n));\n                     // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n-                    }\n+                    elem = base::to_immediate(bcx, elem, ty);\n                     // If the tuple is immediate, the elements are as well\n                     let op = OperandRef {\n                         val: Immediate(elem),\n@@ -748,11 +733,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Pair(a, b) => {\n                 let elems = [a, b];\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let mut elem = elems[n];\n-                    // Truncate bools to i1, if needed\n-                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx) {\n-                        elem = bcx.trunc(elem, Type::i1(bcx.ccx));\n-                    }\n+                    let elem = base::to_immediate(bcx, elems[n], ty);\n                     // Pair is always made up of immediates\n                     let op = OperandRef {\n                         val: Immediate(elem),\n@@ -809,10 +790,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let slot = self.get_personality_slot(&bcx);\n         slot.storage_live(&bcx);\n-        self.store_operand(&bcx, slot.llval, None, OperandRef {\n+        OperandRef {\n             val: Pair(bcx.extract_value(lp, 0), bcx.extract_value(lp, 1)),\n             ty: slot.ty.to_ty(ccx.tcx())\n-        });\n+        }.store(&bcx, slot);\n \n         bcx.br(target_bb);\n         bcx.llbb()\n@@ -888,7 +869,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     llargs.push(dest.llval);\n                     ReturnDest::Nothing\n                 },\n-                Alignment::Packed => {\n+                Alignment::Packed(_) => {\n                     // Currently, MIR code generation does not create calls\n                     // that store directly to fields of packed structs (in\n                     // fact, the calls it creates write only to temps),\n@@ -899,7 +880,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n         } else {\n-            ReturnDest::Store(dest.llval)\n+            ReturnDest::Store(dest)\n         }\n     }\n \n@@ -908,14 +889,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                        dst: &mir::Lvalue<'tcx>) {\n         if let mir::Lvalue::Local(index) = *dst {\n             match self.locals[index] {\n-                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, &lvalue),\n+                LocalRef::Lvalue(lvalue) => self.trans_transmute_into(bcx, src, lvalue),\n                 LocalRef::Operand(None) => {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(dst);\n                     assert!(!lvalue_ty.has_erasable_regions());\n                     let lvalue = LvalueRef::alloca(bcx, lvalue_ty, \"transmute_temp\");\n                     lvalue.storage_live(bcx);\n-                    self.trans_transmute_into(bcx, src, &lvalue);\n-                    let op = self.trans_load(bcx, lvalue.llval, lvalue.alignment, lvalue_ty);\n+                    self.trans_transmute_into(bcx, src, lvalue);\n+                    let op = lvalue.load(bcx);\n                     lvalue.storage_dead(bcx);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n                 }\n@@ -927,20 +908,21 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         } else {\n             let dst = self.trans_lvalue(bcx, dst);\n-            self.trans_transmute_into(bcx, src, &dst);\n+            self.trans_transmute_into(bcx, src, dst);\n         }\n     }\n \n     fn trans_transmute_into(&mut self, bcx: &Builder<'a, 'tcx>,\n                             src: &mir::Operand<'tcx>,\n-                            dst: &LvalueRef<'tcx>) {\n+                            dst: LvalueRef<'tcx>) {\n         let val = self.trans_operand(bcx, src);\n         let llty = type_of::type_of(bcx.ccx, val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());\n         let align = bcx.ccx.align_of(in_type).min(bcx.ccx.align_of(out_type));\n-        self.store_operand(bcx, cast_ptr, Some(align), val);\n+        val.store(bcx,\n+            LvalueRef::new_sized(cast_ptr, val.ty, Alignment::Packed(align)));\n     }\n \n \n@@ -956,7 +938,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Nothing => (),\n             Store(dst) => ret_ty.store(bcx, op.immediate(), dst),\n             IndirectOperand(tmp, index) => {\n-                let op = self.trans_load(bcx, tmp.llval, Alignment::AbiAligned, op.ty);\n+                let op = tmp.load(bcx);\n                 tmp.storage_dead(bcx);\n                 self.locals[index] = LocalRef::Operand(Some(op));\n             }\n@@ -965,8 +947,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let op = if ret_ty.cast.is_some() {\n                     let tmp = LvalueRef::alloca(bcx, op.ty, \"tmp_ret\");\n                     tmp.storage_live(bcx);\n-                    ret_ty.store(bcx, op.immediate(), tmp.llval);\n-                    let op = self.trans_load(bcx, tmp.llval, tmp.alignment, op.ty);\n+                    ret_ty.store(bcx, op.immediate(), tmp);\n+                    let op = tmp.load(bcx);\n                     tmp.storage_dead(bcx);\n                     op\n                 } else {\n@@ -982,7 +964,7 @@ enum ReturnDest<'tcx> {\n     // Do nothing, the return value is indirect or ignored\n     Nothing,\n     // Store the return value to the pointer\n-    Store(ValueRef),\n+    Store(LvalueRef<'tcx>),\n     // Stores an indirect return value to an operand local lvalue\n     IndirectOperand(LvalueRef<'tcx>, mir::Local),\n     // Stores a direct return value to an operand local lvalue"}, {"sha": "c2bc0684c6278c85925f620a05936311a3ddfac2", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -32,7 +32,7 @@ use common::{C_array, C_bool, C_bytes, C_int, C_uint, C_big_integral, C_u32, C_u\n use common::{C_null, C_struct, C_str_slice, C_undef, C_usize, C_vector};\n use common::const_to_opt_u128;\n use consts;\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n use type_::Type;\n use value::Value;\n \n@@ -117,14 +117,7 @@ impl<'a, 'tcx> Const<'tcx> {\n     }\n \n     fn get_field(&self, ccx: &CrateContext<'a, 'tcx>, i: usize) -> ValueRef {\n-        let layout = ccx.layout_of(self.ty);\n-        let ix = if let layout::Univariant { ref variant, .. } = *layout {\n-            adt::struct_llfields_index(variant, i)\n-        } else {\n-            i\n-        };\n-\n-        const_get_elt(self.llval, ix)\n+        const_get_elt(self.llval, ccx.layout_of(self.ty).llvm_field_index(i))\n     }\n \n     fn get_pair(&self, ccx: &CrateContext<'a, 'tcx>) -> (ValueRef, ValueRef) {\n@@ -494,7 +487,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n                         let llelem = if iv < len as u128 {\n-                            const_get_elt(base.llval, iv as usize)\n+                            const_get_elt(base.llval, iv as u64)\n                         } else {\n                             C_undef(type_of::type_of(self.ccx, projected_ty))\n                         };"}, {"sha": "168f2e8c0567960470315e58f9cb800516c6f59f", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 231, "deletions": 121, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -10,28 +10,31 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, LayoutTyper};\n+use rustc::ty::layout::{self, Align, Layout, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n+use abi;\n use adt;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize, C_u8, C_i32, C_int, C_null, val_ty};\n+use common::{self, CrateContext, C_usize, C_u8, C_u32, C_int, C_null, val_ty};\n use consts;\n-use type_of;\n+use type_of::{self, LayoutLlvmExt};\n use type_::Type;\n use value::Value;\n use glue;\n \n+use std::iter;\n use std::ptr;\n use std::ops;\n \n use super::{MirContext, LocalRef};\n+use super::operand::{OperandRef, OperandValue};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum Alignment {\n-    Packed,\n+    Packed(Align),\n     AbiAligned,\n }\n \n@@ -40,31 +43,41 @@ impl ops::BitOr for Alignment {\n \n     fn bitor(self, rhs: Self) -> Self {\n         match (self, rhs) {\n-            (Alignment::Packed, _) => Alignment::Packed,\n-            (Alignment::AbiAligned, a) => a,\n+            (Alignment::Packed(a), Alignment::Packed(b)) => {\n+                Alignment::Packed(a.min(b))\n+            }\n+            (Alignment::Packed(x), _) | (_, Alignment::Packed(x)) => {\n+                Alignment::Packed(x)\n+            }\n+            (Alignment::AbiAligned, Alignment::AbiAligned) => {\n+                Alignment::AbiAligned\n+            }\n         }\n     }\n }\n \n-impl Alignment {\n-    pub fn from_packed(packed: bool) -> Self {\n+impl<'a> From<&'a Layout> for Alignment {\n+    fn from(layout: &Layout) -> Self {\n+        let (packed, align) = match *layout {\n+            Layout::UntaggedUnion { ref variants } => (variants.packed, variants.align),\n+            Layout::Univariant { ref variant, .. } => (variant.packed, variant.align),\n+            _ => return Alignment::AbiAligned\n+        };\n         if packed {\n-            Alignment::Packed\n+            Alignment::Packed(align)\n         } else {\n             Alignment::AbiAligned\n         }\n     }\n+}\n \n-    pub fn to_align(self) -> Option<Align> {\n+impl Alignment {\n+    pub fn non_abi(self) -> Option<Align> {\n         match self {\n-            Alignment::Packed => Some(Align::from_bytes(1, 1).unwrap()),\n+            Alignment::Packed(x) => Some(x),\n             Alignment::AbiAligned => None,\n         }\n     }\n-\n-    pub fn min_with(self, align: Option<Align>) -> Option<Align> {\n-        self.to_align().or(align)\n-    }\n }\n \n fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n@@ -87,21 +100,16 @@ pub struct LvalueRef<'tcx> {\n }\n \n impl<'a, 'tcx> LvalueRef<'tcx> {\n-    pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>,\n-                     alignment: Alignment) -> LvalueRef<'tcx> {\n-        LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty, alignment: alignment }\n-    }\n-\n-    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>, alignment: Alignment) -> LvalueRef<'tcx> {\n-        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty), alignment)\n+    pub fn new_sized(llval: ValueRef, ty: Ty<'tcx>, alignment: Alignment) -> LvalueRef<'tcx> {\n+        LvalueRef { llval, llextra: ptr::null_mut(), ty: LvalueTy::from_ty(ty), alignment }\n     }\n \n     pub fn alloca(bcx: &Builder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, ty);\n         let tmp = bcx.alloca(\n             type_of::type_of(bcx.ccx, ty), name, bcx.ccx.over_align_of(ty));\n         assert!(!ty.has_param_types());\n-        Self::new_sized_ty(tmp, ty, Alignment::AbiAligned)\n+        Self::new_sized(tmp, ty, Alignment::AbiAligned)\n     }\n \n     pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n@@ -122,8 +130,74 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n+    pub fn load(&self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n+        debug!(\"LvalueRef::load: {:?}\", self);\n+\n+        assert!(!self.has_extra());\n+\n+        let ty = self.ty.to_ty(bcx.tcx());\n+\n+        if common::type_is_zero_size(bcx.ccx, ty) {\n+            return OperandRef::new_zst(bcx.ccx, ty);\n+        }\n+\n+        let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n+            let data = self.project_field(bcx, abi::FAT_PTR_ADDR);\n+            let lldata = if ty.is_region_ptr() || ty.is_box() {\n+                bcx.load_nonnull(data.llval, data.alignment.non_abi())\n+            } else {\n+                bcx.load(data.llval, data.alignment.non_abi())\n+            };\n+\n+            let extra = self.project_field(bcx, abi::FAT_PTR_EXTRA);\n+            let meta_ty = val_ty(extra.llval);\n+            // If the 'extra' field is a pointer, it's a vtable, so use load_nonnull\n+            // instead\n+            let llextra = if meta_ty.element_type().kind() == llvm::TypeKind::Pointer {\n+                bcx.load_nonnull(extra.llval, extra.alignment.non_abi())\n+            } else {\n+                bcx.load(extra.llval, extra.alignment.non_abi())\n+            };\n+\n+            OperandValue::Pair(lldata, llextra)\n+        } else if common::type_is_imm_pair(bcx.ccx, ty) {\n+            OperandValue::Pair(\n+                self.project_field(bcx, 0).load(bcx).pack_if_pair(bcx).immediate(),\n+                self.project_field(bcx, 1).load(bcx).pack_if_pair(bcx).immediate())\n+        } else if common::type_is_immediate(bcx.ccx, ty) {\n+            let mut const_llval = ptr::null_mut();\n+            unsafe {\n+                let global = llvm::LLVMIsAGlobalVariable(self.llval);\n+                if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                    const_llval = llvm::LLVMGetInitializer(global);\n+                }\n+            }\n+\n+            let llval = if !const_llval.is_null() {\n+                const_llval\n+            } else if ty.is_bool() {\n+                bcx.load_range_assert(self.llval, 0, 2, llvm::False,\n+                    self.alignment.non_abi())\n+            } else if ty.is_char() {\n+                // a char is a Unicode codepoint, and so takes values from 0\n+                // to 0x10FFFF inclusive only.\n+                bcx.load_range_assert(self.llval, 0, 0x10FFFF + 1, llvm::False,\n+                    self.alignment.non_abi())\n+            } else if ty.is_region_ptr() || ty.is_box() || ty.is_fn() {\n+                bcx.load_nonnull(self.llval, self.alignment.non_abi())\n+            } else {\n+                bcx.load(self.llval, self.alignment.non_abi())\n+            };\n+            OperandValue::Immediate(base::to_immediate(bcx, llval, ty))\n+        } else {\n+            OperandValue::Ref(self.llval, self.alignment)\n+        };\n+\n+        OperandRef { val, ty }\n+    }\n+\n     /// Access a field, at a point when the value's case is known.\n-    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> (ValueRef, Alignment) {\n+    pub fn project_field(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> LvalueRef<'tcx> {\n         let ccx = bcx.ccx;\n         let mut l = ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n         match self.ty {\n@@ -132,16 +206,16 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 l = l.for_variant(variant_index)\n             }\n         }\n-        let fty = l.field(ccx, ix).ty;\n-        let mut ix = ix;\n-        let st = match *l {\n-            layout::Vector { .. } => {\n-                return (bcx.struct_gep(self.llval, ix), self.alignment);\n-            }\n-            layout::UntaggedUnion { ref variants } => {\n+        let fty = l.field_type(ccx, ix);\n+\n+        let alignment = self.alignment | Alignment::from(&*l);\n+\n+        // Handle all the non-aggregate cases first.\n+        match *l {\n+            layout::UntaggedUnion { .. } => {\n                 let ty = type_of::in_memory_type_of(ccx, fty);\n-                return (bcx.pointercast(self.llval, ty.ptr_to()),\n-                    self.alignment | Alignment::from_packed(variants.packed));\n+                return LvalueRef::new_sized(\n+                    bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n             }\n             layout::RawNullablePointer { nndiscr, .. } |\n             layout::StructWrappedNullablePointer { nndiscr,  .. }\n@@ -150,58 +224,66 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 // (e.d., Result of Either with (), as one side.)\n                 let ty = type_of::type_of(ccx, fty);\n                 assert_eq!(ccx.size_of(fty).bytes(), 0);\n-                return (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed);\n+                return LvalueRef::new_sized(\n+                    bcx.pointercast(self.llval, ty.ptr_to()), fty,\n+                    Alignment::Packed(Align::from_bytes(1, 1).unwrap()));\n             }\n             layout::RawNullablePointer { .. } => {\n                 let ty = type_of::type_of(ccx, fty);\n-                return (bcx.pointercast(self.llval, ty.ptr_to()), self.alignment);\n+                return LvalueRef::new_sized(\n+                    bcx.pointercast(self.llval, ty.ptr_to()), fty, alignment);\n             }\n-            layout::Univariant { ref variant, .. } => variant,\n-            layout::StructWrappedNullablePointer { ref nonnull, .. } => nonnull,\n-            layout::General { ref variants, .. } => {\n+            _ => {}\n+        }\n+\n+        // Adjust the index to account for enum discriminants in variants.\n+        let mut ix = ix;\n+        if let layout::General { .. } = *l {\n+            if l.variant_index.is_some() {\n                 ix += 1;\n-                &variants[l.variant_index.unwrap()]\n             }\n-            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", l.ty, l)\n-        };\n+        }\n \n-        let alignment = self.alignment | Alignment::from_packed(st.packed);\n+        let simple = || {\n+            LvalueRef {\n+                llval: bcx.struct_gep(self.llval, l.llvm_field_index(ix)),\n+                llextra: if !ccx.shared().type_has_metadata(fty) {\n+                    ptr::null_mut()\n+                } else {\n+                    self.llextra\n+                },\n+                ty: LvalueTy::from_ty(fty),\n+                alignment,\n+            }\n+        };\n \n-        let ptr_val = if let layout::General { discr, .. } = *l {\n-            let variant_ty = Type::struct_(ccx,\n-                &adt::struct_llfields(ccx, l.ty, l.variant_index.unwrap(), st,\n-                                      Some(discr.to_ty(bcx.tcx(), false))), st.packed);\n-            bcx.pointercast(self.llval, variant_ty.ptr_to())\n-        } else {\n-            self.llval\n+        // Check whether the variant being used is packed, if applicable.\n+        let is_packed = match (&*l, l.variant_index) {\n+            (&layout::Univariant { ref variant, .. }, _) => variant.packed,\n+            (&layout::StructWrappedNullablePointer { ref nonnull, .. }, _) => nonnull.packed,\n+            (&layout::General { ref variants, .. }, Some(v)) => variants[v].packed,\n+            _ => return simple()\n         };\n \n         // Simple case - we can just GEP the field\n-        //   * First field - Always aligned properly\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n-        if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-            ccx.shared().type_is_sized(fty)\n-        {\n-            return (bcx.struct_gep(\n-                    ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n+        if is_packed || ccx.shared().type_is_sized(fty) {\n+            return simple();\n         }\n \n         // If the type of the last field is [T], str or a foreign type, then we don't need to do\n         // any adjusments\n         match fty.sty {\n-            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => {\n-                return (bcx.struct_gep(\n-                        ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n-            }\n+            ty::TySlice(..) | ty::TyStr | ty::TyForeign(..) => return simple(),\n             _ => ()\n         }\n \n         // There's no metadata available, log the case and just do the GEP.\n         if !self.has_extra() {\n             debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-                ix, Value(ptr_val));\n-            return (bcx.struct_gep(ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n+                ix, Value(self.llval));\n+            return simple();\n         }\n \n         // We need to get the pointer manually now.\n@@ -222,7 +304,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let meta = self.llextra;\n \n \n-        let offset = st.offsets[ix].bytes();\n+        let offset = l.field_offset(ccx, ix).bytes();\n         let unaligned_offset = C_usize(ccx, offset);\n \n         // Get the alignment of the field\n@@ -241,21 +323,29 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n         // Cast and adjust pointer\n-        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(ccx));\n+        let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n         let ll_fty = type_of::in_memory_type_of(ccx, fty);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-        (bcx.pointercast(byte_ptr, ll_fty.ptr_to()), alignment)\n+\n+        LvalueRef {\n+            llval: bcx.pointercast(byte_ptr, ll_fty.ptr_to()),\n+            llextra: self.llextra,\n+            ty: LvalueTy::from_ty(fty),\n+            alignment,\n+        }\n     }\n \n     // Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n     fn gepi_struct_llfields_path(self, bcx: &Builder, discrfield: &layout::FieldPath) -> ValueRef {\n-        let path = discrfield.iter().map(|&i| {\n-            adt::memory_index_to_gep(i as usize)\n-        }).collect::<Vec<_>>();\n-        bcx.gepi(self.llval, &path)\n+        let path = iter::once(C_u32(bcx.ccx, 0)).chain(discrfield[1..].iter().map(|&i| {\n+            let i = adt::memory_index_to_gep(i as u64);\n+            assert_eq!(i as u32 as u64, i);\n+            C_u32(bcx.ccx, i as u32)\n+        })).collect::<Vec<_>>();\n+        bcx.inbounds_gep(self.llval, &path)\n     }\n \n     /// Helper for cases where the discriminant is simply loaded.\n@@ -274,12 +364,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             // rejected by the LLVM verifier (it would mean either an\n             // empty set, which is impossible, or the entire range of the\n             // type, which is pointless).\n-            bcx.load(ptr, self.alignment.to_align())\n+            bcx.load(ptr, self.alignment.non_abi())\n         } else {\n             // llvm::ConstantRange can deal with ranges that wrap around,\n             // so an overflow on (max + 1) is fine.\n             bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ llvm::True,\n-                                  self.alignment.to_align())\n+                                  self.alignment.non_abi())\n         }\n     }\n \n@@ -292,18 +382,18 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 self.load_discr(bcx, discr, self.llval, min, max)\n             }\n             layout::General { discr, ref variants, .. } => {\n-                let ptr = bcx.struct_gep(self.llval, 0);\n-                self.load_discr(bcx, discr, ptr, 0, variants.len() as u64 - 1)\n+                let ptr = self.project_field(bcx, 0);\n+                self.load_discr(bcx, discr, ptr.llval, 0, variants.len() as u64 - 1)\n             }\n             layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n             layout::RawNullablePointer { nndiscr, .. } => {\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n-                let discr = bcx.load(self.llval, self.alignment.to_align());\n+                let discr = bcx.load(self.llval, self.alignment.non_abi());\n                 bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n             }\n             layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n-                let llptr = bcx.load(llptrptr, self.alignment.to_align());\n+                let llptr = bcx.load(llptrptr, self.alignment.non_abi());\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n                 bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n             },\n@@ -324,11 +414,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::CEnum { discr, min, max, .. } => {\n                 adt::assert_discr_in_range(min, max, to);\n                 bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                    self.llval, self.alignment.to_align());\n+                    self.llval, self.alignment.non_abi());\n             }\n             layout::General { discr, .. } => {\n+                let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                    bcx.struct_gep(self.llval, 0), self.alignment.to_align());\n+                    ptr.llval, ptr.alignment.non_abi());\n             }\n             layout::Univariant { .. }\n             | layout::UntaggedUnion { .. }\n@@ -338,7 +429,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             layout::RawNullablePointer { nndiscr, .. } => {\n                 if to != nndiscr {\n                     let llptrty = val_ty(self.llval).element_type();\n-                    bcx.store(C_null(llptrty), self.llval, self.alignment.to_align());\n+                    bcx.store(C_null(llptrty), self.llval, self.alignment.non_abi());\n                 }\n             }\n             layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n@@ -350,26 +441,60 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                         let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n                         let fill_byte = C_u8(bcx.ccx, 0);\n                         let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n-                        let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n+                        let align = C_u32(bcx.ccx, nonnull.align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n                     } else {\n                         let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n                         let llptrty = val_ty(llptrptr).element_type();\n-                        bcx.store(C_null(llptrty), llptrptr, self.alignment.to_align());\n+                        bcx.store(C_null(llptrty), llptrptr, self.alignment.non_abi());\n                     }\n                 }\n             }\n             _ => bug!(\"Cannot handle {} represented as {:#?}\", l.ty, l)\n         }\n     }\n \n-    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n-        if let ty::TySlice(_) = self.ty.to_ty(bcx.tcx()).sty {\n-            // Slices already point to the array element type.\n-            bcx.inbounds_gep(self.llval, &[llindex])\n+    pub fn project_index(&self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef)\n+                         -> LvalueRef<'tcx> {\n+        let ty = self.ty.to_ty(bcx.tcx());\n+        let (ptr, elem_ty) = match ty.sty {\n+            ty::TySlice(ty) => {\n+                // Slices already point to the array element type.\n+                (bcx.inbounds_gep(self.llval, &[llindex]), ty)\n+            }\n+            ty::TyArray(ty, _) => {\n+                let zero = common::C_usize(bcx.ccx, 0);\n+                (bcx.inbounds_gep(self.llval, &[zero, llindex]), ty)\n+            }\n+            _ => bug!(\"unexpected type `{}` in LvalueRef::project_index\", ty)\n+        };\n+        LvalueRef::new_sized(ptr, elem_ty, self.alignment)\n+    }\n+\n+    pub fn project_downcast(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize)\n+                            -> LvalueRef<'tcx> {\n+        let ty = self.ty.to_ty(bcx.tcx());\n+        if let ty::TyAdt(adt_def, substs) = ty.sty {\n+            let mut downcast = *self;\n+            downcast.ty = LvalueTy::Downcast {\n+                adt_def,\n+                substs,\n+                variant_index,\n+            };\n+\n+            // If this is an enum, cast to the appropriate variant struct type.\n+            let layout = bcx.ccx.layout_of(ty).for_variant(variant_index);\n+            if let layout::General { discr, ref variants, .. } = *layout {\n+                let st = &variants[variant_index];\n+                let variant_ty = Type::struct_(bcx.ccx,\n+                    &adt::struct_llfields(bcx.ccx, layout, st,\n+                        Some(discr.to_ty(bcx.tcx(), false))), st.packed);\n+                downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n+            }\n+\n+            downcast\n         } else {\n-            let zero = common::C_usize(bcx.ccx, 0);\n-            bcx.inbounds_gep(self.llval, &[zero, llindex])\n+            bug!(\"unexpected type `{}` in LvalueRef::project_downcast\", ty)\n         }\n     }\n \n@@ -407,7 +532,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Lvalue::Local(_) => bug!(), // handled above\n             mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n-                                     LvalueTy::from_ty(self.monomorphize(&ty)),\n+                                     self.monomorphize(&ty),\n                                      Alignment::AbiAligned)\n             },\n             mir::Lvalue::Projection(box mir::Projection {\n@@ -419,73 +544,58 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n             mir::Lvalue::Projection(ref projection) => {\n                 let tr_base = self.trans_lvalue(bcx, &projection.base);\n-                let projected_ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n-                let projected_ty = self.monomorphize(&projected_ty);\n-                let align = tr_base.alignment;\n \n-                let ((llprojected, align), llextra) = match projection.elem {\n+                match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let has_metadata = self.ccx.shared()\n-                            .type_has_metadata(projected_ty.to_ty(tcx));\n-                        let llextra = if !has_metadata {\n-                            ptr::null_mut()\n-                        } else {\n-                            tr_base.llextra\n-                        };\n-                        (tr_base.trans_field_ptr(bcx, field.index()), llextra)\n+                        tr_base.project_field(bcx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Consume(mir::Lvalue::Local(index));\n                         let index = self.trans_operand(bcx, index);\n                         let llindex = index.immediate();\n-                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n+                        tr_base.project_index(bcx, llindex)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bcx.ccx, offset as u64);\n-                        ((tr_base.project_index(bcx, lloffset), align), ptr::null_mut())\n+                        tr_base.project_index(bcx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_usize(bcx.ccx, offset as u64);\n                         let lllen = tr_base.len(bcx.ccx);\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        ((tr_base.project_index(bcx, llindex), align), ptr::null_mut())\n+                        tr_base.project_index(bcx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n-                        let llbase = tr_base.project_index(bcx, C_usize(bcx.ccx, from as u64));\n+                        let mut subslice = tr_base.project_index(bcx,\n+                            C_usize(bcx.ccx, from as u64));\n+                        subslice.ty = tr_base.ty.projection_ty(tcx, &projection.elem);\n+                        subslice.ty = self.monomorphize(&subslice.ty);\n \n-                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n-                        match base_ty.sty {\n+                        match subslice.ty.to_ty(tcx).sty {\n                             ty::TyArray(..) => {\n                                 // must cast the lvalue pointer type to the new\n                                 // array type (*[%_; new_len]).\n-                                let base_ty = self.monomorphized_lvalue_ty(lvalue);\n-                                let llbasety = type_of::type_of(bcx.ccx, base_ty).ptr_to();\n-                                let llbase = bcx.pointercast(llbase, llbasety);\n-                                ((llbase, align), ptr::null_mut())\n+                                subslice.llval = bcx.pointercast(subslice.llval,\n+                                    type_of::type_of(bcx.ccx, subslice.ty.to_ty(tcx)).ptr_to())\n                             }\n                             ty::TySlice(..) => {\n-                                assert!(tr_base.llextra != ptr::null_mut());\n-                                let lllen = bcx.sub(tr_base.llextra,\n-                                                    C_usize(bcx.ccx, (from as u64)+(to as u64)));\n-                                ((llbase, align), lllen)\n+                                assert!(tr_base.has_extra());\n+                                subslice.llextra = bcx.sub(tr_base.llextra,\n+                                    C_usize(bcx.ccx, (from as u64) + (to as u64)));\n                             }\n-                            _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n+                            _ => bug!(\"unexpected type {:?} in Subslice\", subslice.ty)\n                         }\n+\n+                        subslice\n                     }\n-                    mir::ProjectionElem::Downcast(..) => {\n-                        ((tr_base.llval, align), tr_base.llextra)\n+                    mir::ProjectionElem::Downcast(_, v) => {\n+                        tr_base.project_downcast(bcx, v)\n                     }\n-                };\n-                LvalueRef {\n-                    llval: llprojected,\n-                    llextra,\n-                    ty: projected_ty,\n-                    alignment: align,\n                 }\n             }\n         };"}, {"sha": "c82a9317a021e2e1c01d769204c0d14f91fea846", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -14,7 +14,6 @@ use llvm::debuginfo::DIScope;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir::{self, Mir};\n-use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n use rustc::session::config::FullDebugInfo;\n@@ -23,7 +22,7 @@ use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::{ArgAttribute, FnType};\n+use abi::{self, ArgAttribute, FnType};\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n@@ -281,8 +280,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n-                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty),\n-                                                          Alignment::AbiAligned))\n+                    LocalRef::Lvalue(LvalueRef::new_sized(llretptr, ty, Alignment::AbiAligned))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n                     assert!(!ty.has_erasable_regions());\n@@ -404,16 +402,18 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n             let lvalue = LvalueRef::alloca(bcx, arg_ty, &name);\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                let (dst, _) = lvalue.trans_field_ptr(bcx, i);\n+                let dst = lvalue.project_field(bcx, i);\n                 let arg = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 if common::type_is_fat_ptr(bcx.ccx, tupled_arg_ty) {\n                     // We pass fat pointers as two words, but inside the tuple\n                     // they are the two sub-fields of a single aggregate field.\n                     let meta = &mircx.fn_ty.args[idx];\n                     idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, dst));\n+                    arg.store_fn_arg(bcx, &mut llarg_idx,\n+                        dst.project_field(bcx, abi::FAT_PTR_ADDR));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx,\n+                        dst.project_field(bcx, abi::FAT_PTR_EXTRA));\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n@@ -441,7 +441,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() {\n+        let lvalue = if arg.is_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up\n             // FIXME: lifetimes\n@@ -451,7 +451,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            llarg\n+            LvalueRef::new_sized(llarg, arg_ty, Alignment::AbiAligned)\n         } else if !lvalue_locals.contains(local.index()) &&\n                   arg.cast.is_none() && arg_scope.is_none() {\n             if arg.is_ignore() {\n@@ -502,21 +502,21 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = LvalueRef::alloca(bcx, arg_ty, &name);\n+            let tmp = LvalueRef::alloca(bcx, arg_ty, &name);\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n                 // so make an alloca to store them in.\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n-                arg.store_fn_arg(bcx, &mut llarg_idx, base::get_dataptr(bcx, lltemp.llval));\n-                meta.store_fn_arg(bcx, &mut llarg_idx, base::get_meta(bcx, lltemp.llval));\n+                arg.store_fn_arg(bcx, &mut llarg_idx, tmp.project_field(bcx, abi::FAT_PTR_ADDR));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, tmp.project_field(bcx, abi::FAT_PTR_EXTRA));\n             } else  {\n                 // otherwise, arg is passed by value, so make a\n                 // temporary and store it there\n-                arg.store_fn_arg(bcx, &mut llarg_idx, lltemp.llval);\n+                arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n             }\n-            lltemp.llval\n+            tmp\n         };\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n@@ -527,11 +527,11 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let variable_access = if arg.is_indirect() &&\n                     !arg.attrs.contains(ArgAttribute::ByVal) {\n                     VariableAccess::IndirectVariable {\n-                        alloca: llval,\n+                        alloca: lvalue.llval,\n                         address_operations: &deref_op,\n                     }\n                 } else {\n-                    VariableAccess::DirectVariable { alloca: llval }\n+                    VariableAccess::DirectVariable { alloca: lvalue.llval }\n                 };\n \n                 declare_local(\n@@ -567,11 +567,12 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\", None);\n-                bcx.store(llval, alloc, None);\n-                alloc\n+                let alloc_ty = tcx.mk_mut_ptr(arg_ty);\n+                let alloc = LvalueRef::alloca(bcx, alloc_ty, \"__debuginfo_env_ptr\");\n+                bcx.store(lvalue.llval, alloc.llval, None);\n+                alloc.llval\n             } else {\n-                llval\n+                lvalue.llval\n             };\n \n             let layout = bcx.ccx.layout_of(closure_ty);\n@@ -619,15 +620,14 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 );\n             }\n         });\n-        LocalRef::Lvalue(LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty),\n-                                              Alignment::AbiAligned))\n+        LocalRef::Lvalue(lvalue)\n     }).collect()\n }\n \n mod analyze;\n mod block;\n mod constant;\n pub mod lvalue;\n-mod operand;\n+pub mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "85bd99fed1465af1127f64747b1dce9fca48928a", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 42, "deletions": 120, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -10,18 +10,16 @@\n \n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{Align, Layout, LayoutTyper};\n+use rustc::ty::layout::LayoutTyper;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use adt;\n use base;\n use common::{self, CrateContext, C_undef};\n use builder::Builder;\n use value::Value;\n-use type_of;\n-use type_::Type;\n+use type_of::{self, LayoutLlvmExt};\n \n use std::fmt;\n use std::ptr;\n@@ -49,8 +47,8 @@ pub enum OperandValue {\n ///\n /// NOTE: unless you know a value's type exactly, you should not\n /// generate LLVM opcodes acting on it and instead act via methods,\n-/// to avoid nasty edge cases. In particular, using `Builder.store`\n-/// directly is sure to cause problems -- use `MirContext.store_operand`\n+/// to avoid nasty edge cases. In particular, using `Builder::store`\n+/// directly is sure to cause problems -- use `OperandRef::store`\n /// instead.\n #[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n@@ -121,15 +119,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             let llty = type_of::type_of(bcx.ccx, self.ty);\n             let mut llpair = C_undef(llty);\n             let elems = [a, b];\n+            let layout = bcx.ccx.layout_of(self.ty);\n             for i in 0..2 {\n                 let elem = base::from_immediate(bcx, elems[i]);\n-                let layout = bcx.ccx.layout_of(self.ty);\n-                let i = if let Layout::Univariant { ref variant, .. } = *layout {\n-                    adt::struct_llfields_index(variant, i)\n-                } else {\n-                    i\n-                };\n-                llpair = bcx.insert_value(llpair, elem, i);\n+                llpair = bcx.insert_value(llpair, elem, layout.llvm_field_index(i));\n             }\n             self.val = OperandValue::Immediate(llpair);\n         }\n@@ -145,72 +138,51 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 debug!(\"Operand::unpack_if_pair: unpacking {:?}\", self);\n \n                 let layout = bcx.ccx.layout_of(self.ty);\n-                let (ix0, ix1) = if let Layout::Univariant { ref variant, .. } = *layout {\n-                    (adt::struct_llfields_index(variant, 0),\n-                    adt::struct_llfields_index(variant, 1))\n-                } else {\n-                    (0, 1)\n-                };\n \n-                let mut a = bcx.extract_value(llval, ix0);\n-                let mut b = bcx.extract_value(llval, ix1);\n+                let a = bcx.extract_value(llval, layout.llvm_field_index(0));\n+                let a = base::to_immediate(bcx, a, layout.field_type(bcx.ccx, 0));\n \n-                let pair_fields = common::type_pair_fields(bcx.ccx, self.ty);\n-                if let Some([a_ty, b_ty]) = pair_fields {\n-                    if a_ty.is_bool() {\n-                        a = bcx.trunc(a, Type::i1(bcx.ccx));\n-                    }\n-                    if b_ty.is_bool() {\n-                        b = bcx.trunc(b, Type::i1(bcx.ccx));\n-                    }\n-                }\n+                let b = bcx.extract_value(llval, layout.llvm_field_index(1));\n+                let b = base::to_immediate(bcx, b, layout.field_type(bcx.ccx, 1));\n \n                 self.val = OperandValue::Pair(a, b);\n             }\n         }\n         self\n     }\n-}\n-\n-impl<'a, 'tcx> MirContext<'a, 'tcx> {\n-    pub fn trans_load(&mut self,\n-                      bcx: &Builder<'a, 'tcx>,\n-                      llval: ValueRef,\n-                      align: Alignment,\n-                      ty: Ty<'tcx>)\n-                      -> OperandRef<'tcx>\n-    {\n-        debug!(\"trans_load: {:?} @ {:?}\", Value(llval), ty);\n-\n-        let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n-            let (lldata, llextra) = base::load_fat_ptr(bcx, llval, align, ty);\n-            OperandValue::Pair(lldata, llextra)\n-        } else if common::type_is_imm_pair(bcx.ccx, ty) {\n-            let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(ty) {\n-                Layout::Univariant { ref variant, .. } => {\n-                    (adt::struct_llfields_index(variant, 0),\n-                    adt::struct_llfields_index(variant, 1),\n-                    Alignment::from_packed(variant.packed) | align)\n-                },\n-                _ => (0, 1, align)\n-            };\n-            let [a_ty, b_ty] = common::type_pair_fields(bcx.ccx, ty).unwrap();\n-            let a_ptr = bcx.struct_gep(llval, ix0);\n-            let b_ptr = bcx.struct_gep(llval, ix1);\n-\n-            OperandValue::Pair(\n-                base::load_ty(bcx, a_ptr, f_align, a_ty),\n-                base::load_ty(bcx, b_ptr, f_align, b_ty)\n-            )\n-        } else if common::type_is_immediate(bcx.ccx, ty) {\n-            OperandValue::Immediate(base::load_ty(bcx, llval, align, ty))\n-        } else {\n-            OperandValue::Ref(llval, align)\n-        };\n \n-        OperandRef { val: val, ty: ty }\n+    pub fn store(self, bcx: &Builder<'a, 'tcx>, dest: LvalueRef<'tcx>) {\n+        debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n+        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n+        // value is through `undef`, and store itself is useless.\n+        if common::type_is_zero_size(bcx.ccx, self.ty) {\n+            return;\n+        }\n+        match self.val {\n+            OperandValue::Ref(r, source_align) =>\n+                base::memcpy_ty(bcx, dest.llval, r, self.ty,\n+                                (source_align | dest.alignment).non_abi()),\n+            OperandValue::Immediate(s) => {\n+                bcx.store(base::from_immediate(bcx, s), dest.llval, dest.alignment.non_abi());\n+            }\n+            OperandValue::Pair(a, b) => {\n+                // See comment above about zero-sized values.\n+                let dest_a = dest.project_field(bcx, 0);\n+                if !common::type_is_zero_size(bcx.ccx, dest_a.ty.to_ty(bcx.tcx())) {\n+                    let a = base::from_immediate(bcx, a);\n+                    bcx.store(a, dest_a.llval, dest_a.alignment.non_abi());\n+                }\n+                let dest_b = dest.project_field(bcx, 1);\n+                if !common::type_is_zero_size(bcx.ccx, dest_b.ty.to_ty(bcx.tcx())) {\n+                    let b = base::from_immediate(bcx, b);\n+                    bcx.store(b, dest_b.llval, dest_b.alignment.non_abi());\n+                }\n+            }\n+        }\n     }\n+}\n \n+impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_consume(&mut self,\n                          bcx: &Builder<'a, 'tcx>,\n                          lvalue: &mir::Lvalue<'tcx>)\n@@ -258,9 +230,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         // for most lvalues, to consume them we just load them\n         // out from their home\n-        let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-        let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-        self.trans_load(bcx, tr_lvalue.llval, tr_lvalue.alignment, ty)\n+        self.trans_lvalue(bcx, lvalue).load(bcx)\n     }\n \n     pub fn trans_operand(&mut self,\n@@ -280,59 +250,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let operand = val.to_operand(bcx.ccx);\n                 if let OperandValue::Ref(ptr, align) = operand.val {\n                     // If this is a OperandValue::Ref to an immediate constant, load it.\n-                    self.trans_load(bcx, ptr, align, operand.ty)\n+                    LvalueRef::new_sized(ptr, operand.ty, align).load(bcx)\n                 } else {\n                     operand\n                 }\n             }\n         }\n     }\n-\n-    pub fn store_operand(&mut self,\n-                         bcx: &Builder<'a, 'tcx>,\n-                         lldest: ValueRef,\n-                         align: Option<Align>,\n-                         operand: OperandRef<'tcx>) {\n-        debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n-        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n-        // value is through `undef`, and store itself is useless.\n-        if common::type_is_zero_size(bcx.ccx, operand.ty) {\n-            return;\n-        }\n-        match operand.val {\n-            OperandValue::Ref(r, source_align) =>\n-                base::memcpy_ty(bcx, lldest, r, operand.ty,\n-                                source_align.min_with(align)),\n-            OperandValue::Immediate(s) => {\n-                bcx.store(base::from_immediate(bcx, s), lldest, align);\n-            }\n-            OperandValue::Pair(a, b) => {\n-                let (ix0, ix1, f_align) = match *bcx.ccx.layout_of(operand.ty) {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        (adt::struct_llfields_index(variant, 0),\n-                        adt::struct_llfields_index(variant, 1),\n-                        if variant.packed { Some(variant.align) } else { None })\n-                    }\n-                    _ => (0, 1, align)\n-                };\n-\n-                let a = base::from_immediate(bcx, a);\n-                let b = base::from_immediate(bcx, b);\n-\n-                // See comment above about zero-sized values.\n-                let (a_zst, b_zst) = common::type_pair_fields(bcx.ccx, operand.ty)\n-                    .map_or((false, false), |[a_ty, b_ty]| {\n-                        (common::type_is_zero_size(bcx.ccx, a_ty),\n-                         common::type_is_zero_size(bcx.ccx, b_ty))\n-                    });\n-\n-                if !a_zst {\n-                    bcx.store(a, bcx.struct_gep(lldest, ix0), f_align);\n-                }\n-                if !b_zst {\n-                    bcx.store(b, bcx.struct_gep(lldest, ix1), f_align);\n-                }\n-            }\n-        }\n-    }\n }"}, {"sha": "4f4fbcd62371ec5727da5f32ce475e4d2fd5b533", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 57, "deletions": 68, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -12,7 +12,6 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::{Layout, LayoutTyper};\n-use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n@@ -25,11 +24,9 @@ use callee;\n use common::{self, val_ty};\n use common::{C_bool, C_u8, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n use consts;\n-use adt;\n use monomorphize;\n use type_::Type;\n use type_of;\n-use tvec;\n use value::Value;\n \n use super::{MirContext, LocalRef};\n@@ -52,7 +49,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), tr_operand);\n+               tr_operand.store(&bcx, dest);\n                bcx\n            }\n \n@@ -63,7 +60,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n+                    temp.store(&bcx, dest);\n                     return bcx;\n                 }\n \n@@ -73,9 +70,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // so the (generic) MIR may not be able to expand it.\n                 let operand = self.trans_operand(&bcx, source);\n                 let operand = operand.pack_if_pair(&bcx);\n-                let llref = match operand.val {\n+                match operand.val {\n                     OperandValue::Pair(..) => bug!(),\n-                    OperandValue::Immediate(llval) => {\n+                    OperandValue::Immediate(_) => {\n                         // unsize from an immediate structure. We don't\n                         // really need a temporary alloca here, but\n                         // avoiding it would require us to have\n@@ -84,109 +81,101 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n                         let scratch = LvalueRef::alloca(&bcx, operand.ty, \"__unsize_temp\");\n-                        base::store_ty(&bcx, llval, scratch.llval, scratch.alignment, operand.ty);\n-                        scratch\n+                        scratch.storage_live(&bcx);\n+                        operand.store(&bcx, scratch);\n+                        base::coerce_unsized_into(&bcx, scratch, dest);\n+                        scratch.storage_dead(&bcx);\n                     }\n                     OperandValue::Ref(llref, align) => {\n-                        LvalueRef::new_sized_ty(llref, operand.ty, align)\n+                        let source = LvalueRef::new_sized(llref, operand.ty, align);\n+                        base::coerce_unsized_into(&bcx, source, dest);\n                     }\n-                };\n-                base::coerce_unsized_into(&bcx, &llref, &dest);\n+                }\n                 bcx\n             }\n \n             mir::Rvalue::Repeat(ref elem, count) => {\n-                let dest_ty = dest.ty.to_ty(bcx.tcx());\n+                let tr_elem = self.trans_operand(&bcx, elem);\n \n-                // No need to inizialize memory of a zero-sized slice\n+                // Do not generate the loop for zero-sized elements or empty arrays.\n+                let dest_ty = dest.ty.to_ty(bcx.tcx());\n                 if common::type_is_zero_size(bcx.ccx, dest_ty) {\n                     return bcx;\n                 }\n \n-                let tr_elem = self.trans_operand(&bcx, elem);\n-                let count = count.as_u64();\n-                let count = C_usize(bcx.ccx, count);\n-                let base = base::get_dataptr(&bcx, dest.llval);\n-                let align = dest.alignment.to_align();\n+                let start = dest.project_index(&bcx, C_usize(bcx.ccx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n-                    let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                    let align = dest.alignment.non_abi()\n+                        .unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n                     let align = C_i32(bcx.ccx, align.abi() as i32);\n                     let size = C_usize(bcx.ccx, bcx.ccx.size_of(dest_ty).bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n                         let fill = C_u8(bcx.ccx, 0);\n-                        base::call_memset(&bcx, base, fill, size, align, false);\n+                        base::call_memset(&bcx, start, fill, size, align, false);\n                         return bcx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     if common::val_ty(v) == Type::i8(bcx.ccx) {\n-                        base::call_memset(&bcx, base, v, size, align, false);\n+                        base::call_memset(&bcx, start, v, size, align, false);\n                         return bcx;\n                     }\n                 }\n \n-                tvec::slice_for_each(&bcx, base, tr_elem.ty, count, |bcx, llslot, loop_bb| {\n-                    self.store_operand(bcx, llslot, align, tr_elem);\n-                    bcx.br(loop_bb);\n-                })\n+                let count = count.as_u64();\n+                let count = C_usize(bcx.ccx, count);\n+                let end = dest.project_index(&bcx, count).llval;\n+\n+                let header_bcx = bcx.build_sibling_block(\"repeat_loop_header\");\n+                let body_bcx = bcx.build_sibling_block(\"repeat_loop_body\");\n+                let next_bcx = bcx.build_sibling_block(\"repeat_loop_next\");\n+\n+                bcx.br(header_bcx.llbb());\n+                let current = header_bcx.phi(common::val_ty(start), &[start], &[bcx.llbb()]);\n+\n+                let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n+                header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n+\n+                tr_elem.store(&body_bcx,\n+                    LvalueRef::new_sized(current, tr_elem.ty, dest.alignment));\n+\n+                let next = body_bcx.inbounds_gep(current, &[C_usize(bcx.ccx, 1)]);\n+                body_bcx.br(header_bcx.llbb());\n+                header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n+\n+                next_bcx\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n-                match **kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n+                let (dest, active_field_index) = match **kind {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         dest.trans_set_discr(&bcx, variant_index);\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(&bcx, operand);\n-                            // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let mut val = LvalueRef::new_sized(\n-                                    dest.llval, dest.ty, dest.alignment);\n-                                let field_index = active_field_index.unwrap_or(i);\n-                                val.ty = LvalueTy::Downcast {\n-                                    adt_def,\n-                                    substs: self.monomorphize(&substs),\n-                                    variant_index,\n-                                };\n-                                let (lldest_i, align) = val.trans_field_ptr(&bcx, field_index);\n-                                self.store_operand(&bcx, lldest_i, align.to_align(), op);\n-                            }\n-                        }\n-                    },\n-                    _ => {\n-                        // If this is a tuple or closure, we need to translate GEP indices.\n-                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n-                        let get_memory_index = |i| {\n-                            if let Layout::Univariant { ref variant, .. } = *layout {\n-                                adt::struct_llfields_index(variant, i)\n-                            } else {\n-                                i\n-                            }\n-                        };\n-                        let alignment = dest.alignment;\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let op = self.trans_operand(&bcx, operand);\n-                            // Do not generate stores and GEPis for zero-sized fields.\n-                            if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                // Note: perhaps this should be StructGep, but\n-                                // note that in some cases the values here will\n-                                // not be structs but arrays.\n-                                let i = get_memory_index(i);\n-                                let dest = bcx.gepi(dest.llval, &[0, i]);\n-                                self.store_operand(&bcx, dest, alignment.to_align(), op);\n-                            }\n+                        if adt_def.is_enum() {\n+                            (dest.project_downcast(&bcx, variant_index), active_field_index)\n+                        } else {\n+                            (dest, active_field_index)\n                         }\n                     }\n+                    _ => (dest, None)\n+                };\n+                for (i, operand) in operands.iter().enumerate() {\n+                    let op = self.trans_operand(&bcx, operand);\n+                    // Do not generate stores and GEPis for zero-sized fields.\n+                    if !common::type_is_zero_size(bcx.ccx, op.ty) {\n+                        let field_index = active_field_index.unwrap_or(i);\n+                        op.store(&bcx, dest.project_field(&bcx, field_index));\n+                    }\n                 }\n                 bcx\n             }\n \n             _ => {\n                 assert!(self.rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n+                temp.store(&bcx, dest);\n                 bcx\n             }\n         }"}, {"sha": "da4a4e55a67f4819356305a7b692979f8006b1af", "filename": "src/librustc_trans/tvec.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/260c41b4b808fd9995f23ce1eb7d820f49254c85/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/260c41b4b808fd9995f23ce1eb7d820f49254c85/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=260c41b4b808fd9995f23ce1eb7d820f49254c85", "patch": "@@ -1,53 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use llvm;\n-use builder::Builder;\n-use llvm::{BasicBlockRef, ValueRef};\n-use common::*;\n-use rustc::ty::Ty;\n-\n-pub fn slice_for_each<'a, 'tcx, F>(\n-    bcx: &Builder<'a, 'tcx>,\n-    data_ptr: ValueRef,\n-    unit_ty: Ty<'tcx>,\n-    len: ValueRef,\n-    f: F\n-) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef, BasicBlockRef) {\n-    // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n-    let zst = type_is_zero_size(bcx.ccx, unit_ty);\n-    let add = |bcx: &Builder, a, b| if zst {\n-        bcx.add(a, b)\n-    } else {\n-        bcx.inbounds_gep(a, &[b])\n-    };\n-\n-    let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n-    let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n-    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n-\n-    let start = if zst {\n-        C_usize(bcx.ccx, 1)\n-    } else {\n-        data_ptr\n-    };\n-    let end = add(&bcx, start, len);\n-\n-    bcx.br(header_bcx.llbb());\n-    let current = header_bcx.phi(val_ty(start), &[start], &[bcx.llbb()]);\n-\n-    let keep_going = header_bcx.icmp(llvm::IntNE, current, end);\n-    header_bcx.cond_br(keep_going, body_bcx.llbb(), next_bcx.llbb());\n-\n-    let next = add(&body_bcx, current, C_usize(bcx.ccx, 1));\n-    f(&body_bcx, if zst { data_ptr } else { current }, header_bcx.llbb());\n-    header_bcx.add_incoming_to_phi(current, next, body_bcx.llbb());\n-    next_bcx\n-}"}, {"sha": "1187ef1cd2f224497378fc2925a3554324cc27ee", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -12,7 +12,7 @@ use abi::FnType;\n use adt;\n use common::*;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{Align, LayoutTyper, Size};\n+use rustc::ty::layout::{Align, Layout, LayoutTyper, Size, TyLayout};\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -237,6 +237,50 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     }\n }\n \n+pub trait LayoutLlvmExt {\n+    fn llvm_field_index(&self, index: usize) -> u64;\n+}\n+\n+impl<'tcx> LayoutLlvmExt for TyLayout<'tcx> {\n+    fn llvm_field_index(&self, index: usize) -> u64 {\n+        match **self {\n+            Layout::Scalar { .. } |\n+            Layout::CEnum { .. } |\n+            Layout::UntaggedUnion { .. } |\n+            Layout::RawNullablePointer { .. } => {\n+                bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+            }\n+\n+            Layout::Vector { .. } |\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } => {\n+                index as u64\n+            }\n+\n+            Layout::Univariant { ref variant, .. } => {\n+                adt::memory_index_to_gep(variant.memory_index[index] as u64)\n+            }\n+\n+            Layout::General { ref variants, .. } => {\n+                if let Some(v) = self.variant_index {\n+                    adt::memory_index_to_gep(variants[v].memory_index[index] as u64)\n+                } else {\n+                    assert_eq!(index, 0);\n+                    index as u64\n+                }\n+            }\n+\n+            Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                if self.variant_index == Some(nndiscr as usize) {\n+                    adt::memory_index_to_gep(nonnull.memory_index[index] as u64)\n+                } else {\n+                    bug!(\"TyLayout::llvm_field_index({:?}): not applicable\", self)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {\n     let mut name = String::with_capacity(32);\n     let printer = DefPathBasedNames::new(cx.tcx(), true, true);"}, {"sha": "eee5c1d9ef238c6a397590ed63390a1ea46a7642", "filename": "src/librustc_trans_utils/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Flibrustc_trans_utils%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fmonomorphize.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst};\n use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::ty::Instance;\n@@ -125,12 +125,3 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-/// Returns the normalized type of a struct field\n-pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          param_substs: &Substs<'tcx>,\n-                          f: &'tcx ty::FieldDef)\n-                          -> Ty<'tcx>\n-{\n-    tcx.fully_normalize_associated_types_in(&f.ty(tcx, param_substs))\n-}\n-"}, {"sha": "915db493fc2a4f2068971228e38eecd05fa4a7c3", "filename": "src/test/codegen/slice-init.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Ftest%2Fcodegen%2Fslice-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb/src%2Ftest%2Fcodegen%2Fslice-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-init.rs?ref=5b1fdaeb80b14bc0b7d7c172019b7cd792bb9abb", "patch": "@@ -15,7 +15,7 @@\n // CHECK-LABEL: @zero_sized_elem\n #[no_mangle]\n pub fn zero_sized_elem() {\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [(); 4];\n     drop(&x);\n@@ -24,7 +24,7 @@ pub fn zero_sized_elem() {\n // CHECK-LABEL: @zero_len_array\n #[no_mangle]\n pub fn zero_len_array() {\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [4; 0];\n     drop(&x);\n@@ -34,7 +34,7 @@ pub fn zero_len_array() {\n #[no_mangle]\n pub fn byte_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 7, i[[WIDTH]] 4\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [7u8; 4];\n     drop(&x);\n }\n@@ -50,7 +50,7 @@ enum Init {\n #[no_mangle]\n pub fn byte_enum_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 {{.*}}, i[[WIDTH]] 4\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [Init::Memset; 4];\n     drop(&x);\n }\n@@ -59,15 +59,15 @@ pub fn byte_enum_array() {\n #[no_mangle]\n pub fn zeroed_integer_array() {\n     // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 0, i[[WIDTH]] 16\n-    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: br label %repeat_loop_header{{.*}}\n     let x = [0u32; 4];\n     drop(&x);\n }\n \n // CHECK-LABEL: @nonzero_integer_array\n #[no_mangle]\n pub fn nonzero_integer_array() {\n-    // CHECK: br label %slice_loop_header{{.*}}\n+    // CHECK: br label %repeat_loop_header{{.*}}\n     // CHECK-NOT: call void @llvm.memset.p0i8\n     let x = [0x1a_2b_3c_4d_u32; 4];\n     drop(&x);"}]}