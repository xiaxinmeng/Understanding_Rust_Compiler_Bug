{"sha": "44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YmUwNTRhMmFjYmVlYjY4MmQwMmE1Zjg4ZGRlZGMwY2I1YzliZjI=", "commit": {"author": {"name": "Martin Hoffmann", "email": "hn@nvnc.de", "date": "2018-02-27T15:24:52Z"}, "committer": {"name": "Martin Hoffmann", "email": "hn@nvnc.de", "date": "2018-02-27T15:24:52Z"}, "message": "Further refinement of Borrow documentation.", "tree": {"sha": "829c5d94a98cdcb2379ca48b23ec4ad179ffdd14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/829c5d94a98cdcb2379ca48b23ec4ad179ffdd14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2", "html_url": "https://github.com/rust-lang/rust/commit/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2/comments", "author": {"login": "partim", "id": 1318494, "node_id": "MDQ6VXNlcjEzMTg0OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1318494?v=4", "gravatar_id": "", "url": "https://api.github.com/users/partim", "html_url": "https://github.com/partim", "followers_url": "https://api.github.com/users/partim/followers", "following_url": "https://api.github.com/users/partim/following{/other_user}", "gists_url": "https://api.github.com/users/partim/gists{/gist_id}", "starred_url": "https://api.github.com/users/partim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/partim/subscriptions", "organizations_url": "https://api.github.com/users/partim/orgs", "repos_url": "https://api.github.com/users/partim/repos", "events_url": "https://api.github.com/users/partim/events{/privacy}", "received_events_url": "https://api.github.com/users/partim/received_events", "type": "User", "site_admin": false}, "committer": {"login": "partim", "id": 1318494, "node_id": "MDQ6VXNlcjEzMTg0OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1318494?v=4", "gravatar_id": "", "url": "https://api.github.com/users/partim", "html_url": "https://github.com/partim", "followers_url": "https://api.github.com/users/partim/followers", "following_url": "https://api.github.com/users/partim/following{/other_user}", "gists_url": "https://api.github.com/users/partim/gists{/gist_id}", "starred_url": "https://api.github.com/users/partim/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/partim/subscriptions", "organizations_url": "https://api.github.com/users/partim/orgs", "repos_url": "https://api.github.com/users/partim/repos", "events_url": "https://api.github.com/users/partim/events{/privacy}", "received_events_url": "https://api.github.com/users/partim/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ae7e5393367cdc9a630cd56911ab42f499c091f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae7e5393367cdc9a630cd56911ab42f499c091f", "html_url": "https://github.com/rust-lang/rust/commit/7ae7e5393367cdc9a630cd56911ab42f499c091f"}], "stats": {"total": 68, "additions": 36, "deletions": 32}, "files": [{"sha": "c0f1989f8794487c320f3565916edfef1750c626", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=44be054a2acbeeb682d02a5f88ddedc0cb5c9bf2", "patch": "@@ -17,36 +17,41 @@\n /// In Rust, it is common to provide different representations of a type for\n /// different use cases. For instance, storage location and management for a\n /// value can be specifically chosen as appropriate for a particular use via\n-/// pointer types such as [`Box<T>`] or [`Rc<T>`] or one can opt into\n-/// concurrency via synchronization types such as [`Mutex<T>`], avoiding the\n-/// associated cost when in parallel doesn\u2019t happen. Beyond these generic\n+/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n /// wrappers that can be used with any type, some types provide optional\n /// facets providing potentially costly functionality. An example for such a\n /// type is [`String`] which adds the ability to extend a string to the basic\n /// [`str`]. This requires keeping additional information unnecessary for a\n-/// simple, imutable string.\n+/// simple, immutable string.\n ///\n /// These types signal that they are a specialized representation of a basic\n /// type `T` by implementing `Borrow<T>`. The method `borrow` provides a way\n-/// to convert a reference to the type into a reference to the underlying\n-/// basic type.\n+/// to convert a reference to the type into a reference to this basic type\n+/// `T`.\n ///\n-/// If a type implementing `Borrow<T>` implements other traits also\n-/// implemented by `T`, these implementations behave identically if the trait\n-/// is concerned with the data rather than its representation. For instance,\n-/// the comparison traits such as `PartialEq` or `PartialOrd` must behave\n-/// identical for `T` and any type implemeting `Borrow<T>`.\n+/// Further, when providing implementations for additional traits, it needs\n+/// to be considered whether they should behave identical to those of the\n+/// underlying type as a consequence of acting as a representation of that\n+/// underlying type.\n ///\n-/// When writing generic code, a use of `Borrow` should always be justified\n-/// by additional trait bounds, making it clear that the two types need to\n-/// behave identically in a certain context. If the code should merely be\n-/// able to operate on any type that can produce a reference to a given type,\n-/// you should use [`AsRef`] instead.\n+/// Generic code typically uses `Borrow<T>` when it not only needs access\n+/// to a reference of the underlying type but relies on the identical\n+/// behavior of these additional trait implementations. These traits are\n+/// likely to appear as additional trait bounds.\n ///\n-/// The companion trait [`BorrowMut`] provides the same guarantees for\n-/// mutable references.\n+/// If generic code merely needs to work for all types that can\n+/// provide a reference to related type `T`, it is often better to use\n+/// [`AsRef<T>`] as more types can safely implement it.\n ///\n-/// [`AsRef`]: ../../std/convert/trait.AsRef.html\n+/// If a type implementing `Borrow<T>` also wishes to allow mutable access\n+/// to the underlying type `T`, it can do so by implementing the companion\n+/// trait [`BorrowMut`].\n+///\n+/// Note also that it is perfectly fine for a single type to have multiple\n+/// implementations of `Borrow<T>` for different `T`s. In fact, a blanket\n+/// implementation lets every type be at least a borrow of itself.\n+///\n+/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n /// [`BorrowMut`]: trait.BorrowMut.html\n /// [`Box<T>`]: ../../std/boxed/struct.Box.html\n /// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n@@ -111,7 +116,7 @@\n /// data, called `Q` in the method signature above. It states that `K` is a\n /// representation of `Q` by requiring that `K: Borrow<Q>`. By additionally\n /// requiring `Q: Hash + Eq`, it demands that `K` and `Q` have\n-/// implementations of the `Hash` and `Eq` traits that procude identical\n+/// implementations of the `Hash` and `Eq` traits that produce identical\n /// results.\n ///\n /// The implementation of `get` relies in particular on identical\n@@ -124,24 +129,24 @@\n /// type that wraps a string but compares ASCII letters ignoring their case:\n ///\n /// ```\n-/// pub struct CIString(String);\n+/// pub struct CaseInsensitiveString(String);\n ///\n-/// impl PartialEq for CIString {\n+/// impl PartialEq for CaseInsensitiveString {\n ///     fn eq(&self, other: &Self) -> bool {\n ///         self.0.eq_ignore_ascii_case(&other.0)\n ///     }\n /// }\n ///\n-/// impl Eq for CIString { }\n+/// impl Eq for CaseInsensitiveString { }\n /// ```\n ///\n /// Because two equal values need to produce the same hash value, the\n /// implementation of `Hash` needs to reflect that, too:\n ///\n /// ```\n /// # use std::hash::{Hash, Hasher};\n-/// # pub struct CIString(String);\n-/// impl Hash for CIString {\n+/// # pub struct CaseInsensitiveString(String);\n+/// impl Hash for CaseInsensitiveString {\n ///     fn hash<H: Hasher>(&self, state: &mut H) {\n ///         for c in self.0.as_bytes() {\n ///             c.to_ascii_lowercase().hash(state)\n@@ -150,13 +155,12 @@\n /// }\n /// ```\n ///\n-/// Can `CIString` implement `Borrow<str>`? It certainly can provide a\n-/// reference to a string slice via its contained owned string. But because\n-/// its `Hash` implementation differs, it cannot fulfill the guarantee for\n-/// `Borrow` that all common trait implementations must behave the same way\n-/// and must not, in fact, implement `Borrow<str>`. If it wants to allow\n-/// others access to the underlying `str`, it can do that via `AsRef<str>`\n-/// which doesn\u2019t carry any such restrictions.\n+/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n+/// provide a reference to a string slice via its contained owned string.\n+/// But because its `Hash` implementation differs, it behaves differently\n+/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n+/// If it wants to allow others access to the underlying `str`, it can do\n+/// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n ///\n /// [`Hash`]: ../../std/hash/trait.Hash.html\n /// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html"}]}