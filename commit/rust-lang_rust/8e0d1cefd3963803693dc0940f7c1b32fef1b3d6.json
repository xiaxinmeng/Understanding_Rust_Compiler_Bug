{"sha": "8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMGQxY2VmZDM5NjM4MDM2OTNkYzA5NDBmN2MxYjMyZmVmMWIzZDY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-28T15:23:41Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-02-05T16:23:54Z"}, "message": "Improve html::render::cache::get_real_types code", "tree": {"sha": "565529b6c3301f387579a113071a0991dc267573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/565529b6c3301f387579a113071a0991dc267573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "html_url": "https://github.com/rust-lang/rust/commit/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4810910b0b2be1f28a2ed666ad1a3825b00bb933", "url": "https://api.github.com/repos/rust-lang/rust/commits/4810910b0b2be1f28a2ed666ad1a3825b00bb933", "html_url": "https://github.com/rust-lang/rust/commit/4810910b0b2be1f28a2ed666ad1a3825b00bb933"}], "stats": {"total": 132, "additions": 127, "deletions": 5}, "files": [{"sha": "ca8ee8ac82d23e9a8d8ca73d96661b944e7304ca", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "patch": "@@ -1408,14 +1408,14 @@ impl Type {\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<Type>> {\n+    crate fn generics(&self) -> Option<Vec<&Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n                     Some(\n                         args.iter()\n                             .filter_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty.clone()),\n+                                GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n                             })\n                             .collect(),"}, {"sha": "821f1cc71a3d8079e16f83196de9d857ad5c2d9b", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 125, "deletions": 3, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e0d1cefd3963803693dc0940f7c1b32fef1b3d6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=8e0d1cefd3963803693dc0940f7c1b32fef1b3d6", "patch": "@@ -70,8 +70,6 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n \n-    // For now we don't get the primitive types in the search index.\n-    let empty_cache = Cache::default();\n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n     for &(did, ref item) in &cache.orphan_impl_items {\n@@ -83,7 +81,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(&item, cache),\n+                search_type: get_index_search_type(&item, cache, tcx),\n             });\n             for alias in item.attrs.get_doc_aliases() {\n                 cache\n@@ -248,3 +246,127 @@ fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>>\n         if r.is_empty() { None } else { Some(r) }\n     })\n }\n+\n+/// The point of this function is to replace bounds with types.\n+///\n+/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n+/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n+/// wrapped types in here).\n+crate fn get_real_types<'tcx>(\n+    generics: &Generics,\n+    arg: &Type,\n+    tcx: TyCtxt<'tcx>,\n+    recurse: i32,\n+    cache: &Cache,\n+    res: &mut FxHashSet<(Type, TypeKind)>,\n+) -> usize {\n+    fn insert(res: &mut FxHashSet<(Type, TypeKind)>, tcx: TyCtxt<'_>, ty: Type) -> usize {\n+        if let Some(kind) = ty.def_id().map(|did| tcx.def_kind(did).into()) {\n+            res.insert((ty, kind));\n+            1\n+        } else if ty.is_primitive() {\n+            // This is a primitive, let's store it as such.\n+            res.insert((ty, TypeKind::Primitive));\n+            1\n+        } else {\n+            0\n+        }\n+    }\n+\n+    if recurse >= 10 {\n+        // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        return 0;\n+    }\n+    let mut nb_added = 0;\n+\n+    if arg.is_full_generic() {\n+        let arg_s = Symbol::intern(&arg.print(cache).to_string());\n+        if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n+            WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n+            _ => false,\n+        }) {\n+            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+            for bound in bounds.iter() {\n+                if let GenericBound::TraitBound(poly_trait, _) = bound {\n+                    for x in poly_trait.generic_params.iter() {\n+                        if !x.is_type() {\n+                            continue;\n+                        }\n+                        if let Some(ty) = x.get_type() {\n+                            let adds = get_real_types(generics, &ty, tcx, recurse + 1, cache, res);\n+                            nb_added += adds;\n+                            if adds == 0 && !ty.is_full_generic() {\n+                                nb_added += insert(res, tcx, ty);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    let adds = get_real_types(generics, &ty, tcx, recurse + 1, cache, res);\n+                    nb_added += adds;\n+                    if adds == 0 && !ty.is_full_generic() {\n+                        nb_added += insert(res, tcx, ty);\n+                    }\n+                }\n+            }\n+        }\n+    } else {\n+        nb_added += insert(res, tcx, arg.clone());\n+        if let Some(gens) = arg.generics() {\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    nb_added += get_real_types(generics, gen, tcx, recurse + 1, cache, res);\n+                } else {\n+                    nb_added += insert(res, tcx, (*gen).clone());\n+                }\n+            }\n+        }\n+    }\n+    nb_added\n+}\n+\n+/// Return the full list of types when bounds have been resolved.\n+///\n+/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n+/// `[u32, Display, Option]`.\n+crate fn get_all_types<'tcx>(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    tcx: TyCtxt<'tcx>,\n+    cache: &Cache,\n+) -> (Vec<(Type, TypeKind)>, Vec<(Type, TypeKind)>) {\n+    let mut all_types = FxHashSet::default();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        let mut args = FxHashSet::default();\n+        get_real_types(generics, &arg.type_, tcx, 0, cache, &mut args);\n+        if !args.is_empty() {\n+            all_types.extend(args);\n+        } else {\n+            if let Some(kind) = arg.type_.def_id().map(|did| tcx.def_kind(did).into()) {\n+                all_types.insert((arg.type_.clone(), kind));\n+            }\n+        }\n+    }\n+\n+    let ret_types = match decl.output {\n+        FnRetTy::Return(ref return_type) => {\n+            let mut ret = FxHashSet::default();\n+            get_real_types(generics, &return_type, tcx, 0, cache, &mut ret);\n+            if ret.is_empty() {\n+                if let Some(kind) = return_type.def_id().map(|did| tcx.def_kind(did).into()) {\n+                    ret.insert((return_type.clone(), kind));\n+                }\n+            }\n+            ret.into_iter().collect()\n+        }\n+        _ => Vec::new(),\n+    };\n+    (all_types.into_iter().collect(), ret_types)\n+}"}]}