{"sha": "0aec4db1c09574da2f30e3844de6d252d79d4939", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZWM0ZGIxYzA5NTc0ZGEyZjMwZTM4NDRkZTZkMjUyZDc5ZDQ5Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T04:45:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T04:45:18Z"}, "message": "auto merge of #20889 : Manishearth/rust/trait-error, r=nikomatsakis\n\nfixes #20783\r\n\r\nr? @nikomatsakis", "tree": {"sha": "64ef8983eb848612559f373ab7069e033672745f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64ef8983eb848612559f373ab7069e033672745f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aec4db1c09574da2f30e3844de6d252d79d4939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aec4db1c09574da2f30e3844de6d252d79d4939", "html_url": "https://github.com/rust-lang/rust/commit/0aec4db1c09574da2f30e3844de6d252d79d4939", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aec4db1c09574da2f30e3844de6d252d79d4939/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a41380c14e94052332360b104ec1651f97297b", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a41380c14e94052332360b104ec1651f97297b", "html_url": "https://github.com/rust-lang/rust/commit/15a41380c14e94052332360b104ec1651f97297b"}, {"sha": "02d0a8bbcf0a64339e4279c4ddb4841189ba5069", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d0a8bbcf0a64339e4279c4ddb4841189ba5069", "html_url": "https://github.com/rust-lang/rust/commit/02d0a8bbcf0a64339e4279c4ddb4841189ba5069"}], "stats": {"total": 237, "additions": 234, "deletions": 3}, "files": [{"sha": "623097b2fc90f872fae1f3530468c183e9fe1481", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -2117,6 +2117,13 @@ macro scope.\n   destructors from being run twice. Destructors might be run multiple times on\n   the same object with this attribute.\n - `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n+- `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n+   when the trait is found to be unimplemented on a type.\n+   You may use format arguments like `{T}`, `{A}` to correspond to the\n+   types at the point of use corresponding to the type parameters of the\n+   trait of the same name. `{Self}` will be replaced with the type that is supposed\n+   to implement the trait but doesn't. To use this, the `on_unimplemented` feature gate\n+   must be enabled.\n \n ### Conditional compilation\n "}, {"sha": "5ed77852ad0a1e1ee6a6a232848dfdfa4392b8ba", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -101,6 +101,8 @@ pub trait Iterator {\n \n /// Conversion from an `Iterator`\n #[stable]\n+#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n+                          built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;"}, {"sha": "78e8a2a9e9164be4bf34700c3ec630231a328202", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -63,6 +63,7 @@\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(on_unimplemented)]\n #![deny(missing_docs)]\n \n #[macro_use]"}, {"sha": "e720a5df5980741b9b0d8046dce765017a6bbb1d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -32,6 +32,7 @@\n \n extern crate arena;\n extern crate flate;\n+extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;"}, {"sha": "8ed177c82a8f7c70749990544ef4c4e3e42f59a2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -666,6 +666,7 @@ impl LintPass for UnusedAttributes {\n             \"must_use\",\n             \"stable\",\n             \"unstable\",\n+            \"rustc_on_unimplemented\",\n \n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\","}, {"sha": "6b4dd101286d664ec0195992e7dd29c48a2c6b09", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -18,9 +18,12 @@ use super::{\n     SelectionError,\n };\n \n+use fmt_macros::{Parser, Piece, Position};\n use middle::infer::InferCtxt;\n-use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef};\n-use syntax::codemap::Span;\n+use middle::ty::{self, AsPredicate, ReferencesError, ToPolyTraitRef, TraitRef};\n+use std::collections::HashMap;\n+use syntax::codemap::{DUMMY_SP, Span};\n+use syntax::attr::{AttributeMethods, AttrMetaMethods};\n use util::ppaux::{Repr, UserString};\n \n pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n@@ -62,6 +65,85 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     }\n }\n \n+fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                     trait_ref: &TraitRef<'tcx>,\n+                                     span: Span) -> Option<String> {\n+    let def_id = trait_ref.def_id;\n+    let mut report = None;\n+    ty::each_attr(infcx.tcx, def_id, |item| {\n+        if item.check_name(\"rustc_on_unimplemented\") {\n+            let err_sp = if item.meta().span == DUMMY_SP {\n+                span\n+            } else {\n+                item.meta().span\n+            };\n+            let def = ty::lookup_trait_def(infcx.tcx, def_id);\n+            let trait_str = def.trait_ref.user_string(infcx.tcx);\n+            if let Some(ref istring) = item.value_str() {\n+                let mut generic_map = def.generics.types.iter_enumerated()\n+                                         .map(|(param, i, gen)| {\n+                                               (gen.name.as_str().to_string(),\n+                                                trait_ref.substs.types.get(param, i)\n+                                                         .user_string(infcx.tcx))\n+                                              }).collect::<HashMap<String, String>>();\n+                generic_map.insert(\"Self\".to_string(),\n+                                   trait_ref.self_ty().user_string(infcx.tcx));\n+                let parser = Parser::new(istring.get());\n+                let mut errored = false;\n+                let err: String = parser.filter_map(|p| {\n+                    match p {\n+                        Piece::String(s) => Some(s),\n+                        Piece::NextArgument(a) => match a.position {\n+                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                Some(val) => Some(val.as_slice()),\n+                                None => {\n+                                    infcx.tcx.sess\n+                                         .span_err(err_sp,\n+                                                   format!(\"the #[rustc_on_unimplemented] \\\n+                                                            attribute on \\\n+                                                            trait definition for {} refers to \\\n+                                                            non-existent type parameter {}\",\n+                                                           trait_str, s)\n+                                                   .as_slice());\n+                                    errored = true;\n+                                    None\n+                                }\n+                            },\n+                            _ => {\n+                                infcx.tcx.sess\n+                                     .span_err(err_sp,\n+                                               format!(\"the #[rustc_on_unimplemented] \\\n+                                                        attribute on \\\n+                                                        trait definition for {} must have named \\\n+                                                        format arguments, \\\n+                                                        eg `#[rustc_on_unimplemented = \\\n+                                                        \\\"foo {{T}}\\\"]`\",\n+                                                       trait_str).as_slice());\n+                                errored = true;\n+                                None\n+                            }\n+                        }\n+                    }\n+                }).collect();\n+                // Report only if the format string checks out\n+                if !errored {\n+                    report = Some(err);\n+                }\n+            } else {\n+                infcx.tcx.sess.span_err(err_sp,\n+                                        format!(\"the #[rustc_on_unimplemented] attribute on \\\n+                                                 trait definition for {} must have a value, \\\n+                                                 eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                                                 trait_str).as_slice());\n+            }\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+    report\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)\n@@ -94,6 +176,14 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(infcx.tcx),\n                                 trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                        // Check if it has a custom \"#[rustc_on_unimplemented]\" error message,\n+                        // report with that message if it does\n+                        let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n+                                                                  obligation.cause.span);\n+                        if let Some(s) = custom_note {\n+                           infcx.tcx.sess.span_note(obligation.cause.span,\n+                                                    s.as_slice());\n+                        }\n                     }\n                 }\n "}, {"sha": "7473f0223a669c01fe84072b22bfa1689b36a84e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -83,6 +83,7 @@ use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv};\n use check::_match::pat_ctxt;\n+use fmt_macros::{Parser, Piece, Position};\n use middle::{const_eval, def};\n use middle::infer;\n use middle::lang_items::IteratorItem;\n@@ -114,6 +115,7 @@ use std::rc::Rc;\n use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n+use syntax::attr::AttrMetaMethods;\n use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{self, local_def, PostExpansionMethod};\n use syntax::codemap::{self, Span};\n@@ -727,7 +729,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         }\n \n       }\n-      ast::ItemTrait(_, _, _, ref trait_methods) => {\n+      ast::ItemTrait(_, ref generics, _, ref trait_methods) => {\n+        check_trait_on_unimplemented(ccx, generics, it);\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in trait_methods.iter() {\n             match *trait_method {\n@@ -777,6 +780,51 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n+fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               generics: &ast::Generics,\n+                               item: &ast::Item) {\n+    if let Some(ref attr) = item.attrs.iter().find(|&: a| {\n+        a.check_name(\"rustc_on_unimplemented\")\n+    }) {\n+        if let Some(ref istring) = attr.value_str() {\n+            let mut parser = Parser::new(istring.get());\n+            let types = generics.ty_params.as_slice();\n+            for token in parser {\n+                match token {\n+                    Piece::String(_) => (), // Normal string, no need to check it\n+                    Piece::NextArgument(a) => match a.position {\n+                        // `{Self}` is allowed\n+                        Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                        // So is `{A}` if A is a type parameter\n+                        Position::ArgumentNamed(s) => match types.iter().find(|t| {\n+                            t.ident.as_str() == s\n+                        }) {\n+                            Some(_) => (),\n+                            None => {\n+                                ccx.tcx.sess.span_err(attr.span,\n+                                                 format!(\"there is no type parameter \\\n+                                                          {} on trait {}\",\n+                                                           s, item.ident.as_str())\n+                                            .as_slice());\n+                            }\n+                        },\n+                        // `{:1}` and `{}` are not to be used\n+                        Position::ArgumentIs(_) | Position::ArgumentNext => {\n+                            ccx.tcx.sess.span_err(attr.span,\n+                                                  \"only named substitution \\\n+                                                   parameters are allowed\");\n+                        }\n+                    }\n+                }\n+            }\n+        } else {\n+            ccx.tcx.sess.span_err(attr.span,\n+                                  \"this attribute must have a value, \\\n+                                   eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\")\n+        }\n+    }\n+}\n+\n /// Type checks a method body.\n ///\n /// # Parameters"}, {"sha": "68b152dee233b4ea86be313adcf9076049d2e6f8", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -84,6 +84,7 @@ This API is completely unstable and subject to change.\n #[macro_use] extern crate syntax;\n \n extern crate arena;\n+extern crate fmt_macros;\n extern crate rustc;\n \n pub use rustc::lint;"}, {"sha": "8929bbe0232edc7bf78a6404f8204cbdfb83cd13", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -71,6 +71,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"visible_private_types\", Active),\n     (\"slicing_syntax\", Active),\n     (\"box_syntax\", Active),\n+    (\"on_unimplemented\", Active),\n \n     (\"if_let\", Accepted),\n     (\"while_let\", Accepted),\n@@ -249,6 +250,10 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 self.gate_feature(\"linkage\", i.span,\n                                   \"the `linkage` attribute is experimental \\\n                                    and not portable across platforms\")\n+            } else if attr.name() == \"rustc_on_unimplemented\" {\n+                self.gate_feature(\"on_unimplemented\", i.span,\n+                                  \"the `#[rustc_on_unimplemented]` attribute \\\n+                                  is an experimental feature\")\n             }\n         }\n         match i.node {"}, {"sha": "dda534cc489b522e12db13c208f11545abc0fc5c", "filename": "src/test/compile-fail/on-unimplemented-bad-anno.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented-bad-anno.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// ignore-tidy-linelength\n+\n+#![feature(on_unimplemented)]\n+\n+#![allow(unused)]\n+\n+#[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n+trait Foo<Bar, Baz, Quux>{}\n+\n+#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n+trait MyFromIterator<A> {\n+    /// Build a container with elements from an external iterator.\n+    fn my_from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n+}\n+\n+#[rustc_on_unimplemented] //~ ERROR this attribute must have a value\n+trait BadAnnotation1 {}\n+\n+#[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{C}>`\"]\n+//~^ ERROR there is no type parameter C on trait BadAnnotation2\n+trait BadAnnotation2<A,B> {}\n+\n+#[rustc_on_unimplemented = \"Unimplemented trait error on `{Self}` with params `<{A},{B},{}>`\"]\n+//~^ only named substitution parameters are allowed\n+trait BadAnnotation3<A,B> {}\n+\n+pub fn main() {\n+}"}, {"sha": "7b406afcf1f5832dcd79890388076ff26b09da29", "filename": "src/test/compile-fail/on-unimplemented.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aec4db1c09574da2f30e3844de6d252d79d4939/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented.rs?ref=0aec4db1c09574da2f30e3844de6d252d79d4939", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+// ignore-tidy-linelength\n+\n+#![feature(on_unimplemented)]\n+\n+#[rustc_on_unimplemented = \"test error `{Self}` with `{Bar}` `{Baz}` `{Quux}`\"]\n+trait Foo<Bar, Baz, Quux>{}\n+\n+fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n+\n+}\n+\n+#[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n+trait MyFromIterator<A> {\n+    /// Build a container with elements from an external iterator.\n+    fn my_from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n+}\n+\n+fn collect<A, I: Iterator<Item=A>, B: MyFromIterator<A>>(it: I) -> B {\n+    MyFromIterator::my_from_iter(it)\n+}\n+\n+pub fn main() {\n+    let x = vec!(1u8, 2, 3, 4);\n+    let y: Option<Vec<u8>> = collect(x.iter()); // this should give approximately the same error for x.iter().collect()\n+    //~^ ERROR\n+    //~^^ NOTE a collection of type `core::option::Option<collections::vec::Vec<u8>>` cannot be built from an iterator over elements of type `&u8`\n+    let x: String = foobar(); //~ ERROR\n+    //~^ NOTE test error `collections::string::String` with `u8` `_` `u32`\n+}"}]}