{"sha": "cc9088f2873300c98d35d4d028d53e474b55a96b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTA4OGYyODczMzAwYzk4ZDM1ZDRkMDI4ZDUzZTQ3NGI1NWE5NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T13:53:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-02T13:53:39Z"}, "message": "Auto merge of #5550 - ebroto:manual_non_exhaustive, r=flip1995\n\nImplement the manual_non_exhaustive lint\n\nSome implementation notes:\n* Not providing automatic fixups because additional changes may be needed in other parts of the code, e.g. when constructing a struct.\n* Even though the attribute is valid on enum variants, it's not possible to use the manual implementation of the pattern because the visibility is always public, so the lint ignores enum variants.\n* Unit structs are also ignored, it's not possible to implement the pattern manually without fields.\n* The attribute is not accepted in unions, so those are ignored too.\n* Even though the original issue did not mention it, tuple structs are also linted because it's possible to apply the pattern manually.\n\nchangelog: Added the manual non-exhaustive implementation lint\n\nCloses #2017", "tree": {"sha": "0b2b63e35738dee8a872f38959dda42e6b9dac48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b2b63e35738dee8a872f38959dda42e6b9dac48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc9088f2873300c98d35d4d028d53e474b55a96b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9088f2873300c98d35d4d028d53e474b55a96b", "html_url": "https://github.com/rust-lang/rust/commit/cc9088f2873300c98d35d4d028d53e474b55a96b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc9088f2873300c98d35d4d028d53e474b55a96b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "991efa6375e548ff86334916a585a7e36a9d6839", "url": "https://api.github.com/repos/rust-lang/rust/commits/991efa6375e548ff86334916a585a7e36a9d6839", "html_url": "https://github.com/rust-lang/rust/commit/991efa6375e548ff86334916a585a7e36a9d6839"}, {"sha": "350c17de24c0bc7ee1b17981fe02f88ca6ec50a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/350c17de24c0bc7ee1b17981fe02f88ca6ec50a4", "html_url": "https://github.com/rust-lang/rust/commit/350c17de24c0bc7ee1b17981fe02f88ca6ec50a4"}], "stats": {"total": 426, "additions": 426, "deletions": 0}, "files": [{"sha": "facf363e371e0f56e7729e19d0a4ad1246b1f5b6", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -1423,6 +1423,7 @@ Released 2018-09-13\n [`macro_use_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#macro_use_imports\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n+[`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names"}, {"sha": "97785cba8835522dc34bdabdd3b346de004102e6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -247,6 +247,7 @@ mod literal_representation;\n mod loops;\n mod macro_use;\n mod main_recursion;\n+mod manual_non_exhaustive;\n mod map_clone;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -628,6 +629,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::WHILE_LET_ON_ITERATOR,\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n+        &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -1064,6 +1066,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n+    store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1281,6 +1284,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n@@ -1474,6 +1478,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),"}, {"sha": "f3b8902e26f672f4df92b63f07da040c67734b44", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::{snippet_opt, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{Attribute, Item, ItemKind, StructField, Variant, VariantData, VisibilityKind};\n+use rustc_attr as attr;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n+    ///\n+    /// **Why is this bad?** Using the #[non_exhaustive] attribute expresses better the intent\n+    /// and allows possible optimizations when applied to enums.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    ///     _c: (),\n+    /// }\n+    ///\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    ///     #[doc(hidden)]\n+    ///     _C,\n+    /// }\n+    ///\n+    /// struct T(pub i32, pub i32, ());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[non_exhaustive]\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// struct T(pub i32, pub i32);\n+    /// ```\n+    pub MANUAL_NON_EXHAUSTIVE,\n+    style,\n+    \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n+}\n+\n+declare_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+\n+impl EarlyLintPass for ManualNonExhaustive {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        match &item.kind {\n+            ItemKind::Enum(def, _) => {\n+                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n+            },\n+            ItemKind::Struct(variant_data, _) => {\n+                if let VariantData::Unit(..) = variant_data {\n+                    return;\n+                }\n+\n+                check_manual_non_exhaustive_struct(cx, item, variant_data);\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n+    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n+        matches!(variant.data, VariantData::Unit(_))\n+            && variant.ident.as_str().starts_with('_')\n+            && variant.attrs.iter().any(|a| is_doc_hidden(a))\n+    }\n+\n+    fn is_doc_hidden(attr: &Attribute) -> bool {\n+        attr.check_name(sym!(doc))\n+            && match attr.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n+                None => false,\n+            }\n+    }\n+\n+    if_chain! {\n+        let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n+        if let Some(marker) = markers.next();\n+        if markers.count() == 0 && variants.len() > 1;\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                    diag.span_help(marker.span, \"remove this variant\");\n+                });\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n+    fn is_private(field: &StructField) -> bool {\n+        matches!(field.vis.node, VisibilityKind::Inherited)\n+    }\n+\n+    fn is_non_exhaustive_marker(field: &StructField) -> bool {\n+        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+    }\n+\n+    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n+        let delimiter = match data {\n+            VariantData::Struct(..) => '{',\n+            VariantData::Tuple(..) => '(',\n+            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n+        };\n+\n+        cx.sess.source_map().span_until_char(item.span, delimiter)\n+    }\n+\n+    let fields = data.fields();\n+    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n+    let public_fields = fields.iter().filter(|f| f.vis.node.is_pub()).count();\n+\n+    if_chain! {\n+        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n+        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    if_chain! {\n+                        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+                        let header_span = find_header_span(cx, item, data);\n+                        if let Some(snippet) = snippet_opt(cx, header_span);\n+                        then {\n+                            diag.span_suggestion(\n+                                header_span,\n+                                \"add the attribute\",\n+                                format!(\"#[non_exhaustive] {}\", snippet),\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                    diag.span_help(marker.span, \"remove this field\");\n+                });\n+        }\n+    }\n+}"}, {"sha": "a7685f67211f8dc8e460b4265b1c1f63023b64fa", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -1088,6 +1088,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"loops\",\n     },\n+    Lint {\n+        name: \"manual_non_exhaustive\",\n+        group: \"style\",\n+        desc: \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\",\n+        deprecation: None,\n+        module: \"manual_non_exhaustive\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\","}, {"sha": "7a788f4852072022b393541e63edae6bf0d474da", "filename": "tests/ui/manual_non_exhaustive.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/tests%2Fui%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/tests%2Fui%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.rs?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -0,0 +1,137 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+mod enums {\n+    enum E {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // user forgot to remove the marker\n+    #[non_exhaustive]\n+    enum Ep {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // marker variant does not have doc hidden attribute, should be ignored\n+    enum NoDocHidden {\n+        A,\n+        B,\n+        _C,\n+    }\n+\n+    // name of variant with doc hidden does not start with underscore, should be ignored\n+    enum NoUnderscore {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        C,\n+    }\n+\n+    // variant with doc hidden is not unit, should be ignored\n+    enum NotUnit {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C(bool),\n+    }\n+\n+    // variant with doc hidden is the only one, should be ignored\n+    enum OnlyMarker {\n+        #[doc(hidden)]\n+        _A,\n+    }\n+\n+    // variant with multiple markers, should be ignored\n+    enum MultipleMarkers {\n+        A,\n+        #[doc(hidden)]\n+        _B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // already non_exhaustive and no markers, should be ignored\n+    #[non_exhaustive]\n+    enum NonExhaustive {\n+        A,\n+        B,\n+    }\n+}\n+\n+mod structs {\n+    struct S {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Sp {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields {\n+        a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // private field name does not start with underscore, should be ignored\n+    struct NoUnderscore {\n+        pub a: i32,\n+        pub b: i32,\n+        c: (),\n+    }\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: i32,\n+    }\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker {\n+        _a: (),\n+    }\n+\n+    // already non exhaustive and no private fields, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive {\n+        pub a: i32,\n+        pub b: i32,\n+    }\n+}\n+\n+mod tuple_structs {\n+    struct T(pub i32, pub i32, ());\n+\n+    // user forgot to remove the private field\n+    #[non_exhaustive]\n+    struct Tp(pub i32, pub i32, ());\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields(pub i32, i32, ());\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit(pub i32, pub i32, i32);\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker(());\n+\n+    // already non exhaustive and no private fields, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive(pub i32, pub i32);\n+}\n+\n+fn main() {}"}, {"sha": "613c5e8ca1d45b38ec58c9dfc403f4b5abd37e04", "filename": "tests/ui/manual_non_exhaustive.stderr", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cc9088f2873300c98d35d4d028d53e474b55a96b/tests%2Fui%2Fmanual_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc9088f2873300c98d35d4d028d53e474b55a96b/tests%2Fui%2Fmanual_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.stderr?ref=cc9088f2873300c98d35d4d028d53e474b55a96b", "patch": "@@ -0,0 +1,103 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:5:5\n+   |\n+LL |       enum E {\n+   |       ^-----\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:9:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:14:5\n+   |\n+LL | /     enum Ep {\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:18:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:68:5\n+   |\n+LL |       struct S {\n+   |       ^-------\n+   |       |\n+   |  _____help: add the attribute: `#[non_exhaustive] struct S`\n+   | |\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:71:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:76:5\n+   |\n+LL | /     struct Sp {\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:79:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:117:5\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |     --------^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     help: add the attribute: `#[non_exhaustive] struct T`\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:117:32\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |                                ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:121:5\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: remove this field\n+  --> $DIR/manual_non_exhaustive.rs:121:33\n+   |\n+LL |     struct Tp(pub i32, pub i32, ());\n+   |                                 ^^\n+\n+error: aborting due to 6 previous errors\n+"}]}