{"sha": "534f044425d019518b9f7936cbe5955f18157e0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNGYwNDQ0MjVkMDE5NTE4YjlmNzkzNmNiZTU5NTVmMTgxNTdlMGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-10-08T23:26:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-02-06T20:58:00Z"}, "message": "index ReEmpty by universe\n\nWe now make `'empty` indexed by a universe index, resulting\nin a region lattice like this:\n\n```\nstatic ----------+-----...------+       (greatest)\n|                |              |\nearly-bound and  |              |\nfree regions     |              |\n|                |              |\nscope regions    |              |\n|                |              |\nempty(root)   placeholder(U1)   |\n|            /                  |\n|           /         placeholder(Un)\nempty(U1) --         /\n|                   /\n...                /\n|                 /\nempty(Un) --------                      (smallest)\n```\n\nTherefore, `exists<A> { forall<B> { B: A } }` is now unprovable,\nbecause A must be at least Empty(U1) and B is placeholder(U2), and hence\nthe two regions are unrelated.", "tree": {"sha": "e6ec1fc2a4c336baede1083c714dc26d3bde529b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6ec1fc2a4c336baede1083c714dc26d3bde529b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/534f044425d019518b9f7936cbe5955f18157e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/534f044425d019518b9f7936cbe5955f18157e0a", "html_url": "https://github.com/rust-lang/rust/commit/534f044425d019518b9f7936cbe5955f18157e0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/534f044425d019518b9f7936cbe5955f18157e0a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3", "html_url": "https://github.com/rust-lang/rust/commit/b52414fedebe9774bf8a5339eb5042a2fa3dc9a3"}], "stats": {"total": 327, "additions": 269, "deletions": 58}, "files": [{"sha": "844250f51a099536b67d57446d93ab57abb4ab5d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -63,9 +63,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ty::ReErased | ty::ReStatic | ty::ReEmpty => {\n+            ty::ReErased | ty::ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReEmpty(universe) => {\n+                universe.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);"}, {"sha": "48a6c6d7413d195b93635543b559f30ee9b1ebf5", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -167,18 +167,29 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_)\n+            | ty::ReErased\n+            | ty::ReStatic\n+            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n+            | ty::ReEarlyBound(..) => r,\n+\n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(*placeholder) },\n                 r,\n             ),\n+\n             ty::ReVar(vid) => {\n                 let universe = canonicalizer.region_var_universe(*vid);\n                 canonicalizer.canonical_var_for_region(\n                     CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n                     r,\n                 )\n             }\n+\n+            ty::ReEmpty(ui) => {\n+                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n+            }\n+\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -213,7 +224,7 @@ impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReEmpty | ty::ReStatic => r,\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n             _ => {\n                 // We only expect region names that the user can type.\n@@ -320,8 +331,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n+            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) => {"}, {"sha": "2518805a1ecfc618a7dc6b793509e9729349b768", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -577,7 +577,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReScope(..)\n             | ty::ReEarlyBound(..)"}, {"sha": "57a52a991edc85b0767e573e1e161cf452f777c1", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -138,7 +138,10 @@ pub(super) fn note_and_explain_region(\n             msg_span_from_free_region(tcx, region)\n         }\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), None),\n+\n+        // uh oh, hope no user ever sees THIS\n+        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), None),\n \n         ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n@@ -181,7 +184,8 @@ fn msg_span_from_free_region(\n             msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), None),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -375,6 +379,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n+                    RegionResolutionError::UpperBoundUniverseConflict(\n+                        _,\n+                        _,\n+                        var_universe,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        assert!(sup_r.is_placeholder());\n+\n+                        // Make a dummy value for the \"sub region\" --\n+                        // this is the initial value of the\n+                        // placeholder. In practice, we expect more\n+                        // tailored errors that don't really use this\n+                        // value.\n+                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+\n+                        self.report_placeholder_failure(\n+                            region_scope_tree,\n+                            sup_origin,\n+                            sub_r,\n+                            sup_r,\n+                        )\n+                        .emit();\n+                    }\n+\n                     RegionResolutionError::MemberConstraintFailure {\n                         opaque_type_def_id,\n                         hidden_ty,\n@@ -429,6 +458,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n             | RegionResolutionError::SubSupConflict(..)\n+            | RegionResolutionError::UpperBoundUniverseConflict(..)\n             | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n@@ -443,6 +473,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::UpperBoundUniverseConflict(_, ref rvo, _, _, _) => rvo.span(),\n             RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors"}, {"sha": "0b0bd61ce771e770a7dcd2a919aff509b4916ef5", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -107,6 +107,25 @@ impl NiceRegionError<'me, 'tcx> {\n                 found.substs,\n             )),\n \n+            Some(RegionResolutionError::UpperBoundUniverseConflict(\n+                vid,\n+                _,\n+                _,\n+                SubregionOrigin::Subtype(box TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n+\n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace {\n                     cause,"}, {"sha": "cf61cac0ac4bbf9042763ba7196c3e918e6e0afb", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased"}, {"sha": "f4d583d9092ea28d88741cd7788369c23fcd20ed", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -82,6 +82,16 @@ pub enum RegionResolutionError<'tcx> {\n         Region<'tcx>,\n     ),\n \n+    /// Indicates a `'b: 'a` constraint where `'a` is in a universe that\n+    /// cannot name the placeholder `'b`\n+    UpperBoundUniverseConflict(\n+        RegionVid,\n+        RegionVariableOrigin,\n+        ty::UniverseIndex,     // the universe index of the region variable\n+        SubregionOrigin<'tcx>, // cause of the constraint\n+        Region<'tcx>,          // the placeholder `'b`\n+    ),\n+\n     /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n@@ -149,7 +159,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n+            values: IndexVec::from_fn_n(\n+                |vid| {\n+                    let vid_universe = self.var_infos[vid].universe;\n+                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n+                    VarValue::Value(re_empty)\n+                },\n+                self.num_vars(),\n+            ),\n         }\n     }\n \n@@ -381,8 +398,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n-                if let ReEmpty = a_region {\n-                    return false;\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ReEmpty(a_universe) = a_region {\n+                    if *a_universe == b_universe {\n+                        return false;\n+                    }\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -399,7 +419,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                let b_universe = self.var_infos[b_vid].universe;\n                 if let ty::RePlaceholder(p) = lub {\n                     if b_universe.cannot_name(p.universe) {\n                         lub = self.tcx().lifetimes.re_static;\n@@ -445,7 +464,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         self.lub_concrete_regions(a, b) == b\n     }\n \n-    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n+    /// Returns the least-upper-bound of `a` and `b`; i.e., the\n+    /// smallest region `c` such that `a <= c` and `b <= c`.\n+    ///\n+    /// Neither `a` nor `b` may be an inference variable (hence the\n+    /// term \"concrete regions\").\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let r = match (a, b) {\n             (&ty::ReClosureBound(..), _)\n@@ -457,14 +480,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n                     self.var_infos[v_id].origin.span(),\n@@ -475,6 +490,41 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 );\n             }\n \n+            (&ReStatic, _) | (_, &ReStatic) => {\n+                // nothing lives longer than static\n+                self.tcx().lifetimes.re_static\n+            }\n+\n+            (&ReEmpty(_), r @ ReEarlyBound(_))\n+            | (r @ ReEarlyBound(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReFree(_))\n+            | (r @ ReFree(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReScope(_))\n+            | (r @ ReScope(_), &ReEmpty(_)) => {\n+                // all empty regions are less than early-bound, free,\n+                // and scope regions\n+                r\n+            }\n+\n+            (&ReEmpty(a_ui), &ReEmpty(b_ui)) => {\n+                // empty regions are ordered according to the universe\n+                // they are associated with\n+                let ui = a_ui.min(b_ui);\n+                self.tcx().mk_region(ReEmpty(ui))\n+            }\n+\n+            (&ReEmpty(empty_ui), &RePlaceholder(placeholder))\n+            | (&RePlaceholder(placeholder), &ReEmpty(empty_ui)) => {\n+                // If this empty region is from a universe that can\n+                // name the placeholder, then the placeholder is\n+                // larger; otherwise, the only ancestor is `'static`.\n+                if empty_ui.can_name(placeholder.universe) {\n+                    self.tcx().mk_region(RePlaceholder(placeholder))\n+                } else {\n+                    self.tcx().lifetimes.re_static\n+                }\n+            }\n+\n             (&ReEarlyBound(_), &ReScope(s_id))\n             | (&ReScope(s_id), &ReEarlyBound(_))\n             | (&ReFree(_), &ReScope(s_id))\n@@ -800,6 +850,26 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n+        // 'a } }`, we wind up without any lower-bound -- all we have\n+        // are placeholders as upper bounds, but the universe of the\n+        // variable `'a` doesn't permit those placeholders.\n+        for upper_bound in &upper_bounds {\n+            if let ty::RePlaceholder(p) = upper_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    let origin = self.var_infos[node_idx].origin.clone();\n+                    errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n+                        node_idx,\n+                        origin,\n+                        node_universe,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Errors in earlier passes can yield error variables without\n         // resolution errors here; delay ICE in favor of those errors.\n         self.tcx().sess.delay_span_bug(\n@@ -914,7 +984,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::IsEmpty => {\n-                if let ty::ReEmpty = min {\n+                if let ty::ReEmpty(_) = min {\n                     true\n                 } else {\n                     false"}, {"sha": "fab753bb0f4c190c071ca7e97da698acd63566f6", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -611,7 +611,7 @@ pub fn unexpected_hidden_region_diagnostic(\n     );\n \n     // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n         // Assuming regionck succeeded (*), we ought to always be\n         // capturing *some* region from the fn header, and hence it\n         // ought to be free. So under normal circumstances, we will go\n@@ -843,7 +843,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                         .emit();\n                     }\n                 }\n-                self.tcx.lifetimes.re_empty\n+                self.tcx.lifetimes.re_root_empty\n             }\n             None => {\n                 self.tcx"}, {"sha": "2c580e2e3490a4e0bcef02a6aa1e8c6727cb8bdc", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -795,10 +795,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         match *region {\n             ty::ReScope(..)\n             | ty::ReStatic\n-            | ty::ReEmpty\n             | ty::ReErased\n             | ty::ReFree(..)\n             | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),"}, {"sha": "d56d4fa14855dce1aded41d47b3c7ecf7dd926bd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -173,8 +173,13 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct CommonLifetimes<'tcx> {\n-    pub re_empty: Region<'tcx>,\n+    /// ReEmpty in the root universe\n+    pub re_root_empty: Region<'tcx>,\n+\n+    /// ReStatic\n     pub re_static: Region<'tcx>,\n+\n+    /// Erased region, used after type-checking\n     pub re_erased: Region<'tcx>,\n }\n \n@@ -876,7 +881,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n         let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n \n         CommonLifetimes {\n-            re_empty: mk(RegionKind::ReEmpty),\n+            re_root_empty: mk(RegionKind::ReEmpty(ty::UniverseIndex::ROOT)),\n             re_static: mk(RegionKind::ReStatic),\n             re_erased: mk(RegionKind::ReErased),\n         }"}, {"sha": "0da680d1f915ee8c872640a41277d28a25e78276", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -1382,7 +1382,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n             ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n \n-            ty::ReStatic | ty::ReEmpty | ty::ReClosureBound(_) => true,\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n         }\n     }\n }\n@@ -1464,10 +1464,14 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                 p!(write(\"'static\"));\n                 return Ok(self);\n             }\n-            ty::ReEmpty => {\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n                 p!(write(\"'<empty>\"));\n                 return Ok(self);\n             }\n+            ty::ReEmpty(ui) => {\n+                p!(write(\"'<empty:{:?}>\", ui));\n+                return Ok(self);\n+            }\n \n             // The user should never encounter these in unsubstituted form.\n             ty::ReClosureBound(vid) => {"}, {"sha": "a56684ee8e974ab75389eb40294936b368c9f559", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -108,7 +108,7 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+            ty::ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n \n             ty::ReErased => write!(f, \"ReErased\"),\n         }"}, {"sha": "c0ee14192ff7d25038e345768cfdec3314dcd84c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -1269,11 +1269,67 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of regions.\n+/// Representation of (lexical) regions. Note that the NLL checker\n+/// uses a distinct representation of regions. For this reason, it\n+/// internally replaces all the regions with inference variables --\n+/// the index of the variable is then used to index into internal NLL\n+/// data structures. See `rustc_mir::borrow_check` module for more\n+/// information.\n ///\n-/// Unlike types, most region variants are \"fictitious\", not concrete,\n-/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n-/// ones representing concrete regions.\n+/// ## The Region lattice within a given function\n+///\n+/// In general, the (lexical, and hence deprecated) region lattice\n+/// looks like\n+///\n+/// ```\n+/// static ----------+-----...------+       (greatest)\n+/// |                |              |\n+/// early-bound and  |              |\n+/// free regions     |              |\n+/// |                |              |\n+/// scope regions    |              |\n+/// |                |              |\n+/// empty(root)   placeholder(U1)   |\n+/// |            /                  |\n+/// |           /         placeholder(Un)\n+/// empty(U1) --         /\n+/// |                   /\n+/// ...                /\n+/// |                 /\n+/// empty(Un) --------                      (smallest)\n+/// ```\n+///\n+/// Early-bound/free regions are the named lifetimes in scope from the\n+/// function declaration. They have relationships to one another\n+/// determined based on the declared relationships from the\n+/// function. They all collectively outlive the scope regions. (See\n+/// `RegionRelations` type, and particularly\n+/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n+///\n+/// The scope regions are related to one another based on the AST\n+/// structure. (See `RegionRelations` type, and particularly the\n+/// `rustc::middle::region::ScopeTree`.)\n+///\n+/// Note that inference variables and bound regions are not included\n+/// in this diagram. In the case of inference variables, they should\n+/// be inferred to some other region from the diagram.  In the case of\n+/// bound regions, they are excluded because they don't make sense to\n+/// include -- the diagram indicates the relationship between free\n+/// regions.\n+///\n+/// ## Inference variables\n+///\n+/// During region inference, we sometimes create inference variables,\n+/// represented as `ReVar`. These will be inferred by the code in\n+/// `infer::lexical_region_resolve` to some free region from the\n+/// lattice above (the minimal region that meets the\n+/// constraints).\n+///\n+/// During NLL checking, where regions are defined differently, we\n+/// also use `ReVar` -- in that case, the index is used to index into\n+/// the NLL region checker's data structures. The variable may in fact\n+/// represent either a free region or an inference variable, in that\n+/// case.\n ///\n /// ## Bound Regions\n ///\n@@ -1356,14 +1412,13 @@ pub enum RegionKind {\n     /// Should not exist after typeck.\n     RePlaceholder(ty::PlaceholderRegion),\n \n-    /// Empty lifetime is for data that is never accessed.\n-    /// Bottom in the region lattice. We treat ReEmpty somewhat\n-    /// specially; at least right now, we do not generate instances of\n-    /// it during the GLB computations, but rather\n-    /// generate an error instead. This is to improve error messages.\n-    /// The only way to get an instance of ReEmpty is to have a region\n-    /// variable with no constraints.\n-    ReEmpty,\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe U is less than all\n+    /// regions visible from U, but not less than regions not visible\n+    /// from U.\n+    ReEmpty(ty::UniverseIndex),\n \n     /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n@@ -1612,7 +1667,7 @@ impl RegionKind {\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n-            RegionKind::ReEmpty => false,\n+            RegionKind::ReEmpty(_) => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n         }\n@@ -1695,7 +1750,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_EARLY_BOUND;\n             }\n-            ty::ReEmpty | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n             ty::ReErased => {}\n@@ -1705,7 +1760,7 @@ impl RegionKind {\n         }\n \n         match *self {\n-            ty::ReStatic | ty::ReEmpty | ty::ReErased | ty::ReLateBound(..) => (),\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReErased | ty::ReLateBound(..) => (),\n             _ => flags = flags | TypeFlags::HAS_FREE_LOCAL_NAMES,\n         }\n "}, {"sha": "1dfe97238a3df8b7f6235f08b0383733d7e86992", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -574,6 +574,14 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: vec![elem; n], _marker: PhantomData }\n     }\n \n+    /// Create an `IndexVec` with `n` elements, where the value of each\n+    /// element is the result of `func(i)`\n+    #[inline]\n+    pub fn from_fn_n(func: impl FnMut(I) -> T, n: usize) -> Self {\n+        let indices = (0..n).map(I::new);\n+        Self::from_raw(indices.map(func).collect())\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());"}, {"sha": "09d61d9ad9ad130e5836cc98b4c6137c89ebc583", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased\n             | ty::ReClosureBound(..) => None,\n         }"}, {"sha": "a3e38cd7a5f856deb6096b0e62e08e00cf76ec72", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -160,7 +160,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME -- this is not the fix I would prefer\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let b = self.to_region_vid(b);\n@@ -175,7 +176,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME: I'd prefer if NLL had a notion of empty\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let type_test = self.verify_to_type_test(kind, a, bound);"}, {"sha": "cf8c3449d666be4476f3fc2df59c868c02f2b2cd", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -333,7 +333,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                     // `where Type:` is lowered to `where Type: 'empty` so that\n                     // we check `Type` is well formed, but there's no use for\n                     // this bound here.\n-                    if let ty::ReEmpty = r1 {\n+                    if let ty::ReEmpty(_) = r1 {\n                         return;\n                     }\n "}, {"sha": "301ebf8adc5c700086ba7977bc8d5dab4b80b29c", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -246,9 +246,11 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n                 assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n             }\n \n-            (ty::ReStatic, ty::ReStatic)\n-            | (ty::ReErased, ty::ReErased)\n-            | (ty::ReEmpty, ty::ReEmpty) => (),\n+            (ty::ReStatic, ty::ReStatic) | (ty::ReErased, ty::ReErased) => (),\n+\n+            (ty::ReEmpty(a_ui), ty::ReEmpty(b_ui)) => {\n+                assert_eq!(a_ui, b_ui);\n+            }\n \n             (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n                 assert_eq!(a_free, b_free);"}, {"sha": "713f41311a6960a2f50c1a3410bf2aac7cfc22c2", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -2322,7 +2322,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        let predicate = ty::OutlivesPredicate(ty, tcx.mk_region(ty::ReEmpty));\n+                        let re_root_empty = tcx.lifetimes.re_root_empty;\n+                        let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n                             ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)),\n                             span,"}, {"sha": "0cc322f8c2d3da900a4d66542a44106acc02f619", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -166,7 +166,7 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n         //\n         //     struct Bar<T>(<Self as Foo>::Type) where Self: ;\n         //     struct Baz<'a>(&'a Self) where Self: ;\n-        RegionKind::ReEmpty => false,\n+        RegionKind::ReEmpty(_) => false,\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased"}, {"sha": "6f5caea250b0719efda46dc9f36d521b529f132b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types."}, {"sha": "f140f11b090980ec295ba17176dfee9013440354", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/534f044425d019518b9f7936cbe5955f18157e0a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=534f044425d019518b9f7936cbe5955f18157e0a", "patch": "@@ -447,7 +447,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReClosureBound(_)\n             | ty::ReErased => {\n                 debug!(\"cannot clean region {:?}\", self);\n@@ -521,7 +521,7 @@ impl<'tcx> Clean<Option<WherePredicate>>\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n-            (ty::ReEmpty, ty::ReEmpty) => {\n+            (ty::ReEmpty(_), ty::ReEmpty(_)) => {\n                 return None;\n             }\n             _ => {}\n@@ -539,7 +539,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n-            ty::ReEmpty => return None,\n+            ty::ReEmpty(_) => return None,\n             _ => {}\n         }\n "}]}