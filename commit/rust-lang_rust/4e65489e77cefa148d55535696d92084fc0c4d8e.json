{"sha": "4e65489e77cefa148d55535696d92084fc0c4d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNjU0ODllNzdjZWZhMTQ4ZDU1NTM1Njk2ZDkyMDg0ZmMwYzRkOGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-10-12T17:15:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-10-12T21:07:55Z"}, "message": "Rollup merge of #37049 - srinivasreddy:librustc_lint, r=nrc\n\nrun rustfmt on librustc_lint folder", "tree": {"sha": "5fdf73482ab9b355a7112caba608dc105f07435b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fdf73482ab9b355a7112caba608dc105f07435b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e65489e77cefa148d55535696d92084fc0c4d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e65489e77cefa148d55535696d92084fc0c4d8e", "html_url": "https://github.com/rust-lang/rust/commit/4e65489e77cefa148d55535696d92084fc0c4d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e65489e77cefa148d55535696d92084fc0c4d8e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65fc3ef1f4eeefbde4fd2592f1907c922181bfa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/65fc3ef1f4eeefbde4fd2592f1907c922181bfa8", "html_url": "https://github.com/rust-lang/rust/commit/65fc3ef1f4eeefbde4fd2592f1907c922181bfa8"}, {"sha": "bf5dfacddea8cf6d82d2f2c5f014b45cc9ffe60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf5dfacddea8cf6d82d2f2c5f014b45cc9ffe60d", "html_url": "https://github.com/rust-lang/rust/commit/bf5dfacddea8cf6d82d2f2c5f014b45cc9ffe60d"}], "stats": {"total": 1080, "additions": 601, "deletions": 479}, "files": [{"sha": "acb92bec7c7971bd7ab305148ad6329c428156fe", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=4e65489e77cefa148d55535696d92084fc0c4d8e", "patch": "@@ -24,19 +24,21 @@ use rustc::hir::intravisit::FnKind;\n pub enum MethodLateContext {\n     TraitDefaultImpl,\n     TraitImpl,\n-    PlainImpl\n+    PlainImpl,\n }\n \n pub fn method_context(cx: &LateContext, id: ast::NodeId, span: Span) -> MethodLateContext {\n     let def_id = cx.tcx.map.local_def_id(id);\n     match cx.tcx.impl_or_trait_items.borrow().get(&def_id) {\n         None => span_bug!(span, \"missing method descriptor?!\"),\n-        Some(item) => match item.container() {\n-            ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n-            ty::ImplContainer(cid) => {\n-                match cx.tcx.impl_trait_ref(cid) {\n-                    Some(_) => MethodLateContext::TraitImpl,\n-                    None => MethodLateContext::PlainImpl\n+        Some(item) => {\n+            match item.container() {\n+                ty::TraitContainer(..) => MethodLateContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match cx.tcx.impl_trait_ref(cid) {\n+                        Some(_) => MethodLateContext::TraitImpl,\n+                        None => MethodLateContext::PlainImpl,\n+                    }\n                 }\n             }\n         }\n@@ -63,29 +65,35 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            !name.is_empty() &&\n-                !name.chars().next().unwrap().is_lowercase() &&\n-                !name.contains('_')\n+            !name.is_empty() && !name.chars().next().unwrap().is_lowercase() && !name.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n-            s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 {\n-                    c.to_uppercase().collect::<String>()\n-                } else {\n-                    c.to_lowercase().collect()\n-                }\n-            )).collect::<Vec<_>>().concat()\n+            s.split('_')\n+                .flat_map(|word| {\n+                    word.chars().enumerate().map(|(i, c)| if i == 0 {\n+                        c.to_uppercase().collect::<String>()\n+                    } else {\n+                        c.to_lowercase().collect()\n+                    })\n+                })\n+                .collect::<Vec<_>>()\n+                .concat()\n         }\n \n         let s = name.as_str();\n \n         if !is_camel_case(name) {\n             let c = to_camel_case(&s);\n             let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, s)\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\",\n+                        sort,\n+                        s)\n             } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n+                format!(\"{} `{}` should have a camel case name such as `{}`\",\n+                        sort,\n+                        s,\n+                        c)\n             };\n             cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n@@ -100,23 +108,25 @@ impl LintPass for NonCamelCaseTypes {\n \n impl LateLintPass for NonCamelCaseTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        let extern_repr_count = it.attrs.iter().filter(|attr| {\n-            attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n-                .any(|r| r == &attr::ReprExtern)\n-        }).count();\n+        let extern_repr_count = it.attrs\n+            .iter()\n+            .filter(|attr| {\n+                attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr)\n+                    .iter()\n+                    .any(|r| r == &attr::ReprExtern)\n+            })\n+            .count();\n         let has_extern_repr = extern_repr_count > 0;\n \n         if has_extern_repr {\n             return;\n         }\n \n         match it.node {\n-            hir::ItemTy(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n-                self.check_case(cx, \"type\", it.name, it.span)\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_case(cx, \"trait\", it.name, it.span)\n-            }\n+            hir::ItemTy(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => self.check_case(cx, \"type\", it.name, it.span),\n+            hir::ItemTrait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n             hir::ItemEnum(ref enum_definition, _) => {\n                 if has_extern_repr {\n                     return;\n@@ -126,7 +136,7 @@ impl LateLintPass for NonCamelCaseTypes {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -165,9 +175,7 @@ impl NonSnakeCase {\n                 continue;\n             }\n             for ch in s.chars() {\n-                if !buf.is_empty() && buf != \"'\"\n-                                   && ch.is_uppercase()\n-                                   && !last_upper {\n+                if !buf.is_empty() && buf != \"'\" && ch.is_uppercase() && !last_upper {\n                     words.push(buf);\n                     buf = String::new();\n                 }\n@@ -205,10 +213,11 @@ impl NonSnakeCase {\n             let sc = NonSnakeCase::to_snake_case(name);\n             let msg = if sc != name {\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, name, sc)\n+                        sort,\n+                        name,\n+                        sc)\n             } else {\n-                format!(\"{} `{}` should have a snake case name\",\n-                        sort, name)\n+                format!(\"{} `{}` should have a snake case name\", sort, name)\n             };\n             match span {\n                 Some(span) => cx.span_lint(NON_SNAKE_CASE, span, &msg),\n@@ -226,31 +235,39 @@ impl LintPass for NonSnakeCase {\n \n impl LateLintPass for NonSnakeCase {\n     fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n-        let attr_crate_name = cr.attrs.iter().find(|at| at.check_name(\"crate_name\"))\n-                                      .and_then(|at| at.value_str().map(|s| (at, s)));\n+        let attr_crate_name = cr.attrs\n+            .iter()\n+            .find(|at| at.check_name(\"crate_name\"))\n+            .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);\n         } else if let Some((attr, ref name)) = attr_crate_name {\n             self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext,\n-                fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fk: FnKind,\n+                _: &hir::FnDecl,\n+                _: &hir::Block,\n+                span: Span,\n+                id: ast::NodeId) {\n         match fk {\n-            FnKind::Method(name, ..) => match method_context(cx, id, span) {\n-                MethodLateContext::PlainImpl => {\n-                    self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n-                },\n-                MethodLateContext::TraitDefaultImpl => {\n-                    self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n-                },\n-                _ => (),\n-            },\n+            FnKind::Method(name, ..) => {\n+                match method_context(cx, id, span) {\n+                    MethodLateContext::PlainImpl => {\n+                        self.check_snake_case(cx, \"method\", &name.as_str(), Some(span))\n+                    }\n+                    MethodLateContext::TraitDefaultImpl => {\n+                        self.check_snake_case(cx, \"trait method\", &name.as_str(), Some(span))\n+                    }\n+                    _ => (),\n+                }\n+            }\n             FnKind::ItemFn(name, ..) => {\n                 self.check_snake_case(cx, \"function\", &name.as_str(), Some(span))\n-            },\n+            }\n             FnKind::Closure(_) => (),\n         }\n     }\n@@ -263,13 +280,17 @@ impl LateLintPass for NonSnakeCase {\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(_, None) = trait_item.node {\n-            self.check_snake_case(cx, \"trait method\", &trait_item.name.as_str(),\n+            self.check_snake_case(cx,\n+                                  \"trait method\",\n+                                  &trait_item.name.as_str(),\n                                   Some(trait_item.span));\n         }\n     }\n \n     fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n-        self.check_snake_case(cx, \"lifetime\", &t.lifetime.name.as_str(),\n+        self.check_snake_case(cx,\n+                              \"lifetime\",\n+                              &t.lifetime.name.as_str(),\n                               Some(t.lifetime.span));\n     }\n \n@@ -282,8 +303,12 @@ impl LateLintPass for NonSnakeCase {\n         }\n     }\n \n-    fn check_struct_def(&mut self, cx: &LateContext, s: &hir::VariantData,\n-                        _: ast::Name, _: &hir::Generics, _: ast::NodeId) {\n+    fn check_struct_def(&mut self,\n+                        cx: &LateContext,\n+                        s: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        _: ast::NodeId) {\n         for sf in s.fields() {\n             self.check_snake_case(cx, \"structure field\", &sf.name.as_str(), Some(sf.span));\n         }\n@@ -306,13 +331,16 @@ impl NonUpperCaseGlobals {\n         if s.chars().any(|c| c.is_lowercase()) {\n             let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n             if uc != &s[..] {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name such as `{}`\",\n-                             sort, s, uc));\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS,\n+                             span,\n+                             &format!(\"{} `{}` should have an upper case name such as `{}`\",\n+                                      sort,\n+                                      s,\n+                                      uc));\n             } else {\n-                cx.span_lint(NON_UPPER_CASE_GLOBALS, span,\n-                    &format!(\"{} `{}` should have an upper case name\",\n-                             sort, s));\n+                cx.span_lint(NON_UPPER_CASE_GLOBALS,\n+                             span,\n+                             &format!(\"{} `{}` should have an upper case name\", sort, s));\n             }\n         }\n     }\n@@ -341,8 +369,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::ConstTraitItem(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ti.name, ti.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -351,8 +378,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n-                                                      ii.name, ii.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ii.name, ii.span);\n             }\n             _ => {}\n         }\n@@ -363,8 +389,10 @@ impl LateLintPass for NonUpperCaseGlobals {\n         if let PatKind::Path(None, ref path) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n                 if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n-                    NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                          path.segments[0].name, path.span);\n+                    NonUpperCaseGlobals::check_upper_case(cx,\n+                                                          \"constant in pattern\",\n+                                                          path.segments[0].name,\n+                                                          path.span);\n                 }\n             }\n         }"}, {"sha": "3428ec8d4c9602ffc2ac2a41a16778499da31832", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 176, "deletions": 126, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4e65489e77cefa148d55535696d92084fc0c4d8e", "patch": "@@ -37,15 +37,15 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n-use util::nodemap::{NodeSet};\n+use util::nodemap::NodeSet;\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n use lint::{LintPass, LateLintPass};\n \n use std::collections::HashSet;\n \n-use syntax::{ast};\n+use syntax::ast;\n use syntax::attr;\n-use syntax_pos::{Span};\n+use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::FnKind;\n@@ -75,7 +75,8 @@ impl LateLintPass for WhileTrue {\n         if let hir::ExprWhile(ref cond, ..) = e.node {\n             if let hir::ExprLit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n-                    cx.span_lint(WHILE_TRUE, e.span,\n+                    cx.span_lint(WHILE_TRUE,\n+                                 e.span,\n                                  \"denote infinite loops with loop { ... }\");\n                 }\n             }\n@@ -93,8 +94,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>,\n-                                 span: Span, ty: Ty<'tcx>) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'a, 'tcx>, span: Span, ty: Ty<'tcx>) {\n         for leaf_ty in ty.walk() {\n             if let ty::TyBox(_) = leaf_ty.sty {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n@@ -117,22 +117,21 @@ impl LateLintPass for BoxPointers {\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n             hir::ItemStruct(..) |\n-            hir::ItemUnion(..) =>\n-                self.check_heap_type(cx, it.span,\n-                                     cx.tcx.node_id_to_type(it.id)),\n-            _ => ()\n+            hir::ItemUnion(..) => self.check_heap_type(cx, it.span, cx.tcx.node_id_to_type(it.id)),\n+            _ => (),\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n             hir::ItemStruct(ref struct_def, _) |\n             hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n-                    self.check_heap_type(cx, struct_field.span,\n+                    self.check_heap_type(cx,\n+                                         struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.id));\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n     }\n \n@@ -166,9 +165,11 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node == fieldpat.node.name {\n-                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n+                        cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n+                                     fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node))\n+                                              be removed\",\n+                                              ident.node))\n                     }\n                 }\n             }\n@@ -203,27 +204,35 @@ impl LateLintPass for UnsafeCode {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemTrait(hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n+            hir::ItemTrait(hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\")\n+            }\n \n-            hir::ItemImpl(hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n+            hir::ItemImpl(hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\")\n+            }\n \n             _ => return,\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext, fk: FnKind, _: &hir::FnDecl,\n-                _: &hir::Block, span: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fk: FnKind,\n+                _: &hir::FnDecl,\n+                _: &hir::Block,\n+                span: Span,\n+                _: ast::NodeId) {\n         match fk {\n-            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) =>\n-                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n+            FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) => {\n+                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\")\n+            }\n \n             FnKind::Method(_, sig, ..) => {\n                 if sig.unsafety == hir::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n-            },\n+            }\n \n             _ => (),\n         }\n@@ -232,7 +241,8 @@ impl LateLintPass for UnsafeCode {\n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n         if let hir::MethodTraitItem(ref sig, None) = trait_item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n-                cx.span_lint(UNSAFE_CODE, trait_item.span,\n+                cx.span_lint(UNSAFE_CODE,\n+                             trait_item.span,\n                              \"declaration of an `unsafe` method\")\n             }\n         }\n@@ -263,9 +273,9 @@ pub struct MissingDoc {\n impl MissingDoc {\n     pub fn new() -> MissingDoc {\n         MissingDoc {\n-            struct_def_stack: vec!(),\n+            struct_def_stack: vec![],\n             in_variant: false,\n-            doc_hidden_stack: vec!(false),\n+            doc_hidden_stack: vec![false],\n             private_traits: HashSet::new(),\n         }\n     }\n@@ -275,11 +285,11 @@ impl MissingDoc {\n     }\n \n     fn check_missing_docs_attrs(&self,\n-                               cx: &LateContext,\n-                               id: Option<ast::NodeId>,\n-                               attrs: &[ast::Attribute],\n-                               sp: Span,\n-                               desc: &'static str) {\n+                                cx: &LateContext,\n+                                id: Option<ast::NodeId>,\n+                                attrs: &[ast::Attribute],\n+                                sp: Span,\n+                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n         if cx.sess().opts.test {\n@@ -302,7 +312,8 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n         if !has_doc {\n-            cx.span_lint(MISSING_DOCS, sp,\n+            cx.span_lint(MISSING_DOCS,\n+                         sp,\n                          &format!(\"missing documentation for {}\", desc));\n         }\n     }\n@@ -316,8 +327,10 @@ impl LintPass for MissingDoc {\n \n impl LateLintPass for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n-        let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n-            attr.check_name(\"doc\") && match attr.meta_item_list() {\n+        let doc_hidden = self.doc_hidden() ||\n+                         attrs.iter().any(|attr| {\n+            attr.check_name(\"doc\") &&\n+            match attr.meta_item_list() {\n                 None => false,\n                 Some(l) => attr::list_contains_name(&l[..], \"hidden\"),\n             }\n@@ -329,13 +342,21 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &LateContext, _: &hir::VariantData,\n-                        _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n+    fn check_struct_def(&mut self,\n+                        _: &LateContext,\n+                        _: &hir::VariantData,\n+                        _: ast::Name,\n+                        _: &hir::Generics,\n+                        item_id: ast::NodeId) {\n         self.struct_def_stack.push(item_id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &LateContext, _: &hir::VariantData,\n-                             _: ast::Name, _: &hir::Generics, item_id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self,\n+                             _: &LateContext,\n+                             _: &hir::VariantData,\n+                             _: ast::Name,\n+                             _: &hir::Generics,\n+                             item_id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == item_id);\n     }\n@@ -358,47 +379,53 @@ impl LateLintPass for MissingDoc {\n                     for itm in items {\n                         self.private_traits.insert(itm.id);\n                     }\n-                    return\n+                    return;\n                 }\n                 \"a trait\"\n-            },\n+            }\n             hir::ItemTy(..) => \"a type alias\",\n             hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_items) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n-                        Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n-                            for itm in impl_items {\n-                                self.private_traits.insert(itm.id);\n+                        Some(hir_map::NodeItem(item)) => {\n+                            if item.vis == hir::Visibility::Inherited {\n+                                for itm in impl_items {\n+                                    self.private_traits.insert(itm.id);\n+                                }\n                             }\n-                        },\n-                        _ => { }\n+                        }\n+                        _ => {}\n                     }\n                 }\n-                return\n-            },\n+                return;\n+            }\n             hir::ItemConst(..) => \"a constant\",\n             hir::ItemStatic(..) => \"a static\",\n-            _ => return\n+            _ => return,\n         };\n \n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n-        if self.private_traits.contains(&trait_item.id) { return }\n+        if self.private_traits.contains(&trait_item.id) {\n+            return;\n+        }\n \n         let desc = match trait_item.node {\n             hir::ConstTraitItem(..) => \"an associated constant\",\n             hir::MethodTraitItem(..) => \"a trait method\",\n             hir::TypeTraitItem(..) => \"an associated type\",\n         };\n \n-        self.check_missing_docs_attrs(cx, Some(trait_item.id),\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(trait_item.id),\n                                       &trait_item.attrs,\n-                                      trait_item.span, desc);\n+                                      trait_item.span,\n+                                      desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n@@ -412,26 +439,34 @@ impl LateLintPass for MissingDoc {\n             hir::ImplItemKind::Method(..) => \"a method\",\n             hir::ImplItemKind::Type(_) => \"an associated type\",\n         };\n-        self.check_missing_docs_attrs(cx, Some(impl_item.id),\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(impl_item.id),\n                                       &impl_item.attrs,\n-                                      impl_item.span, desc);\n+                                      impl_item.span,\n+                                      desc);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             if sf.vis == hir::Public || self.in_variant {\n-                let cur_struct_def = *self.struct_def_stack.last()\n+                let cur_struct_def = *self.struct_def_stack\n+                    .last()\n                     .expect(\"empty struct_def_stack\");\n-                self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              &sf.attrs, sf.span,\n+                self.check_missing_docs_attrs(cx,\n+                                              Some(cur_struct_def),\n+                                              &sf.attrs,\n+                                              sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.data.id()),\n-                                      &v.node.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx,\n+                                      Some(v.node.data.id()),\n+                                      &v.node.attrs,\n+                                      v.span,\n+                                      \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n@@ -486,7 +521,9 @@ impl LateLintPass for MissingCopyImplementations {\n             }\n             _ => return,\n         };\n-        if def.has_dtor() { return; }\n+        if def.has_dtor() {\n+            return;\n+        }\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n         // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n         // method\n@@ -514,9 +551,7 @@ pub struct MissingDebugImplementations {\n \n impl MissingDebugImplementations {\n     pub fn new() -> MissingDebugImplementations {\n-        MissingDebugImplementations {\n-            impling_types: None,\n-        }\n+        MissingDebugImplementations { impling_types: None }\n     }\n }\n \n@@ -533,7 +568,9 @@ impl LateLintPass for MissingDebugImplementations {\n         }\n \n         match item.node {\n-            hir::ItemStruct(..) | hir::ItemUnion(..) | hir::ItemEnum(..) => {},\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) |\n+            hir::ItemEnum(..) => {}\n             _ => return,\n         }\n \n@@ -585,12 +622,13 @@ pub struct Deprecated {\n \n impl Deprecated {\n     pub fn new() -> Deprecated {\n-        Deprecated {\n-            current_item: ast::CRATE_NODE_ID,\n-        }\n+        Deprecated { current_item: ast::CRATE_NODE_ID }\n     }\n \n-    fn lint(&self, cx: &LateContext, _id: DefId, span: Span,\n+    fn lint(&self,\n+            cx: &LateContext,\n+            _id: DefId,\n+            span: Span,\n             stability: &Option<&attr::Stability>,\n             deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n@@ -641,37 +679,41 @@ impl LintPass for Deprecated {\n impl LateLintPass for Deprecated {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         self.push_item(item.id);\n-        stability::check_item(cx.tcx, item, false,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_item(cx.tcx,\n+                              item,\n+                              false,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_item_post(&mut self, cx: &LateContext, item: &hir::Item) {\n         self.item_post(cx, item.id);\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        stability::check_expr(cx.tcx, e,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_expr(cx.tcx,\n+                              e,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n-        stability::check_path(cx.tcx, path, id,\n-                              &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_path(cx.tcx,\n+                              path,\n+                              id,\n+                              &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_path_list_item(&mut self, cx: &LateContext, item: &hir::PathListItem) {\n-        stability::check_path_list_item(cx.tcx, item,\n-                                         &mut |id, sp, stab, depr|\n-                                           self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_path_list_item(cx.tcx,\n+                                        item,\n+                                        &mut |id, sp, stab, depr| {\n+                                            self.lint(cx, id, sp, &stab, &depr)\n+                                        });\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n-        stability::check_pat(cx.tcx, pat,\n-                             &mut |id, sp, stab, depr|\n-                                self.lint(cx, id, sp, &stab, &depr));\n+        stability::check_pat(cx.tcx,\n+                             pat,\n+                             &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n     fn check_impl_item(&mut self, _: &LateContext, item: &hir::ImplItem) {\n@@ -716,15 +758,20 @@ impl LintPass for UnconditionalRecursion {\n }\n \n impl LateLintPass for UnconditionalRecursion {\n-    fn check_fn(&mut self, cx: &LateContext, fn_kind: FnKind, _: &hir::FnDecl,\n-                blk: &hir::Block, sp: Span, id: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                fn_kind: FnKind,\n+                _: &hir::FnDecl,\n+                blk: &hir::Block,\n+                sp: Span,\n+                id: ast::NodeId) {\n         let method = match fn_kind {\n             FnKind::ItemFn(..) => None,\n             FnKind::Method(..) => {\n                 cx.tcx.impl_or_trait_item(cx.tcx.map.local_def_id(id)).as_opt_method()\n             }\n             // closures can't recur, so they don't matter.\n-            FnKind::Closure(_) => return\n+            FnKind::Closure(_) => return,\n         };\n \n         // Walk through this function (say `f`) looking to see if\n@@ -779,10 +826,8 @@ impl LateLintPass for UnconditionalRecursion {\n             // is this a recursive call?\n             let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n                 match method {\n-                    Some(ref method) => {\n-                        expr_refers_to_this_method(cx.tcx, method, node_id)\n-                    }\n-                    None => expr_refers_to_this_fn(cx.tcx, id, node_id)\n+                    Some(ref method) => expr_refers_to_this_method(cx.tcx, method, node_id),\n+                    None => expr_refers_to_this_fn(cx.tcx, id, node_id),\n                 }\n             } else {\n                 false\n@@ -808,7 +853,8 @@ impl LateLintPass for UnconditionalRecursion {\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n-            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION, sp,\n+            let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION,\n+                                             sp,\n                                              \"function cannot return without recurring\");\n \n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n@@ -829,23 +875,21 @@ impl LateLintPass for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: TyCtxt,\n-                                  fn_id: ast::NodeId,\n-                                  id: ast::NodeId) -> bool {\n+        fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.expect_def_or_none(callee.id).map_or(false, |def| {\n-                        def.def_id() == tcx.map.local_def_id(fn_id)\n-                    })\n+                    tcx.expect_def_or_none(callee.id)\n+                        .map_or(false, |def| def.def_id() == tcx.map.local_def_id(fn_id))\n                 }\n-                _ => false\n+                _ => false,\n             }\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n         fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 method: &ty::Method,\n-                                                id: ast::NodeId) -> bool {\n+                                                id: ast::NodeId)\n+                                                -> bool {\n             // Check for method calls and overloaded operators.\n             let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n@@ -859,9 +903,11 @@ impl LateLintPass for UnconditionalRecursion {\n             if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n                 for i in 0..adj.autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n-                    if let Some(m) = tcx.tables.borrow().method_map\n-                                                        .get(&method_call)\n-                                                        .cloned() {\n+                    if let Some(m) = tcx.tables\n+                        .borrow()\n+                        .method_map\n+                        .get(&method_call)\n+                        .cloned() {\n                         if method_call_refers_to_method(tcx, method, m.def_id, m.substs, id) {\n                             return true;\n                         }\n@@ -877,13 +923,16 @@ impl LateLintPass for UnconditionalRecursion {\n                     match tcx.expect_def_or_none(callee.id) {\n                         Some(Def::Method(def_id)) => {\n                             let item_substs = tcx.node_id_item_substs(callee.id);\n-                            method_call_refers_to_method(\n-                                tcx, method, def_id, &item_substs.substs, id)\n+                            method_call_refers_to_method(tcx,\n+                                                         method,\n+                                                         def_id,\n+                                                         &item_substs.substs,\n+                                                         id)\n                         }\n-                        _ => false\n+                        _ => false,\n                     }\n                 }\n-                _ => false\n+                _ => false,\n             }\n         }\n \n@@ -893,15 +942,14 @@ impl LateLintPass for UnconditionalRecursion {\n                                                   method: &ty::Method,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n-                                                  expr_id: ast::NodeId) -> bool {\n+                                                  expr_id: ast::NodeId)\n+                                                  -> bool {\n             let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {\n                 // This is an inherent method, so the `def_id` refers\n                 // directly to the method definition.\n-                ty::ImplContainer(_) => {\n-                    callee_id == method.def_id\n-                }\n+                ty::ImplContainer(_) => callee_id == method.def_id,\n \n                 // A trait method, from any number of possible sources.\n                 // Attempt to select a concrete impl before checking.\n@@ -939,13 +987,12 @@ impl LateLintPass for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container\n-                                    && callee_item.name() == method.name\n+                                container == method.container && callee_item.name() == method.name\n                             }\n \n                             // There's no way to know if this call is\n                             // recursive, so we assume it's not.\n-                            _ => false\n+                            _ => false,\n                         }\n                     })\n                 }\n@@ -992,7 +1039,8 @@ impl LateLintPass for PluginAsLibrary {\n         };\n \n         if prfn.is_some() {\n-            cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n+            cx.span_lint(PLUGIN_AS_LIBRARY,\n+                         it.span,\n                          \"compiler plugin used as an ordinary library\");\n         }\n     }\n@@ -1050,15 +1098,15 @@ impl LateLintPass for InvalidNoMangleItems {\n                                      \"generic functions must be mangled\");\n                     }\n                 }\n-            },\n+            }\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                       !cx.access_levels.is_reachable(it.id) {\n+                   !cx.access_levels.is_reachable(it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);\n                 }\n-            },\n+            }\n             hir::ItemConst(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n@@ -1068,7 +1116,7 @@ impl LateLintPass for InvalidNoMangleItems {\n                     cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n                 }\n             }\n-            _ => {},\n+            _ => {}\n         }\n     }\n }\n@@ -1096,19 +1144,21 @@ impl LateLintPass for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr) {\n             Some((&ty::TyRef(_, from_mt), &ty::TyRef(_, to_mt))) => {\n-                if to_mt.mutbl == hir::Mutability::MutMutable\n-                    && from_mt.mutbl == hir::Mutability::MutImmutable {\n+                if to_mt.mutbl == hir::Mutability::MutMutable &&\n+                   from_mt.mutbl == hir::Mutability::MutImmutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }\n-            _ => ()\n+            _ => (),\n         }\n \n-        fn get_transmute_from_to<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr)\n-            -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n+        fn get_transmute_from_to<'a, 'tcx>\n+            (cx: &LateContext<'a, 'tcx>,\n+             expr: &hir::Expr)\n+             -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             match expr.node {\n                 hir::ExprPath(..) => (),\n-                _ => return None\n+                _ => return None,\n             }\n             if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n                 if !def_id_is_transmute(cx, did) {\n@@ -1120,8 +1170,8 @@ impl LateLintPass for MutableTransmutes {\n                         let from = bare_fn.sig.0.inputs[0];\n                         let to = bare_fn.sig.0.output;\n                         return Some((&from.sty, &to.sty));\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 }\n             }\n             None\n@@ -1130,7 +1180,7 @@ impl LateLintPass for MutableTransmutes {\n         fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n             match cx.tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n-                _ => return false\n+                _ => return false,\n             }\n             cx.tcx.item_name(def_id).as_str() == \"transmute\"\n         }"}, {"sha": "74483b89cea22f1671b75cc8840dbe6cd79cba55", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=4e65489e77cefa148d55535696d92084fc0c4d8e", "patch": "@@ -48,10 +48,10 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n-pub use rustc::lint as lint;\n-pub use rustc::middle as middle;\n-pub use rustc::session as session;\n-pub use rustc::util as util;\n+pub use rustc::lint;\n+pub use rustc::middle;\n+pub use rustc::session;\n+pub use rustc::util;\n \n use session::Session;\n use lint::LintId;\n@@ -139,13 +139,24 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                           MissingDebugImplementations,\n                           );\n \n-    add_lint_group!(sess, \"bad_style\",\n-                    NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS);\n-\n-    add_lint_group!(sess, \"unused\",\n-                    UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n-                    UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n-                    UNUSED_UNSAFE, PATH_STATEMENTS, UNUSED_ATTRIBUTES);\n+    add_lint_group!(sess,\n+                    \"bad_style\",\n+                    NON_CAMEL_CASE_TYPES,\n+                    NON_SNAKE_CASE,\n+                    NON_UPPER_CASE_GLOBALS);\n+\n+    add_lint_group!(sess,\n+                    \"unused\",\n+                    UNUSED_IMPORTS,\n+                    UNUSED_VARIABLES,\n+                    UNUSED_ASSIGNMENTS,\n+                    DEAD_CODE,\n+                    UNUSED_MUT,\n+                    UNREACHABLE_CODE,\n+                    UNUSED_MUST_USE,\n+                    UNUSED_UNSAFE,\n+                    PATH_STATEMENTS,\n+                    UNUSED_ATTRIBUTES);\n \n     // Guidelines for creating a future incompatibility lint:\n     //\n@@ -155,7 +166,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     //   and include the full URL.\n     // - Later, change lint to error\n     // - Eventually, remove lint\n-    store.register_future_incompatible(sess, vec![\n+    store.register_future_incompatible(sess,\n+                                       vec![\n         FutureIncompatibleInfo {\n             id: LintId::of(PRIVATE_IN_PUBLIC),\n             reference: \"issue #34537 <https://github.com/rust-lang/rust/issues/34537>\",\n@@ -204,11 +216,13 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n \n     // Register renamed and removed lints\n     store.register_renamed(\"unknown_features\", \"unused_features\");\n-    store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n+    store.register_removed(\"unsigned_negation\",\n+                           \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");\n     store.register_removed(\"raw_pointer_derive\", \"using derive with raw pointers is ok\");\n     // This was renamed to raw_pointer_derive, which was then removed,\n     // so it is also considered removed\n-    store.register_removed(\"raw_pointer_deriving\", \"using derive with raw pointers is ok\");\n+    store.register_removed(\"raw_pointer_deriving\",\n+                           \"using derive with raw pointers is ok\");\n     store.register_removed(\"drop_with_repr_extern\", \"drop flags have been removed\");\n }"}, {"sha": "9464bf30b693fd86dcedad02e5157c94a123fbb4", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 246, "deletions": 228, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=4e65489e77cefa148d55535696d92084fc0c4d8e", "patch": "@@ -18,7 +18,7 @@ use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n-use util::nodemap::{FnvHashSet};\n+use util::nodemap::FnvHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n \n@@ -91,15 +91,15 @@ pub struct TypeLimits {\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits {\n-            negated_expr_id: ast::DUMMY_NODE_ID,\n-        }\n+        TypeLimits { negated_expr_id: ast::DUMMY_NODE_ID }\n     }\n }\n \n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_COMPARISONS, OVERFLOWING_LITERALS, EXCEEDING_BITSHIFTS)\n+        lint_array!(UNUSED_COMPARISONS,\n+                    OVERFLOWING_LITERALS,\n+                    EXCEEDING_BITSHIFTS)\n     }\n }\n \n@@ -111,13 +111,13 @@ impl LateLintPass for TypeLimits {\n                     match lit.node {\n                         ast::LitKind::Int(_, ast::LitIntType::Unsigned(_)) => {\n                             forbid_unsigned_negation(cx, e.span);\n-                        },\n+                        }\n                         ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n                             if let ty::TyUint(_) = cx.tcx.node_id_to_type(e.id).sty {\n                                 forbid_unsigned_negation(cx, e.span);\n                             }\n-                        },\n-                        _ => ()\n+                        }\n+                        _ => (),\n                     }\n                 } else {\n                     let t = cx.tcx.node_id_to_type(expr.id);\n@@ -129,41 +129,47 @@ impl LateLintPass for TypeLimits {\n                 if self.negated_expr_id != e.id {\n                     self.negated_expr_id = expr.id;\n                 }\n-            },\n+            }\n             hir::ExprBinary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, &l, &r) {\n-                    cx.span_lint(UNUSED_COMPARISONS, e.span,\n+                    cx.span_lint(UNUSED_COMPARISONS,\n+                                 e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n \n                 if binop.node.is_shift() {\n                     let opt_ty_bits = match cx.tcx.node_id_to_type(l.id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n-                        _ => None\n+                        _ => None,\n                     };\n \n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitKind::Int(shift, _) = lit.node { shift >= bits }\n-                            else { false }\n+                            if let ast::LitKind::Int(shift, _) = lit.node {\n+                                shift >= bits\n+                            } else {\n+                                false\n+                            }\n                         } else {\n                             match eval_const_expr_partial(cx.tcx, &r, ExprTypeChecked, None) {\n                                 Ok(ConstVal::Integral(i)) => {\n-                                    i.is_negative() || i.to_u64()\n-                                                        .map(|i| i >= bits)\n-                                                        .unwrap_or(true)\n-                                },\n-                                _ => { false }\n+                                    i.is_negative() ||\n+                                    i.to_u64()\n+                                        .map(|i| i >= bits)\n+                                        .unwrap_or(true)\n+                                }\n+                                _ => false,\n                             }\n                         };\n                         if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS, e.span,\n+                            cx.span_lint(EXCEEDING_BITSHIFTS,\n+                                         e.span,\n                                          \"bitshift exceeds the type's number of bits\");\n                         }\n                     };\n                 }\n-            },\n+            }\n             hir::ExprLit(ref lit) => {\n                 match cx.tcx.node_id_to_type(e.id).sty {\n                     ty::TyInt(t) => {\n@@ -182,14 +188,15 @@ impl LateLintPass for TypeLimits {\n                                 // avoiding use of -min to prevent overflow/panic\n                                 if (negative && v > max as u64 + 1) ||\n                                    (!negative && v > max as u64) {\n-                                    cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                                    cx.span_lint(OVERFLOWING_LITERALS,\n+                                                 e.span,\n                                                  &format!(\"literal out of range for {:?}\", t));\n                                     return;\n                                 }\n                             }\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n-                    },\n+                    }\n                     ty::TyUint(t) => {\n                         let uint_type = if let ast::UintTy::Us = t {\n                             cx.sess().target.uint_type\n@@ -201,84 +208,86 @@ impl LateLintPass for TypeLimits {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS,\n+                                         e.span,\n                                          &format!(\"literal out of range for {:?}\", t));\n                         }\n-                    },\n+                    }\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n                             ast::LitKind::Float(ref v, _) |\n                             ast::LitKind::FloatUnsuffixed(ref v) => {\n                                 match v.parse() {\n                                     Ok(f) => f,\n-                                    Err(_) => return\n+                                    Err(_) => return,\n                                 }\n                             }\n-                            _ => bug!()\n+                            _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            cx.span_lint(OVERFLOWING_LITERALS, e.span,\n+                            cx.span_lint(OVERFLOWING_LITERALS,\n+                                         e.span,\n                                          &format!(\"literal out of range for {:?}\", t));\n                         }\n-                    },\n-                    _ => ()\n+                    }\n+                    _ => (),\n                 };\n-            },\n-            _ => ()\n+            }\n+            _ => (),\n         };\n \n-        fn is_valid<T:cmp::PartialOrd>(binop: hir::BinOp, v: T,\n-                                min: T, max: T) -> bool {\n+        fn is_valid<T: cmp::PartialOrd>(binop: hir::BinOp, v: T, min: T, max: T) -> bool {\n             match binop.node {\n-                hir::BiLt => v >  min && v <= max,\n-                hir::BiLe => v >= min && v <  max,\n-                hir::BiGt => v >= min && v <  max,\n-                hir::BiGe => v >  min && v <= max,\n+                hir::BiLt => v > min && v <= max,\n+                hir::BiLe => v >= min && v < max,\n+                hir::BiGt => v >= min && v < max,\n+                hir::BiGe => v > min && v <= max,\n                 hir::BiEq | hir::BiNe => v >= min && v <= max,\n-                _ => bug!()\n+                _ => bug!(),\n             }\n         }\n \n         fn rev_binop(binop: hir::BinOp) -> hir::BinOp {\n-            codemap::respan(binop.span, match binop.node {\n-                hir::BiLt => hir::BiGt,\n-                hir::BiLe => hir::BiGe,\n-                hir::BiGt => hir::BiLt,\n-                hir::BiGe => hir::BiLe,\n-                _ => return binop\n-            })\n+            codemap::respan(binop.span,\n+                            match binop.node {\n+                                hir::BiLt => hir::BiGt,\n+                                hir::BiLe => hir::BiGe,\n+                                hir::BiGt => hir::BiLt,\n+                                hir::BiGe => hir::BiLe,\n+                                _ => return binop,\n+                            })\n         }\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::IntTy::Is => (i64::MIN,        i64::MAX),\n-                ast::IntTy::I8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::IntTy::I16 =>   (i16::MIN as i64, i16::MAX as i64),\n-                ast::IntTy::I32 =>   (i32::MIN as i64, i32::MAX as i64),\n-                ast::IntTy::I64 =>   (i64::MIN,        i64::MAX)\n+                ast::IntTy::Is => (i64::MIN, i64::MAX),\n+                ast::IntTy::I8 => (i8::MIN as i64, i8::MAX as i64),\n+                ast::IntTy::I16 => (i16::MIN as i64, i16::MAX as i64),\n+                ast::IntTy::I32 => (i32::MIN as i64, i32::MAX as i64),\n+                ast::IntTy::I64 => (i64::MIN, i64::MAX),\n             }\n         }\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::UintTy::Us => (u64::MIN,         u64::MAX),\n-                ast::UintTy::U8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::UintTy::U16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::UintTy::U32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::UintTy::U64 =>   (u64::MIN,         u64::MAX)\n+                ast::UintTy::Us => (u64::MIN, u64::MAX),\n+                ast::UintTy::U8 => (u8::MIN as u64, u8::MAX as u64),\n+                ast::UintTy::U16 => (u16::MIN as u64, u16::MAX as u64),\n+                ast::UintTy::U32 => (u32::MIN as u64, u32::MAX as u64),\n+                ast::UintTy::U64 => (u64::MIN, u64::MAX),\n             }\n         }\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n                 ast::FloatTy::F32 => (f32::MIN as f64, f32::MAX as f64),\n-                ast::FloatTy::F64 => (f64::MIN,        f64::MAX)\n+                ast::FloatTy::F64 => (f64::MIN, f64::MAX),\n             }\n         }\n \n@@ -305,60 +314,60 @@ impl LateLintPass for TypeLimits {\n         fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   binop: hir::BinOp,\n                                   l: &hir::Expr,\n-                                  r: &hir::Expr) -> bool {\n+                                  r: &hir::Expr)\n+                                  -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n-                _ => return true\n+                _ => return true,\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n-            let norm_binop = if swap {\n-                rev_binop(binop)\n-            } else {\n-                binop\n-            };\n+            let norm_binop = if swap { rev_binop(binop) } else { binop };\n             match tcx.node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                            ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n-                            _ => return true\n-                        },\n-                        _ => bug!()\n+                        hir::ExprLit(ref li) => {\n+                            match li.node {\n+                                ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n+                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n+                                _ => return true,\n+                            }\n+                        }\n+                        _ => bug!(),\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n                 ty::TyUint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n-                        hir::ExprLit(ref li) => match li.node {\n-                            ast::LitKind::Int(v, _) => v,\n-                            _ => return true\n-                        },\n-                        _ => bug!()\n+                        hir::ExprLit(ref li) => {\n+                            match li.node {\n+                                ast::LitKind::Int(v, _) => v,\n+                                _ => return true,\n+                            }\n+                        }\n+                        _ => bug!(),\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n-                _ => true\n+                _ => true,\n             }\n         }\n \n         fn is_comparison(binop: hir::BinOp) -> bool {\n             match binop.node {\n-                hir::BiEq | hir::BiLt | hir::BiLe |\n-                hir::BiNe | hir::BiGe | hir::BiGt => true,\n-                _ => false\n+                hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => true,\n+                _ => false,\n             }\n         }\n \n         fn forbid_unsigned_negation(cx: &LateContext, span: Span) {\n             cx.sess()\n-              .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n-              .span_help(span, \"use a cast or the `!` operator\")\n-              .emit();\n+                .struct_span_err_with_code(span, \"unary negation of unsigned integer\", \"E0519\")\n+                .span_help(span, \"use a cast or the `!` operator\")\n+                .emit();\n         }\n     }\n }\n@@ -370,7 +379,7 @@ declare_lint! {\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n enum FfiResult {\n@@ -403,9 +412,13 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         if def.variants[data_idx].fields.len() == 1 {\n             match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n-                ty::TyFnPtr(_) => { return true; }\n-                ty::TyRef(..) => { return true; }\n-                _ => { }\n+                ty::TyFnPtr(_) => {\n+                    return true;\n+                }\n+                ty::TyRef(..) => {\n+                    return true;\n+                }\n+                _ => {}\n             }\n         }\n     }\n@@ -415,10 +428,7 @@ fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the given type is \"ffi-safe\" (has a stable, well-defined\n     /// representation which can be exported to C code).\n-    fn check_type_for_ffi(&self,\n-                          cache: &mut FnvHashSet<Ty<'tcx>>,\n-                          ty: Ty<'tcx>)\n-                          -> FfiResult {\n+    fn check_type_for_ffi(&self, cache: &mut FnvHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult {\n         use self::FfiResult::*;\n         let cx = self.cx.tcx;\n \n@@ -431,121 +441,126 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.sty {\n-            ty::TyAdt(def, substs) => match def.adt_kind() {\n-                AdtKind::Struct => {\n-                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                        return FfiUnsafe(\n-                            \"found struct without foreign-function-safe \\\n-                            representation annotation in foreign module, \\\n-                            consider adding a #[repr(C)] attribute to \\\n-                            the type\");\n-                    }\n+            ty::TyAdt(def, substs) => {\n+                match def.adt_kind() {\n+                    AdtKind::Struct => {\n+                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                            return FfiUnsafe(\"found struct without foreign-function-safe \\\n+                                              representation annotation in foreign module, \\\n+                                              consider adding a #[repr(C)] attribute to the type\");\n+                        }\n \n-                    // We can't completely trust repr(C) markings; make sure the\n-                    // fields are actually safe.\n-                    if def.struct_variant().fields.is_empty() {\n-                        return FfiUnsafe(\n-                            \"found zero-size struct in foreign module, consider \\\n-                            adding a member to this struct\");\n-                    }\n+                        // We can't completely trust repr(C) markings; make sure the\n+                        // fields are actually safe.\n+                        if def.struct_variant().fields.is_empty() {\n+                            return FfiUnsafe(\"found zero-size struct in foreign module, consider \\\n+                                              adding a member to this struct\");\n+                        }\n \n-                    for field in &def.struct_variant().fields {\n-                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, field_ty);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n+                        for field in &def.struct_variant().fields {\n+                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let r = self.check_type_for_ffi(cache, field_ty);\n+                            match r {\n+                                FfiSafe => {}\n+                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                    return r;\n+                                }\n+                                FfiUnsafe(s) => {\n+                                    return FfiBadStruct(def.did, s);\n+                                }\n+                            }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n-                }\n-                AdtKind::Union => {\n-                    if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n-                        return FfiUnsafe(\n-                            \"found union without foreign-function-safe \\\n-                            representation annotation in foreign module, \\\n-                            consider adding a #[repr(C)] attribute to \\\n-                            the type\");\n-                    }\n+                    AdtKind::Union => {\n+                        if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                            return FfiUnsafe(\"found union without foreign-function-safe \\\n+                                              representation annotation in foreign module, \\\n+                                              consider adding a #[repr(C)] attribute to the type\");\n+                        }\n \n-                    for field in &def.struct_variant().fields {\n-                        let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n-                        let r = self.check_type_for_ffi(cache, field_ty);\n-                        match r {\n-                            FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                            FfiUnsafe(s) => { return FfiBadUnion(def.did, s); }\n+                        for field in &def.struct_variant().fields {\n+                            let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                            let r = self.check_type_for_ffi(cache, field_ty);\n+                            match r {\n+                                FfiSafe => {}\n+                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                    return r;\n+                                }\n+                                FfiUnsafe(s) => {\n+                                    return FfiBadUnion(def.did, s);\n+                                }\n+                            }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n-                }\n-                AdtKind::Enum => {\n-                    if def.variants.is_empty() {\n-                        // Empty enums are okay... although sort of useless.\n-                        return FfiSafe\n-                    }\n+                    AdtKind::Enum => {\n+                        if def.variants.is_empty() {\n+                            // Empty enums are okay... although sort of useless.\n+                            return FfiSafe;\n+                        }\n \n-                    // Check for a repr() attribute to specify the size of the\n-                    // discriminant.\n-                    let repr_hints = cx.lookup_repr_hints(def.did);\n-                    match &repr_hints[..] {\n-                        &[] => {\n-                            // Special-case types like `Option<extern fn()>`.\n-                            if !is_repr_nullable_ptr(cx, def, substs) {\n-                                return FfiUnsafe(\n-                                    \"found enum without foreign-function-safe \\\n-                                    representation annotation in foreign module, \\\n-                                    consider adding a #[repr(...)] attribute to \\\n-                                    the type\")\n+                        // Check for a repr() attribute to specify the size of the\n+                        // discriminant.\n+                        let repr_hints = cx.lookup_repr_hints(def.did);\n+                        match &repr_hints[..] {\n+                            &[] => {\n+                                // Special-case types like `Option<extern fn()>`.\n+                                if !is_repr_nullable_ptr(cx, def, substs) {\n+                                    return FfiUnsafe(\"found enum without foreign-function-safe \\\n+                                                      representation annotation in foreign \\\n+                                                      module, consider adding a #[repr(...)] \\\n+                                                      attribute to the type\");\n+                                }\n                             }\n-                        }\n-                        &[ref hint] => {\n-                            if !hint.is_ffi_safe() {\n+                            &[ref hint] => {\n+                                if !hint.is_ffi_safe() {\n+                                    // FIXME: This shouldn't be reachable: we should check\n+                                    // this earlier.\n+                                    return FfiUnsafe(\"enum has unexpected #[repr(...)] attribute\");\n+                                }\n+\n+                                // Enum with an explicitly sized discriminant; either\n+                                // a C-style enum or a discriminated union.\n+\n+                                // The layout of enum variants is implicitly repr(C).\n+                                // FIXME: Is that correct?\n+                            }\n+                            _ => {\n                                 // FIXME: This shouldn't be reachable: we should check\n                                 // this earlier.\n-                                return FfiUnsafe(\n-                                    \"enum has unexpected #[repr(...)] attribute\")\n+                                return FfiUnsafe(\"enum has too many #[repr(...)] attributes\");\n                             }\n-\n-                            // Enum with an explicitly sized discriminant; either\n-                            // a C-style enum or a discriminated union.\n-\n-                            // The layout of enum variants is implicitly repr(C).\n-                            // FIXME: Is that correct?\n                         }\n-                        _ => {\n-                            // FIXME: This shouldn't be reachable: we should check\n-                            // this earlier.\n-                            return FfiUnsafe(\n-                                \"enum has too many #[repr(...)] attributes\");\n-                        }\n-                    }\n \n-                    // Check the contained variants.\n-                    for variant in &def.variants {\n-                        for field in &variant.fields {\n-                            let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n-                            let r = self.check_type_for_ffi(cache, arg);\n-                            match r {\n-                                FfiSafe => {}\n-                                FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n-                                FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n+                        // Check the contained variants.\n+                        for variant in &def.variants {\n+                            for field in &variant.fields {\n+                                let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n+                                let r = self.check_type_for_ffi(cache, arg);\n+                                match r {\n+                                    FfiSafe => {}\n+                                    FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => {\n+                                        return r;\n+                                    }\n+                                    FfiUnsafe(s) => {\n+                                        return FfiBadEnum(def.did, s);\n+                                    }\n+                                }\n                             }\n                         }\n+                        FfiSafe\n                     }\n-                    FfiSafe\n                 }\n-            },\n+            }\n \n             ty::TyChar => {\n                 FfiUnsafe(\"found Rust type `char` in foreign module, while \\\n                            `u32` or `libc::wchar_t` should be used\")\n             }\n \n             // Primitive types with a stable representation.\n-            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) |\n-            ty::TyFloat(..) | ty::TyNever => FfiSafe,\n+            ty::TyBool | ty::TyInt(..) | ty::TyUint(..) | ty::TyFloat(..) | ty::TyNever => FfiSafe,\n \n             ty::TyBox(..) => {\n                 FfiUnsafe(\"found Rust type Box<_> in foreign module, \\\n@@ -572,24 +587,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                            consider using a struct instead\")\n             }\n \n-            ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {\n-                self.check_type_for_ffi(cache, m.ty)\n-            }\n+            ty::TyRawPtr(ref m) |\n+            ty::TyRef(_, ref m) => self.check_type_for_ffi(cache, m.ty),\n \n-            ty::TyArray(ty, _) => {\n-                self.check_type_for_ffi(cache, ty)\n-            }\n+            ty::TyArray(ty, _) => self.check_type_for_ffi(cache, ty),\n \n             ty::TyFnPtr(bare_fn) => {\n                 match bare_fn.abi {\n-                    Abi::Rust |\n-                    Abi::RustIntrinsic |\n-                    Abi::PlatformIntrinsic |\n-                    Abi::RustCall => {\n-                        return FfiUnsafe(\n-                            \"found function pointer with Rust calling \\\n-                             convention in foreign module; consider using an \\\n-                             `extern` function pointer\")\n+                    Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic | Abi::RustCall => {\n+                        return FfiUnsafe(\"found function pointer with Rust calling convention in \\\n+                                          foreign module; consider using an `extern` function \\\n+                                          pointer\")\n                     }\n                     _ => {}\n                 }\n@@ -599,24 +607,30 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     let r = self.check_type_for_ffi(cache, sig.output);\n                     match r {\n                         FfiSafe => {}\n-                        _ => { return r; }\n+                        _ => {\n+                            return r;\n+                        }\n                     }\n                 }\n                 for arg in sig.inputs {\n                     let r = self.check_type_for_ffi(cache, arg);\n                     match r {\n                         FfiSafe => {}\n-                        _ => { return r; }\n+                        _ => {\n+                            return r;\n+                        }\n                     }\n                 }\n                 FfiSafe\n             }\n \n-            ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n-            ty::TyClosure(..) | ty::TyProjection(..) | ty::TyAnon(..) |\n-            ty::TyFnDef(..) => {\n-                bug!(\"Unexpected type in foreign function\")\n-            }\n+            ty::TyParam(..) |\n+            ty::TyInfer(..) |\n+            ty::TyError |\n+            ty::TyClosure(..) |\n+            ty::TyProjection(..) |\n+            ty::TyAnon(..) |\n+            ty::TyFnDef(..) => bug!(\"Unexpected type in foreign function\"),\n         }\n     }\n \n@@ -633,23 +647,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             FfiResult::FfiBadStruct(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              struct marked #[repr(C)]: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in struct \\\n+                                            marked #[repr(C)]: {}\",\n+                                           s));\n             }\n             FfiResult::FfiBadUnion(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant field.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              union marked #[repr(C)]: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in union \\\n+                                            marked #[repr(C)]: {}\",\n+                                           s));\n             }\n             FfiResult::FfiBadEnum(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant variant.\n-                self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                    &format!(\"found non-foreign-function-safe member in \\\n-                              enum: {}\", s));\n+                self.cx.span_lint(IMPROPER_CTYPES,\n+                                  sp,\n+                                  &format!(\"found non-foreign-function-safe member in enum: {}\",\n+                                           s));\n             }\n         }\n     }\n@@ -719,13 +738,13 @@ impl LintPass for VariantSizeDifferences {\n impl LateLintPass for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n-            if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n+            if gens.ty_params.is_empty() {\n+                // sizes only make sense for non-generic types\n                 let t = cx.tcx.node_id_to_type(it.id);\n                 let layout = cx.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n-                    ty.layout(&infcx).unwrap_or_else(|e| {\n-                        bug!(\"failed to get layout for `{}`: {}\", t, e)\n-                    })\n+                    ty.layout(&infcx)\n+                        .unwrap_or_else(|e| bug!(\"failed to get layout for `{}`: {}\", t, e))\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n@@ -738,31 +757,30 @@ impl LateLintPass for VariantSizeDifferences {\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.min_size.bytes()\n-                                                                 .saturating_sub(discr_size);\n+                            let bytes = variant_layout.min_size\n+                                .bytes()\n+                                .saturating_sub(discr_size);\n \n                             debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);\n                             bytes\n                         })\n                         .enumerate()\n-                        .fold((0, 0, 0),\n-                            |(l, s, li), (idx, size)|\n-                                if size > l {\n-                                    (size, l, idx)\n-                                } else if size > s {\n-                                    (l, size, li)\n-                                } else {\n-                                    (l, s, li)\n-                                }\n-                        );\n+                        .fold((0, 0, 0), |(l, s, li), (idx, size)| if size > l {\n+                            (size, l, idx)\n+                        } else if size > s {\n+                            (l, size, li)\n+                        } else {\n+                            (l, s, li)\n+                        });\n \n                     // we only warn if the largest variant is at least thrice as large as\n                     // the second-largest.\n                     if largest > slargest * 3 && slargest > 0 {\n                         cx.span_lint(VARIANT_SIZE_DIFFERENCES,\n                                      enum_definition.variants[largest_index].span,\n                                      &format!(\"enum variant is more than three times larger \\\n-                                               ({} bytes) than the next largest\", largest));\n+                                               ({} bytes) than the next largest\",\n+                                              largest));\n                     }\n                 }\n             }"}, {"sha": "a29ff18ab53188311c9ff13343fa7268c10222e0", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 56, "deletions": 44, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e65489e77cefa148d55535696d92084fc0c4d8e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=4e65489e77cefa148d55535696d92084fc0c4d8e", "patch": "@@ -49,8 +49,12 @@ impl UnusedMut {\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n                         match mutables.entry(name.0 as usize) {\n-                            Vacant(entry) => { entry.insert(vec![id]); },\n-                            Occupied(mut entry) => { entry.get_mut().push(id); },\n+                            Vacant(entry) => {\n+                                entry.insert(vec![id]);\n+                            }\n+                            Occupied(mut entry) => {\n+                                entry.get_mut().push(id);\n+                            }\n                         }\n                     }\n                 }\n@@ -60,7 +64,8 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in &mutables {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n+                cx.span_lint(UNUSED_MUT,\n+                             cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n             }\n         }\n@@ -90,9 +95,13 @@ impl LateLintPass for UnusedMut {\n         }\n     }\n \n-    fn check_fn(&mut self, cx: &LateContext,\n-                _: FnKind, decl: &hir::FnDecl,\n-                _: &hir::Block, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self,\n+                cx: &LateContext,\n+                _: FnKind,\n+                decl: &hir::FnDecl,\n+                _: &hir::Block,\n+                _: Span,\n+                _: ast::NodeId) {\n         for a in &decl.inputs {\n             self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n@@ -124,7 +133,7 @@ impl LateLintPass for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtSemi(ref expr, _) => &**expr,\n-            _ => return\n+            _ => return,\n         };\n \n         if let hir::ExprRet(..) = expr.node {\n@@ -184,8 +193,8 @@ impl LateLintPass for UnusedUnsafe {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) &&\n-                !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n+               !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n+                cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n             }\n         }\n     }\n@@ -210,8 +219,7 @@ impl LateLintPass for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         if let hir::StmtSemi(ref expr, _) = s.node {\n             if let hir::ExprPath(..) = expr.node {\n-                cx.span_lint(PATH_STATEMENTS, s.span,\n-                             \"path statement with no effect\");\n+                cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }\n         }\n     }\n@@ -242,8 +250,8 @@ impl LateLintPass for UnusedAttributes {\n                 AttributeType::Whitelisted if attr.check_name(name) => {\n                     debug!(\"{:?} is Whitelisted\", name);\n                     break;\n-                },\n-                _ => ()\n+                }\n+                _ => (),\n             }\n         }\n \n@@ -259,24 +267,22 @@ impl LateLintPass for UnusedAttributes {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n-            let known_crate = KNOWN_ATTRIBUTES.iter().find(|&&(name, ty, _)| {\n-                attr.name() == name &&\n-                ty == AttributeType::CrateLevel\n-            }).is_some();\n+            let known_crate = KNOWN_ATTRIBUTES.iter()\n+                .find(|&&(name, ty, _)| attr.name() == name && ty == AttributeType::CrateLevel)\n+                .is_some();\n \n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                                                .find(|&&(ref x, t)| {\n-                                                        &*attr.name() == x &&\n-                                                        AttributeType::CrateLevel == t\n-                                                    }).is_some();\n-            if  known_crate || plugin_crate {\n+                .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n+                .is_some();\n+            if known_crate || plugin_crate {\n                 let msg = match attr.node.style {\n-                    ast::AttrStyle::Outer => \"crate-level attribute should be an inner \\\n-                                              attribute: add an exclamation mark: #![foo]\",\n-                    ast::AttrStyle::Inner => \"crate-level attribute should be in the \\\n-                                              root module\",\n+                    ast::AttrStyle::Outer => {\n+                        \"crate-level attribute should be an inner attribute: add an exclamation \\\n+                         mark: #![foo]\"\n+                    }\n+                    ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n                 };\n                 cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n             }\n@@ -296,12 +302,16 @@ declare_lint! {\n pub struct UnusedParens;\n \n impl UnusedParens {\n-    fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n+    fn check_unused_parens_core(&self,\n+                                cx: &EarlyContext,\n+                                value: &ast::Expr,\n+                                msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n             if !necessary {\n-                cx.span_lint(UNUSED_PARENS, value.span,\n+                cx.span_lint(UNUSED_PARENS,\n+                             value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n@@ -319,8 +329,7 @@ impl UnusedParens {\n                 ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n                 ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&lhs) ||\n-                        contains_exterior_struct_lit(&rhs)\n+                    contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n                 }\n                 ast::ExprKind::Unary(_, ref x) |\n                 ast::ExprKind::Cast(ref x, _) |\n@@ -337,7 +346,7 @@ impl UnusedParens {\n                     contains_exterior_struct_lit(&exprs[0])\n                 }\n \n-                _ => false\n+                _ => false,\n             }\n         }\n     }\n@@ -363,18 +372,20 @@ impl EarlyLintPass for UnusedParens {\n             Assign(_, ref value) => (value, \"assigned value\", false),\n             AssignOp(.., ref value) => (value, \"assigned value\", false),\n             InPlace(_, ref value) => (value, \"emplacement value\", false),\n-            _ => return\n+            _ => return,\n         };\n         self.check_unused_parens_core(cx, &value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtKind::Local(ref local) => match local.init {\n-                Some(ref value) => (value, \"assigned value\"),\n-                None => return\n-            },\n-            _ => return\n+            ast::StmtKind::Local(ref local) => {\n+                match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n+                    None => return,\n+                }\n+            }\n+            _ => return,\n         };\n         self.check_unused_parens_core(cx, &value, msg, false);\n     }\n@@ -427,23 +438,24 @@ impl LateLintPass for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         match e.node {\n             hir::ExprBox(_) => {}\n-            _ => return\n+            _ => return,\n         }\n \n         if let Some(adjustment) = cx.tcx.tables.borrow().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                ref autoref, ..\n-            }) = *adjustment {\n+            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n+                *adjustment {\n                 match autoref {\n                     &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                        cx.span_lint(UNUSED_ALLOCATION,\n+                                     e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n                     &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n-                        cx.span_lint(UNUSED_ALLOCATION, e.span,\n+                        cx.span_lint(UNUSED_ALLOCATION,\n+                                     e.span,\n                                      \"unnecessary allocation, use &mut instead\");\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n             }\n         }"}]}