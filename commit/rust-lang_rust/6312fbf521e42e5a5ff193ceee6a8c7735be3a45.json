{"sha": "6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "node_id": "C_kwDOAAsO6NoAKDYzMTJmYmY1MjFlNDJlNWE1ZmYxOTNjZWVlNmE4Yzc3MzViZTNhNDU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-28T17:14:30Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-01T19:53:10Z"}, "message": "MIR episode 4", "tree": {"sha": "cbaea739cd9f5e5c850d01c2f2b232da39076668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbaea739cd9f5e5c850d01c2f2b232da39076668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "html_url": "https://github.com/rust-lang/rust/commit/6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "001607fdb4ac6a3059813451234097ce7c2f35de", "url": "https://api.github.com/repos/rust-lang/rust/commits/001607fdb4ac6a3059813451234097ce7c2f35de", "html_url": "https://github.com/rust-lang/rust/commit/001607fdb4ac6a3059813451234097ce7c2f35de"}], "stats": {"total": 3360, "additions": 2556, "deletions": 804}, "files": [{"sha": "f1973a20714a08c98d8b27403d1194d9b09b9c3e", "filename": "crates/base-db/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fbase-db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fbase-db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Fchange.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -34,7 +34,7 @@ impl fmt::Debug for Change {\n }\n \n impl Change {\n-    pub fn new() -> Change {\n+    pub fn new() -> Self {\n         Change::default()\n     }\n "}, {"sha": "d31340fe8f3882c0bc993901a126fec6c9c4a3a2", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -17,7 +17,7 @@ use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasAttrs, HasLoopBody, HasName,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n@@ -302,16 +302,29 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n             }\n             ast::Expr::CallExpr(e) => {\n-                let callee = self.collect_expr_opt(e.expr());\n-                let args = if let Some(arg_list) = e.arg_list() {\n-                    arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n-                } else {\n-                    Box::default()\n+                let is_rustc_box = {\n+                    let attrs = e.attrs();\n+                    attrs.filter_map(|x| x.as_simple_atom()).any(|x| x == \"rustc_box\")\n                 };\n-                self.alloc_expr(\n-                    Expr::Call { callee, args, is_assignee_expr: self.is_lowering_assignee_expr },\n-                    syntax_ptr,\n-                )\n+                if is_rustc_box {\n+                    let expr = self.collect_expr_opt(e.arg_list().and_then(|x| x.args().next()));\n+                    self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n+                } else {\n+                    let callee = self.collect_expr_opt(e.expr());\n+                    let args = if let Some(arg_list) = e.arg_list() {\n+                        arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n+                    } else {\n+                        Box::default()\n+                    };\n+                    self.alloc_expr(\n+                        Expr::Call {\n+                            callee,\n+                            args,\n+                            is_assignee_expr: self.is_lowering_assignee_expr,\n+                        },\n+                        syntax_ptr,\n+                    )\n+                }\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.receiver());"}, {"sha": "2362b08f79a2ae747ff4157f121466c5ae237693", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -232,6 +232,25 @@ impl TyBuilder<()> {\n         TyBuilder::new((), params, parent_subst)\n     }\n \n+    pub fn subst_for_closure(\n+        db: &dyn HirDatabase,\n+        parent: DefWithBodyId,\n+        sig_ty: Ty,\n+    ) -> Substitution {\n+        let sig_ty = sig_ty.cast(Interner);\n+        let self_subst = iter::once(&sig_ty);\n+        let Some(parent) = parent.as_generic_def_id() else {\n+            return Substitution::from_iter(Interner, self_subst);\n+        };\n+        Substitution::from_iter(\n+            Interner,\n+            self_subst\n+                .chain(generics(db.upcast(), parent).placeholder_subst(db).iter(Interner))\n+                .cloned()\n+                .collect::<Vec<_>>(),\n+        )\n+    }\n+\n     pub fn build(self) -> Substitution {\n         let ((), subst) = self.build_internal();\n         subst"}, {"sha": "e5be852bc68c6a49fc9b15c25628a7f5939e39dd", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     method_resolution::{TraitImpls, TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::ChalkContext,\n-    utils::generics,\n+    utils::{generics, ClosureSubst},\n     wrap_empty_binders, AliasEq, AliasTy, BoundVar, CallableDefId, DebruijnIndex, FnDefId,\n     Interner, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Substitution, TraitRef,\n     TraitRefExt, Ty, TyBuilder, TyExt, TyKind, WhereClause,\n@@ -337,7 +337,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        let sig_ty = substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+        let sig_ty = ClosureSubst(substs).sig_ty();\n         let sig = &sig_ty.callable_sig(self.db).expect(\"first closure param should be fn ptr\");\n         let io = rust_ir::FnDefInputsAndOutputDatum {\n             argument_types: sig.params().to_vec(),"}, {"sha": "33c598fe364131e424b8189c1628125cb73d2e78", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,20 +1,22 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n+use chalk_ir::{cast::Cast, FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     type_ref::Rawness,\n-    FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n+    DefWithBodyId, FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n \n use crate::{\n-    db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, ClosureId, DynTy, FnPointer, ImplTraitId, Interner, Lifetime,\n-    ProjectionTy, QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags,\n-    WhereClause,\n+    db::HirDatabase,\n+    from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id, from_placeholder_idx,\n+    to_chalk_trait_id,\n+    utils::{generics, ClosureSubst},\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Canonical, CanonicalVarKinds,\n+    ClosureId, DynTy, FnPointer, ImplTraitId, InEnvironment, Interner, Lifetime, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n pub trait TyExt {\n@@ -46,6 +48,7 @@ pub trait TyExt {\n \n     fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<QuantifiedWhereClause>>;\n     fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId>;\n+    fn is_copy(self, db: &dyn HirDatabase, owner: DefWithBodyId) -> bool;\n \n     /// FIXME: Get rid of this, it's not a good abstraction\n     fn equals_ctor(&self, other: &Ty) -> bool;\n@@ -185,10 +188,7 @@ impl TyExt for Ty {\n                 let sig = db.callable_item_signature(callable_def);\n                 Some(sig.substitute(Interner, parameters))\n             }\n-            TyKind::Closure(.., substs) => {\n-                let sig_param = substs.at(Interner, 0).assert_ty_ref(Interner);\n-                sig_param.callable_sig(db)\n-            }\n+            TyKind::Closure(.., substs) => ClosureSubst(substs).sig_ty().callable_sig(db),\n             _ => None,\n         }\n     }\n@@ -327,6 +327,20 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn is_copy(self, db: &dyn HirDatabase, owner: DefWithBodyId) -> bool {\n+        let crate_id = owner.module(db.upcast()).krate();\n+        let Some(copy_trait) = db.lang_item(crate_id, LangItem::Copy).and_then(|x| x.as_trait()) else {\n+            return false;\n+        };\n+        let trait_ref = TyBuilder::trait_ref(db, copy_trait).push(self).build();\n+        let env = db.trait_environment_for_body(owner);\n+        let goal = Canonical {\n+            value: InEnvironment::new(&env.env, trait_ref.cast(Interner)),\n+            binders: CanonicalVarKinds::empty(Interner),\n+        };\n+        db.trait_solve(crate_id, None, goal).is_some()\n+    }\n+\n     fn equals_ctor(&self, other: &Ty) -> bool {\n         match (self.kind(Interner), other.kind(Interner)) {\n             (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,"}, {"sha": "80b72768b3c34fa0f4f2120c44d20a940d0082ee", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -7,7 +7,7 @@ use hir_def::{\n     path::Path,\n     resolver::{Resolver, ValueNs},\n     type_ref::ConstRef,\n-    ConstId, EnumVariantId,\n+    DefWithBodyId, EnumVariantId,\n };\n use la_arena::{Idx, RawIdx};\n use stdx::never;\n@@ -57,7 +57,7 @@ pub enum ConstEvalError {\n impl From<MirLowerError> for ConstEvalError {\n     fn from(value: MirLowerError) -> Self {\n         match value {\n-            MirLowerError::ConstEvalError(e) => *e,\n+            MirLowerError::ConstEvalError(_, e) => *e,\n             _ => ConstEvalError::MirLowerError(value),\n         }\n     }\n@@ -168,7 +168,7 @@ pub fn try_const_usize(c: &Const) -> Option<u128> {\n pub(crate) fn const_eval_recover(\n     _: &dyn HirDatabase,\n     _: &[String],\n-    _: &ConstId,\n+    _: &DefWithBodyId,\n     _: &Substitution,\n ) -> Result<Const, ConstEvalError> {\n     Err(ConstEvalError::MirLowerError(MirLowerError::Loop))\n@@ -184,10 +184,9 @@ pub(crate) fn const_eval_discriminant_recover(\n \n pub(crate) fn const_eval_query(\n     db: &dyn HirDatabase,\n-    const_id: ConstId,\n+    def: DefWithBodyId,\n     subst: Substitution,\n ) -> Result<Const, ConstEvalError> {\n-    let def = const_id.into();\n     let body = db.mir_body(def)?;\n     let c = interpret_mir(db, &body, subst, false)?;\n     Ok(c)"}, {"sha": "e95e1755363169c4a46754b49f32af271ffb9c33", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 362, "deletions": 33, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,4 +1,4 @@\n-use base_db::fixture::WithFixture;\n+use base_db::{fixture::WithFixture, FileId};\n use chalk_ir::Substitution;\n use hir_def::db::DefDatabase;\n \n@@ -16,21 +16,38 @@ mod intrinsics;\n \n fn simplify(e: ConstEvalError) -> ConstEvalError {\n     match e {\n-        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e)) => {\n+        ConstEvalError::MirEvalError(MirEvalError::InFunction(_, e, _, _)) => {\n             simplify(ConstEvalError::MirEvalError(*e))\n         }\n         _ => e,\n     }\n }\n \n #[track_caller]\n-fn check_fail(ra_fixture: &str, error: ConstEvalError) {\n-    assert_eq!(eval_goal(ra_fixture).map_err(simplify), Err(error));\n+fn check_fail(ra_fixture: &str, error: impl FnOnce(ConstEvalError) -> bool) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    match eval_goal(&db, file_id).map_err(simplify) {\n+        Ok(_) => panic!(\"Expected fail, but it succeeded\"),\n+        Err(e) => assert!(error(e)),\n+    }\n }\n \n #[track_caller]\n fn check_number(ra_fixture: &str, answer: i128) {\n-    let r = eval_goal(ra_fixture).unwrap();\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let r = match eval_goal(&db, file_id) {\n+        Ok(t) => t,\n+        Err(e) => {\n+            let mut err = String::new();\n+            let span_formatter = |file, range| format!(\"{:?} {:?}\", file, range);\n+            match e {\n+                ConstEvalError::MirLowerError(e) => e.pretty_print(&mut err, &db, span_formatter),\n+                ConstEvalError::MirEvalError(e) => e.pretty_print(&mut err, &db, span_formatter),\n+            }\n+            .unwrap();\n+            panic!(\"Error in evaluating goal: {}\", err);\n+        }\n+    };\n     match &r.data(Interner).value {\n         chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n             ConstScalar::Bytes(b, _) => {\n@@ -47,10 +64,9 @@ fn check_number(ra_fixture: &str, answer: i128) {\n     }\n }\n \n-fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+fn eval_goal(db: &TestDB, file_id: FileId) -> Result<Const, ConstEvalError> {\n     let module_id = db.module_for_file(file_id);\n-    let def_map = module_id.def_map(&db);\n+    let def_map = module_id.def_map(db);\n     let scope = &def_map[module_id.local_id].scope;\n     let const_id = scope\n         .declarations()\n@@ -65,7 +81,7 @@ fn eval_goal(ra_fixture: &str) -> Result<Const, ConstEvalError> {\n             _ => None,\n         })\n         .unwrap();\n-    db.const_eval(const_id, Substitution::empty(Interner))\n+    db.const_eval(const_id.into(), Substitution::empty(Interner))\n }\n \n #[test]\n@@ -303,6 +319,81 @@ fn overloaded_index() {\n     );\n }\n \n+#[test]\n+fn overloaded_binop() {\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    enum Color {\n+        Red,\n+        Green,\n+        Yellow,\n+    }\n+\n+    use Color::*;\n+\n+    impl core::ops::Add for Color {\n+        type Output = Color;\n+        fn add(self, rhs: Color) -> Self::Output {\n+            Yellow\n+        }\n+    }\n+\n+    impl core::ops::AddAssign for Color {\n+        fn add_assign(&mut self, rhs: Color) {\n+            *self = Red;\n+        }\n+    }\n+\n+    const GOAL: bool = {\n+        let x = Red + Green;\n+        let mut y = Green;\n+        y += x;\n+        x == Yellow && y == Red && Red + Green == Yellow && Red + Red == Yellow && Yellow + Green == Yellow\n+    };\n+    \"#,\n+        1,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    impl core::ops::Add for usize {\n+        type Output = usize;\n+        fn add(self, rhs: usize) -> Self::Output {\n+            self + rhs\n+        }\n+    }\n+\n+    impl core::ops::AddAssign for usize {\n+        fn add_assign(&mut self, rhs: usize) {\n+            *self += rhs;\n+        }\n+    }\n+\n+    #[lang = \"shl\"]\n+    pub trait Shl<Rhs = Self> {\n+        type Output;\n+\n+        fn shl(self, rhs: Rhs) -> Self::Output;\n+    }\n+\n+    impl Shl<u8> for usize {\n+        type Output = usize;\n+\n+        fn shl(self, rhs: u8) -> Self::Output {\n+            self << rhs\n+        }\n+    }\n+\n+    const GOAL: usize = {\n+        let mut x = 10;\n+        x += 20;\n+        2 + 2 + (x << 1u8)\n+    };\"#,\n+        64,\n+    );\n+}\n+\n #[test]\n fn function_call() {\n     check_number(\n@@ -426,6 +517,16 @@ fn generic_fn() {\n         \"#,\n         12,\n     );\n+    check_number(\n+        r#\"\n+        const fn y<T>(b: T) -> (T, ) {\n+            let alloc = b;\n+            (alloc, )\n+        }\n+        const GOAL: u8 = y(2).0;\n+        \"#,\n+        2,\n+    );\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n@@ -590,6 +691,30 @@ fn loops() {\n         \"#,\n         8,\n     );\n+    check_number(\n+        r#\"\n+    //- minicore: add\n+    const GOAL: u8 = {\n+        let mut x = 0;\n+        'a: loop {\n+            'b: loop {\n+                'c: while x < 20 {\n+                    'd: while x < 5 {\n+                        'e: loop {\n+                            x += 1;\n+                            continue 'c;\n+                        };\n+                    };\n+                    x += 1;\n+                };\n+                break 'a;\n+            };\n+        }\n+        x\n+    };\n+        \"#,\n+        20,\n+    );\n }\n \n #[test]\n@@ -790,10 +915,12 @@ fn path_pattern_matching() {\n \n     use Season::*;\n \n+    const MY_SEASON: Season = Summer;\n+\n     const fn f(x: Season) -> i32 {\n         match x {\n             Spring => 1,\n-            Summer => 2,\n+            MY_SEASON => 2,\n             Fall => 3,\n             Winter => 4,\n         }\n@@ -944,19 +1071,10 @@ fn function_param_patterns() {\n fn match_guards() {\n     check_number(\n         r#\"\n-    //- minicore: option, eq\n-    impl<T: PartialEq> PartialEq for Option<T> {\n-        fn eq(&self, other: &Rhs) -> bool {\n-            match (self, other) {\n-                (Some(x), Some(y)) => x == y,\n-                (None, None) => true,\n-                _ => false,\n-            }\n-        }\n-    }\n+    //- minicore: option\n     fn f(x: Option<i32>) -> i32 {\n         match x {\n-            y if y == Some(42) => 42000,\n+            y if let Some(42) = y => 42000,\n             Some(y) => y,\n             None => 10\n         }\n@@ -967,6 +1085,59 @@ fn match_guards() {\n     );\n }\n \n+#[test]\n+fn result_layout_niche_optimization() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, result\n+    const GOAL: i32 = match Some(2).ok_or(Some(2)) {\n+        Ok(x) => x,\n+        Err(_) => 1000,\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result\n+    pub enum AlignmentEnum64 {\n+        _Align1Shl0 = 1 << 0,\n+        _Align1Shl1 = 1 << 1,\n+        _Align1Shl2 = 1 << 2,\n+        _Align1Shl3 = 1 << 3,\n+        _Align1Shl4 = 1 << 4,\n+        _Align1Shl5 = 1 << 5,\n+    }\n+    const GOAL: Result<AlignmentEnum64, ()> = {\n+        let align = Err(());\n+        align\n+    };\n+    \"#,\n+        0, // It is 0 since result is niche encoded and 1 is valid for `AlignmentEnum64`\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: result\n+    pub enum AlignmentEnum64 {\n+        _Align1Shl0 = 1 << 0,\n+        _Align1Shl1 = 1 << 1,\n+        _Align1Shl2 = 1 << 2,\n+        _Align1Shl3 = 1 << 3,\n+        _Align1Shl4 = 1 << 4,\n+        _Align1Shl5 = 1 << 5,\n+    }\n+    const GOAL: i32 = {\n+        let align = Ok::<_, ()>(AlignmentEnum64::_Align1Shl0);\n+        match align {\n+            Ok(_) => 2,\n+            Err(_) => 1,\n+        }\n+    };\n+    \"#,\n+        2,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number(\n@@ -1147,6 +1318,16 @@ fn closures() {\n     check_number(\n         r#\"\n     //- minicore: fn, copy\n+    const GOAL: i32 = {\n+        let c: fn(i32) -> i32 = |x| 2 * x;\n+        c(2) + c(10)\n+    };\n+        \"#,\n+        24,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n     struct X(i32);\n     impl X {\n         fn mult(&mut self, n: i32) {\n@@ -1180,6 +1361,36 @@ fn closures() {\n     );\n }\n \n+#[test]\n+fn closure_and_impl_fn() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    fn closure_wrapper<F: FnOnce() -> i32>(c: F) -> impl FnOnce() -> F {\n+        || c\n+    }\n+\n+    const GOAL: i32 = {\n+        let y = 5;\n+        let c = closure_wrapper(|| y);\n+        c()()\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn, copy\n+    fn f<T, F: Fn() -> T>(t: F) -> impl Fn() -> T {\n+        move || t()\n+    }\n+\n+    const GOAL: i32 = f(|| 2)();\n+        \"#,\n+        2,\n+    );\n+}\n+\n #[test]\n fn or_pattern() {\n     check_number(\n@@ -1218,6 +1429,23 @@ fn or_pattern() {\n     );\n }\n \n+#[test]\n+fn function_pointer_in_constants() {\n+    check_number(\n+        r#\"\n+    struct Foo {\n+        f: fn(u8) -> u8,\n+    }\n+    const FOO: Foo = Foo { f: add2 };\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = (FOO.f)(3);\n+        \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn function_pointer() {\n     check_number(\n@@ -1432,6 +1660,51 @@ fn dyn_trait() {\n     );\n }\n \n+#[test]\n+fn boxes() {\n+    check_number(\n+        r#\"\n+//- minicore: coerce_unsized, deref_mut, slice\n+use core::ops::{Deref, DerefMut};\n+use core::{marker::Unsize, ops::CoerceUnsized};\n+\n+#[lang = \"owned_box\"]\n+pub struct Box<T: ?Sized> {\n+    inner: *mut T,\n+}\n+impl<T> Box<T> {\n+    fn new(t: T) -> Self {\n+        #[rustc_box]\n+        Box::new(t)\n+    }\n+}\n+\n+impl<T: ?Sized> Deref for Box<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+impl<T: ?Sized> DerefMut for Box<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut **self\n+    }\n+}\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+\n+const GOAL: usize = {\n+    let x = Box::new(5);\n+    let y: Box<[i32]> = Box::new([1, 2, 3]);\n+    *x + y.len()\n+};\n+\"#,\n+        8,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number(\n@@ -1504,6 +1777,37 @@ fn consts() {\n     );\n }\n \n+#[test]\n+fn statics() {\n+    check_number(\n+        r#\"\n+    //- minicore: cell\n+    use core::cell::Cell;\n+    fn f() -> i32 {\n+        static S: Cell<i32> = Cell::new(10);\n+        S.set(S.get() + 1);\n+        S.get()\n+    }\n+    const GOAL: i32 = f() + f() + f();\n+    \"#,\n+        36,\n+    );\n+}\n+\n+#[test]\n+fn extern_weak_statics() {\n+    check_number(\n+        r#\"\n+    extern \"C\" {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+    }\n+    const GOAL: usize = __dso_handle as usize;\n+    \"#,\n+        0,\n+    );\n+}\n+\n #[test]\n fn enums() {\n     check_number(\n@@ -1531,13 +1835,13 @@ fn enums() {\n     \"#,\n         0,\n     );\n-    let r = eval_goal(\n+    let (db, file_id) = TestDB::with_single_file(\n         r#\"\n         enum E { A = 1, B }\n         const GOAL: E = E::A;\n         \"#,\n-    )\n-    .unwrap();\n+    );\n+    let r = eval_goal(&db, file_id).unwrap();\n     assert_eq!(try_const_usize(&r), Some(1));\n }\n \n@@ -1550,7 +1854,7 @@ fn const_loop() {\n     const F2: i32 = 2 * F1;\n     const GOAL: i32 = F3;\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::Loop),\n+        |e| e == ConstEvalError::MirLowerError(MirLowerError::Loop),\n     );\n }\n \n@@ -1609,8 +1913,7 @@ fn const_generic_subst_assoc_const_impl() {\n \n #[test]\n fn const_trait_assoc() {\n-    // FIXME: this should evaluate to 0\n-    check_fail(\n+    check_number(\n         r#\"\n     struct U0;\n     trait ToConst {\n@@ -1619,9 +1922,35 @@ fn const_trait_assoc() {\n     impl ToConst for U0 {\n         const VAL: usize = 0;\n     }\n-    const GOAL: usize = U0::VAL;\n+    impl ToConst for i32 {\n+        const VAL: usize = 32;\n+    }\n+    const GOAL: usize = U0::VAL + i32::VAL;\n     \"#,\n-        ConstEvalError::MirLowerError(MirLowerError::IncompleteExpr),\n+        32,\n+    );\n+    check_number(\n+        r#\"\n+    struct S<T>(*mut T);\n+\n+    trait MySized: Sized {\n+        const SIZE: S<Self> = S(1 as *mut Self);\n+    }\n+\n+    impl MySized for i32 {\n+        const SIZE: S<i32> = S(10 as *mut i32);\n+    }\n+\n+    impl MySized for i64 {\n+    }\n+\n+    const fn f<T: MySized>() -> usize {\n+        T::SIZE.0 as usize\n+    }\n+\n+    const GOAL: usize = f::<i32>() + f::<i64>() * 2;\n+    \"#,\n+        12,\n     );\n }\n \n@@ -1631,7 +1960,7 @@ fn exec_limits() {\n         r#\"\n     const GOAL: usize = loop {};\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n+        |e| e == ConstEvalError::MirEvalError(MirEvalError::ExecutionLimitExceeded),\n     );\n     check_fail(\n         r#\"\n@@ -1640,7 +1969,7 @@ fn exec_limits() {\n     }\n     const GOAL: i32 = f(0);\n     \"#,\n-        ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n+        |e| e == ConstEvalError::MirEvalError(MirEvalError::StackOverflow),\n     );\n     // Reasonable code should still work\n     check_number(\n@@ -1665,14 +1994,14 @@ fn exec_limits() {\n \n #[test]\n fn type_error() {\n-    let e = eval_goal(\n+    check_fail(\n         r#\"\n     const GOAL: u8 = {\n         let x: u16 = 2;\n         let y: (u8, u8) = x;\n         y.0\n     };\n     \"#,\n+        |e| matches!(e, ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_))),\n     );\n-    assert!(matches!(e, Err(ConstEvalError::MirLowerError(MirLowerError::TypeMismatch(_)))));\n }"}, {"sha": "40e68823acdff1c77f5f7d6900c3ca197022e99a", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -67,6 +67,135 @@ fn wrapping_add() {\n     );\n }\n \n+#[test]\n+fn allocator() {\n+    check_number(\n+        r#\"\n+        extern \"Rust\" {\n+            #[rustc_allocator]\n+            fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n+            #[rustc_deallocator]\n+            fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+            #[rustc_reallocator]\n+            fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;\n+            #[rustc_allocator_zeroed]\n+            fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n+        }\n+\n+        const GOAL: u8 = unsafe {\n+            let ptr = __rust_alloc(4, 1);\n+            let ptr2 = ((ptr as usize) + 1) as *mut u8;\n+            *ptr = 23;\n+            *ptr2 = 32;\n+            let ptr = __rust_realloc(ptr, 4, 1, 8);\n+            let ptr2 = ((ptr as usize) + 1) as *mut u8;\n+            *ptr + *ptr2\n+        };\n+        \"#,\n+        55,\n+    );\n+}\n+\n+#[test]\n+fn overflowing_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+        }\n+\n+        const GOAL: u8 = add_with_overflow(1, 2).0;\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn add_with_overflow<T>(x: T, y: T) -> (T, bool);\n+        }\n+\n+        const GOAL: u8 = add_with_overflow(1, 2).1 as u8;\n+        \"#,\n+        0,\n+    );\n+}\n+\n+#[test]\n+fn needs_drop() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy, sized\n+        extern \"rust-intrinsic\" {\n+            pub fn needs_drop<T: ?Sized>() -> bool;\n+        }\n+        struct X;\n+        const GOAL: bool = !needs_drop::<i32>() && needs_drop::<X>();\n+        \"#,\n+        1,\n+    );\n+}\n+\n+#[test]\n+fn likely() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn likely(b: bool) -> bool;\n+            pub fn unlikely(b: bool) -> bool;\n+        }\n+\n+        const GOAL: bool = likely(true) && unlikely(true) && !likely(false) && !unlikely(false);\n+        \"#,\n+        1,\n+    );\n+}\n+\n+#[test]\n+fn atomic() {\n+    check_number(\n+        r#\"\n+        //- minicore: copy\n+        extern \"rust-intrinsic\" {\n+            pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n+            pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+            pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n+            pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n+            pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n+            pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n+        }\n+\n+        fn should_not_reach() {\n+            _ // fails the test if executed\n+        }\n+\n+        const GOAL: i32 = {\n+            let mut x = 5;\n+            atomic_store_release(&mut x, 10);\n+            let mut y = atomic_xchg_acquire(&mut x, 100);\n+            atomic_xadd_acqrel(&mut y, 20);\n+            if (30, true) != atomic_cxchg_release_seqcst(&mut y, 30, 40) {\n+                should_not_reach();\n+            }\n+            if (40, false) != atomic_cxchg_release_seqcst(&mut y, 30, 50) {\n+                should_not_reach();\n+            }\n+            if (40, true) != atomic_cxchgweak_acquire_acquire(&mut y, 40, 30) {\n+                should_not_reach();\n+            }\n+            let mut z = atomic_xsub_seqcst(&mut x, -200);\n+            atomic_xor_seqcst(&mut x, 1024);\n+            atomic_load_seqcst(&x) + z * 3 + atomic_load_seqcst(&y) * 2\n+        };\n+        \"#,\n+        660 + 1024,\n+    );\n+}\n+\n #[test]\n fn offset() {\n     check_number("}, {"sha": "963b3b72abb7f93e5db6e62b2138ced0d7022697", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -5,7 +5,7 @@ use std::sync::Arc;\n \n use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n-    db::DefDatabase, hir::ExprId, layout::TargetDataLayout, AdtId, BlockId, ConstId, ConstParamId,\n+    db::DefDatabase, hir::ExprId, layout::TargetDataLayout, AdtId, BlockId, ConstParamId,\n     DefWithBodyId, EnumVariantId, FunctionId, GenericDefId, ImplId, LifetimeParamId, LocalFieldId,\n     TypeOrConstParamId, VariantId,\n };\n@@ -59,7 +59,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n     #[salsa::invoke(crate::consteval::const_eval_query)]\n     #[salsa::cycle(crate::consteval::const_eval_recover)]\n-    fn const_eval(&self, def: ConstId, subst: Substitution) -> Result<Const, ConstEvalError>;\n+    fn const_eval(&self, def: DefWithBodyId, subst: Substitution) -> Result<Const, ConstEvalError>;\n \n     #[salsa::invoke(crate::consteval::const_eval_discriminant_variant)]\n     #[salsa::cycle(crate::consteval::const_eval_discriminant_recover)]"}, {"sha": "a0f6b9368ee01ad1ce3c91cba8d9390a76ab8f77", "filename": "crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -772,7 +772,7 @@ impl<'p> Fields<'p> {\n \n         (0..fields_len).map(|idx| LocalFieldId::from_raw(idx.into())).filter_map(move |fid| {\n             let ty = field_ty[fid].clone().substitute(Interner, substs);\n-            let ty = normalize(cx.db, cx.body, ty);\n+            let ty = normalize(cx.db, cx.db.trait_environment_for_body(cx.body), ty);\n             let is_visible = matches!(adt, hir_def::AdtId::EnumId(..))\n                 || visibility[fid].is_visible_from(cx.db.upcast(), cx.module);\n             let is_uninhabited = cx.is_uninhabited(&ty);"}, {"sha": "3cfe78141d43be764bca81e96cc681f04e8cac9d", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 99, "deletions": 78, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -32,7 +32,7 @@ use crate::{\n     mapping::from_chalk,\n     mir::pad16,\n     primitive, to_assoc_type_id,\n-    utils::{self, generics},\n+    utils::{self, generics, ClosureSubst},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstScalar, ConstValue,\n     DomainGoal, GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives,\n     MemoryMap, Mutability, OpaqueTy, ProjectionTy, ProjectionTyExt, QuantifiedWhereClause, Scalar,\n@@ -419,6 +419,16 @@ impl HirDisplay for Const {\n             }\n             ConstValue::Concrete(c) => match &c.interned {\n                 ConstScalar::Bytes(b, m) => render_const_scalar(f, &b, m, &data.ty),\n+                ConstScalar::UnevaluatedConst(c, parameters) => {\n+                    let const_data = f.db.const_data(*c);\n+                    write!(\n+                        f,\n+                        \"{}\",\n+                        const_data.name.as_ref().and_then(|x| x.as_str()).unwrap_or(\"_\")\n+                    )?;\n+                    hir_fmt_generics(f, parameters, Some((*c).into()))?;\n+                    Ok(())\n+                }\n                 ConstScalar::Unknown => f.write_char('_'),\n             },\n         }\n@@ -485,7 +495,7 @@ fn render_const_scalar(\n         chalk_ir::TyKind::Ref(_, _, t) => match t.kind(Interner) {\n             chalk_ir::TyKind::Str => {\n                 let addr = usize::from_le_bytes(b[0..b.len() / 2].try_into().unwrap());\n-                let bytes = memory_map.0.get(&addr).map(|x| &**x).unwrap_or(&[]);\n+                let bytes = memory_map.memory.get(&addr).map(|x| &**x).unwrap_or(&[]);\n                 let s = std::str::from_utf8(bytes).unwrap_or(\"<utf8-error>\");\n                 write!(f, \"{s:?}\")\n             }\n@@ -574,6 +584,11 @@ fn render_const_scalar(\n             hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n         },\n         chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n+        chalk_ir::TyKind::Raw(_, _) => {\n+            let x = u128::from_le_bytes(pad16(b, false));\n+            write!(f, \"{:#X} as \", x)?;\n+            ty.hir_fmt(f)\n+        }\n         _ => f.write_str(\"<not-supported>\"),\n     }\n }\n@@ -794,82 +809,9 @@ impl HirDisplay for Ty {\n                 }\n                 f.end_location_link();\n \n-                if parameters.len(Interner) > 0 {\n-                    let parameters_to_write = if f.display_target.is_source_code()\n-                        || f.omit_verbose_types()\n-                    {\n-                        match self\n-                            .as_generic_def(db)\n-                            .map(|generic_def_id| db.generic_defaults(generic_def_id))\n-                            .filter(|defaults| !defaults.is_empty())\n-                        {\n-                            None => parameters.as_slice(Interner),\n-                            Some(default_parameters) => {\n-                                fn should_show(\n-                                    parameter: &GenericArg,\n-                                    default_parameters: &[Binders<GenericArg>],\n-                                    i: usize,\n-                                    parameters: &Substitution,\n-                                ) -> bool {\n-                                    if parameter.ty(Interner).map(|x| x.kind(Interner))\n-                                        == Some(&TyKind::Error)\n-                                    {\n-                                        return true;\n-                                    }\n-                                    if let Some(ConstValue::Concrete(c)) = parameter\n-                                        .constant(Interner)\n-                                        .map(|x| &x.data(Interner).value)\n-                                    {\n-                                        if c.interned == ConstScalar::Unknown {\n-                                            return true;\n-                                        }\n-                                    }\n-                                    let default_parameter = match default_parameters.get(i) {\n-                                        Some(x) => x,\n-                                        None => return true,\n-                                    };\n-                                    let actual_default =\n-                                        default_parameter.clone().substitute(Interner, &parameters);\n-                                    parameter != &actual_default\n-                                }\n-                                let mut default_from = 0;\n-                                for (i, parameter) in parameters.iter(Interner).enumerate() {\n-                                    if should_show(parameter, &default_parameters, i, parameters) {\n-                                        default_from = i + 1;\n-                                    }\n-                                }\n-                                &parameters.as_slice(Interner)[0..default_from]\n-                            }\n-                        }\n-                    } else {\n-                        parameters.as_slice(Interner)\n-                    };\n-                    if !parameters_to_write.is_empty() {\n-                        write!(f, \"<\")?;\n-\n-                        if f.display_target.is_source_code() {\n-                            let mut first = true;\n-                            for generic_arg in parameters_to_write {\n-                                if !first {\n-                                    write!(f, \", \")?;\n-                                }\n-                                first = false;\n-\n-                                if generic_arg.ty(Interner).map(|ty| ty.kind(Interner))\n-                                    == Some(&TyKind::Error)\n-                                {\n-                                    write!(f, \"_\")?;\n-                                } else {\n-                                    generic_arg.hir_fmt(f)?;\n-                                }\n-                            }\n-                        } else {\n-                            f.write_joined(parameters_to_write, \", \")?;\n-                        }\n+                let generic_def = self.as_generic_def(db);\n \n-                        write!(f, \">\")?;\n-                    }\n-                }\n+                hir_fmt_generics(f, parameters, generic_def)?;\n             }\n             TyKind::AssociatedType(assoc_type_id, parameters) => {\n                 let type_alias = from_assoc_type_id(*assoc_type_id);\n@@ -983,7 +925,7 @@ impl HirDisplay for Ty {\n                     }\n                     _ => (),\n                 }\n-                let sig = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db);\n+                let sig = ClosureSubst(substs).sig_ty().callable_sig(db);\n                 if let Some(sig) = sig {\n                     let (def, _) = db.lookup_intern_closure((*id).into());\n                     let infer = db.infer(def);\n@@ -1141,6 +1083,85 @@ impl HirDisplay for Ty {\n     }\n }\n \n+fn hir_fmt_generics(\n+    f: &mut HirFormatter<'_>,\n+    parameters: &Substitution,\n+    generic_def: Option<hir_def::GenericDefId>,\n+) -> Result<(), HirDisplayError> {\n+    let db = f.db;\n+    if parameters.len(Interner) > 0 {\n+        let parameters_to_write = if f.display_target.is_source_code() || f.omit_verbose_types() {\n+            match generic_def\n+                .map(|generic_def_id| db.generic_defaults(generic_def_id))\n+                .filter(|defaults| !defaults.is_empty())\n+            {\n+                None => parameters.as_slice(Interner),\n+                Some(default_parameters) => {\n+                    fn should_show(\n+                        parameter: &GenericArg,\n+                        default_parameters: &[Binders<GenericArg>],\n+                        i: usize,\n+                        parameters: &Substitution,\n+                    ) -> bool {\n+                        if parameter.ty(Interner).map(|x| x.kind(Interner)) == Some(&TyKind::Error)\n+                        {\n+                            return true;\n+                        }\n+                        if let Some(ConstValue::Concrete(c)) =\n+                            parameter.constant(Interner).map(|x| &x.data(Interner).value)\n+                        {\n+                            if c.interned == ConstScalar::Unknown {\n+                                return true;\n+                            }\n+                        }\n+                        let default_parameter = match default_parameters.get(i) {\n+                            Some(x) => x,\n+                            None => return true,\n+                        };\n+                        let actual_default =\n+                            default_parameter.clone().substitute(Interner, &parameters);\n+                        parameter != &actual_default\n+                    }\n+                    let mut default_from = 0;\n+                    for (i, parameter) in parameters.iter(Interner).enumerate() {\n+                        if should_show(parameter, &default_parameters, i, parameters) {\n+                            default_from = i + 1;\n+                        }\n+                    }\n+                    &parameters.as_slice(Interner)[0..default_from]\n+                }\n+            }\n+        } else {\n+            parameters.as_slice(Interner)\n+        };\n+        if !parameters_to_write.is_empty() {\n+            write!(f, \"<\")?;\n+\n+            if f.display_target.is_source_code() {\n+                let mut first = true;\n+                for generic_arg in parameters_to_write {\n+                    if !first {\n+                        write!(f, \", \")?;\n+                    }\n+                    first = false;\n+\n+                    if generic_arg.ty(Interner).map(|ty| ty.kind(Interner)) == Some(&TyKind::Error)\n+                    {\n+                        write!(f, \"_\")?;\n+                    } else {\n+                        generic_arg.hir_fmt(f)?;\n+                    }\n+                }\n+            } else {\n+                f.write_joined(parameters_to_write, \", \")?;\n+            }\n+\n+            write!(f, \">\")?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n impl HirDisplay for CallableSig {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write!(f, \"fn(\")?;"}, {"sha": "ba0b6d254b79bbc91f160823c8c7be54845b9ed1", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -44,7 +44,7 @@ use crate::{\n     db::HirDatabase, fold_tys, infer::coerce::CoerceMany, lower::ImplTraitLoweringMode,\n     static_lifetime, to_assoc_type_id, traits::FnTrait, AliasEq, AliasTy, ClosureId, DomainGoal,\n     GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n-    TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -117,11 +117,10 @@ pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<Infer\n ///\n /// This is appropriate to use only after type-check: it assumes\n /// that normalization will succeed, for example.\n-pub(crate) fn normalize(db: &dyn HirDatabase, owner: DefWithBodyId, ty: Ty) -> Ty {\n+pub(crate) fn normalize(db: &dyn HirDatabase, trait_env: Arc<TraitEnvironment>, ty: Ty) -> Ty {\n     if !ty.data(Interner).flags.intersects(TypeFlags::HAS_PROJECTION) {\n         return ty;\n     }\n-    let trait_env = db.trait_environment_for_body(owner);\n     let mut table = unify::InferenceTable::new(db, trait_env);\n \n     let ty_with_vars = table.normalize_associated_types_in(ty);"}, {"sha": "d3acbf7b4045eae7310157a758f1bb2f3fee8346", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -2,7 +2,11 @@\n \n use std::{cmp, collections::HashMap, convert::Infallible, mem};\n \n-use chalk_ir::{cast::Cast, AliasEq, AliasTy, FnSubst, Mutability, TyKind, WhereClause};\n+use chalk_ir::{\n+    cast::Cast,\n+    fold::{FallibleTypeFolder, TypeFoldable},\n+    AliasEq, AliasTy, BoundVar, DebruijnIndex, FnSubst, Mutability, TyKind, WhereClause,\n+};\n use hir_def::{\n     data::adt::VariantData,\n     hir::{\n@@ -11,7 +15,7 @@ use hir_def::{\n     },\n     lang_item::LangItem,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n-    FieldId, HasModule, VariantId,\n+    DefWithBodyId, FieldId, HasModule, VariantId,\n };\n use hir_expand::name;\n use rustc_hash::FxHashMap;\n@@ -20,12 +24,13 @@ use stdx::never;\n \n use crate::{\n     db::HirDatabase,\n+    from_placeholder_idx, make_binders,\n     mir::{BorrowKind, MirSpan, ProjectionElem},\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n-    utils::{self, pattern_matching_dereference_count},\n-    Adjust, Adjustment, Canonical, CanonicalVarKinds, ChalkTraitId, ClosureId, DynTy, FnPointer,\n-    FnSig, InEnvironment, Interner, Substitution, Ty, TyBuilder, TyExt,\n+    utils::{self, generics, pattern_matching_dereference_count, Generics},\n+    Adjust, Adjustment, Binders, ChalkTraitId, ClosureId, DynTy, FnPointer, FnSig, Interner,\n+    Substitution, Ty, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -117,7 +122,7 @@ impl HirPlace {\n     fn ty(&self, ctx: &mut InferenceContext<'_>) -> Ty {\n         let mut ty = ctx.table.resolve_completely(ctx.result[self.local].clone());\n         for p in &self.projections {\n-            ty = p.projected_ty(ty, ctx.db, |_, _| {\n+            ty = p.projected_ty(ty, ctx.db, |_, _, _| {\n                 unreachable!(\"Closure field only happens in MIR\");\n             });\n         }\n@@ -152,7 +157,7 @@ pub struct CapturedItem {\n     pub(crate) place: HirPlace,\n     pub(crate) kind: CaptureKind,\n     pub(crate) span: MirSpan,\n-    pub(crate) ty: Ty,\n+    pub(crate) ty: Binders<Ty>,\n }\n \n impl CapturedItem {\n@@ -232,6 +237,52 @@ pub(crate) struct CapturedItemWithoutTy {\n \n impl CapturedItemWithoutTy {\n     fn with_ty(self, ctx: &mut InferenceContext<'_>) -> CapturedItem {\n+        fn replace_placeholder_with_binder(\n+            db: &dyn HirDatabase,\n+            owner: DefWithBodyId,\n+            ty: Ty,\n+        ) -> Binders<Ty> {\n+            struct Filler<'a> {\n+                db: &'a dyn HirDatabase,\n+                generics: Generics,\n+            }\n+            impl FallibleTypeFolder<Interner> for Filler<'_> {\n+                type Error = ();\n+\n+                fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n+                    self\n+                }\n+\n+                fn interner(&self) -> Interner {\n+                    Interner\n+                }\n+\n+                fn try_fold_free_placeholder_ty(\n+                    &mut self,\n+                    idx: chalk_ir::PlaceholderIndex,\n+                    _outer_binder: DebruijnIndex,\n+                ) -> std::result::Result<Ty, Self::Error> {\n+                    let x = from_placeholder_idx(self.db, idx);\n+                    let Some(idx) = self.generics.param_idx(x) else {\n+                        return Err(());\n+                    };\n+                    Ok(TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+                        .intern(Interner))\n+                }\n+            }\n+            let g_def = match owner {\n+                DefWithBodyId::FunctionId(f) => Some(f.into()),\n+                DefWithBodyId::StaticId(_) => None,\n+                DefWithBodyId::ConstId(f) => Some(f.into()),\n+                DefWithBodyId::VariantId(f) => Some(f.into()),\n+            };\n+            let Some(generics) = g_def.map(|g_def| generics(db.upcast(), g_def)) else {\n+                return Binders::empty(Interner, ty);\n+            };\n+            let filler = &mut Filler { db, generics };\n+            let result = ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST).unwrap_or(ty);\n+            make_binders(db, &filler.generics, result)\n+        }\n         let ty = self.place.ty(ctx).clone();\n         let ty = match &self.kind {\n             CaptureKind::ByValue => ty,\n@@ -243,7 +294,12 @@ impl CapturedItemWithoutTy {\n                 TyKind::Ref(m, static_lifetime(), ty).intern(Interner)\n             }\n         };\n-        CapturedItem { place: self.place, kind: self.kind, span: self.span, ty }\n+        CapturedItem {\n+            place: self.place,\n+            kind: self.kind,\n+            span: self.span,\n+            ty: replace_placeholder_with_binder(ctx.db, ctx.owner, ty),\n+        }\n     }\n }\n \n@@ -590,17 +646,7 @@ impl InferenceContext<'_> {\n             // without creating query cycles.\n             return self.result.closure_info.get(id).map(|x| x.1 == FnTrait::Fn).unwrap_or(true);\n         }\n-        let crate_id = self.owner.module(self.db.upcast()).krate();\n-        let Some(copy_trait) = self.db.lang_item(crate_id, LangItem::Copy).and_then(|x| x.as_trait()) else {\n-            return false;\n-        };\n-        let trait_ref = TyBuilder::trait_ref(self.db, copy_trait).push(ty).build();\n-        let env = self.db.trait_environment_for_body(self.owner);\n-        let goal = Canonical {\n-            value: InEnvironment::new(&env.env, trait_ref.cast(Interner)),\n-            binders: CanonicalVarKinds::empty(Interner),\n-        };\n-        self.db.trait_solve(crate_id, None, goal).is_some()\n+        ty.is_copy(self.db, self.owner)\n     }\n \n     fn select_from_expr(&mut self, expr: ExprId) {"}, {"sha": "d613a5ff5049d1300420b3c8aa0c248c83d3a738", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -21,8 +21,10 @@ use crate::{\n         Adjust, Adjustment, AutoBorrow, InferOk, InferenceContext, OverloadedDeref, PointerCast,\n         TypeError, TypeMismatch,\n     },\n-    static_lifetime, Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner,\n-    Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n+    static_lifetime,\n+    utils::ClosureSubst,\n+    Canonical, DomainGoal, FnPointer, FnSig, Guidance, InEnvironment, Interner, Solution,\n+    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::unify::InferenceTable;\n@@ -670,7 +672,7 @@ impl<'a> InferenceTable<'a> {\n }\n \n fn coerce_closure_fn_ty(closure_substs: &Substitution, safety: chalk_ir::Safety) -> Ty {\n-    let closure_sig = closure_substs.at(Interner, 0).assert_ty_ref(Interner).clone();\n+    let closure_sig = ClosureSubst(closure_substs).sig_ty().clone();\n     match closure_sig.kind(Interner) {\n         TyKind::Function(fn_ty) => TyKind::Function(FnPointer {\n             num_binders: fn_ty.num_binders,"}, {"sha": "06ca9b026e378c30c465065f5bc85cfb866964db", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -282,7 +282,7 @@ impl<'a> InferenceContext<'a> {\n                         let closure_id = self.db.intern_closure((self.owner, tgt_expr)).into();\n                         let closure_ty = TyKind::Closure(\n                             closure_id,\n-                            Substitution::from1(Interner, sig_ty.clone()),\n+                            TyBuilder::subst_for_closure(self.db, self.owner, sig_ty.clone()),\n                         )\n                         .intern(Interner);\n                         self.deferred_closures.entry(closure_id).or_default();"}, {"sha": "ebbf16caee1e8c6175261a77209aef4371f52e61", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,5 +1,7 @@\n //! Compute the binary representation of a type\n \n+use std::sync::Arc;\n+\n use base_db::CrateId;\n use chalk_ir::{AdtId, TyKind};\n use hir_def::{\n@@ -13,8 +15,8 @@ use la_arena::{Idx, RawIdx};\n use stdx::never;\n \n use crate::{\n-    consteval::try_const_usize, db::HirDatabase, layout::adt::struct_variant_idx, Interner,\n-    Substitution, Ty,\n+    consteval::try_const_usize, db::HirDatabase, infer::normalize, layout::adt::struct_variant_idx,\n+    utils::ClosureSubst, Interner, Substitution, TraitEnvironment, Ty,\n };\n \n pub use self::{\n@@ -80,6 +82,8 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n     let Some(target) = db.target_data_layout(krate) else { return Err(LayoutError::TargetLayoutNotAvailable) };\n     let cx = LayoutCx { krate, target: &target };\n     let dl = &*cx.current_data_layout();\n+    let trait_env = Arc::new(TraitEnvironment::empty(krate));\n+    let ty = normalize(db, trait_env, ty.clone());\n     Ok(match ty.kind(Interner) {\n         TyKind::Adt(AdtId(def), subst) => db.layout_of_adt(*def, subst.clone())?,\n         TyKind::Scalar(s) => match s {\n@@ -146,7 +150,7 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n         }\n         TyKind::Array(element, count) => {\n             let count = try_const_usize(&count).ok_or(LayoutError::UserError(\n-                \"mismatched type of const generic parameter\".to_string(),\n+                \"unevaluated or mistyped const generic parameter\".to_string(),\n             ))? as u64;\n             let element = layout_of_ty(db, element, krate)?;\n             let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n@@ -252,13 +256,19 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n                 }\n             }\n         }\n-        TyKind::Closure(c, _) => {\n+        TyKind::Closure(c, subst) => {\n             let (def, _) = db.lookup_intern_closure((*c).into());\n             let infer = db.infer(def);\n             let (captures, _) = infer.closure_info(c);\n             let fields = captures\n                 .iter()\n-                .map(|x| layout_of_ty(db, &x.ty, krate))\n+                .map(|x| {\n+                    layout_of_ty(\n+                        db,\n+                        &x.ty.clone().substitute(Interner, ClosureSubst(subst).parent_subst()),\n+                        krate,\n+                    )\n+                })\n                 .collect::<Result<Vec<_>, _>>()?;\n             let fields = fields.iter().collect::<Vec<_>>();\n             let fields = fields.iter().collect::<Vec<_>>();"}, {"sha": "1502ab14cc7ceb814a7f7fed068749c0bac14ec7", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -218,6 +218,22 @@ fn generic() {\n     }\n }\n \n+#[test]\n+fn associated_types() {\n+    size_and_align! {\n+        trait Tr {\n+            type Ty;\n+        }\n+\n+        impl Tr for i32 {\n+            type Ty = i64;\n+        }\n+\n+        struct Foo<A: Tr>(<A as Tr>::Ty);\n+        struct Goal(Foo<i32>);\n+    }\n+}\n+\n #[test]\n fn return_position_impl_trait() {\n     size_and_align_expr! {"}, {"sha": "071d95839ecce617850d7b8f435af994ab0a6415", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -44,10 +44,10 @@ use chalk_ir::{\n     NoSolution, TyData,\n };\n use either::Either;\n-use hir_def::{hir::ExprId, type_ref::Rawness, TypeOrConstParamId};\n+use hir_def::{hir::ExprId, type_ref::Rawness, ConstId, TypeOrConstParamId};\n use hir_expand::name;\n use la_arena::{Arena, Idx};\n-use mir::MirEvalError;\n+use mir::{MirEvalError, VTableMap};\n use rustc_hash::FxHashSet;\n use traits::FnTrait;\n use utils::Generics;\n@@ -151,11 +151,14 @@ pub type WhereClause = chalk_ir::WhereClause<Interner>;\n /// the necessary bits of memory of the const eval session to keep the constant\n /// meaningful.\n #[derive(Debug, Default, Clone, PartialEq, Eq)]\n-pub struct MemoryMap(pub HashMap<usize, Vec<u8>>);\n+pub struct MemoryMap {\n+    pub memory: HashMap<usize, Vec<u8>>,\n+    pub vtable: VTableMap,\n+}\n \n impl MemoryMap {\n     fn insert(&mut self, addr: usize, x: Vec<u8>) {\n-        self.0.insert(addr, x);\n+        self.memory.insert(addr, x);\n     }\n \n     /// This functions convert each address by a function `f` which gets the byte intervals and assign an address\n@@ -165,14 +168,17 @@ impl MemoryMap {\n         &self,\n         mut f: impl FnMut(&[u8]) -> Result<usize, MirEvalError>,\n     ) -> Result<HashMap<usize, usize>, MirEvalError> {\n-        self.0.iter().map(|x| Ok((*x.0, f(x.1)?))).collect()\n+        self.memory.iter().map(|x| Ok((*x.0, f(x.1)?))).collect()\n     }\n }\n \n /// A concrete constant value\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum ConstScalar {\n     Bytes(Vec<u8>, MemoryMap),\n+    // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n+    // constants\n+    UnevaluatedConst(ConstId, Substitution),\n     /// Case of an unknown value that rustc might know but we don't\n     // FIXME: this is a hack to get around chalk not being able to represent unevaluatable\n     // constants"}, {"sha": "4846bbfe5fd7d73e6cf2c1321d31ae08e6051887", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -3,13 +3,14 @@\n use std::{fmt::Display, iter};\n \n use crate::{\n-    db::HirDatabase, display::HirDisplay, infer::PointerCast, lang_items::is_box, ClosureId, Const,\n-    ConstScalar, InferenceResult, Interner, MemoryMap, Substitution, Ty, TyKind,\n+    db::HirDatabase, display::HirDisplay, infer::PointerCast, lang_items::is_box, mapping::ToChalk,\n+    CallableDefId, ClosureId, Const, ConstScalar, InferenceResult, Interner, MemoryMap,\n+    Substitution, Ty, TyKind,\n };\n use chalk_ir::Mutability;\n use hir_def::{\n     hir::{BindingId, Expr, ExprId, Ordering, PatId},\n-    DefWithBodyId, FieldId, UnionId, VariantId,\n+    DefWithBodyId, FieldId, StaticId, UnionId, VariantId,\n };\n use la_arena::{Arena, ArenaMap, Idx, RawIdx};\n \n@@ -19,7 +20,7 @@ mod borrowck;\n mod pretty;\n \n pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n-pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError};\n+pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError, VTableMap};\n pub use lower::{\n     lower_to_mir, mir_body_for_closure_query, mir_body_query, mir_body_recover, MirLowerError,\n };\n@@ -76,6 +77,9 @@ pub enum Operand {\n     Move(Place),\n     /// Constants are already semantically values, and remain unchanged.\n     Constant(Const),\n+    /// NON STANDARD: This kind of operand returns an immutable reference to that static memory. Rustc\n+    /// handles it with the `Constant` variant somehow.\n+    Static(StaticId),\n }\n \n impl Operand {\n@@ -90,6 +94,17 @@ impl Operand {\n     fn const_zst(ty: Ty) -> Operand {\n         Self::from_bytes(vec![], ty)\n     }\n+\n+    fn from_fn(\n+        db: &dyn HirDatabase,\n+        func_id: hir_def::FunctionId,\n+        generic_args: Substitution,\n+    ) -> Operand {\n+        let ty =\n+            chalk_ir::TyKind::FnDef(CallableDefId::FunctionId(func_id).to_chalk(db), generic_args)\n+                .intern(Interner);\n+        Operand::from_bytes(vec![], ty)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -110,7 +125,7 @@ impl<V, T> ProjectionElem<V, T> {\n         &self,\n         base: Ty,\n         db: &dyn HirDatabase,\n-        closure_field: impl FnOnce(ClosureId, usize) -> Ty,\n+        closure_field: impl FnOnce(ClosureId, &Substitution, usize) -> Ty,\n     ) -> Ty {\n         match self {\n             ProjectionElem::Deref => match &base.data(Interner).kind {\n@@ -142,7 +157,7 @@ impl<V, T> ProjectionElem<V, T> {\n                         never!(\"Out of bound tuple field\");\n                         TyKind::Error.intern(Interner)\n                     }),\n-                TyKind::Closure(id, _) => closure_field(*id, *f),\n+                TyKind::Closure(id, subst) => closure_field(*id, subst, *f),\n                 _ => {\n                     never!(\"Only tuple or closure has tuple or closure field\");\n                     return TyKind::Error.intern(Interner);\n@@ -261,7 +276,13 @@ impl SwitchTargets {\n }\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n-pub enum Terminator {\n+pub struct Terminator {\n+    span: MirSpan,\n+    kind: TerminatorKind,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum TerminatorKind {\n     /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlockId },\n \n@@ -836,6 +857,9 @@ pub enum Rvalue {\n     /// affects alias analysis.\n     ShallowInitBox(Operand, Ty),\n \n+    /// NON STANDARD: allocates memory with the type's layout, and shallow init the box with the resulting pointer.\n+    ShallowInitBoxWithAlloc(Ty),\n+\n     /// A CopyForDeref is equivalent to a read from a place at the\n     /// codegen level, but is treated specially by drop elaboration. When such a read happens, it\n     /// is guaranteed (via nature of the mir_opt `Derefer` in rustc_mir_transform/src/deref_separator)\n@@ -918,7 +942,7 @@ impl MirBody {\n                 Operand::Copy(p) | Operand::Move(p) => {\n                     f(p);\n                 }\n-                Operand::Constant(_) => (),\n+                Operand::Constant(_) | Operand::Static(_) => (),\n             }\n         }\n         for (_, block) in self.basic_blocks.iter_mut() {\n@@ -927,6 +951,7 @@ impl MirBody {\n                     StatementKind::Assign(p, r) => {\n                         f(p);\n                         match r {\n+                            Rvalue::ShallowInitBoxWithAlloc(_) => (),\n                             Rvalue::ShallowInitBox(o, _)\n                             | Rvalue::UnaryOp(_, o)\n                             | Rvalue::Cast(_, o, _)\n@@ -954,32 +979,32 @@ impl MirBody {\n                 }\n             }\n             match &mut block.terminator {\n-                Some(x) => match x {\n-                    Terminator::SwitchInt { discr, .. } => for_operand(discr, &mut f),\n-                    Terminator::FalseEdge { .. }\n-                    | Terminator::FalseUnwind { .. }\n-                    | Terminator::Goto { .. }\n-                    | Terminator::Resume\n-                    | Terminator::GeneratorDrop\n-                    | Terminator::Abort\n-                    | Terminator::Return\n-                    | Terminator::Unreachable => (),\n-                    Terminator::Drop { place, .. } => {\n+                Some(x) => match &mut x.kind {\n+                    TerminatorKind::SwitchInt { discr, .. } => for_operand(discr, &mut f),\n+                    TerminatorKind::FalseEdge { .. }\n+                    | TerminatorKind::FalseUnwind { .. }\n+                    | TerminatorKind::Goto { .. }\n+                    | TerminatorKind::Resume\n+                    | TerminatorKind::GeneratorDrop\n+                    | TerminatorKind::Abort\n+                    | TerminatorKind::Return\n+                    | TerminatorKind::Unreachable => (),\n+                    TerminatorKind::Drop { place, .. } => {\n                         f(place);\n                     }\n-                    Terminator::DropAndReplace { place, value, .. } => {\n+                    TerminatorKind::DropAndReplace { place, value, .. } => {\n                         f(place);\n                         for_operand(value, &mut f);\n                     }\n-                    Terminator::Call { func, args, destination, .. } => {\n+                    TerminatorKind::Call { func, args, destination, .. } => {\n                         for_operand(func, &mut f);\n                         args.iter_mut().for_each(|x| for_operand(x, &mut f));\n                         f(destination);\n                     }\n-                    Terminator::Assert { cond, .. } => {\n+                    TerminatorKind::Assert { cond, .. } => {\n                         for_operand(cond, &mut f);\n                     }\n-                    Terminator::Yield { value, resume_arg, .. } => {\n+                    TerminatorKind::Yield { value, resume_arg, .. } => {\n                         for_operand(value, &mut f);\n                         f(resume_arg);\n                     }"}, {"sha": "7b99fbf42f012e9b20fcdea929e04ccd3147e003", "filename": "crates/hir-ty/src/mir/borrowck.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fborrowck.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -13,7 +13,7 @@ use crate::{db::HirDatabase, ClosureId};\n \n use super::{\n     BasicBlockId, BorrowKind, LocalId, MirBody, MirLowerError, MirSpan, Place, ProjectionElem,\n-    Rvalue, StatementKind, Terminator,\n+    Rvalue, StatementKind, TerminatorKind,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -141,26 +141,26 @@ fn ever_initialized_map(body: &MirBody) -> ArenaMap<BasicBlockId, ArenaMap<Local\n             never!(\"Terminator should be none only in construction\");\n             return;\n         };\n-        let targets = match terminator {\n-            Terminator::Goto { target } => vec![*target],\n-            Terminator::SwitchInt { targets, .. } => targets.all_targets().to_vec(),\n-            Terminator::Resume\n-            | Terminator::Abort\n-            | Terminator::Return\n-            | Terminator::Unreachable => vec![],\n-            Terminator::Call { target, cleanup, destination, .. } => {\n+        let targets = match &terminator.kind {\n+            TerminatorKind::Goto { target } => vec![*target],\n+            TerminatorKind::SwitchInt { targets, .. } => targets.all_targets().to_vec(),\n+            TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable => vec![],\n+            TerminatorKind::Call { target, cleanup, destination, .. } => {\n                 if destination.projection.len() == 0 && destination.local == l {\n                     is_ever_initialized = true;\n                 }\n                 target.into_iter().chain(cleanup.into_iter()).copied().collect()\n             }\n-            Terminator::Drop { .. }\n-            | Terminator::DropAndReplace { .. }\n-            | Terminator::Assert { .. }\n-            | Terminator::Yield { .. }\n-            | Terminator::GeneratorDrop\n-            | Terminator::FalseEdge { .. }\n-            | Terminator::FalseUnwind { .. } => {\n+            TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {\n                 never!(\"We don't emit these MIR terminators yet\");\n                 vec![]\n             }\n@@ -228,21 +228,21 @@ fn mutability_of_locals(body: &MirBody) -> ArenaMap<LocalId, MutabilityReason> {\n             never!(\"Terminator should be none only in construction\");\n             continue;\n         };\n-        match terminator {\n-            Terminator::Goto { .. }\n-            | Terminator::Resume\n-            | Terminator::Abort\n-            | Terminator::Return\n-            | Terminator::Unreachable\n-            | Terminator::FalseEdge { .. }\n-            | Terminator::FalseUnwind { .. }\n-            | Terminator::GeneratorDrop\n-            | Terminator::SwitchInt { .. }\n-            | Terminator::Drop { .. }\n-            | Terminator::DropAndReplace { .. }\n-            | Terminator::Assert { .. }\n-            | Terminator::Yield { .. } => (),\n-            Terminator::Call { destination, .. } => {\n+        match &terminator.kind {\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::DropAndReplace { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Yield { .. } => (),\n+            TerminatorKind::Call { destination, .. } => {\n                 if destination.projection.len() == 0 {\n                     if ever_init_map.get(destination.local).copied().unwrap_or_default() {\n                         push_mut_span(destination.local, MirSpan::Unknown);"}, {"sha": "01d27f2672c292fb3614707f418c394afd187536", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 609, "deletions": 354, "changes": 963, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,39 +1,49 @@\n //! This module provides a MIR interpreter, which is used in const eval.\n \n-use std::{borrow::Cow, collections::HashMap, iter, ops::Range, sync::Arc};\n+use std::{borrow::Cow, collections::HashMap, fmt::Write, iter, ops::Range, sync::Arc};\n \n-use base_db::CrateId;\n+use base_db::{CrateId, FileId};\n use chalk_ir::{\n     fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n-    DebruijnIndex, TyKind,\n+    DebruijnIndex, Mutability,\n };\n+use either::Either;\n use hir_def::{\n     builtin_type::BuiltinType,\n     lang_item::{lang_attr, LangItem},\n     layout::{TagEncoding, Variants},\n-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, VariantId,\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, StaticId,\n+    TypeOrConstParamId, VariantId,\n };\n+use hir_expand::{name::Name, InFile};\n use intern::Interned;\n use la_arena::ArenaMap;\n+use rustc_hash::FxHashMap;\n+use syntax::{SyntaxNodePtr, TextRange};\n \n use crate::{\n     consteval::{intern_const_scalar, ConstEvalError},\n     db::HirDatabase,\n+    display::{ClosureStyle, HirDisplay},\n     from_placeholder_idx,\n     infer::{normalize, PointerCast},\n     layout::{layout_of_ty, Layout, LayoutError, RustcEnumVariantIdx},\n     mapping::from_chalk,\n-    method_resolution::{is_dyn_method, lookup_impl_method},\n+    method_resolution::{is_dyn_method, lookup_impl_const, lookup_impl_method},\n+    static_lifetime,\n     traits::FnTrait,\n+    utils::{generics, ClosureSubst, Generics},\n     CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n-    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt,\n+    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n-    Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n+    MirSpan, Operand, Place, ProjectionElem, Rvalue, StatementKind, TerminatorKind, UnOp,\n };\n \n+mod shim;\n+\n macro_rules! from_bytes {\n     ($ty:tt, $value:expr) => {\n         ($ty::from_le_bytes(match ($value).try_into() {\n@@ -43,9 +53,15 @@ macro_rules! from_bytes {\n     };\n }\n \n-#[derive(Debug, Default)]\n-struct VTableMap {\n-    ty_to_id: HashMap<Ty, usize>,\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirEvalError::NotSupported(format!($x)))\n+    };\n+}\n+\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n+pub struct VTableMap {\n+    ty_to_id: FxHashMap<Ty, usize>,\n     id_to_ty: Vec<Ty>,\n }\n \n@@ -75,6 +91,9 @@ pub struct Evaluator<'a> {\n     trait_env: Arc<TraitEnvironment>,\n     stack: Vec<u8>,\n     heap: Vec<u8>,\n+    /// Stores the global location of the statics. We const evaluate every static first time we need it\n+    /// and see it's missing, then we add it to this to reuse.\n+    static_locations: FxHashMap<StaticId, Address>,\n     /// We don't really have function pointers, i.e. pointers to some assembly instructions that we can run. Instead, we\n     /// store the type as an interned id in place of function and vtable pointers, and we recover back the type at the\n     /// time of use.\n@@ -88,7 +107,7 @@ pub struct Evaluator<'a> {\n     stack_depth_limit: usize,\n }\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n enum Address {\n     Stack(usize),\n     Heap(usize),\n@@ -153,13 +172,27 @@ enum IntervalOrOwned {\n     Owned(Vec<u8>),\n     Borrowed(Interval),\n }\n+\n+impl From<Interval> for IntervalOrOwned {\n+    fn from(it: Interval) -> IntervalOrOwned {\n+        IntervalOrOwned::Borrowed(it)\n+    }\n+}\n+\n impl IntervalOrOwned {\n     pub(crate) fn to_vec(self, memory: &Evaluator<'_>) -> Result<Vec<u8>> {\n         Ok(match self {\n             IntervalOrOwned::Owned(o) => o,\n             IntervalOrOwned::Borrowed(b) => b.get(memory)?.to_vec(),\n         })\n     }\n+\n+    fn get<'a>(&'a self, memory: &'a Evaluator<'a>) -> Result<&'a [u8]> {\n+        Ok(match self {\n+            IntervalOrOwned::Owned(o) => o,\n+            IntervalOrOwned::Borrowed(b) => b.get(memory)?,\n+        })\n+    }\n }\n \n impl Address {\n@@ -205,30 +238,129 @@ impl Address {\n \n #[derive(Clone, PartialEq, Eq)]\n pub enum MirEvalError {\n-    ConstEvalError(Box<ConstEvalError>),\n+    ConstEvalError(String, Box<ConstEvalError>),\n     LayoutError(LayoutError, Ty),\n     /// Means that code had type errors (or mismatched args) and we shouldn't generate mir in first place.\n     TypeError(&'static str),\n     /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n     /// then use this type of error.\n-    UndefinedBehavior(&'static str),\n+    UndefinedBehavior(String),\n+    GenericArgNotProvided(TypeOrConstParamId, Substitution),\n     Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n     MirLowerErrorForClosure(ClosureId, MirLowerError),\n     TypeIsUnsized(Ty, &'static str),\n     NotSupported(String),\n     InvalidConst(Const),\n-    InFunction(FunctionId, Box<MirEvalError>),\n+    InFunction(Either<FunctionId, ClosureId>, Box<MirEvalError>, MirSpan, DefWithBodyId),\n     ExecutionLimitExceeded,\n     StackOverflow,\n     TargetDataLayoutNotAvailable,\n     InvalidVTableId(usize),\n+    CoerceUnsizedError(Ty),\n+}\n+\n+impl MirEvalError {\n+    pub fn pretty_print(\n+        &self,\n+        f: &mut String,\n+        db: &dyn HirDatabase,\n+        span_formatter: impl Fn(FileId, TextRange) -> String,\n+    ) -> std::result::Result<(), std::fmt::Error> {\n+        writeln!(f, \"Mir eval error:\")?;\n+        let mut err = self;\n+        while let MirEvalError::InFunction(func, e, span, def) = err {\n+            err = e;\n+            match func {\n+                Either::Left(func) => {\n+                    let function_name = db.function_data(*func);\n+                    writeln!(f, \"In function {} ({:?})\", function_name.name, func)?;\n+                }\n+                Either::Right(clos) => {\n+                    writeln!(f, \"In {:?}\", clos)?;\n+                }\n+            }\n+            let source_map = db.body_with_source_map(*def).1;\n+            let span: InFile<SyntaxNodePtr> = match span {\n+                MirSpan::ExprId(e) => match source_map.expr_syntax(*e) {\n+                    Ok(s) => s.map(|x| x.into()),\n+                    Err(_) => continue,\n+                },\n+                MirSpan::PatId(p) => match source_map.pat_syntax(*p) {\n+                    Ok(s) => s.map(|x| match x {\n+                        Either::Left(e) => e.into(),\n+                        Either::Right(e) => e.into(),\n+                    }),\n+                    Err(_) => continue,\n+                },\n+                MirSpan::Unknown => continue,\n+            };\n+            let file_id = span.file_id.original_file(db.upcast());\n+            let text_range = span.value.text_range();\n+            writeln!(f, \"{}\", span_formatter(file_id, text_range))?;\n+        }\n+        match err {\n+            MirEvalError::InFunction(..) => unreachable!(),\n+            MirEvalError::LayoutError(err, ty) => {\n+                write!(\n+                    f,\n+                    \"Layout for type `{}` is not available due {err:?}\",\n+                    ty.display(db).with_closure_style(ClosureStyle::ClosureWithId).to_string()\n+                )?;\n+            }\n+            MirEvalError::GenericArgNotProvided(id, subst) => {\n+                let parent = id.parent;\n+                let param = &db.generic_params(parent).type_or_consts[id.local_id];\n+                writeln!(\n+                    f,\n+                    \"Generic arg not provided for {}\",\n+                    param.name().unwrap_or(&Name::missing())\n+                )?;\n+                writeln!(f, \"Provided args: [\")?;\n+                for g in subst.iter(Interner) {\n+                    write!(f, \"    {},\", g.display(db).to_string())?;\n+                }\n+                writeln!(f, \"]\")?;\n+            }\n+            MirEvalError::MirLowerError(func, err) => {\n+                let function_name = db.function_data(*func);\n+                writeln!(\n+                    f,\n+                    \"MIR lowering for function `{}` ({:?}) failed due:\",\n+                    function_name.name, func\n+                )?;\n+                err.pretty_print(f, db, span_formatter)?;\n+            }\n+            MirEvalError::ConstEvalError(name, err) => {\n+                MirLowerError::ConstEvalError(name.clone(), err.clone()).pretty_print(\n+                    f,\n+                    db,\n+                    span_formatter,\n+                )?;\n+            }\n+            MirEvalError::TypeError(_)\n+            | MirEvalError::UndefinedBehavior(_)\n+            | MirEvalError::Panic(_)\n+            | MirEvalError::MirLowerErrorForClosure(_, _)\n+            | MirEvalError::TypeIsUnsized(_, _)\n+            | MirEvalError::NotSupported(_)\n+            | MirEvalError::InvalidConst(_)\n+            | MirEvalError::ExecutionLimitExceeded\n+            | MirEvalError::StackOverflow\n+            | MirEvalError::TargetDataLayoutNotAvailable\n+            | MirEvalError::CoerceUnsizedError(_)\n+            | MirEvalError::InvalidVTableId(_) => writeln!(f, \"{:?}\", err)?,\n+        }\n+        Ok(())\n+    }\n }\n \n impl std::fmt::Debug for MirEvalError {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            Self::ConstEvalError(arg0) => f.debug_tuple(\"ConstEvalError\").field(arg0).finish(),\n+            Self::ConstEvalError(arg0, arg1) => {\n+                f.debug_tuple(\"ConstEvalError\").field(arg0).field(arg1).finish()\n+            }\n             Self::LayoutError(arg0, arg1) => {\n                 f.debug_tuple(\"LayoutError\").field(arg0).field(arg1).finish()\n             }\n@@ -241,47 +373,38 @@ impl std::fmt::Debug for MirEvalError {\n             Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n             Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n             Self::StackOverflow => write!(f, \"stack overflow\"),\n+            Self::GenericArgNotProvided(..) => f.debug_tuple(\"GenericArgNotProvided\").finish(),\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n             Self::MirLowerErrorForClosure(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n+            Self::CoerceUnsizedError(arg0) => {\n+                f.debug_tuple(\"CoerceUnsizedError\").field(arg0).finish()\n+            }\n             Self::InvalidVTableId(arg0) => f.debug_tuple(\"InvalidVTableId\").field(arg0).finish(),\n             Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n             Self::InvalidConst(arg0) => {\n                 let data = &arg0.data(Interner);\n                 f.debug_struct(\"InvalidConst\").field(\"ty\", &data.ty).field(\"value\", &arg0).finish()\n             }\n-            Self::InFunction(func, e) => {\n+            Self::InFunction(func, e, span, _) => {\n                 let mut e = &**e;\n-                let mut stack = vec![*func];\n-                while let Self::InFunction(f, next_e) = e {\n+                let mut stack = vec![(*func, *span)];\n+                while let Self::InFunction(f, next_e, span, _) = e {\n                     e = &next_e;\n-                    stack.push(*f);\n+                    stack.push((*f, *span));\n                 }\n                 f.debug_struct(\"WithStack\").field(\"error\", e).field(\"stack\", &stack).finish()\n             }\n         }\n     }\n }\n \n-macro_rules! not_supported {\n-    ($x: expr) => {\n-        return Err(MirEvalError::NotSupported(format!($x)))\n-    };\n-}\n-\n-impl From<ConstEvalError> for MirEvalError {\n-    fn from(value: ConstEvalError) -> Self {\n-        match value {\n-            _ => MirEvalError::ConstEvalError(Box::new(value)),\n-        }\n-    }\n-}\n-\n type Result<T> = std::result::Result<T, MirEvalError>;\n \n+#[derive(Debug)]\n struct Locals<'a> {\n     ptr: &'a ArenaMap<LocalId, Address>,\n     body: &'a MirBody,\n@@ -301,12 +424,14 @@ pub fn interpret_mir(\n ) -> Result<Const> {\n     let ty = body.locals[return_slot()].ty.clone();\n     let mut evaluator = Evaluator::new(db, body, assert_placeholder_ty_is_unused);\n+    let ty = evaluator.ty_filler(&ty, &subst, body.owner)?;\n     let bytes = evaluator.interpret_mir(&body, None.into_iter(), subst.clone())?;\n-    let memory_map = evaluator.create_memory_map(\n+    let mut memory_map = evaluator.create_memory_map(\n         &bytes,\n         &ty,\n         &Locals { ptr: &ArenaMap::new(), body: &body, subst: &subst },\n     )?;\n+    memory_map.vtable = evaluator.vtable_map;\n     return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n }\n \n@@ -322,6 +447,7 @@ impl Evaluator<'_> {\n             stack: vec![0],\n             heap: vec![0],\n             vtable_map: VTableMap::default(),\n+            static_locations: HashMap::default(),\n             db,\n             trait_env,\n             crate_id,\n@@ -365,15 +491,21 @@ impl Evaluator<'_> {\n         let mut metadata = None; // locals are always sized\n         for proj in &p.projection {\n             let prev_ty = ty.clone();\n-            ty = proj.projected_ty(ty, self.db, |c, f| {\n+            ty = proj.projected_ty(ty, self.db, |c, subst, f| {\n                 let (def, _) = self.db.lookup_intern_closure(c.into());\n                 let infer = self.db.infer(def);\n                 let (captures, _) = infer.closure_info(&c);\n-                captures.get(f).expect(\"broken closure field\").ty.clone()\n+                let parent_subst = ClosureSubst(subst).parent_subst();\n+                captures\n+                    .get(f)\n+                    .expect(\"broken closure field\")\n+                    .ty\n+                    .clone()\n+                    .substitute(Interner, parent_subst)\n             });\n             match proj {\n                 ProjectionElem::Deref => {\n-                    metadata = if self.size_of(&ty, locals)?.is_none() {\n+                    metadata = if self.size_align_of(&ty, locals)?.is_none() {\n                         Some(Interval { addr: addr.offset(self.ptr_size()), size: self.ptr_size() })\n                     } else {\n                         None\n@@ -435,6 +567,11 @@ impl Evaluator<'_> {\n             .map_err(|e| MirEvalError::LayoutError(e, ty.clone()))\n     }\n \n+    fn layout_filled(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Layout> {\n+        let ty = &self.ty_filler(ty, locals.subst, locals.body.owner)?;\n+        self.layout(ty)\n+    }\n+\n     fn layout_adt(&self, adt: AdtId, subst: Substitution) -> Result<Layout> {\n         self.db.layout_of_adt(adt, subst.clone()).map_err(|e| {\n             MirEvalError::LayoutError(e, TyKind::Adt(chalk_ir::AdtId(adt), subst).intern(Interner))\n@@ -449,6 +586,10 @@ impl Evaluator<'_> {\n         Ok(match o {\n             Operand::Copy(p) | Operand::Move(p) => self.place_ty(p, locals)?,\n             Operand::Constant(c) => c.data(Interner).ty.clone(),\n+            &Operand::Static(s) => {\n+                let ty = self.db.infer(s.into())[self.db.body(s.into()).body_expr].clone();\n+                TyKind::Ref(Mutability::Not, static_lifetime(), ty).intern(Interner)\n+            }\n         })\n     }\n \n@@ -524,11 +665,11 @@ impl Evaluator<'_> {\n             let Some(terminator) = current_block.terminator.as_ref() else {\n                 not_supported!(\"block without terminator\");\n             };\n-            match terminator {\n-                Terminator::Goto { target } => {\n+            match &terminator.kind {\n+                TerminatorKind::Goto { target } => {\n                     current_block_idx = *target;\n                 }\n-                Terminator::Call {\n+                TerminatorKind::Call {\n                     func,\n                     args,\n                     destination,\n@@ -545,23 +686,36 @@ impl Evaluator<'_> {\n                     match &fn_ty.data(Interner).kind {\n                         TyKind::Function(_) => {\n                             let bytes = self.eval_operand(func, &locals)?;\n-                            self.exec_fn_pointer(bytes, destination, &args, &locals)?;\n+                            self.exec_fn_pointer(\n+                                bytes,\n+                                destination,\n+                                &args,\n+                                &locals,\n+                                terminator.span,\n+                            )?;\n                         }\n                         TyKind::FnDef(def, generic_args) => {\n-                            self.exec_fn_def(*def, generic_args, destination, &args, &locals)?;\n+                            self.exec_fn_def(\n+                                *def,\n+                                generic_args,\n+                                destination,\n+                                &args,\n+                                &locals,\n+                                terminator.span,\n+                            )?;\n                         }\n                         x => not_supported!(\"unknown function type {x:?}\"),\n                     }\n                     current_block_idx = target.expect(\"broken mir, function without target\");\n                 }\n-                Terminator::SwitchInt { discr, targets } => {\n+                TerminatorKind::SwitchInt { discr, targets } => {\n                     let val = u128::from_le_bytes(pad16(\n                         self.eval_operand(discr, &locals)?.get(&self)?,\n                         false,\n                     ));\n                     current_block_idx = targets.target_for_value(val);\n                 }\n-                Terminator::Return => {\n+                TerminatorKind::Return => {\n                     let ty = body.locals[return_slot()].ty.clone();\n                     self.stack_depth_limit += 1;\n                     return Ok(self\n@@ -571,8 +725,8 @@ impl Evaluator<'_> {\n                         )?\n                         .to_owned());\n                 }\n-                Terminator::Unreachable => {\n-                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\"));\n+                TerminatorKind::Unreachable => {\n+                    return Err(MirEvalError::UndefinedBehavior(\"unreachable executed\".to_owned()));\n                 }\n                 _ => not_supported!(\"unknown terminator\"),\n             }\n@@ -725,13 +879,13 @@ impl Evaluator<'_> {\n                 };\n                 match layout.variants {\n                     Variants::Single { index } => {\n-                        let r = self.db.const_eval_discriminant(EnumVariantId {\n+                        let r = self.const_eval_discriminant(EnumVariantId {\n                             parent: enum_id,\n                             local_id: index.0,\n                         })?;\n                         Owned(r.to_le_bytes().to_vec())\n                     }\n-                    Variants::Multiple { tag, tag_encoding, .. } => {\n+                    Variants::Multiple { tag, tag_encoding, variants, .. } => {\n                         let Some(target_data_layout) = self.db.target_data_layout(self.crate_id) else {\n                             not_supported!(\"missing target data layout\");\n                         };\n@@ -744,25 +898,20 @@ impl Evaluator<'_> {\n                             }\n                             TagEncoding::Niche { untagged_variant, niche_start, .. } => {\n                                 let tag = &bytes[offset..offset + size];\n-                                let candidate_discriminant = i128::from_le_bytes(pad16(tag, false))\n-                                    .wrapping_sub(niche_start as i128);\n-                                let enum_data = self.db.enum_data(enum_id);\n-                                let result = 'b: {\n-                                    for (local_id, _) in enum_data.variants.iter() {\n-                                        if candidate_discriminant\n-                                            == self.db.const_eval_discriminant(EnumVariantId {\n-                                                parent: enum_id,\n-                                                local_id,\n-                                            })?\n-                                        {\n-                                            break 'b candidate_discriminant;\n-                                        }\n-                                    }\n-                                    self.db.const_eval_discriminant(EnumVariantId {\n-                                        parent: enum_id,\n-                                        local_id: untagged_variant.0,\n-                                    })?\n-                                };\n+                                let candidate_tag = i128::from_le_bytes(pad16(tag, false))\n+                                    .wrapping_sub(niche_start as i128)\n+                                    as usize;\n+                                let variant = variants\n+                                    .iter_enumerated()\n+                                    .map(|(x, _)| x)\n+                                    .filter(|x| *x != untagged_variant)\n+                                    .nth(candidate_tag)\n+                                    .unwrap_or(untagged_variant)\n+                                    .0;\n+                                let result = self.const_eval_discriminant(EnumVariantId {\n+                                    parent: enum_id,\n+                                    local_id: variant,\n+                                })?;\n                                 Owned(result.to_le_bytes().to_vec())\n                             }\n                         }\n@@ -771,6 +920,13 @@ impl Evaluator<'_> {\n             }\n             Rvalue::Repeat(_, _) => not_supported!(\"evaluating repeat rvalue\"),\n             Rvalue::ShallowInitBox(_, _) => not_supported!(\"shallow init box\"),\n+            Rvalue::ShallowInitBoxWithAlloc(ty) => {\n+                let Some((size, align)) = self.size_align_of(ty, locals)? else {\n+                    not_supported!(\"unsized box initialization\");\n+                };\n+                let addr = self.heap_allocate(size, align);\n+                Owned(addr.to_bytes())\n+            }\n             Rvalue::CopyForDeref(_) => not_supported!(\"copy for deref\"),\n             Rvalue::Aggregate(kind, values) => {\n                 let values = values\n@@ -787,12 +943,12 @@ impl Evaluator<'_> {\n                         Owned(r)\n                     }\n                     AggregateKind::Tuple(ty) => {\n-                        let layout = self.layout(&ty)?;\n+                        let layout = self.layout_filled(&ty, locals)?;\n                         Owned(self.make_by_layout(\n                             layout.size.bytes_usize(),\n                             &layout,\n                             None,\n-                            values.iter().copied(),\n+                            values.iter().map(|&x| x.into()),\n                         )?)\n                     }\n                     AggregateKind::Union(x, f) => {\n@@ -814,74 +970,44 @@ impl Evaluator<'_> {\n                             size,\n                             &variant_layout,\n                             tag,\n-                            values.iter().copied(),\n+                            values.iter().map(|&x| x.into()),\n                         )?)\n                     }\n                     AggregateKind::Closure(ty) => {\n-                        let layout = self.layout(&ty)?;\n+                        let layout = self.layout_filled(&ty, locals)?;\n                         Owned(self.make_by_layout(\n                             layout.size.bytes_usize(),\n                             &layout,\n                             None,\n-                            values.iter().copied(),\n+                            values.iter().map(|&x| x.into()),\n                         )?)\n                     }\n                 }\n             }\n             Rvalue::Cast(kind, operand, target_ty) => match kind {\n                 CastKind::Pointer(cast) => match cast {\n-                    PointerCast::ReifyFnPointer => {\n+                    PointerCast::ReifyFnPointer | PointerCast::ClosureFnPointer(_) => {\n                         let current_ty = self.operand_ty(operand, locals)?;\n-                        if let TyKind::FnDef(_, _) = &current_ty.data(Interner).kind {\n+                        if let TyKind::FnDef(_, _) | TyKind::Closure(_, _) =\n+                            &current_ty.data(Interner).kind\n+                        {\n                             let id = self.vtable_map.id(current_ty);\n                             let ptr_size = self.ptr_size();\n                             Owned(id.to_le_bytes()[0..ptr_size].to_vec())\n                         } else {\n-                            not_supported!(\"ReifyFnPointer cast of a non FnDef type\");\n+                            not_supported!(\n+                                \"creating a fn pointer from a non FnDef or Closure type\"\n+                            );\n                         }\n                     }\n                     PointerCast::Unsize => {\n                         let current_ty = self.operand_ty(operand, locals)?;\n-                        match &target_ty.data(Interner).kind {\n-                            TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n-                                match &ty.data(Interner).kind {\n-                                    TyKind::Slice(_) => match &current_ty.data(Interner).kind {\n-                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n-                                            match &ty.data(Interner).kind {\n-                                                TyKind::Array(_, size) => {\n-                                                    let addr = self\n-                                                        .eval_operand(operand, locals)?\n-                                                        .get(&self)?;\n-                                                    let len = const_as_usize(size);\n-                                                    let mut r = Vec::with_capacity(16);\n-                                                    r.extend(addr.iter().copied());\n-                                                    r.extend(len.to_le_bytes().into_iter());\n-                                                    Owned(r)\n-                                                }\n-                                                _ => {\n-                                                    not_supported!(\"slice unsizing from non arrays\")\n-                                                }\n-                                            }\n-                                        }\n-                                        _ => not_supported!(\"slice unsizing from non pointers\"),\n-                                    },\n-                                    TyKind::Dyn(_) => match &current_ty.data(Interner).kind {\n-                                        TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n-                                            let vtable = self.vtable_map.id(ty.clone());\n-                                            let addr =\n-                                                self.eval_operand(operand, locals)?.get(&self)?;\n-                                            let mut r = Vec::with_capacity(16);\n-                                            r.extend(addr.iter().copied());\n-                                            r.extend(vtable.to_le_bytes().into_iter());\n-                                            Owned(r)\n-                                        }\n-                                        _ => not_supported!(\"dyn unsizing from non pointers\"),\n-                                    },\n-                                    _ => not_supported!(\"unknown unsized cast\"),\n-                                }\n-                            }\n-                            _ => not_supported!(\"unsized cast on unknown pointer type\"),\n-                        }\n+                        let addr = self.eval_operand(operand, locals)?;\n+                        self.coerce_unsized(addr, &current_ty, target_ty)?\n+                    }\n+                    PointerCast::MutToConstPointer | PointerCast::UnsafeFnPointer => {\n+                        // This is no-op\n+                        Borrowed(self.eval_operand(operand, locals)?)\n                     }\n                     x => not_supported!(\"pointer cast {x:?}\"),\n                 },\n@@ -909,6 +1035,77 @@ impl Evaluator<'_> {\n         })\n     }\n \n+    fn coerce_unsized_look_through_fields<T>(\n+        &self,\n+        ty: &Ty,\n+        goal: impl Fn(&TyKind) -> Option<T>,\n+    ) -> Result<T> {\n+        let kind = ty.kind(Interner);\n+        if let Some(x) = goal(kind) {\n+            return Ok(x);\n+        }\n+        if let TyKind::Adt(id, subst) = kind {\n+            if let AdtId::StructId(struct_id) = id.0 {\n+                let field_types = self.db.field_types(struct_id.into());\n+                let mut field_types = field_types.iter();\n+                if let Some(ty) =\n+                    field_types.next().map(|x| x.1.clone().substitute(Interner, subst))\n+                {\n+                    return self.coerce_unsized_look_through_fields(&ty, goal);\n+                }\n+            }\n+        }\n+        Err(MirEvalError::CoerceUnsizedError(ty.clone()))\n+    }\n+\n+    fn coerce_unsized(\n+        &mut self,\n+        addr: Interval,\n+        current_ty: &Ty,\n+        target_ty: &Ty,\n+    ) -> Result<IntervalOrOwned> {\n+        use IntervalOrOwned::*;\n+        fn for_ptr(x: &TyKind) -> Option<Ty> {\n+            match x {\n+                TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => Some(ty.clone()),\n+                _ => None,\n+            }\n+        }\n+        Ok(match self.coerce_unsized_look_through_fields(target_ty, for_ptr)? {\n+            ty => match &ty.data(Interner).kind {\n+                TyKind::Slice(_) => {\n+                    match self.coerce_unsized_look_through_fields(current_ty, for_ptr)? {\n+                        ty => match &ty.data(Interner).kind {\n+                            TyKind::Array(_, size) => {\n+                                let len = const_as_usize(size);\n+                                let mut r = Vec::with_capacity(16);\n+                                let addr = addr.get(self)?;\n+                                r.extend(addr.iter().copied());\n+                                r.extend(len.to_le_bytes().into_iter());\n+                                Owned(r)\n+                            }\n+                            _ => {\n+                                not_supported!(\"slice unsizing from non arrays\")\n+                            }\n+                        },\n+                    }\n+                }\n+                TyKind::Dyn(_) => match &current_ty.data(Interner).kind {\n+                    TyKind::Raw(_, ty) | TyKind::Ref(_, _, ty) => {\n+                        let vtable = self.vtable_map.id(ty.clone());\n+                        let mut r = Vec::with_capacity(16);\n+                        let addr = addr.get(self)?;\n+                        r.extend(addr.iter().copied());\n+                        r.extend(vtable.to_le_bytes().into_iter());\n+                        Owned(r)\n+                    }\n+                    _ => not_supported!(\"dyn unsizing from non pointers\"),\n+                },\n+                _ => not_supported!(\"unknown unsized cast\"),\n+            },\n+        })\n+    }\n+\n     fn layout_of_variant(\n         &mut self,\n         x: VariantId,\n@@ -921,7 +1118,7 @@ impl Evaluator<'_> {\n                 if AdtId::from(f.parent) == adt {\n                     // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n                     // infinite sized type errors) we use a dummy layout\n-                    let i = self.db.const_eval_discriminant(x)?;\n+                    let i = self.const_eval_discriminant(x)?;\n                     return Ok((16, self.layout(&TyBuilder::unit())?, Some((0, 16, i))));\n                 }\n             }\n@@ -939,13 +1136,22 @@ impl Evaluator<'_> {\n                     _ => not_supported!(\"multi variant layout for non-enums\"),\n                 };\n                 let rustc_enum_variant_idx = RustcEnumVariantIdx(enum_variant_id.local_id);\n-                let mut discriminant = self.db.const_eval_discriminant(enum_variant_id)?;\n+                let mut discriminant = self.const_eval_discriminant(enum_variant_id)?;\n                 let variant_layout = variants[rustc_enum_variant_idx].clone();\n                 let have_tag = match tag_encoding {\n                     TagEncoding::Direct => true,\n                     TagEncoding::Niche { untagged_variant, niche_variants: _, niche_start } => {\n-                        discriminant = discriminant.wrapping_add(niche_start as i128);\n-                        untagged_variant != rustc_enum_variant_idx\n+                        if untagged_variant == rustc_enum_variant_idx {\n+                            false\n+                        } else {\n+                            discriminant = (variants\n+                                .iter_enumerated()\n+                                .filter(|(x, _)| *x != untagged_variant)\n+                                .position(|(x, _)| x == rustc_enum_variant_idx)\n+                                .unwrap() as i128)\n+                                .wrapping_add(niche_start as i128);\n+                            true\n+                        }\n                     }\n                 };\n                 (\n@@ -970,7 +1176,7 @@ impl Evaluator<'_> {\n         size: usize, // Not necessarily equal to variant_layout.size\n         variant_layout: &Layout,\n         tag: Option<(usize, usize, i128)>,\n-        values: impl Iterator<Item = Interval>,\n+        values: impl Iterator<Item = IntervalOrOwned>,\n     ) -> Result<Vec<u8>> {\n         let mut result = vec![0; size];\n         if let Some((offset, size, value)) = tag {\n@@ -987,6 +1193,10 @@ impl Evaluator<'_> {\n     fn eval_operand(&mut self, x: &Operand, locals: &Locals<'_>) -> Result<Interval> {\n         Ok(match x {\n             Operand::Copy(p) | Operand::Move(p) => self.eval_place(p, locals)?,\n+            Operand::Static(st) => {\n+                let addr = self.eval_static(*st, locals)?;\n+                Interval::new(addr, self.ptr_size())\n+            }\n             Operand::Constant(konst) => {\n                 let data = &konst.data(Interner);\n                 match &data.value {\n@@ -1003,37 +1213,71 @@ impl Evaluator<'_> {\n                         not_supported!(\"inference var constant\")\n                     }\n                     chalk_ir::ConstValue::Placeholder(_) => not_supported!(\"placeholder constant\"),\n-                    chalk_ir::ConstValue::Concrete(c) => match &c.interned {\n-                        ConstScalar::Bytes(v, memory_map) => {\n-                            let mut v: Cow<'_, [u8]> = Cow::Borrowed(v);\n-                            let patch_map = memory_map.transform_addresses(|b| {\n-                                let addr = self.heap_allocate(b.len());\n-                                self.write_memory(addr, b)?;\n-                                Ok(addr.to_usize())\n-                            })?;\n-                            let size = self.size_of(&data.ty, locals)?.unwrap_or(v.len());\n-                            if size != v.len() {\n-                                // Handle self enum\n-                                if size == 16 && v.len() < 16 {\n-                                    v = Cow::Owned(pad16(&v, false).to_vec());\n-                                } else if size < 16 && v.len() == 16 {\n-                                    v = Cow::Owned(v[0..size].to_vec());\n-                                } else {\n-                                    return Err(MirEvalError::InvalidConst(konst.clone()));\n-                                }\n-                            }\n-                            let addr = self.heap_allocate(size);\n-                            self.write_memory(addr, &v)?;\n-                            self.patch_addresses(&patch_map, addr, &data.ty, locals)?;\n-                            Interval::new(addr, size)\n-                        }\n-                        ConstScalar::Unknown => not_supported!(\"evaluating unknown const\"),\n-                    },\n+                    chalk_ir::ConstValue::Concrete(c) => {\n+                        self.allocate_const_in_heap(c, &data.ty, locals, konst)?\n+                    }\n                 }\n             }\n         })\n     }\n \n+    fn allocate_const_in_heap(\n+        &mut self,\n+        c: &chalk_ir::ConcreteConst<Interner>,\n+        ty: &Ty,\n+        locals: &Locals<'_>,\n+        konst: &chalk_ir::Const<Interner>,\n+    ) -> Result<Interval> {\n+        Ok(match &c.interned {\n+            ConstScalar::Bytes(v, memory_map) => {\n+                let mut v: Cow<'_, [u8]> = Cow::Borrowed(v);\n+                let patch_map = memory_map.transform_addresses(|b| {\n+                    let addr = self.heap_allocate(b.len(), 1); // FIXME: align is wrong\n+                    self.write_memory(addr, b)?;\n+                    Ok(addr.to_usize())\n+                })?;\n+                let (size, align) = self.size_align_of(ty, locals)?.unwrap_or((v.len(), 1));\n+                if size != v.len() {\n+                    // Handle self enum\n+                    if size == 16 && v.len() < 16 {\n+                        v = Cow::Owned(pad16(&v, false).to_vec());\n+                    } else if size < 16 && v.len() == 16 {\n+                        v = Cow::Owned(v[0..size].to_vec());\n+                    } else {\n+                        return Err(MirEvalError::InvalidConst(konst.clone()));\n+                    }\n+                }\n+                let addr = self.heap_allocate(size, align);\n+                self.write_memory(addr, &v)?;\n+                self.patch_addresses(&patch_map, &memory_map.vtable, addr, ty, locals)?;\n+                Interval::new(addr, size)\n+            }\n+            ConstScalar::UnevaluatedConst(const_id, subst) => {\n+                let subst = self.subst_filler(subst, locals);\n+                let (const_id, subst) = lookup_impl_const(\n+                    self.db,\n+                    self.db.trait_environment_for_body(locals.body.owner),\n+                    *const_id,\n+                    subst,\n+                );\n+                let c = self.db.const_eval(const_id.into(), subst).map_err(|e| {\n+                    let const_data = self.db.const_data(const_id);\n+                    MirEvalError::ConstEvalError(\n+                        const_data.name.as_ref().and_then(|x| x.as_str()).unwrap_or(\"_\").to_owned(),\n+                        Box::new(e),\n+                    )\n+                })?;\n+                if let chalk_ir::ConstValue::Concrete(c) = &c.data(Interner).value {\n+                    if let ConstScalar::Bytes(_, _) = &c.interned {\n+                        return self.allocate_const_in_heap(&c, ty, locals, konst);\n+                    }\n+                }\n+                not_supported!(\"failing at evaluating unevaluated const\");\n+            }\n+            ConstScalar::Unknown => not_supported!(\"evaluating unknown const\"),\n+        })\n+    }\n+\n     fn eval_place(&mut self, p: &Place, locals: &Locals<'_>) -> Result<Interval> {\n         let addr = self.place_addr(p, locals)?;\n         Ok(Interval::new(\n@@ -1046,53 +1290,61 @@ impl Evaluator<'_> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&self.stack, x),\n             Heap(x) => (&self.heap, x),\n-            Invalid(_) => {\n-                return Err(MirEvalError::UndefinedBehavior(\"read invalid memory address\"))\n+            Invalid(x) => {\n+                return Err(MirEvalError::UndefinedBehavior(format!(\n+                    \"read invalid memory address {x} with size {size}\"\n+                )));\n             }\n         };\n-        mem.get(pos..pos + size).ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory read\"))\n+        mem.get(pos..pos + size)\n+            .ok_or_else(|| MirEvalError::UndefinedBehavior(\"out of bound memory read\".to_string()))\n     }\n \n     fn write_memory(&mut self, addr: Address, r: &[u8]) -> Result<()> {\n         let (mem, pos) = match addr {\n             Stack(x) => (&mut self.stack, x),\n             Heap(x) => (&mut self.heap, x),\n-            Invalid(_) => {\n-                return Err(MirEvalError::UndefinedBehavior(\"write invalid memory address\"))\n+            Invalid(x) => {\n+                return Err(MirEvalError::UndefinedBehavior(format!(\n+                    \"write invalid memory address {x} with content {r:?}\"\n+                )));\n             }\n         };\n         mem.get_mut(pos..pos + r.len())\n-            .ok_or(MirEvalError::UndefinedBehavior(\"out of bound memory write\"))?\n+            .ok_or_else(|| {\n+                MirEvalError::UndefinedBehavior(\"out of bound memory write\".to_string())\n+            })?\n             .copy_from_slice(r);\n         Ok(())\n     }\n \n-    fn size_of(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Option<usize>> {\n+    fn size_align_of(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Option<(usize, usize)>> {\n         if let DefWithBodyId::VariantId(f) = locals.body.owner {\n             if let Some((adt, _)) = ty.as_adt() {\n                 if AdtId::from(f.parent) == adt {\n                     // Computing the exact size of enums require resolving the enum discriminants. In order to prevent loops (and\n                     // infinite sized type errors) we use a dummy size\n-                    return Ok(Some(16));\n+                    return Ok(Some((16, 16)));\n                 }\n             }\n         }\n-        let ty = &self.ty_filler(ty, locals.subst, locals.body.owner)?;\n-        let layout = self.layout(ty);\n+        let layout = self.layout_filled(ty, locals);\n         if self.assert_placeholder_ty_is_unused {\n             if matches!(layout, Err(MirEvalError::LayoutError(LayoutError::HasPlaceholder, _))) {\n-                return Ok(Some(0));\n+                return Ok(Some((0, 1)));\n             }\n         }\n         let layout = layout?;\n-        Ok(layout.is_sized().then(|| layout.size.bytes_usize()))\n+        Ok(layout\n+            .is_sized()\n+            .then(|| (layout.size.bytes_usize(), layout.align.abi.bytes() as usize)))\n     }\n \n     /// A version of `self.size_of` which returns error if the type is unsized. `what` argument should\n     /// be something that complete this: `error: type {ty} was unsized. {what} should be sized`\n     fn size_of_sized(&self, ty: &Ty, locals: &Locals<'_>, what: &'static str) -> Result<usize> {\n-        match self.size_of(ty, locals)? {\n-            Some(x) => Ok(x),\n+        match self.size_align_of(ty, locals)? {\n+            Some(x) => Ok(x.0),\n             None => Err(MirEvalError::TypeIsUnsized(ty.clone(), what)),\n         }\n     }\n@@ -1120,7 +1372,7 @@ impl Evaluator<'_> {\n         struct Filler<'a> {\n             db: &'a dyn HirDatabase,\n             subst: &'a Substitution,\n-            skip_params: usize,\n+            generics: Option<Generics>,\n         }\n         impl FallibleTypeFolder<Interner> for Filler<'_> {\n             type Error = MirEvalError;\n@@ -1144,7 +1396,11 @@ impl Evaluator<'_> {\n                         match impl_trait_id {\n                             crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                                 let infer = self.db.infer(func.into());\n-                                let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n+                                let filler = &mut Filler {\n+                                    db: self.db,\n+                                    subst,\n+                                    generics: Some(generics(self.db.upcast(), func.into())),\n+                                };\n                                 filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n                             }\n                             crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n@@ -1162,39 +1418,43 @@ impl Evaluator<'_> {\n                 _outer_binder: DebruijnIndex,\n             ) -> std::result::Result<Ty, Self::Error> {\n                 let x = from_placeholder_idx(self.db, idx);\n+                let Some(idx) = self.generics.as_ref().and_then(|g| g.param_idx(x)) else {\n+                    not_supported!(\"missing idx in generics\");\n+                };\n                 Ok(self\n                     .subst\n                     .as_slice(Interner)\n-                    .get((u32::from(x.local_id.into_raw()) as usize) + self.skip_params)\n+                    .get(idx)\n                     .and_then(|x| x.ty(Interner))\n-                    .ok_or(MirEvalError::TypeError(\"Generic arg not provided\"))?\n+                    .ok_or_else(|| MirEvalError::GenericArgNotProvided(x, self.subst.clone()))?\n                     .clone())\n             }\n         }\n-        let filler = &mut Filler { db: self.db, subst, skip_params: 0 };\n-        Ok(normalize(self.db, owner, ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST)?))\n+        let g_def = match owner {\n+            DefWithBodyId::FunctionId(f) => Some(f.into()),\n+            DefWithBodyId::StaticId(_) => None,\n+            DefWithBodyId::ConstId(f) => Some(f.into()),\n+            DefWithBodyId::VariantId(f) => Some(f.into()),\n+        };\n+        let generics = g_def.map(|g_def| generics(self.db.upcast(), g_def));\n+        let filler = &mut Filler { db: self.db, subst, generics };\n+        Ok(normalize(\n+            self.db,\n+            self.trait_env.clone(),\n+            ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST)?,\n+        ))\n     }\n \n-    fn heap_allocate(&mut self, s: usize) -> Address {\n+    fn heap_allocate(&mut self, size: usize, _align: usize) -> Address {\n         let pos = self.heap.len();\n-        self.heap.extend(iter::repeat(0).take(s));\n+        self.heap.extend(iter::repeat(0).take(size));\n         Address::Heap(pos)\n     }\n \n     pub fn interpret_mir_with_no_arg(&mut self, body: &MirBody) -> Result<Vec<u8>> {\n         self.interpret_mir(&body, vec![].into_iter(), Substitution::empty(Interner))\n     }\n \n-    fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n-        use LangItem::*;\n-        let candidate = lang_attr(self.db.upcast(), def)?;\n-        // We want to execute these functions with special logic\n-        if [PanicFmt, BeginPanic, SliceLen].contains(&candidate) {\n-            return Some(candidate);\n-        }\n-        None\n-    }\n-\n     fn detect_fn_trait(&self, def: FunctionId) -> Option<FnTrait> {\n         use LangItem::*;\n         let ItemContainerId::TraitId(parent) = self.db.lookup_intern_function(def).container else {\n@@ -1214,9 +1474,9 @@ impl Evaluator<'_> {\n         let mut mm = MemoryMap::default();\n         match ty.kind(Interner) {\n             TyKind::Ref(_, _, t) => {\n-                let size = self.size_of(t, locals)?;\n+                let size = self.size_align_of(t, locals)?;\n                 match size {\n-                    Some(size) => {\n+                    Some((size, _)) => {\n                         let addr_usize = from_bytes!(usize, bytes);\n                         mm.insert(\n                             addr_usize,\n@@ -1246,15 +1506,17 @@ impl Evaluator<'_> {\n     fn patch_addresses(\n         &mut self,\n         patch_map: &HashMap<usize, usize>,\n+        old_vtable: &VTableMap,\n         addr: Address,\n         ty: &Ty,\n         locals: &Locals<'_>,\n     ) -> Result<()> {\n         // FIXME: support indirect references\n+        let layout = self.layout(ty)?;\n         let my_size = self.size_of_sized(ty, locals, \"value to patch address\")?;\n         match ty.kind(Interner) {\n             TyKind::Ref(_, _, t) => {\n-                let size = self.size_of(t, locals)?;\n+                let size = self.size_align_of(t, locals)?;\n                 match size {\n                     Some(_) => {\n                         let current = from_bytes!(usize, self.read_memory(addr, my_size)?);\n@@ -1270,98 +1532,50 @@ impl Evaluator<'_> {\n                     }\n                 }\n             }\n-            _ => (),\n-        }\n-        Ok(())\n-    }\n-\n-    fn exec_intrinsic(\n-        &mut self,\n-        as_str: &str,\n-        args: &[IntervalAndTy],\n-        generic_args: Substitution,\n-        destination: Interval,\n-        locals: &Locals<'_>,\n-    ) -> Result<()> {\n-        match as_str {\n-            \"size_of\" => {\n-                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n-                    return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n-                };\n-                let size = self.size_of_sized(ty, locals, \"size_of arg\")?;\n-                destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])\n-            }\n-            \"wrapping_add\" => {\n-                let [lhs, rhs] = args else {\n-                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n-                };\n-                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n-                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n-                let ans = lhs.wrapping_add(rhs);\n-                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n-            }\n-            \"copy\" | \"copy_nonoverlapping\" => {\n-                let [src, dst, offset] = args else {\n-                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping args are not provided\"));\n-                };\n-                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n-                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping generic arg is not provided\"));\n-                };\n-                let src = Address::from_bytes(src.get(self)?)?;\n-                let dst = Address::from_bytes(dst.get(self)?)?;\n-                let offset = from_bytes!(usize, offset.get(self)?);\n-                let size = self.size_of_sized(ty, locals, \"copy_nonoverlapping ptr type\")?;\n-                let size = offset * size;\n-                let src = Interval { addr: src, size };\n-                let dst = Interval { addr: dst, size };\n-                dst.write_from_interval(self, src)\n-            }\n-            \"offset\" | \"arith_offset\" => {\n-                let [ptr, offset] = args else {\n-                    return Err(MirEvalError::TypeError(\"offset args are not provided\"));\n-                };\n-                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n-                    return Err(MirEvalError::TypeError(\"offset generic arg is not provided\"));\n-                };\n-                let ptr = u128::from_le_bytes(pad16(ptr.get(self)?, false));\n-                let offset = u128::from_le_bytes(pad16(offset.get(self)?, false));\n-                let size = self.size_of_sized(ty, locals, \"offset ptr type\")? as u128;\n-                let ans = ptr + offset * size;\n-                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n-            }\n-            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n-                // FIXME: We should actually implement these checks\n-                Ok(())\n-            }\n-            \"forget\" => {\n-                // We don't call any drop glue yet, so there is nothing here\n-                Ok(())\n-            }\n-            \"transmute\" => {\n-                let [arg] = args else {\n-                    return Err(MirEvalError::TypeError(\"trasmute arg is not provided\"));\n-                };\n-                destination.write_from_interval(self, arg.interval)\n+            TyKind::Function(_) => {\n+                let ty = old_vtable.ty_of_bytes(self.read_memory(addr, my_size)?)?.clone();\n+                let new_id = self.vtable_map.id(ty);\n+                self.write_memory(addr, &new_id.to_le_bytes())?;\n             }\n-            \"const_eval_select\" => {\n-                let [tuple, const_fn, _] = args else {\n-                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n-                };\n-                let mut args = vec![const_fn.clone()];\n-                let TyKind::Tuple(_, fields) = tuple.ty.kind(Interner) else {\n-                    return Err(MirEvalError::TypeError(\"const_eval_select arg[0] is not a tuple\"));\n-                };\n-                let layout = self.layout(&tuple.ty)?;\n-                for (i, field) in fields.iter(Interner).enumerate() {\n-                    let field = field.assert_ty_ref(Interner).clone();\n-                    let offset = layout.fields.offset(i).bytes_usize();\n-                    let addr = tuple.interval.addr.offset(offset);\n-                    args.push(IntervalAndTy::new(addr, field, self, locals)?);\n+            TyKind::Adt(id, subst) => match id.0 {\n+                AdtId::StructId(s) => {\n+                    for (i, (_, ty)) in self.db.field_types(s.into()).iter().enumerate() {\n+                        let offset = layout.fields.offset(i).bytes_usize();\n+                        let ty = ty.clone().substitute(Interner, subst);\n+                        self.patch_addresses(\n+                            patch_map,\n+                            old_vtable,\n+                            addr.offset(offset),\n+                            &ty,\n+                            locals,\n+                        )?;\n+                    }\n                 }\n-                self.exec_fn_trait(&args, destination, locals)\n-            }\n-            _ => not_supported!(\"unknown intrinsic {as_str}\"),\n+                AdtId::UnionId(_) => (),\n+                AdtId::EnumId(_) => (),\n+            },\n+            TyKind::AssociatedType(_, _)\n+            | TyKind::Scalar(_)\n+            | TyKind::Tuple(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Raw(_, _)\n+            | TyKind::OpaqueType(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Str\n+            | TyKind::Never\n+            | TyKind::Closure(_, _)\n+            | TyKind::Generator(_, _)\n+            | TyKind::GeneratorWitness(_, _)\n+            | TyKind::Foreign(_)\n+            | TyKind::Error\n+            | TyKind::Placeholder(_)\n+            | TyKind::Dyn(_)\n+            | TyKind::Alias(_)\n+            | TyKind::BoundVar(_)\n+            | TyKind::InferenceVar(_, _) => (),\n         }\n+        Ok(())\n     }\n \n     fn exec_fn_pointer(\n@@ -1370,13 +1584,18 @@ impl Evaluator<'_> {\n         destination: Interval,\n         args: &[IntervalAndTy],\n         locals: &Locals<'_>,\n+        span: MirSpan,\n     ) -> Result<()> {\n         let id = from_bytes!(usize, bytes.get(self)?);\n         let next_ty = self.vtable_map.ty(id)?.clone();\n-        if let TyKind::FnDef(def, generic_args) = &next_ty.data(Interner).kind {\n-            self.exec_fn_def(*def, generic_args, destination, args, &locals)?;\n-        } else {\n-            return Err(MirEvalError::TypeError(\"function pointer to non function\"));\n+        match &next_ty.data(Interner).kind {\n+            TyKind::FnDef(def, generic_args) => {\n+                self.exec_fn_def(*def, generic_args, destination, args, &locals, span)?;\n+            }\n+            TyKind::Closure(id, subst) => {\n+                self.exec_closure(*id, bytes.slice(0..0), subst, destination, args, locals, span)?;\n+            }\n+            _ => return Err(MirEvalError::TypeError(\"function pointer to non function\")),\n         }\n         Ok(())\n     }\n@@ -1388,6 +1607,8 @@ impl Evaluator<'_> {\n         generic_args: &Substitution,\n         destination: Interval,\n         args: &[IntervalAndTy],\n+        locals: &Locals<'_>,\n+        span: MirSpan,\n     ) -> Result<()> {\n         let mir_body = self\n             .db\n@@ -1396,7 +1617,16 @@ impl Evaluator<'_> {\n         let arg_bytes = iter::once(Ok(closure_data.get(self)?.to_owned()))\n             .chain(args.iter().map(|x| Ok(x.get(&self)?.to_owned())))\n             .collect::<Result<Vec<_>>>()?;\n-        let bytes = self.interpret_mir(&mir_body, arg_bytes.into_iter(), generic_args.clone())?;\n+        let bytes = self\n+            .interpret_mir(&mir_body, arg_bytes.into_iter(), generic_args.clone())\n+            .map_err(|e| {\n+                MirEvalError::InFunction(\n+                    Either::Right(closure),\n+                    Box::new(e),\n+                    span,\n+                    locals.body.owner,\n+                )\n+            })?;\n         destination.write_from_bytes(self, &bytes)\n     }\n \n@@ -1407,16 +1637,17 @@ impl Evaluator<'_> {\n         destination: Interval,\n         args: &[IntervalAndTy],\n         locals: &Locals<'_>,\n+        span: MirSpan,\n     ) -> Result<()> {\n         let def: CallableDefId = from_chalk(self.db, def);\n         let generic_args = self.subst_filler(generic_args, &locals);\n         match def {\n             CallableDefId::FunctionId(def) => {\n                 if let Some(_) = self.detect_fn_trait(def) {\n-                    self.exec_fn_trait(&args, destination, locals)?;\n+                    self.exec_fn_trait(&args, destination, locals, span)?;\n                     return Ok(());\n                 }\n-                self.exec_fn_with_args(def, args, generic_args, locals, destination)?;\n+                self.exec_fn_with_args(def, args, generic_args, locals, destination, span)?;\n             }\n             CallableDefId::StructId(id) => {\n                 let (size, variant_layout, tag) =\n@@ -1425,7 +1656,7 @@ impl Evaluator<'_> {\n                     size,\n                     &variant_layout,\n                     tag,\n-                    args.iter().map(|x| x.interval),\n+                    args.iter().map(|x| x.interval.into()),\n                 )?;\n                 destination.write_from_bytes(self, &result)?;\n             }\n@@ -1436,7 +1667,7 @@ impl Evaluator<'_> {\n                     size,\n                     &variant_layout,\n                     tag,\n-                    args.iter().map(|x| x.interval),\n+                    args.iter().map(|x| x.interval.into()),\n                 )?;\n                 destination.write_from_bytes(self, &result)?;\n             }\n@@ -1451,50 +1682,37 @@ impl Evaluator<'_> {\n         generic_args: Substitution,\n         locals: &Locals<'_>,\n         destination: Interval,\n+        span: MirSpan,\n     ) -> Result<()> {\n-        let function_data = self.db.function_data(def);\n-        let is_intrinsic = match &function_data.abi {\n-            Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n-            None => match def.lookup(self.db.upcast()).container {\n-                hir_def::ItemContainerId::ExternBlockId(block) => {\n-                    let id = block.lookup(self.db.upcast()).id;\n-                    id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n-                        == Some(\"rust-intrinsic\")\n-                }\n-                _ => false,\n-            },\n-        };\n-        if is_intrinsic {\n-            return self.exec_intrinsic(\n-                function_data.name.as_text().unwrap_or_default().as_str(),\n-                args,\n-                generic_args,\n-                destination,\n-                &locals,\n-            );\n+        if self.detect_and_exec_special_function(\n+            def,\n+            args,\n+            &generic_args,\n+            locals,\n+            destination,\n+            span,\n+        )? {\n+            return Ok(());\n         }\n         let arg_bytes =\n             args.iter().map(|x| Ok(x.get(&self)?.to_owned())).collect::<Result<Vec<_>>>()?;\n-        let result = if let Some(x) = self.detect_lang_function(def) {\n-            self.exec_lang_item(x, &arg_bytes)?\n-        } else {\n-            if let Some(self_ty_idx) =\n-                is_dyn_method(self.db, self.trait_env.clone(), def, generic_args.clone())\n-            {\n-                // In the layout of current possible receiver, which at the moment of writing this code is one of\n-                // `&T`, `&mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`, and `Pin<P>` where `P` is one of possible receivers,\n-                // the vtable is exactly in the `[ptr_size..2*ptr_size]` bytes. So we can use it without branching on\n-                // the type.\n-                let ty = self\n-                    .vtable_map\n-                    .ty_of_bytes(&arg_bytes[0][self.ptr_size()..self.ptr_size() * 2])?;\n-                let mut args_for_target = args.to_vec();\n-                args_for_target[0] = IntervalAndTy {\n-                    interval: args_for_target[0].interval.slice(0..self.ptr_size()),\n-                    ty: ty.clone(),\n-                };\n-                let ty = GenericArgData::Ty(ty.clone()).intern(Interner);\n-                let generics_for_target = Substitution::from_iter(\n+        if let Some(self_ty_idx) =\n+            is_dyn_method(self.db, self.trait_env.clone(), def, generic_args.clone())\n+        {\n+            // In the layout of current possible receiver, which at the moment of writing this code is one of\n+            // `&T`, `&mut T`, `Box<T>`, `Rc<T>`, `Arc<T>`, and `Pin<P>` where `P` is one of possible recievers,\n+            // the vtable is exactly in the `[ptr_size..2*ptr_size]` bytes. So we can use it without branching on\n+            // the type.\n+            let ty =\n+                self.vtable_map.ty_of_bytes(&arg_bytes[0][self.ptr_size()..self.ptr_size() * 2])?;\n+            let mut args_for_target = args.to_vec();\n+            args_for_target[0] = IntervalAndTy {\n+                interval: args_for_target[0].interval.slice(0..self.ptr_size()),\n+                ty: ty.clone(),\n+            };\n+            let ty = GenericArgData::Ty(ty.clone()).intern(Interner);\n+            let generics_for_target =\n+                Substitution::from_iter(\n                     Interner,\n                     generic_args.iter(Interner).enumerate().map(|(i, x)| {\n                         if i == self_ty_idx {\n@@ -1504,23 +1722,25 @@ impl Evaluator<'_> {\n                         }\n                     }),\n                 );\n-                return self.exec_fn_with_args(\n-                    def,\n-                    &args_for_target,\n-                    generics_for_target,\n-                    locals,\n-                    destination,\n-                );\n-            }\n-            let (imp, generic_args) =\n-                lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args);\n-            let generic_args = self.subst_filler(&generic_args, &locals);\n-            let def = imp.into();\n-            let mir_body =\n-                self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n-            self.interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n-                .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n-        };\n+            return self.exec_fn_with_args(\n+                def,\n+                &args_for_target,\n+                generics_for_target,\n+                locals,\n+                destination,\n+                span,\n+            );\n+        }\n+        let (imp, generic_args) =\n+            lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args);\n+        let generic_args = self.subst_filler(&generic_args, &locals);\n+        let def = imp.into();\n+        let mir_body = self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+        let result = self\n+            .interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n+            .map_err(|e| {\n+                MirEvalError::InFunction(Either::Left(imp), Box::new(e), span, locals.body.owner)\n+            })?;\n         destination.write_from_bytes(self, &result)?;\n         Ok(())\n     }\n@@ -1530,6 +1750,7 @@ impl Evaluator<'_> {\n         args: &[IntervalAndTy],\n         destination: Interval,\n         locals: &Locals<'_>,\n+        span: MirSpan,\n     ) -> Result<()> {\n         let func = args.get(0).ok_or(MirEvalError::TypeError(\"fn trait with no arg\"))?;\n         let mut func_ty = func.ty.clone();\n@@ -1547,35 +1768,69 @@ impl Evaluator<'_> {\n         }\n         match &func_ty.data(Interner).kind {\n             TyKind::FnDef(def, subst) => {\n-                self.exec_fn_def(*def, subst, destination, &args[1..], locals)?;\n+                self.exec_fn_def(*def, subst, destination, &args[1..], locals, span)?;\n             }\n             TyKind::Function(_) => {\n-                self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n+                self.exec_fn_pointer(func_data, destination, &args[1..], locals, span)?;\n             }\n             TyKind::Closure(closure, subst) => {\n-                self.exec_closure(*closure, func_data, subst, destination, &args[1..])?;\n+                self.exec_closure(\n+                    *closure,\n+                    func_data,\n+                    &Substitution::from_iter(Interner, ClosureSubst(subst).parent_subst()),\n+                    destination,\n+                    &args[1..],\n+                    locals,\n+                    span,\n+                )?;\n             }\n             x => not_supported!(\"Call FnTrait methods with type {x:?}\"),\n         }\n         Ok(())\n     }\n \n-    fn exec_lang_item(&self, x: LangItem, args: &[Vec<u8>]) -> Result<Vec<u8>> {\n-        use LangItem::*;\n-        let mut args = args.iter();\n-        match x {\n-            // FIXME: we want to find the panic message from arguments, but it wouldn't work\n-            // currently even if we do that, since macro expansion of panic related macros\n-            // is dummy.\n-            PanicFmt | BeginPanic => Err(MirEvalError::Panic(\"<format-args>\".to_string())),\n-            SliceLen => {\n-                let arg = args\n-                    .next()\n-                    .ok_or(MirEvalError::TypeError(\"argument of <[T]>::len() is not provided\"))?;\n-                let ptr_size = arg.len() / 2;\n-                Ok(arg[ptr_size..].into())\n+    fn eval_static(&mut self, st: StaticId, locals: &Locals<'_>) -> Result<Address> {\n+        if let Some(o) = self.static_locations.get(&st) {\n+            return Ok(*o);\n+        };\n+        let static_data = self.db.static_data(st);\n+        let result = if !static_data.is_extern {\n+            let konst =\n+                self.db.const_eval(st.into(), Substitution::empty(Interner)).map_err(|e| {\n+                    MirEvalError::ConstEvalError(\n+                        static_data.name.as_str().unwrap_or(\"_\").to_owned(),\n+                        Box::new(e),\n+                    )\n+                })?;\n+            let data = &konst.data(Interner);\n+            if let chalk_ir::ConstValue::Concrete(c) = &data.value {\n+                self.allocate_const_in_heap(&c, &data.ty, locals, &konst)?\n+            } else {\n+                not_supported!(\"unevaluatable static\");\n+            }\n+        } else {\n+            let ty = &self.db.infer(st.into())[self.db.body(st.into()).body_expr];\n+            let Some((size, align)) = self.size_align_of(&ty, locals)? else {\n+                not_supported!(\"unsized extern static\");\n+            };\n+            let addr = self.heap_allocate(size, align);\n+            Interval::new(addr, size)\n+        };\n+        let addr = self.heap_allocate(self.ptr_size(), self.ptr_size());\n+        self.write_memory(addr, &result.addr.to_bytes())?;\n+        self.static_locations.insert(st, addr);\n+        Ok(addr)\n+    }\n+\n+    fn const_eval_discriminant(&self, variant: EnumVariantId) -> Result<i128> {\n+        let r = self.db.const_eval_discriminant(variant);\n+        match r {\n+            Ok(r) => Ok(r),\n+            Err(e) => {\n+                let data = self.db.enum_data(variant.parent);\n+                let name = format!(\"{}::{}\", data.name, data.variants[variant.local_id].name);\n+                Err(MirEvalError::ConstEvalError(name, Box::new(e)))\n             }\n-            x => not_supported!(\"Executing lang item {x:?}\"),\n         }\n     }\n }"}, {"sha": "78938af15b87287687f9cf386fa31fae57e79047", "filename": "crates/hir-ty/src/mir/eval/shim.rs", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -0,0 +1,396 @@\n+//! Interpret intrinsics, lang items and `extern \"C\"` wellknown functions which their implementation\n+//! is not available.\n+\n+use super::*;\n+\n+macro_rules! from_bytes {\n+    ($ty:tt, $value:expr) => {\n+        ($ty::from_le_bytes(match ($value).try_into() {\n+            Ok(x) => x,\n+            Err(_) => return Err(MirEvalError::TypeError(\"mismatched size\")),\n+        }))\n+    };\n+}\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirEvalError::NotSupported(format!($x)))\n+    };\n+}\n+\n+impl Evaluator<'_> {\n+    pub(super) fn detect_and_exec_special_function(\n+        &mut self,\n+        def: FunctionId,\n+        args: &[IntervalAndTy],\n+        generic_args: &Substitution,\n+        locals: &Locals<'_>,\n+        destination: Interval,\n+        span: MirSpan,\n+    ) -> Result<bool> {\n+        let function_data = self.db.function_data(def);\n+        let is_intrinsic = match &function_data.abi {\n+            Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+            None => match def.lookup(self.db.upcast()).container {\n+                hir_def::ItemContainerId::ExternBlockId(block) => {\n+                    let id = block.lookup(self.db.upcast()).id;\n+                    id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n+                        == Some(\"rust-intrinsic\")\n+                }\n+                _ => false,\n+            },\n+        };\n+        if is_intrinsic {\n+            self.exec_intrinsic(\n+                function_data.name.as_text().unwrap_or_default().as_str(),\n+                args,\n+                generic_args,\n+                destination,\n+                &locals,\n+                span,\n+            )?;\n+            return Ok(true);\n+        }\n+        let alloc_fn = function_data\n+            .attrs\n+            .iter()\n+            .filter_map(|x| x.path().as_ident())\n+            .filter_map(|x| x.as_str())\n+            .find(|x| {\n+                [\n+                    \"rustc_allocator\",\n+                    \"rustc_deallocator\",\n+                    \"rustc_reallocator\",\n+                    \"rustc_allocator_zeroed\",\n+                ]\n+                .contains(x)\n+            });\n+        if let Some(alloc_fn) = alloc_fn {\n+            self.exec_alloc_fn(alloc_fn, args, destination)?;\n+            return Ok(true);\n+        }\n+        if let Some(x) = self.detect_lang_function(def) {\n+            let arg_bytes =\n+                args.iter().map(|x| Ok(x.get(&self)?.to_owned())).collect::<Result<Vec<_>>>()?;\n+            let result = self.exec_lang_item(x, &arg_bytes)?;\n+            destination.write_from_bytes(self, &result)?;\n+            return Ok(true);\n+        }\n+        Ok(false)\n+    }\n+\n+    fn exec_alloc_fn(\n+        &mut self,\n+        alloc_fn: &str,\n+        args: &[IntervalAndTy],\n+        destination: Interval,\n+    ) -> Result<()> {\n+        match alloc_fn {\n+            \"rustc_allocator_zeroed\" | \"rustc_allocator\" => {\n+                let [size, align] = args else {\n+                    return Err(MirEvalError::TypeError(\"rustc_allocator args are not provided\"));\n+                };\n+                let size = from_bytes!(usize, size.get(self)?);\n+                let align = from_bytes!(usize, align.get(self)?);\n+                let result = self.heap_allocate(size, align);\n+                destination.write_from_bytes(self, &result.to_bytes())?;\n+            }\n+            \"rustc_deallocator\" => { /* no-op for now */ }\n+            \"rustc_reallocator\" => {\n+                let [ptr, old_size, align, new_size] = args else {\n+                    return Err(MirEvalError::TypeError(\"rustc_allocator args are not provided\"));\n+                };\n+                let ptr = Address::from_bytes(ptr.get(self)?)?;\n+                let old_size = from_bytes!(usize, old_size.get(self)?);\n+                let new_size = from_bytes!(usize, new_size.get(self)?);\n+                let align = from_bytes!(usize, align.get(self)?);\n+                let result = self.heap_allocate(new_size, align);\n+                Interval { addr: result, size: old_size }\n+                    .write_from_interval(self, Interval { addr: ptr, size: old_size })?;\n+                destination.write_from_bytes(self, &result.to_bytes())?;\n+            }\n+            _ => not_supported!(\"unknown alloc function\"),\n+        }\n+        Ok(())\n+    }\n+\n+    fn detect_lang_function(&self, def: FunctionId) -> Option<LangItem> {\n+        use LangItem::*;\n+        let candidate = lang_attr(self.db.upcast(), def)?;\n+        // We want to execute these functions with special logic\n+        if [PanicFmt, BeginPanic, SliceLen].contains(&candidate) {\n+            return Some(candidate);\n+        }\n+        None\n+    }\n+\n+    fn exec_lang_item(&self, x: LangItem, args: &[Vec<u8>]) -> Result<Vec<u8>> {\n+        use LangItem::*;\n+        let mut args = args.iter();\n+        match x {\n+            // FIXME: we want to find the panic message from arguments, but it wouldn't work\n+            // currently even if we do that, since macro expansion of panic related macros\n+            // is dummy.\n+            PanicFmt | BeginPanic => Err(MirEvalError::Panic(\"<format-args>\".to_string())),\n+            SliceLen => {\n+                let arg = args\n+                    .next()\n+                    .ok_or(MirEvalError::TypeError(\"argument of <[T]>::len() is not provided\"))?;\n+                let ptr_size = arg.len() / 2;\n+                Ok(arg[ptr_size..].into())\n+            }\n+            x => not_supported!(\"Executing lang item {x:?}\"),\n+        }\n+    }\n+\n+    fn exec_intrinsic(\n+        &mut self,\n+        as_str: &str,\n+        args: &[IntervalAndTy],\n+        generic_args: &Substitution,\n+        destination: Interval,\n+        locals: &Locals<'_>,\n+        span: MirSpan,\n+    ) -> Result<()> {\n+        // We are a single threaded runtime with no UB checking and no optimization, so\n+        // we can implement these as normal functions.\n+        if let Some(name) = as_str.strip_prefix(\"atomic_\") {\n+            let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                return Err(MirEvalError::TypeError(\"atomic intrinsic generic arg is not provided\"));\n+            };\n+            let Some(arg0) = args.get(0) else {\n+                return Err(MirEvalError::TypeError(\"atomic intrinsic arg0 is not provided\"));\n+            };\n+            let arg0_addr = Address::from_bytes(arg0.get(self)?)?;\n+            let arg0_interval = Interval::new(\n+                arg0_addr,\n+                self.size_of_sized(ty, locals, \"atomic intrinsic type arg\")?,\n+            );\n+            if name.starts_with(\"load_\") {\n+                return destination.write_from_interval(self, arg0_interval);\n+            }\n+            let Some(arg1) = args.get(1) else {\n+                return Err(MirEvalError::TypeError(\"atomic intrinsic arg1 is not provided\"));\n+            };\n+            if name.starts_with(\"store_\") {\n+                return arg0_interval.write_from_interval(self, arg1.interval);\n+            }\n+            if name.starts_with(\"xchg_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                return arg0_interval.write_from_interval(self, arg1.interval);\n+            }\n+            if name.starts_with(\"xadd_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = lhs.wrapping_add(rhs);\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            if name.starts_with(\"xsub_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = lhs.wrapping_sub(rhs);\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            if name.starts_with(\"and_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = lhs & rhs;\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            if name.starts_with(\"or_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = lhs | rhs;\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            if name.starts_with(\"xor_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = lhs ^ rhs;\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            if name.starts_with(\"nand_\") {\n+                destination.write_from_interval(self, arg0_interval)?;\n+                let lhs = u128::from_le_bytes(pad16(arg0_interval.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(arg1.get(self)?, false));\n+                let ans = !(lhs & rhs);\n+                return arg0_interval\n+                    .write_from_bytes(self, &ans.to_le_bytes()[0..destination.size]);\n+            }\n+            let Some(arg2) = args.get(2) else {\n+                return Err(MirEvalError::TypeError(\"atomic intrinsic arg2 is not provided\"));\n+            };\n+            if name.starts_with(\"cxchg_\") || name.starts_with(\"cxchgweak_\") {\n+                let dest = if arg1.get(self)? == arg0_interval.get(self)? {\n+                    arg0_interval.write_from_interval(self, arg2.interval)?;\n+                    (arg1.interval, true)\n+                } else {\n+                    (arg0_interval, false)\n+                };\n+                let result_ty = TyKind::Tuple(\n+                    2,\n+                    Substitution::from_iter(Interner, [ty.clone(), TyBuilder::bool()]),\n+                )\n+                .intern(Interner);\n+                let layout = self.layout(&result_ty)?;\n+                let result = self.make_by_layout(\n+                    layout.size.bytes_usize(),\n+                    &layout,\n+                    None,\n+                    [\n+                        IntervalOrOwned::Borrowed(dest.0),\n+                        IntervalOrOwned::Owned(vec![u8::from(dest.1)]),\n+                    ]\n+                    .into_iter(),\n+                )?;\n+                return destination.write_from_bytes(self, &result);\n+            }\n+            not_supported!(\"unknown atomic intrinsic {name}\");\n+        }\n+        match as_str {\n+            \"size_of\" => {\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n+                };\n+                let size = self.size_of_sized(ty, locals, \"size_of arg\")?;\n+                destination.write_from_bytes(self, &size.to_le_bytes()[0..destination.size])\n+            }\n+            \"min_align_of\" | \"pref_align_of\" => {\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"align_of generic arg is not provided\"));\n+                };\n+                let align = self.layout_filled(ty, locals)?.align.abi.bytes();\n+                destination.write_from_bytes(self, &align.to_le_bytes()[0..destination.size])\n+            }\n+            \"needs_drop\" => {\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"size_of generic arg is not provided\"));\n+                };\n+                let result = !ty.clone().is_copy(self.db, locals.body.owner);\n+                destination.write_from_bytes(self, &[u8::from(result)])\n+            }\n+            \"ptr_guaranteed_cmp\" => {\n+                // FIXME: this is wrong for const eval, it should return 2 in some\n+                // cases.\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"wrapping_add args are not provided\"));\n+                };\n+                let ans = lhs.get(self)? == rhs.get(self)?;\n+                destination.write_from_bytes(self, &[u8::from(ans)])\n+            }\n+            \"wrapping_add\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"wrapping_add args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_add(rhs);\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"add_with_overflow\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let result_ty = TyKind::Tuple(\n+                    2,\n+                    Substitution::from_iter(Interner, [lhs.ty.clone(), TyBuilder::bool()]),\n+                )\n+                .intern(Interner);\n+                let op_size =\n+                    self.size_of_sized(&lhs.ty, locals, \"operand of add_with_overflow\")?;\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_add(rhs);\n+                let is_overflow = false;\n+                let is_overflow = vec![u8::from(is_overflow)];\n+                let layout = self.layout(&result_ty)?;\n+                let result = self.make_by_layout(\n+                    layout.size.bytes_usize(),\n+                    &layout,\n+                    None,\n+                    [ans.to_le_bytes()[0..op_size].to_vec(), is_overflow]\n+                        .into_iter()\n+                        .map(IntervalOrOwned::Owned),\n+                )?;\n+                destination.write_from_bytes(self, &result)\n+            }\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+                let [src, dst, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"copy_nonoverlapping generic arg is not provided\"));\n+                };\n+                let src = Address::from_bytes(src.get(self)?)?;\n+                let dst = Address::from_bytes(dst.get(self)?)?;\n+                let offset = from_bytes!(usize, offset.get(self)?);\n+                let size = self.size_of_sized(ty, locals, \"copy_nonoverlapping ptr type\")?;\n+                let size = offset * size;\n+                let src = Interval { addr: src, size };\n+                let dst = Interval { addr: dst, size };\n+                dst.write_from_interval(self, src)\n+            }\n+            \"offset\" | \"arith_offset\" => {\n+                let [ptr, offset] = args else {\n+                    return Err(MirEvalError::TypeError(\"offset args are not provided\"));\n+                };\n+                let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n+                    return Err(MirEvalError::TypeError(\"offset generic arg is not provided\"));\n+                };\n+                let ptr = u128::from_le_bytes(pad16(ptr.get(self)?, false));\n+                let offset = u128::from_le_bytes(pad16(offset.get(self)?, false));\n+                let size = self.size_of_sized(ty, locals, \"offset ptr type\")? as u128;\n+                let ans = ptr + offset * size;\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n+            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" | \"assume\" => {\n+                // FIXME: We should actually implement these checks\n+                Ok(())\n+            }\n+            \"forget\" => {\n+                // We don't call any drop glue yet, so there is nothing here\n+                Ok(())\n+            }\n+            \"transmute\" => {\n+                let [arg] = args else {\n+                    return Err(MirEvalError::TypeError(\"trasmute arg is not provided\"));\n+                };\n+                destination.write_from_interval(self, arg.interval)\n+            }\n+            \"likely\" | \"unlikely\" => {\n+                let [arg] = args else {\n+                    return Err(MirEvalError::TypeError(\"likely arg is not provided\"));\n+                };\n+                destination.write_from_interval(self, arg.interval)\n+            }\n+            \"const_eval_select\" => {\n+                let [tuple, const_fn, _] = args else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n+                };\n+                let mut args = vec![const_fn.clone()];\n+                let TyKind::Tuple(_, fields) = tuple.ty.kind(Interner) else {\n+                    return Err(MirEvalError::TypeError(\"const_eval_select arg[0] is not a tuple\"));\n+                };\n+                let layout = self.layout(&tuple.ty)?;\n+                for (i, field) in fields.iter(Interner).enumerate() {\n+                    let field = field.assert_ty_ref(Interner).clone();\n+                    let offset = layout.fields.offset(i).bytes_usize();\n+                    let addr = tuple.interval.addr.offset(offset);\n+                    args.push(IntervalAndTy::new(addr, field, self, locals)?);\n+                }\n+                self.exec_fn_trait(&args, destination, locals, span)\n+            }\n+            _ => not_supported!(\"unknown intrinsic {as_str}\"),\n+        }\n+    }\n+}"}, {"sha": "733f58e8f6b087a2dc15d62f227a9025403dde68", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 235, "deletions": 102, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,14 +1,15 @@\n //! This module generates a polymorphic MIR from a hir body\n \n-use std::{iter, mem, sync::Arc};\n+use std::{fmt::Write, iter, mem, sync::Arc};\n \n+use base_db::FileId;\n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n     body::Body,\n     data::adt::{StructKind, VariantData},\n     hir::{\n-        Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n-        RecordFieldPat, RecordLitField,\n+        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm,\n+        Pat, PatId, RecordFieldPat, RecordLitField,\n     },\n     lang_item::{LangItem, LangItemTarget},\n     path::Path,\n@@ -18,6 +19,7 @@ use hir_def::{\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n+use syntax::TextRange;\n \n use crate::{\n     consteval::ConstEvalError,\n@@ -27,8 +29,9 @@ use crate::{\n     inhabitedness::is_ty_uninhabited_from,\n     layout::{layout_of_ty, LayoutError},\n     mapping::ToChalk,\n+    method_resolution::lookup_impl_const,\n     static_lifetime,\n-    utils::generics,\n+    utils::{generics, ClosureSubst},\n     Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n \n@@ -62,14 +65,14 @@ struct MirLowerCtx<'a> {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum MirLowerError {\n-    ConstEvalError(Box<ConstEvalError>),\n+    ConstEvalError(String, Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n     /// Trying to lower a trait function, instead of an implementation\n     TraitFunctionDefinition(TraitId, Name),\n     UnresolvedName(String),\n     RecordLiteralWithoutPath,\n-    UnresolvedMethod,\n+    UnresolvedMethod(String),\n     UnresolvedField,\n     MissingFunctionDefinition,\n     TypeMismatch(TypeMismatch),\n@@ -88,6 +91,46 @@ pub enum MirLowerError {\n     UnaccessableLocal,\n }\n \n+impl MirLowerError {\n+    pub fn pretty_print(\n+        &self,\n+        f: &mut String,\n+        db: &dyn HirDatabase,\n+        span_formatter: impl Fn(FileId, TextRange) -> String,\n+    ) -> std::result::Result<(), std::fmt::Error> {\n+        match self {\n+            MirLowerError::ConstEvalError(name, e) => {\n+                writeln!(f, \"In evaluating constant {name}\")?;\n+                match &**e {\n+                    ConstEvalError::MirLowerError(e) => e.pretty_print(f, db, span_formatter)?,\n+                    ConstEvalError::MirEvalError(e) => e.pretty_print(f, db, span_formatter)?,\n+                }\n+            }\n+            MirLowerError::LayoutError(_)\n+            | MirLowerError::IncompleteExpr\n+            | MirLowerError::UnaccessableLocal\n+            | MirLowerError::TraitFunctionDefinition(_, _)\n+            | MirLowerError::UnresolvedName(_)\n+            | MirLowerError::RecordLiteralWithoutPath\n+            | MirLowerError::UnresolvedMethod(_)\n+            | MirLowerError::UnresolvedField\n+            | MirLowerError::MissingFunctionDefinition\n+            | MirLowerError::TypeMismatch(_)\n+            | MirLowerError::TypeError(_)\n+            | MirLowerError::NotSupported(_)\n+            | MirLowerError::ContinueWithoutLoop\n+            | MirLowerError::BreakWithoutLoop\n+            | MirLowerError::Loop\n+            | MirLowerError::ImplementationError(_)\n+            | MirLowerError::LangItemNotFound(_)\n+            | MirLowerError::MutatingRvalue\n+            | MirLowerError::UnresolvedLabel\n+            | MirLowerError::UnresolvedUpvar(_) => writeln!(f, \"{:?}\", self)?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n macro_rules! not_supported {\n     ($x: expr) => {\n         return Err(MirLowerError::NotSupported(format!($x)))\n@@ -101,15 +144,6 @@ macro_rules! implementation_error {\n     }};\n }\n \n-impl From<ConstEvalError> for MirLowerError {\n-    fn from(value: ConstEvalError) -> Self {\n-        match value {\n-            ConstEvalError::MirLowerError(e) => e,\n-            _ => MirLowerError::ConstEvalError(Box::new(value)),\n-        }\n-    }\n-}\n-\n impl From<LayoutError> for MirLowerError {\n     fn from(value: LayoutError) -> Self {\n         MirLowerError::LayoutError(value)\n@@ -177,7 +211,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         if !self.has_adjustments(expr_id) {\n             match &self.body.exprs[expr_id] {\n                 Expr::Literal(l) => {\n-                    let ty = self.expr_ty(expr_id);\n+                    let ty = self.expr_ty_without_adjust(expr_id);\n                     return Ok(Some((self.lower_literal_to_operand(ty, l)?, current)));\n                 }\n                 _ => (),\n@@ -282,7 +316,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         {\n                             match assoc {\n                                 hir_def::AssocItemId::ConstId(c) => {\n-                                    self.lower_const(c, current, place, subst, expr_id.into())?;\n+                                    self.lower_const(c, current, place, subst, expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n                                     return Ok(Some(current))\n                                 },\n                                 hir_def::AssocItemId::FunctionId(_) => {\n@@ -309,17 +343,20 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     }\n                 };\n                 match pr {\n-                    ValueNs::LocalBinding(pat_id) => {\n+                    ValueNs::LocalBinding(_) | ValueNs::StaticId(_) => {\n+                        let Some((temp, current)) = self.lower_expr_as_place_without_adjust(current, expr_id, false)? else {\n+                            return Ok(None);\n+                        };\n                         self.push_assignment(\n                             current,\n                             place,\n-                            Operand::Copy(self.binding_local(pat_id)?.into()).into(),\n+                            Operand::Copy(temp).into(),\n                             expr_id.into(),\n                         );\n                         Ok(Some(current))\n                     }\n                     ValueNs::ConstId(const_id) => {\n-                        self.lower_const(const_id, current, place, Substitution::empty(Interner), expr_id.into())?;\n+                        self.lower_const(const_id, current, place, Substitution::empty(Interner), expr_id.into(), self.expr_ty_without_adjust(expr_id))?;\n                         Ok(Some(current))\n                     }\n                     ValueNs::EnumVariantId(variant_id) => {\n@@ -343,7 +380,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                             not_supported!(\"owner without generic def id\");\n                         };\n                         let gen = generics(self.db.upcast(), def);\n-                        let ty = self.expr_ty(expr_id);\n+                        let ty = self.expr_ty_without_adjust(expr_id);\n                         self.push_assignment(\n                             current,\n                             place,\n@@ -388,12 +425,13 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 };\n                 self.set_terminator(\n                     current,\n-                    Terminator::SwitchInt {\n+                    TerminatorKind::SwitchInt {\n                         discr,\n                         targets: SwitchTargets::static_if(1, start_of_then, start_of_else),\n                     },\n+                    expr_id.into(),\n                 );\n-                Ok(self.merge_blocks(end_of_then, end_of_else))\n+                Ok(self.merge_blocks(end_of_then, end_of_else, expr_id.into()))\n             }\n             Expr::Let { pat, expr } => {\n                 let Some((cond_place, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n@@ -423,46 +461,47 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         MirSpan::Unknown,\n                     )?;\n                 }\n-                Ok(self.merge_blocks(Some(then_target), else_target))\n+                Ok(self.merge_blocks(Some(then_target), else_target, expr_id.into()))\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n-                self.lower_block_to_place(statements, current, *tail, place)\n+                self.lower_block_to_place(statements, current, *tail, place, expr_id.into())\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n                 if let Some(label) = label {\n-                    self.lower_loop(current, place.clone(), Some(*label), |this, begin| {\n-                        if let Some(block) = this.lower_block_to_place(statements, begin, *tail, place)? {\n+                    self.lower_loop(current, place.clone(), Some(*label), expr_id.into(), |this, begin| {\n+                        if let Some(block) = this.lower_block_to_place(statements, begin, *tail, place, expr_id.into())? {\n                             let end = this.current_loop_end()?;\n-                            this.set_goto(block, end);\n+                            this.set_goto(block, end, expr_id.into());\n                         }\n                         Ok(())\n                     })\n                 } else {\n-                    self.lower_block_to_place(statements, current, *tail, place)\n+                    self.lower_block_to_place(statements, current, *tail, place, expr_id.into())\n                 }\n             }\n-            Expr::Loop { body, label } => self.lower_loop(current, place, *label, |this, begin| {\n+            Expr::Loop { body, label } => self.lower_loop(current, place, *label, expr_id.into(), |this, begin| {\n                 if let Some((_, block)) = this.lower_expr_as_place(begin, *body, true)? {\n-                    this.set_goto(block, begin);\n+                    this.set_goto(block, begin, expr_id.into());\n                 }\n                 Ok(())\n             }),\n             Expr::While { condition, body, label } => {\n-                self.lower_loop(current, place, *label, |this, begin| {\n+                self.lower_loop(current, place, *label, expr_id.into(),|this, begin| {\n                     let Some((discr, to_switch)) = this.lower_expr_to_some_operand(*condition, begin)? else {\n                         return Ok(());\n                     };\n                     let end = this.current_loop_end()?;\n                     let after_cond = this.new_basic_block();\n                     this.set_terminator(\n                         to_switch,\n-                        Terminator::SwitchInt {\n+                        TerminatorKind::SwitchInt {\n                             discr,\n                             targets: SwitchTargets::static_if(1, after_cond, end),\n                         },\n+                        expr_id.into(),\n                     );\n                     if let Some((_, block)) = this.lower_expr_as_place(after_cond, *body, true)? {\n-                        this.set_goto(block, begin);\n+                        this.set_goto(block, begin, expr_id.into());\n                     }\n                     Ok(())\n                 })\n@@ -478,12 +517,12 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let into_iter_fn_op = Operand::const_zst(\n                     TyKind::FnDef(\n                         self.db.intern_callable_def(CallableDefId::FunctionId(into_iter_fn)).into(),\n-                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                        Substitution::from1(Interner, self.expr_ty_without_adjust(iterable))\n                     ).intern(Interner));\n                 let iter_next_fn_op = Operand::const_zst(\n                     TyKind::FnDef(\n                         self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n-                        Substitution::from1(Interner, self.expr_ty(iterable))\n+                        Substitution::from1(Interner, self.expr_ty_without_adjust(iterable))\n                     ).intern(Interner));\n                 let &Some(iterator_ty) = &self.infer.type_of_for_iterator.get(&expr_id) else {\n                     return Err(MirLowerError::TypeError(\"unknown for loop iterator type\"));\n@@ -494,13 +533,13 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let iterator_place: Place = self.temp(iterator_ty.clone())?.into();\n                 let option_item_place: Place = self.temp(option_item_ty.clone())?.into();\n                 let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty)?.into();\n-                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false)?\n+                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false, expr_id.into())?\n                 else {\n                     return Ok(None);\n                 };\n                 self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n-                self.lower_loop(current, place, label, |this, begin| {\n-                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false)?\n+                self.lower_loop(current, place, label, expr_id.into(), |this, begin| {\n+                    let Some(current) = this.lower_call(iter_next_fn_op, vec![Operand::Copy(ref_mut_iterator_place)], option_item_place.clone(), begin, false, expr_id.into())?\n                     else {\n                         return Ok(());\n                     };\n@@ -516,7 +555,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         AdtPatternShape::Tuple { args: &[pat], ellipsis: None },\n                     )?;\n                     if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n-                        this.set_goto(block, begin);\n+                        this.set_goto(block, begin, expr_id.into());\n                     }\n                     Ok(())\n                 })\n@@ -536,39 +575,36 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         place,\n                         current,\n                         self.is_uninhabited(expr_id),\n+                        expr_id.into(),\n                     );\n                 }\n                 let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n-                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id), expr_id.into())\n                     }\n                     chalk_ir::TyKind::Function(_) => {\n                         let Some((func, current)) = self.lower_expr_to_some_operand(*callee, current)? else {\n                             return Ok(None);\n                         };\n-                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id), expr_id.into())\n                     }\n                     TyKind::Error => return Err(MirLowerError::MissingFunctionDefinition),\n                     _ => return Err(MirLowerError::TypeError(\"function call on bad type\")),\n                 }\n             }\n-            Expr::MethodCall { receiver, args, .. } => {\n+            Expr::MethodCall { receiver, args, method_name, .. } => {\n                 let (func_id, generic_args) =\n-                    self.infer.method_resolution(expr_id).ok_or(MirLowerError::UnresolvedMethod)?;\n-                let ty = chalk_ir::TyKind::FnDef(\n-                    CallableDefId::FunctionId(func_id).to_chalk(self.db),\n-                    generic_args,\n-                )\n-                .intern(Interner);\n-                let func = Operand::from_bytes(vec![], ty);\n+                    self.infer.method_resolution(expr_id).ok_or_else(|| MirLowerError::UnresolvedMethod(format!(\"{}\", method_name)))?;\n+                let func = Operand::from_fn(self.db, func_id, generic_args);\n                 self.lower_call_and_args(\n                     func,\n                     iter::once(*receiver).chain(args.iter().copied()),\n                     place,\n                     current,\n                     self.is_uninhabited(expr_id),\n+                    expr_id.into(),\n                 )\n             }\n             Expr::Match { expr, arms } => {\n@@ -591,15 +627,15 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         let next = self.new_basic_block();\n                         let o = otherwise.get_or_insert_with(|| self.new_basic_block());\n                         if let Some((discr, c)) = self.lower_expr_to_some_operand(guard, then)? {\n-                            self.set_terminator(c, Terminator::SwitchInt { discr, targets: SwitchTargets::static_if(1, next, *o) });\n+                            self.set_terminator(c, TerminatorKind::SwitchInt { discr, targets: SwitchTargets::static_if(1, next, *o) }, expr_id.into());\n                         }\n                         next\n                     } else {\n                         then\n                     };\n                     if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n                         let r = end.get_or_insert_with(|| self.new_basic_block());\n-                        self.set_goto(block, *r);\n+                        self.set_goto(block, *r, expr_id.into());\n                     }\n                     match otherwise {\n                         Some(o) => current = o,\n@@ -611,18 +647,17 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     }\n                 }\n                 if self.is_unterminated(current) {\n-                    self.set_terminator(current, Terminator::Unreachable);\n+                    self.set_terminator(current, TerminatorKind::Unreachable, expr_id.into());\n                 }\n                 Ok(end)\n             }\n-            Expr::Continue { label } => match label {\n-                Some(_) => not_supported!(\"continue with label\"),\n-                None => {\n-                    let loop_data =\n-                        self.current_loop_blocks.as_ref().ok_or(MirLowerError::ContinueWithoutLoop)?;\n-                    self.set_goto(current, loop_data.begin);\n-                    Ok(None)\n-                }\n+            Expr::Continue { label } => {\n+                let loop_data = match label {\n+                    Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n+                    None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::ContinueWithoutLoop)?,\n+                };\n+                self.set_goto(current, loop_data.begin, expr_id.into());\n+                Ok(None)\n             },\n             &Expr::Break { expr, label } => {\n                 if let Some(expr) = expr {\n@@ -639,7 +674,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n                     None => self.current_loop_end()?,\n                 };\n-                self.set_goto(current, end);\n+                self.set_goto(current, end, expr_id.into());\n                 Ok(None)\n             }\n             Expr::Return { expr } => {\n@@ -650,7 +685,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         return Ok(None);\n                     }\n                 }\n-                self.set_terminator(current, Terminator::Return);\n+                self.set_terminator(current, TerminatorKind::Return, expr_id.into());\n                 Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n@@ -672,7 +707,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         Some(p) => MirLowerError::UnresolvedName(p.display(self.db).to_string()),\n                         None => MirLowerError::RecordLiteralWithoutPath,\n                     })?;\n-                let subst = match self.expr_ty(expr_id).kind(Interner) {\n+                let subst = match self.expr_ty_without_adjust(expr_id).kind(Interner) {\n                     TyKind::Adt(_, s) => s.clone(),\n                     _ => not_supported!(\"Non ADT record literal\"),\n                 };\n@@ -757,7 +792,17 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 self.push_assignment(current, place, Rvalue::Ref(bk, p), expr_id.into());\n                 Ok(Some(current))\n             }\n-            Expr::Box { .. } => not_supported!(\"box expression\"),\n+            Expr::Box { expr } => {\n+                let ty = self.expr_ty_after_adjustments(*expr);\n+                self.push_assignment(current, place.clone(), Rvalue::ShallowInitBoxWithAlloc(ty), expr_id.into());\n+                let Some((operand, current)) = self.lower_expr_to_some_operand(*expr, current)? else {\n+                    return Ok(None);\n+                };\n+                let mut p = place;\n+                p.projection.push(ProjectionElem::Deref);\n+                self.push_assignment(current, p, operand.into(), expr_id.into());\n+                Ok(Some(current))\n+            },\n             Expr::Field { .. } | Expr::Index { .. } | Expr::UnaryOp { op: hir_def::hir::UnaryOp::Deref, .. } => {\n                 let Some((p, current)) = self.lower_expr_as_place_without_adjust(current, expr_id, true)? else {\n                     return Ok(None);\n@@ -784,20 +829,63 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             },\n             Expr::BinaryOp { lhs, rhs, op } => {\n                 let op = op.ok_or(MirLowerError::IncompleteExpr)?;\n-                if let hir_def::hir::BinaryOp::Assignment { op } = op {\n-                    if op.is_some() {\n-                        not_supported!(\"assignment with arith op (like +=)\");\n+                let is_builtin = {\n+                    // Without adjust here is a hack. We assume that we know every possible adjustment\n+                    // for binary operator, and use without adjust to simplify our conditions.\n+                    let lhs_ty = self.expr_ty_without_adjust(*lhs);\n+                    let rhs_ty = self.expr_ty_without_adjust(*rhs);\n+                    let builtin_inequal_impls = matches!(\n+                        op,\n+                        BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) | BinaryOp::Assignment { op: Some(ArithOp::Shl | ArithOp::Shr) }\n+                    );\n+                    lhs_ty.as_builtin().is_some() && rhs_ty.as_builtin().is_some() && (lhs_ty == rhs_ty || builtin_inequal_impls)\n+                };\n+                if !is_builtin {\n+                    if let Some((func_id, generic_args)) = self.infer.method_resolution(expr_id) {\n+                        let func = Operand::from_fn(self.db, func_id, generic_args);\n+                        return self.lower_call_and_args(\n+                            func,\n+                            [*lhs, *rhs].into_iter(),\n+                            place,\n+                            current,\n+                            self.is_uninhabited(expr_id),\n+                            expr_id.into(),\n+                        );\n                     }\n-                    let Some((lhs_place, current)) =\n+                }\n+                if let hir_def::hir::BinaryOp::Assignment { op } = op {\n+                    if let Some(op) = op {\n+                        // last adjustment is `&mut` which we don't want it.\n+                        let adjusts = self\n+                            .infer\n+                            .expr_adjustments\n+                            .get(lhs)\n+                            .and_then(|x| x.split_last())\n+                            .map(|x| x.1)\n+                            .ok_or(MirLowerError::TypeError(\"adjustment of binary op was missing\"))?;\n+                        let Some((lhs_place, current)) =\n+                            self.lower_expr_as_place_with_adjust(current, *lhs, false, adjusts)?\n+                        else {\n+                            return Ok(None);\n+                        };\n+                        let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                            return Ok(None);\n+                        };\n+                        let r_value = Rvalue::CheckedBinaryOp(op.into(), Operand::Copy(lhs_place.clone()), rhs_op);\n+                        self.push_assignment(current, lhs_place, r_value, expr_id.into());\n+                        return Ok(Some(current));\n+                    } else {\n+                        let Some((lhs_place, current)) =\n                         self.lower_expr_as_place(current, *lhs, false)?\n-                    else {\n-                        return Ok(None);\n-                    };\n-                    let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n-                        return Ok(None);\n-                    };\n-                    self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n-                    return Ok(Some(current));\n+                        else {\n+                            return Ok(None);\n+                        };\n+                        let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n+                            return Ok(None);\n+                        };\n+                        self.push_assignment(current, lhs_place, rhs_op.into(), expr_id.into());\n+                        return Ok(Some(current));\n+                    }\n                 }\n                 let Some((lhs_op, current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n                     return Ok(None);\n@@ -826,7 +914,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 Ok(Some(current))\n             }\n             &Expr::Range { lhs, rhs, range_type: _ } => {\n-                let ty = self.expr_ty(expr_id);\n+                let ty = self.expr_ty_without_adjust(expr_id);\n                 let Some((adt, subst)) = ty.as_adt() else {\n                     return Err(MirLowerError::TypeError(\"Range type is not adt\"));\n                 };\n@@ -869,7 +957,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 Ok(Some(current))\n             },\n             Expr::Closure { .. } => {\n-                let ty = self.expr_ty(expr_id);\n+                let ty = self.expr_ty_without_adjust(expr_id);\n                 let TyKind::Closure(id, _) = ty.kind(Interner) else {\n                     not_supported!(\"closure with non closure type\");\n                 };\n@@ -893,7 +981,12 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     };\n                     match &capture.kind {\n                         CaptureKind::ByRef(bk) => {\n-                            let tmp: Place = self.temp(capture.ty.clone())?.into();\n+                            let placeholder_subst = match self.owner.as_generic_def_id() {\n+                                Some(x) => TyBuilder::placeholder_subst(self.db, x),\n+                                None => Substitution::empty(Interner),\n+                            };\n+                            let tmp_ty = capture.ty.clone().substitute(Interner, &placeholder_subst);\n+                            let tmp: Place = self.temp(tmp_ty)?.into();\n                             self.push_assignment(\n                                 current,\n                                 tmp.clone(),\n@@ -928,15 +1021,15 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     return Ok(None);\n                 };\n                 let r = Rvalue::Aggregate(\n-                    AggregateKind::Tuple(self.expr_ty(expr_id)),\n+                    AggregateKind::Tuple(self.expr_ty_without_adjust(expr_id)),\n                     values,\n                 );\n                 self.push_assignment(current, place, r, expr_id.into());\n                 Ok(Some(current))\n             }\n             Expr::Array(l) => match l {\n                 Array::ElementList { elements, .. } => {\n-                    let elem_ty = match &self.expr_ty(expr_id).data(Interner).kind {\n+                    let elem_ty = match &self.expr_ty_without_adjust(expr_id).data(Interner).kind {\n                         TyKind::Array(ty, _) => ty.clone(),\n                         _ => {\n                             return Err(MirLowerError::TypeError(\n@@ -968,7 +1061,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     let Some((init, current)) = self.lower_expr_to_some_operand(*initializer, current)? else {\n                         return Ok(None);\n                     };\n-                    let len = match &self.expr_ty(expr_id).data(Interner).kind {\n+                    let len = match &self.expr_ty_without_adjust(expr_id).data(Interner).kind {\n                         TyKind::Array(_, len) => len.clone(),\n                         _ => {\n                             return Err(MirLowerError::TypeError(\n@@ -982,7 +1075,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 },\n             },\n             Expr::Literal(l) => {\n-                let ty = self.expr_ty(expr_id);\n+                let ty = self.expr_ty_without_adjust(expr_id);\n                 let op = self.lower_literal_to_operand(ty, l)?;\n                 self.push_assignment(current, place, op.into(), expr_id.into());\n                 Ok(Some(current))\n@@ -1057,8 +1150,30 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         place: Place,\n         subst: Substitution,\n         span: MirSpan,\n+        ty: Ty,\n     ) -> Result<()> {\n-        let c = self.db.const_eval(const_id, subst)?;\n+        let c = if subst.len(Interner) != 0 {\n+            // We can't evaluate constant with substitution now, as generics are not monomorphized in lowering.\n+            intern_const_scalar(ConstScalar::UnevaluatedConst(const_id, subst), ty)\n+        } else {\n+            let (const_id, subst) = lookup_impl_const(\n+                self.db,\n+                self.db.trait_environment_for_body(self.owner),\n+                const_id,\n+                subst,\n+            );\n+            let name = self\n+                .db\n+                .const_data(const_id)\n+                .name\n+                .as_ref()\n+                .and_then(|x| x.as_str())\n+                .unwrap_or(\"_\")\n+                .to_owned();\n+            self.db\n+                .const_eval(const_id.into(), subst)\n+                .map_err(|e| MirLowerError::ConstEvalError(name, Box::new(e)))?\n+        };\n         self.write_const_to_place(c, prev_block, place, span)\n     }\n \n@@ -1114,6 +1229,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         place: Place,\n         mut current: BasicBlockId,\n         is_uninhabited: bool,\n+        span: MirSpan,\n     ) -> Result<Option<BasicBlockId>> {\n         let Some(args) = args\n             .map(|arg| {\n@@ -1128,7 +1244,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         else {\n             return Ok(None);\n         };\n-        self.lower_call(func, args, place, current, is_uninhabited)\n+        self.lower_call(func, args, place, current, is_uninhabited, span)\n     }\n \n     fn lower_call(\n@@ -1138,18 +1254,20 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         place: Place,\n         current: BasicBlockId,\n         is_uninhabited: bool,\n+        span: MirSpan,\n     ) -> Result<Option<BasicBlockId>> {\n         let b = if is_uninhabited { None } else { Some(self.new_basic_block()) };\n         self.set_terminator(\n             current,\n-            Terminator::Call {\n+            TerminatorKind::Call {\n                 func,\n                 args,\n                 destination: place,\n                 target: b,\n                 cleanup: None,\n                 from_hir_call: true,\n             },\n+            span,\n         );\n         Ok(b)\n     }\n@@ -1158,15 +1276,15 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         self.result.basic_blocks[source].terminator.is_none()\n     }\n \n-    fn set_terminator(&mut self, source: BasicBlockId, terminator: Terminator) {\n-        self.result.basic_blocks[source].terminator = Some(terminator);\n+    fn set_terminator(&mut self, source: BasicBlockId, terminator: TerminatorKind, span: MirSpan) {\n+        self.result.basic_blocks[source].terminator = Some(Terminator { span, kind: terminator });\n     }\n \n-    fn set_goto(&mut self, source: BasicBlockId, target: BasicBlockId) {\n-        self.set_terminator(source, Terminator::Goto { target });\n+    fn set_goto(&mut self, source: BasicBlockId, target: BasicBlockId, span: MirSpan) {\n+        self.set_terminator(source, TerminatorKind::Goto { target }, span);\n     }\n \n-    fn expr_ty(&self, e: ExprId) -> Ty {\n+    fn expr_ty_without_adjust(&self, e: ExprId) -> Ty {\n         self.infer[e].clone()\n     }\n \n@@ -1177,7 +1295,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 ty = Some(x.target.clone());\n             }\n         }\n-        ty.unwrap_or_else(|| self.expr_ty(e))\n+        ty.unwrap_or_else(|| self.expr_ty_without_adjust(e))\n     }\n \n     fn push_statement(&mut self, block: BasicBlockId, statement: Statement) {\n@@ -1211,6 +1329,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         prev_block: BasicBlockId,\n         place: Place,\n         label: Option<LabelId>,\n+        span: MirSpan,\n         f: impl FnOnce(&mut MirLowerCtx<'_>, BasicBlockId) -> Result<()>,\n     ) -> Result<Option<BasicBlockId>> {\n         let begin = self.new_basic_block();\n@@ -1228,7 +1347,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         } else {\n             None\n         };\n-        self.set_goto(prev_block, begin);\n+        self.set_goto(prev_block, begin, span);\n         f(self, begin)?;\n         let my = mem::replace(&mut self.current_loop_blocks, prev).ok_or(\n             MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\".to_string()),\n@@ -1247,14 +1366,15 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         &mut self,\n         b1: Option<BasicBlockId>,\n         b2: Option<BasicBlockId>,\n+        span: MirSpan,\n     ) -> Option<BasicBlockId> {\n         match (b1, b2) {\n             (None, None) => None,\n             (None, Some(b)) | (Some(b), None) => Some(b),\n             (Some(b1), Some(b2)) => {\n                 let bm = self.new_basic_block();\n-                self.set_goto(b1, bm);\n-                self.set_goto(b2, bm);\n+                self.set_goto(b1, bm, span);\n+                self.set_goto(b2, bm, span);\n                 Some(bm)\n             }\n         }\n@@ -1332,6 +1452,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         mut current: BasicBlockId,\n         tail: Option<ExprId>,\n         place: Place,\n+        span: MirSpan,\n     ) -> Result<Option<Idx<BasicBlock>>> {\n         for statement in statements.iter() {\n             match statement {\n@@ -1355,13 +1476,13 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                         match (else_block, else_branch) {\n                             (None, _) => (),\n                             (Some(else_block), None) => {\n-                                self.set_terminator(else_block, Terminator::Unreachable);\n+                                self.set_terminator(else_block, TerminatorKind::Unreachable, span);\n                             }\n                             (Some(else_block), Some(else_branch)) => {\n                                 if let Some((_, b)) =\n                                     self.lower_expr_as_place(else_block, *else_branch, true)?\n                                 {\n-                                    self.set_terminator(b, Terminator::Unreachable);\n+                                    self.set_terminator(b, TerminatorKind::Unreachable, span);\n                                 }\n                             }\n                         }\n@@ -1438,7 +1559,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 BindingAnnotation::Unannotated,\n             )?;\n             if let Some(b) = r.1 {\n-                self.set_terminator(b, Terminator::Unreachable);\n+                self.set_terminator(b, TerminatorKind::Unreachable, param.into());\n             }\n             current = r.0;\n         }\n@@ -1456,6 +1577,18 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             }\n         }\n     }\n+\n+    fn const_eval_discriminant(&self, variant: EnumVariantId) -> Result<i128> {\n+        let r = self.db.const_eval_discriminant(variant);\n+        match r {\n+            Ok(r) => Ok(r),\n+            Err(e) => {\n+                let data = self.db.enum_data(variant.parent);\n+                let name = format!(\"{}::{}\", data.name, data.variants[variant.local_id].name);\n+                Err(MirLowerError::ConstEvalError(name, Box::new(e)))\n+            }\n+        }\n+    }\n }\n \n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n@@ -1498,15 +1631,15 @@ pub fn mir_body_for_closure_query(\n     // 0 is return local\n     ctx.result.locals.alloc(Local { ty: infer[*root].clone() });\n     ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n-    let Some(sig) = substs.at(Interner, 0).assert_ty_ref(Interner).callable_sig(db) else {\n+    let Some(sig) = ClosureSubst(substs).sig_ty().callable_sig(db) else {\n         implementation_error!(\"closure has not callable sig\");\n     };\n     let current = ctx.lower_params_and_bindings(\n         args.iter().zip(sig.params().iter()).map(|(x, y)| (*x, y.clone())),\n         |_| true,\n     )?;\n     if let Some(b) = ctx.lower_expr_to_place(*root, return_slot().into(), current)? {\n-        ctx.set_terminator(b, Terminator::Return);\n+        ctx.set_terminator(b, TerminatorKind::Return, (*root).into());\n     }\n     let mut upvar_map: FxHashMap<LocalId, Vec<(&CapturedItem, usize)>> = FxHashMap::default();\n     for (i, capture) in captures.iter().enumerate() {\n@@ -1628,7 +1761,7 @@ pub fn lower_to_mir(\n         ctx.lower_params_and_bindings([].into_iter(), binding_picker)?\n     };\n     if let Some(b) = ctx.lower_expr_to_place(root_expr, return_slot().into(), current)? {\n-        ctx.set_terminator(b, Terminator::Return);\n+        ctx.set_terminator(b, TerminatorKind::Return, root_expr.into());\n     }\n     Ok(ctx.result)\n }"}, {"sha": "8d8870da0d4f188255d253ca827e6218bcb0d9df", "filename": "crates/hir-ty/src/mir/lower/as_place.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fas_place.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,7 +1,7 @@\n //! MIR lowering for places\n \n use super::*;\n-use hir_def::FunctionId;\n+use hir_def::{lang_item::lang_attr, FunctionId};\n use hir_expand::name;\n \n macro_rules! not_supported {\n@@ -16,7 +16,7 @@ impl MirLowerCtx<'_> {\n         expr_id: ExprId,\n         prev_block: BasicBlockId,\n     ) -> Result<Option<(Place, BasicBlockId)>> {\n-        let ty = self.expr_ty(expr_id);\n+        let ty = self.expr_ty_without_adjust(expr_id);\n         let place = self.temp(ty)?;\n         let Some(current) = self.lower_expr_to_place_without_adjust(expr_id, place.into(), prev_block)? else {\n             return Ok(None);\n@@ -30,8 +30,10 @@ impl MirLowerCtx<'_> {\n         prev_block: BasicBlockId,\n         adjustments: &[Adjustment],\n     ) -> Result<Option<(Place, BasicBlockId)>> {\n-        let ty =\n-            adjustments.last().map(|x| x.target.clone()).unwrap_or_else(|| self.expr_ty(expr_id));\n+        let ty = adjustments\n+            .last()\n+            .map(|x| x.target.clone())\n+            .unwrap_or_else(|| self.expr_ty_without_adjust(expr_id));\n         let place = self.temp(ty)?;\n         let Some(current) = self.lower_expr_to_place_with_adjust(expr_id, place.into(), prev_block, adjustments)? else {\n             return Ok(None);\n@@ -80,7 +82,7 @@ impl MirLowerCtx<'_> {\n                         r,\n                         rest.last()\n                             .map(|x| x.target.clone())\n-                            .unwrap_or_else(|| self.expr_ty(expr_id)),\n+                            .unwrap_or_else(|| self.expr_ty_without_adjust(expr_id)),\n                         last.target.clone(),\n                         expr_id.into(),\n                         match od.0 {\n@@ -135,25 +137,47 @@ impl MirLowerCtx<'_> {\n                 };\n                 match pr {\n                     ValueNs::LocalBinding(pat_id) => {\n-                        Ok(Some((self.result.binding_locals[pat_id].into(), current)))\n+                        Ok(Some((self.binding_local(pat_id)?.into(), current)))\n+                    }\n+                    ValueNs::StaticId(s) => {\n+                        let ty = self.expr_ty_without_adjust(expr_id);\n+                        let ref_ty =\n+                            TyKind::Ref(Mutability::Not, static_lifetime(), ty).intern(Interner);\n+                        let mut temp: Place = self.temp(ref_ty)?.into();\n+                        self.push_assignment(\n+                            current,\n+                            temp.clone(),\n+                            Operand::Static(s).into(),\n+                            expr_id.into(),\n+                        );\n+                        temp.projection.push(ProjectionElem::Deref);\n+                        Ok(Some((temp, current)))\n                     }\n                     _ => try_rvalue(self),\n                 }\n             }\n             Expr::UnaryOp { expr, op } => match op {\n                 hir_def::hir::UnaryOp::Deref => {\n-                    if !matches!(\n-                        self.expr_ty(*expr).kind(Interner),\n-                        TyKind::Ref(..) | TyKind::Raw(..)\n-                    ) {\n+                    let is_builtin = match self.expr_ty_without_adjust(*expr).kind(Interner) {\n+                        TyKind::Ref(..) | TyKind::Raw(..) => true,\n+                        TyKind::Adt(id, _) => {\n+                            if let Some(lang_item) = lang_attr(self.db.upcast(), id.0) {\n+                                lang_item == LangItem::OwnedBox\n+                            } else {\n+                                false\n+                            }\n+                        }\n+                        _ => false,\n+                    };\n+                    if !is_builtin {\n                         let Some((p, current)) = self.lower_expr_as_place(current, *expr, true)? else {\n                             return Ok(None);\n                         };\n                         return self.lower_overloaded_deref(\n                             current,\n                             p,\n                             self.expr_ty_after_adjustments(*expr),\n-                            self.expr_ty(expr_id),\n+                            self.expr_ty_without_adjust(expr_id),\n                             expr_id.into(),\n                             'b: {\n                                 if let Some((f, _)) = self.infer.method_resolution(expr_id) {\n@@ -198,7 +222,7 @@ impl MirLowerCtx<'_> {\n                     )\n                 {\n                     let Some(index_fn) = self.infer.method_resolution(expr_id) else {\n-                        return Err(MirLowerError::UnresolvedMethod);\n+                        return Err(MirLowerError::UnresolvedMethod(\"[overloaded index]\".to_string()));\n                     };\n                     let Some((base_place, current)) = self.lower_expr_as_place(current, *base, true)? else {\n                         return Ok(None);\n@@ -210,7 +234,7 @@ impl MirLowerCtx<'_> {\n                         current,\n                         base_place,\n                         base_ty,\n-                        self.expr_ty(expr_id),\n+                        self.expr_ty_without_adjust(expr_id),\n                         index_operand,\n                         expr_id.into(),\n                         index_fn,\n@@ -266,7 +290,7 @@ impl MirLowerCtx<'_> {\n             )\n             .intern(Interner),\n         );\n-        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(ref_place), index_operand], result.clone(), current, false)? else {\n+        let Some(current) = self.lower_call(index_fn_op, vec![Operand::Copy(ref_place), index_operand], result.clone(), current, false, span)? else {\n             return Ok(None);\n         };\n         result.projection.push(ProjectionElem::Deref);\n@@ -313,7 +337,7 @@ impl MirLowerCtx<'_> {\n             .intern(Interner),\n         );\n         let mut result: Place = self.temp(target_ty_ref)?.into();\n-        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false)? else {\n+        let Some(current) = self.lower_call(deref_fn_op, vec![Operand::Copy(ref_place)], result.clone(), current, false, span)? else {\n             return Ok(None);\n         };\n         result.projection.push(ProjectionElem::Deref);"}, {"sha": "97aa3b0f2150e96e29883bec509675fb8e1dc329", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,5 +1,7 @@\n //! MIR lowering for patterns\n \n+use hir_def::resolver::HasResolver;\n+\n use crate::utils::pattern_matching_dereference_count;\n \n use super::*;\n@@ -72,7 +74,7 @@ impl MirLowerCtx<'_> {\n                         *pat,\n                         binding_mode,\n                     )?;\n-                    self.set_goto(next, then_target);\n+                    self.set_goto(next, then_target, pattern.into());\n                     match next_else {\n                         Some(t) => {\n                             current = t;\n@@ -85,13 +87,13 @@ impl MirLowerCtx<'_> {\n                 }\n                 if !finished {\n                     let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n-                    self.set_goto(current, ce);\n+                    self.set_goto(current, ce, pattern.into());\n                 }\n                 (then_target, current_else)\n             }\n             Pat::Record { args, .. } => {\n                 let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n+                    not_supported!(\"unresolved variant for record\");\n                 };\n                 self.pattern_matching_variant(\n                     cond_ty,\n@@ -106,11 +108,8 @@ impl MirLowerCtx<'_> {\n             }\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n             Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n-            Pat::Path(_) => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n+            Pat::Path(p) => match self.infer.variant_resolution_for_pat(pattern) {\n+                Some(variant) => self.pattern_matching_variant(\n                     cond_ty,\n                     binding_mode,\n                     cond_place,\n@@ -119,8 +118,60 @@ impl MirLowerCtx<'_> {\n                     pattern.into(),\n                     current_else,\n                     AdtPatternShape::Unit,\n-                )?\n-            }\n+                )?,\n+                None => {\n+                    let unresolved_name = || MirLowerError::unresolved_path(self.db, p);\n+                    let resolver = self.owner.resolver(self.db.upcast());\n+                    let pr = resolver\n+                        .resolve_path_in_value_ns(self.db.upcast(), p)\n+                        .ok_or_else(unresolved_name)?;\n+                    match pr {\n+                        ResolveValueResult::ValueNs(v) => match v {\n+                            ValueNs::ConstId(c) => {\n+                                let tmp: Place = self.temp(cond_ty.clone())?.into();\n+                                let span = pattern.into();\n+                                self.lower_const(\n+                                    c,\n+                                    current,\n+                                    tmp.clone(),\n+                                    Substitution::empty(Interner),\n+                                    span,\n+                                    cond_ty.clone(),\n+                                )?;\n+                                let tmp2: Place = self.temp(TyBuilder::bool())?.into();\n+                                self.push_assignment(\n+                                    current,\n+                                    tmp2.clone(),\n+                                    Rvalue::CheckedBinaryOp(\n+                                        BinOp::Eq,\n+                                        Operand::Copy(tmp),\n+                                        Operand::Copy(cond_place),\n+                                    ),\n+                                    span,\n+                                );\n+                                let next = self.new_basic_block();\n+                                let else_target =\n+                                    current_else.unwrap_or_else(|| self.new_basic_block());\n+                                self.set_terminator(\n+                                    current,\n+                                    TerminatorKind::SwitchInt {\n+                                        discr: Operand::Copy(tmp2),\n+                                        targets: SwitchTargets::static_if(1, next, else_target),\n+                                    },\n+                                    span,\n+                                );\n+                                (next, Some(else_target))\n+                            }\n+                            _ => not_supported!(\n+                                \"path in pattern position that is not const or variant\"\n+                            ),\n+                        },\n+                        ResolveValueResult::Partial(_, _) => {\n+                            not_supported!(\"assoc const in patterns\")\n+                        }\n+                    }\n+                }\n+            },\n             Pat::Lit(l) => match &self.body.exprs[*l] {\n                 Expr::Literal(l) => {\n                     let c = self.lower_literal_to_operand(cond_ty, l)?;\n@@ -218,10 +269,11 @@ impl MirLowerCtx<'_> {\n         let discr = Operand::Copy(discr);\n         self.set_terminator(\n             current,\n-            Terminator::SwitchInt {\n+            TerminatorKind::SwitchInt {\n                 discr,\n                 targets: SwitchTargets::static_if(1, then_target, else_target),\n             },\n+            pattern.into(),\n         );\n         Ok((then_target, Some(else_target)))\n     }\n@@ -244,22 +296,23 @@ impl MirLowerCtx<'_> {\n         };\n         Ok(match variant {\n             VariantId::EnumVariantId(v) => {\n-                let e = self.db.const_eval_discriminant(v)? as u128;\n-                let next = self.new_basic_block();\n+                let e = self.const_eval_discriminant(v)? as u128;\n                 let tmp = self.discr_temp_place();\n                 self.push_assignment(\n                     current,\n                     tmp.clone(),\n                     Rvalue::Discriminant(cond_place.clone()),\n                     span,\n                 );\n+                let next = self.new_basic_block();\n                 let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n                 self.set_terminator(\n                     current,\n-                    Terminator::SwitchInt {\n+                    TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(tmp),\n                         targets: SwitchTargets::static_if(e, next, else_target),\n                     },\n+                    span,\n                 );\n                 let enum_data = self.db.enum_data(v.parent);\n                 self.pattern_matching_variant_fields("}, {"sha": "257860968c46bd82a3d1b1038185f488bd25cd2e", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 74, "deletions": 46, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -11,19 +11,52 @@ use la_arena::ArenaMap;\n \n use crate::{\n     db::HirDatabase,\n-    display::HirDisplay,\n-    mir::{PlaceElem, ProjectionElem, StatementKind, Terminator},\n+    display::{ClosureStyle, HirDisplay},\n+    mir::{PlaceElem, ProjectionElem, StatementKind, TerminatorKind},\n+    ClosureId,\n };\n \n use super::{\n     AggregateKind, BasicBlockId, BorrowKind, LocalId, MirBody, Operand, Place, Rvalue, UnOp,\n };\n \n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n impl MirBody {\n     pub fn pretty_print(&self, db: &dyn HirDatabase) -> String {\n         let hir_body = db.body(self.owner);\n         let mut ctx = MirPrettyCtx::new(self, &hir_body, db);\n-        ctx.for_body(ctx.body.owner);\n+        ctx.for_body(|this| match ctx.body.owner {\n+            hir_def::DefWithBodyId::FunctionId(id) => {\n+                let data = db.function_data(id);\n+                w!(this, \"fn {}() \", data.name);\n+            }\n+            hir_def::DefWithBodyId::StaticId(id) => {\n+                let data = db.static_data(id);\n+                w!(this, \"static {}: _ = \", data.name);\n+            }\n+            hir_def::DefWithBodyId::ConstId(id) => {\n+                let data = db.const_data(id);\n+                w!(this, \"const {}: _ = \", data.name.as_ref().unwrap_or(&Name::missing()));\n+            }\n+            hir_def::DefWithBodyId::VariantId(id) => {\n+                let data = db.enum_data(id.parent);\n+                w!(this, \"enum {} = \", data.name);\n+            }\n+        });\n         ctx.result\n     }\n \n@@ -49,21 +82,6 @@ struct MirPrettyCtx<'a> {\n     local_to_binding: ArenaMap<LocalId, BindingId>,\n }\n \n-macro_rules! w {\n-    ($dst:expr, $($arg:tt)*) => {\n-        { let _ = write!($dst, $($arg)*); }\n-    };\n-}\n-\n-macro_rules! wln {\n-    ($dst:expr) => {\n-        { let _ = writeln!($dst); }\n-    };\n-    ($dst:expr, $($arg:tt)*) => {\n-        { let _ = writeln!($dst, $($arg)*); }\n-    };\n-}\n-\n impl Write for MirPrettyCtx<'_> {\n     fn write_str(&mut self, s: &str) -> std::fmt::Result {\n         let mut it = s.split('\\n'); // note: `.lines()` is wrong here\n@@ -91,36 +109,40 @@ impl Display for LocalName {\n }\n \n impl<'a> MirPrettyCtx<'a> {\n-    fn for_body(&mut self, name: impl Debug) {\n-        wln!(self, \"// {:?}\", name);\n+    fn for_body(&mut self, name: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n+        name(self);\n         self.with_block(|this| {\n             this.locals();\n             wln!(this);\n             this.blocks();\n         });\n         for &closure in &self.body.closures {\n-            let body = match self.db.mir_body_for_closure(closure) {\n-                Ok(x) => x,\n-                Err(e) => {\n-                    wln!(self, \"// error in {closure:?}: {e:?}\");\n-                    continue;\n-                }\n-            };\n-            let result = mem::take(&mut self.result);\n-            let indent = mem::take(&mut self.indent);\n-            let mut ctx = MirPrettyCtx {\n-                body: &body,\n-                local_to_binding: body.binding_locals.iter().map(|(x, y)| (*y, x)).collect(),\n-                result,\n-                indent,\n-                ..*self\n-            };\n-            ctx.for_body(closure);\n-            self.result = ctx.result;\n-            self.indent = ctx.indent;\n+            self.for_closure(closure);\n         }\n     }\n \n+    fn for_closure(&mut self, closure: ClosureId) {\n+        let body = match self.db.mir_body_for_closure(closure) {\n+            Ok(x) => x,\n+            Err(e) => {\n+                wln!(self, \"// error in {closure:?}: {e:?}\");\n+                return;\n+            }\n+        };\n+        let result = mem::take(&mut self.result);\n+        let indent = mem::take(&mut self.indent);\n+        let mut ctx = MirPrettyCtx {\n+            body: &body,\n+            local_to_binding: body.binding_locals.iter().map(|(x, y)| (*y, x)).collect(),\n+            result,\n+            indent,\n+            ..*self\n+        };\n+        ctx.for_body(|this| wln!(this, \"// Closure: {:?}\", closure));\n+        self.result = ctx.result;\n+        self.indent = ctx.indent;\n+    }\n+\n     fn with_block(&mut self, f: impl FnOnce(&mut MirPrettyCtx<'_>)) {\n         self.indent += \"    \";\n         wln!(self, \"{{\");\n@@ -155,7 +177,7 @@ impl<'a> MirPrettyCtx<'a> {\n \n     fn locals(&mut self) {\n         for (id, local) in self.body.locals.iter() {\n-            wln!(self, \"let {}: {};\", self.local_name(id), local.ty.display(self.db));\n+            wln!(self, \"let {}: {};\", self.local_name(id), self.hir_display(&local.ty));\n         }\n     }\n \n@@ -198,11 +220,11 @@ impl<'a> MirPrettyCtx<'a> {\n                     }\n                 }\n                 match &block.terminator {\n-                    Some(terminator) => match terminator {\n-                        Terminator::Goto { target } => {\n+                    Some(terminator) => match &terminator.kind {\n+                        TerminatorKind::Goto { target } => {\n                             wln!(this, \"goto 'bb{};\", u32::from(target.into_raw()))\n                         }\n-                        Terminator::SwitchInt { discr, targets } => {\n+                        TerminatorKind::SwitchInt { discr, targets } => {\n                             w!(this, \"switch \");\n                             this.operand(discr);\n                             w!(this, \" \");\n@@ -213,7 +235,7 @@ impl<'a> MirPrettyCtx<'a> {\n                                 wln!(this, \"_ => {},\", this.basic_block_id(targets.otherwise()));\n                             });\n                         }\n-                        Terminator::Call { func, args, destination, target, .. } => {\n+                        TerminatorKind::Call { func, args, destination, target, .. } => {\n                             w!(this, \"Call \");\n                             this.with_block(|this| {\n                                 w!(this, \"func: \");\n@@ -295,7 +317,8 @@ impl<'a> MirPrettyCtx<'a> {\n                 // equally. Feel free to change it.\n                 self.place(p);\n             }\n-            Operand::Constant(c) => w!(self, \"Const({})\", c.display(self.db)),\n+            Operand::Constant(c) => w!(self, \"Const({})\", self.hir_display(c)),\n+            Operand::Static(s) => w!(self, \"Static({:?})\", s),\n         }\n     }\n \n@@ -349,7 +372,7 @@ impl<'a> MirPrettyCtx<'a> {\n             Rvalue::Cast(ck, op, ty) => {\n                 w!(self, \"Cast({ck:?}, \");\n                 self.operand(op);\n-                w!(self, \", {})\", ty.display(self.db));\n+                w!(self, \", {})\", self.hir_display(ty));\n             }\n             Rvalue::CheckedBinaryOp(b, o1, o2) => {\n                 self.operand(o1);\n@@ -369,6 +392,7 @@ impl<'a> MirPrettyCtx<'a> {\n                 self.place(p);\n                 w!(self, \")\");\n             }\n+            Rvalue::ShallowInitBoxWithAlloc(_) => w!(self, \"ShallowInitBoxWithAlloc\"),\n             Rvalue::ShallowInitBox(op, _) => {\n                 w!(self, \"ShallowInitBox(\");\n                 self.operand(op);\n@@ -392,4 +416,8 @@ impl<'a> MirPrettyCtx<'a> {\n             }\n         }\n     }\n+\n+    fn hir_display<T: HirDisplay>(&self, ty: &'a T) -> impl Display + 'a {\n+        ty.display(self.db).with_closure_style(ClosureStyle::ClosureWithId)\n+    }\n }"}, {"sha": "aa40d084795a0647dae20844877b2b2c5b9ecdec", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -23,10 +23,11 @@ use hir_expand::name::Name;\n use intern::Interned;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n+use stdx::never;\n \n use crate::{\n-    db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, Ty, TyExt,\n-    WhereClause,\n+    db::HirDatabase, ChalkTraitId, GenericArg, Interner, Substitution, TraitRef, TraitRefExt, Ty,\n+    TyExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(\n@@ -176,6 +177,37 @@ pub(crate) fn generics(db: &dyn DefDatabase, def: GenericDefId) -> Generics {\n     Generics { def, params: db.generic_params(def), parent_generics }\n }\n \n+/// It is a bit different from the rustc equivalent. Currently it stores:\n+/// - 0: the function signature, encoded as a function pointer type\n+/// - 1..n: generics of the parent\n+///\n+/// and it doesn't store the closure types and fields.\n+///\n+/// Codes should not assume this ordering, and should always use methods available\n+/// on this struct for retriving, and `TyBuilder::substs_for_closure` for creating.\n+pub(crate) struct ClosureSubst<'a>(pub(crate) &'a Substitution);\n+\n+impl<'a> ClosureSubst<'a> {\n+    pub(crate) fn parent_subst(&self) -> &'a [GenericArg] {\n+        match self.0.as_slice(Interner) {\n+            [_, x @ ..] => x,\n+            _ => {\n+                never!(\"Closure missing parameter\");\n+                &[]\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn sig_ty(&self) -> &'a Ty {\n+        match self.0.as_slice(Interner) {\n+            [x, ..] => x.assert_ty_ref(Interner),\n+            _ => {\n+                unreachable!(\"Closure missing sig_ty parameter\");\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct Generics {\n     def: GenericDefId,"}, {"sha": "145506a89df309c53b3f5aab449ff9f5b5fa49b0", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1856,11 +1856,21 @@ impl Function {\n         def_map.fn_as_proc_macro(self.id).map(|id| Macro { id: id.into() })\n     }\n \n-    pub fn eval(self, db: &dyn HirDatabase) -> Result<(), MirEvalError> {\n+    pub fn eval(\n+        self,\n+        db: &dyn HirDatabase,\n+        span_formatter: impl Fn(FileId, TextRange) -> String,\n+    ) -> Result<(), String> {\n+        let converter = |e: MirEvalError| {\n+            let mut r = String::new();\n+            _ = e.pretty_print(&mut r, db, &span_formatter);\n+            r\n+        };\n         let body = db\n             .mir_body(self.id.into())\n-            .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))?;\n-        interpret_mir(db, &body, Substitution::empty(Interner), false)?;\n+            .map_err(|e| MirEvalError::MirLowerError(self.id.into(), e))\n+            .map_err(converter)?;\n+        interpret_mir(db, &body, Substitution::empty(Interner), false).map_err(converter)?;\n         Ok(())\n     }\n }\n@@ -2006,7 +2016,7 @@ impl Const {\n     }\n \n     pub fn render_eval(self, db: &dyn HirDatabase) -> Result<String, ConstEvalError> {\n-        let c = db.const_eval(self.id, Substitution::empty(Interner))?;\n+        let c = db.const_eval(self.id.into(), Substitution::empty(Interner))?;\n         let r = format!(\"{}\", HexifiedConst(c).display(db));\n         // We want to see things like `<utf8-error>` and `<layout-error>` as they are probably bug in our\n         // implementation, but there is no need to show things like `<enum-not-supported>` or `<ref-not-supported>` to"}, {"sha": "8e0aa9df147143ebb2d1dc8844b8b938c7fd9ca8", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -30,7 +30,6 @@ pub struct HoverConfig {\n     pub documentation: bool,\n     pub keywords: bool,\n     pub format: HoverDocFormat,\n-    pub interpret_tests: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]"}, {"sha": "8f8cdcce515c2eca44ccb106e55f22cffe9d9759", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -3,8 +3,7 @@ use std::fmt::Display;\n \n use either::Either;\n use hir::{\n-    db::DefDatabase, Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay,\n-    MirEvalError, Semantics, TypeInfo,\n+    Adt, AsAssocItem, AttributeTemplate, HasAttrs, HasSource, HirDisplay, Semantics, TypeInfo,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -435,19 +434,7 @@ pub(super) fn definition(\n             ))\n         }),\n         Definition::Module(it) => label_and_docs(db, it),\n-        Definition::Function(it) => label_and_layout_info_and_docs(db, it, |_| {\n-            if !config.interpret_tests {\n-                return None;\n-            }\n-            match it.eval(db) {\n-                Ok(()) => Some(\"pass\".into()),\n-                Err(MirEvalError::MirLowerError(f, e)) => {\n-                    let name = &db.function_data(f).name;\n-                    Some(format!(\"error: fail to lower {name} due {e:?}\"))\n-                }\n-                Err(e) => Some(format!(\"error: {e:?}\")),\n-            }\n-        }),\n+        Definition::Function(it) => label_and_docs(db, it),\n         Definition::Adt(it) => label_and_layout_info_and_docs(db, it, |&it| {\n             let layout = it.layout(db).ok()?;\n             Some(format!(\"size = {}, align = {}\", layout.size.bytes(), layout.align.abi.bytes()))"}, {"sha": "082e5372d426c866bc3d86af59d5b70bf450e199", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -9,7 +9,6 @@ const HOVER_BASE_CONFIG: HoverConfig = HoverConfig {\n     documentation: true,\n     format: HoverDocFormat::Markdown,\n     keywords: true,\n-    interpret_tests: false,\n };\n \n fn check_hover_no_result(ra_fixture: &str) {"}, {"sha": "27e9ba3c36b4af8753eb8ead85871d0b6157ad41", "filename": "crates/ide/src/inlay_hints/adjustment.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fadjustment.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -3,7 +3,10 @@\n //! let _: u32  = /* <never-to-any> */ loop {};\n //! let _: &u32 = /* &* */ &mut 0;\n //! ```\n-use hir::{Adjust, Adjustment, AutoBorrow, HirDisplay, Mutability, PointerCast, Safety, Semantics};\n+use hir::{\n+    Adjust, Adjustment, AutoBorrow, HirDisplay, Mutability, OverloadedDeref, PointerCast, Safety,\n+    Semantics,\n+};\n use ide_db::RootDatabase;\n \n use stdx::never;\n@@ -88,7 +91,13 @@ pub(super) fn hints(\n             Adjust::NeverToAny if config.adjustment_hints == AdjustmentHints::Always => {\n                 (\"<never-to-any>\", \"never to any\")\n             }\n-            Adjust::Deref(_) => (\"*\", \"dereference\"),\n+            Adjust::Deref(None) => (\"*\", \"dereference\"),\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Shared))) => {\n+                (\"*\", \"`Deref` dereference\")\n+            }\n+            Adjust::Deref(Some(OverloadedDeref(Mutability::Mut))) => {\n+                (\"*\", \"`DerefMut` dereference\")\n+            }\n             Adjust::Borrow(AutoBorrow::Ref(Mutability::Shared)) => (\"&\", \"borrow\"),\n             Adjust::Borrow(AutoBorrow::Ref(Mutability::Mut)) => (\"&mut \", \"unique borrow\"),\n             Adjust::Borrow(AutoBorrow::RawPtr(Mutability::Shared)) => {"}, {"sha": "d8c8401af77d68e3d12c363305da590a536844a6", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -444,7 +444,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5768..5776,\n+                                        range: 5769..5777,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -457,7 +457,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5800..5804,\n+                                        range: 5801..5805,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -478,7 +478,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5768..5776,\n+                                        range: 5769..5777,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -491,7 +491,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5800..5804,\n+                                        range: 5801..5805,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -512,7 +512,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5768..5776,\n+                                        range: 5769..5777,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -525,7 +525,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 5800..5804,\n+                                        range: 5801..5805,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "d111f98955ac0cc6c3f53655bfcb34fddfbc57dd", "filename": "crates/ide/src/interpret_function.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finterpret_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Finterpret_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finterpret_function.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -0,0 +1,49 @@\n+use hir::Semantics;\n+use ide_db::base_db::SourceDatabaseExt;\n+use ide_db::RootDatabase;\n+use ide_db::{base_db::FilePosition, LineIndexDatabase};\n+use std::{fmt::Write, time::Instant};\n+use syntax::TextRange;\n+use syntax::{algo::find_node_at_offset, ast, AstNode};\n+\n+// Feature: Interpret Function\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **rust-analyzer: Interpret Function**\n+// |===\n+pub(crate) fn interpret_function(db: &RootDatabase, position: FilePosition) -> String {\n+    let start_time = Instant::now();\n+    let mut result = find_and_interpret(db, position)\n+        .unwrap_or_else(|| \"Not inside a function body\".to_string());\n+    let duration = Instant::now() - start_time;\n+    writeln!(result, \"\").unwrap();\n+    writeln!(result, \"----------------------\").unwrap();\n+    writeln!(result, \"  Finished in {}s\", duration.as_secs_f32()).unwrap();\n+    result\n+}\n+\n+fn find_and_interpret(db: &RootDatabase, position: FilePosition) -> Option<String> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+\n+    let item = find_node_at_offset::<ast::Item>(source_file.syntax(), position.offset)?;\n+    let def = match item {\n+        ast::Item::Fn(it) => sema.to_def(&it)?,\n+        _ => return None,\n+    };\n+    let span_formatter = |file_id, text_range: TextRange| {\n+        let line_col = db.line_index(file_id).line_col(text_range.start());\n+        let path = &db\n+            .source_root(db.file_source_root(file_id))\n+            .path_for_file(&file_id)\n+            .map(|x| x.to_string());\n+        let path = path.as_deref().unwrap_or(\"<unknown file>\");\n+        format!(\"file://{path}#{}:{}\", line_col.line + 1, line_col.col)\n+    };\n+    match def.eval(db, span_formatter) {\n+        Ok(_) => Some(\"pass\".to_string()),\n+        Err(e) => Some(e),\n+    }\n+}"}, {"sha": "3509dee0c96ec6b8f1b4901588634f9e715df1aa", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -56,6 +56,7 @@ mod typing;\n mod view_crate_graph;\n mod view_hir;\n mod view_mir;\n+mod interpret_function;\n mod view_item_tree;\n mod shuffle_crate_graph;\n \n@@ -317,6 +318,10 @@ impl Analysis {\n         self.with_db(|db| view_mir::view_mir(db, position))\n     }\n \n+    pub fn interpret_function(&self, position: FilePosition) -> Cancellable<String> {\n+        self.with_db(|db| interpret_function::interpret_function(db, position))\n+    }\n+\n     pub fn view_item_tree(&self, file_id: FileId) -> Cancellable<String> {\n         self.with_db(|db| view_item_tree::view_item_tree(db, file_id))\n     }"}, {"sha": "7ce20e973bb22ad6e674e6b979882c3b3e83d6cf", "filename": "crates/ide/src/static_index.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatic_index.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -140,7 +140,6 @@ impl StaticIndex<'_> {\n             documentation: true,\n             keywords: true,\n             format: crate::HoverDocFormat::Markdown,\n-            interpret_tests: false,\n         };\n         let tokens = tokens.filter(|token| {\n             matches!("}, {"sha": "f9288f01b53406286663aa50aff8bf7bd104717a", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -574,6 +574,7 @@ pub struct LensConfig {\n     // runnables\n     pub run: bool,\n     pub debug: bool,\n+    pub interpret: bool,\n \n     // implementations\n     pub implementations: bool,\n@@ -1423,6 +1424,9 @@ impl Config {\n         LensConfig {\n             run: self.data.lens_enable && self.data.lens_run_enable,\n             debug: self.data.lens_enable && self.data.lens_debug_enable,\n+            interpret: self.data.lens_enable\n+                && self.data.lens_run_enable\n+                && self.data.interpret_tests,\n             implementations: self.data.lens_enable && self.data.lens_implementations_enable,\n             method_refs: self.data.lens_enable && self.data.lens_references_method_enable,\n             refs_adt: self.data.lens_enable && self.data.lens_references_adt_enable,\n@@ -1481,7 +1485,6 @@ impl Config {\n                 }\n             },\n             keywords: self.data.hover_documentation_keywords_enable,\n-            interpret_tests: self.data.interpret_tests,\n         }\n     }\n "}, {"sha": "a5b9004d80fe198b42017ac9fef1c19d1ffe9af8", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -163,6 +163,16 @@ pub(crate) fn handle_view_mir(\n     Ok(res)\n }\n \n+pub(crate) fn handle_interpret_function(\n+    snap: GlobalStateSnapshot,\n+    params: lsp_types::TextDocumentPositionParams,\n+) -> Result<String> {\n+    let _p = profile::span(\"handle_interpret_function\");\n+    let position = from_proto::file_position(&snap, params)?;\n+    let res = snap.analysis.interpret_function(position)?;\n+    Ok(res)\n+}\n+\n pub(crate) fn handle_view_file_text(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::TextDocumentIdentifier,"}, {"sha": "90c9b16ec2b5e4d972df9d45ab06ae458a0247a0", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -90,6 +90,14 @@ impl Request for ViewMir {\n     const METHOD: &'static str = \"rust-analyzer/viewMir\";\n }\n \n+pub enum InterpretFunction {}\n+\n+impl Request for InterpretFunction {\n+    type Params = lsp_types::TextDocumentPositionParams;\n+    type Result = String;\n+    const METHOD: &'static str = \"rust-analyzer/interpretFunction\";\n+}\n+\n pub enum ViewFileText {}\n \n impl Request for ViewFileText {"}, {"sha": "6f31c641222387178b5629ca27535d33a338242d", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -665,6 +665,7 @@ impl GlobalState {\n             .on::<lsp_ext::SyntaxTree>(handlers::handle_syntax_tree)\n             .on::<lsp_ext::ViewHir>(handlers::handle_view_hir)\n             .on::<lsp_ext::ViewMir>(handlers::handle_view_mir)\n+            .on::<lsp_ext::InterpretFunction>(handlers::handle_interpret_function)\n             .on::<lsp_ext::ViewFileText>(handlers::handle_view_file_text)\n             .on::<lsp_ext::ViewCrateGraph>(handlers::handle_view_crate_graph)\n             .on::<lsp_ext::ViewItemTree>(handlers::handle_view_item_tree)"}, {"sha": "521db6b0ca9c9fc45046d27ccf165ff008f09229", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1215,6 +1215,14 @@ pub(crate) fn code_lens(\n                     data: None,\n                 })\n             }\n+            if lens_config.interpret {\n+                let command = command::interpret_single(&r);\n+                acc.push(lsp_types::CodeLens {\n+                    range: annotation_range,\n+                    command: Some(command),\n+                    data: None,\n+                })\n+            }\n         }\n         AnnotationKind::HasImpls { pos: file_range, data } => {\n             if !client_commands_config.show_reference {\n@@ -1359,6 +1367,15 @@ pub(crate) mod command {\n         }\n     }\n \n+    pub(crate) fn interpret_single(_runnable: &lsp_ext::Runnable) -> lsp_types::Command {\n+        lsp_types::Command {\n+            title: \"Interpret\".into(),\n+            command: \"rust-analyzer.interpretFunction\".into(),\n+            // FIXME: use the `_runnable` here.\n+            arguments: Some(vec![]),\n+        }\n+    }\n+\n     pub(crate) fn goto_location(\n         snap: &GlobalStateSnapshot,\n         nav: &NavigationTarget,"}, {"sha": "f403ef8ee03b6825f1fd3ecdb90320d87ad1732f", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -11,6 +11,7 @@\n //!     add:\n //!     as_ref: sized\n //!     bool_impl: option, fn\n+//!     cell: copy, drop\n //!     clone: sized\n //!     coerce_unsized: unsize\n //!     copy: clone\n@@ -139,6 +140,52 @@ pub mod hash {\n }\n // endregion:hash\n \n+// region:cell\n+pub mod cell {\n+    use crate::mem;\n+\n+    #[lang = \"unsafe_cell\"]\n+    pub struct UnsafeCell<T: ?Sized> {\n+        value: T,\n+    }\n+\n+    impl<T> UnsafeCell<T> {\n+        pub const fn new(value: T) -> UnsafeCell<T> {\n+            UnsafeCell { value }\n+        }\n+\n+        pub const fn get(&self) -> *mut T {\n+            self as *const UnsafeCell<T> as *const T as *mut T\n+        }\n+    }\n+\n+    pub struct Cell<T: ?Sized> {\n+        value: UnsafeCell<T>,\n+    }\n+\n+    impl<T> Cell<T> {\n+        pub const fn new(value: T) -> Cell<T> {\n+            Cell { value: UnsafeCell::new(value) }\n+        }\n+\n+        pub fn set(&self, val: T) {\n+            let old = self.replace(val);\n+            mem::drop(old);\n+        }\n+\n+        pub fn replace(&self, val: T) -> T {\n+            mem::replace(unsafe { &mut *self.value.get() }, val)\n+        }\n+    }\n+\n+    impl<T: Copy> Cell<T> {\n+        pub fn get(&self) -> T {\n+            unsafe { *self.value.get() }\n+        }\n+    }\n+}\n+// endregion:cell\n+\n // region:clone\n pub mod clone {\n     #[lang = \"clone\"]\n@@ -220,6 +267,13 @@ pub mod mem {\n     // endregion:manually_drop\n \n     pub fn drop<T>(_x: T) {}\n+    pub const fn replace<T>(dest: &mut T, src: T) -> T {\n+        unsafe {\n+            let result = *dest;\n+            *dest = src;\n+            result\n+        }\n+    }\n }\n // endregion:drop\n \n@@ -710,6 +764,14 @@ pub mod option {\n                 None => default,\n             }\n         }\n+        // region:result\n+        pub const fn ok_or<E>(self, err: E) -> Result<T, E> {\n+            match self {\n+                Some(v) => Ok(v),\n+                None => Err(err),\n+            }\n+        }\n+        // endregion:result\n         // region:fn\n         pub fn and_then<U, F>(self, f: F) -> Option<U>\n         where"}, {"sha": "76080eca4e03d2f1ac2960cc2c556b6e1dbad63a", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: be2f663a78beb7bd\n+lsp_ext.rs hash: 37ac44a0f507e05a\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -548,6 +548,18 @@ For debugging or when working on rust-analyzer itself.\n Returns a textual representation of the MIR of the function containing the cursor.\n For debugging or when working on rust-analyzer itself.\n \n+## Interpret Function\n+\n+**Method:** `rust-analyzer/interpretFunction`\n+\n+**Request:** `TextDocumentPositionParams`\n+\n+**Response:** `string`\n+\n+Tries to evaluate the function using internal rust analyzer knowledge, without compiling\n+the code. Currently evaluates the function under cursor, but will give a runnable in\n+future. Highly experimental.\n+\n ## View File Text\n \n **Method:** `rust-analyzer/viewFileText`"}, {"sha": "d46c248cd49f19ef3427820d102a78283f95310d", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -120,6 +120,11 @@\n                 \"title\": \"View Mir\",\n                 \"category\": \"rust-analyzer (debug command)\"\n             },\n+            {\n+                \"command\": \"rust-analyzer.interpretFunction\",\n+                \"title\": \"Interpret Function\",\n+                \"category\": \"rust-analyzer (debug command)\"\n+            },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\","}, {"sha": "2d5272d199d8d2bbac2ebf4fb0e0849b075f0cf9", "filename": "editors/code/src/commands.ts", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands.ts?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -422,8 +422,20 @@ export function syntaxTree(ctx: CtxInit): Cmd {\n function viewHirOrMir(ctx: CtxInit, xir: \"hir\" | \"mir\"): Cmd {\n     const viewXir = xir === \"hir\" ? \"viewHir\" : \"viewMir\";\n     const requestType = xir === \"hir\" ? ra.viewHir : ra.viewMir;\n+    const uri = `rust-analyzer-${xir}://${viewXir}/${xir}.rs`;\n+    const scheme = `rust-analyzer-${xir}`;\n+    return viewFileUsingTextDocumentContentProvider(ctx, requestType, uri, scheme, true);\n+}\n+\n+function viewFileUsingTextDocumentContentProvider(\n+    ctx: CtxInit,\n+    requestType: lc.RequestType<lc.TextDocumentPositionParams, string, void>,\n+    uri: string,\n+    scheme: string,\n+    shouldUpdate: boolean\n+): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n-        readonly uri = vscode.Uri.parse(`rust-analyzer-${xir}://${viewXir}/${xir}.rs`);\n+        readonly uri = vscode.Uri.parse(uri);\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n         constructor() {\n             vscode.workspace.onDidChangeTextDocument(\n@@ -439,14 +451,14 @@ function viewHirOrMir(ctx: CtxInit, xir: \"hir\" | \"mir\"): Cmd {\n         }\n \n         private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n-            if (isRustDocument(event.document)) {\n+            if (isRustDocument(event.document) && shouldUpdate) {\n                 // We need to order this after language server updates, but there's no API for that.\n                 // Hence, good old sleep().\n                 void sleep(10).then(() => this.eventEmitter.fire(this.uri));\n             }\n         }\n         private onDidChangeActiveTextEditor(editor: vscode.TextEditor | undefined) {\n-            if (editor && isRustEditor(editor)) {\n+            if (editor && isRustEditor(editor) && shouldUpdate) {\n                 this.eventEmitter.fire(this.uri);\n             }\n         }\n@@ -473,9 +485,7 @@ function viewHirOrMir(ctx: CtxInit, xir: \"hir\" | \"mir\"): Cmd {\n         }\n     })();\n \n-    ctx.pushExtCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(`rust-analyzer-${xir}`, tdcp)\n-    );\n+    ctx.pushExtCleanup(vscode.workspace.registerTextDocumentContentProvider(scheme, tdcp));\n \n     return async () => {\n         const document = await vscode.workspace.openTextDocument(tdcp.uri);\n@@ -501,6 +511,20 @@ export function viewMir(ctx: CtxInit): Cmd {\n     return viewHirOrMir(ctx, \"mir\");\n }\n \n+// Opens the virtual file that will show the MIR of the function containing the cursor position\n+//\n+// The contents of the file come from the `TextDocumentContentProvider`\n+export function interpretFunction(ctx: CtxInit): Cmd {\n+    const uri = `rust-analyzer-interpret-function://interpretFunction/result.log`;\n+    return viewFileUsingTextDocumentContentProvider(\n+        ctx,\n+        ra.interpretFunction,\n+        uri,\n+        `rust-analyzer-interpret-function`,\n+        false\n+    );\n+}\n+\n export function viewFileText(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-file-text://viewFileText/file.rs\");"}, {"sha": "754d43618a4d795dd2ab82028dbe2484801f6c9a", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -64,6 +64,9 @@ export const viewHir = new lc.RequestType<lc.TextDocumentPositionParams, string,\n export const viewMir = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n     \"rust-analyzer/viewMir\"\n );\n+export const interpretFunction = new lc.RequestType<lc.TextDocumentPositionParams, string, void>(\n+    \"rust-analyzer/interpretFunction\"\n+);\n export const viewItemTree = new lc.RequestType<ViewItemTreeParams, string, void>(\n     \"rust-analyzer/viewItemTree\"\n );"}, {"sha": "7ae8fa8ca28507b98f62f9f95906a6588ce6e356", "filename": "editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6312fbf521e42e5a5ff193ceee6a8c7735be3a45/editors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fmain.ts?ref=6312fbf521e42e5a5ff193ceee6a8c7735be3a45", "patch": "@@ -159,6 +159,7 @@ function createCommands(): Record<string, CommandFactory> {\n         syntaxTree: { enabled: commands.syntaxTree },\n         viewHir: { enabled: commands.viewHir },\n         viewMir: { enabled: commands.viewMir },\n+        interpretFunction: { enabled: commands.interpretFunction },\n         viewFileText: { enabled: commands.viewFileText },\n         viewItemTree: { enabled: commands.viewItemTree },\n         viewCrateGraph: { enabled: commands.viewCrateGraph },"}]}