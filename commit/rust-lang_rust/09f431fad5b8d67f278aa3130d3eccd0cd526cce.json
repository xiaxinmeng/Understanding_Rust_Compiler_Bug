{"sha": "09f431fad5b8d67f278aa3130d3eccd0cd526cce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjQzMWZhZDViOGQ2N2YyNzhhYTMxMzBkM2VjY2QwY2Q1MjZjY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-03T09:29:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-03T22:10:08Z"}, "message": "simplify and cleanup error-reporting walk code", "tree": {"sha": "3b110e957589440446f8ed3a5c0d58caad27ecbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b110e957589440446f8ed3a5c0d58caad27ecbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f431fad5b8d67f278aa3130d3eccd0cd526cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f431fad5b8d67f278aa3130d3eccd0cd526cce", "html_url": "https://github.com/rust-lang/rust/commit/09f431fad5b8d67f278aa3130d3eccd0cd526cce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f431fad5b8d67f278aa3130d3eccd0cd526cce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "html_url": "https://github.com/rust-lang/rust/commit/ea0224f5ab5e0fce6f83ae395c30058dcd434be7"}], "stats": {"total": 216, "additions": 95, "deletions": 121}, "files": [{"sha": "d8258afc24f621f4753172df267bb6e9d4c0d996", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "modified", "additions": 95, "deletions": 121, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/09f431fad5b8d67f278aa3130d3eccd0cd526cce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f431fad5b8d67f278aa3130d3eccd0cd526cce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=09f431fad5b8d67f278aa3130d3eccd0cd526cce", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt;\n use syntax_pos::Span;\n@@ -48,140 +48,107 @@ impl fmt::Display for ConstraintCategory {\n }\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n-    /// When reporting an error, it is useful to be able to determine which constraints influenced\n-    /// the region being reported as an error. This function finds all of the paths from the\n+    /// Walks the graph of constraints (where `'a: 'b` is considered\n+    /// an edge `'b -> 'a`) to find all paths from `from_region` to\n+    /// `to_region`. The paths are accumulated into the vector\n+    /// `results`. The paths are stored as a series of\n+    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `from_region`\n+    /// When reporting an error, it is useful to be able to determine\n+    /// which constraints influenced the region being reported as an\n+    /// error. This function finds all of the paths from the\n     /// constraint.\n-    fn find_constraint_paths_from_region(&self, r0: RegionVid) -> Vec<Vec<ConstraintIndex>> {\n-        let constraints = self.constraints.clone();\n-\n-        // Mapping of regions to the previous region and constraint index that led to it.\n-        let mut previous = FxHashMap();\n-        // Regions yet to be visited.\n-        let mut next = vec![r0];\n-        // Regions that have been visited.\n-        let mut visited = FxHashSet();\n-        // Ends of paths.\n-        let mut end_regions = FxHashSet();\n-\n-        // When we've still got points to visit...\n-        while let Some(current) = next.pop() {\n-            // ...take the next point...\n-            debug!(\n-                \"find_constraint_paths_from_region: current={:?} visited={:?} next={:?}\",\n-                current, visited, next\n-            );\n-            // ...but make sure not to visit this point again...\n-            visited.insert(current);\n-\n-            // ...find the edges containing it...\n-            let mut upcoming = Vec::new();\n-            for (index, constraint) in constraints.iter_enumerated() {\n-                if constraint.sub == current {\n-                    // ...add the regions that join us with to the path we've taken...\n-                    debug!(\n-                        \"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n-                        index, constraint\n-                    );\n-                    let next_region = constraint.sup.clone();\n-\n-                    // ...unless we've visited it since this was added...\n-                    if visited.contains(&next_region) {\n-                        debug!(\"find_constraint_paths_from_region: skipping as visited\");\n-                        continue;\n-                    }\n+    fn find_constraint_paths_between_regions(\n+        &self,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+    ) -> Vec<Vec<ConstraintIndex>> {\n+        let mut results = vec![];\n+        self.find_constraint_paths_between_regions_helper(\n+            from_region,\n+            from_region,\n+            to_region,\n+            &mut FxHashSet::default(),\n+            &mut vec![],\n+            &mut results,\n+        );\n+        results\n+    }\n \n-                    previous.insert(next_region, (index, Some(current)));\n-                    upcoming.push(next_region);\n-                }\n-            }\n+    /// Helper for `find_constraint_paths_between_regions`.\n+    fn find_constraint_paths_between_regions_helper(\n+        &self,\n+        from_region: RegionVid,\n+        current_region: RegionVid,\n+        to_region: RegionVid,\n+        visited: &mut FxHashSet<RegionVid>,\n+        stack: &mut Vec<ConstraintIndex>,\n+        results: &mut Vec<Vec<ConstraintIndex>>,\n+    ) {\n+        let dependency_map = self.dependency_map.as_ref().unwrap();\n \n-            if upcoming.is_empty() {\n-                // If we didn't find any edges then this is the end of a path...\n-                debug!(\n-                    \"find_constraint_paths_from_region: new end region current={:?}\",\n-                    current\n-                );\n-                end_regions.insert(current);\n-            } else {\n-                // ...but, if we did find edges, then add these to the regions yet to visit.\n-                debug!(\n-                    \"find_constraint_paths_from_region: extend next upcoming={:?}\",\n-                    upcoming\n-                );\n-                next.extend(upcoming);\n-            }\n+        // Check if we already visited this region.\n+        if !visited.insert(current_region) {\n+            return;\n         }\n \n-        // Now we've visited each point, compute the final paths.\n-        let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n-        debug!(\n-            \"find_constraint_paths_from_region: end_regions={:?}\",\n-            end_regions\n-        );\n-        for end_region in end_regions {\n-            debug!(\n-                \"find_constraint_paths_from_region: end_region={:?}\",\n-                end_region\n-            );\n+        // Check if we reached the region we were looking for.\n+        if current_region == to_region {\n+            // Unless we started out searching for `'a ~> 'a`, which shouldn't have caused\n+            // en error, then we must have traversed at least *some* constraint:\n+            assert!(!stack.is_empty());\n \n-            // Get the constraint and region that led to this end point.\n-            // We can unwrap as we know if end_point was in the vector that it\n-            // must also be in our previous map.\n-            let (mut index, mut region) = previous.get(&end_region).unwrap();\n-            debug!(\n-                \"find_constraint_paths_from_region: index={:?} region={:?}\",\n-                index, region\n-            );\n-\n-            // Keep track of the indices.\n-            let mut path: Vec<ConstraintIndex> = vec![index];\n-\n-            while region.is_some() && region != Some(r0) {\n-                let p = previous.get(&region.unwrap()).unwrap();\n-                index = p.0;\n-                region = p.1;\n+            // The first constraint should be like `X: from_region`.\n+            assert_eq!(self.constraints[stack[0]].sub, from_region);\n \n-                debug!(\n-                    \"find_constraint_paths_from_region: index={:?} region={:?}\",\n-                    index, region\n-                );\n-                path.push(index);\n-            }\n+            // The last constraint should be like `to_region: Y`.\n+            assert_eq!(self.constraints[*stack.last().unwrap()].sup, to_region);\n \n-            // Add to our paths.\n-            paths.push(path);\n+            results.push(stack.clone());\n+            return;\n         }\n \n-        debug!(\"find_constraint_paths_from_region: paths={:?}\", paths);\n-        paths\n+        self.constraints\n+            .each_affected_by_dirty(dependency_map[current_region], |constraint| {\n+                assert_eq!(self.constraints[constraint].sub, current_region);\n+                stack.push(constraint);\n+                self.find_constraint_paths_between_regions_helper(\n+                    from_region,\n+                    self.constraints[constraint].sup,\n+                    to_region,\n+                    visited,\n+                    stack,\n+                    results,\n+                );\n+                stack.pop();\n+            });\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n     /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n-        self.constraints\n-            .get(*index)\n-            .filter(|constraint| {\n-                debug!(\n-                    \"constraint_is_interesting: locations={:?} constraint={:?}\",\n-                    constraint.locations, constraint\n-                );\n-                if let Locations::Interesting(_) = constraint.locations {\n-                    true\n-                } else {\n-                    false\n-                }\n-            })\n-            .is_some()\n+    fn constraint_is_interesting(&self, index: ConstraintIndex) -> bool {\n+        let constraint = self.constraints[index];\n+        debug!(\n+            \"constraint_is_interesting: locations={:?} constraint={:?}\",\n+            constraint.locations, constraint\n+        );\n+        if let Locations::Interesting(_) = constraint.locations {\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// This function classifies a constraint from a location.\n     fn classify_constraint(\n         &self,\n-        index: &ConstraintIndex,\n+        index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n     ) -> Option<(ConstraintCategory, Span)> {\n-        let constraint = self.constraints.get(*index)?;\n+        let constraint = self.constraints[index];\n         let span = constraint.locations.span(mir);\n         let location = constraint.locations.from_location()?;\n \n@@ -238,7 +205,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlived_fr: RegionVid,\n         blame_span: Span,\n     ) {\n-        // Obviously uncool error reporting.\n+        debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n         let fr_name = self.to_error_region(fr);\n         let outlived_fr_name = self.to_error_region(outlived_fr);\n@@ -261,19 +228,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None => format!(\"free region `{:?}`\", outlived_fr),\n         };\n \n-        let constraints = self.find_constraint_paths_from_region(fr.clone());\n-        let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n+        // Find all paths\n+        let constraint_paths = self.find_constraint_paths_between_regions(outlived_fr, fr);\n+        debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n+\n+        // Find the shortest such path.\n+        let path = constraint_paths.iter().min_by_key(|p| p.len()).unwrap();\n         debug!(\"report_error: shortest_path={:?}\", path);\n \n-        let mut categorized_path = path.iter()\n-            .filter_map(|index| self.classify_constraint(index, mir))\n-            .collect::<Vec<(ConstraintCategory, Span)>>();\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n+            .filter_map(|&index| self.classify_constraint(index, mir))\n+            .collect();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n+        // Find what appears to be the most interesting path to report to the user.\n         categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n         debug!(\"report_error: sorted_path={:?}\", categorized_path);\n \n-        if let Some((category, span)) = &categorized_path.first() {\n+        // If we found something, cite that as the main cause of the problem.\n+        if let Some((category, span)) = categorized_path.first() {\n             let mut diag = infcx.tcx.sess.struct_span_err(\n                 *span,\n                 &format!("}]}