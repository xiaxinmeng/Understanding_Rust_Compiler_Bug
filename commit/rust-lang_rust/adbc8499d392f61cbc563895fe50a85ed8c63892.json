{"sha": "adbc8499d392f61cbc563895fe50a85ed8c63892", "node_id": "C_kwDOAAsO6NoAKGFkYmM4NDk5ZDM5MmY2MWNiYzU2Mzg5NWZlNTBhODVlZDhjNjM4OTI", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-08T17:21:04Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-29T17:43:05Z"}, "message": "Don't lint `while_let_loop` when drop order would change", "tree": {"sha": "cd96a13da066843018242b6694018a7a91495209", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd96a13da066843018242b6694018a7a91495209"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adbc8499d392f61cbc563895fe50a85ed8c63892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adbc8499d392f61cbc563895fe50a85ed8c63892", "html_url": "https://github.com/rust-lang/rust/commit/adbc8499d392f61cbc563895fe50a85ed8c63892", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adbc8499d392f61cbc563895fe50a85ed8c63892/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58434ae38514222ba03f99183391e56323970243", "url": "https://api.github.com/repos/rust-lang/rust/commits/58434ae38514222ba03f99183391e56323970243", "html_url": "https://github.com/rust-lang/rust/commit/58434ae38514222ba03f99183391e56323970243"}], "stats": {"total": 132, "additions": 76, "deletions": 56}, "files": [{"sha": "45af6be2653f3d4478fb026d65392fc191cccf1a", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/adbc8499d392f61cbc563895fe50a85ed8c63892/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbc8499d392f61cbc563895fe50a85ed8c63892/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=adbc8499d392f61cbc563895fe50a85ed8c63892", "patch": "@@ -2,71 +2,60 @@ use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n-use rustc_lint::{LateContext, LintContext};\n-use rustc_middle::lint::in_external_macro;\n+use rustc_hir::{Block, Expr, ExprKind, Local, MatchSource, Pat, StmtKind};\n+use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n-    // extract the expression from the first statement (if any) in a block\n-    let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n-    // or extract the first expression (if any) from the block\n-    if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let Some(higher::IfLet {\n-            let_pat,\n-            let_expr,\n-            if_else: Some(if_else),\n-            ..\n-        }) = higher::IfLet::hir(cx, inner)\n-        {\n-            if is_simple_break_expr(if_else) {\n-                could_be_while_let(cx, expr, let_pat, let_expr);\n+    let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n+        ([stmt, stmts @ ..], expr) => {\n+            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+                (e, !stmts.is_empty() || expr.is_some())\n+            } else {\n+                return;\n             }\n-        }\n-\n-        if let ExprKind::Match(matchexpr, arms, MatchSource::Normal) = inner.kind {\n-            if arms.len() == 2\n-                && arms[0].guard.is_none()\n-                && arms[1].guard.is_none()\n-                && is_simple_break_expr(arms[1].body)\n-            {\n-                could_be_while_let(cx, expr, arms[0].pat, matchexpr);\n-            }\n-        }\n-    }\n-}\n+        },\n+        ([], Some(e)) => (e, false),\n+        _ => return,\n+    };\n \n-/// If a block begins with a statement (possibly a `let` binding) and has an\n-/// expression, return it.\n-fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if let Some(first_stmt) = block.stmts.get(0) {\n-        if let StmtKind::Local(local) = first_stmt.kind {\n-            return local.init;\n-        }\n+    if let Some(if_let) = higher::IfLet::hir(cx, init)\n+        && let Some(else_expr) = if_let.if_else\n+        && is_simple_break_expr(else_expr)\n+    {\n+        could_be_while_let(cx, expr, if_let.let_pat, if_let.let_expr, has_trailing_exprs);\n+    } else if let ExprKind::Match(scrutinee, [arm1, arm2], MatchSource::Normal) = init.kind\n+        && arm1.guard.is_none()\n+        && arm2.guard.is_none()\n+        && is_simple_break_expr(arm2.body)\n+    {\n+        could_be_while_let(cx, expr, arm1.pat, scrutinee, has_trailing_exprs);\n     }\n-    None\n }\n \n-/// If a block begins with an expression (with or without semicolon), return it.\n-fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    match block.expr {\n-        Some(expr) if block.stmts.is_empty() => Some(expr),\n-        None if !block.stmts.is_empty() => match block.stmts[0].kind {\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n-            StmtKind::Local(..) | StmtKind::Item(..) => None,\n-        },\n-        _ => None,\n-    }\n+/// Returns `true` if expr contains a single break expression without a label or eub-expression.\n+fn is_simple_break_expr(e: &Expr<'_>) -> bool {\n+    matches!(peel_blocks(e).kind, ExprKind::Break(dest, None) if dest.label.is_none())\n }\n \n-/// Returns `true` if expr contains a single break expr without destination label\n-/// and\n-/// passed expression. The expression may be within a block.\n-fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n-        ExprKind::Block(b, _) => extract_first_expr(b).map_or(false, is_simple_break_expr),\n-        _ => false,\n+/// Removes any blocks containing only a single expression.\n+fn peel_blocks<'tcx>(e: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n+    if let ExprKind::Block(b, _) = e.kind {\n+        match (b.stmts, b.expr) {\n+            ([s], None) => {\n+                if let StmtKind::Expr(e) | StmtKind::Semi(e) = s.kind {\n+                    peel_blocks(e)\n+                } else {\n+                    e\n+                }\n+            },\n+            ([], Some(e)) => peel_blocks(e),\n+            _ => e,\n+        }\n+    } else {\n+        e\n     }\n }\n \n@@ -75,8 +64,13 @@ fn could_be_while_let<'tcx>(\n     expr: &'tcx Expr<'_>,\n     let_pat: &'tcx Pat<'_>,\n     let_expr: &'tcx Expr<'_>,\n+    has_trailing_exprs: bool,\n ) {\n-    if in_external_macro(cx.sess(), expr.span) {\n+    if has_trailing_exprs\n+        && (needs_ordered_drop(cx, cx.typeck_results().expr_ty(let_expr))\n+            || any_temporaries_need_ordered_drop(cx, let_expr))\n+    {\n+        // Switching to a `while let` loop will extend the lifetime of some values.\n         return;\n     }\n "}, {"sha": "c42e2a79a9bf9048dd19ea4942348a1df7695543", "filename": "tests/ui/while_let_loop.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/adbc8499d392f61cbc563895fe50a85ed8c63892/tests%2Fui%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adbc8499d392f61cbc563895fe50a85ed8c63892/tests%2Fui%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_loop.rs?ref=adbc8499d392f61cbc563895fe50a85ed8c63892", "patch": "@@ -117,3 +117,29 @@ fn issue1948() {\n         }\n     };\n }\n+\n+fn issue_7913(m: &std::sync::Mutex<Vec<u32>>) {\n+    // Don't lint. The lock shouldn't be held while printing.\n+    loop {\n+        let x = if let Some(x) = m.lock().unwrap().pop() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn issue_5715(mut m: core::cell::RefCell<Option<u32>>) {\n+    // Don't lint. The temporary from `borrow_mut` must be dropped before overwriting the `RefCell`.\n+    loop {\n+        let x = if let &mut Some(x) = &mut *m.borrow_mut() {\n+            x\n+        } else {\n+            break;\n+        };\n+\n+        m = core::cell::RefCell::new(Some(x + 1));\n+    }\n+}"}]}