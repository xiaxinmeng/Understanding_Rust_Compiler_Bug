{"sha": "d9db7f6137122c1cf174518cc402e04d54c3c8c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZGI3ZjYxMzcxMjJjMWNmMTc0NTE4Y2M0MDJlMDRkNTRjM2M4YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-07T03:01:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-07T03:01:34Z"}, "message": "auto merge of #15464 : dotdash/rust/bool_stores, r=pcwalton\n\nLLVM doesn't handle i1 value in allocas/memory very well and skips a number of optimizations if it hits it. So we have to do the same thing that Clang does, using i1 for SSA values, but storing i8 in memory.\r\n\r\nFixes #15203.", "tree": {"sha": "e4dc42deecaff6db93ecfaf8ded10932401328c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4dc42deecaff6db93ecfaf8ded10932401328c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9db7f6137122c1cf174518cc402e04d54c3c8c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9db7f6137122c1cf174518cc402e04d54c3c8c3", "html_url": "https://github.com/rust-lang/rust/commit/d9db7f6137122c1cf174518cc402e04d54c3c8c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9db7f6137122c1cf174518cc402e04d54c3c8c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ef888bb798f2ebd8773d3b95b098ba18f0dbd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ef888bb798f2ebd8773d3b95b098ba18f0dbd6", "html_url": "https://github.com/rust-lang/rust/commit/21ef888bb798f2ebd8773d3b95b098ba18f0dbd6"}, {"sha": "dd4112bf7924767a6074b54ffe297c877f8b042d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd4112bf7924767a6074b54ffe297c877f8b042d", "html_url": "https://github.com/rust-lang/rust/commit/dd4112bf7924767a6074b54ffe297c877f8b042d"}], "stats": {"total": 211, "additions": 126, "deletions": 85}, "files": [{"sha": "f7fb6646938fdd706b38ead1ec2f9f9cac7b5fb4", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -618,7 +618,7 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n             assert!(discr == 0 || discr == 1);\n-            _match::single_result(Result::new(bcx, C_i1(bcx.ccx(), discr != 0)))\n+            _match::single_result(Result::new(bcx, C_bool(bcx.ccx(), discr != 0)))\n         }\n     }\n }\n@@ -641,7 +641,7 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n-            Store(bcx, C_bool(bcx.ccx(), true),\n+            Store(bcx, C_u8(bcx.ccx(), 1),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(..) => {"}, {"sha": "08cdde38c34601fe2dc94b9066eddfb1bad478c0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -538,8 +538,8 @@ pub fn compare_scalar_values<'a>(\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(cx.ccx(), true),\n-          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(cx.ccx(), false),\n+          ast::BiEq | ast::BiLe | ast::BiGe => return C_bool(cx.ccx(), true),\n+          ast::BiNe | ast::BiLt | ast::BiGt => return C_bool(cx.ccx(), false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -958,10 +958,42 @@ pub fn need_invoke(bcx: &Block) -> bool {\n \n pub fn load_if_immediate(cx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if type_is_immediate(cx.ccx(), t) { return Load(cx, v); }\n+    if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n+pub fn load_ty(cx: &Block, ptr: ValueRef, t: ty::t) -> ValueRef {\n+    /*!\n+     * Helper for loading values from memory. Does the necessary conversion if\n+     * the in-memory type differs from the type used for SSA values. Also\n+     * handles various special cases where the type gives us better information\n+     * about what we are loading.\n+     */\n+    if type_is_zero_size(cx.ccx(), t) {\n+        C_undef(type_of::type_of(cx.ccx(), t))\n+    } else if ty::type_is_bool(t) {\n+        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, lib::llvm::False), Type::i1(cx.ccx()))\n+    } else if ty::type_is_char(t) {\n+        // a char is a unicode codepoint, and so takes values from 0\n+        // to 0x10FFFF inclusive only.\n+        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, lib::llvm::False)\n+    } else {\n+        Load(cx, ptr)\n+    }\n+}\n+\n+pub fn store_ty(cx: &Block, v: ValueRef, dst: ValueRef, t: ty::t) {\n+    /*!\n+     * Helper for storing values in memory. Does the necessary conversion if\n+     * the in-memory type differs from the type used for SSA values.\n+     */\n+    if ty::type_is_bool(t) {\n+        Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n+    } else {\n+        Store(cx, v, dst);\n+    };\n+}\n+\n pub fn ignore_lhs(_bcx: &Block, local: &ast::Local) -> bool {\n     match local.pat.node {\n         ast::PatWild => true, _ => false\n@@ -1013,7 +1045,7 @@ pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef,\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(ccx, align as i32);\n-    let volatile = C_i1(ccx, false);\n+    let volatile = C_bool(ccx, false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n@@ -1058,7 +1090,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let llzeroval = C_u8(ccx, 0);\n     let size = machine::llsize_of(ccx, ty);\n     let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n-    let volatile = C_i1(ccx, false);\n+    let volatile = C_bool(ccx, false);\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n@@ -1282,9 +1314,14 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n-                     last_bcx: &'a Block<'a>) {\n+                     last_bcx: &'a Block<'a>,\n+                     retty: ty::t) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n+    // This shouldn't need to recompute the return type,\n+    // as new_fn_ctxt did it already.\n+    let substd_retty = retty.substp(fcx.ccx.tcx(), fcx.param_substs);\n+\n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n@@ -1294,13 +1331,13 @@ pub fn finish_fn<'a>(fcx: &'a FunctionContext<'a>,\n         }\n         None => last_bcx\n     };\n-    build_return_block(fcx, ret_cx);\n+    build_return_block(fcx, ret_cx, substd_retty);\n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n+pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block, retty: ty::t) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.get().is_none() || fcx.caller_expects_out_pointer {\n         return RetVoid(ret_cx);\n@@ -1318,13 +1355,16 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n                 retptr.erase_from_parent();\n             }\n \n-            retval\n+            if ty::type_is_bool(retty) {\n+                Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n+            } else {\n+                retval\n+            }\n         }\n         // Otherwise, load the return value from the ret slot\n-        None => Load(ret_cx, fcx.llretptr.get().unwrap())\n+        None => load_ty(ret_cx, fcx.llretptr.get().unwrap(), retty)\n     };\n \n-\n     Ret(ret_cx, retval);\n }\n \n@@ -1422,7 +1462,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, output_type);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -1512,7 +1552,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n         }\n     }\n \n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, result_ty);\n }\n \n fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,"}, {"sha": "c44a4e02ad462a5be8ef51d67934634776880a49", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -85,7 +85,7 @@ fn ty_size(ty: Type) -> uint {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty);\n@@ -104,7 +104,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = ty_align(ty);"}, {"sha": "9e5b38d2f7ddb4b468505c78b676bc73d5e9bb67", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -85,7 +85,7 @@ fn ty_size(ty: Type) -> uint {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::indirect(ty, Some(StructRetAttribute))\n@@ -102,7 +102,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "0d88c611cbaede78a0a996f6eee4d6f34bc78573", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -59,7 +59,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             }\n         }\n     } else {\n-        let attr = if rty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -74,7 +74,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "5b8ddfe1be7bf707d09dcdd1e9736cc53d40bc57", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -350,7 +350,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::bool(ccx) { Some(ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }"}, {"sha": "c5361045549eb94b09305f5d48fe8a9486c710fb", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -345,7 +345,7 @@ pub fn trans_unboxing_shim(bcx: &Block,\n                            }).bcx;\n \n     bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_scope);\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, return_type);\n \n     llfn\n }\n@@ -757,7 +757,7 @@ pub fn trans_call_inner<'a>(\n                 if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n                     !type_is_zero_size(bcx.ccx(), ret_ty)\n                 {\n-                    Store(bcx, llret, llretslot);\n+                    store_ty(bcx, llret, llretslot, ret_ty)\n                 }\n             }\n             None => {}"}, {"sha": "de5de64e346c331830c5bdef060755532c7ed938", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -522,10 +522,6 @@ pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n-    C_integral(Type::bool(ccx), val as u64, false)\n-}\n-\n-pub fn C_i1(ccx: &CrateContext, val: bool) -> ValueRef {\n     C_integral(Type::i1(ccx), val as u64, false)\n }\n "}, {"sha": "b93469ad2fba330a9315f428641a9ab383d47407", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -13,10 +13,8 @@\n  * Datums are and how they are intended to be used.\n  */\n \n-use lib;\n use lib::llvm::ValueRef;\n use middle::trans::base::*;\n-use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n@@ -344,7 +342,7 @@ impl Datum<Rvalue> {\n                 match self.kind.mode {\n                     ByValue => DatumBlock::new(bcx, self),\n                     ByRef => {\n-                        let llval = load(bcx, self.val, self.ty);\n+                        let llval = load_ty(bcx, self.val, self.ty);\n                         DatumBlock::new(bcx, Datum::new(llval, self.ty, Rvalue::new(ByValue)))\n                     }\n                 }\n@@ -471,7 +469,7 @@ impl Datum<Expr> {\n                         DatumBlock::new(bcx, scratch)\n                     }\n                     ByValue => {\n-                        let v = load(bcx, l.val, l.ty);\n+                        let v = load_ty(bcx, l.val, l.ty);\n                         bcx = l.kind.post_store(bcx, l.val, l.ty);\n                         DatumBlock::new(bcx, Datum::new(v, l.ty, Rvalue::new(ByValue)))\n                     }\n@@ -516,24 +514,6 @@ impl Datum<Lvalue> {\n     }\n }\n \n-fn load<'a>(bcx: &'a Block<'a>, llptr: ValueRef, ty: ty::t) -> ValueRef {\n-    /*!\n-     * Private helper for loading from a by-ref datum. Handles various\n-     * special cases where the type gives us better information about\n-     * what we are loading.\n-     */\n-\n-    if type_is_zero_size(bcx.ccx(), ty) {\n-        C_undef(type_of::type_of(bcx.ccx(), ty))\n-    } else if ty::type_is_char(ty) {\n-        // a char is a unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(bcx, llptr, 0, 0x10FFFF + 1, lib::llvm::False)\n-    } else {\n-        Load(bcx, llptr)\n-    }\n-}\n-\n /**\n  * Generic methods applicable to any sort of datum.\n  */\n@@ -591,7 +571,7 @@ impl<K:KindOps> Datum<K> {\n         if self.kind.is_by_ref() {\n             memcpy_ty(bcx, dst, self.val, self.ty);\n         } else {\n-            Store(bcx, self.val, dst);\n+            store_ty(bcx, self.val, dst, self.ty);\n         }\n \n         return bcx;\n@@ -642,7 +622,7 @@ impl<K:KindOps> Datum<K> {\n         assert!(!ty::type_needs_drop(bcx.tcx(), self.ty));\n         assert!(self.appropriate_rvalue_mode(bcx.ccx()) == ByValue);\n         if self.kind.is_by_ref() {\n-            load(bcx, self.val, self.ty)\n+            load_ty(bcx, self.val, self.ty)\n         } else {\n             self.val\n         }"}, {"sha": "ac33f9bd1a87d44938c41dba00b424570e6dd910", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -505,7 +505,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n     let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n-    let expected = Call(bcx, expect, [bounds_check, C_i1(ccx, false)], []);\n+    let expected = Call(bcx, expect, [bounds_check, C_bool(ccx, false)], []);\n     let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n         });\n@@ -1149,13 +1149,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let llresult = if ty::type_is_bool(un_ty) {\n-                let val = datum.to_llscalarish(bcx);\n-                Xor(bcx, val, C_bool(ccx, true))\n-            } else {\n-                // Note: `Not` is bitwise, not suitable for logical not.\n-                Not(bcx, datum.to_llscalarish(bcx))\n-            };\n+            let llresult = Not(bcx, datum.to_llscalarish(bcx));\n             immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n         }\n         ast::UnNeg => {\n@@ -1380,7 +1374,7 @@ fn trans_lazy_binop<'a>(\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, Type::bool(bcx.ccx()), [lhs, rhs],\n+    let phi = Phi(join, Type::i1(bcx.ccx()), [lhs, rhs],\n                   [past_lhs.llbb, past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n@@ -1597,8 +1591,8 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n     let k_in = cast_type_kind(t_in);\n     let k_out = cast_type_kind(t_out);\n     let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n-    let ll_t_in = type_of::type_of(ccx, t_in);\n-    let ll_t_out = type_of::type_of(ccx, t_out);\n+    let ll_t_in = type_of::arg_type_of(ccx, t_in);\n+    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n \n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n@@ -1689,7 +1683,7 @@ fn trans_assign_op<'a>(\n     let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n     assert!(!ty::type_needs_drop(bcx.tcx(), dst_datum.ty));\n     let dst_ty = dst_datum.ty;\n-    let dst = Load(bcx, dst_datum.val);\n+    let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n \n     // Evaluate RHS\n     let rhs_datum = unpack_datum!(bcx, trans(bcx, &*src));"}, {"sha": "9d7261f809414672734024690b6d07c2966f1ced", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -325,7 +325,7 @@ pub fn trans_native_call<'a>(\n                 base::alloca(bcx,\n                              type_of::type_of(ccx, *passed_arg_tys.get(i)),\n                              \"__arg\");\n-            Store(bcx, llarg_rust, scratch);\n+            base::store_ty(bcx, llarg_rust, scratch, *passed_arg_tys.get(i));\n             llarg_rust = scratch;\n         }\n \n@@ -346,7 +346,12 @@ pub fn trans_native_call<'a>(\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            Load(bcx, llarg_rust)\n+            if ty::type_is_bool(*passed_arg_tys.get(i)) {\n+                let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, lib::llvm::False);\n+                Trunc(bcx, val, Type::i1(bcx.ccx()))\n+            } else {\n+                Load(bcx, llarg_rust)\n+            }\n         };\n \n         debug!(\"argument {}, llarg_foreign={}\",\n@@ -431,7 +436,7 @@ pub fn trans_native_call<'a>(\n         debug!(\"llforeign_ret_ty={}\", ccx.tn.type_to_str(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            Store(bcx, llforeign_retval, llretptr);\n+            base::store_ty(bcx, llforeign_retval, llretptr, fn_sig.output)\n         } else {\n             // The actual return type is a struct, but the ABI\n             // adaptation code has cast it into some scalar type.  The\n@@ -715,9 +720,15 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             // pointer).  It makes adapting types easier, since we can\n             // always just bitcast pointers.\n             if !foreign_indirect {\n-                let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n-                builder.store(llforeign_arg, lltemp);\n-                llforeign_arg = lltemp;\n+                llforeign_arg = if ty::type_is_bool(rust_ty) {\n+                    let lltemp = builder.alloca(Type::bool(ccx), \"\");\n+                    builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n+                    lltemp\n+                } else {\n+                    let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n+                    builder.store(llforeign_arg, lltemp);\n+                    lltemp\n+                }\n             }\n \n             // If the types in the ABI and the Rust types don't match,\n@@ -731,7 +742,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n             let llrust_arg = if rust_indirect {\n                 llforeign_arg\n             } else {\n-                builder.load(llforeign_arg)\n+                if ty::type_is_bool(rust_ty) {\n+                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, lib::llvm::False);\n+                    builder.trunc(tmp, Type::i1(ccx))\n+                } else {\n+                    builder.load(llforeign_arg)\n+                }\n             };\n \n             debug!(\"llrust_arg {}{}: {}\", \"#\",\n@@ -828,8 +844,8 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = arg_tys.iter().map(|&arg| type_of(ccx, arg)).collect();\n-    let llret_ty = type_of::type_of(ccx, fn_sig.output);\n+    let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n+    let llret_ty = type_of::arg_type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n         llret_ty: llret_ty"}, {"sha": "d046778485ccf9a90fc938cffbb70464930d4e36", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -234,7 +234,7 @@ fn trans_struct_drop_flag<'a>(bcx: &'a Block<'a>,\n                               -> &'a Block<'a> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let drop_flag = adt::trans_drop_flag_ptr(bcx, &*repr, v0);\n-    with_cond(bcx, IsNotNull(bcx, Load(bcx, drop_flag)), |cx| {\n+    with_cond(bcx, load_ty(bcx, drop_flag, ty::mk_bool()), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }\n@@ -504,7 +504,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx);\n+    finish_fn(&fcx, bcx, ty::mk_nil());\n \n     llfn\n }"}, {"sha": "5022e0bf05ba82a9975c30a4536b8004422fb747", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -96,13 +96,19 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let b = get_param(bcx.fcx.llfn, first_real_arg + 1);\n         let llfn = bcx.ccx().get_intrinsic(&name);\n \n+        // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n+        let result = ExtractValue(bcx, val, 0);\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n+        let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n+        let ret = InsertValue(bcx, ret, result, 0);\n+        let ret = InsertValue(bcx, ret, overflow, 1);\n \n         if type_is_immediate(bcx.ccx(), t) {\n-            Ret(bcx, val);\n+            Ret(bcx, ret);\n         } else {\n             let retptr = get_param(bcx.fcx.llfn, bcx.fcx.out_arg_pos());\n-            Store(bcx, val, retptr);\n+            Store(bcx, ret, retptr);\n             RetVoid(bcx);\n         }\n     }\n@@ -150,7 +156,8 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p(ccx));\n         let count = get_param(decl, first_real_arg + 2);\n         let llfn = ccx.get_intrinsic(&name);\n-        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, C_i1(ccx, volatile)], []);\n+        Call(bcx, llfn,\n+             [dst_ptr, src_ptr, Mul(bcx, size, count), align, C_bool(ccx, volatile)], []);\n         RetVoid(bcx);\n     }\n \n@@ -171,13 +178,13 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n         let val = get_param(decl, first_real_arg + 1);\n         let count = get_param(decl, first_real_arg + 2);\n         let llfn = ccx.get_intrinsic(&name);\n-        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, C_i1(ccx, volatile)], []);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, C_bool(ccx, volatile)], []);\n         RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_i1(bcx.ccx(), false);\n+        let y = C_bool(bcx.ccx(), false);\n         let llfn = bcx.ccx().get_intrinsic(&name);\n         let llcall = Call(bcx, llfn, [x, y], []);\n         Ret(bcx, llcall);\n@@ -365,7 +372,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n             let retty = *substs.substs.types.get(FnSpace, 0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n-                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(arg_type_of(ccx, retty).to_ref()));\n                 }\n             } else {\n                 RetVoid(bcx)"}, {"sha": "ee581f756340bc980c43d1e170c08cab0fd6f21d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                     Some(llreturn) => Br(bcx, llreturn),\n                     None => {}\n                 };\n-                finish_fn(&fcx, bcx);\n+                finish_fn(&fcx, bcx, ty::mk_u64());\n                 llfdecl\n             };\n "}, {"sha": "b10f6eda8805321359042c817fdbd9ecc2f0da25", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -89,7 +89,7 @@ impl Type {\n     }\n \n     pub fn bool(ccx: &CrateContext) -> Type {\n-        Type::i1(ccx)\n+        Type::i8(ccx)\n     }\n \n     pub fn char(ccx: &CrateContext) -> Type {"}, {"sha": "028722071a6999a3bfadc25fc6d32ed5d33fbd97", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9db7f6137122c1cf174518cc402e04d54c3c8c3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=d9db7f6137122c1cf174518cc402e04d54c3c8c3", "patch": "@@ -31,7 +31,7 @@ pub fn return_uses_outptr(ccx: &CrateContext, ty: ty::t) -> bool {\n }\n \n pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n-    let llty = type_of(ccx, arg_ty);\n+    let llty = arg_type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n     } else {\n@@ -46,7 +46,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n     let use_out_pointer = return_uses_outptr(cx, output);\n-    let lloutputtype = type_of(cx, output);\n+    let lloutputtype = arg_type_of(cx, output);\n     if use_out_pointer {\n         atys.push(lloutputtype.ptr_to());\n     }\n@@ -167,6 +167,14 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     llsizingty\n }\n \n+pub fn arg_type_of(cx: &CrateContext, t: ty::t) -> Type {\n+    if ty::type_is_bool(t) {\n+        Type::i1(cx)\n+    } else {\n+        type_of(cx, t)\n+    }\n+}\n+\n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     // Check the cache."}]}