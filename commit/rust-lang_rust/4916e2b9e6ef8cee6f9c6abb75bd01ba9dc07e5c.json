{"sha": "4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "node_id": "C_kwDOAAsO6NoAKDQ5MTZlMmI5ZTZlZjhjZWU2ZjljNmFiYjc1YmQwMWJhOWRjMDdlNWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T12:59:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-15T12:59:53Z"}, "message": "Auto merge of #98393 - michaelwoerister:new-cpp-like-enum-debuginfo, r=wesleywiser\n\ndebuginfo: Generalize C++-like encoding for enums.\n\nThe updated encoding should be able to handle niche layouts where more than one variant has fields (as introduced in https://github.com/rust-lang/rust/pull/94075).\n\nThe new encoding is more uniform as there is no structural difference between direct-tag, niche-tag, and no-tag layouts anymore. The only difference between those cases is that the \"dataful\" variant in a niche-tag enum will have a `(start, end)` pair denoting the tag range instead of a single value.\n\nThe new encoding now also supports 128-bit tags, which occur in at least some standard library types. These tags are represented as `u64` pairs so that debuggers (which don't always have support for 128-bit integers) can reliably deal with them. The downside is that this adds quite a bit of complexity to the encoding and especially to the corresponding NatVis.\n\nThe new encoding seems to increase the size of (x86_64-pc-windows-msvc) debuginfo by 10-15%. The size of binaries is not affected (release builds were built with `-Cdebuginfo=2`, numbers are in kilobytes):\n\nEXE | before | after |\u00a0relative\n-- | -- | -- | --\ncargo (debug) | 40453 | 40450 | +0%\nripgrep (debug) | 10275 | 10273 | +0%\ncargo (release) | 16186 | 16185 | +0%\nripgrep (release) | 4727 | 4726 | +0%\n\nPDB | before | after |\u00a0relative\n-- | -- | -- | --\ncargo (debug) | 236524 | 261412 | +11%\nripgrep (debug) | 53140 | 59060 | +11%\ncargo (release) | 148516 | 169620 | +14%\nripgrep (release) | 10676 | 11804 | +11%\n\nGiven that the new encoding is more general, this is to be expected. Only platforms using C++-like debuginfo are affected -- which currently is only `*-pc-windows-msvc`.\n\n*TODO*\n- [x] Properly update documentation\n- [x] Add regression tests for new optimized enum layouts as introduced by #94075.\n\nr? `@wesleywiser`", "tree": {"sha": "7115ce81f5279dae264956cac3d4be4dcedc1c18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7115ce81f5279dae264956cac3d4be4dcedc1c18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "html_url": "https://github.com/rust-lang/rust/commit/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ce76091c7cef21692a15dce1f0a4c415d245be4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce76091c7cef21692a15dce1f0a4c415d245be4", "html_url": "https://github.com/rust-lang/rust/commit/6ce76091c7cef21692a15dce1f0a4c415d245be4"}, {"sha": "03b93d008d16132dc644d811bef9e452c515ed75", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b93d008d16132dc644d811bef9e452c515ed75", "html_url": "https://github.com/rust-lang/rust/commit/03b93d008d16132dc644d811bef9e452c515ed75"}], "stats": {"total": 1542, "additions": 1118, "deletions": 424}, "files": [{"sha": "25a989bdf05253b6ec91aed5ee615b24a71bbca9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -114,6 +114,7 @@ macro_rules! return_if_di_node_created_in_meantime {\n }\n \n /// Extract size and alignment from a TyAndLayout.\n+#[inline]\n fn size_and_align_of<'tcx>(ty_and_layout: TyAndLayout<'tcx>) -> (Size, Align) {\n     (ty_and_layout.size, ty_and_layout.align.abi)\n }"}, {"sha": "daec9303b2c67edbf6f009ec9492bc81a8c02f68", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 574, "deletions": 164, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -1,29 +1,31 @@\n use std::borrow::Cow;\n \n use libc::c_uint;\n-use rustc_codegen_ssa::debuginfo::{\n-    type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo,\n+use rustc_codegen_ssa::{\n+    debuginfo::{type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo},\n+    traits::ConstMethods,\n };\n+\n+use rustc_index::vec::IndexVec;\n use rustc_middle::{\n     bug,\n     ty::{\n         self,\n         layout::{LayoutOf, TyAndLayout},\n-        util::Discr,\n-        AdtDef, GeneratorSubsts,\n+        AdtDef, GeneratorSubsts, Ty,\n     },\n };\n-use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{Align, Endian, Size, TagEncoding, VariantIdx, Variants};\n use smallvec::smallvec;\n \n use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n             build_field_di_node, closure_saved_names_of_captured_variables,\n-            enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of,\n-            type_map::{self, UniqueTypeId},\n+            enums::{tag_base_type, DiscrResult},\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n         },\n@@ -35,59 +37,161 @@ use crate::{\n     },\n };\n \n-/// In CPP-like mode, we generate a union of structs for each variant and an\n-/// explicit discriminant field roughly equivalent to the following C/C++ code:\n+// The names of the associated constants in each variant wrapper struct.\n+// These have to match up with the names being used in `intrinsic.natvis`.\n+const ASSOC_CONST_DISCR_NAME: &str = \"NAME\";\n+const ASSOC_CONST_DISCR_EXACT: &str = \"DISCR_EXACT\";\n+const ASSOC_CONST_DISCR_BEGIN: &str = \"DISCR_BEGIN\";\n+const ASSOC_CONST_DISCR_END: &str = \"DISCR_END\";\n+\n+const ASSOC_CONST_DISCR128_EXACT_LO: &str = \"DISCR128_EXACT_LO\";\n+const ASSOC_CONST_DISCR128_EXACT_HI: &str = \"DISCR128_EXACT_HI\";\n+const ASSOC_CONST_DISCR128_BEGIN_LO: &str = \"DISCR128_BEGIN_LO\";\n+const ASSOC_CONST_DISCR128_BEGIN_HI: &str = \"DISCR128_BEGIN_HI\";\n+const ASSOC_CONST_DISCR128_END_LO: &str = \"DISCR128_END_LO\";\n+const ASSOC_CONST_DISCR128_END_HI: &str = \"DISCR128_END_HI\";\n+\n+// The name of the tag field in the top-level union\n+const TAG_FIELD_NAME: &str = \"tag\";\n+const TAG_FIELD_NAME_128_LO: &str = \"tag128_lo\";\n+const TAG_FIELD_NAME_128_HI: &str = \"tag128_hi\";\n+\n+// We assign a \"virtual\" discriminant value to the sole variant of\n+// a single-variant enum.\n+const SINGLE_VARIANT_VIRTUAL_DISR: u64 = 0;\n+\n+/// In CPP-like mode, we generate a union with a field for each variant and an\n+/// explicit tag field. The field of each variant has a struct type\n+/// that encodes the discrimiant of the variant and it's data layout.\n+/// The union also has a nested enumeration type that is only used for encoding\n+/// variant names in an efficient way. Its enumerator values do _not_ correspond\n+/// to the enum's discriminant values.\n+/// It's roughly equivalent to the following C/C++ code:\n ///\n /// ```c\n-/// union enum$<{fully-qualified-name}> {\n-///   struct {variant 0 name} {\n-///     <variant 0 fields>\n+/// union enum2$<{fully-qualified-name}> {\n+///   struct Variant0 {\n+///     struct {name-of-variant-0} {\n+///        <variant 0 fields>\n+///     } value;\n+///\n+///     static VariantNames NAME = {name-of-variant-0};\n+///     static int_type DISCR_EXACT = {discriminant-of-variant-0};\n ///   } variant0;\n+///\n ///   <other variant structs>\n-///   {name} discriminant;\n+///\n+///   int_type tag;\n+///\n+///   enum VariantNames {\n+///      <name-of-variant-0> = 0, // The numeric values are variant index,\n+///      <name-of-variant-1> = 1, // not discriminant values.\n+///      <name-of-variant-2> = 2,\n+///      ...\n+///   }\n /// }\n /// ```\n ///\n-/// As you can see, the type name is wrapped `enum$`. This way we can have a\n-/// single NatVis rule for handling all enums.\n+/// As you can see, the type name is wrapped in `enum2$<_>`. This way we can\n+/// have a single NatVis rule for handling all enums. The `2` in `enum2$<_>`\n+/// is an encoding version tag, so that debuggers can decide to decode this\n+/// differently than the previous `enum$<_>` encoding emitted by earlier\n+/// compiler versions.\n ///\n-/// At the LLVM IR level this looks like\n+/// Niche-tag enums have one special variant, usually called the\n+/// \"dataful variant\". This variant has a field that\n+/// doubles as the tag of the enum. The variant is active when the value of\n+/// that field is within a pre-defined range. Therefore the variant struct\n+/// has a `DISCR_BEGIN` and `DISCR_END` field instead of `DISCR_EXACT` in\n+/// that case. Both `DISCR_BEGIN` and `DISCR_END` are inclusive bounds.\n+/// Note that these ranges can wrap around, so that `DISCR_END < DISCR_BEGIN`.\n ///\n-/// ```txt\n-///       DW_TAG_union_type              (top-level type for enum)\n-///         DW_TAG_member                    (member for variant 1)\n-///         DW_TAG_member                    (member for variant 2)\n-///         DW_TAG_member                    (member for variant 3)\n-///         DW_TAG_structure_type            (type of variant 1)\n-///         DW_TAG_structure_type            (type of variant 2)\n-///         DW_TAG_structure_type            (type of variant 3)\n-///         DW_TAG_enumeration_type          (type of tag)\n-/// ```\n+/// Single-variant enums don't actually have a tag field. In this case we\n+/// emit a static tag field (that always has the value 0) so we can use the\n+/// same representation (and NatVis).\n ///\n-/// The above encoding applies for enums with a direct tag. For niche-tag we have to do things\n-/// differently in order to allow a NatVis visualizer to extract all the information needed:\n-/// We generate a union of two fields, one for the dataful variant\n-/// and one that just points to the discriminant (which is some field within the dataful variant).\n-/// We also create a DW_TAG_enumeration_type DIE that contains tag values for the non-dataful\n-/// variants and make the discriminant field that type. We then use NatVis to render the enum type\n-/// correctly in Windbg/VS. This will generate debuginfo roughly equivalent to the following C:\n+/// For niche-layout enums it's possible to have a 128-bit tag. NatVis, VS, and\n+/// WinDbg (the main targets for CPP-like debuginfo at the moment) don't support\n+/// 128-bit integers, so all values involved get split into two 64-bit fields.\n+/// Instead of the `tag` field, we generate two fields `tag128_lo` and `tag128_hi`,\n+/// Instead of `DISCR_EXACT`, we generate `DISCR128_EXACT_LO` and `DISCR128_EXACT_HI`,\n+/// and so on.\n ///\n-/// ```c\n-/// union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n-///   struct <dataful variant name> {\n-///     <fields in dataful variant>\n-///   } dataful_variant;\n-///   enum Discriminant$ {\n-///     <non-dataful variants>\n-///   } discriminant;\n+///\n+/// The following pseudocode shows how to decode an enum value in a debugger:\n+///\n+/// ```text\n+///\n+/// fn find_active_variant(enum_value) -> (VariantName, VariantValue) {\n+///     let is_128_bit = enum_value.has_field(\"tag128_lo\");\n+///\n+///     if !is_128_bit {\n+///         // Note: `tag` can be a static field for enums with only one\n+///         //       inhabited variant.\n+///         let tag = enum_value.field(\"tag\").value;\n+///\n+///         // For each variant, check if it is a match. Only one of them will match,\n+///         // so if we find it we can return it immediately.\n+///         for variant_field in enum_value.fields().filter(|f| f.name.starts_with(\"variant\")) {\n+///             if variant_field.has_field(\"DISCR_EXACT\") {\n+///                 // This variant corresponds to a single tag value\n+///                 if variant_field.field(\"DISCR_EXACT\").value == tag {\n+///                     return (variant_field.field(\"NAME\"), variant_field.value);\n+///                 }\n+///             } else {\n+///                 // This is a range variant\n+///                 let begin = variant_field.field(\"DISCR_BEGIN\");\n+///                 let end = variant_field.field(\"DISCR_END\");\n+///\n+///                 if is_in_range(tag, begin, end) {\n+///                     return (variant_field.field(\"NAME\"), variant_field.value);\n+///                 }\n+///             }\n+///         }\n+///     } else {\n+///         // Basically the same as with smaller tags, we just have to\n+///         // stitch the values together.\n+///         let tag: u128 = (enum_value.field(\"tag128_lo\").value as u128) |\n+///                         (enum_value.field(\"tag128_hi\").value as u128 << 64);\n+///\n+///         for variant_field in enum_value.fields().filter(|f| f.name.starts_with(\"variant\")) {\n+///             if variant_field.has_field(\"DISCR128_EXACT_LO\") {\n+///                 let discr_exact = (variant_field.field(\"DISCR128_EXACT_LO\" as u128) |\n+///                                   (variant_field.field(\"DISCR128_EXACT_HI\") as u128 << 64);\n+///\n+///                 // This variant corresponds to a single tag value\n+///                 if discr_exact.value == tag {\n+///                     return (variant_field.field(\"NAME\"), variant_field.value);\n+///                 }\n+///             } else {\n+///                 // This is a range variant\n+///                 let begin = (variant_field.field(\"DISCR128_BEGIN_LO\").value as u128) |\n+///                             (variant_field.field(\"DISCR128_BEGIN_HI\").value as u128 << 64);\n+///                 let end = (variant_field.field(\"DISCR128_END_LO\").value as u128) |\n+///                           (variant_field.field(\"DISCR128_END_HI\").value as u128 << 64);\n+///\n+///                 if is_in_range(tag, begin, end) {\n+///                     return (variant_field.field(\"NAME\"), variant_field.value);\n+///                 }\n+///             }\n+///         }\n+///     }\n+///\n+///     // We should have found an active variant at this point.\n+///     unreachable!();\n /// }\n-/// ```\n ///\n-/// The NatVis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n-/// and evaluates `this.discriminant`. If the value is between the min niche and max\n-/// niche, then the enum is in the dataful variant and `this.dataful_variant` is\n-/// rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n-/// case, we just need to render the name of the `this.discriminant` enum.\n+/// // Check if a value is within the given range\n+/// // (where the range might wrap around the value space)\n+/// fn is_in_range(value, start, end) -> bool {\n+///     if start < end {\n+///         value >= start && value <= end\n+///     } else {\n+///         value >= start || value <= end\n+///     }\n+/// }\n+///\n+/// ```\n pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId<'tcx>,\n@@ -135,27 +239,28 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     ref variants,\n                     tag_field,\n                     ..\n-                } => build_union_fields_for_direct_tag_enum(\n+                } => build_union_fields_for_enum(\n                     cx,\n                     enum_adt_def,\n                     enum_type_and_layout,\n                     enum_type_di_node,\n-                    &mut variants.indices(),\n+                    variants.indices(),\n                     tag_field,\n+                    None,\n                 ),\n                 Variants::Multiple {\n                     tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n                     ref variants,\n                     tag_field,\n                     ..\n-                } => build_union_fields_for_niche_tag_enum(\n+                } => build_union_fields_for_enum(\n                     cx,\n                     enum_adt_def,\n                     enum_type_and_layout,\n                     enum_type_di_node,\n-                    dataful_variant,\n-                    &mut variants.indices(),\n+                    variants.indices(),\n                     tag_field,\n+                    Some(dataful_variant),\n                 ),\n             }\n         },\n@@ -217,137 +322,344 @@ fn build_single_variant_union_fields<'ll, 'tcx>(\n     let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n     let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n         cx,\n-        enum_type_and_layout.ty,\n+        enum_type_and_layout,\n         enum_type_di_node,\n         variant_index,\n         enum_adt_def.variant(variant_index),\n         variant_layout,\n     );\n \n-    // NOTE: The field name of the union is the same as the variant name, not \"variant0\".\n-    let variant_name = enum_adt_def.variant(variant_index).name.as_str();\n+    let tag_base_type = cx.tcx.types.u32;\n+    let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n+    let tag_base_type_align = cx.align_of(tag_base_type);\n \n-    smallvec![build_field_di_node(\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n         cx,\n         enum_type_di_node,\n-        variant_name,\n-        // NOTE: We use the size and align of the entire type, not from variant_layout\n-        //       since the later is sometimes smaller (if it has fewer fields).\n-        size_and_align_of(enum_type_and_layout),\n-        Size::ZERO,\n-        DIFlags::FlagZero,\n+        std::iter::once((\n+            variant_index,\n+            Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n+        )),\n+    );\n+\n+    let variant_struct_type_wrapper_di_node = build_variant_struct_wrapper_type_di_node(\n+        cx,\n+        enum_type_and_layout,\n+        enum_type_di_node,\n+        variant_index,\n+        None,\n         variant_struct_type_di_node,\n-    )]\n+        variant_names_type_di_node,\n+        tag_base_type_di_node,\n+        tag_base_type,\n+        DiscrResult::NoDiscriminant,\n+    );\n+\n+    smallvec![\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            &variant_union_field_name(variant_index),\n+            // NOTE: We use the size and align of the entire type, not from variant_layout\n+            //       since the later is sometimes smaller (if it has fewer fields).\n+            size_and_align_of(enum_type_and_layout),\n+            Size::ZERO,\n+            DIFlags::FlagZero,\n+            variant_struct_type_wrapper_di_node,\n+        ),\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateStaticMemberType(\n+                DIB(cx),\n+                enum_type_di_node,\n+                TAG_FIELD_NAME.as_ptr().cast(),\n+                TAG_FIELD_NAME.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                variant_names_type_di_node,\n+                DIFlags::FlagZero,\n+                Some(cx.const_u64(SINGLE_VARIANT_VIRTUAL_DISR)),\n+                tag_base_type_align.bits() as u32,\n+            )\n+        }\n+    ]\n }\n \n-fn build_union_fields_for_direct_tag_enum<'ll, 'tcx>(\n+fn build_union_fields_for_enum<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_adt_def: AdtDef<'tcx>,\n     enum_type_and_layout: TyAndLayout<'tcx>,\n     enum_type_di_node: &'ll DIType,\n-    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    variant_indices: impl Iterator<Item = VariantIdx> + Clone,\n     tag_field: usize,\n+    dataful_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n+        cx,\n+        enum_type_di_node,\n+        variant_indices.clone().map(|variant_index| {\n+            let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+            (variant_index, variant_name)\n+        }),\n+    );\n+\n     let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_indices\n         .map(|variant_index| {\n             let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n \n+            let variant_def = enum_adt_def.variant(variant_index);\n+\n+            let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+                cx,\n+                enum_type_and_layout,\n+                enum_type_di_node,\n+                variant_index,\n+                variant_def,\n+                variant_layout,\n+            );\n+\n             VariantFieldInfo {\n                 variant_index,\n-                variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n-                    cx,\n-                    enum_type_and_layout.ty,\n-                    enum_type_di_node,\n-                    variant_index,\n-                    enum_adt_def.variant(variant_index),\n-                    variant_layout,\n-                ),\n+                variant_struct_type_di_node,\n                 source_info: None,\n+                discr: super::compute_discriminant_value(cx, enum_type_and_layout, variant_index),\n             }\n         })\n         .collect();\n \n-    let discr_type_name = cx.tcx.item_name(enum_adt_def.did());\n-    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n-        cx,\n-        discr_type_name.as_str(),\n-        tag_base_type,\n-        &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n-            (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n-        }),\n-        enum_type_di_node,\n-    );\n-\n     build_union_fields_for_direct_tag_enum_or_generator(\n         cx,\n         enum_type_and_layout,\n         enum_type_di_node,\n         &variant_field_infos,\n-        discr_type_di_node,\n+        variant_names_type_di_node,\n+        tag_base_type,\n         tag_field,\n+        dataful_variant_index,\n     )\n }\n \n-fn build_union_fields_for_niche_tag_enum<'ll, 'tcx>(\n+// The base type of the VariantNames DW_AT_enumeration_type is always the same.\n+// It has nothing to do with the tag of the enum and just has to be big enough\n+// to hold all variant names.\n+fn variant_names_enum_base_type<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) -> Ty<'tcx> {\n+    cx.tcx.types.u32\n+}\n+\n+/// This function builds a DW_AT_enumeration_type that contains an entry for\n+/// each variant. Note that this has nothing to do with the discriminant. The\n+/// numeric value of each enumerator corresponds to the variant index. The\n+/// type is only used for efficiently encoding the name of each variant in\n+/// debuginfo.\n+fn build_variant_names_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    enum_adt_def: AdtDef<'tcx>,\n-    enum_type_and_layout: TyAndLayout<'tcx>,\n-    enum_type_di_node: &'ll DIType,\n-    dataful_variant_index: VariantIdx,\n-    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n-    tag_field: usize,\n-) -> SmallVec<&'ll DIType> {\n-    let dataful_variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+    containing_scope: &'ll DIType,\n+    variants: impl Iterator<Item = (VariantIdx, Cow<'tcx, str>)>,\n+) -> &'ll DIType {\n+    // Create an enumerator for each variant.\n+    super::build_enumeration_type_di_node(\n         cx,\n-        enum_type_and_layout.ty,\n-        enum_type_di_node,\n-        dataful_variant_index,\n-        &enum_adt_def.variant(dataful_variant_index),\n-        enum_type_and_layout.for_variant(cx, dataful_variant_index),\n-    );\n+        \"VariantNames\",\n+        variant_names_enum_base_type(cx),\n+        variants.map(|(variant_index, variant_name)| (variant_name, variant_index.as_u32() as u64)),\n+        containing_scope,\n+    )\n+}\n \n-    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n-    // Create an DW_TAG_enumerator for each variant except the dataful one.\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n+fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n+    enum_or_generator_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+    dataful_variant_index: Option<VariantIdx>,\n+    variant_struct_type_di_node: &'ll DIType,\n+    variant_names_type_di_node: &'ll DIType,\n+    tag_base_type_di_node: &'ll DIType,\n+    tag_base_type: Ty<'tcx>,\n+    discr: DiscrResult,\n+) -> &'ll DIType {\n+    type_map::build_type_with_children(\n         cx,\n-        \"Discriminant$\",\n-        tag_base_type,\n-        &mut variant_indices.filter_map(|variant_index| {\n-            if let Some(discr_val) =\n-                super::compute_discriminant_value(cx, enum_type_and_layout, variant_index)\n-            {\n-                let discr = Discr { val: discr_val as u128, ty: tag_base_type };\n-                let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n-                Some((discr, variant_name))\n-            } else {\n-                debug_assert_eq!(variant_index, dataful_variant_index);\n-                None\n-            }\n-        }),\n-        enum_type_di_node,\n-    );\n-\n-    smallvec![\n-        build_field_di_node(\n-            cx,\n-            enum_type_di_node,\n-            \"dataful_variant\",\n-            size_and_align_of(enum_type_and_layout),\n-            Size::ZERO,\n-            DIFlags::FlagZero,\n-            dataful_variant_struct_type_di_node,\n-        ),\n-        build_field_di_node(\n+        type_map::stub(\n             cx,\n-            enum_type_di_node,\n-            \"discriminant\",\n-            cx.size_and_align_of(tag_base_type),\n-            enum_type_and_layout.fields.offset(tag_field),\n+            Stub::Struct,\n+            UniqueTypeId::for_enum_variant_struct_type_wrapper(\n+                cx.tcx,\n+                enum_or_generator_type_and_layout.ty,\n+                variant_index,\n+            ),\n+            &variant_struct_wrapper_type_name(variant_index),\n+            // NOTE: We use size and align of enum_type, not from variant_layout:\n+            size_and_align_of(enum_or_generator_type_and_layout),\n+            Some(enum_or_generator_type_di_node),\n             DIFlags::FlagZero,\n-            discr_type_di_node,\n         ),\n-    ]\n+        |cx, wrapper_struct_type_di_node| {\n+            enum DiscrKind {\n+                Exact(u64),\n+                Exact128(u128),\n+                Range(u64, u64),\n+                Range128(u128, u128),\n+            }\n+\n+            let (tag_base_type_size, tag_base_type_align) = cx.size_and_align_of(tag_base_type);\n+            let is_128_bits = tag_base_type_size.bits() > 64;\n+\n+            let discr = match discr {\n+                DiscrResult::NoDiscriminant => DiscrKind::Exact(SINGLE_VARIANT_VIRTUAL_DISR),\n+                DiscrResult::Value(discr_val) => {\n+                    if is_128_bits {\n+                        DiscrKind::Exact128(discr_val)\n+                    } else {\n+                        debug_assert_eq!(discr_val, discr_val as u64 as u128);\n+                        DiscrKind::Exact(discr_val as u64)\n+                    }\n+                }\n+                DiscrResult::Range(min, max) => {\n+                    assert_eq!(Some(variant_index), dataful_variant_index);\n+                    if is_128_bits {\n+                        DiscrKind::Range128(min, max)\n+                    } else {\n+                        debug_assert_eq!(min, min as u64 as u128);\n+                        debug_assert_eq!(max, max as u64 as u128);\n+                        DiscrKind::Range(min as u64, max as u64)\n+                    }\n+                }\n+            };\n+\n+            let mut fields = SmallVec::new();\n+\n+            // We always have a field for the value\n+            fields.push(build_field_di_node(\n+                cx,\n+                wrapper_struct_type_di_node,\n+                \"value\",\n+                size_and_align_of(enum_or_generator_type_and_layout),\n+                Size::ZERO,\n+                DIFlags::FlagZero,\n+                variant_struct_type_di_node,\n+            ));\n+\n+            let build_assoc_const =\n+                |name: &str, type_di_node: &'ll DIType, value: u64, align: Align| unsafe {\n+                    llvm::LLVMRustDIBuilderCreateStaticMemberType(\n+                        DIB(cx),\n+                        wrapper_struct_type_di_node,\n+                        name.as_ptr().cast(),\n+                        name.len(),\n+                        unknown_file_metadata(cx),\n+                        UNKNOWN_LINE_NUMBER,\n+                        type_di_node,\n+                        DIFlags::FlagZero,\n+                        Some(cx.const_u64(value)),\n+                        align.bits() as u32,\n+                    )\n+                };\n+\n+            // We also always have an associated constant for the discriminant value\n+            // of the variant.\n+            fields.push(build_assoc_const(\n+                ASSOC_CONST_DISCR_NAME,\n+                variant_names_type_di_node,\n+                variant_index.as_u32() as u64,\n+                cx.align_of(variant_names_enum_base_type(cx)),\n+            ));\n+\n+            // Emit the discriminant value (or range) corresponding to the variant.\n+            match discr {\n+                DiscrKind::Exact(discr_val) => {\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_EXACT,\n+                        tag_base_type_di_node,\n+                        discr_val,\n+                        tag_base_type_align,\n+                    ));\n+                }\n+                DiscrKind::Exact128(discr_val) => {\n+                    let align = cx.align_of(cx.tcx.types.u64);\n+                    let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+                    let Split128 { hi, lo } = split_128(discr_val);\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_EXACT_LO,\n+                        type_di_node,\n+                        lo,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_EXACT_HI,\n+                        type_di_node,\n+                        hi,\n+                        align,\n+                    ));\n+                }\n+                DiscrKind::Range(begin, end) => {\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_BEGIN,\n+                        tag_base_type_di_node,\n+                        begin,\n+                        tag_base_type_align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_END,\n+                        tag_base_type_di_node,\n+                        end,\n+                        tag_base_type_align,\n+                    ));\n+                }\n+                DiscrKind::Range128(begin, end) => {\n+                    let align = cx.align_of(cx.tcx.types.u64);\n+                    let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+                    let Split128 { hi: begin_hi, lo: begin_lo } = split_128(begin);\n+                    let Split128 { hi: end_hi, lo: end_lo } = split_128(end);\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_BEGIN_HI,\n+                        type_di_node,\n+                        begin_hi,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_BEGIN_LO,\n+                        type_di_node,\n+                        begin_lo,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_END_HI,\n+                        type_di_node,\n+                        end_hi,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_END_LO,\n+                        type_di_node,\n+                        end_lo,\n+                        align,\n+                    ));\n+                }\n+            }\n+\n+            fields\n+        },\n+        NO_GENERICS,\n+    )\n+    .di_node\n+}\n+\n+struct Split128 {\n+    hi: u64,\n+    lo: u64,\n+}\n+\n+fn split_128(value: u128) -> Split128 {\n+    Split128 { hi: (value >> 64) as u64, lo: value as u64 }\n }\n \n fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n@@ -369,6 +681,29 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n \n     let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n+    let variant_count = (variant_range.start.as_u32()..variant_range.end.as_u32()).len();\n+\n+    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n+\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n+        cx,\n+        generator_type_di_node,\n+        variant_range\n+            .clone()\n+            .map(|variant_index| (variant_index, GeneratorSubsts::variant_name(variant_index))),\n+    );\n+\n+    let discriminants: IndexVec<VariantIdx, DiscrResult> = {\n+        let discriminants_iter = generator_substs.discriminants(generator_def_id, cx.tcx);\n+        let mut discriminants: IndexVec<VariantIdx, DiscrResult> =\n+            IndexVec::with_capacity(variant_count);\n+        for (variant_index, discr) in discriminants_iter {\n+            // Assert that the index in the IndexMap matches up with the given VariantIdx.\n+            assert_eq!(variant_index, discriminants.next_index());\n+            discriminants.push(DiscrResult::Value(discr.val));\n+        }\n+        discriminants\n+    };\n \n     // Build the type node for each field.\n     let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_range\n@@ -391,29 +726,24 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n                 None\n             };\n \n-            VariantFieldInfo { variant_index, variant_struct_type_di_node, source_info }\n+            VariantFieldInfo {\n+                variant_index,\n+                variant_struct_type_di_node,\n+                source_info,\n+                discr: discriminants[variant_index],\n+            }\n         })\n         .collect();\n \n-    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n-    let discr_type_name = \"Discriminant$\";\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n-        cx,\n-        discr_type_name,\n-        tag_base_type,\n-        &mut generator_substs\n-            .discriminants(generator_def_id, cx.tcx)\n-            .map(|(variant_index, discr)| (discr, GeneratorSubsts::variant_name(variant_index))),\n-        generator_type_di_node,\n-    );\n-\n     build_union_fields_for_direct_tag_enum_or_generator(\n         cx,\n         generator_type_and_layout,\n         generator_type_di_node,\n         &variant_field_infos[..],\n-        discr_type_di_node,\n+        variant_names_type_di_node,\n+        tag_base_type,\n         tag_field,\n+        None,\n     )\n }\n \n@@ -425,8 +755,11 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n     enum_type_di_node: &'ll DIType,\n     variant_field_infos: &[VariantFieldInfo<'ll>],\n     discr_type_di_node: &'ll DIType,\n+    tag_base_type: Ty<'tcx>,\n     tag_field: usize,\n+    dataful_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n+    let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n     let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n \n     // We create a field in the union for each variant ...\n@@ -438,6 +771,19 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n         let field_name = variant_union_field_name(variant_member_info.variant_index);\n         let (size, align) = size_and_align_of(enum_type_and_layout);\n \n+        let variant_struct_type_wrapper = build_variant_struct_wrapper_type_di_node(\n+            cx,\n+            enum_type_and_layout,\n+            enum_type_di_node,\n+            variant_member_info.variant_index,\n+            dataful_variant_index,\n+            variant_member_info.variant_struct_type_di_node,\n+            discr_type_di_node,\n+            tag_base_type_di_node,\n+            tag_base_type,\n+            variant_member_info.discr,\n+        );\n+\n         // We use LLVMRustDIBuilderCreateMemberType() member type directly because\n         // the build_field_di_node() function does not support specifying a source location,\n         // which is something that we don't do anywhere else.\n@@ -456,7 +802,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n                 // Union fields are always at offset zero\n                 Size::ZERO.bits(),\n                 DIFlags::FlagZero,\n-                variant_member_info.variant_struct_type_di_node,\n+                variant_struct_type_wrapper,\n             )\n         }\n     }));\n@@ -466,16 +812,53 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n         cx.size_and_align_of(super::tag_base_type(cx, enum_type_and_layout))\n     );\n \n-    // ... and a field for the discriminant.\n-    unions_fields.push(build_field_di_node(\n-        cx,\n-        enum_type_di_node,\n-        \"discriminant\",\n-        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n-        enum_type_and_layout.fields.offset(tag_field),\n-        DIFlags::FlagZero,\n-        discr_type_di_node,\n-    ));\n+    // ... and a field for the tag. If the tag is 128 bits wide, this will actually\n+    // be two 64-bit fields.\n+    let is_128_bits = cx.size_of(tag_base_type).bits() > 64;\n+\n+    if is_128_bits {\n+        let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+        let size_and_align = cx.size_and_align_of(cx.tcx.types.u64);\n+\n+        let (lo_offset, hi_offset) = match cx.tcx.data_layout.endian {\n+            Endian::Little => (0, 8),\n+            Endian::Big => (8, 0),\n+        };\n+\n+        let tag_field_offset = enum_type_and_layout.fields.offset(tag_field).bytes();\n+        let lo_offset = Size::from_bytes(tag_field_offset + lo_offset);\n+        let hi_offset = Size::from_bytes(tag_field_offset + hi_offset);\n+\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME_128_LO,\n+            size_and_align,\n+            lo_offset,\n+            DIFlags::FlagZero,\n+            type_di_node,\n+        ));\n+\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME_128_HI,\n+            size_and_align,\n+            hi_offset,\n+            DIFlags::FlagZero,\n+            type_di_node,\n+        ));\n+    } else {\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME,\n+            cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+            enum_type_and_layout.fields.offset(tag_field),\n+            DIFlags::FlagZero,\n+            tag_base_type_di_node,\n+        ));\n+    }\n \n     unions_fields\n }\n@@ -485,6 +868,7 @@ struct VariantFieldInfo<'ll> {\n     variant_index: VariantIdx,\n     variant_struct_type_di_node: &'ll DIType,\n     source_info: Option<(&'ll DIFile, c_uint)>,\n+    discr: DiscrResult,\n }\n \n fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n@@ -512,3 +896,29 @@ fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n         .map(|&s| Cow::from(s))\n         .unwrap_or_else(|| format!(\"variant{}\", variant_index.as_usize()).into())\n }\n+\n+fn variant_struct_wrapper_type_name(variant_index: VariantIdx) -> Cow<'static, str> {\n+    const PRE_ALLOCATED: [&str; 16] = [\n+        \"Variant0\",\n+        \"Variant1\",\n+        \"Variant2\",\n+        \"Variant3\",\n+        \"Variant4\",\n+        \"Variant5\",\n+        \"Variant6\",\n+        \"Variant7\",\n+        \"Variant8\",\n+        \"Variant9\",\n+        \"Variant10\",\n+        \"Variant11\",\n+        \"Variant12\",\n+        \"Variant13\",\n+        \"Variant14\",\n+        \"Variant15\",\n+    ];\n+\n+    PRE_ALLOCATED\n+        .get(variant_index.as_usize())\n+        .map(|&s| Cow::from(s))\n+        .unwrap_or_else(|| format!(\"Variant{}\", variant_index.as_usize()).into())\n+}"}, {"sha": "9b3d080bfd6aa3f8dbb7b1f76de5c70ba62e9fe9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -10,7 +10,6 @@ use rustc_middle::{\n     ty::{\n         self,\n         layout::{IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout},\n-        util::Discr,\n         AdtDef, GeneratorSubsts, Ty, VariantDef,\n     },\n };\n@@ -90,8 +89,11 @@ fn build_c_style_enum_di_node<'ll, 'tcx>(\n             cx,\n             &compute_debuginfo_type_name(cx.tcx, enum_type_and_layout.ty, false),\n             tag_base_type(cx, enum_type_and_layout),\n-            &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n-                (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+            enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+                let name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+                // Is there anything we can do to support 128-bit C-Style enums?\n+                let value = discr.val as u64;\n+                (name, value)\n             }),\n             containing_scope,\n         ),\n@@ -152,7 +154,7 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     type_name: &str,\n     base_type: Ty<'tcx>,\n-    variants: &mut dyn Iterator<Item = (Discr<'tcx>, Cow<'tcx, str>)>,\n+    enumerators: impl Iterator<Item = (Cow<'tcx, str>, u64)>,\n     containing_scope: &'ll DIType,\n ) -> &'ll DIType {\n     let is_unsigned = match base_type.kind() {\n@@ -161,18 +163,15 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n         _ => bug!(\"build_enumeration_type_di_node() called with non-integer tag type.\"),\n     };\n \n-    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = variants\n-        .map(|(discr, variant_name)| {\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    variant_name.as_ptr().cast(),\n-                    variant_name.len(),\n-                    // FIXME: what if enumeration has i128 discriminant?\n-                    discr.val as i64,\n-                    is_unsigned,\n-                ))\n-            }\n+    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = enumerators\n+        .map(|(name, value)| unsafe {\n+            Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                DIB(cx),\n+                name.as_ptr().cast(),\n+                name.len(),\n+                value as i64,\n+                is_unsigned,\n+            ))\n         })\n         .collect();\n \n@@ -247,23 +246,27 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n /// and a DW_TAG_member for each field (but not the discriminant).\n fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    enum_type: Ty<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n     enum_type_di_node: &'ll DIType,\n     variant_index: VariantIdx,\n     variant_def: &VariantDef,\n     variant_layout: TyAndLayout<'tcx>,\n ) -> &'ll DIType {\n-    debug_assert_eq!(variant_layout.ty, enum_type);\n+    debug_assert_eq!(variant_layout.ty, enum_type_and_layout.ty);\n \n     type_map::build_type_with_children(\n         cx,\n         type_map::stub(\n             cx,\n             Stub::Struct,\n-            UniqueTypeId::for_enum_variant_struct_type(cx.tcx, enum_type, variant_index),\n+            UniqueTypeId::for_enum_variant_struct_type(\n+                cx.tcx,\n+                enum_type_and_layout.ty,\n+                variant_index,\n+            ),\n             variant_def.name.as_str(),\n             // NOTE: We use size and align of enum_type, not from variant_layout:\n-            cx.size_and_align_of(enum_type),\n+            size_and_align_of(enum_type_and_layout),\n             Some(enum_type_di_node),\n             DIFlags::FlagZero,\n         ),\n@@ -290,9 +293,9 @@ fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n                         type_di_node(cx, field_layout.ty),\n                     )\n                 })\n-                .collect()\n+                .collect::<SmallVec<_>>()\n         },\n-        |cx| build_generic_type_param_di_nodes(cx, enum_type),\n+        |cx| build_generic_type_param_di_nodes(cx, enum_type_and_layout.ty),\n     )\n     .di_node\n }\n@@ -398,6 +401,19 @@ pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n     .di_node\n }\n \n+#[derive(Copy, Clone)]\n+enum DiscrResult {\n+    NoDiscriminant,\n+    Value(u128),\n+    Range(u128, u128),\n+}\n+\n+impl DiscrResult {\n+    fn opt_single_val(&self) -> Option<u128> {\n+        if let Self::Value(d) = *self { Some(d) } else { None }\n+    }\n+}\n+\n /// Returns the discriminant value corresponding to the variant index.\n ///\n /// Will return `None` if there is less than two variants (because then the enum won't have)\n@@ -407,30 +423,38 @@ fn compute_discriminant_value<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_type_and_layout: TyAndLayout<'tcx>,\n     variant_index: VariantIdx,\n-) -> Option<u64> {\n+) -> DiscrResult {\n     match enum_type_and_layout.layout.variants() {\n-        &Variants::Single { .. } => None,\n-        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => Some(\n-            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val\n-                as u64,\n+        &Variants::Single { .. } => DiscrResult::NoDiscriminant,\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => DiscrResult::Value(\n+            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val,\n         ),\n         &Variants::Multiple {\n             tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n             tag,\n             ..\n         } => {\n             if variant_index == dataful_variant {\n-                None\n+                let valid_range = enum_type_and_layout\n+                    .for_variant(cx, variant_index)\n+                    .largest_niche\n+                    .as_ref()\n+                    .unwrap()\n+                    .valid_range;\n+\n+                let min = valid_range.start.min(valid_range.end);\n+                let min = tag.size(cx).truncate(min);\n+\n+                let max = valid_range.start.max(valid_range.end);\n+                let max = tag.size(cx).truncate(max);\n+\n+                DiscrResult::Range(min, max)\n             } else {\n                 let value = (variant_index.as_u32() as u128)\n                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                     .wrapping_add(niche_start);\n                 let value = tag.size(cx).truncate(value);\n-                // NOTE(eddyb) do *NOT* remove this assert, until\n-                // we pass the full 128-bit value to LLVM, otherwise\n-                // truncation will be silent and remain undetected.\n-                assert_eq!(value as u64 as u128, value);\n-                Some(value as u64)\n+                DiscrResult::Value(value)\n             }\n         }\n     }"}, {"sha": "dae90a43f2659c32ab5277b6a09d4071dc074bff", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -88,7 +88,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     variant_name: Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n                     variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n                         cx,\n-                        enum_type,\n+                        enum_type_and_layout,\n                         enum_type_di_node,\n                         variant_index,\n                         enum_adt_def.variant(variant_index),\n@@ -413,7 +413,13 @@ fn build_enum_variant_member_di_node<'ll, 'tcx>(\n             enum_type_and_layout.size.bits(),\n             enum_type_and_layout.align.abi.bits() as u32,\n             Size::ZERO.bits(),\n-            discr_value.map(|v| cx.const_u64(v)),\n+            discr_value.opt_single_val().map(|value| {\n+                // NOTE(eddyb) do *NOT* remove this assert, until\n+                // we pass the full 128-bit value to LLVM, otherwise\n+                // truncation will be silent and remain undetected.\n+                assert_eq!(value as u64 as u128, value);\n+                cx.const_u64(value as u64)\n+            }),\n             DIFlags::FlagZero,\n             variant_member_info.variant_struct_type_di_node,\n         )"}, {"sha": "e30622cbdced69260cb2107ba6459898fbcd8235", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -47,6 +47,8 @@ pub(super) enum UniqueTypeId<'tcx> {\n     VariantPart(Ty<'tcx>, private::HiddenZst),\n     /// The ID for the artificial struct type describing a single enum variant.\n     VariantStructType(Ty<'tcx>, VariantIdx, private::HiddenZst),\n+    /// The ID for the additional wrapper struct type describing an enum variant in CPP-like mode.\n+    VariantStructTypeCppLikeWrapper(Ty<'tcx>, VariantIdx, private::HiddenZst),\n     /// The ID of the artificial type we create for VTables.\n     VTableTy(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>, private::HiddenZst),\n }\n@@ -71,6 +73,15 @@ impl<'tcx> UniqueTypeId<'tcx> {\n         UniqueTypeId::VariantStructType(enum_ty, variant_idx, private::HiddenZst)\n     }\n \n+    pub fn for_enum_variant_struct_type_wrapper(\n+        tcx: TyCtxt<'tcx>,\n+        enum_ty: Ty<'tcx>,\n+        variant_idx: VariantIdx,\n+    ) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantStructTypeCppLikeWrapper(enum_ty, variant_idx, private::HiddenZst)\n+    }\n+\n     pub fn for_vtable_ty(\n         tcx: TyCtxt<'tcx>,\n         self_type: Ty<'tcx>,"}, {"sha": "89611fc0dee1b2d9cc8a73d0d125e9b20c1766aa", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -2079,6 +2079,19 @@ extern \"C\" {\n         Ty: &'a DIType,\n     ) -> &'a DIType;\n \n+    pub fn LLVMRustDIBuilderCreateStaticMemberType<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        val: Option<&'a Value>,\n+        AlignInBits: u32,\n+    ) -> &'a DIDerivedType;\n+\n     pub fn LLVMRustDIBuilderCreateLexicalBlock<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,"}, {"sha": "135ed680da2dc7ad998c2ee25f75be979959662f", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -18,11 +18,10 @@ use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathD\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, ExistentialProjection, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n-use rustc_target::abi::{Integer, TagEncoding, Variants};\n+use rustc_middle::ty::{self, ExistentialProjection, ParamEnv, Ty, TyCtxt};\n+use rustc_target::abi::Integer;\n use smallvec::SmallVec;\n \n-use std::borrow::Cow;\n use std::fmt::Write;\n \n use crate::debuginfo::wants_c_like_enum_debuginfo;\n@@ -98,7 +97,6 @@ fn push_debuginfo_type_name<'tcx>(\n \n             if let Some(ty_and_layout) = layout_for_cpp_like_fallback {\n                 msvc_enum_fallback(\n-                    tcx,\n                     ty_and_layout,\n                     &|output, visited| {\n                         push_item_name(tcx, def.did(), true, output);\n@@ -391,11 +389,10 @@ fn push_debuginfo_type_name<'tcx>(\n             // Name will be \"{closure_env#0}<T1, T2, ...>\", \"{generator_env#0}<T1, T2, ...>\", or\n             // \"{async_fn_env#0}<T1, T2, ...>\", etc.\n             // In the case of cpp-like debuginfo, the name additionally gets wrapped inside of\n-            // an artificial `enum$<>` type, as defined in msvc_enum_fallback().\n+            // an artificial `enum2$<>` type, as defined in msvc_enum_fallback().\n             if cpp_like_debuginfo && t.is_generator() {\n                 let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).unwrap();\n                 msvc_enum_fallback(\n-                    tcx,\n                     ty_and_layout,\n                     &|output, visited| {\n                         push_closure_or_generator_name(tcx, def_id, substs, true, output, visited);\n@@ -428,58 +425,17 @@ fn push_debuginfo_type_name<'tcx>(\n \n     /// MSVC names enums differently than other platforms so that the debugging visualization\n     // format (natvis) is able to understand enums and render the active variant correctly in the\n-    // debugger. For more information, look in `src/etc/natvis/intrinsic.natvis` and\n-    // `EnumMemberDescriptionFactor::create_member_descriptions`.\n+    // debugger. For more information, look in\n+    // rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs.\n     fn msvc_enum_fallback<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n         ty_and_layout: TyAndLayout<'tcx>,\n         push_inner: &dyn Fn(/*output*/ &mut String, /*visited*/ &mut FxHashSet<Ty<'tcx>>),\n         output: &mut String,\n         visited: &mut FxHashSet<Ty<'tcx>>,\n     ) {\n         debug_assert!(!wants_c_like_enum_debuginfo(ty_and_layout));\n-        let ty = ty_and_layout.ty;\n-\n-        output.push_str(\"enum$<\");\n+        output.push_str(\"enum2$<\");\n         push_inner(output, visited);\n-\n-        let variant_name = |variant_index| match ty.kind() {\n-            ty::Adt(adt_def, _) => {\n-                debug_assert!(adt_def.is_enum());\n-                Cow::from(adt_def.variant(variant_index).name.as_str())\n-            }\n-            ty::Generator(..) => GeneratorSubsts::variant_name(variant_index),\n-            _ => unreachable!(),\n-        };\n-\n-        if let Variants::Multiple {\n-            tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n-            tag,\n-            variants,\n-            ..\n-        } = &ty_and_layout.variants\n-        {\n-            let dataful_variant_layout = &variants[*dataful_variant];\n-\n-            // calculate the range of values for the dataful variant\n-            let dataful_discriminant_range =\n-                dataful_variant_layout.largest_niche().unwrap().valid_range;\n-\n-            let min = dataful_discriminant_range.start;\n-            let min = tag.size(&tcx).truncate(min);\n-\n-            let max = dataful_discriminant_range.end;\n-            let max = tag.size(&tcx).truncate(max);\n-\n-            let dataful_variant_name = variant_name(*dataful_variant);\n-            write!(output, \", {}, {}, {}\", min, max, dataful_variant_name).unwrap();\n-        } else if let Variants::Single { index: variant_idx } = &ty_and_layout.variants {\n-            // Uninhabited enums can't be constructed and should never need to be visualized so\n-            // skip this step for them.\n-            if !ty_and_layout.abi.is_uninhabited() {\n-                write!(output, \", {}\", variant_name(*variant_idx)).unwrap();\n-            }\n-        }\n         push_close_angle_bracket(true, output);\n     }\n "}, {"sha": "4172ce3bb306a22add12777d422cf05834e58ef4", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -172,7 +172,9 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn indices(&self) -> impl DoubleEndedIterator<Item = I> + ExactSizeIterator + 'static {\n+    pub fn indices(\n+        &self,\n+    ) -> impl DoubleEndedIterator<Item = I> + ExactSizeIterator + Clone + 'static {\n         (0..self.len()).map(|n| I::new(n))\n     }\n "}, {"sha": "f9bffe6d8239230f1d571e47b0660f89d6274d42", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -924,6 +924,30 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n                                                fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticMemberType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMMetadataRef Scope,\n+    const char *Name,\n+    size_t NameLen,\n+    LLVMMetadataRef File,\n+    unsigned LineNo,\n+    LLVMMetadataRef Ty,\n+    LLVMRustDIFlags Flags,\n+    LLVMValueRef val,\n+    uint32_t AlignInBits\n+) {\n+  return wrap(Builder->createStaticMemberType(\n+    unwrapDI<DIDescriptor>(Scope),\n+    StringRef(Name, NameLen),\n+    unwrapDI<DIFile>(File),\n+    LineNo,\n+    unwrapDI<DIType>(Ty),\n+    fromRust(Flags),\n+    unwrap<llvm::ConstantInt>(val),\n+    AlignInBits\n+  ));\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     LLVMMetadataRef File, unsigned Line, unsigned Col) {"}, {"sha": "277e57aaf6fc5ea4cd93efe9e1cdddf8a37f19f4", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 181, "deletions": 68, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -1,4 +1,4 @@\n-<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n   <Type Name=\"str\">\n     <DisplayString>{(char*)data_ptr,[length]s8}</DisplayString>\n@@ -150,76 +150,189 @@\n     </Expand>\n   </Type>\n \n-  <!-- Directly tagged enums. $T1 is the type name -->\n-  <Type Name=\"enum$&lt;*&gt;\">\n-    <Intrinsic Name=\"tag\" Expression=\"discriminant\" />\n-    <DisplayString Condition=\"tag() == 0\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 1\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 2\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 3\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 4\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 5\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 6\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 7\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 8\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 9\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 10\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 11\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 12\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 13\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 14\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 15\" Optional=\"true\">{tag(),en}</DisplayString>\n+  <!--\n+    This is the visualizer for all enums. It takes care of selecting the active variant.\n+    See `compiler\\rustc_codegen_llvm\\src\\debuginfo\\metadata\\enums\\cpp_like.rs` for more information.\n+  -->\n+  <Type Name=\"enum2$&lt;*&gt;\">\n+    <!-- NOTE: That tag ranges can wrap around, in which case `end` is less than `begin` and we\n+               have to do a different check -->\n+    <Intrinsic Name=\"in_range\" Expression=\"(begin &lt;= end) ? ((x &gt;= begin) &amp;&amp; (x &lt;= end)) : ((x &gt;= begin) || (x &lt;= end))\">\n+      <Parameter Name=\"x\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"begin\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-    <Expand>\n-      <Synthetic Name=\"[variant]\">\n-        <DisplayString>{tag(),en}</DisplayString>\n-      </Synthetic>\n-      <ExpandedItem Condition=\"tag() == 0\">variant0</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 1\" Optional=\"true\">variant1</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 2\" Optional=\"true\">variant2</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 3\" Optional=\"true\">variant3</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 4\" Optional=\"true\">variant4</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 5\" Optional=\"true\">variant5</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 6\" Optional=\"true\">variant6</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 7\" Optional=\"true\">variant7</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 8\" Optional=\"true\">variant8</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 9\" Optional=\"true\">variant9</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 10\" Optional=\"true\">variant10</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 11\" Optional=\"true\">variant11</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 12\" Optional=\"true\">variant12</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 13\" Optional=\"true\">variant13</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 14\" Optional=\"true\">variant14</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 15\" Optional=\"true\">variant15</ExpandedItem>\n-    </Expand>\n-  </Type>\n+    <Intrinsic Name=\"eq128\" Expression=\"(x_hi == y_hi) &amp;&amp; (x_lo == y_lo)\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-  <!-- Single variant enums. $T1 is the name of the enum, $T2 is the name of the variant -->\n-  <Type Name=\"enum$&lt;*, *&gt;\">\n-    <DisplayString>{\"$T2\",sb}</DisplayString>\n-    <Expand>\n-      <Synthetic Name=\"[variant]\">\n-        <DisplayString>{\"$T2\",sb}</DisplayString>\n-      </Synthetic>\n-      <ExpandedItem>$T2</ExpandedItem>\n-    </Expand>\n-  </Type>\n+    <Intrinsic Name=\"lt128\" Expression=\"(x_hi &lt; y_hi) || ((x_hi == y_hi) &amp;&amp; (x_lo &lt; y_lo))\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-  <!-- Niche-layout enums. $T1 is the name of the enum, $T2 is the low value of the dataful\n-       variant tag, $T3 is the high value of the dataful variant tag, $T4 is the name of\n-       the dataful variant -->\n-  <Type Name=\"enum$&lt;*, *, *, *&gt;\">\n-    <Intrinsic Name=\"tag\" Expression=\"discriminant\" />\n-    <Intrinsic Name=\"is_dataful\" Expression=\"tag() &gt;= $T2 &amp;&amp; tag() &lt;= $T3\" />\n-    <DisplayString Condition=\"is_dataful()\">{\"$T4\",sb}({dataful_variant})</DisplayString>\n-    <DisplayString Condition=\"!is_dataful()\">{discriminant,en}</DisplayString>\n-    <Expand>\n-      <ExpandedItem Condition=\"is_dataful()\">dataful_variant</ExpandedItem>\n-      <Synthetic Condition=\"is_dataful()\" Name=\"[variant]\">\n-        <DisplayString>{\"$T4\",sb}</DisplayString>\n-      </Synthetic>\n-      <Synthetic Condition=\"!is_dataful()\" Name=\"[variant]\">\n-        <DisplayString>{discriminant,en}</DisplayString>\n-      </Synthetic>\n+    <Intrinsic Name=\"lt_or_eq128\" Expression=\"((x_hi == y_hi) &amp;&amp; (x_lo == y_lo)) || lt128(x_hi, x_lo, y_hi, y_lo)\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n+\n+    <!-- NOTE: That tag ranges can wrap around, in which case `end` is less than `begin` and we\n+               have to do a different check -->\n+    <Intrinsic Name=\"in_range128\" Expression=\"(lt_or_eq128(begin_hi, begin_lo, end_hi, end_lo)) ?\n+                                              (lt_or_eq128(begin_hi, begin_lo, x_hi, x_lo) &amp;&amp; lt_or_eq128(x_hi, x_lo, end_hi, end_lo)) :\n+                                              (lt_or_eq128(begin_hi, begin_lo, x_hi, x_lo) || lt_or_eq128(x_hi, x_lo, end_hi, end_lo))\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"begin_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"begin_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n+\n+    <DisplayString Condition=\"tag == variant0.DISCR_EXACT\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant1.DISCR_EXACT\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant2.DISCR_EXACT\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant3.DISCR_EXACT\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant4.DISCR_EXACT\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant5.DISCR_EXACT\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant6.DISCR_EXACT\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant7.DISCR_EXACT\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant8.DISCR_EXACT\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant9.DISCR_EXACT\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant10.DISCR_EXACT\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant11.DISCR_EXACT\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant12.DISCR_EXACT\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant13.DISCR_EXACT\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant14.DISCR_EXACT\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant15.DISCR_EXACT\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <DisplayString Condition=\"in_range(tag, variant0.DISCR_BEGIN, variant0.DISCR_END)\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant1.DISCR_BEGIN, variant1.DISCR_END)\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant2.DISCR_BEGIN, variant2.DISCR_END)\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant3.DISCR_BEGIN, variant3.DISCR_END)\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant4.DISCR_BEGIN, variant4.DISCR_END)\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant5.DISCR_BEGIN, variant5.DISCR_END)\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant6.DISCR_BEGIN, variant6.DISCR_END)\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant7.DISCR_BEGIN, variant7.DISCR_END)\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant8.DISCR_BEGIN, variant8.DISCR_END)\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant9.DISCR_BEGIN, variant9.DISCR_END)\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant10.DISCR_BEGIN, variant10.DISCR_END)\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant11.DISCR_BEGIN, variant11.DISCR_END)\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant12.DISCR_BEGIN, variant12.DISCR_END)\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant13.DISCR_BEGIN, variant13.DISCR_END)\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant14.DISCR_BEGIN, variant14.DISCR_END)\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range(tag, variant15.DISCR_BEGIN, variant15.DISCR_END)\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant0.DISCR128_EXACT_HI, variant0.DISCR128_EXACT_LO)\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant1.DISCR128_EXACT_HI, variant1.DISCR128_EXACT_LO)\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant2.DISCR128_EXACT_HI, variant2.DISCR128_EXACT_LO)\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant3.DISCR128_EXACT_HI, variant3.DISCR128_EXACT_LO)\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant4.DISCR128_EXACT_HI, variant4.DISCR128_EXACT_LO)\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant5.DISCR128_EXACT_HI, variant5.DISCR128_EXACT_LO)\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant6.DISCR128_EXACT_HI, variant6.DISCR128_EXACT_LO)\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant7.DISCR128_EXACT_HI, variant7.DISCR128_EXACT_LO)\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant8.DISCR128_EXACT_HI, variant8.DISCR128_EXACT_LO)\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant9.DISCR128_EXACT_HI, variant9.DISCR128_EXACT_LO)\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant10.DISCR128_EXACT_HI, variant10.DISCR128_EXACT_LO)\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant11.DISCR128_EXACT_HI, variant11.DISCR128_EXACT_LO)\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant12.DISCR128_EXACT_HI, variant12.DISCR128_EXACT_LO)\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant13.DISCR128_EXACT_HI, variant13.DISCR128_EXACT_LO)\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant14.DISCR128_EXACT_HI, variant14.DISCR128_EXACT_LO)\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"eq128(tag128_hi, tag128_lo, variant15.DISCR128_EXACT_HI, variant15.DISCR128_EXACT_LO)\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant0.DISCR128_BEGIN_HI, variant0.DISCR128_BEGIN_LO, variant0.DISCR128_END_HI, variant0.DISCR128_END_LO)\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant1.DISCR128_BEGIN_HI, variant1.DISCR128_BEGIN_LO, variant1.DISCR128_END_HI, variant1.DISCR128_END_LO)\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant2.DISCR128_BEGIN_HI, variant2.DISCR128_BEGIN_LO, variant2.DISCR128_END_HI, variant2.DISCR128_END_LO)\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant3.DISCR128_BEGIN_HI, variant3.DISCR128_BEGIN_LO, variant3.DISCR128_END_HI, variant3.DISCR128_END_LO)\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant4.DISCR128_BEGIN_HI, variant4.DISCR128_BEGIN_LO, variant4.DISCR128_END_HI, variant4.DISCR128_END_LO)\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant5.DISCR128_BEGIN_HI, variant5.DISCR128_BEGIN_LO, variant5.DISCR128_END_HI, variant5.DISCR128_END_LO)\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant6.DISCR128_BEGIN_HI, variant6.DISCR128_BEGIN_LO, variant6.DISCR128_END_HI, variant6.DISCR128_END_LO)\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant7.DISCR128_BEGIN_HI, variant7.DISCR128_BEGIN_LO, variant7.DISCR128_END_HI, variant7.DISCR128_END_LO)\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant8.DISCR128_BEGIN_HI, variant8.DISCR128_BEGIN_LO, variant8.DISCR128_END_HI, variant8.DISCR128_END_LO)\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant9.DISCR128_BEGIN_HI, variant9.DISCR128_BEGIN_LO, variant9.DISCR128_END_HI, variant9.DISCR128_END_LO)\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant10.DISCR128_BEGIN_HI, variant10.DISCR128_BEGIN_LO, variant10.DISCR128_END_HI, variant10.DISCR128_END_LO)\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant11.DISCR128_BEGIN_HI, variant11.DISCR128_BEGIN_LO, variant11.DISCR128_END_HI, variant11.DISCR128_END_LO)\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant12.DISCR128_BEGIN_HI, variant12.DISCR128_BEGIN_LO, variant12.DISCR128_END_HI, variant12.DISCR128_END_LO)\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant13.DISCR128_BEGIN_HI, variant13.DISCR128_BEGIN_LO, variant13.DISCR128_END_HI, variant13.DISCR128_END_LO)\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant14.DISCR128_BEGIN_HI, variant14.DISCR128_BEGIN_LO, variant14.DISCR128_END_HI, variant14.DISCR128_END_LO)\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"in_range128(tag128_hi, tag128_lo, variant15.DISCR128_BEGIN_HI, variant15.DISCR128_BEGIN_LO, variant15.DISCR128_END_HI, variant15.DISCR128_END_LO)\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <Expand HideRawView=\"true\">\n+      <ExpandedItem Condition=\"tag == variant0.DISCR_EXACT\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant1.DISCR_EXACT\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant2.DISCR_EXACT\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant3.DISCR_EXACT\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant4.DISCR_EXACT\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant5.DISCR_EXACT\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant6.DISCR_EXACT\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant7.DISCR_EXACT\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant8.DISCR_EXACT\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant9.DISCR_EXACT\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant10.DISCR_EXACT\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant11.DISCR_EXACT\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant12.DISCR_EXACT\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant13.DISCR_EXACT\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant14.DISCR_EXACT\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant15.DISCR_EXACT\" Optional=\"true\">variant15.value</ExpandedItem>\n+\n+      <ExpandedItem Condition=\"in_range(tag, variant0.DISCR_BEGIN, variant0.DISCR_END)\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant1.DISCR_BEGIN, variant1.DISCR_END)\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant2.DISCR_BEGIN, variant2.DISCR_END)\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant3.DISCR_BEGIN, variant3.DISCR_END)\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant4.DISCR_BEGIN, variant4.DISCR_END)\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant5.DISCR_BEGIN, variant5.DISCR_END)\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant6.DISCR_BEGIN, variant6.DISCR_END)\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant7.DISCR_BEGIN, variant7.DISCR_END)\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant8.DISCR_BEGIN, variant8.DISCR_END)\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant9.DISCR_BEGIN, variant9.DISCR_END)\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant10.DISCR_BEGIN, variant10.DISCR_END)\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant11.DISCR_BEGIN, variant11.DISCR_END)\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant12.DISCR_BEGIN, variant12.DISCR_END)\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant13.DISCR_BEGIN, variant13.DISCR_END)\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant14.DISCR_BEGIN, variant14.DISCR_END)\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range(tag, variant15.DISCR_BEGIN, variant15.DISCR_END)\" Optional=\"true\">variant15.value</ExpandedItem>\n+\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant0.DISCR128_EXACT_HI, variant0.DISCR128_EXACT_LO)\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant1.DISCR128_EXACT_HI, variant1.DISCR128_EXACT_LO)\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant2.DISCR128_EXACT_HI, variant2.DISCR128_EXACT_LO)\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant3.DISCR128_EXACT_HI, variant3.DISCR128_EXACT_LO)\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant4.DISCR128_EXACT_HI, variant4.DISCR128_EXACT_LO)\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant5.DISCR128_EXACT_HI, variant5.DISCR128_EXACT_LO)\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant6.DISCR128_EXACT_HI, variant6.DISCR128_EXACT_LO)\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant7.DISCR128_EXACT_HI, variant7.DISCR128_EXACT_LO)\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant8.DISCR128_EXACT_HI, variant8.DISCR128_EXACT_LO)\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant9.DISCR128_EXACT_HI, variant9.DISCR128_EXACT_LO)\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant10.DISCR128_EXACT_HI, variant10.DISCR128_EXACT_LO)\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant11.DISCR128_EXACT_HI, variant11.DISCR128_EXACT_LO)\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant12.DISCR128_EXACT_HI, variant12.DISCR128_EXACT_LO)\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant13.DISCR128_EXACT_HI, variant13.DISCR128_EXACT_LO)\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant14.DISCR128_EXACT_HI, variant14.DISCR128_EXACT_LO)\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"eq128(tag128_hi, tag128_lo, variant15.DISCR128_EXACT_HI, variant15.DISCR128_EXACT_LO)\" Optional=\"true\">variant15.value</ExpandedItem>\n+\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant0.DISCR128_BEGIN_HI, variant0.DISCR128_BEGIN_LO, variant0.DISCR128_END_HI, variant0.DISCR128_END_LO)\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant1.DISCR128_BEGIN_HI, variant1.DISCR128_BEGIN_LO, variant1.DISCR128_END_HI, variant1.DISCR128_END_LO)\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant2.DISCR128_BEGIN_HI, variant2.DISCR128_BEGIN_LO, variant2.DISCR128_END_HI, variant2.DISCR128_END_LO)\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant3.DISCR128_BEGIN_HI, variant3.DISCR128_BEGIN_LO, variant3.DISCR128_END_HI, variant3.DISCR128_END_LO)\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant4.DISCR128_BEGIN_HI, variant4.DISCR128_BEGIN_LO, variant4.DISCR128_END_HI, variant4.DISCR128_END_LO)\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant5.DISCR128_BEGIN_HI, variant5.DISCR128_BEGIN_LO, variant5.DISCR128_END_HI, variant5.DISCR128_END_LO)\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant6.DISCR128_BEGIN_HI, variant6.DISCR128_BEGIN_LO, variant6.DISCR128_END_HI, variant6.DISCR128_END_LO)\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant7.DISCR128_BEGIN_HI, variant7.DISCR128_BEGIN_LO, variant7.DISCR128_END_HI, variant7.DISCR128_END_LO)\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant8.DISCR128_BEGIN_HI, variant8.DISCR128_BEGIN_LO, variant8.DISCR128_END_HI, variant8.DISCR128_END_LO)\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant9.DISCR128_BEGIN_HI, variant9.DISCR128_BEGIN_LO, variant9.DISCR128_END_HI, variant9.DISCR128_END_LO)\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant10.DISCR128_BEGIN_HI, variant10.DISCR128_BEGIN_LO, variant10.DISCR128_END_HI, variant10.DISCR128_END_LO)\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant11.DISCR128_BEGIN_HI, variant11.DISCR128_BEGIN_LO, variant11.DISCR128_END_HI, variant11.DISCR128_END_LO)\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant12.DISCR128_BEGIN_HI, variant12.DISCR128_BEGIN_LO, variant12.DISCR128_END_HI, variant12.DISCR128_END_LO)\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant13.DISCR128_BEGIN_HI, variant13.DISCR128_BEGIN_LO, variant13.DISCR128_END_HI, variant13.DISCR128_END_LO)\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant14.DISCR128_BEGIN_HI, variant14.DISCR128_BEGIN_LO, variant14.DISCR128_END_HI, variant14.DISCR128_END_LO)\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"in_range128(tag128_hi, tag128_lo, variant15.DISCR128_BEGIN_HI, variant15.DISCR128_BEGIN_LO, variant15.DISCR128_END_HI, variant15.DISCR128_END_LO)\" Optional=\"true\">variant15.value</ExpandedItem>\n     </Expand>\n   </Type>\n </AutoVisualizer>"}, {"sha": "bf6c02b91461a973f77f6cdce891719ff3423e11", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -185,12 +185,4 @@\n       </ArrayItems>\n     </Expand>\n   </Type>\n-\n-  <Type Name=\"alloc::borrow::Cow&lt;*&gt;\">\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x0\">Borrowed({__0})</DisplayString>\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x1\">Owned({__0})</DisplayString>\n-    <Expand>\n-      <Item Name=\"[value]\" ExcludeView=\"simple\">__0</Item>\n-    </Expand>\n-  </Type>\n </AutoVisualizer>"}, {"sha": "909cd0062a623050a02e6fcb98695e60295fc013", "filename": "src/test/codegen/async-fn-debug-awaitee-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-awaitee-field.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -12,11 +12,11 @@ async fn async_fn_test() {\n }\n \n // NONMSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"{async_fn_env#0}\",\n-// MSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum$<async_fn_debug_awaitee_field::async_fn_test::async_fn_env$0>\",\n+// MSVC: [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum2$<async_fn_debug_awaitee_field::async_fn_test::async_fn_env$0>\",\n // CHECK: [[SUSPEND_STRUCT:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend0\", scope: [[GEN]],\n // CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"__awaitee\", scope: [[SUSPEND_STRUCT]], {{.*}}, baseType: [[AWAITEE_TYPE:![0-9]*]],\n // NONMSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"GenFuture<async_fn_debug_awaitee_field::foo::{async_fn_env#0}>\",\n-// MSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"GenFuture<enum$<async_fn_debug_awaitee_field::foo::async_fn_env$0> >\",\n+// MSVC: [[AWAITEE_TYPE]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"GenFuture<enum2$<async_fn_debug_awaitee_field::foo::async_fn_env$0> >\",\n \n fn main() {\n     let _fn = async_fn_test();"}, {"sha": "73c652c9dd15ea3a87323f63628b2f5f356309e7", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -16,7 +16,7 @@ async fn async_fn_test() {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum$<async_fn_debug_msvc::async_fn_test::async_fn_env$0>\",\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum2$<async_fn_debug_msvc::async_fn_test::async_fn_env$0>\",\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n@@ -36,16 +36,17 @@ async fn async_fn_test() {\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant4\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 14,\n-// CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n+// CHECK-SAME: baseType: [[VARIANT_WRAPPER:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"value\", scope: [[VARIANT_WRAPPER]], file: !2, baseType: [[VARIANT:![0-9]*]],\n // CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"tag\", scope: [[GEN]],\n // CHECK-NOT: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "bdd312878ec887bb5ade80915bdde69fce5060f7", "filename": "src/test/codegen/debug-vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdebug-vtable.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -46,7 +46,7 @@\n // CHECK: !DIDerivedType(tag: DW_TAG_member, name: \"align\", scope: ![[VTABLE_TY2]], {{.*}}, baseType: ![[USIZE]], size: {{64|32}}, align: {{64|32}}, offset: {{128|64}})\n \n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::bar::{closure_env#0} as core::ops::function::FnOnce<(core::option::Option<&dyn core::ops::function::Fn<(), Output=()>>)>>::{vtable}\"\n-// MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::bar::closure_env$0, core::ops::function::FnOnce<tuple$<enum$<core::option::Option<ref$<dyn$<core::ops::function::Fn<tuple$<>,assoc$<Output,tuple$<> > > > > >, {{.*}}, {{.*}}, Some> > > >::vtable$\"\n+// MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::bar::closure_env$0, core::ops::function::FnOnce<tuple$<enum2$<core::option::Option<ref$<dyn$<core::ops::function::Fn<tuple$<>,assoc$<Output,tuple$<> > > > > > > > > >::vtable$\"\n \n // NONMSVC: !DIGlobalVariable(name: \"<debug_vtable::generic_closure::{closure_env#0}<bool> as core::ops::function::FnOnce<()>>::{vtable}\"\n // MSVC: !DIGlobalVariable(name: \"impl$<debug_vtable::generic_closure::closure_env$0<bool>, core::ops::function::FnOnce<tuple$<> > >::vtable$"}, {"sha": "b712068bf27f2ab9790ef7741df57ee3df78f8d3", "filename": "src/test/codegen/generator-debug-msvc.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -20,7 +20,7 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n \n // FIXME: No way to reliably check the filename.\n \n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum$<generator_debug_msvc::generator_test::generator_env$0>\"\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"enum2$<generator_debug_msvc::generator_test::generator_env$0>\"\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 14,\n@@ -40,16 +40,18 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant4\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 17,\n-// CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n+// CHECK-SAME: baseType: [[VARIANT_WRAPPER:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n+// CHECK:      [[VARIANT_WRAPPER]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Variant4\", scope: [[GEN]],\n+// CHECK:      !DIDerivedType(tag: DW_TAG_member, name: \"value\", scope: [[VARIANT_WRAPPER]], {{.*}}, baseType: [[VARIANT:![0-9]*]],\n // CHECK:      [[VARIANT]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[VARIANT]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"discriminant\", scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"tag\", scope: [[GEN]],\n // CHECK-NOT: flags: DIFlagArtificial\n \n fn main() {"}, {"sha": "11c4ae2f65929c4e7d63268f197c3036647b4592", "filename": "src/test/debuginfo/generator-objects.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -41,31 +41,26 @@\n \n // cdb-command: g\n // cdb-command: dx b\n-// cdb-check: b                : Unresumed [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Unresumed\n+// cdb-check: b                : Unresumed [Type: enum2$<generator_objects::main::generator_env$0>]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n-// cdb-check: b                : Suspend0 [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Suspend0\n+// cdb-check: b                : Suspend0 [Type: enum2$<generator_objects::main::generator_env$0>]\n // cdb-check:    [+0x[...]] c                : 6 [Type: int]\n // cdb-check:    [+0x[...]] d                : 7 [Type: int]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n-// cdb-check: b                : Suspend1 [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Suspend1\n+// cdb-check: b                : Suspend1 [Type: enum2$<generator_objects::main::generator_env$0>]\n // cdb-check:    [+0x[...]] c                : 7 [Type: int]\n // cdb-check:    [+0x[...]] d                : 8 [Type: int]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n-// cdb-check: b                : Returned [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Returned\n+// cdb-check: b                : Returned [Type: enum2$<generator_objects::main::generator_env$0>]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n \n #![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]"}, {"sha": "45d5ddf5c0ebc8644832c112986c09bf5840418a", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "modified", "additions": 179, "deletions": 33, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -4,69 +4,141 @@\n // cdb-command: g\n \n // cdb-command: dx a\n-// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:a                : Some [Type: enum2$<core::option::Option<msvc_pretty_enums::CStyleEnum> >]\n // cdb-check:    [+0x000] __0              : Low (0x2) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx b\n-// cdb-check:b                : None [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [variant]        : None\n+// cdb-check:b                : None [Type: enum2$<core::option::Option<msvc_pretty_enums::CStyleEnum> >]\n \n // cdb-command: dx c\n-// cdb-check:c                : Tag1 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        : Tag1\n+// cdb-check:c                : Tag1 [Type: enum2$<msvc_pretty_enums::NicheLayoutEnum>]\n \n // cdb-command: dx d\n-// cdb-check:d                :  Data({...}) [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        :  Data\n+// cdb-check:d                : Data [Type: enum2$<msvc_pretty_enums::NicheLayoutEnum>]\n // cdb-check:    [+0x000] my_data          : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx e\n-// cdb-check:e                : Tag2 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        : Tag2\n+// cdb-check:e                : Tag2 [Type: enum2$<msvc_pretty_enums::NicheLayoutEnum>]\n \n // cdb-command: dx f\n-// cdb-check:f                :  Some({...}) [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:f                : Some [Type: enum2$<core::option::Option<ref$<u32> > >]\n // cdb-check:    [+0x000] __0              : 0x[...] : 0x1 [Type: unsigned int *]\n \n // cdb-command: dx g\n-// cdb-check:g                : None [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [variant]        : None\n+// cdb-check:g                : None [Type: enum2$<core::option::Option<ref$<u32> > >]\n \n // cdb-command: dx h\n-// cdb-check:h                : Some [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : Some\n+// cdb-check:h                : Some [Type: enum2$<core::option::Option<u32> >]\n // cdb-check:    [+0x004] __0              : 0xc [Type: unsigned int]\n \n // cdb-command: dx i\n-// cdb-check:i                : None [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : None\n+// cdb-check:i                : None [Type: enum2$<core::option::Option<u32> >]\n \n // cdb-command: dx j\n // cdb-check:j                : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx k\n-// cdb-check:k                :  Some({...}) [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:k                : Some [Type: enum2$<core::option::Option<alloc::string::String> >]\n // cdb-check:    [+0x000] __0              : \"IAMA optional string!\" [Type: alloc::string::String]\n \n // cdb-command: dx l\n-// cdb-check:l                :  Ok [Type: enum$<core::result::Result<u32,enum$<msvc_pretty_enums::Empty> >, Ok>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::result::Result<u32,enum$<msvc_pretty_enums::Empty> >, Ok>]\n-// cdb-check:    [variant]        :  Ok\n+// cdb-check:l                : Ok [Type: enum2$<core::result::Result<u32,enum2$<msvc_pretty_enums::Empty> > >]\n // cdb-check:    [+0x000] __0              : 0x2a [Type: unsigned int]\n \n+// cdb-command: dx niche128_some\n+// cdb-check: niche128_some    : Some [Type: enum2$<core::option::Option<core::num::nonzero::NonZeroI128> >]\n+// Note: we can't actually read the value of the field because CDB cannot handle 128 bit integers.\n+// cdb-check:    [+0x000] __0 [...] [Type: core::num::nonzero::NonZeroI128]\n+\n+// cdb-command: dx niche128_none\n+// cdb-check: niche128_none    : None [Type: enum2$<core::option::Option<core::num::nonzero::NonZeroI128> >]\n+\n+// cdb-command: dx wrapping_niche128_dataful\n+// cdb-check: wrapping_niche128_dataful : X [Type: enum2$<msvc_pretty_enums::Wrapping128Niche>]\n+// cdb-check:    [+0x[...]] __0              [Type: msvc_pretty_enums::Wrapping128]\n+\n+// cdb-command: dx wrapping_niche128_none1\n+// cdb-check: wrapping_niche128_none1 : Y [Type: enum2$<msvc_pretty_enums::Wrapping128Niche>]\n+// cdb-check:    [+0x[...]] __0              [Type: msvc_pretty_enums::Wrapping128]\n+\n+// cdb-command: dx wrapping_niche128_none2\n+// cdb-check: wrapping_niche128_none2 : Z [Type: enum2$<msvc_pretty_enums::Wrapping128Niche>]\n+// cdb-check:    [+0x[...]] __0              [Type: msvc_pretty_enums::Wrapping128]\n+\n+// cdb-command: dx direct_tag_128_a,d\n+// cdb-check: direct_tag_128_a,d : A [Type: enum2$<msvc_pretty_enums::DirectTag128>]\n+// cdb-check:     [+0x[...]] __0              : 42 [Type: unsigned int]\n+\n+// cdb-command: dx direct_tag_128_b,d\n+// cdb-check: direct_tag_128_b,d : B [Type: enum2$<msvc_pretty_enums::DirectTag128>]\n+// cdb-check:     [+0x[...]] __0              : 137 [Type: unsigned int]\n+\n+// cdb-command: dx niche_w_fields_1_some,d\n+// cdb-check: niche_w_fields_1_some,d : A [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields1>]\n+// cdb-check:     [+0x[...]] __0              : 0x[...] : 77 [Type: unsigned char *]\n+// cdb-check:     [+0x[...]] __1              : 7 [Type: unsigned int]\n+\n+// cdb-command: dx niche_w_fields_1_none,d\n+// cdb-check: niche_w_fields_1_none,d : B [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields1>]\n+// cdb-check:     [+0x[...]] __0              : 99 [Type: unsigned int]\n+\n+// cdb-command: dx niche_w_fields_2_some,d\n+// cdb-check: niche_w_fields_2_some,d : A [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields2>]\n+// cdb-check:     [+0x[...]] __0              : 800 [Type: core::num::nonzero::NonZeroU32]\n+// cdb-check:     [+0x[...]] __1              : 900 [Type: unsigned __int64]\n+\n+// cdb-command: dx niche_w_fields_2_none,d\n+// cdb-check: niche_w_fields_2_none,d : B [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields2>]\n+// cdb-check:     [+0x[...]] __0              : 1000 [Type: unsigned __int64]\n+\n+// cdb-command: dx niche_w_fields_3_some,d\n+// cdb-check: niche_w_fields_3_some,d : A [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 137 [Type: unsigned char]\n+// cdb-check:     [+0x[...]] __1              : true [Type: bool]\n+\n+// cdb-command: dx niche_w_fields_3_niche1,d\n+// cdb-check: niche_w_fields_3_niche1,d : B [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 12 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche2,d\n+// cdb-check: niche_w_fields_3_niche2,d : C [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : false [Type: bool]\n+\n+// cdb-command: dx niche_w_fields_3_niche3,d\n+// cdb-check: niche_w_fields_3_niche3,d : D [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 34 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche4,d\n+// cdb-check: niche_w_fields_3_niche4,d : E [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 56 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche5,d\n+// cdb-check: niche_w_fields_3_niche5,d : F [Type: enum2$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+\n+// cdb-command: dx -r3 niche_w_fields_std_result_ok,d\n+// cdb-check: niche_w_fields_std_result_ok,d : Ok [Type: enum2$<core::result::Result<alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>,u64> >]\n+// cdb-check:    [+0x[...]] __0              [Type: alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>]\n+// cdb-check:        [+0x[...]] data_ptr         : [...]\n+// cdb-check:        [+0x[...]] length           : 3 [...]\n+\n+// cdb-command: dx -r3 niche_w_fields_std_result_err,d\n+// cdb-check: niche_w_fields_std_result_err,d : Err [Type: enum2$<core::result::Result<alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>,u64> >]\n+// cdb-check:    [+0x[...]] __0              : 789 [Type: unsigned __int64]\n+\n+// cdb-command: dx -r2 arbitrary_discr1,d\n+// cdb-check: arbitrary_discr1,d : Abc [Type: enum2$<msvc_pretty_enums::ArbitraryDiscr>]\n+// cdb-check:     [+0x[...]] __0              : 1234 [Type: unsigned int]\n+\n+// cdb-command: dx -r2 arbitrary_discr2,d\n+// cdb-check: arbitrary_discr2,d : Def [Type: enum2$<msvc_pretty_enums::ArbitraryDiscr>]\n+// cdb-check:     [+0x[...]] __0              : 5678 [Type: unsigned int]\n+\n+#![feature(rustc_attrs)]\n+#![feature(repr128)]\n+#![feature(arbitrary_enum_discriminant)]\n+\n+use std::num::{NonZeroI128, NonZeroU32};\n+\n pub enum CStyleEnum {\n     Low = 2,\n     High = 16,\n@@ -80,6 +152,51 @@ pub enum NicheLayoutEnum {\n \n pub enum Empty {}\n \n+// The following three types will use a niche layout once\n+// https://github.com/rust-lang/rust/pull/94075 is merged:\n+enum NicheLayoutWithFields1<'a> {\n+    A(&'a u8, u32),\n+    B(u32),\n+}\n+\n+enum NicheLayoutWithFields2 {\n+    A(NonZeroU32, u64),\n+    B(u64),\n+}\n+\n+enum NicheLayoutWithFields3 {\n+    A(u8, bool),\n+    B(u8),\n+    C(bool),\n+    D(u8),\n+    E(u8),\n+    F,\n+}\n+\n+#[rustc_layout_scalar_valid_range_start(340282366920938463463374607431768211454)]\n+#[rustc_layout_scalar_valid_range_end(1)]\n+#[repr(transparent)]\n+struct Wrapping128(u128);\n+\n+// #[rustc_layout(debug)]\n+enum Wrapping128Niche {\n+    X(Wrapping128),\n+    Y,\n+    Z,\n+}\n+\n+#[repr(i128)]\n+enum DirectTag128 {\n+    A(u32),\n+    B(u32),\n+}\n+\n+#[repr(u32)]\n+enum ArbitraryDiscr {\n+    Abc(u32) = 1000,\n+    Def(u32) = 5000_000,\n+}\n+\n fn main() {\n     let a = Some(CStyleEnum::Low);\n     let b = Option::<CStyleEnum>::None;\n@@ -93,6 +210,35 @@ fn main() {\n     let j = CStyleEnum::High;\n     let k = Some(\"IAMA optional string!\".to_string());\n     let l = Result::<u32, Empty>::Ok(42);\n+    let niche128_some = Some(NonZeroI128::new(123456).unwrap());\n+    let niche128_none: Option<NonZeroI128> = None;\n+\n+    let wrapping_niche128_dataful =\n+        unsafe { Wrapping128Niche::X(Wrapping128(340282366920938463463374607431768211454)) };\n+    let wrapping_niche128_none1 = Wrapping128Niche::Y;\n+    let wrapping_niche128_none2 = Wrapping128Niche::Z;\n+\n+    let direct_tag_128_a = DirectTag128::A(42);\n+    let direct_tag_128_b = DirectTag128::B(137);\n+\n+    let niche_w_fields_1_some = NicheLayoutWithFields1::A(&77, 7);\n+    let niche_w_fields_1_none = NicheLayoutWithFields1::B(99);\n+\n+    let niche_w_fields_2_some = NicheLayoutWithFields2::A(NonZeroU32::new(800).unwrap(), 900);\n+    let niche_w_fields_2_none = NicheLayoutWithFields2::B(1000);\n+\n+    let niche_w_fields_3_some = NicheLayoutWithFields3::A(137, true);\n+    let niche_w_fields_3_niche1 = NicheLayoutWithFields3::B(12);\n+    let niche_w_fields_3_niche2 = NicheLayoutWithFields3::C(false);\n+    let niche_w_fields_3_niche3 = NicheLayoutWithFields3::D(34);\n+    let niche_w_fields_3_niche4 = NicheLayoutWithFields3::E(56);\n+    let niche_w_fields_3_niche5 = NicheLayoutWithFields3::F;\n+\n+    let niche_w_fields_std_result_ok: Result<Box<[u8]>, u64> = Ok(vec![1, 2, 3].into());\n+    let niche_w_fields_std_result_err: Result<Box<[u8]>, u64> = Err(789);\n+\n+    let arbitrary_discr1 = ArbitraryDiscr::Abc(1234);\n+    let arbitrary_discr2 = ArbitraryDiscr::Def(5678);\n \n     zzz(); // #break\n }"}, {"sha": "9630952cbaae0c41b44c5b8e390b97201bac3392", "filename": "src/test/debuginfo/msvc-scalarpair-params.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -18,12 +18,10 @@\n // cdb-command: g\n \n // cdb-command: dx o1\n-// cdb-check:o1               : Some [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : Some\n+// cdb-check:o1               : Some [Type: enum2$<core::option::Option<u32> >]\n // cdb-check:    [+0x004] __0              : 0x4d2 [Type: [...]]\n // cdb-command: dx o2\n-// cdb-check:o2               : Some [Type: enum$<core::option::Option<u64> >]\n-// cdb-check:    [variant]        : Some\n+// cdb-check:o2               : Some [Type: enum2$<core::option::Option<u64> >]\n // cdb-check:    [+0x008] __0              : 0x162e [Type: unsigned __int64]\n \n // cdb-command: g\n@@ -89,7 +87,7 @@ fn slice(s: &[u8]) {\n     zzz(); // #break\n }\n \n-fn zzz() { }\n+fn zzz() {}\n \n fn main() {\n     range(10..12, 20..30);"}, {"sha": "314ba40b0e3d0b8a4208d565fca78fd0a80d34ca", "filename": "src/test/debuginfo/mutex.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmutex.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -20,19 +20,20 @@\n // cdb-check:    [<Raw View>]     [Type: core::cell::UnsafeCell<i32>]\n \n //\n-// cdb-command:dx lock,d\n-// cdb-check:lock,d           : Ok [Type: enum$<core::result::Result<std::sync::mutex::MutexGuard<i32>,enum$<std::sync::poison::TryLockError<std::sync::mutex::MutexGuard<i32> >, 0, 1, Poisoned> > >]\n-// cdb-check:    [variant]        : Ok\n+// cdb-command:dx _lock,d\n+// cdb-check:_lock,d          : Ok [Type: enum2$<core::result::Result<std::sync::mutex::MutexGuard<i32>,enum2$<std::sync::poison::TryLockError<std::sync::mutex::MutexGuard<i32> > > > >]\n // cdb-check:    [...] __0              [Type: std::sync::mutex::MutexGuard<i32>]\n \n use std::sync::Mutex;\n \n-#[allow(unused_variables)]\n-fn main()\n-{\n+fn main() {\n     let m = Mutex::new(0);\n-    let lock = m.try_lock();\n+    let _lock = m.try_lock();\n+\n+    println!(\"this line avoids an `Ambiguous symbol error` while setting the breakpoint\");\n+\n     zzz(); // #break\n }\n \n+#[inline(never)]\n fn zzz() {}"}, {"sha": "a51b37205e8aa2cb8cd443b6b3f6035af8106871", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -39,7 +39,6 @@\n // gdb-command: print some_string\n // gdb-check:$8 = Some = {\"IAMA \"...}\n \n-\n // === LLDB TESTS ==================================================================================\n \n // lldb-command: run\n@@ -65,7 +64,6 @@\n // lldb-command: print os_string\n // lldb-check:[...]$6 = \"IAMA OS string \ud83d\ude03\"[...]\n \n-\n // === CDB TESTS ==================================================================================\n \n // cdb-command: g\n@@ -118,20 +116,17 @@\n // cdb-check:    [chars]          : \"IAMA OS string [...]\"\n \n // cdb-command: dx some\n-// cdb-check:some             : Some [Type: enum$<core::option::Option<i16> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<i16> >]\n-// cdb-check:    [variant]        : Some\n+// cdb-check:some             : Some [Type: enum2$<core::option::Option<i16> >]\n+// cdb-check:    [<Raw View>]     [Type: enum2$<core::option::Option<i16> >]\n // cdb-check:    [+0x002] __0              : 8 [Type: short]\n \n // cdb-command: dx none\n-// cdb-check:none             : None [Type: enum$<core::option::Option<i64> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<i64> >]\n-// cdb-check:    [variant]        : None\n+// cdb-check:none             : None [Type: enum2$<core::option::Option<i64> >]\n+// cdb-check:    [<Raw View>]     [Type: enum2$<core::option::Option<i64> >]\n \n // cdb-command: dx some_string\n-// cdb-check:some_string      :  Some({...}) [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:some_string      : Some [Type: enum2$<core::option::Option<alloc::string::String> >]\n+// cdb-check:    [<Raw View>]     [Type: enum2$<core::option::Option<alloc::string::String> >]\n // cdb-check:    [+0x000] __0              : \"IAMA optional string!\" [Type: alloc::string::String]\n \n // cdb-command: dx linkedlist\n@@ -153,7 +148,6 @@ use std::collections::{LinkedList, VecDeque};\n use std::ffi::OsString;\n \n fn main() {\n-\n     // &[]\n     let slice: &[i32] = &[0, 1, 2, 3];\n \n@@ -188,4 +182,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "cdac47a784d94339567d2d713d9abaede6b4b610", "filename": "src/test/debuginfo/result-types.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fresult-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Fresult-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fresult-types.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -7,15 +7,14 @@\n // cdb-command: g\n \n // cdb-command: dx x,d\n-// cdb-check:x,d              : Ok [Type: enum$<core::result::Result<i32,str> >]\n+// cdb-check:x,d              : Ok [Type: enum2$<core::result::Result<i32,str> >]\n // cdb-check:    [...] __0              : -3 [Type: int]\n \n // cdb-command: dx y\n-// cdb-check:y                : Err [Type: enum$<core::result::Result<i32,str> >]\n+// cdb-check:y                : Err [Type: enum2$<core::result::Result<i32,str> >]\n // cdb-check:    [...] __0              : \"Some error message\" [Type: str]\n \n-fn main()\n-{\n+fn main() {\n     let x: Result<i32, &str> = Ok(-3);\n     assert_eq!(x.is_ok(), true);\n \n@@ -25,4 +24,6 @@ fn main()\n     zzz(); // #break.\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "9cc99d7767c1f927a635b29d66f53a9631249b89", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -175,51 +175,51 @@\n // 0-sized structs appear to be optimized away in some cases, so only check the structs that do\n // actually appear.\n // cdb-command:dv /t *_struct\n-// cdb-check:struct type_names::GenericStruct<enum$<type_names::mod1::Enum2>,f64> mut_generic_struct = [...]\n+// cdb-check:struct type_names::GenericStruct<enum2$<type_names::mod1::Enum2>,f64> mut_generic_struct = [...]\n \n // ENUMS\n // cdb-command:dv /t *_enum_*\n-// cdb-check:union enum$<type_names::Enum1> simple_enum_1 = [...]\n-// cdb-check:union enum$<type_names::Enum1> simple_enum_2 = [...]\n-// cdb-check:union enum$<type_names::mod1::Enum2> simple_enum_3 = [...]\n-// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > generic_enum_1 = [...]\n-// cdb-check:union enum$<type_names::mod1::mod2::Enum3<type_names::Struct1> > generic_enum_2 = [...]\n+// cdb-check:union enum2$<type_names::Enum1> simple_enum_1 = [...]\n+// cdb-check:union enum2$<type_names::Enum1> simple_enum_2 = [...]\n+// cdb-check:union enum2$<type_names::mod1::Enum2> simple_enum_3 = [...]\n+// cdb-check:union enum2$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > generic_enum_1 = [...]\n+// cdb-check:union enum2$<type_names::mod1::mod2::Enum3<type_names::Struct1> > generic_enum_2 = [...]\n \n // TUPLES\n // cdb-command:dv /t tuple*\n-// cdb-check:struct tuple$<u32,type_names::Struct1,enum$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > > tuple1 = [...]\n-// cdb-check:struct tuple$<tuple$<type_names::Struct1,type_names::mod1::mod2::Struct3>,enum$<type_names::mod1::Enum2>,char> tuple2 = [...]\n+// cdb-check:struct tuple$<u32,type_names::Struct1,enum2$<type_names::mod1::mod2::Enum3<type_names::mod1::Struct2> > > tuple1 = [...]\n+// cdb-check:struct tuple$<tuple$<type_names::Struct1,type_names::mod1::mod2::Struct3>,enum2$<type_names::mod1::Enum2>,char> tuple2 = [...]\n \n // BOX\n // cdb-command:dv /t box*\n // cdb-check:struct tuple$<alloc::boxed::Box<f32,alloc::alloc::Global>,i32> box1 = [...]\n-// cdb-check:struct tuple$<alloc::boxed::Box<enum$<type_names::mod1::mod2::Enum3<f32> >,alloc::alloc::Global>,i32> box2 = [...]\n+// cdb-check:struct tuple$<alloc::boxed::Box<enum2$<type_names::mod1::mod2::Enum3<f32> >,alloc::alloc::Global>,i32> box2 = [...]\n \n // REFERENCES\n // cdb-command:dv /t *ref*\n // cdb-check:struct tuple$<ref$<type_names::Struct1>,i32> ref1 = [...]\n // cdb-check:struct tuple$<ref$<type_names::GenericStruct<char,type_names::Struct1> >,i32> ref2 = [...]\n // cdb-check:struct tuple$<ref_mut$<type_names::Struct1>,i32> mut_ref1 = [...]\n-// cdb-check:struct tuple$<ref_mut$<type_names::GenericStruct<enum$<type_names::mod1::Enum2>,f64> >,i32> mut_ref2 = [...]\n+// cdb-check:struct tuple$<ref_mut$<type_names::GenericStruct<enum2$<type_names::mod1::Enum2>,f64> >,i32> mut_ref2 = [...]\n \n // RAW POINTERS\n // cdb-command:dv /t *_ptr*\n // cdb-check:struct tuple$<ptr_mut$<type_names::Struct1>,isize> mut_ptr1 = [...]\n // cdb-check:struct tuple$<ptr_mut$<isize>,isize> mut_ptr2 = [...]\n-// cdb-check:struct tuple$<ptr_mut$<enum$<type_names::mod1::mod2::Enum3<type_names::Struct1> > >,isize> mut_ptr3 = [...]\n+// cdb-check:struct tuple$<ptr_mut$<enum2$<type_names::mod1::mod2::Enum3<type_names::Struct1> > >,isize> mut_ptr3 = [...]\n // cdb-check:struct tuple$<ptr_const$<type_names::Struct1>,isize> const_ptr1 = [...]\n // cdb-check:struct tuple$<ptr_const$<isize>,isize> const_ptr2 = [...]\n-// cdb-check:struct tuple$<ptr_const$<enum$<type_names::mod1::mod2::Enum3<type_names::Struct1> > >,isize> const_ptr3 = [...]\n+// cdb-check:struct tuple$<ptr_const$<enum2$<type_names::mod1::mod2::Enum3<type_names::Struct1> > >,isize> const_ptr3 = [...]\n \n // VECTORS\n // cdb-command:dv /t *vec*\n // cdb-check:struct tuple$<array$<type_names::Struct1,3>,i16> fixed_size_vec1 = [...]\n // cdb-check:struct tuple$<array$<usize,3>,i16> fixed_size_vec2 = [...]\n // cdb-check:struct alloc::vec::Vec<usize,alloc::alloc::Global> vec1 = [...]\n-// cdb-check:struct alloc::vec::Vec<enum$<type_names::mod1::Enum2>,alloc::alloc::Global> vec2 = [...]\n+// cdb-check:struct alloc::vec::Vec<enum2$<type_names::mod1::Enum2>,alloc::alloc::Global> vec2 = [...]\n // cdb-command:dv /t slice*\n // cdb-check:struct slice$<usize> slice1 = [...]\n-// cdb-check:struct slice$<enum$<type_names::mod1::Enum2> > slice2 = [...]\n+// cdb-check:struct slice$<enum2$<type_names::mod1::Enum2> > slice2 = [...]\n \n // TRAITS\n // cdb-command:dv /t *_trait\n@@ -238,16 +238,16 @@\n // cdb-check:struct tuple$<type_names::mod1::Struct2 (*)(type_names::GenericStruct<u16,u8>),usize> unsafe_fn_with_return_value = [...]\n // cdb-check:struct tuple$<type_names::Struct1 (*)(),usize> extern_c_fn_with_return_value = [...]\n // cdb-check:struct tuple$<usize (*)(f64),usize> rust_fn_with_return_value = [...]\n-// cdb-check:struct tuple$<void (*)(enum$<core::result::Result<char,f64> >),usize> unsafe_fn = [...]\n+// cdb-check:struct tuple$<void (*)(enum2$<core::result::Result<char,f64> >),usize> unsafe_fn = [...]\n // cdb-check:struct tuple$<void (*)(isize),usize> extern_c_fn = [...]\n-// cdb-check:struct tuple$<void (*)(enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>),usize> rust_fn = [...]\n+// cdb-check:struct tuple$<void (*)(enum2$<core::option::Option<isize> >,enum2$<core::option::Option<ref$<type_names::mod1::Struct2> > >),usize> rust_fn = [...]\n // cdb-command:dv /t *_function*\n // cdb-check:struct tuple$<isize (*)(ptr_const$<u8>, ...),usize> variadic_function = [...]\n // cdb-check:struct tuple$<type_names::mod1::mod2::Struct3 (*)(type_names::mod1::mod2::Struct3),usize> generic_function_struct3 = [...]\n // cdb-check:struct tuple$<isize (*)(isize),usize> generic_function_int = [...]\n // cdb-command:dx Debugger.State.Scripts.@\"type-names.cdb\".Contents.getFunctionDetails(\"rust_fn\")\n // cdb-check:Return Type: void\n-// cdb-check:Parameter Types: enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>\n+// cdb-check:Parameter Types: enum2$<core::option::Option<isize> >,enum2$<core::option::Option<ref$<type_names::mod1::Struct2> > >\n // cdb-command:dx Debugger.State.Scripts.@\"type-names.cdb\".Contents.getFunctionDetails(\"rust_fn_with_return_value\")\n // cdb-check:Return Type: usize\n // cdb-check:Parameter Types: f64"}, {"sha": "0e2cc52a645bcbdc982476ecc0c723e39bf0bda7", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=4916e2b9e6ef8cee6f9c6abb75bd01ba9dc07e5c", "patch": "@@ -545,6 +545,8 @@ fn common_inputs_stamp(config: &Config) -> Stamp {\n         stamp.add_path(&path);\n     }\n \n+    stamp.add_dir(&rust_src_dir.join(\"src/etc/natvis\"));\n+\n     stamp.add_dir(&config.run_lib_path);\n \n     if let Some(ref rustdoc_path) = config.rustdoc_path {"}]}