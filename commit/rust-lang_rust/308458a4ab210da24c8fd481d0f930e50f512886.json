{"sha": "308458a4ab210da24c8fd481d0f930e50f512886", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwODQ1OGE0YWIyMTBkYTI0YzhmZDQ4MWQwZjkzMGU1MGY1MTI4ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T20:47:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-06T20:47:34Z"}, "message": "Auto merge of #1396 - RalfJung:float-cast-tests, r=RalfJung\n\ncopy some float cast tests from rustc\n\nThe more the merrirer!", "tree": {"sha": "bf7c5ed58bb5fa6a9f6a9400cd071a7024f749d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf7c5ed58bb5fa6a9f6a9400cd071a7024f749d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/308458a4ab210da24c8fd481d0f930e50f512886", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/308458a4ab210da24c8fd481d0f930e50f512886", "html_url": "https://github.com/rust-lang/rust/commit/308458a4ab210da24c8fd481d0f930e50f512886", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/308458a4ab210da24c8fd481d0f930e50f512886/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2e283bf6aba3e7528f0a9e1c92dc870f0bed91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e283bf6aba3e7528f0a9e1c92dc870f0bed91e", "html_url": "https://github.com/rust-lang/rust/commit/d2e283bf6aba3e7528f0a9e1c92dc870f0bed91e"}, {"sha": "da6846c8a953c065ec868d91d4e40d0b4dda4659", "url": "https://api.github.com/repos/rust-lang/rust/commits/da6846c8a953c065ec868d91d4e40d0b4dda4659", "html_url": "https://github.com/rust-lang/rust/commit/da6846c8a953c065ec868d91d4e40d0b4dda4659"}], "stats": {"total": 113, "additions": 112, "deletions": 1}, "files": [{"sha": "3347b0a07c26a6395a95b6368c3911403f1f3779", "filename": "tests/run-pass/float.rs", "status": "modified", "additions": 112, "deletions": 1, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/308458a4ab210da24c8fd481d0f930e50f512886/tests%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/308458a4ab210da24c8fd481d0f930e50f512886/tests%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffloat.rs?ref=308458a4ab210da24c8fd481d0f930e50f512886", "patch": "@@ -1,4 +1,4 @@\n-#![feature(track_caller)]\n+#![feature(track_caller, stmt_expr_attributes)]\n use std::fmt::Debug;\n \n // Helper function to avoid promotion so that this tests \"run-time\" casts, not CTFE.\n@@ -78,6 +78,7 @@ fn test_both_cast<F, I>(x: F, y: I)\n fn main() {\n     basic();\n     casts();\n+    more_casts();\n     ops();\n }\n \n@@ -334,3 +335,113 @@ fn ops() {\n     assert_eq((-3.5_f64).copysign(-0.42), -3.5_f64);\n     assert!(f64::NAN.copysign(1.0).is_nan());\n }\n+\n+/// Tests taken from rustc test suite.\n+///\n+\n+// Poor-man's black-box\n+#[inline(never)]\n+fn black_box<T>(x: T) -> T { x }\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+macro_rules! common_fptoi_tests {\n+    ($fty:ident -> $($ity:ident)+) => ({ $(\n+        test!($fty::NAN, $fty -> $ity, 0);\n+        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n+        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n+        // These two tests are not solely float->int tests, in particular the latter relies on\n+        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n+        // as well, the test is just slightly misplaced.\n+        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n+        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.9, $fty -> $ity, 0);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        common_fptoi_tests!(f32 -> $($ity)+);\n+        common_fptoi_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+macro_rules! fptoui_tests {\n+    ($fty: ident -> $($ity: ident)+) => ({ $(\n+        test!(-0., $fty -> $ity, 0);\n+        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.99999994, $fty -> $ity, 0);\n+        test!(-1., $fty -> $ity, 0);\n+        test!(-100., $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        fptoui_tests!(f32 -> $($ity)+);\n+        fptoui_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+fn more_casts() {\n+    common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n+    fptoui_tests!(f* -> u8 u16 u32 u64);\n+    common_fptoi_tests!(f* -> i128 u128);\n+    fptoui_tests!(f* -> u128);\n+\n+    // The following tests cover edge cases for some integer types.\n+\n+    // # u8\n+    test!(254., f* -> u8, 254);\n+    test!(256., f* -> u8, 255);\n+\n+    // # i8\n+    test!(-127., f* -> i8, -127);\n+    test!(-129., f* -> i8, -128);\n+    test!(126., f* -> i8, 126);\n+    test!(128., f* -> i8, 127);\n+\n+    // # i32\n+    // -2147483648. is i32::MIN (exactly)\n+    test!(-2147483648., f* -> i32, i32::MIN);\n+    // 2147483648. is i32::MAX rounded up\n+    test!(2147483648., f32 -> i32, 2147483647);\n+    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n+    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n+    test!(2147483520., f32 -> i32, 2147483520);\n+    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n+    test!(-2147483904., f* -> i32, i32::MIN);\n+    test!(-2147483520., f* -> i32, -2147483520);\n+\n+    // # u32\n+    // round(MAX) and nextUp(round(MAX))\n+    test!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967296., f* -> u32, 4294967295);\n+\n+    // # u128\n+    // float->int:\n+    test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+    // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+    const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+    test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+}"}]}