{"sha": "2ba36ec62934c8b877766a6283633b6407c8d357", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTM2ZWM2MjkzNGM4Yjg3Nzc2NmE2MjgzNjMzYjY0MDdjOGQzNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T14:47:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T14:47:14Z"}, "message": "auto merge of #8327 : sstewartgallus/rust/factor_out_waitqueue, r=bblum\n\nI'm a bit disappointed that I couldn't figure out how to factor out more of the code implementing `extra::sync` but I feel this is an okay start. Also I added some documentation explaining that `WaitQueue` isn't thread safe, and needs an exclusive lock.\r\n \r\n@bblum", "tree": {"sha": "04185bd1ac2556cb5d97e87667164e28435d259a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04185bd1ac2556cb5d97e87667164e28435d259a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba36ec62934c8b877766a6283633b6407c8d357", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba36ec62934c8b877766a6283633b6407c8d357", "html_url": "https://github.com/rust-lang/rust/commit/2ba36ec62934c8b877766a6283633b6407c8d357", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba36ec62934c8b877766a6283633b6407c8d357/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e70aac572ac9dd6e1b8f7f434e77c602c1fa0d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70aac572ac9dd6e1b8f7f434e77c602c1fa0d0e", "html_url": "https://github.com/rust-lang/rust/commit/e70aac572ac9dd6e1b8f7f434e77c602c1fa0d0e"}, {"sha": "1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e576a35eb7e1eeb2c4a2d0c03955490337891c1", "html_url": "https://github.com/rust-lang/rust/commit/1e576a35eb7e1eeb2c4a2d0c03955490337891c1"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "756a5c7da006594a0efcec42dcdaf2ffe83c21e0", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ba36ec62934c8b877766a6283633b6407c8d357/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba36ec62934c8b877766a6283633b6407c8d357/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=2ba36ec62934c8b877766a6283633b6407c8d357", "patch": "@@ -72,6 +72,12 @@ impl WaitQueue {\n         }\n         count\n     }\n+\n+    fn wait_end(&self) -> WaitEnd {\n+        let (wait_end, signal_end) = comm::oneshot();\n+        self.tail.send_deferred(signal_end);\n+        wait_end\n+    }\n }\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n@@ -100,12 +106,9 @@ impl<Q:Send> Sem<Q> {\n             do (**self).with |state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n-                    // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = comm::oneshot();\n-                    // Tell outer scope we need to block.\n-                    waiter_nobe = Some(WaitEnd);\n-                    // Enqueue ourself.\n-                    state.waiters.tail.send_deferred(SignalEnd);\n+                    // Create waiter nobe, enqueue ourself, and tell\n+                    // outer scope we need to block.\n+                    waiter_nobe = Some(state.waiters.wait_end());\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -201,10 +204,7 @@ impl<'self> Condvar<'self> {\n      * wait() is equivalent to wait_on(0).\n      */\n     pub fn wait_on(&self, condvar_id: uint) {\n-        // Create waiter nobe.\n-        let (WaitEnd, SignalEnd) = comm::oneshot();\n-        let mut WaitEnd   = Some(WaitEnd);\n-        let mut SignalEnd = Some(SignalEnd);\n+        let mut WaitEnd = None;\n         let mut out_of_bounds = None;\n         do task::unkillable {\n             // Release lock, 'atomically' enqueuing ourselves in so doing.\n@@ -216,9 +216,9 @@ impl<'self> Condvar<'self> {\n                         if state.count <= 0 {\n                             state.waiters.signal();\n                         }\n-                        // Enqueue ourself to be woken up by a signaller.\n-                        let SignalEnd = SignalEnd.take_unwrap();\n-                        state.blocked[condvar_id].tail.send_deferred(SignalEnd);\n+                        // Create waiter nobe, and enqueue ourself to\n+                        // be woken up by a signaller.\n+                        WaitEnd = Some(state.blocked[condvar_id].wait_end());\n                     } else {\n                         out_of_bounds = Some(state.blocked.len());\n                     }"}]}