{"sha": "617417e9ad355e61a466640165d32680ee017198", "node_id": "C_kwDOAAsO6NoAKDYxNzQxN2U5YWQzNTVlNjFhNDY2NjQwMTY1ZDMyNjgwZWUwMTcxOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T19:55:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-07T19:55:34Z"}, "message": "Auto merge of #9365 - c410-f3r:arith, r=Alexendoo\n\n[Arithmetic] Consider literals\n\nFixes https://github.com/rust-lang/rust-clippy/issues/9307 and makes the `arithmetic` lint behave like `integer_arithmetic`.\n\nIt is worth noting that literal integers of a binary operation (`1 + 1`, `i32::MAX + 1`), **regardless if they are in a constant environment**, won't trigger the lint. Assign operations also have similar reasoning.\n\nchangelog: Consider literals in the arithmetic lint", "tree": {"sha": "01534a1d289bb15e0b5d1dd121c155a8bdc05601", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01534a1d289bb15e0b5d1dd121c155a8bdc05601"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/617417e9ad355e61a466640165d32680ee017198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/617417e9ad355e61a466640165d32680ee017198", "html_url": "https://github.com/rust-lang/rust/commit/617417e9ad355e61a466640165d32680ee017198", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/617417e9ad355e61a466640165d32680ee017198/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da29f8928d929309cec7ae06828659a634567d9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/da29f8928d929309cec7ae06828659a634567d9f", "html_url": "https://github.com/rust-lang/rust/commit/da29f8928d929309cec7ae06828659a634567d9f"}, {"sha": "0d078c9fd6881a011713d810773aec03e17d793f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d078c9fd6881a011713d810773aec03e17d793f", "html_url": "https://github.com/rust-lang/rust/commit/0d078c9fd6881a011713d810773aec03e17d793f"}], "stats": {"total": 248, "additions": 168, "deletions": 80}, "files": [{"sha": "27eef92deef4fac2f9d707ac3fd96ceb3042dd6f", "filename": "clippy_lints/src/operators/arithmetic.rs", "status": "modified", "additions": 86, "deletions": 32, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/617417e9ad355e61a466640165d32680ee017198/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617417e9ad355e61a466640165d32680ee017198/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Farithmetic.rs?ref=617417e9ad355e61a466640165d32680ee017198", "patch": "@@ -5,13 +5,21 @@\n \n use super::ARITHMETIC;\n use clippy_utils::{consts::constant_simple, diagnostics::span_lint};\n+use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n use rustc_session::impl_lint_pass;\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{Span, Spanned};\n \n-const HARD_CODED_ALLOWED: &[&str] = &[\"std::num::Saturating\", \"std::string::String\", \"std::num::Wrapping\"];\n+const HARD_CODED_ALLOWED: &[&str] = &[\n+    \"f32\",\n+    \"f64\",\n+    \"std::num::Saturating\",\n+    \"std::string::String\",\n+    \"std::num::Wrapping\",\n+];\n \n #[derive(Debug)]\n pub struct Arithmetic {\n@@ -34,6 +42,27 @@ impl Arithmetic {\n         }\n     }\n \n+    /// Checks assign operators (+=, -=, *=, /=) of integers in a non-constant environment that\n+    /// won't overflow.\n+    fn has_valid_assign_op(op: &Spanned<hir::BinOpKind>, rhs: &hir::Expr<'_>, rhs_refs: Ty<'_>) -> bool {\n+        if !Self::is_literal_integer(rhs, rhs_refs) {\n+            return false;\n+        }\n+        if let hir::BinOpKind::Div | hir::BinOpKind::Mul = op.node\n+            && let hir::ExprKind::Lit(ref lit) = rhs.kind\n+            && let ast::LitKind::Int(1, _) = lit.node\n+        {\n+            return true;\n+        }\n+        false\n+    }\n+\n+    /// Checks \"raw\" binary operators (+, -, *, /) of integers in a non-constant environment\n+    /// already handled by the CTFE.\n+    fn has_valid_bin_op(lhs: &hir::Expr<'_>, lhs_refs: Ty<'_>, rhs: &hir::Expr<'_>, rhs_refs: Ty<'_>) -> bool {\n+        Self::is_literal_integer(lhs, lhs_refs) && Self::is_literal_integer(rhs, rhs_refs)\n+    }\n+\n     /// Checks if the given `expr` has any of the inner `allowed` elements.\n     fn is_allowed_ty(&self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n         self.allowed.contains(\n@@ -46,40 +75,66 @@ impl Arithmetic {\n         )\n     }\n \n+    /// Explicit integers like `1` or `i32::MAX`. Does not take into consideration references.\n+    fn is_literal_integer(expr: &hir::Expr<'_>, expr_refs: Ty<'_>) -> bool {\n+        let is_integral = expr_refs.is_integral();\n+        let is_literal = matches!(expr.kind, hir::ExprKind::Lit(_));\n+        is_integral && is_literal\n+    }\n+\n     fn issue_lint(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n         span_lint(cx, ARITHMETIC, expr.span, \"arithmetic detected\");\n         self.expr_span = Some(expr.span);\n     }\n+\n+    /// Manages when the lint should be triggered. Operations in constant environments, hard coded\n+    /// types, custom allowed types and non-constant operations that won't overflow are ignored.\n+    fn manage_bin_ops(\n+        &mut self,\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        op: &Spanned<hir::BinOpKind>,\n+        lhs: &hir::Expr<'_>,\n+        rhs: &hir::Expr<'_>,\n+    ) {\n+        if constant_simple(cx, cx.typeck_results(), expr).is_some() {\n+            return;\n+        }\n+        if !matches!(\n+            op.node,\n+            hir::BinOpKind::Add\n+                | hir::BinOpKind::Sub\n+                | hir::BinOpKind::Mul\n+                | hir::BinOpKind::Div\n+                | hir::BinOpKind::Rem\n+                | hir::BinOpKind::Shl\n+                | hir::BinOpKind::Shr\n+        ) {\n+            return;\n+        };\n+        if self.is_allowed_ty(cx, lhs) || self.is_allowed_ty(cx, rhs) {\n+            return;\n+        }\n+        let lhs_refs = cx.typeck_results().expr_ty(lhs).peel_refs();\n+        let rhs_refs = cx.typeck_results().expr_ty(rhs).peel_refs();\n+        let has_valid_assign_op = Self::has_valid_assign_op(op, rhs, rhs_refs);\n+        if has_valid_assign_op || Self::has_valid_bin_op(lhs, lhs_refs, rhs, rhs_refs) {\n+            return;\n+        }\n+        self.issue_lint(cx, expr);\n+    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if self.expr_span.is_some() {\n-            return;\n-        }\n-        if let Some(span) = self.const_span && span.contains(expr.span) {\n+        if self.expr_span.is_some() || self.const_span.map_or(false, |sp| sp.contains(expr.span)) {\n             return;\n         }\n         match &expr.kind {\n             hir::ExprKind::Binary(op, lhs, rhs) | hir::ExprKind::AssignOp(op, lhs, rhs) => {\n-                let (\n-                    hir::BinOpKind::Add\n-                    | hir::BinOpKind::Sub\n-                    | hir::BinOpKind::Mul\n-                    | hir::BinOpKind::Div\n-                    | hir::BinOpKind::Rem\n-                    | hir::BinOpKind::Shl\n-                    | hir::BinOpKind::Shr\n-                ) = op.node else {\n-                    return;\n-                };\n-                if self.is_allowed_ty(cx, lhs) || self.is_allowed_ty(cx, rhs) {\n-                    return;\n-                }\n-                self.issue_lint(cx, expr);\n+                self.manage_bin_ops(cx, expr, op, lhs, rhs);\n             },\n             hir::ExprKind::Unary(hir::UnOp::Neg, _) => {\n-                // CTFE already takes care of things like `-1` that do not overflow.\n                 if constant_simple(cx, cx.typeck_results(), expr).is_none() {\n                     self.issue_lint(cx, expr);\n                 }\n@@ -89,16 +144,15 @@ impl<'tcx> LateLintPass<'tcx> for Arithmetic {\n     }\n \n     fn check_body(&mut self, cx: &LateContext<'_>, body: &hir::Body<'_>) {\n-        let body_owner = cx.tcx.hir().body_owner_def_id(body.id());\n-        match cx.tcx.hir().body_owner_kind(body_owner) {\n-            hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                let body_span = cx.tcx.def_span(body_owner);\n-                if let Some(span) = self.const_span && span.contains(body_span) {\n-                    return;\n-                }\n-                self.const_span = Some(body_span);\n-            },\n-            hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => {},\n+        let body_owner = cx.tcx.hir().body_owner(body.id());\n+        let body_owner_def_id = cx.tcx.hir().local_def_id(body_owner);\n+        let body_owner_kind = cx.tcx.hir().body_owner_kind(body_owner_def_id);\n+        if let hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) = body_owner_kind {\n+            let body_span = cx.tcx.hir().span_with_body(body_owner);\n+            if let Some(span) = self.const_span && span.contains(body_span) {\n+                return;\n+            }\n+            self.const_span = Some(body_span);\n         }\n     }\n "}, {"sha": "c7b0633b79ca491fba614d06cd4aa7a4f789b8bf", "filename": "clippy_lints/src/operators/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/617417e9ad355e61a466640165d32680ee017198/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617417e9ad355e61a466640165d32680ee017198/clippy_lints%2Fsrc%2Foperators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fmod.rs?ref=617417e9ad355e61a466640165d32680ee017198", "patch": "@@ -61,25 +61,29 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for any kind of arithmetic operation of any type.\n+    /// Checks any kind of arithmetic operation of any type.\n     ///\n     /// Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n     /// Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-    /// or can panic (`/`, `%`). Known safe built-in types like `Wrapping` or `Saturing` are filtered\n-    /// away.\n+    /// or can panic (`/`, `%`).\n+    ///\n+    /// Known safe built-in types like `Wrapping` or `Saturing`, floats, operations in constant\n+    /// environments, allowed types and non-constant operations that won't overflow are ignored.\n     ///\n     /// ### Why is this bad?\n-    /// Integer overflow will trigger a panic in debug builds or will wrap in\n-    /// release mode. Division by zero will cause a panic in either mode. In some applications one\n-    /// wants explicitly checked, wrapping or saturating arithmetic.\n+    /// For integers, overflow will trigger a panic in debug builds or wrap the result in\n+    /// release mode; division by zero will cause a panic in either mode. As a result, it is\n+    /// desirable to explicitly call checked, wrapping or saturating arithmetic methods.\n     ///\n     /// #### Example\n     /// ```rust\n-    /// # let a = 0;\n-    /// a + 1;\n+    /// // `n` can be any number, including `i32::MAX`.\n+    /// fn foo(n: i32) -> i32 {\n+    ///   n + 1\n+    /// }\n     /// ```\n     ///\n-    /// Third-party types also tend to overflow.\n+    /// Third-party types can also overflow or present unwanted side-effects.\n     ///\n     /// #### Example\n     /// ```ignore,rust"}, {"sha": "f04125060fbdff09f63e5bb487d0cb11e40c355c", "filename": "src/docs/arithmetic.txt", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/617417e9ad355e61a466640165d32680ee017198/src%2Fdocs%2Farithmetic.txt", "raw_url": "https://github.com/rust-lang/rust/raw/617417e9ad355e61a466640165d32680ee017198/src%2Fdocs%2Farithmetic.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Farithmetic.txt?ref=617417e9ad355e61a466640165d32680ee017198", "patch": "@@ -1,22 +1,27 @@\n ### What it does\n-Checks for any kind of arithmetic operation of any type.\n+Checks any kind of arithmetic operation of any type.\n \n Operators like `+`, `-`, `*` or `<<` are usually capable of overflowing according to the [Rust\n Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow),\n-or can panic (`/`, `%`). Known safe built-in types like `Wrapping` or `Saturing` are filtered\n-away.\n+or can panic (`/`, `%`).\n+\n+Known safe built-in types like `Wrapping` or `Saturing`, floats, operations in constant\n+environments, allowed types and non-constant operations that won't overflow are ignored.\n \n ### Why is this bad?\n-Integer overflow will trigger a panic in debug builds or will wrap in\n-release mode. Division by zero will cause a panic in either mode. In some applications one\n-wants explicitly checked, wrapping or saturating arithmetic.\n+For integers, overflow will trigger a panic in debug builds or wrap the result in\n+release mode; division by zero will cause a panic in either mode. As a result, it is\n+desirable to explicitly call checked, wrapping or saturating arithmetic methods.\n \n #### Example\n ```\n-a + 1;\n+// `n` can be any number, including `i32::MAX`.\n+fn foo(n: i32) -> i32 {\n+  n + 1\n+}\n ```\n \n-Third-party types also tend to overflow.\n+Third-party types can also overflow or present unwanted side-effects.\n \n #### Example\n ```"}, {"sha": "a2a1c4394c21f73eeb1f01a182a419362cbf2b05", "filename": "tests/ui/arithmetic.fixed", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/da29f8928d929309cec7ae06828659a634567d9f/tests%2Fui%2Farithmetic.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/da29f8928d929309cec7ae06828659a634567d9f/tests%2Fui%2Farithmetic.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic.fixed?ref=da29f8928d929309cec7ae06828659a634567d9f", "patch": "@@ -1,27 +0,0 @@\n-// run-rustfix\n-\n-#![allow(clippy::unnecessary_owned_empty_strings)]\n-#![feature(saturating_int_impl)]\n-#![warn(clippy::arithmetic)]\n-\n-use core::num::{Saturating, Wrapping};\n-\n-pub fn hard_coded_allowed() {\n-    let _ = Saturating(0u32) + Saturating(0u32);\n-    let _ = String::new() + \"\";\n-    let _ = Wrapping(0u32) + Wrapping(0u32);\n-\n-    let saturating: Saturating<u32> = Saturating(0u32);\n-    let string: String = String::new();\n-    let wrapping: Wrapping<u32> = Wrapping(0u32);\n-\n-    let inferred_saturating = saturating + saturating;\n-    let inferred_string = string + \"\";\n-    let inferred_wrapping = wrapping + wrapping;\n-\n-    let _ = inferred_saturating + inferred_saturating;\n-    let _ = inferred_string + \"\";\n-    let _ = inferred_wrapping + inferred_wrapping;\n-}\n-\n-fn main() {}"}, {"sha": "a9ac46e9a190accaf021abaabb8370f8749dc7de", "filename": "tests/ui/arithmetic.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/617417e9ad355e61a466640165d32680ee017198/tests%2Fui%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/617417e9ad355e61a466640165d32680ee017198/tests%2Fui%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic.rs?ref=617417e9ad355e61a466640165d32680ee017198", "patch": "@@ -1,12 +1,13 @@\n-// run-rustfix\n-\n-#![allow(clippy::unnecessary_owned_empty_strings)]\n-#![feature(saturating_int_impl)]\n+#![allow(clippy::assign_op_pattern, clippy::unnecessary_owned_empty_strings)]\n+#![feature(inline_const, saturating_int_impl)]\n #![warn(clippy::arithmetic)]\n \n use core::num::{Saturating, Wrapping};\n \n pub fn hard_coded_allowed() {\n+    let _ = 1f32 + 1f32;\n+    let _ = 1f64 + 1f64;\n+\n     let _ = Saturating(0u32) + Saturating(0u32);\n     let _ = String::new() + \"\";\n     let _ = Wrapping(0u32) + Wrapping(0u32);\n@@ -24,4 +25,33 @@ pub fn hard_coded_allowed() {\n     let _ = inferred_wrapping + inferred_wrapping;\n }\n \n+#[rustfmt::skip]\n+pub fn non_overflowing_ops() {\n+    const _: i32 = { let mut n = 1; n += 1; n };\n+    let _ = const { let mut n = 1; n += 1; n };\n+\n+    const _: i32 = { let mut n = 1; n = n + 1; n };\n+    let _ = const { let mut n = 1; n = n + 1; n };\n+\n+    const _: i32 = { let mut n = 1; n = 1 + n; n };\n+    let _ = const { let mut n = 1; n = 1 + n; n };\n+\n+    const _: i32 = 1 + 1;\n+    let _ = 1 + 1;\n+    let _ = const { 1 + 1 };\n+\n+    let mut _a = 1;\n+    _a *= 1;\n+    _a /= 1;\n+}\n+\n+#[rustfmt::skip]\n+pub fn overflowing_ops() {\n+    let mut _a = 1; _a += 1;\n+\n+    let mut _b = 1; _b = _b + 1;\n+\n+    let mut _c = 1; _c = 1 + _c;\n+}\n+\n fn main() {}"}, {"sha": "a51cf6ba60059805d58a5b1c45057a0b7260f733", "filename": "tests/ui/arithmetic.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/617417e9ad355e61a466640165d32680ee017198/tests%2Fui%2Farithmetic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/617417e9ad355e61a466640165d32680ee017198/tests%2Fui%2Farithmetic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Farithmetic.stderr?ref=617417e9ad355e61a466640165d32680ee017198", "patch": "@@ -0,0 +1,22 @@\n+error: arithmetic detected\n+  --> $DIR/arithmetic.rs:50:21\n+   |\n+LL |     let mut _a = 1; _a += 1;\n+   |                     ^^^^^^^\n+   |\n+   = note: `-D clippy::arithmetic` implied by `-D warnings`\n+\n+error: arithmetic detected\n+  --> $DIR/arithmetic.rs:52:26\n+   |\n+LL |     let mut _b = 1; _b = _b + 1;\n+   |                          ^^^^^^\n+\n+error: arithmetic detected\n+  --> $DIR/arithmetic.rs:54:26\n+   |\n+LL |     let mut _c = 1; _c = 1 + _c;\n+   |                          ^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}