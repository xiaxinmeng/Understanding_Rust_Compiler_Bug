{"sha": "6af1e632a974b78b62895e8cb918b889cf613882", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZjFlNjMyYTk3NGI3OGI2Mjg5NWU4Y2I5MThiODg5Y2Y2MTM4ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-20T08:33:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-20T08:33:51Z"}, "message": "Auto merge of #84323 - richkadel:uncovered-functions, r=tmandry\n\ncoverage of async function bodies should match non-async\n\nThis fixes some missing coverage within async function bodies.\n\nCommit 1 demonstrates the problem in the fixed issue, and commit 2 corrects it.\n\nFixes: #83985", "tree": {"sha": "231461a9cc863dd74799601b79b507b053645b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/231461a9cc863dd74799601b79b507b053645b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6af1e632a974b78b62895e8cb918b889cf613882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6af1e632a974b78b62895e8cb918b889cf613882", "html_url": "https://github.com/rust-lang/rust/commit/6af1e632a974b78b62895e8cb918b889cf613882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6af1e632a974b78b62895e8cb918b889cf613882/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a70fbf6620ddaacc2ef805fa8c4ac2dc9bf02f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70fbf6620ddaacc2ef805fa8c4ac2dc9bf02f3c", "html_url": "https://github.com/rust-lang/rust/commit/a70fbf6620ddaacc2ef805fa8c4ac2dc9bf02f3c"}, {"sha": "5d8d67f746a2955635de8c2168c972b4d6e7eb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8d67f746a2955635de8c2168c972b4d6e7eb58", "html_url": "https://github.com/rust-lang/rust/commit/5d8d67f746a2955635de8c2168c972b4d6e7eb58"}], "stats": {"total": 199, "additions": 194, "deletions": 5}, "files": [{"sha": "067e1001def883740e13f4759ffe51aa327ad10a", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6af1e632a974b78b62895e8cb918b889cf613882/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af1e632a974b78b62895e8cb918b889cf613882/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=6af1e632a974b78b62895e8cb918b889cf613882", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n \n use rustc_span::source_map::original_sp;\n-use rustc_span::{BytePos, Span, SyntaxContext};\n+use rustc_span::{BytePos, Span};\n \n use std::cmp::Ordering;\n \n@@ -246,7 +246,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     ) -> Vec<CoverageSpan> {\n         let mut coverage_spans = CoverageSpans {\n             mir_body,\n-            fn_sig_span,\n+            fn_sig_span: fn_sig_source_span(fn_sig_span, body_span),\n             body_span,\n             basic_coverage_blocks,\n             sorted_spans_iter: None,\n@@ -731,8 +731,13 @@ pub(super) fn filtered_terminator_span(\n     }\n }\n \n+#[inline]\n+fn fn_sig_source_span(fn_sig_span: Span, body_span: Span) -> Span {\n+    original_sp(fn_sig_span, body_span).with_ctxt(body_span.ctxt())\n+}\n+\n #[inline]\n fn function_source_span(span: Span, body_span: Span) -> Span {\n-    let span = original_sp(span, body_span).with_ctxt(SyntaxContext::root());\n+    let span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n     if body_span.contains(span) { span } else { body_span }\n }"}, {"sha": "ae9487473d0ca9bbf761601ffa6c7fbde242ab59", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async.txt?ref=6af1e632a974b78b62895e8cb918b889cf613882", "patch": "@@ -1,6 +1,6 @@\n     1|       |#![allow(unused_assignments, dead_code)]\n     2|       |\n-    3|       |// compile-flags: --edition=2018 -C opt-level=1 # fix in rustc_mir/monomorphize/partitioning/mod.rs\n+    3|       |// compile-flags: --edition=2018 -C opt-level=1\n     4|       |\n     5|      1|async fn c(x: u8) -> u8 {\n     6|      1|    if x == 8 {"}, {"sha": "8a445433ab65fd61af91d318f8751b4581cc107b", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=6af1e632a974b78b62895e8cb918b889cf613882", "patch": "@@ -0,0 +1,115 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |\n+    3|       |use core::{\n+    4|       |    future::Future,\n+    5|       |    marker::Send,\n+    6|       |    pin::Pin,\n+    7|       |};\n+    8|       |\n+    9|      1|fn non_async_func() {\n+   10|      1|    println!(\"non_async_func was covered\");\n+   11|      1|    let b = true;\n+   12|      1|    if b {\n+   13|      1|        println!(\"non_async_func println in block\");\n+   14|      1|    }\n+   15|      1|}\n+   16|       |\n+   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include\n+   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n+   19|       |// non-async function above, unless the `println!()` is inside a covered block.\n+   20|      1|async fn async_func() {\n+   21|      1|    println!(\"async_func was covered\");\n+   22|      1|    let b = true;\n+   23|      1|    if b {\n+   24|      1|        println!(\"async_func println in block\");\n+   25|      1|    }\n+                   ^0\n+   26|      1|}\n+   27|       |\n+   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n+   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n+   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n+   31|      1|async fn async_func_just_println() {\n+   32|      1|    println!(\"async_func_just_println was covered\");\n+   33|      1|}\n+   34|       |\n+   35|      1|fn main() {\n+   36|      1|    println!(\"codecovsample::main\");\n+   37|      1|\n+   38|      1|    non_async_func();\n+   39|      1|\n+   40|      1|    executor::block_on(async_func());\n+   41|      1|    executor::block_on(async_func_just_println());\n+   42|      1|}\n+   43|       |\n+   44|       |mod executor {\n+   45|       |    use core::{\n+   46|       |        future::Future,\n+   47|       |        pin::Pin,\n+   48|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+   49|       |    };\n+   50|       |\n+   51|      2|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+   52|      2|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+   53|      2|        use std::hint::unreachable_unchecked;\n+   54|      2|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+   55|      2|            |_| unsafe { unreachable_unchecked() }, // clone\n+                              ^0\n+   56|      2|            |_| unsafe { unreachable_unchecked() }, // wake\n+                              ^0\n+   57|      2|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+                              ^0\n+   58|      2|            |_| (),\n+   59|      2|        );\n+   60|      2|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+   61|      2|        let mut context = Context::from_waker(&waker);\n+   62|       |\n+   63|       |        loop {\n+   64|      2|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+   65|      2|                break val;\n+   66|      0|            }\n+   67|       |        }\n+   68|      2|    }\n+  ------------------\n+  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func::{closure#0}>>:\n+  |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   53|      1|        use std::hint::unreachable_unchecked;\n+  |   54|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   55|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   56|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   57|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   58|      1|            |_| (),\n+  |   59|      1|        );\n+  |   60|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   61|      1|        let mut context = Context::from_waker(&waker);\n+  |   62|       |\n+  |   63|       |        loop {\n+  |   64|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   65|      1|                break val;\n+  |   66|      0|            }\n+  |   67|       |        }\n+  |   68|      1|    }\n+  ------------------\n+  | async2::executor::block_on::<core::future::from_generator::GenFuture<async2::async_func_just_println::{closure#0}>>:\n+  |   51|      1|    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+  |   52|      1|        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+  |   53|      1|        use std::hint::unreachable_unchecked;\n+  |   54|      1|        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+  |   55|      1|            |_| unsafe { unreachable_unchecked() }, // clone\n+  |   56|      1|            |_| unsafe { unreachable_unchecked() }, // wake\n+  |   57|      1|            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+  |   58|      1|            |_| (),\n+  |   59|      1|        );\n+  |   60|      1|        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+  |   61|      1|        let mut context = Context::from_waker(&waker);\n+  |   62|       |\n+  |   63|       |        loop {\n+  |   64|      1|            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+  |   65|      1|                break val;\n+  |   66|      0|            }\n+  |   67|       |        }\n+  |   68|      1|    }\n+  ------------------\n+   69|       |}\n+"}, {"sha": "a6e387747068abedd73e2360cdcad9d4e6e598ec", "filename": "src/test/run-make-fulldeps/coverage/async.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync.rs?ref=6af1e632a974b78b62895e8cb918b889cf613882", "patch": "@@ -1,6 +1,6 @@\n #![allow(unused_assignments, dead_code)]\n \n-// compile-flags: --edition=2018 -C opt-level=1 # fix in rustc_mir/monomorphize/partitioning/mod.rs\n+// compile-flags: --edition=2018 -C opt-level=1\n \n async fn c(x: u8) -> u8 {\n     if x == 8 {"}, {"sha": "6171d95ff5543d458b6f0f657b2c771a7cbae541", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6af1e632a974b78b62895e8cb918b889cf613882/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=6af1e632a974b78b62895e8cb918b889cf613882", "patch": "@@ -0,0 +1,69 @@\n+// compile-flags: --edition=2018\n+\n+use core::{\n+    future::Future,\n+    marker::Send,\n+    pin::Pin,\n+};\n+\n+fn non_async_func() {\n+    println!(\"non_async_func was covered\");\n+    let b = true;\n+    if b {\n+        println!(\"non_async_func println in block\");\n+    }\n+}\n+\n+// FIXME(#83985): The auto-generated closure in an async function is failing to include\n+// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n+// non-async function above, unless the `println!()` is inside a covered block.\n+async fn async_func() {\n+    println!(\"async_func was covered\");\n+    let b = true;\n+    if b {\n+        println!(\"async_func println in block\");\n+    }\n+}\n+\n+// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n+// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n+// It's only certain kinds of lines and/or their context that results in missing coverage.\n+async fn async_func_just_println() {\n+    println!(\"async_func_just_println was covered\");\n+}\n+\n+fn main() {\n+    println!(\"codecovsample::main\");\n+\n+    non_async_func();\n+\n+    executor::block_on(async_func());\n+    executor::block_on(async_func_just_println());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+        use std::hint::unreachable_unchecked;\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unsafe { unreachable_unchecked() }, // clone\n+            |_| unsafe { unreachable_unchecked() }, // wake\n+            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}]}