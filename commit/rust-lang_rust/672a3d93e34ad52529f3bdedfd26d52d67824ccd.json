{"sha": "672a3d93e34ad52529f3bdedfd26d52d67824ccd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MmEzZDkzZTM0YWQ1MjUyOWYzYmRlZGZkMjZkNTJkNjc4MjRjY2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-11T04:27:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-11T04:27:53Z"}, "message": "Auto merge of #30294 - jseyfried:fix_shadowed_use_visibility, r=nrc\n\nThis fixes a bug in which the visibility of a use declaration defining a name in one namespace (e.g. the value namespace) is overridden by a later use declaration defining the same name in the other namespace (e.g. the type namespace). For example,\n```rust\nfn f() {}\npub mod bar {}\n\nmod foo {\n    use f; // This import should not be visible outside `foo`,\n    pub use bar as f; // but it visible outside of `foo` because of this import.\n}\n\nfn main() { foo::f(); }\n```\nAs the example demonstrates, this is a [breaking-change], but it looks unlikely to cause breakage in practice, and any breakage can be fixed by correcting visibility modifiers.", "tree": {"sha": "e8cdf1ecf16d6e3ad9b24857d180c0ff106d21ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8cdf1ecf16d6e3ad9b24857d180c0ff106d21ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/672a3d93e34ad52529f3bdedfd26d52d67824ccd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/672a3d93e34ad52529f3bdedfd26d52d67824ccd", "html_url": "https://github.com/rust-lang/rust/commit/672a3d93e34ad52529f3bdedfd26d52d67824ccd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/672a3d93e34ad52529f3bdedfd26d52d67824ccd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae5d09551e8a0777999aadb1aa804e43aeab0ff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5d09551e8a0777999aadb1aa804e43aeab0ff2", "html_url": "https://github.com/rust-lang/rust/commit/ae5d09551e8a0777999aadb1aa804e43aeab0ff2"}, {"sha": "ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161", "html_url": "https://github.com/rust-lang/rust/commit/ada87fae5f2fe1b2bc6e95ad7a6a730921c22161"}], "stats": {"total": 331, "additions": 168, "deletions": 163}, "files": [{"sha": "0deef91a0f6b08e9692190ef3f0023c115d05d64", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -16,7 +16,7 @@\n use DefModifiers;\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use resolve_imports::ImportResolution;\n+use resolve_imports::{ImportResolution, ImportResolutionPerNamespace};\n use Module;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n@@ -822,22 +822,23 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {\n-                    Some(resolution) => {\n+                    Some(resolution_per_ns) => {\n                         debug!(\"(building import directive) bumping reference\");\n-                        resolution.outstanding_references += 1;\n+                        resolution_per_ns.outstanding_references += 1;\n \n                         // the source of this name is different now\n-                        resolution.type_id = id;\n-                        resolution.value_id = id;\n-                        resolution.is_public = is_public;\n+                        let resolution =\n+                            ImportResolution { id: id, is_public: is_public, target: None };\n+                        resolution_per_ns[TypeNS] = resolution.clone();\n+                        resolution_per_ns[ValueNS] = resolution;\n                         return;\n                     }\n                     None => {}\n                 }\n                 debug!(\"(building import directive) creating new\");\n-                let mut resolution = ImportResolution::new(id, is_public);\n-                resolution.outstanding_references = 1;\n-                import_resolutions.insert(target, resolution);\n+                let mut import_resolution_per_ns = ImportResolutionPerNamespace::new(id, is_public);\n+                import_resolution_per_ns.outstanding_references = 1;\n+                import_resolutions.insert(target, import_resolution_per_ns);\n             }\n             GlobImport => {\n                 // Set the glob flag. This tells us that we don't know the"}, {"sha": "c32acb7bb269f36f51c3c0aec8c4fec6dd0df251", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -96,7 +96,7 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::usize;\n \n-use resolve_imports::{Target, ImportDirective, ImportResolution};\n+use resolve_imports::{Target, ImportDirective, ImportResolutionPerNamespace};\n use resolve_imports::Shadowable;\n \n // NB: This module needs to be declared first so diagnostics are\n@@ -328,7 +328,7 @@ fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                              .import_resolutions\n                                              .borrow()\n                                              .get(&name) {\n-                let item = resolver.ast_map.expect_item(directive.value_id);\n+                let item = resolver.ast_map.expect_item(directive.value_ns.id);\n                 resolver.session.span_note(item.span, \"constant imported here\");\n             }\n         }\n@@ -793,7 +793,7 @@ pub struct Module {\n     anonymous_children: RefCell<NodeMap<Rc<Module>>>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: RefCell<HashMap<Name, ImportResolution>>,\n+    import_resolutions: RefCell<HashMap<Name, ImportResolutionPerNamespace>>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: Cell<usize>,\n@@ -912,7 +912,7 @@ bitflags! {\n // Records a possibly-private value, type, or module definition.\n #[derive(Debug)]\n struct NsDef {\n-    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n+    modifiers: DefModifiers, // see note in ImportResolutionPerNamespace about how to use this\n     def_or_module: DefOrModule,\n     span: Option<Span>,\n }\n@@ -1491,7 +1491,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n         if let Some(import_resolution) = module_.import_resolutions.borrow().get(&name) {\n-            match (*import_resolution).target_for_namespace(namespace) {\n+            match import_resolution[namespace].target.clone() {\n                 None => {\n                     // Not found; continue.\n                     debug!(\"(resolving item in lexical scope) found import resolution, but not \\\n@@ -1501,7 +1501,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Some(target) => {\n                     debug!(\"(resolving item in lexical scope) using import resolution\");\n                     // track used imports and extern crates as well\n-                    let id = import_resolution.id(namespace);\n+                    let id = import_resolution[namespace].id;\n                     self.used_imports.insert((id, namespace));\n                     self.record_import_use(id, name);\n                     if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n@@ -1712,21 +1712,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Check the list of resolved imports.\n         match module_.import_resolutions.borrow().get(&name) {\n-            Some(import_resolution) if allow_private_imports || import_resolution.is_public => {\n+            Some(import_resolution) if allow_private_imports ||\n+                                       import_resolution[namespace].is_public => {\n \n-                if import_resolution.is_public && import_resolution.outstanding_references != 0 {\n+                if import_resolution[namespace].is_public &&\n+                   import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                match import_resolution.target_for_namespace(namespace) {\n+                match import_resolution[namespace].target.clone() {\n                     None => {\n                         debug!(\"(resolving name in module) name found, but not in namespace {:?}\",\n                                namespace);\n                     }\n                     Some(target) => {\n                         debug!(\"(resolving name in module) resolved to import\");\n                         // track used imports and extern crates as well\n-                        let id = import_resolution.id(namespace);\n+                        let id = import_resolution[namespace].id;\n                         self.used_imports.insert((id, namespace));\n                         self.record_import_use(id, name);\n                         if let Some(DefId{krate: kid, ..}) = target.target_module.def_id() {\n@@ -3651,17 +3653,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             // Look for imports.\n             for (_, import) in search_module.import_resolutions.borrow().iter() {\n-                let target = match import.target_for_namespace(TypeNS) {\n+                let target = match import.type_ns.target {\n                     None => continue,\n-                    Some(target) => target,\n+                    Some(ref target) => target,\n                 };\n                 let did = match target.binding.def() {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n                     add_trait_info(&mut found_traits, did, name);\n-                    let id = import.type_id;\n+                    let id = import.type_ns.id;\n                     self.used_imports.insert((id, TypeNS));\n                     let trait_name = self.get_trait_name(did);\n                     self.record_import_use(id, trait_name);\n@@ -3734,7 +3736,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let import_resolutions = module_.import_resolutions.borrow();\n         for (&name, import_resolution) in import_resolutions.iter() {\n             let value_repr;\n-            match import_resolution.target_for_namespace(ValueNS) {\n+            match import_resolution.value_ns.target {\n                 None => {\n                     value_repr = \"\".to_string();\n                 }\n@@ -3745,7 +3747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             let type_repr;\n-            match import_resolution.target_for_namespace(TypeNS) {\n+            match import_resolution.type_ns.target {\n                 None => {\n                     type_repr = \"\".to_string();\n                 }"}, {"sha": "59cf83e91d2da68bc13f4997fa58af3b160abeb2", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -130,13 +130,14 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n \n     fn add_exports_for_module(&mut self, exports: &mut Vec<Export>, module_: &Module) {\n         for (name, import_resolution) in module_.import_resolutions.borrow().iter() {\n-            if !import_resolution.is_public {\n-                continue;\n-            }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n-                match import_resolution.target_for_namespace(ns) {\n-                    Some(target) => {\n+                if !import_resolution[ns].is_public {\n+                    continue;\n+                }\n+\n+                match import_resolution[ns].target {\n+                    Some(ref target) => {\n                         debug!(\"(computing exports) maybe export '{}'\", name);\n                         self.add_export_of_namebinding(exports, *name, &target.binding)\n                     }"}, {"sha": "fd471893acd53c5517328ae67e73597b8457d293", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 89, "deletions": 134, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -58,7 +58,7 @@ pub struct ImportDirective {\n     pub subclass: ImportDirectiveSubclass,\n     pub span: Span,\n     pub id: NodeId,\n-    pub is_public: bool, // see note in ImportResolution about how to use this\n+    pub is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n     pub shadowable: Shadowable,\n }\n \n@@ -102,80 +102,61 @@ impl Target {\n     }\n }\n \n-/// An ImportResolution represents a particular `use` directive.\n #[derive(Debug)]\n+/// An ImportResolutionPerNamespace records what we know about an imported name.\n+/// More specifically, it records the number of unresolved `use` directives that import the name,\n+/// and for each namespace, it records the `use` directive importing the name in the namespace\n+/// and the `Target` to which the name in the namespace resolves (if applicable).\n+/// Different `use` directives may import the same name in different namespaces.\n+pub struct ImportResolutionPerNamespace {\n+    // When outstanding_references reaches zero, outside modules can count on the targets being\n+    // correct. Before then, all bets are off; future `use` directives could override the name.\n+    // Since shadowing is forbidden, the only way outstanding_references > 1 in a legal program\n+    // is if the name is imported by exactly two `use` directives, one of which resolves to a\n+    // value and the other of which resolves to a type.\n+    pub outstanding_references: usize,\n+    pub type_ns: ImportResolution,\n+    pub value_ns: ImportResolution,\n+}\n+\n+/// Records what we know about an imported name in a namespace (see `ImportResolutionPerNamespace`).\n+#[derive(Clone,Debug)]\n pub struct ImportResolution {\n-    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n-    /// should *not* be used whenever resolution is being performed. Privacy\n-    /// testing occurs during a later phase of compilation.\n+    /// Whether the name in the namespace was imported with a `use` or a `pub use`.\n     pub is_public: bool,\n \n-    // The number of outstanding references to this name. When this reaches\n-    // zero, outside modules can count on the targets being correct. Before\n-    // then, all bets are off; future imports could override this name.\n-    // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n-    // way outstanding_references is > 1 in a legal program is if the name is\n-    // used in both namespaces.\n-    pub outstanding_references: usize,\n+    /// Resolution of the name in the namespace\n+    pub target: Option<Target>,\n \n-    /// The value that this `use` directive names, if there is one.\n-    pub value_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the value target\n-    /// being non-none\n-    pub value_id: NodeId,\n-\n-    /// The type that this `use` directive names, if there is one.\n-    pub type_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the type target\n-    /// being non-none\n-    pub type_id: NodeId,\n+    /// The source node of the `use` directive\n+    pub id: NodeId,\n }\n \n-impl ImportResolution {\n-    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n-        ImportResolution {\n-            type_id: id,\n-            value_id: id,\n-            outstanding_references: 0,\n-            value_target: None,\n-            type_target: None,\n-            is_public: is_public,\n-        }\n+impl ::std::ops::Index<Namespace> for ImportResolutionPerNamespace {\n+    type Output = ImportResolution;\n+    fn index(&self, ns: Namespace) -> &ImportResolution {\n+        match ns { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n     }\n+}\n \n-    pub fn target_for_namespace(&self, namespace: Namespace) -> Option<Target> {\n-        match namespace {\n-            TypeNS => self.type_target.clone(),\n-            ValueNS => self.value_target.clone(),\n-        }\n+impl ::std::ops::IndexMut<Namespace> for ImportResolutionPerNamespace {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut ImportResolution {\n+        match ns { TypeNS => &mut self.type_ns, ValueNS => &mut self.value_ns }\n     }\n+}\n \n-    pub fn id(&self, namespace: Namespace) -> NodeId {\n-        match namespace {\n-            TypeNS => self.type_id,\n-            ValueNS => self.value_id,\n+impl ImportResolutionPerNamespace {\n+    pub fn new(id: NodeId, is_public: bool) -> Self {\n+        let resolution = ImportResolution { id: id, is_public: is_public, target: None };\n+        ImportResolutionPerNamespace {\n+            outstanding_references: 0, type_ns: resolution.clone(), value_ns: resolution,\n         }\n     }\n \n     pub fn shadowable(&self, namespace: Namespace) -> Shadowable {\n-        let target = self.target_for_namespace(namespace);\n-        if target.is_none() {\n-            return Shadowable::Always;\n-        }\n-\n-        target.unwrap().shadowable\n-    }\n-\n-    pub fn set_target_and_id(&mut self, namespace: Namespace, target: Option<Target>, id: NodeId) {\n-        match namespace {\n-            TypeNS => {\n-                self.type_target = target;\n-                self.type_id = id;\n-            }\n-            ValueNS => {\n-                self.value_target = target;\n-                self.value_id = id;\n-            }\n+        match self[namespace].target {\n+            Some(ref target) => target.shadowable,\n+            None => Shadowable::Always,\n         }\n     }\n }\n@@ -523,18 +504,18 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     Some(import_resolution) if import_resolution.outstanding_references == 0 => {\n \n                         fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolution,\n+                                       import_resolution: &ImportResolutionPerNamespace,\n                                        namespace: Namespace,\n                                        source: Name)\n                                        -> NamespaceResult {\n \n                             // Import resolutions must be declared with \"pub\"\n                             // in order to be exported.\n-                            if !import_resolution.is_public {\n+                            if !import_resolution[namespace].is_public {\n                                 return UnboundResult;\n                             }\n \n-                            match import_resolution.target_for_namespace(namespace) {\n+                            match import_resolution[namespace].target.clone() {\n                                 None => {\n                                     return UnboundResult;\n                                 }\n@@ -545,7 +526,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                 }) => {\n                                     debug!(\"(resolving single import) found import in ns {:?}\",\n                                            namespace);\n-                                    let id = import_resolution.id(namespace);\n+                                    let id = import_resolution[namespace].id;\n                                     // track used imports and extern crates as well\n                                     this.used_imports.insert((id, namespace));\n                                     this.record_import_use(id, source);\n@@ -567,14 +548,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                        import_resolution,\n                                                        ValueNS,\n                                                        source);\n-                            value_used_reexport = import_resolution.is_public;\n+                            value_used_reexport = import_resolution.value_ns.is_public;\n                         }\n                         if type_result.is_unknown() {\n                             type_result = get_binding(self.resolver,\n                                                       import_resolution,\n                                                       TypeNS,\n                                                       source);\n-                            type_used_reexport = import_resolution.is_public;\n+                            type_used_reexport = import_resolution.type_ns.is_public;\n                         }\n \n                     }\n@@ -663,11 +644,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        let target = Some(Target::new(target_module.clone(),\n-                                                      name_binding.clone(),\n-                                                      directive.shadowable));\n-                        import_resolution.set_target_and_id(namespace, target, directive.id);\n-                        import_resolution.is_public = directive.is_public;\n+                        import_resolution[namespace] = ImportResolution {\n+                            target: Some(Target::new(target_module.clone(),\n+                                                     name_binding.clone(),\n+                                                     directive.shadowable)),\n+                            id: directive.id,\n+                            is_public: directive.is_public\n+                        };\n                         *used_public = name_binding.is_public();\n                     }\n                     UnboundResult => {\n@@ -702,7 +685,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n+        let value_def_and_priv = import_resolution.value_ns.target.as_ref().map(|target| {\n             let def = target.binding.def().unwrap();\n             (def,\n              if value_used_public {\n@@ -711,7 +694,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 DependsOn(def.def_id())\n             })\n         });\n-        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n+        let type_def_and_priv = import_resolution.type_ns.target.as_ref().map(|target| {\n             let def = target.binding.def().unwrap();\n             (def,\n              if type_used_public {\n@@ -791,54 +774,26 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                    *name,\n                    module_to_string(module_));\n \n-            if !target_import_resolution.is_public {\n-                debug!(\"(resolving glob import) nevermind, just kidding\");\n-                continue;\n-            }\n-\n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.get_mut(name) {\n-                Some(dest_import_resolution) => {\n-                    // Merge the two import resolutions at a finer-grained\n-                    // level.\n-\n-                    match target_import_resolution.value_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref value_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution,\n-                                                              import_directive.span,\n-                                                              *name,\n-                                                              ValueNS);\n-                            dest_import_resolution.value_target = Some(value_target.clone());\n-                        }\n-                    }\n-                    match target_import_resolution.type_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref type_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution,\n-                                                              import_directive.span,\n-                                                              *name,\n-                                                              TypeNS);\n-                            dest_import_resolution.type_target = Some(type_target.clone());\n-                        }\n+            let mut dest_import_resolution = import_resolutions.entry(*name).or_insert_with(|| {\n+                ImportResolutionPerNamespace::new(id, is_public)\n+            });\n+\n+            for &ns in [TypeNS, ValueNS].iter() {\n+                match target_import_resolution[ns].target {\n+                    Some(ref target) if target_import_resolution[ns].is_public => {\n+                        self.check_for_conflicting_import(&dest_import_resolution,\n+                                                          import_directive.span,\n+                                                          *name,\n+                                                          ns);\n+                        dest_import_resolution[ns] = ImportResolution {\n+                            id: id, is_public: is_public, target: Some(target.clone())\n+                        };\n                     }\n-                    dest_import_resolution.is_public = is_public;\n-                    continue;\n+                    _ => {}\n                 }\n-                None => {}\n             }\n-\n-            // Simple: just copy the old import resolution.\n-            let mut new_import_resolution = ImportResolution::new(id, is_public);\n-            new_import_resolution.value_target = target_import_resolution.value_target.clone();\n-            new_import_resolution.type_target = target_import_resolution.type_target.clone();\n-\n-            import_resolutions.insert(*name, new_import_resolution);\n         }\n \n         // Add all children from the containing module.\n@@ -877,10 +832,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let is_public = import_directive.is_public;\n \n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(name)\n-                                                       .or_insert_with(|| {\n-                                                           ImportResolution::new(id, is_public)\n-                                                       });\n+        let dest_import_resolution = import_resolutions.entry(name).or_insert_with(|| {\n+            ImportResolutionPerNamespace::new(id, is_public)\n+        });\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` to `{}`\",\n                name,\n@@ -909,19 +863,20 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   \"{}\",\n                                   msg);\n                     } else {\n-                        let target = Target::new(containing_module.clone(),\n-                                                 name_bindings[namespace].clone(),\n-                                                 import_directive.shadowable);\n-                        dest_import_resolution.set_target_and_id(namespace, Some(target), id);\n+                        dest_import_resolution[namespace] = ImportResolution {\n+                            target: Some(Target::new(containing_module.clone(),\n+                                                     name_bindings[namespace].clone(),\n+                                                     import_directive.shadowable)),\n+                            id: id,\n+                            is_public: is_public\n+                        };\n                     }\n                 }\n             };\n             merge_child_item(ValueNS);\n             merge_child_item(TypeNS);\n         }\n \n-        dest_import_resolution.is_public = is_public;\n-\n         self.check_for_conflicts_between_imports_and_items(module_,\n                                                            dest_import_resolution,\n                                                            import_directive.span,\n@@ -930,16 +885,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicting_import(&mut self,\n-                                    import_resolution: &ImportResolution,\n+                                    import_resolution: &ImportResolutionPerNamespace,\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        let target = import_resolution.target_for_namespace(namespace);\n+        let target = &import_resolution[namespace].target;\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                name,\n                target.is_some());\n \n-        match target {\n+        match *target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n@@ -957,7 +912,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                           \"a {} named `{}` has already been imported in this module\",\n                           ns_word,\n                           name);\n-                let use_id = import_resolution.id(namespace);\n+                let use_id = import_resolution[namespace].id;\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n                 span_note!(self.resolver.session,\n@@ -983,14 +938,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicts_between_imports_and_items(&mut self,\n                                                      module: &Module,\n-                                                     import_resolution: &ImportResolution,\n+                                                     import: &ImportResolutionPerNamespace,\n                                                      import_span: Span,\n                                                      name: Name) {\n         // First, check for conflicts between imports and `extern crate`s.\n         if module.external_module_children\n                  .borrow()\n                  .contains_key(&name) {\n-            match import_resolution.type_target {\n+            match import.type_ns.target {\n                 Some(ref target) if target.shadowable != Shadowable::Always => {\n                     let msg = format!(\"import `{0}` conflicts with imported crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n@@ -1011,7 +966,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref name_bindings) => (*name_bindings).clone(),\n         };\n \n-        match import_resolution.value_target {\n+        match import.value_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref value) = *name_bindings.value_ns.borrow() {\n                     span_err!(self.resolver.session,\n@@ -1027,7 +982,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(_) | None => {}\n         }\n \n-        match import_resolution.type_target {\n+        match import.type_ns.target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n                     let (what, note) = match ty.module() {"}, {"sha": "1bf7f3933849de76ba2307357ba574ebc776b90c", "filename": "src/test/compile-fail/shadowed-use-visibility.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshadowed-use-visibility.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub fn f() {}\n+\n+    use foo as bar;\n+    pub use self::f as bar;\n+}\n+\n+mod bar {\n+    use foo::bar::f as g; //~ ERROR unresolved import\n+\n+    use foo as f;\n+    pub use foo::*;\n+}\n+\n+use bar::f::f; //~ ERROR unresolved import\n+fn main() {}"}, {"sha": "d2a32da4feaa29ffcc286a93ae96ff2118b026c6", "filename": "src/test/run-pass/shadowed-use-visibility.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672a3d93e34ad52529f3bdedfd26d52d67824ccd/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadowed-use-visibility.rs?ref=672a3d93e34ad52529f3bdedfd26d52d67824ccd", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub fn f() {}\n+\n+    pub use self::f as bar;\n+    use foo as bar;\n+}\n+\n+fn main() {\n+    foo::bar();\n+}"}]}