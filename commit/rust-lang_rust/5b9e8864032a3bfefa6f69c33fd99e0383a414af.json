{"sha": "5b9e8864032a3bfefa6f69c33fd99e0383a414af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViOWU4ODY0MDMyYTNiZmVmYTZmNjljMzNmZDk5ZTAzODNhNDE0YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T14:42:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-25T14:42:20Z"}, "message": "Auto merge of #73453 - erikdesjardins:tuplayout, r=eddyb\n\nIgnore ZST offsets when deciding whether to use Scalar/ScalarPair layout\n\nThis is important because Scalar/ScalarPair layout previously would not be used if any ZST had nonzero offset.\nFor example, before this change, only `((), u128)` would be laid out like `u128`, not `(u128, ())`.\n\nFixes #63244", "tree": {"sha": "2dbbe921ff9dca5c86e8865a12da48dac8b96409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dbbe921ff9dca5c86e8865a12da48dac8b96409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b9e8864032a3bfefa6f69c33fd99e0383a414af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9e8864032a3bfefa6f69c33fd99e0383a414af", "html_url": "https://github.com/rust-lang/rust/commit/5b9e8864032a3bfefa6f69c33fd99e0383a414af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b9e8864032a3bfefa6f69c33fd99e0383a414af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b984ef6797ff17faa2b1e0ebb54b78de1491e5fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b984ef6797ff17faa2b1e0ebb54b78de1491e5fd", "html_url": "https://github.com/rust-lang/rust/commit/b984ef6797ff17faa2b1e0ebb54b78de1491e5fd"}, {"sha": "24e0913e37cc6fc363b37d13bf519db212f175a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/24e0913e37cc6fc363b37d13bf519db212f175a2", "html_url": "https://github.com/rust-lang/rust/commit/24e0913e37cc6fc363b37d13bf519db212f175a2"}], "stats": {"total": 302, "additions": 228, "deletions": 74}, "files": [{"sha": "91609b226158bbf8dbdc1511e24d2234fc8e12e1", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -93,15 +93,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         let effective_field_align = self.align.restrict_for_offset(offset);\n \n         let mut simple = || {\n-            // Unions and newtypes only use an offset of 0.\n-            let llval = if offset.bytes() == 0 {\n-                self.llval\n-            } else if let Abi::ScalarPair(ref a, ref b) = self.layout.abi {\n-                // Offsets have to match either first or second field.\n-                assert_eq!(offset, a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi));\n-                bx.struct_gep(self.llval, 1)\n-            } else {\n-                bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix))\n+            let llval = match self.layout.abi {\n+                _ if offset.bytes() == 0 => {\n+                    // Unions and newtypes only use an offset of 0.\n+                    // Also handles the first field of Scalar, ScalarPair, and Vector layouts.\n+                    self.llval\n+                }\n+                Abi::ScalarPair(ref a, ref b)\n+                    if offset == a.value.size(bx.cx()).align_to(b.value.align(bx.cx()).abi) =>\n+                {\n+                    // Offset matches second field.\n+                    bx.struct_gep(self.llval, 1)\n+                }\n+                Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. } if field.is_zst() => {\n+                    // ZST fields are not included in Scalar, ScalarPair, and Vector layouts, so manually offset the pointer.\n+                    let byte_ptr = bx.pointercast(self.llval, bx.cx().type_i8p());\n+                    bx.gep(byte_ptr, &[bx.const_usize(offset.bytes())])\n+                }\n+                Abi::Scalar(_) | Abi::ScalarPair(..) => {\n+                    // All fields of Scalar and ScalarPair layouts must have been handled by this point.\n+                    // Vector layouts have additional fields for each element of the vector, so don't panic in that case.\n+                    bug!(\n+                        \"offset of non-ZST field `{:?}` does not match layout `{:#?}`\",\n+                        field,\n+                        self.layout\n+                    );\n+                }\n+                _ => bx.struct_gep(self.llval, bx.cx().backend_field_index(self.layout, ix)),\n             };\n             PlaceRef {\n                 // HACK(eddyb): have to bitcast pointers until LLVM removes pointee types."}, {"sha": "0fda1473f6488f5a5b67b8048cb3dcec97e552b0", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 47, "deletions": 65, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -390,78 +390,60 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         // Unpack newtype ABIs and find scalar pairs.\n         if sized && size.bytes() > 0 {\n-            // All other fields must be ZSTs, and we need them to all start at 0.\n-            let mut zst_offsets = offsets.iter().enumerate().filter(|&(i, _)| fields[i].is_zst());\n-            if zst_offsets.all(|(_, o)| o.bytes() == 0) {\n-                let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n-\n-                match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                    // We have exactly one non-ZST field.\n-                    (Some((i, field)), None, None) => {\n-                        // Field fills the struct and it has a scalar or scalar pair ABI.\n-                        if offsets[i].bytes() == 0\n-                            && align.abi == field.align.abi\n-                            && size == field.size\n-                        {\n-                            match field.abi {\n-                                // For plain scalars, or vectors of them, we can't unpack\n-                                // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                                Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                // But scalar pairs are Rust-specific and get\n-                                // treated as aggregates by C ABIs anyway.\n-                                Abi::ScalarPair(..) => {\n-                                    abi = field.abi.clone();\n-                                }\n-                                _ => {}\n+            // All other fields must be ZSTs.\n+            let mut non_zst_fields = fields.iter().enumerate().filter(|&(_, f)| !f.is_zst());\n+\n+            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+                // We have exactly one non-ZST field.\n+                (Some((i, field)), None, None) => {\n+                    // Field fills the struct and it has a scalar or scalar pair ABI.\n+                    if offsets[i].bytes() == 0 && align.abi == field.align.abi && size == field.size\n+                    {\n+                        match field.abi {\n+                            // For plain scalars, or vectors of them, we can't unpack\n+                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                                abi = field.abi.clone();\n                             }\n+                            // But scalar pairs are Rust-specific and get\n+                            // treated as aggregates by C ABIs anyway.\n+                            Abi::ScalarPair(..) => {\n+                                abi = field.abi.clone();\n+                            }\n+                            _ => {}\n                         }\n                     }\n+                }\n \n-                    // Two non-ZST fields, and they're both scalars.\n-                    (\n-                        Some((\n-                            i,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref a), .. }, ..\n-                            },\n-                        )),\n-                        Some((\n-                            j,\n-                            &TyAndLayout {\n-                                layout: &Layout { abi: Abi::Scalar(ref b), .. }, ..\n-                            },\n-                        )),\n-                        None,\n-                    ) => {\n-                        // Order by the memory placement, not source order.\n-                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                            ((i, a), (j, b))\n-                        } else {\n-                            ((j, b), (i, a))\n-                        };\n-                        let pair = self.scalar_pair(a.clone(), b.clone());\n-                        let pair_offsets = match pair.fields {\n-                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                assert_eq!(memory_index, &[0, 1]);\n-                                offsets\n-                            }\n-                            _ => bug!(),\n-                        };\n-                        if offsets[i] == pair_offsets[0]\n-                            && offsets[j] == pair_offsets[1]\n-                            && align == pair.align\n-                            && size == pair.size\n-                        {\n-                            // We can use `ScalarPair` only when it matches our\n-                            // already computed layout (including `#[repr(C)]`).\n-                            abi = pair.abi;\n+                // Two non-ZST fields, and they're both scalars.\n+                (\n+                    Some((i, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref a), .. }, .. })),\n+                    Some((j, &TyAndLayout { layout: &Layout { abi: Abi::Scalar(ref b), .. }, .. })),\n+                    None,\n+                ) => {\n+                    // Order by the memory placement, not source order.\n+                    let ((i, a), (j, b)) =\n+                        if offsets[i] < offsets[j] { ((i, a), (j, b)) } else { ((j, b), (i, a)) };\n+                    let pair = self.scalar_pair(a.clone(), b.clone());\n+                    let pair_offsets = match pair.fields {\n+                        FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                            assert_eq!(memory_index, &[0, 1]);\n+                            offsets\n                         }\n+                        _ => bug!(),\n+                    };\n+                    if offsets[i] == pair_offsets[0]\n+                        && offsets[j] == pair_offsets[1]\n+                        && align == pair.align\n+                        && size == pair.size\n+                    {\n+                        // We can use `ScalarPair` only when it matches our\n+                        // already computed layout (including `#[repr(C)]`).\n+                        abi = pair.abi;\n                     }\n-\n-                    _ => {}\n                 }\n+\n+                _ => {}\n             }\n         }\n "}, {"sha": "e86c75f3f482607b204d715d879f4cfa5b136a40", "filename": "src/test/codegen/tuple-layout-opt.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fcodegen%2Ftuple-layout-opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fcodegen%2Ftuple-layout-opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ftuple-layout-opt.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -0,0 +1,36 @@\n+// ignore-emscripten\n+// compile-flags: -C no-prepopulate-passes\n+\n+// Test that tuples get optimized layout, in particular with a ZST in the last field (#63244)\n+\n+#![crate_type=\"lib\"]\n+\n+type ScalarZstLast = (u128, ());\n+// CHECK: define i128 @test_ScalarZstLast(i128 %_1)\n+#[no_mangle]\n+pub fn test_ScalarZstLast(_: ScalarZstLast) -> ScalarZstLast { loop {} }\n+\n+type ScalarZstFirst = ((), u128);\n+// CHECK: define i128 @test_ScalarZstFirst(i128 %_1)\n+#[no_mangle]\n+pub fn test_ScalarZstFirst(_: ScalarZstFirst) -> ScalarZstFirst { loop {} }\n+\n+type ScalarPairZstLast = (u8, u128, ());\n+// CHECK: define { i128, i8 } @test_ScalarPairZstLast(i128 %_1.0, i8 %_1.1)\n+#[no_mangle]\n+pub fn test_ScalarPairZstLast(_: ScalarPairZstLast) -> ScalarPairZstLast { loop {} }\n+\n+type ScalarPairZstFirst = ((), u8, u128);\n+// CHECK: define { i8, i128 } @test_ScalarPairZstFirst(i8 %_1.0, i128 %_1.1)\n+#[no_mangle]\n+pub fn test_ScalarPairZstFirst(_: ScalarPairZstFirst) -> ScalarPairZstFirst { loop {} }\n+\n+type ScalarPairLotsOfZsts = ((), u8, (), u128, ());\n+// CHECK: define { i128, i8 } @test_ScalarPairLotsOfZsts(i128 %_1.0, i8 %_1.1)\n+#[no_mangle]\n+pub fn test_ScalarPairLotsOfZsts(_: ScalarPairLotsOfZsts) -> ScalarPairLotsOfZsts { loop {} }\n+\n+type ScalarPairLottaNesting = (((), ((), u8, (), u128, ())), ());\n+// CHECK: define { i128, i8 } @test_ScalarPairLottaNesting(i128 %_1.0, i8 %_1.1)\n+#[no_mangle]\n+pub fn test_ScalarPairLottaNesting(_: ScalarPairLottaNesting) -> ScalarPairLottaNesting { loop {} }"}, {"sha": "0c015fca3253a6e7f66840fc6bde27bf272b64f7", "filename": "src/test/codegen/zst-offset.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fcodegen%2Fzst-offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fcodegen%2Fzst-offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fzst-offset.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+#![feature(repr_simd)]\n+\n+// Hack to get the correct size for the length part in slices\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n+#[no_mangle]\n+pub fn helper(_: usize) {\n+}\n+\n+// Check that we correctly generate a GEP for a ZST that is not included in Scalar layout\n+// CHECK-LABEL: @scalar_layout\n+#[no_mangle]\n+pub fn scalar_layout(s: &(u64, ())) {\n+// CHECK: [[X0:%[0-9]+]] = bitcast i64* %s to i8*\n+// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 8\n+    let x = &s.1;\n+    &x; // keep variable in an alloca\n+}\n+\n+// Check that we correctly generate a GEP for a ZST that is not included in ScalarPair layout\n+// CHECK-LABEL: @scalarpair_layout\n+#[no_mangle]\n+pub fn scalarpair_layout(s: &(u64, u32, ())) {\n+// CHECK: [[X0:%[0-9]+]] = bitcast { i64, i32 }* %s to i8*\n+// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 12\n+    let x = &s.2;\n+    &x; // keep variable in an alloca\n+}\n+\n+#[repr(simd)]\n+pub struct U64x4(u64, u64, u64, u64);\n+\n+// Check that we correctly generate a GEP for a ZST that is not included in Vector layout\n+// CHECK-LABEL: @vector_layout\n+#[no_mangle]\n+pub fn vector_layout(s: &(U64x4, ())) {\n+// CHECK: [[X0:%[0-9]+]] = bitcast <4 x i64>* %s to i8*\n+// CHECK-NEXT: [[X1:%[0-9]+]] = getelementptr i8, i8* [[X0]], [[USIZE]] 32\n+    let x = &s.1;\n+    &x; // keep variable in an alloca\n+}"}, {"sha": "26b923f431f98cf6ad2588a924d796f0ab859974", "filename": "src/test/ui/dynamically-sized-types/dst-tuple-no-reorder.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-no-reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-no-reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-no-reorder.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+// Ensure that unsizable fields that might be accessed don't get reordered\n+\n+fn nonzero_size() {\n+    let sized: (u8, [u32; 2]) = (123, [456, 789]);\n+    let unsize: &(u8, [u32]) = &sized;\n+    assert_eq!(unsize.0, 123);\n+    assert_eq!(unsize.1.len(), 2);\n+    assert_eq!(unsize.1[0], 456);\n+    assert_eq!(unsize.1[1], 789);\n+}\n+\n+fn zst() {\n+    let sized: (u8, [u32; 0]) = (123, []);\n+    let unsize: &(u8, [u32]) = &sized;\n+    assert_eq!(unsize.0, 123);\n+    assert_eq!(unsize.1.len(), 0);\n+}\n+\n+pub fn main() {\n+    nonzero_size();\n+    zst();\n+}"}, {"sha": "b0cefe77039d6aae8c5165a85f65639be8d25a5e", "filename": "src/test/ui/dynamically-sized-types/dst-tuple-zst-offsets.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-zst-offsets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-zst-offsets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdynamically-sized-types%2Fdst-tuple-zst-offsets.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -0,0 +1,22 @@\n+// run-pass\n+\n+#![feature(unsized_tuple_coercion)]\n+\n+// Check that we do not change the offsets of ZST fields when unsizing\n+\n+fn scalar_layout() {\n+    let sized: &(u8, [(); 13]) = &(123, [(); 13]);\n+    let unsize: &(u8, [()]) = sized;\n+    assert_eq!(sized.1.as_ptr(), unsize.1.as_ptr());\n+}\n+\n+fn scalarpair_layout() {\n+    let sized: &(u8, u16, [(); 13]) = &(123, 456, [(); 13]);\n+    let unsize: &(u8, u16, [()]) = sized;\n+    assert_eq!(sized.2.as_ptr(), unsize.2.as_ptr());\n+}\n+\n+pub fn main() {\n+    scalar_layout();\n+    scalarpair_layout();\n+}"}, {"sha": "629b50dec65f900556c3f9f87c30d0566ca208af", "filename": "src/test/ui/mir/mir_const_prop_tuple_field_reorder.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_tuple_field_reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b9e8864032a3bfefa6f69c33fd99e0383a414af/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_tuple_field_reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_const_prop_tuple_field_reorder.rs?ref=5b9e8864032a3bfefa6f69c33fd99e0383a414af", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Z mir-opt-level=2\n+// build-pass\n+#![crate_type=\"lib\"]\n+\n+// This used to ICE: const-prop did not account for field reordering of scalar pairs,\n+// and would generate a tuple like `(0x1337, VariantBar): (FooEnum, isize)`,\n+// causing assertion failures in codegen when trying to read 0x1337 at the wrong type.\n+\n+pub enum FooEnum {\n+    VariantBar,\n+    VariantBaz,\n+    VariantBuz,\n+}\n+\n+pub fn wrong_index() -> isize {\n+    let (_, b) = id((FooEnum::VariantBar, 0x1337));\n+    b\n+}\n+\n+pub fn wrong_index_two() -> isize {\n+    let (_, (_, b)) = id(((), (FooEnum::VariantBar, 0x1338)));\n+    b\n+}\n+\n+fn id<T>(x: T) -> T {\n+    x\n+}"}]}