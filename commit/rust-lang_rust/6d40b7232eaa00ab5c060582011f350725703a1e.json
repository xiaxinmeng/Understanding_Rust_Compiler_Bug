{"sha": "6d40b7232eaa00ab5c060582011f350725703a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNDBiNzIzMmVhYTAwYWI1YzA2MDU4MjAxMWYzNTA3MjU3MDNhMWU=", "commit": {"author": {"name": "Sebastian Geisler", "email": "sebastian@blockstream.io", "date": "2018-10-31T05:24:33Z"}, "committer": {"name": "Sebastian Geisler", "email": "sebastian@blockstream.io", "date": "2018-11-16T06:55:24Z"}, "message": "Implement checked_add_duration for SystemTime\n\nSince SystemTime is opaque there is no way to check if the result\nof an addition will be in bounds. That makes the Add<Duration>\ntrait completely unusable with untrusted data. This is a big problem\nbecause adding a Duration to UNIX_EPOCH is the standard way of\nconstructing a SystemTime from a unix timestamp.\n\nThis commit implements checked_add_duration(&self, &Duration) -> Option<SystemTime>\nfor std::time::SystemTime and as a prerequisite also for all platform\nspecific time structs. This also led to the refactoring of many\nadd_duration(&self, &Duration) -> SystemTime functions to avoid\nredundancy (they now unwrap the result of checked_add_duration).\n\nSome basic unit tests for the newly introduced function were added\ntoo.", "tree": {"sha": "f2e1c25c92d32bb635a8df1792e96c32cec199bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2e1c25c92d32bb635a8df1792e96c32cec199bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d40b7232eaa00ab5c060582011f350725703a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d40b7232eaa00ab5c060582011f350725703a1e", "html_url": "https://github.com/rust-lang/rust/commit/6d40b7232eaa00ab5c060582011f350725703a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d40b7232eaa00ab5c060582011f350725703a1e/comments", "author": {"login": "sgeisler", "id": 1876998, "node_id": "MDQ6VXNlcjE4NzY5OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1876998?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgeisler", "html_url": "https://github.com/sgeisler", "followers_url": "https://api.github.com/users/sgeisler/followers", "following_url": "https://api.github.com/users/sgeisler/following{/other_user}", "gists_url": "https://api.github.com/users/sgeisler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgeisler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgeisler/subscriptions", "organizations_url": "https://api.github.com/users/sgeisler/orgs", "repos_url": "https://api.github.com/users/sgeisler/repos", "events_url": "https://api.github.com/users/sgeisler/events{/privacy}", "received_events_url": "https://api.github.com/users/sgeisler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgeisler", "id": 1876998, "node_id": "MDQ6VXNlcjE4NzY5OTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1876998?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgeisler", "html_url": "https://github.com/sgeisler", "followers_url": "https://api.github.com/users/sgeisler/followers", "following_url": "https://api.github.com/users/sgeisler/following{/other_user}", "gists_url": "https://api.github.com/users/sgeisler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgeisler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgeisler/subscriptions", "organizations_url": "https://api.github.com/users/sgeisler/orgs", "repos_url": "https://api.github.com/users/sgeisler/repos", "events_url": "https://api.github.com/users/sgeisler/events{/privacy}", "received_events_url": "https://api.github.com/users/sgeisler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8aef7cae14bc7a56859408c90253e9bcc07fcff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8aef7cae14bc7a56859408c90253e9bcc07fcff", "html_url": "https://github.com/rust-lang/rust/commit/e8aef7cae14bc7a56859408c90253e9bcc07fcff"}], "stats": {"total": 114, "additions": 92, "deletions": 22}, "files": [{"sha": "191324e26a40f7d0bc79d746d45e75496de7119d", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -19,10 +19,14 @@ pub struct Instant {\n     t: abi::timestamp,\n }\n \n-pub fn dur2intervals(dur: &Duration) -> abi::timestamp {\n+fn checked_dur2intervals(dur: &Duration) -> Option<abi::timestamp> {\n     dur.as_secs()\n         .checked_mul(NSEC_PER_SEC)\n         .and_then(|nanos| nanos.checked_add(dur.subsec_nanos() as abi::timestamp))\n+}\n+\n+pub fn dur2intervals(dur: &Duration) -> abi::timestamp {\n+    checked_dur2intervals(dur)\n         .expect(\"overflow converting duration to nanoseconds\")\n }\n \n@@ -92,11 +96,14 @@ impl SystemTime {\n     }\n \n     pub fn add_duration(&self, other: &Duration) -> SystemTime {\n-        SystemTime {\n-            t: self.t\n-                .checked_add(dur2intervals(other))\n-                .expect(\"overflow when adding duration to instant\"),\n-        }\n+        self.checked_add_duration(other)\n+            .expect(\"overflow when adding duration to instant\")\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        checked_dur2intervals(other)\n+            .and_then(|d| self.t.checked_add(d))\n+            .map(|t| SystemTime {t})\n     }\n \n     pub fn sub_duration(&self, other: &Duration) -> SystemTime {"}, {"sha": "5f8799489aa6a42005fe1f82d0bde907d218acb1", "filename": "src/libstd/sys/redox/time.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -42,27 +42,36 @@ impl Timespec {\n     }\n \n     fn add_duration(&self, other: &Duration) -> Timespec {\n-        let mut secs = other\n+        self.checked_add_duration(other).expect(\"overflow when adding duration to time\")\n+    }\n+\n+    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = match other\n             .as_secs()\n             .try_into() // <- target type would be `i64`\n             .ok()\n             .and_then(|secs| self.t.tv_sec.checked_add(secs))\n-            .expect(\"overflow when adding duration to time\");\n+        {\n+            Some(ts) => ts,\n+            None => return None,\n+        };\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n         let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n-            secs = secs.checked_add(1).expect(\"overflow when adding \\\n-                                               duration to time\");\n+            secs = match secs.checked_add(1) {\n+                Some(ts) => ts,\n+                None => return None,\n+            }\n         }\n-        Timespec {\n+        Some(Timespec {\n             t: syscall::TimeSpec {\n                 tv_sec: secs,\n                 tv_nsec: nsec as i32,\n             },\n-        }\n+        })\n     }\n \n     fn sub_duration(&self, other: &Duration) -> Timespec {\n@@ -180,6 +189,10 @@ impl SystemTime {\n         SystemTime { t: self.t.add_duration(other) }\n     }\n \n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        self.t.checked_add_duration(other).map(|t| SystemTime { t })\n+    }\n+\n     pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n         SystemTime { t: self.t.sub_duration(other) }\n     }"}, {"sha": "50c3c00382eb5053e7e7e7d9dfad5642137d0edb", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -43,27 +43,36 @@ impl Timespec {\n     }\n \n     fn add_duration(&self, other: &Duration) -> Timespec {\n-        let mut secs = other\n+        self.checked_add_duration(other).expect(\"overflow when adding duration to time\")\n+    }\n+\n+    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n+        let mut secs = match other\n             .as_secs()\n             .try_into() // <- target type would be `libc::time_t`\n             .ok()\n             .and_then(|secs| self.t.tv_sec.checked_add(secs))\n-            .expect(\"overflow when adding duration to time\");\n+        {\n+            Some(ts) => ts,\n+            None => return None,\n+        };\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n         let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n-            secs = secs.checked_add(1).expect(\"overflow when adding \\\n-                                               duration to time\");\n+            secs = match secs.checked_add(1) {\n+                Some(ts) => ts,\n+                None => return None,\n+            }\n         }\n-        Timespec {\n+        Some(Timespec {\n             t: libc::timespec {\n                 tv_sec: secs,\n                 tv_nsec: nsec as _,\n             },\n-        }\n+        })\n     }\n \n     fn sub_duration(&self, other: &Duration) -> Timespec {\n@@ -201,6 +210,10 @@ mod inner {\n             SystemTime { t: self.t.add_duration(other) }\n         }\n \n+        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+            self.t.checked_add_duration(other).map(|t| SystemTime { t })\n+        }\n+\n         pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n             SystemTime { t: self.t.sub_duration(other) }\n         }\n@@ -325,6 +338,10 @@ mod inner {\n             SystemTime { t: self.t.add_duration(other) }\n         }\n \n+        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+            self.t.checked_add_duration(other).map(|t| SystemTime { t })\n+        }\n+\n         pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n             SystemTime { t: self.t.sub_duration(other) }\n         }"}, {"sha": "991e8176edf6d8182bd2a70669549301c933f7f9", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -51,6 +51,10 @@ impl SystemTime {\n         SystemTime(self.0 + *other)\n     }\n \n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        self.0.checked_add(*other).map(|d| SystemTime(d))\n+    }\n+\n     pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n         SystemTime(self.0 - *other)\n     }"}, {"sha": "8eebe4a85fe160648d85e0d34509ca8345e3e01c", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -128,9 +128,13 @@ impl SystemTime {\n     }\n \n     pub fn add_duration(&self, other: &Duration) -> SystemTime {\n-        let intervals = self.intervals().checked_add(dur2intervals(other))\n-                            .expect(\"overflow when adding duration to time\");\n-        SystemTime::from_intervals(intervals)\n+        self.checked_add_duration(other).expect(\"overflow when adding duration to time\")\n+    }\n+\n+    pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n+        checked_dur2intervals(other)\n+            .and_then(|d| self.intervals().checked_add(d))\n+            .map(|i| SystemTime::from_intervals(i))\n     }\n \n     pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n@@ -180,11 +184,15 @@ impl Hash for SystemTime {\n     }\n }\n \n-fn dur2intervals(d: &Duration) -> i64 {\n+fn checked_dur2intervals(d: &Duration) -> Option<i64> {\n     d.as_secs()\n         .checked_mul(INTERVALS_PER_SEC)\n         .and_then(|i| i.checked_add(d.subsec_nanos() as u64 / 100))\n         .and_then(|i| i.try_into().ok())\n+}\n+\n+fn dur2intervals(d: &Duration) -> i64 {\n+    checked_dur2intervals(d)\n         .expect(\"overflow when converting duration to intervals\")\n }\n "}, {"sha": "94875d8993d335cc125cf2e2a8007456e6ab6335", "filename": "src/libstd/time.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d40b7232eaa00ab5c060582011f350725703a1e/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=6d40b7232eaa00ab5c060582011f350725703a1e", "patch": "@@ -357,6 +357,14 @@ impl SystemTime {\n     pub fn elapsed(&self) -> Result<Duration, SystemTimeError> {\n         SystemTime::now().duration_since(*self)\n     }\n+\n+    /// Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n+    /// `SystemTime` (which means it's inside the bounds of the underlying data structure), `None`\n+    /// otherwise.\n+    #[stable(feature = \"time_checked_add\", since = \"1.32.0\")]\n+    pub fn checked_add_duration(&self, duration: &Duration) -> Option<SystemTime> {\n+        self.0.checked_add_duration(duration).map(|t| SystemTime(t))\n+    }\n }\n \n #[stable(feature = \"time2\", since = \"1.8.0\")]\n@@ -557,6 +565,19 @@ mod tests {\n         let one_second_from_epoch2 = UNIX_EPOCH + Duration::new(0, 500_000_000)\n             + Duration::new(0, 500_000_000);\n         assert_eq!(one_second_from_epoch, one_second_from_epoch2);\n+\n+        // checked_add_duration will not panic on overflow\n+        let mut maybe_t = Some(SystemTime::UNIX_EPOCH);\n+        let max_duration = Duration::from_secs(u64::max_value());\n+        // in case `SystemTime` can store `>= UNIX_EPOCH + max_duration`.\n+        for _ in 0..2 {\n+            maybe_t = maybe_t.and_then(|t| t.checked_add_duration(&max_duration));\n+        }\n+        assert_eq!(maybe_t, None);\n+\n+        // checked_add_duration calculates the right time and will work for another year\n+        let year = Duration::from_secs(60 * 60 * 24 * 365);\n+        assert_eq!(a + year, a.checked_add_duration(&year).unwrap());\n     }\n \n     #[test]"}]}