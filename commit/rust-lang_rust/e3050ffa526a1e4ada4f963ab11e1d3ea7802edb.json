{"sha": "e3050ffa526a1e4ada4f963ab11e1d3ea7802edb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMDUwZmZhNTI2YTFlNGFkYTRmOTYzYWIxMWUxZDNlYTc4MDJlZGI=", "commit": {"author": {"name": "Zooko Wilcox-O'Hearn", "email": "zooko@zooko.com", "date": "2014-06-25T01:25:10Z"}, "committer": {"name": "Zooko Wilcox-O'Hearn", "email": "zooko@zooko.com", "date": "2014-06-25T01:25:10Z"}, "message": "Optimize out exhortations about being careful.\n\nYes, it is important to be careful, but repeated emphasis about it is probably\nnot helpful \u2014 it starts to sound like you came for a tutorial but found a\nfinger-wagging lecture.\n\nEven after I removed a few of these comments, there are still several left in\nthe text. That's probably fine! A couple of mentions of how this is dangerous\nand you ought to be careful may be a good reminder to the reader.\n\nAfter making the edits, I reflowed the paragraphs that I had touched, using\nemacs's \"M-x fill-paragraph\", with fill-column equal to 70.", "tree": {"sha": "104b1cae716b79d058590ac5d0373beb8e4cce6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/104b1cae716b79d058590ac5d0373beb8e4cce6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb", "html_url": "https://github.com/rust-lang/rust/commit/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb/comments", "author": {"login": "zooko", "id": 467900, "node_id": "MDQ6VXNlcjQ2NzkwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/467900?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zooko", "html_url": "https://github.com/zooko", "followers_url": "https://api.github.com/users/zooko/followers", "following_url": "https://api.github.com/users/zooko/following{/other_user}", "gists_url": "https://api.github.com/users/zooko/gists{/gist_id}", "starred_url": "https://api.github.com/users/zooko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zooko/subscriptions", "organizations_url": "https://api.github.com/users/zooko/orgs", "repos_url": "https://api.github.com/users/zooko/repos", "events_url": "https://api.github.com/users/zooko/events{/privacy}", "received_events_url": "https://api.github.com/users/zooko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zooko", "id": 467900, "node_id": "MDQ6VXNlcjQ2NzkwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/467900?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zooko", "html_url": "https://github.com/zooko", "followers_url": "https://api.github.com/users/zooko/followers", "following_url": "https://api.github.com/users/zooko/following{/other_user}", "gists_url": "https://api.github.com/users/zooko/gists{/gist_id}", "starred_url": "https://api.github.com/users/zooko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zooko/subscriptions", "organizations_url": "https://api.github.com/users/zooko/orgs", "repos_url": "https://api.github.com/users/zooko/repos", "events_url": "https://api.github.com/users/zooko/events{/privacy}", "received_events_url": "https://api.github.com/users/zooko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0550b79f73996b69e7f3540fc365b7e49455ca75", "url": "https://api.github.com/repos/rust-lang/rust/commits/0550b79f73996b69e7f3540fc365b7e49455ca75", "html_url": "https://github.com/rust-lang/rust/commit/0550b79f73996b69e7f3540fc365b7e49455ca75"}], "stats": {"total": 68, "additions": 33, "deletions": 35}, "files": [{"sha": "da577b88ac2f23ad001cf8b452957c3ef5173e2c", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3050ffa526a1e4ada4f963ab11e1d3ea7802edb/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=e3050ffa526a1e4ada4f963ab11e1d3ea7802edb", "patch": "@@ -3,13 +3,12 @@\n # Introduction\n \n Rust aims to provide safe abstractions over the low-level details of\n-the CPU and operating system, but sometimes one is forced to drop down\n-and write code at that level (those abstractions have to be created\n-somehow). This guide aims to provide an overview of the dangers and\n-power one gets with Rust's unsafe subset.\n+the CPU and operating system, but sometimes one needs to drop down and\n+write code at that level. This guide aims to provide an overview of\n+the dangers and power one gets with Rust's unsafe subset.\n \n Rust provides an escape hatch in the form of the `unsafe { ... }`\n-block which allows the programmer to dodge some of the compilers\n+block which allows the programmer to dodge some of the compiler's\n checks and do a wide range of operations, such as:\n \n - dereferencing [raw pointers](#raw-pointers)\n@@ -18,13 +17,12 @@ checks and do a wide range of operations, such as:\n - [inline assembly](#inline-assembly)\n \n Note that an `unsafe` block does not relax the rules about lifetimes\n-of `&` and the freezing of borrowed data, it just allows the use of\n-additional techniques for skirting the compiler's watchful eye. Any\n-use of `unsafe` is the programmer saying \"I know more than you\" to the\n-compiler, and, as such, the programmer should be very sure that they\n-actually do know more about why that piece of code is valid.\n+of `&` and the freezing of borrowed data.\n \n-In general, one should try to minimize the amount of unsafe code in a\n+Any use of `unsafe` is the programmer saying \"I know more than you\" to\n+the compiler, and, as such, the programmer should be very sure that\n+they actually do know more about why that piece of code is valid.  In\n+general, one should try to minimize the amount of unsafe code in a\n code base; preferably by using the bare minimum `unsafe` blocks to\n build safe interfaces.\n \n@@ -38,25 +36,25 @@ build safe interfaces.\n \n ## References\n \n-One of Rust's biggest goals as a language is ensuring memory safety,\n-achieved in part via [the lifetime system](guide-lifetimes.html) which\n-every `&` references has associated with it. This system is how the\n+One of Rust's biggest features is memory safety.  This is achieved in\n+part via [the lifetime system](guide-lifetimes.html), which is how the\n compiler can guarantee that every `&` reference is always valid, and,\n for example, never pointing to freed memory.\n \n-These restrictions on `&` have huge advantages. However, there's no\n-free lunch club. For example, `&` isn't a valid replacement for C's\n-pointers, and so cannot be used for FFI, in general. Additionally,\n-both immutable (`&`) and mutable (`&mut`) references have some\n-aliasing and freezing guarantees, required for memory safety.\n+These restrictions on `&` have huge advantages. However, they also\n+constrain how we can use them. For example, `&` doesn't behave\n+identically to C's pointers, and so cannot be used for pointers in\n+foreign function interfaces (FFI). Additionally, both immutable (`&`)\n+and mutable (`&mut`) references have some aliasing and freezing\n+guarantees, required for memory safety.\n \n In particular, if you have an `&T` reference, then the `T` must not be\n modified through that reference or any other reference. There are some\n standard library types, e.g. `Cell` and `RefCell`, that provide inner\n mutability by replacing compile time guarantees with dynamic checks at\n runtime.\n \n-An `&mut` reference has a stronger requirement: when an object has an\n+An `&mut` reference has a different constraint: when an object has an\n `&mut T` pointing into it, then that `&mut` reference must be the only\n such usable path to that object in the whole program. That is, an\n `&mut` cannot alias with any other references.\n@@ -106,19 +104,19 @@ offered by the Rust language and libraries. For example, they\n \n Fortunately, they come with a redeeming feature: the weaker guarantees\n mean weaker restrictions. The missing restrictions make raw pointers\n-appropriate as a building block for (carefully!) implementing things\n-like smart pointers and vectors inside libraries. For example, `*`\n-pointers are allowed to alias, allowing them to be used to write\n-shared-ownership types like reference counted and garbage collected\n-pointers, and even thread-safe shared memory types (`Rc` and the `Arc`\n-types are both implemented entirely in Rust).\n+appropriate as a building block for implementing things like smart\n+pointers and vectors inside libraries. For example, `*` pointers are\n+allowed to alias, allowing them to be used to write shared-ownership\n+types like reference counted and garbage collected pointers, and even\n+thread-safe shared memory types (`Rc` and the `Arc` types are both\n+implemented entirely in Rust).\n \n There are two things that you are required to be careful about\n (i.e. require an `unsafe { ... }` block) with raw pointers:\n \n - dereferencing: they can have any value: so possible results include\n   a crash, a read of uninitialised memory, a use-after-free, or\n-  reading data as normal (and one hopes happens).\n+  reading data as normal.\n - pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or\n   `.offset` method): this intrinsic uses so-called \"in-bounds\"\n   arithmetic, that is, it is only defined behaviour if the result is\n@@ -177,9 +175,10 @@ code:\n - store pointers privately (i.e. not in public fields of public\n   structs), so that you can see and control all reads and writes to\n   the pointer in one place.\n-- use `assert!()` a lot: once you've thrown away the protection of the\n-  compiler & type-system via `unsafe { ... }` you're left with just\n-  your wits and your `assert!()`s, any bug is potentially exploitable.\n+- use `assert!()` a lot: since you can't rely on the protection of the\n+  compiler & type-system to ensure that your `unsafe` code is correct\n+  at compile-time, use `assert!()` to verify that it is doing the\n+  right thing at run-time.\n - implement the `Drop` for resource clean-up via a destructor, and use\n   RAII (Resource Acquisition Is Initialization). This reduces the need\n   for any manual memory management by users, and automatically ensures\n@@ -298,8 +297,8 @@ asm!(assembly template\n Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n crate to allow) and of course requires an `unsafe` block.\n \n-> **Note**: the examples here are given in x86/x86-64 assembly, but all\n-> platforms are supported.\n+> **Note**: the examples here are given in x86/x86-64 assembly, but\n+> all platforms are supported.\n \n ## Assembly template\n \n@@ -497,7 +496,7 @@ detects that it will overflow its stack. The example above uses the\n > parts of the language may never be full specified and so details may\n > differ wildly between implementations (and even versions of `rustc`\n > itself).\n->\n+> \n > Furthermore, this is just an overview; the best form of\n > documentation for specific instances of these features are their\n > definitions and uses in `std`.\n@@ -584,8 +583,7 @@ fn main(_argc: int, _argv: **u8) -> int {\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to\n-return a valid pointer, and so needs to do the check\n-internally.\n+return a valid pointer, and so needs to do the check internally.\n \n Other features provided by lang items include:\n "}]}