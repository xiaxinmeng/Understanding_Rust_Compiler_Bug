{"sha": "08e2d4616613716362b4b49980ff303f2b9ae654", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZTJkNDYxNjYxMzcxNjM2MmI0YjQ5OTgwZmYzMDNmMmI5YWU2NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T12:26:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T12:26:54Z"}, "message": "Auto merge of #73905 - matthewjasper:projection-bounds-2, r=nikomatsakis\n\nSeparate projection bounds and predicates\n\nFollow up to #72788.\n\n- Rename `projection_predicates` to `item_bounds`\n- Separate bounds on associated types (the things after the `:` in `type X: ...`) and opaque types (the things after `impl`)  from predicates.\n- Projection candidates now have the correct nested obligations\n- Trait object candidates now check that the associated types on the trait object satisfy their bounds as nested obligations\n- Type alias impl trait types are now checked (#73035)\n- `feature(generic_associated_types)` no longer changes how we handle bounds (#73816)\n\nOpening for a perf and crater runs.\n\nr? `@nikomatsakis`", "tree": {"sha": "3140f61b9128491dae42380b257532428869d1e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3140f61b9128491dae42380b257532428869d1e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08e2d4616613716362b4b49980ff303f2b9ae654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08e2d4616613716362b4b49980ff303f2b9ae654", "html_url": "https://github.com/rust-lang/rust/commit/08e2d4616613716362b4b49980ff303f2b9ae654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08e2d4616613716362b4b49980ff303f2b9ae654/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5849a7eca90582ee59b67eb09548a2aa424d7f52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5849a7eca90582ee59b67eb09548a2aa424d7f52", "html_url": "https://github.com/rust-lang/rust/commit/5849a7eca90582ee59b67eb09548a2aa424d7f52"}, {"sha": "69fc6d8c5c27da57a399a3f5ab51f2ecf2bb954a", "url": "https://api.github.com/repos/rust-lang/rust/commits/69fc6d8c5c27da57a399a3f5ab51f2ecf2bb954a", "html_url": "https://github.com/rust-lang/rust/commit/69fc6d8c5c27da57a399a3f5ab51f2ecf2bb954a"}], "stats": {"total": 5940, "additions": 3604, "deletions": 2336}, "files": [{"sha": "4676ad5c31fca360b1b3478b5b3a87c1f131c36c", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -432,17 +432,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.with_catch_scope(body.id, |this| {\n             let mut block = this.lower_block_noalloc(body, true);\n \n-            let try_span = this.mark_span_with_reason(\n-                DesugaringKind::TryBlock,\n-                body.span,\n-                this.allow_try_trait.clone(),\n-            );\n-\n             // Final expression of the block (if present) or `()` with span at the end of block\n-            let tail_expr = block\n-                .expr\n-                .take()\n-                .unwrap_or_else(|| this.expr_unit(this.sess.source_map().end_point(try_span)));\n+            let (try_span, tail_expr) = if let Some(expr) = block.expr.take() {\n+                (\n+                    this.mark_span_with_reason(\n+                        DesugaringKind::TryBlock,\n+                        expr.span,\n+                        this.allow_try_trait.clone(),\n+                    ),\n+                    expr,\n+                )\n+            } else {\n+                let try_span = this.mark_span_with_reason(\n+                    DesugaringKind::TryBlock,\n+                    this.sess.source_map().end_point(body.span),\n+                    this.allow_try_trait.clone(),\n+                );\n+\n+                (try_span, this.expr_unit(try_span))\n+            };\n \n             let ok_wrapped_span =\n                 this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, None);\n@@ -1553,7 +1561,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::LangItem::TryFromError,\n                 unstable_span,\n                 from_expr,\n-                try_span,\n+                unstable_span,\n             );\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().copied();"}, {"sha": "82598aeec021598fa55e61164d209e28867d552f", "filename": "compiler/rustc_error_codes/src/error_codes/E0284.md", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0284.md?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,37 +5,29 @@ as the `collect` method for `Iterator`s.\n For example:\n \n ```compile_fail,E0284\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v: Vec<bool> = results.collect()?;\n-    // Do things with v...\n-    Ok(true)\n+fn main() {\n+    let n: u32 = 1;\n+    let mut d: u64 = 2;\n+    d = d + n.into();\n }\n ```\n \n-Here we have an iterator `results` over `Result<bool, ()>`.\n-Hence, `results.collect()` can return any type implementing\n-`FromIterator<Result<bool, ()>>`. On the other hand, the\n-`?` operator can accept any type implementing `Try`.\n+Here we have an addition of `d` and `n.into()`. Hence, `n.into()` can return\n+any type `T` where `u64: Add<T>`. On the other hand, the `into` method can\n+return any type where `u32: Into<T>`.\n \n-The author of this code probably wants `collect()` to return a\n-`Result<Vec<bool>, ()>`, but the compiler can't be sure\n-that there isn't another type `T` implementing both `Try` and\n-`FromIterator<Result<bool, ()>>` in scope such that\n-`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n-is returned.\n+The author of this code probably wants `into()` to return a `u64`, but the\n+compiler can't be sure that there isn't another type `T` where both\n+`u32: Into<T>` and `u64: Add<T>`.\n \n To resolve this error, use a concrete type for the intermediate expression:\n \n ```\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v = {\n-        let temp: Result<Vec<bool>, ()> = results.collect();\n-        temp?\n-    };\n-    // Do things with v...\n-    Ok(true)\n+fn main() {\n+    let n: u32 = 1;\n+    let mut d: u64 = 2;\n+    let m: u64 = n.into();\n+    d = d + m;\n }\n ```\n "}, {"sha": "e3365e8590b5edecf7d25beb7e04ee9fe2a46e10", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -2,7 +2,7 @@\n //! the end of the file for details.\n \n use super::combine::CombineFields;\n-use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n+use super::{HigherRankedType, InferCtxt};\n \n use crate::infer::CombinedSnapshot;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -33,7 +33,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(&b);\n+            let b_prime = self.infcx.replace_bound_vars_with_placeholders(&b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n@@ -66,10 +66,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    pub fn replace_bound_vars_with_placeholders<T>(\n-        &self,\n-        binder: &ty::Binder<T>,\n-    ) -> (T, PlaceholderMap<'tcx>)\n+    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: &ty::Binder<T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -122,7 +119,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             next_universe, binder, result, map,\n         );\n \n-        (result, map)\n+        result\n     }\n \n     /// See `infer::region_constraints::RegionConstraintCollector::leak_check`."}, {"sha": "9742f5e2346516339033b96264b0ed9ef362b6d1", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -351,11 +351,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     universe: Cell<ty::UniverseIndex>,\n }\n \n-/// A map returned by `replace_bound_vars_with_placeholders()`\n-/// indicating the placeholder region that each late-bound region was\n-/// replaced with.\n-pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n-\n /// See the `error_reporting` module for more details.\n #[derive(Clone, Debug, PartialEq, Eq, TypeFoldable)]\n pub enum ValuePairs<'tcx> {\n@@ -992,7 +987,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         Some(self.commit_if_ok(|_snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b }, _) =\n+            let ty::SubtypePredicate { a_is_expected, a, b } =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -1007,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|_snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), _) =\n+            let ty::OutlivesPredicate(r_a, r_b) =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)"}, {"sha": "2b827f4f4eddc43411296d763d75c4cd3995b1cc", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -328,8 +328,8 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         assoc_item_def_id: DefId,\n     ) -> impl Iterator<Item = ty::Region<'tcx>> {\n         let tcx = self.tcx;\n-        let predicates = tcx.projection_predicates(assoc_item_def_id);\n-        predicates\n+        let bounds = tcx.item_bounds(assoc_item_def_id);\n+        bounds\n             .into_iter()\n             .filter_map(|p| p.to_opt_type_outlives())\n             .filter_map(|p| p.no_bound_vars())"}, {"sha": "1b7269706a7583f61b1e880290249c8a62614a33", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -4,7 +4,6 @@ use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n-use rustc_span::Span;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -94,7 +93,11 @@ pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n ) -> Elaborator<'tcx> {\n-    let obligations = predicates.map(|predicate| predicate_obligation(predicate, None)).collect();\n+    let obligations = predicates\n+        .map(|predicate| {\n+            predicate_obligation(predicate, ty::ParamEnv::empty(), ObligationCause::dummy())\n+        })\n+        .collect();\n     elaborate_obligations(tcx, obligations)\n }\n \n@@ -109,15 +112,10 @@ pub fn elaborate_obligations<'tcx>(\n \n fn predicate_obligation<'tcx>(\n     predicate: ty::Predicate<'tcx>,\n-    span: Option<Span>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> PredicateObligation<'tcx> {\n-    let cause = if let Some(span) = span {\n-        ObligationCause::dummy_with_span(span)\n-    } else {\n-        ObligationCause::dummy()\n-    };\n-\n-    Obligation { cause, param_env: ty::ParamEnv::empty(), recursion_depth: 0, predicate }\n+    Obligation { cause, param_env, recursion_depth: 0, predicate }\n }\n \n impl Elaborator<'tcx> {\n@@ -133,10 +131,11 @@ impl Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(pred, span)| {\n+                let obligations = predicates.predicates.iter().map(|&(pred, _)| {\n                     predicate_obligation(\n                         pred.subst_supertrait(tcx, &ty::Binder::bind(data.trait_ref)),\n-                        Some(span),\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n                     )\n                 });\n                 debug!(\"super_predicates: data={:?}\", data);\n@@ -233,7 +232,13 @@ impl Elaborator<'tcx> {\n                         })\n                         .map(|predicate_kind| predicate_kind.to_predicate(tcx))\n                         .filter(|&predicate| visited.insert(predicate))\n-                        .map(|predicate| predicate_obligation(predicate, None)),\n+                        .map(|predicate| {\n+                            predicate_obligation(\n+                                predicate,\n+                                obligation.param_env,\n+                                obligation.cause.clone(),\n+                            )\n+                        }),\n                 );\n             }\n             ty::PredicateAtom::TypeWellFormedFromEnv(..) => {"}, {"sha": "3abd9a6325d6ee0e1a061546693efd4a69ed536f", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Adt(def, _) => check_must_use_def(cx, def.did, span, descr_pre, descr_post),\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n-                    for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n+                    for &(predicate, _) in cx.tcx.explicit_item_bounds(def) {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateAtom::Trait(ref poly_trait_predicate, _) =\n                             predicate.skip_binders()"}, {"sha": "2662f6b6ed65cec9781549636b480ea35045e207", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -937,7 +937,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .inferred_outlives\n             .get(self, item_id)\n-            .map(|predicates| predicates.decode((self, tcx)))\n+            .map(|predicates| tcx.arena.alloc_from_iter(predicates.decode((self, tcx))))\n             .unwrap_or_default()\n     }\n \n@@ -949,6 +949,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n+    fn get_explicit_item_bounds(\n+        &self,\n+        item_id: DefIndex,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+        self.root\n+            .tables\n+            .explicit_item_bounds\n+            .get(self, item_id)\n+            .map(|bounds| tcx.arena.alloc_from_iter(bounds.decode((self, tcx))))\n+            .unwrap_or_default()\n+    }\n+\n     fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n         self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n     }"}, {"sha": "60705f68681a1d6170a600ff5a05533695f3af7e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -89,6 +89,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n     inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n+    explicit_item_bounds => { cdata.get_explicit_item_bounds(def_id.index, tcx) }\n     trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {"}, {"sha": "f0911928e81c9cf97e5d1782a8bbc6dc77fb6083", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -965,6 +965,14 @@ impl EncodeContext<'a, 'tcx> {\n         record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n     }\n \n+    fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n+        let bounds = self.tcx.explicit_item_bounds(def_id);\n+        if !bounds.is_empty() {\n+            record!(self.tables.explicit_item_bounds[def_id] <- bounds);\n+        }\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -1017,7 +1025,10 @@ impl EncodeContext<'a, 'tcx> {\n                     has_self: trait_item.fn_has_self_parameter,\n                 }))\n             }\n-            ty::AssocKind::Type => EntryKind::AssocType(container),\n+            ty::AssocKind::Type => {\n+                self.encode_explicit_item_bounds(def_id);\n+                EntryKind::AssocType(container)\n+            }\n         });\n         record!(self.tables.visibility[def_id] <- trait_item.vis);\n         record!(self.tables.span[def_id] <- ast_item.span);\n@@ -1255,7 +1266,10 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n             hir::ItemKind::TyAlias(..) => EntryKind::Type,\n-            hir::ItemKind::OpaqueTy(..) => EntryKind::OpaqueTy,\n+            hir::ItemKind::OpaqueTy(..) => {\n+                self.encode_explicit_item_bounds(def_id);\n+                EntryKind::OpaqueTy\n+            }\n             hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);"}, {"sha": "2bd2019d3cdb529b617f00d274ee4db57e7470bc", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -295,13 +295,11 @@ define_tables! {\n     generics: Table<DefIndex, Lazy<ty::Generics>>,\n     explicit_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n-    // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n-    // doesn't handle shorthands in its own (de)serialization impls,\n-    // as it's an `enum` for which we want to derive (de)serialization,\n-    // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n-    // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    inferred_outlives: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n     super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n     mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n     promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n     mir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [mir::abstract_const::Node<'tcx>])>,"}, {"sha": "fc4c343372a425d980d065e660f3db5a2459aa72", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -156,21 +156,42 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        /// Returns the list of predicates that can be used for\n-        /// `SelectionCandidate::ProjectionCandidate` and\n+        /// Returns the list of bounds that can be used for\n+        /// `SelectionCandidate::ProjectionCandidate(_)` and\n         /// `ProjectionTyCandidate::TraitDef`.\n-        /// Specifically this is the bounds (equivalent to) those\n-        /// written on the trait's type definition, or those\n-        /// after the `impl` keyword\n+        /// Specifically this is the bounds written on the trait's type\n+        /// definition, or those after the `impl` keyword\n         ///\n         /// type X: Bound + 'lt\n         ///         ^^^^^^^^^^^\n         /// impl Debug + Display\n         ///      ^^^^^^^^^^^^^^^\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n-        query projection_predicates(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-            desc { |tcx| \"finding projection predicates for `{}`\", tcx.def_path_str(key) }\n+        ///\n+        /// Bounds from the parent (e.g. with nested impl trait) are not included.\n+        query explicit_item_bounds(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+            desc { |tcx| \"finding item bounds for `{}`\", tcx.def_path_str(key) }\n+        }\n+\n+        /// Elaborated version of the predicates from `explicit_item_bounds`.\n+        ///\n+        /// Example for\n+        ///\n+        /// trait MyTrait {\n+        ///     type MyAType: Eq + ?Sized`\n+        /// }\n+        ///\n+        /// `explicit_item_bounds` returns `[<Self as MyTrait>::MyAType: Eq]`,\n+        /// and `item_bounds` returns\n+        /// [\n+        ///     <Self as Trait>::MyAType: Eq,\n+        ///     <Self as Trait>::MyAType: PartialEq<<Self as Trait>::MyAType>\n+        /// ]\n+        ///\n+        /// Bounds from the parent (e.g. with nested impl trait) are not included.\n+        query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+            desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n         }\n \n         query projection_ty_from_predicates(key: (DefId, DefId)) -> Option<ty::ProjectionTy<'tcx>> {\n@@ -370,6 +391,24 @@ rustc_queries! {\n             desc { |tcx| \"computing predicates of `{}`\", tcx.def_path_str(key) }\n         }\n \n+        /// Returns everything that looks like a predicate written explicitly\n+        /// by the user on a trait item.\n+        ///\n+        /// Traits are unusual, because predicates on associated types are\n+        /// converted into bounds on that type for backwards compatibility:\n+        ///\n+        /// trait X where Self::U: Copy { type U; }\n+        ///\n+        /// becomes\n+        ///\n+        /// trait X { type U: Copy; }\n+        ///\n+        /// `explicit_predicates_of` and `explicit_item_bounds` will then take\n+        /// the appropriate subsets of the predicates here.\n+        query trait_explicit_predicates_and_bounds(key: LocalDefId) -> ty::GenericPredicates<'tcx> {\n+            desc { |tcx| \"computing explicit predicates of trait `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+\n         /// Returns the predicates written explicitly by the user.\n         query explicit_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing explicit predicates of `{}`\", tcx.def_path_str(key) }"}, {"sha": "358ead507b4d0465f590081913acb6e517569f54", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -105,9 +105,10 @@ pub enum SelectionCandidate<'tcx> {\n     ImplCandidate(DefId),\n     AutoImplCandidate(DefId),\n \n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n+    /// This is a trait matching with a projected type as `Self`, and we found\n+    /// an applicable bound in the trait definition. The `usize` is an index\n+    /// into the list returned by `tcx.item_bounds`.\n+    ProjectionCandidate(usize),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n     /// generated for a `||` expression."}, {"sha": "e1f02d0f70418547704cb820a7613ded670ed572", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -607,12 +607,13 @@ pub trait PrettyPrinter<'tcx>:\n                     }\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+                    let bounds = self.tcx().explicit_item_bounds(def_id);\n \n                     let mut first = true;\n                     let mut is_sized = false;\n                     p!(\"impl\");\n-                    for predicate in bounds.predicates {\n+                    for (predicate, _) in bounds {\n+                        let predicate = predicate.subst(self.tcx(), substs);\n                         // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n                         // may contain unbound variables. We therefore do this manually.\n                         //"}, {"sha": "1af56972ad083b0e67531f916ef4d39b822a7c07", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1513,6 +1513,9 @@ impl<'tcx> ExistentialProjection<'tcx> {\n     /// then this function would return a `exists T. T: Iterator` existential trait\n     /// reference.\n     pub fn trait_ref(&self, tcx: TyCtxt<'_>) -> ty::ExistentialTraitRef<'tcx> {\n+        // FIXME(generic_associated_types): substs is the substs of the\n+        // associated type, which should be truncated to get the correct substs\n+        // for the trait.\n         let def_id = tcx.associated_item(self.item_def_id).container.id();\n         ty::ExistentialTraitRef { def_id, substs: self.substs }\n     }"}, {"sha": "e22dab0151703ee160ea32973927df498adae61e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,6 +6,7 @@ use rustc_infer::infer::{\n     error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n@@ -585,14 +586,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = self.infcx.tcx.predicates_of(did);\n-                    let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n+                    let bounds = self.infcx.tcx.explicit_item_bounds(did);\n \n                     let mut found = false;\n-                    for predicate in bounds.predicates {\n+                    for (bound, _) in bounds {\n                         if let ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            predicate.skip_binders()\n+                            bound.skip_binders()\n                         {\n+                            let r = r.subst(self.infcx.tcx, substs);\n                             if let ty::RegionKind::ReStatic = r {\n                                 found = true;\n                                 break;"}, {"sha": "8f93bce6e99237dd344e6a0d572848e9c4df8759", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -194,11 +194,14 @@ where\n                     // The intent is to treat `impl Trait1 + Trait2` identically to\n                     // `dyn Trait1 + Trait2`. Therefore we ignore def-id of the opaque type itself\n                     // (it either has no visibility, or its visibility is insignificant, like\n-                    // visibilities of type aliases) and recurse into predicates instead to go\n+                    // visibilities of type aliases) and recurse into bounds instead to go\n                     // through the trait list (default type visitor doesn't visit those traits).\n                     // All traits in the list are considered the \"primary\" part of the type\n                     // and are visited by shallow visitors.\n-                    if self.visit_predicates(tcx.predicates_of(def_id)) {\n+                    if self.visit_predicates(ty::GenericPredicates {\n+                        parent: None,\n+                        predicates: tcx.explicit_item_bounds(def_id),\n+                    }) {\n                         return true;\n                     }\n                 }\n@@ -1800,6 +1803,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         self\n     }\n \n+    fn bounds(&mut self) -> &mut Self {\n+        self.visit_predicates(ty::GenericPredicates {\n+            parent: None,\n+            predicates: self.tcx.explicit_item_bounds(self.item_def_id),\n+        });\n+        self\n+    }\n+\n     fn ty(&mut self) -> &mut Self {\n         self.visit(self.tcx.type_of(self.item_def_id));\n         self\n@@ -1975,7 +1986,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemKind::OpaqueTy(..) => {\n                 // `ty()` for opaque types is the underlying type,\n                 // it's not a part of interface, so we skip it.\n-                self.check(item.hir_id, item_visibility).generics().predicates();\n+                self.check(item.hir_id, item_visibility).generics().bounds();\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n@@ -1987,6 +1998,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                         trait_item_ref.defaultness,\n                         item_visibility,\n                     );\n+\n+                    if let AssocItemKind::Type = trait_item_ref.kind {\n+                        self.check(trait_item_ref.id.hir_id, item_visibility).bounds();\n+                    }\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {"}, {"sha": "610c6fd7e35f8450cffb64ff0744638244797ada", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,7 +10,7 @@ use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::config::nightly_options;\n use rustc_span::Span;\n@@ -428,14 +428,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // If there are required region bounds, we can use them.\n         if opaque_defn.has_required_region_bounds {\n-            let predicates_of = tcx.predicates_of(def_id);\n-            debug!(\"constrain_opaque_type: predicates: {:#?}\", predicates_of,);\n-            let bounds = predicates_of.instantiate(tcx, opaque_defn.substs);\n+            let bounds = tcx.explicit_item_bounds(def_id);\n+            debug!(\"constrain_opaque_type: predicates: {:#?}\", bounds);\n+            let bounds: Vec<_> =\n+                bounds.iter().map(|(bound, _)| bound.subst(tcx, opaque_defn.substs)).collect();\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n             let required_region_bounds =\n-                required_region_bounds(tcx, opaque_type, bounds.predicates.into_iter());\n+                required_region_bounds(tcx, opaque_type, bounds.into_iter());\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for required_region in required_region_bounds {\n@@ -1112,9 +1113,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         let ty_var = infcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n \n-        let predicates_of = tcx.predicates_of(def_id);\n-        debug!(\"instantiate_opaque_types: predicates={:#?}\", predicates_of,);\n-        let bounds = predicates_of.instantiate(tcx, substs);\n+        let item_bounds = tcx.explicit_item_bounds(def_id);\n+        debug!(\"instantiate_opaque_types: bounds={:#?}\", item_bounds);\n+        let bounds: Vec<_> =\n+            item_bounds.iter().map(|(bound, _)| bound.subst(tcx, substs)).collect();\n \n         let param_env = tcx.param_env(def_id);\n         let InferOk { value: bounds, obligations } =\n@@ -1123,8 +1125,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n-        let required_region_bounds =\n-            required_region_bounds(tcx, ty, bounds.predicates.iter().cloned());\n+        let required_region_bounds = required_region_bounds(tcx, ty, bounds.iter().copied());\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n@@ -1153,7 +1154,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         );\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n-        for predicate in &bounds.predicates {\n+        for predicate in &bounds {\n             if let ty::PredicateAtom::Projection(projection) = predicate.skip_binders() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n@@ -1162,14 +1163,14 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             }\n         }\n \n-        self.obligations.reserve(bounds.predicates.len());\n-        for predicate in bounds.predicates {\n+        self.obligations.reserve(bounds.len());\n+        for predicate in bounds {\n             // Change the predicate to refer to the type variable,\n             // which will be the concrete type instead of the opaque type.\n             // This also instantiates nested instances of `impl Trait`.\n             let predicate = self.instantiate_opaque_types_in_map(&predicate);\n \n-            let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);\n+            let cause = traits::ObligationCause::new(span, self.body_id, traits::MiscObligation);\n \n             // Require that the predicate holds for the concrete type.\n             debug!(\"instantiate_opaque_types: predicate={:?}\", predicate);"}, {"sha": "27751eb554d3c4dddf42dd74f526e8f9ad2ef9e6", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 | ty::PredicateAtom::Subtype(_)\n                 | ty::PredicateAtom::ConstEvaluatable(..)\n                 | ty::PredicateAtom::ConstEquate(..) => {\n-                    let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n+                    let pred = infcx.replace_bound_vars_with_placeholders(binder);\n                     ProcessResult::Changed(mk_pending(vec![\n                         obligation.with(pred.to_predicate(self.selcx.tcx())),\n                     ]))\n@@ -449,6 +449,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         self.selcx.infcx(),\n                         obligation.param_env,\n                         obligation.cause.body_id,\n+                        obligation.recursion_depth + 1,\n                         arg,\n                         obligation.cause.span,\n                     ) {\n@@ -672,7 +673,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n             Ok(Ok(None)) => {\n                 *stalled_on = trait_ref_infer_vars(\n                     self.selcx,\n-                    project_obligation.predicate.to_poly_trait_ref(self.selcx.tcx()),\n+                    project_obligation.predicate.to_poly_trait_ref(tcx),\n                 );\n                 ProcessResult::Unchanged\n             }"}, {"sha": "0e43f1655ddb2f0c23a1d532344f3254f1230174", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -160,6 +160,10 @@ fn object_safety_violations_for_trait(\n     if !spans.is_empty() {\n         violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n     }\n+    let spans = bounds_reference_self(tcx, trait_def_id);\n+    if !spans.is_empty() {\n+        violations.push(ObjectSafetyViolation::SupertraitSelf(spans));\n+    }\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n@@ -239,51 +243,70 @@ fn predicates_reference_self(\n     } else {\n         tcx.predicates_of(trait_def_id)\n     };\n-    let self_ty = tcx.types.self_param;\n-    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n     predicates\n         .predicates\n         .iter()\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n-        .filter_map(|(predicate, &sp)| {\n-            match predicate.skip_binders() {\n-                ty::PredicateAtom::Trait(ref data, _) => {\n-                    // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n-                }\n-                ty::PredicateAtom::Projection(ref data) => {\n-                    // And similarly for projections. This should be redundant with\n-                    // the previous check because any projection should have a\n-                    // matching `Trait` predicate with the same inputs, but we do\n-                    // the check to be safe.\n-                    //\n-                    // Note that we *do* allow projection *outputs* to contain\n-                    // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n-                    // we just require the user to specify *both* outputs\n-                    // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n-                    //\n-                    // This is ALT2 in issue #56288, see that for discussion of the\n-                    // possible alternatives.\n-                    if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n-                        Some(sp)\n-                    } else {\n-                        None\n-                    }\n-                }\n-                ty::PredicateAtom::WellFormed(..)\n-                | ty::PredicateAtom::ObjectSafe(..)\n-                | ty::PredicateAtom::TypeOutlives(..)\n-                | ty::PredicateAtom::RegionOutlives(..)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::Subtype(..)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..)\n-                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-            }\n-        })\n+        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .filter_map(|predicate| predicate_references_self(tcx, predicate))\n+        .collect()\n+}\n+\n+fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]> {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef::identity(tcx, trait_def_id));\n+    tcx.associated_items(trait_def_id)\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Type)\n+        .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n+        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n \n+fn predicate_references_self(\n+    tcx: TyCtxt<'tcx>,\n+    (predicate, sp): (ty::Predicate<'tcx>, Span),\n+) -> Option<Span> {\n+    let self_ty = tcx.types.self_param;\n+    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(ref data, _) => {\n+            // In the case of a trait predicate, we can skip the \"self\" type.\n+            if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n+        }\n+        ty::PredicateAtom::Projection(ref data) => {\n+            // And similarly for projections. This should be redundant with\n+            // the previous check because any projection should have a\n+            // matching `Trait` predicate with the same inputs, but we do\n+            // the check to be safe.\n+            //\n+            // It's also won't be redundant if we allow type-generic associated\n+            // types for trait objects.\n+            //\n+            // Note that we *do* allow projection *outputs* to contain\n+            // `self` (i.e., `trait Foo: Bar<Output=Self::Result> { type Result; }`),\n+            // we just require the user to specify *both* outputs\n+            // in the object type (i.e., `dyn Foo<Output=(), Result=()>`).\n+            //\n+            // This is ALT2 in issue #56288, see that for discussion of the\n+            // possible alternatives.\n+            if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n+                Some(sp)\n+            } else {\n+                None\n+            }\n+        }\n+        ty::PredicateAtom::WellFormed(..)\n+        | ty::PredicateAtom::ObjectSafe(..)\n+        | ty::PredicateAtom::TypeOutlives(..)\n+        | ty::PredicateAtom::RegionOutlives(..)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::Subtype(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..)\n+        | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+    }\n+}\n+\n fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n     generics_require_sized_self(tcx, trait_def_id)\n }"}, {"sha": "de42aa0e6b764ca69ae2930879729920ebc99562", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 162, "deletions": 153, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,6 +1,5 @@\n //! Code for projecting associated types out of trait references.\n \n-use super::elaborate_predicates;\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n@@ -29,7 +28,6 @@ use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_span::symbol::sym;\n-use rustc_span::DUMMY_SP;\n \n pub use rustc_middle::traits::Reveal;\n \n@@ -53,13 +51,16 @@ pub enum ProjectionTyError<'tcx> {\n \n #[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n-    // from a where-clause in the env or object type\n+    /// From a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n \n-    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n+    /// From the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n     TraitDef(ty::PolyProjectionPredicate<'tcx>),\n \n-    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    /// Bounds specified on an object type\n+    Object(ty::PolyProjectionPredicate<'tcx>),\n+\n+    /// From a \"impl\" (or a \"pseudo-impl\" returned by select)\n     Select(Selection<'tcx>),\n }\n \n@@ -167,7 +168,7 @@ pub(super) fn poly_project_and_unify_type<'cx, 'tcx>(\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|_snapshot| {\n-        let (placeholder_predicate, _) =\n+        let placeholder_predicate =\n             infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n \n         let placeholder_obligation = obligation.with(placeholder_predicate);\n@@ -561,14 +562,6 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             } else {\n                 obligations.extend(ty.obligations);\n             }\n-\n-            obligations.push(get_paranoid_cache_value_obligation(\n-                infcx,\n-                param_env,\n-                projection_ty,\n-                cause,\n-                depth,\n-            ));\n             return Ok(Some(ty.value));\n         }\n         Err(ProjectionCacheEntry::Error) => {\n@@ -703,45 +696,6 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     NormalizedTy { value: result.value, obligations }\n }\n \n-/// Whenever we give back a cache result for a projection like `<T as\n-/// Trait>::Item ==> X`, we *always* include the obligation to prove\n-/// that `T: Trait` (we may also include some other obligations). This\n-/// may or may not be necessary -- in principle, all the obligations\n-/// that must be proven to show that `T: Trait` were also returned\n-/// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precautionary measure of including `T: Trait` in\n-/// the result:\n-///\n-/// Concern #1. The current setup is fragile. Perhaps someone could\n-/// have failed to prove the concerns from when the cache was\n-/// populated, but also not have used a snapshot, in which case the\n-/// cache could remain populated even though `T: Trait` has not been\n-/// shown. In this case, the \"other code\" is at fault -- when you\n-/// project something, you are supposed to either have a snapshot or\n-/// else prove all the resulting obligations -- but it's still easy to\n-/// get wrong.\n-///\n-/// Concern #2. Even within the snapshot, if those original\n-/// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong. This *may* lead to some sort\n-/// of trouble, though we don't have a concrete example of how that\n-/// can occur yet. But it seems risky at best.\n-fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    Obligation {\n-        cause,\n-        recursion_depth: depth,\n-        param_env,\n-        predicate: trait_ref.without_const().to_predicate(infcx.tcx),\n-    }\n-}\n-\n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n /// hold. In various error cases, we cannot generate a valid\n /// normalized projection. Therefore, we create an inference variable\n@@ -848,12 +802,21 @@ fn project_type<'cx, 'tcx>(\n \n     assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n \n-    assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    assemble_candidates_from_object_ty(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+\n+    if let ProjectionTyCandidateSet::Single(ProjectionTyCandidate::Object(_)) = candidates {\n+        // Avoid normalization cycle from selection (see\n+        // `assemble_candidates_from_object_ty`).\n+        // FIXME(lazy_normalization): Lazy normalization should save us from\n+        // having to do special case this.\n+    } else {\n+        assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+    };\n \n     match candidates {\n-        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n-            confirm_candidate(selcx, obligation, &obligation_trait_ref, candidate),\n-        )),\n+        ProjectionTyCandidateSet::Single(candidate) => {\n+            Ok(ProjectedTy::Progress(confirm_candidate(selcx, obligation, candidate)))\n+        }\n         ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n             selcx\n                 .tcx()\n@@ -884,6 +847,7 @@ fn assemble_candidates_from_param_env<'cx, 'tcx>(\n         candidate_set,\n         ProjectionTyCandidate::ParamEnv,\n         obligation.param_env.caller_bounds().iter(),\n+        false,\n     );\n }\n \n@@ -909,10 +873,8 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n     let bounds = match *obligation_trait_ref.self_ty().kind() {\n-        ty::Projection(ref data) => {\n-            tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n-        }\n-        ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n+        ty::Projection(ref data) => tcx.item_bounds(data.item_def_id).subst(tcx, data.substs),\n+        ty::Opaque(def_id, substs) => tcx.item_bounds(def_id).subst(tcx, substs),\n         ty::Infer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -929,16 +891,65 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n         candidate_set,\n         ProjectionTyCandidate::TraitDef,\n         bounds.iter(),\n+        true,\n     )\n }\n \n+/// In the case of a trait object like\n+/// `<dyn Iterator<Item = ()> as Iterator>::Item` we can use the existential\n+/// predicate in the trait object.\n+///\n+/// We don't go through the select candidate for these bounds to avoid cycles:\n+/// In the above case, `dyn Iterator<Item = ()>: Iterator` would create a\n+/// nested obligation of `<dyn Iterator<Item = ()> as Iterator>::Item: Sized`,\n+/// this then has to be normalized without having to prove\n+/// `dyn Iterator<Item = ()>: Iterator` again.\n+fn assemble_candidates_from_object_ty<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n+    debug!(\"assemble_candidates_from_object_ty(..)\");\n+\n+    let tcx = selcx.tcx();\n+\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    let data = match object_ty.kind() {\n+        ty::Dynamic(data, ..) => data,\n+        ty::Infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being an object type, so induce an ambiguity.\n+            candidate_set.mark_ambiguous();\n+            return;\n+        }\n+        _ => return,\n+    };\n+    let env_predicates = data\n+        .projection_bounds()\n+        .filter(|bound| bound.item_def_id() == obligation.predicate.item_def_id)\n+        .map(|p| p.with_self_ty(tcx, object_ty).to_predicate(tcx));\n+\n+    assemble_candidates_from_predicates(\n+        selcx,\n+        obligation,\n+        obligation_trait_ref,\n+        candidate_set,\n+        ProjectionTyCandidate::Object,\n+        env_predicates,\n+        false,\n+    );\n+}\n+\n fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n+    potentially_unnormalized_candidates: bool,\n ) {\n     debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n     let infcx = selcx.infcx();\n@@ -950,16 +961,12 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n \n             let is_match = same_def_id\n                 && infcx.probe(|_| {\n-                    let data_poly_trait_ref = data.to_poly_trait_ref(infcx.tcx);\n-                    let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-                    infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                        .map(|InferOk { obligations: _, value: () }| {\n-                            // FIXME(#32730) -- do we need to take obligations\n-                            // into account in any way? At the moment, no.\n-                        })\n-                        .is_ok()\n+                    selcx.match_projection_projections(\n+                        obligation,\n+                        obligation_trait_ref,\n+                        &data,\n+                        potentially_unnormalized_candidates,\n+                    )\n                 });\n \n             debug!(\n@@ -970,6 +977,15 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n \n             if is_match {\n                 candidate_set.push_candidate(ctor(data));\n+\n+                if potentially_unnormalized_candidates\n+                    && !obligation.predicate.has_infer_types_or_consts()\n+                {\n+                    // HACK: Pick the first trait def candidate for a fully\n+                    // inferred predicate. This is to allow duplicates that\n+                    // differ only in normalization.\n+                    return;\n+                }\n             }\n         }\n     }\n@@ -1003,7 +1019,6 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n             super::ImplSource::Closure(_)\n             | super::ImplSource::Generator(_)\n             | super::ImplSource::FnPointer(_)\n-            | super::ImplSource::Object(_)\n             | super::ImplSource::TraitAlias(_) => {\n                 debug!(\"assemble_candidates_from_impls: impl_source={:?}\", impl_source);\n                 true\n@@ -1128,6 +1143,12 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // in `assemble_candidates_from_param_env`.\n                 false\n             }\n+            super::ImplSource::Object(_) => {\n+                // Handled by the `Object` projection candidate. See\n+                // `assemble_candidates_from_object_ty` for an explanation of\n+                // why we special case object types.\n+                false\n+            }\n             super::ImplSource::AutoImpl(..) | super::ImplSource::Builtin(..) => {\n                 // These traits have no associated types.\n                 selcx.tcx().sess.delay_span_bug(\n@@ -1153,19 +1174,22 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n fn confirm_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>,\n ) -> Progress<'tcx> {\n     debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n \n     let mut progress = match candidate {\n         ProjectionTyCandidate::ParamEnv(poly_projection)\n-        | ProjectionTyCandidate::TraitDef(poly_projection) => {\n-            confirm_param_env_candidate(selcx, obligation, poly_projection)\n+        | ProjectionTyCandidate::Object(poly_projection) => {\n+            confirm_param_env_candidate(selcx, obligation, poly_projection, false)\n+        }\n+\n+        ProjectionTyCandidate::TraitDef(poly_projection) => {\n+            confirm_param_env_candidate(selcx, obligation, poly_projection, true)\n         }\n \n         ProjectionTyCandidate::Select(impl_source) => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref, impl_source)\n+            confirm_select_candidate(selcx, obligation, impl_source)\n         }\n     };\n     // When checking for cycle during evaluation, we compare predicates with\n@@ -1182,7 +1206,6 @@ fn confirm_candidate<'cx, 'tcx>(\n fn confirm_select_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     impl_source: Selection<'tcx>,\n ) -> Progress<'tcx> {\n     match impl_source {\n@@ -1193,10 +1216,8 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::ImplSource::DiscriminantKind(data) => {\n             confirm_discriminant_kind_candidate(selcx, obligation, data)\n         }\n-        super::ImplSource::Object(_) => {\n-            confirm_object_candidate(selcx, obligation, obligation_trait_ref)\n-        }\n-        super::ImplSource::AutoImpl(..)\n+        super::ImplSource::Object(_)\n+        | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n         | super::ImplSource::Builtin(..)\n         | super::ImplSource::TraitAlias(..) =>\n@@ -1211,72 +1232,6 @@ fn confirm_select_candidate<'cx, 'tcx>(\n     }\n }\n \n-fn confirm_object_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-) -> Progress<'tcx> {\n-    let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n-    debug!(\"confirm_object_candidate(object_ty={:?})\", object_ty);\n-    let data = match object_ty.kind() {\n-        ty::Dynamic(data, ..) => data,\n-        _ => span_bug!(\n-            obligation.cause.span,\n-            \"confirm_object_candidate called with non-object: {:?}\",\n-            object_ty\n-        ),\n-    };\n-    let env_predicates = data\n-        .projection_bounds()\n-        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate(selcx.tcx()));\n-    let env_predicate = {\n-        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-\n-        // select only those projections that are actually projecting an\n-        // item with the correct name\n-\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate.skip_binders() {\n-            ty::PredicateAtom::Projection(data)\n-                if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n-            {\n-                Some(ty::Binder::bind(data))\n-            }\n-            _ => None,\n-        });\n-\n-        // select those with a relevant trait-ref\n-        let mut env_predicates = env_predicates.filter(|data| {\n-            let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n-            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-            selcx.infcx().probe(|_| {\n-                selcx\n-                    .infcx()\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                    .is_ok()\n-            })\n-        });\n-\n-        // select the first matching one; there really ought to be one or\n-        // else the object type is not WF, since an object type should\n-        // include all of its projections explicitly\n-        match env_predicates.next() {\n-            Some(env_predicate) => env_predicate,\n-            None => {\n-                debug!(\n-                    \"confirm_object_candidate: no env-predicate \\\n-                     found in object type `{:?}`; ill-formed\",\n-                    object_ty\n-                );\n-                return Progress::error(selcx.tcx());\n-            }\n-        }\n-    };\n-\n-    confirm_param_env_candidate(selcx, obligation, env_predicate)\n-}\n-\n fn confirm_generator_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n@@ -1325,7 +1280,7 @@ fn confirm_generator_candidate<'cx, 'tcx>(\n         }\n     });\n \n-    confirm_param_env_candidate(selcx, obligation, predicate)\n+    confirm_param_env_candidate(selcx, obligation, predicate, false)\n         .with_addl_obligations(impl_source.nested)\n         .with_addl_obligations(obligations)\n }\n@@ -1347,7 +1302,7 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n         ty: self_ty.discriminant_ty(tcx),\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate))\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n@@ -1422,13 +1377,14 @@ fn confirm_callable_candidate<'cx, 'tcx>(\n         ty: ret_type,\n     });\n \n-    confirm_param_env_candidate(selcx, obligation, predicate)\n+    confirm_param_env_candidate(selcx, obligation, predicate, false)\n }\n \n fn confirm_param_env_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n+    potentially_unnormalized_candidate: bool,\n ) -> Progress<'tcx> {\n     let infcx = selcx.infcx();\n     let cause = &obligation.cause;\n@@ -1442,8 +1398,28 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n \n     let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n     let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    let mut nested_obligations = Vec::new();\n+    let cache_trait_ref = if potentially_unnormalized_candidate {\n+        ensure_sufficient_stack(|| {\n+            normalize_with_depth_to(\n+                selcx,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &cache_trait_ref,\n+                &mut nested_obligations,\n+            )\n+        })\n+    } else {\n+        cache_trait_ref\n+    };\n+\n     match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n-        Ok(InferOk { value: _, obligations }) => Progress { ty: cache_entry.ty, obligations },\n+        Ok(InferOk { value: _, obligations }) => {\n+            nested_obligations.extend(obligations);\n+            assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);\n+            Progress { ty: cache_entry.ty, obligations: nested_obligations }\n+        }\n         Err(e) => {\n             let msg = format!(\n                 \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\",\n@@ -1463,7 +1439,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n ) -> Progress<'tcx> {\n     let tcx = selcx.tcx();\n \n-    let ImplSourceUserDefinedData { impl_def_id, substs, nested } = impl_impl_source;\n+    let ImplSourceUserDefinedData { impl_def_id, substs, mut nested } = impl_impl_source;\n     let assoc_item_id = obligation.predicate.item_def_id;\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n@@ -1496,15 +1472,48 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let ty = tcx.type_of(assoc_ty.item.def_id);\n     if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n         let err = tcx.ty_error_with_message(\n-            DUMMY_SP,\n+            obligation.cause.span,\n             \"impl item and trait item have different parameter counts\",\n         );\n         Progress { ty: err, obligations: nested }\n     } else {\n+        assoc_ty_own_obligations(selcx, obligation, &mut nested);\n         Progress { ty: ty.subst(tcx, substs), obligations: nested }\n     }\n }\n \n+// Get obligations corresponding to the predicates from the where-clause of the\n+// associated type itself.\n+// Note: `feature(generic_associated_types)` is required to write such\n+// predicates, even for non-generic associcated types.\n+fn assoc_ty_own_obligations<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    nested: &mut Vec<PredicateObligation<'tcx>>,\n+) {\n+    let tcx = selcx.tcx();\n+    for predicate in tcx\n+        .predicates_of(obligation.predicate.item_def_id)\n+        .instantiate_own(tcx, obligation.predicate.substs)\n+        .predicates\n+    {\n+        let normalized = normalize_with_depth_to(\n+            selcx,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            &predicate,\n+            nested,\n+        );\n+        nested.push(Obligation::with_depth(\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            obligation.param_env,\n+            normalized,\n+        ));\n+    }\n+}\n+\n /// Locate the definition of an associated type in the specialization hierarchy,\n /// starting from the given impl.\n ///"}, {"sha": "038ba431c47d3be42145c1b674418810dd519b69", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -165,7 +165,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n \n-        let needs_infer = stack.obligation.predicate.needs_infer();\n+        let needs_infer = stack.obligation.predicate.has_infer_types_or_consts();\n \n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n@@ -327,8 +327,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .infcx\n             .probe(|_| self.match_projection_obligation_against_definition_bounds(obligation));\n \n-        if result {\n-            candidates.vec.push(ProjectionCandidate);\n+        for predicate_index in result {\n+            candidates.vec.push(ProjectionCandidate(predicate_index));\n         }\n     }\n "}, {"sha": "96f0bedf6f1a733a8d4a41b7b9be5108751c7005", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 183, "deletions": 39, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,12 +10,13 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate, WithConstness};\n use rustc_span::def_id::DefId;\n \n-use crate::traits::project::{self, normalize_with_depth};\n+use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::select::TraitObligationExt;\n use crate::traits::util;\n use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n@@ -68,9 +69,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::AutoImpl(data))\n             }\n \n-            ProjectionCandidate => {\n-                self.confirm_projection_candidate(obligation);\n-                Ok(ImplSource::Param(Vec::new()))\n+            ProjectionCandidate(idx) => {\n+                let obligations = self.confirm_projection_candidate(obligation, idx);\n+                Ok(ImplSource::Param(obligations))\n             }\n \n             ClosureCandidate => {\n@@ -116,10 +117,72 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n+    fn confirm_projection_candidate(\n+        &mut self,\n+        obligation: &TraitObligation<'tcx>,\n+        idx: usize,\n+    ) -> Vec<PredicateObligation<'tcx>> {\n         self.infcx.commit_unconditionally(|_| {\n-            let result = self.match_projection_obligation_against_definition_bounds(obligation);\n-            assert!(result);\n+            let tcx = self.tcx();\n+\n+            let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n+            let placeholder_trait_predicate =\n+                self.infcx().replace_bound_vars_with_placeholders(&trait_predicate);\n+            let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n+            let (def_id, substs) = match *placeholder_self_ty.kind() {\n+                ty::Projection(proj) => (proj.item_def_id, proj.substs),\n+                ty::Opaque(def_id, substs) => (def_id, substs),\n+                _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n+            };\n+\n+            let candidate_predicate = tcx.item_bounds(def_id)[idx].subst(tcx, substs);\n+            let candidate = candidate_predicate\n+                .to_opt_poly_trait_ref()\n+                .expect(\"projection candidate is not a trait predicate\");\n+            let mut obligations = Vec::new();\n+            let candidate = normalize_with_depth_to(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &candidate,\n+                &mut obligations,\n+            );\n+\n+            obligations.extend(\n+                self.infcx\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .sup(placeholder_trait_predicate.trait_ref.to_poly_trait_ref(), candidate)\n+                    .map(|InferOk { obligations, .. }| obligations)\n+                    .unwrap_or_else(|_| {\n+                        bug!(\n+                            \"Projection bound `{:?}` was applicable to `{:?}` but now is not\",\n+                            candidate,\n+                            obligation\n+                        );\n+                    }),\n+            );\n+\n+            if let ty::Projection(..) = placeholder_self_ty.kind() {\n+                for predicate in tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates {\n+                    let normalized = normalize_with_depth_to(\n+                        self,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        &predicate,\n+                        &mut obligations,\n+                    );\n+                    obligations.push(Obligation::with_depth(\n+                        obligation.cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        normalized,\n+                    ));\n+                }\n+            }\n+\n+            obligations\n         })\n     }\n \n@@ -229,7 +292,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let trait_obligations: Vec<PredicateObligation<'_>> =\n                 self.infcx.commit_unconditionally(|_| {\n                     let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let (trait_ref, _) =\n+                    let trait_ref =\n                         self.infcx.replace_bound_vars_with_placeholders(&poly_trait_ref);\n                     let cause = obligation.derived_cause(ImplDerivedObligation);\n                     self.impl_or_trait_obligations(\n@@ -307,55 +370,70 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // relying on projections in the impl-trait-ref.\n         //\n         // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n-        impl_obligations.append(&mut substs.obligations);\n+        substs.obligations.append(&mut impl_obligations);\n \n-        ImplSourceUserDefinedData { impl_def_id, substs: substs.value, nested: impl_obligations }\n+        ImplSourceUserDefinedData { impl_def_id, substs: substs.value, nested: substs.obligations }\n     }\n \n     fn confirm_object_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n+        let tcx = self.tcx();\n         debug!(\"confirm_object_candidate({:?})\", obligation);\n \n-        // FIXME(nmatsakis) skipping binder here seems wrong -- we should\n-        // probably flatten the binder from the obligation and the binder\n-        // from the object. Have to try to make a broken test case that\n-        // results.\n-        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.kind() {\n-            ty::Dynamic(data, ..) => data\n-                .principal()\n-                .unwrap_or_else(|| {\n-                    span_bug!(obligation.cause.span, \"object candidate with no principal\")\n-                })\n-                .with_self_ty(self.tcx(), self_ty),\n+        let trait_predicate =\n+            self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n+        let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n+        let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n+        let data = match self_ty.kind() {\n+            ty::Dynamic(data, ..) => {\n+                self.infcx\n+                    .replace_bound_vars_with_fresh_vars(\n+                        obligation.cause.span,\n+                        HigherRankedType,\n+                        data,\n+                    )\n+                    .0\n+            }\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n \n+        let object_trait_ref = data\n+            .principal()\n+            .unwrap_or_else(|| {\n+                span_bug!(obligation.cause.span, \"object candidate with no principal\")\n+            })\n+            .with_self_ty(self.tcx(), self_ty);\n+\n         let mut upcast_trait_ref = None;\n         let mut nested = vec![];\n         let vtable_base;\n \n         {\n-            let tcx = self.tcx();\n-\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n             // where we can unify, because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n-            let nonmatching = util::supertraits(tcx, poly_trait_ref).take_while(|&t| {\n-                match self.infcx.commit_if_ok(|_| self.match_poly_trait_ref(obligation, t)) {\n-                    Ok(obligations) => {\n-                        upcast_trait_ref = Some(t);\n-                        nested.extend(obligations);\n-                        false\n+            let nonmatching = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref))\n+                .take_while(|&t| {\n+                    match self.infcx.commit_if_ok(|_| {\n+                        self.infcx\n+                            .at(&obligation.cause, obligation.param_env)\n+                            .sup(obligation_trait_ref, t)\n+                            .map(|InferOk { obligations, .. }| obligations)\n+                            .map_err(|_| ())\n+                    }) {\n+                        Ok(obligations) => {\n+                            upcast_trait_ref = Some(t);\n+                            nested.extend(obligations);\n+                            false\n+                        }\n+                        Err(_) => true,\n                     }\n-                    Err(_) => true,\n-                }\n-            });\n+                });\n \n             // Additionally, for each of the non-matching predicates that\n             // we pass over, we sum up the set of number of vtable\n@@ -364,7 +442,73 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n         }\n \n-        ImplSourceObjectData { upcast_trait_ref: upcast_trait_ref.unwrap(), vtable_base, nested }\n+        let upcast_trait_ref = upcast_trait_ref.unwrap();\n+\n+        // Check supertraits hold. This is so that their associated type bounds\n+        // will be checked in the code below.\n+        for super_trait in tcx\n+            .super_predicates_of(trait_predicate.def_id())\n+            .instantiate(tcx, trait_predicate.trait_ref.substs)\n+            .predicates\n+            .into_iter()\n+        {\n+            if let ty::PredicateAtom::Trait(..) = super_trait.skip_binders() {\n+                let normalized_super_trait = normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &super_trait,\n+                    &mut nested,\n+                );\n+                nested.push(Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env.clone(),\n+                    normalized_super_trait,\n+                ));\n+            }\n+        }\n+\n+        let assoc_types: Vec<_> = tcx\n+            .associated_items(trait_predicate.def_id())\n+            .in_definition_order()\n+            .filter_map(\n+                |item| if item.kind == ty::AssocKind::Type { Some(item.def_id) } else { None },\n+            )\n+            .collect();\n+\n+        for assoc_type in assoc_types {\n+            if !tcx.generics_of(assoc_type).params.is_empty() {\n+                // FIXME(generic_associated_types) generate placeholders to\n+                // extend the trait substs.\n+                tcx.sess.span_fatal(\n+                    obligation.cause.span,\n+                    \"generic associated types in trait objects are not supported yet\",\n+                );\n+            }\n+            // This maybe belongs in wf, but that can't (doesn't) handle\n+            // higher-ranked things.\n+            // Prevent, e.g., `dyn Iterator<Item = str>`.\n+            for bound in self.tcx().item_bounds(assoc_type) {\n+                let subst_bound = bound.subst(tcx, trait_predicate.trait_ref.substs);\n+                let normalized_bound = normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &subst_bound,\n+                    &mut nested,\n+                );\n+                nested.push(Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env.clone(),\n+                    normalized_bound,\n+                ));\n+            }\n+        }\n+\n+        debug!(\"confirm_object_candidate: nested: {:?}\", nested);\n+        ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n     }\n \n     fn confirm_fn_pointer_candidate(\n@@ -386,8 +530,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         )\n         .map_bound(|(trait_ref, _)| trait_ref);\n \n-        let Normalized { value: trait_ref, obligations } = ensure_sufficient_stack(|| {\n-            project::normalize_with_depth(\n+        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n+            normalize_with_depth(\n                 self,\n                 obligation.param_env,\n                 obligation.cause.clone(),\n@@ -396,12 +540,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             )\n         });\n \n-        self.confirm_poly_trait_refs(\n+        obligations.extend(self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n             obligation.param_env,\n             obligation.predicate.to_poly_trait_ref(),\n             trait_ref,\n-        )?;\n+        )?);\n         Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested: obligations })\n     }\n \n@@ -413,7 +557,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_trait_alias_candidate({:?}, {:?})\", obligation, alias_def_id);\n \n         self.infcx.commit_unconditionally(|_| {\n-            let (predicate, _) =\n+            let predicate =\n                 self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;\n             let trait_def_id = trait_ref.def_id;"}, {"sha": "a142ba58a6904a8d32e5b631a1cd15283e645d5d", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 287, "deletions": 179, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,6 +9,7 @@ use super::coherence::{self, Conflict};\n use super::const_evaluatable;\n use super::project;\n use super::project::normalize_with_depth_to;\n+use super::project::ProjectionTyObligation;\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -36,9 +37,8 @@ use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{\n-    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n+use rustc_middle::ty::{self, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -343,7 +343,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(SelectionError::Overflow)\n             }\n             Err(e) => Err(e),\n-            Ok(candidate) => Ok(Some(candidate)),\n+            Ok(candidate) => {\n+                debug!(\"select: candidate = {:?}\", candidate);\n+                Ok(Some(candidate))\n+            }\n         }\n     }\n \n@@ -413,9 +416,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         predicates: I,\n     ) -> Result<EvaluationResult, OverflowError>\n     where\n-        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n+        I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n         let mut result = EvaluatedToOk;\n+        debug!(\"evaluate_predicates_recursively({:?})\", predicates);\n         for obligation in predicates {\n             let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\", obligation, eval);\n@@ -436,9 +440,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\n-            \"evaluate_predicate_recursively(previous_stack={:?}, obligation={:?})\",\n-            previous_stack.head(),\n-            obligation\n+            \"evaluate_predicate_recursively(obligation={:?}, previous_stack={:?})\",\n+            obligation,\n+            previous_stack.head()\n         );\n \n         // `previous_stack` stores a `TraitObligation`, while `obligation` is\n@@ -479,15 +483,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     self.infcx,\n                     obligation.param_env,\n                     obligation.cause.body_id,\n+                    obligation.recursion_depth + 1,\n                     arg,\n                     obligation.cause.span,\n                 ) {\n                     Some(mut obligations) => {\n                         self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                        self.evaluate_predicates_recursively(\n-                            previous_stack,\n-                            obligations.into_iter(),\n-                        )\n+                        self.evaluate_predicates_recursively(previous_stack, obligations)\n                     }\n                     None => Ok(EvaluatedToAmbig),\n                 },\n@@ -511,10 +513,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n                             self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                            let result = self.evaluate_predicates_recursively(\n-                                previous_stack,\n-                                subobligations.into_iter(),\n-                            );\n+                            let result = self\n+                                .evaluate_predicates_recursively(previous_stack, subobligations);\n                             if let Some(key) =\n                                 ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                             {\n@@ -879,10 +879,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = self.evaluation_probe(|this| {\n             let candidate = (*candidate).clone();\n             match this.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => this.evaluate_predicates_recursively(\n-                    stack.list(),\n-                    selection.nested_obligations().into_iter(),\n-                ),\n+                Ok(selection) => {\n+                    debug!(\"evaluate_candidate: selection = {:?}\", selection);\n+                    this.evaluate_predicates_recursively(\n+                        stack.list(),\n+                        selection.nested_obligations().into_iter(),\n+                    )\n+                }\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n         })?;\n@@ -943,10 +946,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// to have a *lower* recursion_depth than the obligation used to create it.\n     /// Projection sub-obligations may be returned from the projection cache,\n     /// which results in obligations with an 'old' `recursion_depth`.\n-    /// Additionally, methods like `wf::obligations` and\n-    /// `InferCtxt.subtype_predicate` produce subobligations without\n-    /// taking in a 'parent' depth, causing the generated subobligations\n-    /// to have a `recursion_depth` of `0`.\n+    /// Additionally, methods like `InferCtxt.subtype_predicate` produce\n+    /// subobligations without taking in a 'parent' depth, causing the\n+    /// generated subobligations to have a `recursion_depth` of `0`.\n     ///\n     /// To ensure that obligation_depth never decreasees, we force all subobligations\n     /// to have at least the depth of the original obligation.\n@@ -1156,12 +1158,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n+    /// Matches a predicate against the bounds of its self type.\n+    ///\n+    /// Given an obligation like `<T as Foo>::Bar: Baz` where the self type is\n+    /// a projection, look at the bounds of `T::Bar`, see if we can find a\n+    /// `Baz` bound. We return indexes into the list returned by\n+    /// `tcx.item_bounds` for any applicable bounds.\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> bool {\n+    ) -> smallvec::SmallVec<[usize; 2]> {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n-        let (placeholder_trait_predicate, _) =\n+        let placeholder_trait_predicate =\n             self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n@@ -1170,11 +1178,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         let tcx = self.infcx.tcx;\n-        let predicates = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n-            ty::Projection(ref data) => {\n-                tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n-            }\n-            ty::Opaque(def_id, substs) => tcx.projection_predicates(def_id).subst(tcx, substs),\n+        let (def_id, substs) = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n+            ty::Projection(ref data) => (data.item_def_id, data.substs),\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n@@ -1184,48 +1190,86 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 );\n             }\n         };\n+        let bounds = tcx.item_bounds(def_id).subst(tcx, substs);\n+\n+        // The bounds returned by `item_bounds` may contain duplicates after\n+        // normalization, so try to deduplicate when possible to avoid\n+        // unnecessary ambiguity.\n+        let mut distinct_normalized_bounds = FxHashSet::default();\n \n-        let matching_bound = predicates.iter().find_map(|bound| {\n-            if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n-                let bound = ty::Binder::bind(pred.trait_ref);\n-                if self.infcx.probe(|_| {\n-                    self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)\n-                }) {\n-                    return Some(bound);\n+        let matching_bounds = bounds\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(idx, bound)| {\n+                if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n+                    let bound = ty::Binder::bind(pred.trait_ref);\n+                    if self.infcx.probe(|_| {\n+                        match self.match_projection(\n+                            obligation,\n+                            bound,\n+                            placeholder_trait_predicate.trait_ref,\n+                        ) {\n+                            Ok(None) => true,\n+                            Ok(Some(normalized_trait))\n+                                if distinct_normalized_bounds.insert(normalized_trait) =>\n+                            {\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) {\n+                        return Some(idx);\n+                    }\n                 }\n-            }\n-            None\n-        });\n+                None\n+            })\n+            .collect();\n \n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n-             matching_bound={:?}\",\n-            matching_bound\n+             matching_bounds={:?}\",\n+            matching_bounds\n         );\n-        match matching_bound {\n-            None => false,\n-            Some(bound) => {\n-                // Repeat the successful match, if any, this time outside of a probe.\n-                let result =\n-                    self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref);\n-\n-                assert!(result);\n-                true\n-            }\n-        }\n+        matching_bounds\n     }\n \n+    /// Equates the trait in `obligation` with trait bound. If the two traits\n+    /// can be equated and the normalized trait bound doesn't contain inference\n+    /// variables or placeholders, the normalized bound is returned.\n     fn match_projection(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         placeholder_trait_ref: ty::TraitRef<'tcx>,\n-    ) -> bool {\n+    ) -> Result<Option<ty::PolyTraitRef<'tcx>>, ()> {\n         debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());\n+        if placeholder_trait_ref.def_id != trait_bound.def_id() {\n+            // Avoid unnecessary normalization\n+            return Err(());\n+        }\n+\n+        let Normalized { value: trait_bound, obligations: _ } = ensure_sufficient_stack(|| {\n+            project::normalize_with_depth(\n+                self,\n+                obligation.param_env,\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &trait_bound,\n+            )\n+        });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n-            .is_ok()\n+            .map(|InferOk { obligations: _, value: () }| {\n+                // This method is called within a probe, so we can't have\n+                // inference variables and placeholders escape.\n+                if !trait_bound.needs_infer() && !trait_bound.has_placeholders() {\n+                    Some(trait_bound)\n+                } else {\n+                    None\n+                }\n+            })\n+            .map_err(|_| ())\n     }\n \n     fn evaluate_where_clause<'o>(\n@@ -1235,14 +1279,50 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n-                Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.into_iter())\n-                }\n+                Ok(obligations) => this.evaluate_predicates_recursively(stack.list(), obligations),\n                 Err(()) => Ok(EvaluatedToErr),\n             }\n         })\n     }\n \n+    pub(super) fn match_projection_projections(\n+        &mut self,\n+        obligation: &ProjectionTyObligation<'tcx>,\n+        obligation_trait_ref: &ty::TraitRef<'tcx>,\n+        data: &PolyProjectionPredicate<'tcx>,\n+        potentially_unnormalized_candidates: bool,\n+    ) -> bool {\n+        let mut nested_obligations = Vec::new();\n+        let projection_ty = if potentially_unnormalized_candidates {\n+            ensure_sufficient_stack(|| {\n+                project::normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    &data.map_bound_ref(|data| data.projection_ty),\n+                    &mut nested_obligations,\n+                )\n+            })\n+        } else {\n+            data.map_bound_ref(|data| data.projection_ty)\n+        };\n+\n+        // FIXME(generic_associated_types): Compare the whole projections\n+        let data_poly_trait_ref = projection_ty.map_bound(|proj| proj.trait_ref(self.tcx()));\n+        let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+        self.infcx\n+            .at(&obligation.cause, obligation.param_env)\n+            .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+            .map_or(false, |InferOk { obligations, value: () }| {\n+                self.evaluate_predicates_recursively(\n+                    TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n+                    nested_obligations.into_iter().chain(obligations),\n+                )\n+                .map_or(false, |res| res.may_apply())\n+            })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // WINNOW\n     //\n@@ -1277,146 +1357,174 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //\n         // This is a fix for #53123 and prevents winnowing from accidentally extending the\n         // lifetime of a variable.\n-        match other.candidate {\n+        match (&other.candidate, &victim.candidate) {\n+            (_, AutoImplCandidate(..)) | (AutoImplCandidate(..), _) => {\n+                bug!(\n+                    \"default implementations shouldn't be recorded \\\n+                    when there are other valid candidates\"\n+                );\n+            }\n+\n             // (*)\n-            BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => true,\n-            ParamCandidate(ref cand) => match victim.candidate {\n-                AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\"\n-                    );\n-                }\n-                // (*)\n-                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n+            (BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate, _) => true,\n+            (_, BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate) => false,\n+\n+            (ParamCandidate(..), ParamCandidate(..)) => false,\n+\n+            // Global bounds from the where clause should be ignored\n+            // here (see issue #50825). Otherwise, we have a where\n+            // clause so don't go around looking for impls.\n+            // Arbitrarily give param candidates priority\n+            // over projection and object candidates.\n+            (\n+                ParamCandidate(ref cand),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n-                | TraitAliasCandidate(..) => {\n-                    // Global bounds from the where clause should be ignored\n-                    // here (see issue #50825). Otherwise, we have a where\n-                    // clause so don't go around looking for impls.\n-                    !is_global(cand)\n-                }\n-                ObjectCandidate | ProjectionCandidate => {\n-                    // Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    !is_global(cand)\n-                }\n-                ParamCandidate(..) => false,\n-            },\n-            ObjectCandidate | ProjectionCandidate => match victim.candidate {\n-                AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\"\n-                    );\n-                }\n-                // (*)\n-                BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate => false,\n+                | TraitAliasCandidate(..)\n+                | ObjectCandidate\n+                | ProjectionCandidate(_),\n+            ) => !is_global(cand),\n+            (ObjectCandidate | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n+                // Prefer these to a global where-clause bound\n+                // (see issue #50825).\n+                is_global(cand)\n+            }\n+            (\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+                ParamCandidate(ref cand),\n+            ) => {\n+                // Prefer these to a global where-clause bound\n+                // (see issue #50825).\n+                is_global(cand) && other.evaluation.must_apply_modulo_regions()\n+            }\n+\n+            (ProjectionCandidate(i), ProjectionCandidate(j)) => {\n+                // Arbitrarily pick the first candidate for backwards\n+                // compatibility reasons. Don't let this affect inference.\n+                i > j && !needs_infer\n+            }\n+            (ObjectCandidate, ObjectCandidate) => bug!(\"Duplicate object candidate\"),\n+            (ObjectCandidate, ProjectionCandidate(_))\n+            | (ProjectionCandidate(_), ObjectCandidate) => {\n+                bug!(\"Have both object and projection candidate\")\n+            }\n+\n+            // Arbitrarily give projection and object candidates priority.\n+            (\n+                ObjectCandidate | ProjectionCandidate(_),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n                 | FnPointerCandidate\n                 | BuiltinObjectCandidate\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n-                | TraitAliasCandidate(..) => true,\n-                ObjectCandidate | ProjectionCandidate => {\n-                    // Arbitrarily give param candidates priority\n-                    // over projection and object candidates.\n-                    true\n-                }\n-                ParamCandidate(ref cand) => is_global(cand),\n-            },\n-            ImplCandidate(other_def) => {\n+                | TraitAliasCandidate(..),\n+            ) => true,\n+\n+            (\n+                ImplCandidate(..)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { .. }\n+                | TraitAliasCandidate(..),\n+                ObjectCandidate | ProjectionCandidate(_),\n+            ) => false,\n+\n+            (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n                 // i.e., `EvaluatedToOk`.\n                 if other.evaluation.must_apply_modulo_regions() {\n-                    match victim.candidate {\n-                        ImplCandidate(victim_def) => {\n-                            let tcx = self.tcx();\n-                            if tcx.specializes((other_def, victim_def)) {\n-                                return true;\n-                            }\n-                            return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n-                                Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n-                                    // Subtle: If the predicate we are evaluating has inference\n-                                    // variables, do *not* allow discarding candidates due to\n-                                    // marker trait impls.\n-                                    //\n-                                    // Without this restriction, we could end up accidentally\n-                                    // constrainting inference variables based on an arbitrarily\n-                                    // chosen trait impl.\n-                                    //\n-                                    // Imagine we have the following code:\n-                                    //\n-                                    // ```rust\n-                                    // #[marker] trait MyTrait {}\n-                                    // impl MyTrait for u8 {}\n-                                    // impl MyTrait for bool {}\n-                                    // ```\n-                                    //\n-                                    // And we are evaluating the predicate `<_#0t as MyTrait>`.\n-                                    //\n-                                    // During selection, we will end up with one candidate for each\n-                                    // impl of `MyTrait`. If we were to discard one impl in favor\n-                                    // of the other, we would be left with one candidate, causing\n-                                    // us to \"successfully\" select the predicate, unifying\n-                                    // _#0t with (for example) `u8`.\n-                                    //\n-                                    // However, we have no reason to believe that this unification\n-                                    // is correct - we've essentially just picked an arbitrary\n-                                    // *possibility* for _#0t, and required that this be the *only*\n-                                    // possibility.\n-                                    //\n-                                    // Eventually, we will either:\n-                                    // 1) Unify all inference variables in the predicate through\n-                                    // some other means (e.g. type-checking of a function). We will\n-                                    // then be in a position to drop marker trait candidates\n-                                    // without constraining inference variables (since there are\n-                                    // none left to constrin)\n-                                    // 2) Be left with some unconstrained inference variables. We\n-                                    // will then correctly report an inference error, since the\n-                                    // existence of multiple marker trait impls tells us nothing\n-                                    // about which one should actually apply.\n-                                    !needs_infer\n-                                }\n-                                Some(_) => true,\n-                                None => false,\n-                            };\n-                        }\n-                        ParamCandidate(ref cand) => {\n-                            // Prefer the impl to a global where clause candidate.\n-                            return is_global(cand);\n-                        }\n-                        _ => (),\n+                    let tcx = self.tcx();\n+                    if tcx.specializes((other_def, victim_def)) {\n+                        return true;\n                     }\n-                }\n-\n-                false\n-            }\n-            ClosureCandidate\n-            | GeneratorCandidate\n-            | FnPointerCandidate\n-            | BuiltinObjectCandidate\n-            | BuiltinUnsizeCandidate\n-            | BuiltinCandidate { has_nested: true } => {\n-                match victim.candidate {\n-                    ParamCandidate(ref cand) => {\n-                        // Prefer these to a global where-clause bound\n-                        // (see issue #50825).\n-                        is_global(cand) && other.evaluation.must_apply_modulo_regions()\n-                    }\n-                    _ => false,\n+                    return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                        Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                            // Subtle: If the predicate we are evaluating has inference\n+                            // variables, do *not* allow discarding candidates due to\n+                            // marker trait impls.\n+                            //\n+                            // Without this restriction, we could end up accidentally\n+                            // constrainting inference variables based on an arbitrarily\n+                            // chosen trait impl.\n+                            //\n+                            // Imagine we have the following code:\n+                            //\n+                            // ```rust\n+                            // #[marker] trait MyTrait {}\n+                            // impl MyTrait for u8 {}\n+                            // impl MyTrait for bool {}\n+                            // ```\n+                            //\n+                            // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                            //\n+                            // During selection, we will end up with one candidate for each\n+                            // impl of `MyTrait`. If we were to discard one impl in favor\n+                            // of the other, we would be left with one candidate, causing\n+                            // us to \"successfully\" select the predicate, unifying\n+                            // _#0t with (for example) `u8`.\n+                            //\n+                            // However, we have no reason to believe that this unification\n+                            // is correct - we've essentially just picked an arbitrary\n+                            // *possibility* for _#0t, and required that this be the *only*\n+                            // possibility.\n+                            //\n+                            // Eventually, we will either:\n+                            // 1) Unify all inference variables in the predicate through\n+                            // some other means (e.g. type-checking of a function). We will\n+                            // then be in a position to drop marker trait candidates\n+                            // without constraining inference variables (since there are\n+                            // none left to constrin)\n+                            // 2) Be left with some unconstrained inference variables. We\n+                            // will then correctly report an inference error, since the\n+                            // existence of multiple marker trait impls tells us nothing\n+                            // about which one should actually apply.\n+                            !needs_infer\n+                        }\n+                        Some(_) => true,\n+                        None => false,\n+                    };\n+                } else {\n+                    false\n                 }\n             }\n-            _ => false,\n+\n+            // Everything else is ambiguous\n+            (\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+                ImplCandidate(_)\n+                | ClosureCandidate\n+                | GeneratorCandidate\n+                | FnPointerCandidate\n+                | BuiltinObjectCandidate\n+                | BuiltinUnsizeCandidate\n+                | BuiltinCandidate { has_nested: true }\n+                | TraitAliasCandidate(..),\n+            ) => false,\n         }\n     }\n \n@@ -1649,7 +1757,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n-                    let (placeholder_ty, _) = self.infcx.replace_bound_vars_with_placeholders(&ty);\n+                    let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(&ty);\n                     let Normalized { value: normalized_ty, mut obligations } =\n                         ensure_sufficient_stack(|| {\n                             project::normalize_with_depth(\n@@ -1717,7 +1825,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let (placeholder_obligation, _) =\n+        let placeholder_obligation =\n             self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n "}, {"sha": "d66bfd482069dab2a32847a7e8099fedc2f90459", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 96, "deletions": 31, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -20,6 +20,7 @@ pub fn obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n+    recursion_depth: usize,\n     arg: GenericArg<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n@@ -59,7 +60,8 @@ pub fn obligations<'a, 'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -80,7 +82,8 @@ pub fn trait_obligations<'a, 'tcx>(\n     span: Span,\n     item: Option<&'tcx hir::Item<'tcx>>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth: 0, item };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n@@ -92,7 +95,15 @@ pub fn predicate_obligations<'a, 'tcx>(\n     predicate: ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n+    let mut wf = WfPredicates {\n+        infcx,\n+        param_env,\n+        body_id,\n+        span,\n+        out: vec![],\n+        recursion_depth: 0,\n+        item: None,\n+    };\n \n     // It's ok to skip the binder here because wf code is prepared for it\n     match predicate.skip_binders() {\n@@ -142,6 +153,7 @@ struct WfPredicates<'a, 'tcx> {\n     body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n+    recursion_depth: usize,\n     item: Option<&'tcx hir::Item<'tcx>>,\n }\n \n@@ -241,18 +253,27 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n-    fn normalize(&mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n+    fn normalize(mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n         let cause = self.cause(traits::MiscObligation);\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n         let mut obligations = Vec::with_capacity(self.out.len());\n-        for pred in &self.out {\n-            assert!(!pred.has_escaping_bound_vars());\n+        for mut obligation in self.out {\n+            assert!(!obligation.has_escaping_bound_vars());\n             let mut selcx = traits::SelectionContext::new(infcx);\n-            let i = obligations.len();\n-            let value =\n-                traits::normalize_to(&mut selcx, param_env, cause.clone(), pred, &mut obligations);\n-            obligations.insert(i, value);\n+            // Don't normalize the whole obligation, the param env is either\n+            // already normalized, or we're currently normalizing the\n+            // param_env. Either way we should only normalize the predicate.\n+            let normalized_predicate = traits::project::normalize_with_depth_to(\n+                &mut selcx,\n+                param_env,\n+                cause.clone(),\n+                self.recursion_depth,\n+                &obligation.predicate,\n+                &mut obligations,\n+            );\n+            obligation.predicate = normalized_predicate;\n+            obligations.push(obligation);\n         }\n         obligations\n     }\n@@ -265,6 +286,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         debug!(\"compute_trait_ref obligations {:?}\", obligations);\n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n \n         let item = self.item;\n \n@@ -286,7 +308,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 &obligation.predicate,\n                 tcx.associated_items(trait_ref.def_id).in_definition_order(),\n             );\n-            traits::Obligation::new(cause, param_env, obligation.predicate)\n+            traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n         };\n \n         if let Elaborate::All = elaborate {\n@@ -315,8 +337,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             new_cause.make_mut().span = self_ty.span;\n                         }\n                     }\n-                    traits::Obligation::new(\n+                    traits::Obligation::with_depth(\n                         new_cause,\n+                        depth,\n                         param_env,\n                         ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n                     )\n@@ -327,17 +350,51 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// Pushes the obligations required for `trait_ref::Item` to be WF\n     /// into `self.out`.\n     fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n-        // A projection is well-formed if (a) the trait ref itself is\n-        // WF and (b) the trait-ref holds.  (It may also be\n-        // normalizable and be WF that way.)\n-        let trait_ref = data.trait_ref(self.infcx.tcx);\n-        self.compute_trait_ref(&trait_ref, Elaborate::None);\n-\n-        if !data.has_escaping_bound_vars() {\n-            let predicate = trait_ref.without_const().to_predicate(self.infcx.tcx);\n-            let cause = self.cause(traits::ProjectionWf(data));\n-            self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n-        }\n+        // A projection is well-formed if\n+        //\n+        // (a) its predicates hold (*)\n+        // (b) its substs are wf\n+        //\n+        // (*) The predicates of an associated type include the predicates of\n+        //     the trait that it's contained in. For example, given\n+        //\n+        // trait A<T>: Clone {\n+        //     type X where T: Copy;\n+        // }\n+        //\n+        // The predicates of `<() as A<i32>>::X` are:\n+        // [\n+        //     `(): Sized`\n+        //     `(): Clone`\n+        //     `(): A<i32>`\n+        //     `i32: Sized`\n+        //     `i32: Clone`\n+        //     `i32: Copy`\n+        // ]\n+        let obligations = self.nominal_obligations(data.item_def_id, data.substs);\n+        self.out.extend(obligations);\n+\n+        let tcx = self.tcx();\n+        let cause = self.cause(traits::MiscObligation);\n+        let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n+\n+        self.out.extend(\n+            data.substs\n+                .iter()\n+                .filter(|arg| {\n+                    matches!(arg.unpack(), GenericArgKind::Type(..) | GenericArgKind::Const(..))\n+                })\n+                .filter(|arg| !arg.has_escaping_bound_vars())\n+                .map(|arg| {\n+                    traits::Obligation::with_depth(\n+                        cause.clone(),\n+                        depth,\n+                        param_env,\n+                        ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n+                    )\n+                }),\n+        );\n     }\n \n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n@@ -347,8 +404,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 def_id: self.infcx.tcx.require_lang_item(LangItem::Sized, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n-            self.out.push(traits::Obligation::new(\n+            self.out.push(traits::Obligation::with_depth(\n                 cause,\n+                self.recursion_depth,\n                 self.param_env,\n                 trait_ref.without_const().to_predicate(self.infcx.tcx),\n             ));\n@@ -359,6 +417,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn compute(&mut self, arg: GenericArg<'tcx>) {\n         let mut walker = arg.walk();\n         let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n         while let Some(arg) = walker.next() {\n             let ty = match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty,\n@@ -378,8 +437,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             let predicate = ty::PredicateAtom::ConstEvaluatable(def, substs)\n                                 .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n-                            self.out.push(traits::Obligation::new(\n+                            self.out.push(traits::Obligation::with_depth(\n                                 cause,\n+                                self.recursion_depth,\n                                 self.param_env,\n                                 predicate,\n                             ));\n@@ -394,8 +454,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                     val: ty::ConstKind::Infer(resolved),\n                                     ..*constant\n                                 });\n-                                self.out.push(traits::Obligation::new(\n+                                self.out.push(traits::Obligation::with_depth(\n                                     cause,\n+                                    self.recursion_depth,\n                                     self.param_env,\n                                     ty::PredicateAtom::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n@@ -480,8 +541,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n-                        self.out.push(traits::Obligation::new(\n+                        self.out.push(traits::Obligation::with_depth(\n                             cause,\n+                            depth,\n                             param_env,\n                             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(rty, r))\n                                 .to_predicate(self.tcx()),\n@@ -571,8 +633,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         let component_traits = data.auto_traits().chain(data.principal_def_id());\n                         let tcx = self.tcx();\n                         self.out.extend(component_traits.map(|did| {\n-                            traits::Obligation::new(\n+                            traits::Obligation::with_depth(\n                                 cause.clone(),\n+                                depth,\n                                 param_env,\n                                 ty::PredicateAtom::ObjectSafe(did).to_predicate(tcx),\n                             )\n@@ -597,8 +660,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     if let ty::Infer(ty::TyVar(_)) = ty.kind() {\n                         // Not yet resolved, but we've made progress.\n                         let cause = self.cause(traits::MiscObligation);\n-                        self.out.push(traits::Obligation::new(\n+                        self.out.push(traits::Obligation::with_depth(\n                             cause,\n+                            self.recursion_depth,\n                             param_env,\n                             ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n@@ -635,7 +699,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             .zip(origins.into_iter().rev())\n             .map(|((pred, span), origin_def_id)| {\n                 let cause = self.cause(traits::BindingObligation(origin_def_id, span));\n-                traits::Obligation::new(cause, self.param_env, pred)\n+                traits::Obligation::with_depth(cause, self.recursion_depth, self.param_env, pred)\n             })\n             .filter(|pred| !pred.has_escaping_bound_vars())\n             .collect()\n@@ -688,8 +752,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n-                self.out.push(traits::Obligation::new(\n+                self.out.push(traits::Obligation::with_depth(\n                     cause,\n+                    self.recursion_depth,\n                     self.param_env,\n                     outlives.to_predicate(self.infcx.tcx),\n                 ));"}, {"sha": "223635e9aecd91aa70f80c259fd002011b3acd4c", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -50,6 +50,19 @@ impl<'tcx> RustIrDatabase<'tcx> {\n             .map(|wc| wc.fold_with(&mut regions_substitutor))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n     }\n+\n+    fn bounds_for<T>(&self, def_id: DefId, bound_vars: SubstsRef<'tcx>) -> Vec<T>\n+    where\n+        ty::Predicate<'tcx>: LowerInto<'tcx, std::option::Option<T>>,\n+    {\n+        self.interner\n+            .tcx\n+            .explicit_item_bounds(def_id)\n+            .iter()\n+            .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n+            .filter_map(|bound| LowerInto::<Option<_>>::lower_into(bound, &self.interner))\n+            .collect()\n+    }\n }\n \n impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'tcx> {\n@@ -73,18 +86,17 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         }\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        // FIXME(chalk): this really isn't right I don't think. The functions\n-        // for GATs are a bit hard to figure out. Are these supposed to be where\n-        // clauses or bounds?\n+\n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n+        let bounds = self.bounds_for(def_id, bound_vars);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyDatum {\n             trait_id: chalk_ir::TraitId(trait_def_id),\n             id: assoc_type_id,\n             name: (),\n             binders: chalk_ir::Binders::new(\n                 binders,\n-                chalk_solve::rust_ir::AssociatedTyDatumBound { bounds: vec![], where_clauses },\n+                chalk_solve::rust_ir::AssociatedTyDatumBound { bounds, where_clauses },\n             ),\n         })\n     }\n@@ -442,11 +454,13 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n         let binders = binders_for(&self.interner, bound_vars);\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n+        let bounds = self.bounds_for(opaque_ty_id.0, bound_vars);\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(binders.clone(), vec![]),\n+            bounds: chalk_ir::Binders::new(binders.clone(), bounds),\n             where_clauses: chalk_ir::Binders::new(binders, where_clauses),\n         };\n+\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n             bound: chalk_ir::Binders::empty(&self.interner, value),"}, {"sha": "bdb2513cc46026ad81b0123446c45cc5f6dcd8ff", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -728,6 +728,87 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::FnSig<RustInterner<'tcx>>> for ty::Binder<t\n     }\n }\n \n+// We lower into an Option here since there are some predicates which Chalk\n+// doesn't have a representation for yet (as an `InlineBound`). The `Option` will\n+// eventually be removed.\n+impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>>>\n+    for ty::Predicate<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>> {\n+        match self.bound_atom(interner.tcx).skip_binder() {\n+            ty::PredicateAtom::Trait(predicate, _) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n+\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_solve::rust_ir::InlineBound::TraitBound(\n+                        predicate.trait_ref.lower_into(interner),\n+                    ),\n+                ))\n+            }\n+            ty::PredicateAtom::Projection(predicate) => {\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n+\n+                Some(chalk_ir::Binders::new(\n+                    binders,\n+                    chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n+                ))\n+            }\n+            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n+            ty::PredicateAtom::WellFormed(_ty) => None,\n+\n+            ty::PredicateAtom::RegionOutlives(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..)\n+            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                bug!(\"unexpected predicate {}\", &self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::TraitBound<RustInterner<'tcx>>>\n+    for ty::TraitRef<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_solve::rust_ir::TraitBound<RustInterner<'tcx>> {\n+        chalk_solve::rust_ir::TraitBound {\n+            trait_id: chalk_ir::TraitId(self.def_id),\n+            args_no_self: self.substs[1..].iter().map(|arg| arg.lower_into(interner)).collect(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>>>\n+    for ty::ProjectionPredicate<'tcx>\n+{\n+    fn lower_into(\n+        self,\n+        interner: &RustInterner<'tcx>,\n+    ) -> chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>> {\n+        let trait_ref = self.projection_ty.trait_ref(interner.tcx);\n+        chalk_solve::rust_ir::AliasEqBound {\n+            trait_bound: trait_ref.lower_into(interner),\n+            associated_ty_id: chalk_ir::AssocTypeId(self.projection_ty.item_def_id),\n+            parameters: self.projection_ty.substs[trait_ref.substs.len()..]\n+                .iter()\n+                .map(|arg| arg.lower_into(interner))\n+                .collect(),\n+            value: self.ty.lower_into(interner),\n+        }\n+    }\n+}\n+\n /// To collect bound vars, we have to do two passes. In the first pass, we\n /// collect all `BoundRegion`s and `ty::Bound`s. In the second pass, we then\n /// replace `BrNamed` into `BrAnon`. The two separate passes are important,"}, {"sha": "bc5c07fce045c385f7c8e839f7714e456dab798c", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -61,8 +61,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n-        let obligations =\n-            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, arg, DUMMY_SP).unwrap_or(vec![]);\n+        let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "1f21d9488a454b720dd79319b0d95820d7c8c07d", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 1, "deletions": 131, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,9 @@\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n-use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_infer::traits::util;\n use rustc_middle::hir::map as hir_map;\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{\n     self, Binder, Predicate, PredicateAtom, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n };\n@@ -492,133 +490,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n-/// For associated types we allow bounds written on the associated type\n-/// (`type X: Trait`) to be used as candidates. We also allow the same bounds\n-/// when desugared as bounds on the trait `where Self::X: Trait`.\n-///\n-/// Note that this filtering is done with the items identity substs to\n-/// simplify checking that these bounds are met in impls. This means that\n-/// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n-/// `hr-associated-type-bound-1.rs`.\n-fn associated_type_projection_predicates(\n-    tcx: TyCtxt<'_>,\n-    assoc_item_def_id: DefId,\n-) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let generic_trait_bounds = tcx.predicates_of(assoc_item_def_id);\n-    // We include predicates from the trait as well to handle\n-    // `where Self::X: Trait`.\n-    let item_bounds = generic_trait_bounds.instantiate_identity(tcx);\n-    let item_predicates = util::elaborate_predicates(tcx, item_bounds.predicates.into_iter());\n-\n-    let assoc_item_ty = ty::ProjectionTy {\n-        item_def_id: assoc_item_def_id,\n-        substs: InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n-    };\n-\n-    let predicates = item_predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Projection(p) = *tr.self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Projection(p) = *proj.projection_ty.self_ty().kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = *outlives.0.kind() {\n-                    if p == assoc_item_ty {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        None\n-    });\n-\n-    let result = tcx.mk_predicates(predicates);\n-    debug!(\n-        \"associated_type_projection_predicates({}) = {:?}\",\n-        tcx.def_path_str(assoc_item_def_id),\n-        result\n-    );\n-    result\n-}\n-\n-/// Opaque types don't have the same issues as associated types: the only\n-/// predicates on an opaque type (excluding those it inherits from its parent\n-/// item) should be of the form we're expecting.\n-fn opaque_type_projection_predicates(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-) -> &'_ ty::List<ty::Predicate<'_>> {\n-    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-\n-    let bounds = tcx.predicates_of(def_id);\n-    let predicates =\n-        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n-\n-    let filtered_predicates = predicates.filter_map(|obligation| {\n-        let pred = obligation.predicate;\n-        match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *tr.self_ty().kind() {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) =\n-                    *proj.projection_ty.self_ty().kind()\n-                {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                }\n-            }\n-            ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = *outlives.0.kind() {\n-                    if opaque_def_id == def_id && opaque_substs == substs {\n-                        return Some(pred);\n-                    }\n-                } else {\n-                    // These can come from elaborating other predicates\n-                    return None;\n-                }\n-            }\n-            // These can come from elaborating other predicates\n-            ty::PredicateAtom::RegionOutlives(_) => return None,\n-            _ => {}\n-        }\n-        tcx.sess.delay_span_bug(\n-            obligation.cause.span(tcx),\n-            &format!(\"unexpected predicate {:?} on opaque type\", pred),\n-        );\n-        None\n-    });\n-\n-    let result = tcx.mk_predicates(filtered_predicates);\n-    debug!(\"opaque_type_projection_predicates({}) = {:?}\", tcx.def_path_str(def_id), result);\n-    result\n-}\n-\n-fn projection_predicates(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AssocTy => associated_type_projection_predicates(tcx, def_id),\n-        DefKind::OpaqueTy => opaque_type_projection_predicates(tcx, def_id),\n-        k => bug!(\"projection_predicates called on {}\", k.descr(def_id)),\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n         asyncness,\n@@ -636,7 +507,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         instance_def_size_estimate,\n         issue33140_self_ty,\n         impl_defaultness,\n-        projection_predicates,\n         ..*providers\n     };\n }"}, {"sha": "80f39051c587f9d9055c151c07cd84dca3454f19", "filename": "compiler/rustc_typeck/src/bounds.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -71,12 +71,8 @@ impl<'tcx> Bounds<'tcx> {\n                 self.region_bounds\n                     .iter()\n                     .map(|&(region_bound, span)| {\n-                        // Account for the binder being introduced below; no need to shift `param_ty`\n-                        // because, at present at least, it either only refers to early-bound regions,\n-                        // or it's a generic associated type that deliberately has escaping bound vars.\n-                        let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                         let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n-                        (ty::Binder::bind(outlives).to_predicate(tcx), span)\n+                        (ty::Binder::dummy(outlives).to_predicate(tcx), span)\n                     })\n                     .chain(self.trait_bounds.iter().map(|&(bound_trait_ref, span, constness)| {\n                         let predicate = bound_trait_ref.with_constness(constness).to_predicate(tcx);"}, {"sha": "d319ac2cba65479823f0263ff7a87f99142abd90", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 107, "deletions": 11, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,15 +1,16 @@\n use super::coercion::CoerceMany;\n+use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n use super::*;\n \n use rustc_attr as attr;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n@@ -18,6 +19,8 @@ use rustc_session::config::EntryFnType;\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n pub fn check_wf_new(tcx: TyCtxt<'_>) {\n@@ -385,8 +388,13 @@ pub(super) fn check_opaque<'tcx>(\n     origin: &hir::OpaqueTyOrigin,\n ) {\n     check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n-    tcx.ensure().type_of(def_id);\n-    check_opaque_for_cycles(tcx, def_id, substs, span, origin);\n+    if tcx.type_of(def_id).references_error() {\n+        return;\n+    }\n+    if check_opaque_for_cycles(tcx, def_id, substs, span, origin).is_err() {\n+        return;\n+    }\n+    check_opaque_meets_bounds(tcx, def_id, substs, span, origin);\n }\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n@@ -453,8 +461,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n             ty: None,\n         };\n         let prohibit_opaque = tcx\n-            .predicates_of(def_id)\n-            .predicates\n+            .explicit_item_bounds(def_id)\n             .iter()\n             .any(|(predicate, _)| predicate.visit_with(&mut visitor));\n         debug!(\n@@ -476,7 +483,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 span,\n                 E0760,\n                 \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n-             a parent scope\",\n+                 a parent scope\",\n                 if is_async { \"async fn\" } else { \"impl Trait\" },\n             );\n \n@@ -504,7 +511,7 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n     substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n-) {\n+) -> Result<(), ErrorReported> {\n     if let Err(partially_expanded_type) = tcx.try_expand_impl_trait_type(def_id.to_def_id(), substs)\n     {\n         match origin {\n@@ -514,9 +521,82 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n             }\n             _ => opaque_type_cycle_error(tcx, def_id, span),\n         }\n+        Err(ErrorReported)\n+    } else {\n+        Ok(())\n     }\n }\n \n+/// Check that the concrete type behind `impl Trait` actually implements `Trait`.\n+///\n+/// This is mostly checked at the places that specify the opaque type, but we\n+/// check those cases in the `param_env` of that function, which may have\n+/// bounds not on this opaque type:\n+///\n+/// type X<T> = impl Clone\n+/// fn f<T: Clone>(t: T) -> X<T> {\n+///     t\n+/// }\n+///\n+/// Without this check the above code is incorrectly accepted: we would ICE if\n+/// some tried, for example, to clone an `Option<X<&mut ()>>`.\n+fn check_opaque_meets_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    substs: SubstsRef<'tcx>,\n+    span: Span,\n+    origin: &hir::OpaqueTyOrigin,\n+) {\n+    match origin {\n+        // Checked when type checking the function containing them.\n+        hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => return,\n+        // Can have different predicates to their defining use\n+        hir::OpaqueTyOrigin::Binding | hir::OpaqueTyOrigin::Misc => {}\n+    }\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let param_env = tcx.param_env(def_id);\n+\n+    tcx.infer_ctxt().enter(move |infcx| {\n+        let inh = Inherited::new(infcx, def_id);\n+        let infcx = &inh.infcx;\n+        let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+\n+        let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+\n+        let (_, opaque_type_map) = inh.register_infer_ok_obligations(\n+            infcx.instantiate_opaque_types(def_id, hir_id, param_env, &opaque_ty, span),\n+        );\n+\n+        for (def_id, opaque_defn) in opaque_type_map {\n+            match infcx\n+                .at(&misc_cause, param_env)\n+                .eq(opaque_defn.concrete_ty, tcx.type_of(def_id).subst(tcx, opaque_defn.substs))\n+            {\n+                Ok(infer_ok) => inh.register_infer_ok_obligations(infer_ok),\n+                Err(ty_err) => tcx.sess.delay_span_bug(\n+                    opaque_defn.definition_span,\n+                    &format!(\n+                        \"could not unify `{}` with revealed type:\\n{}\",\n+                        opaque_defn.concrete_ty, ty_err,\n+                    ),\n+                ),\n+            }\n+        }\n+\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(errors, None, false);\n+        }\n+\n+        // Finally, resolve all regions. This catches wily misuses of\n+        // lifetime parameters.\n+        let fcx = FnCtxt::new(&inh, param_env, hir_id);\n+        fcx.regionck_item(hir_id, span, &[]);\n+    });\n+}\n+\n pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n     debug!(\n         \"check_item_type(it.hir_id={}, it.name={})\",\n@@ -553,9 +633,25 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n \n             for item in items.iter() {\n                 let item = tcx.hir().trait_item(item.id);\n-                if let hir::TraitItemKind::Fn(sig, _) = &item.kind {\n-                    let abi = sig.header.abi;\n-                    fn_maybe_err(tcx, item.ident.span, abi);\n+                match item.kind {\n+                    hir::TraitItemKind::Fn(ref sig, _) => {\n+                        let abi = sig.header.abi;\n+                        fn_maybe_err(tcx, item.ident.span, abi);\n+                    }\n+                    hir::TraitItemKind::Type(.., Some(_default)) => {\n+                        let item_def_id = tcx.hir().local_def_id(item.hir_id).to_def_id();\n+                        let assoc_item = tcx.associated_item(item_def_id);\n+                        let trait_substs =\n+                            InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+                        let _: Result<_, rustc_errors::ErrorReported> = check_type_bounds(\n+                            tcx,\n+                            assoc_item,\n+                            assoc_item,\n+                            item.span,\n+                            ty::TraitRef { def_id: def_id.to_def_id(), substs: trait_substs },\n+                        );\n+                    }\n+                    _ => {}\n                 }\n             }\n         }"}, {"sha": "4acc7451a2131399a065829788a1f8f7698a4c62", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 51, "deletions": 37, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::util;\n use rustc_middle::ty;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -327,7 +328,7 @@ fn compare_predicate_entailment<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_m_hir_id);\n-        fcx.regionck_item(impl_m_hir_id, impl_m_span, &[]);\n+        fcx.regionck_item(impl_m_hir_id, impl_m_span, trait_sig.inputs_and_output);\n \n         Ok(())\n     })\n@@ -1052,7 +1053,7 @@ crate fn compare_ty_impl<'tcx>(\n \n         compare_type_predicate_entailment(tcx, impl_ty, impl_ty_span, trait_ty, impl_trait_ref)?;\n \n-        compare_projection_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n+        check_type_bounds(tcx, trait_ty, impl_ty, impl_ty_span, impl_trait_ref)\n     })();\n }\n \n@@ -1170,20 +1171,13 @@ fn compare_type_predicate_entailment<'tcx>(\n /// For default associated types the normalization is not possible (the value\n /// from the impl could be overridden). We also can't normalize generic\n /// associated types (yet) because they contain bound parameters.\n-fn compare_projection_bounds<'tcx>(\n+pub fn check_type_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ty: &ty::AssocItem,\n     impl_ty: &ty::AssocItem,\n     impl_ty_span: Span,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorReported> {\n-    let have_gats = tcx.features().generic_associated_types;\n-    if impl_ty.defaultness.is_final() && !have_gats {\n-        // For \"final\", non-generic associate type implementations, we\n-        // don't need this as described above.\n-        return Ok(());\n-    }\n-\n     // Given\n     //\n     // impl<A, B> Foo<u32> for (A, B) {\n@@ -1211,16 +1205,27 @@ fn compare_projection_bounds<'tcx>(\n     // ParamEnv for normalization specifically.\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n-        predicates.push(\n-            ty::Binder::dummy(ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy {\n-                    item_def_id: trait_ty.def_id,\n-                    substs: rebased_substs,\n-                },\n-                ty: impl_ty_value,\n-            })\n-            .to_predicate(tcx),\n-        );\n+        match impl_ty_value.kind() {\n+            ty::Projection(proj)\n+                if proj.item_def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n+            {\n+                // Don't include this predicate if the projected type is\n+                // exactly the same as the projection. This can occur in\n+                // (somewhat dubious) code like this:\n+                //\n+                // impl<T> X for T where T: X { type Y = <T as X>::Y; }\n+            }\n+            _ => predicates.push(\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty: ty::ProjectionTy {\n+                        item_def_id: trait_ty.def_id,\n+                        substs: rebased_substs,\n+                    },\n+                    ty: impl_ty_value,\n+                })\n+                .to_predicate(tcx),\n+            ),\n+        };\n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), Reveal::UserFacing)\n     };\n \n@@ -1231,33 +1236,38 @@ fn compare_projection_bounds<'tcx>(\n \n         let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n         let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n-        let cause = ObligationCause::new(\n-            impl_ty_span,\n-            impl_ty_hir_id,\n-            ObligationCauseCode::ItemObligation(trait_ty.def_id),\n-        );\n+        let mk_cause = |span| {\n+            ObligationCause::new(\n+                impl_ty_span,\n+                impl_ty_hir_id,\n+                ObligationCauseCode::BindingObligation(trait_ty.def_id, span),\n+            )\n+        };\n \n-        let predicates = tcx.projection_predicates(trait_ty.def_id);\n-        debug!(\"compare_projection_bounds: projection_predicates={:?}\", predicates);\n+        let obligations = tcx\n+            .explicit_item_bounds(trait_ty.def_id)\n+            .iter()\n+            .map(|&(bound, span)| {\n+                let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n+                debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n \n-        for predicate in predicates {\n-            let concrete_ty_predicate = predicate.subst(tcx, rebased_substs);\n-            debug!(\"compare_projection_bounds: concrete predicate = {:?}\", concrete_ty_predicate);\n+                traits::Obligation::new(mk_cause(span), param_env, concrete_ty_bound)\n+            })\n+            .collect();\n+        debug!(\"check_type_bounds: item_bounds={:?}\", obligations);\n \n+        for mut obligation in util::elaborate_obligations(tcx, obligations) {\n             let traits::Normalized { value: normalized_predicate, obligations } = traits::normalize(\n                 &mut selcx,\n                 normalize_param_env,\n                 normalize_cause.clone(),\n-                &concrete_ty_predicate,\n+                &obligation.predicate,\n             );\n             debug!(\"compare_projection_bounds: normalized predicate = {:?}\", normalized_predicate);\n+            obligation.predicate = normalized_predicate;\n \n             inh.register_predicates(obligations);\n-            inh.register_predicate(traits::Obligation::new(\n-                cause.clone(),\n-                param_env,\n-                normalized_predicate,\n-            ));\n+            inh.register_predicate(obligation);\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n@@ -1270,7 +1280,11 @@ fn compare_projection_bounds<'tcx>(\n         // Finally, resolve all regions. This catches wily misuses of\n         // lifetime parameters.\n         let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n-        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &[]);\n+        let implied_bounds = match impl_ty.container {\n+            ty::TraitContainer(_) => vec![],\n+            ty::ImplContainer(def_id) => fcx.impl_implied_bounds(def_id, impl_ty_span),\n+        };\n+        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &implied_bounds);\n \n         Ok(())\n     })"}, {"sha": "b4e950ab6e9e50b7771b25ca7c3cff6eb6c8ddbf", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 20, "deletions": 88, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -420,6 +420,9 @@ fn check_associated_item(\n                 check_method_receiver(fcx, hir_sig, &item, self_ty);\n             }\n             ty::AssocKind::Type => {\n+                if let ty::AssocItemContainer::TraitContainer(_) = item.container {\n+                    check_associated_type_bounds(fcx, item, span)\n+                }\n                 if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.normalize_associated_types_in(span, &ty);\n@@ -571,7 +574,6 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n \n     for_item(tcx, item).with_fcx(|fcx, _| {\n         check_where_clauses(tcx, fcx, item.span, trait_def_id.to_def_id(), None);\n-        check_associated_type_defaults(fcx, trait_def_id.to_def_id());\n \n         vec![]\n     });\n@@ -581,96 +583,26 @@ fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n ///\n /// Assuming the defaults are used, check that all predicates (bounds on the\n /// assoc type and where clauses on the trait) hold.\n-fn check_associated_type_defaults(fcx: &FnCtxt<'_, '_>, trait_def_id: DefId) {\n+fn check_associated_type_bounds(fcx: &FnCtxt<'_, '_>, item: &ty::AssocItem, span: Span) {\n     let tcx = fcx.tcx;\n-    let substs = InternalSubsts::identity_for_item(tcx, trait_def_id);\n-\n-    // For all assoc. types with defaults, build a map from\n-    // `<Self as Trait<...>>::Assoc` to the default type.\n-    let map = tcx\n-        .associated_items(trait_def_id)\n-        .in_definition_order()\n-        .filter_map(|item| {\n-            if item.kind == ty::AssocKind::Type && item.defaultness.has_value() {\n-                // `<Self as Trait<...>>::Assoc`\n-                let proj = ty::ProjectionTy { substs, item_def_id: item.def_id };\n-                let default_ty = tcx.type_of(item.def_id);\n-                debug!(\"assoc. type default mapping: {} -> {}\", proj, default_ty);\n-                Some((proj, default_ty))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<FxHashMap<_, _>>();\n-\n-    /// Replaces projections of associated types with their default types.\n-    ///\n-    /// This does a \"shallow substitution\", meaning that defaults that refer to\n-    /// other defaulted assoc. types will still refer to the projection\n-    /// afterwards, not to the other default. For example:\n-    ///\n-    /// ```compile_fail\n-    /// trait Tr {\n-    ///     type A: Clone = Vec<Self::B>;\n-    ///     type B = u8;\n-    /// }\n-    /// ```\n-    ///\n-    /// This will end up replacing the bound `Self::A: Clone` with\n-    /// `Vec<Self::B>: Clone`, not with `Vec<u8>: Clone`. If we did a deep\n-    /// substitution and ended up with the latter, the trait would be accepted.\n-    /// If an `impl` then replaced `B` with something that isn't `Clone`,\n-    /// suddenly the default for `A` is no longer valid. The shallow\n-    /// substitution forces the trait to add a `B: Clone` bound to be accepted,\n-    /// which means that an `impl` can replace any default without breaking\n-    /// others.\n-    ///\n-    /// Note that this isn't needed for soundness: The defaults would still be\n-    /// checked in any impl that doesn't override them.\n-    struct DefaultNormalizer<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        map: FxHashMap<ty::ProjectionTy<'tcx>, Ty<'tcx>>,\n-    }\n \n-    impl<'tcx> ty::fold::TypeFolder<'tcx> for DefaultNormalizer<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n-            self.tcx\n-        }\n+    let bounds = tcx.explicit_item_bounds(item.def_id);\n \n-        fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-            match t.kind() {\n-                ty::Projection(proj_ty) => {\n-                    if let Some(default) = self.map.get(&proj_ty) {\n-                        default\n-                    } else {\n-                        t.super_fold_with(self)\n-                    }\n-                }\n-                _ => t.super_fold_with(self),\n-            }\n-        }\n-    }\n-\n-    // Now take all predicates defined on the trait, replace any mention of\n-    // the assoc. types with their default, and prove them.\n-    // We only consider predicates that directly mention the assoc. type.\n-    let mut norm = DefaultNormalizer { tcx, map };\n-    let predicates = fcx.tcx.predicates_of(trait_def_id);\n-    for &(orig_pred, span) in predicates.predicates.iter() {\n-        let pred = orig_pred.fold_with(&mut norm);\n-        if pred != orig_pred {\n-            // Mentions one of the defaulted assoc. types\n-            debug!(\"default suitability check: proving predicate: {} -> {}\", orig_pred, pred);\n-            let pred = fcx.normalize_associated_types_in(span, &pred);\n-            let cause = traits::ObligationCause::new(\n-                span,\n-                fcx.body_id,\n-                traits::ItemObligation(trait_def_id),\n-            );\n-            let obligation = traits::Obligation::new(cause, fcx.param_env, pred);\n+    debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n+    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+        let normalized_bound = fcx.normalize_associated_types_in(span, &bound);\n+        traits::wf::predicate_obligations(\n+            fcx,\n+            fcx.param_env,\n+            fcx.body_id,\n+            normalized_bound,\n+            bound_span,\n+        )\n+    });\n \n-            fcx.register_predicate(obligation);\n-        }\n+    for obligation in wf_obligations {\n+        debug!(\"next obligation cause: {:?}\", obligation.cause);\n+        fcx.register_predicate(obligation);\n     }\n }\n \n@@ -1493,7 +1425,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n+    pub(super) fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n         match self.tcx.impl_trait_ref(impl_def_id) {\n             Some(ref trait_ref) => {\n                 // Trait impl: take implied bounds from all types that"}, {"sha": "092dae18192e51e03100ab4b632af06fa7a3ee5a", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 107, "deletions": 106, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -50,6 +50,7 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n+mod item_bounds;\n mod type_of;\n \n struct OnlySelfBounds(bool);\n@@ -68,12 +69,15 @@ pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n+        item_bounds: item_bounds::item_bounds,\n+        explicit_item_bounds: item_bounds::explicit_item_bounds,\n         generics_of,\n         predicates_of,\n         predicates_defined_on,\n         projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n+        trait_explicit_predicates_and_bounds,\n         type_param_predicates,\n         trait_def,\n         adt_def,\n@@ -700,6 +704,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n         hir::ItemKind::OpaqueTy(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n+            tcx.ensure().explicit_item_bounds(def_id);\n         }\n         hir::ItemKind::TyAlias(..)\n         | hir::ItemKind::Static(..)\n@@ -708,8 +713,10 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            if let hir::ItemKind::Fn(..) = it.kind {\n-                tcx.ensure().fn_sig(def_id);\n+            match it.kind {\n+                hir::ItemKind::Fn(..) => tcx.ensure().fn_sig(def_id),\n+                hir::ItemKind::OpaqueTy(..) => tcx.ensure().item_bounds(def_id),\n+                _ => (),\n             }\n         }\n     }\n@@ -730,15 +737,25 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             tcx.ensure().type_of(def_id);\n         }\n \n-        hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(_, Some(_)) => {\n+        hir::TraitItemKind::Const(..) => {\n             tcx.ensure().type_of(def_id);\n-            // Account for `const C: _;` and `type T = _;`.\n+            // Account for `const C: _;`.\n+            let mut visitor = PlaceholderHirTyCollector::default();\n+            visitor.visit_trait_item(trait_item);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false);\n+        }\n+\n+        hir::TraitItemKind::Type(_, Some(_)) => {\n+            tcx.ensure().item_bounds(def_id);\n+            tcx.ensure().type_of(def_id);\n+            // Account for `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n             placeholder_type_error(tcx, None, &[], visitor.0, false);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n+            tcx.ensure().item_bounds(def_id);\n             // #74612: Visit and try to find bad placeholders\n             // even if there is no concrete type.\n             let mut visitor = PlaceholderHirTyCollector::default();\n@@ -1716,7 +1733,7 @@ fn predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n \n /// Returns a list of user-specified type predicates for the definition with ID `def_id`.\n /// N.B., this does not include any implied/inferred constraints.\n-fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n+fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n@@ -1726,7 +1743,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     let mut is_trait = None;\n     let mut is_default_impl_trait = None;\n-    let mut is_trait_associated_type = None;\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let constness = icx.default_constness_for_trait_bounds();\n@@ -1739,12 +1755,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n     let ast_generics = match node {\n-        Node::TraitItem(item) => {\n-            if let hir::TraitItemKind::Type(bounds, _) = item.kind {\n-                is_trait_associated_type = Some((bounds, item.span));\n-            }\n-            &item.generics\n-        }\n+        Node::TraitItem(item) => &item.generics,\n \n         Node::ImplItem(item) => &item.generics,\n \n@@ -1762,44 +1773,38 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                 | ItemKind::Struct(_, ref generics)\n                 | ItemKind::Union(_, ref generics) => generics,\n \n-                ItemKind::Trait(_, _, ref generics, .., items) => {\n-                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                     generics\n                 }\n                 ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some((ty::TraitRef::identity(tcx, def_id), &[]));\n+                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n                     generics\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy {\n-                    ref bounds,\n+                    bounds: _,\n                     impl_trait_fn,\n                     ref generics,\n                     origin: _,\n                 }) => {\n-                    let bounds_predicates = ty::print::with_no_queries(|| {\n-                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                        let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                        // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                        let bounds = AstConv::compute_bounds(\n-                            &icx,\n-                            opaque_ty,\n-                            bounds,\n-                            SizedByDefault::Yes,\n-                            tcx.def_span(def_id),\n-                        );\n-\n-                        bounds.predicates(tcx, opaque_ty)\n-                    });\n                     if impl_trait_fn.is_some() {\n-                        // opaque types\n-                        return ty::GenericPredicates {\n-                            parent: None,\n-                            predicates: tcx.arena.alloc_from_iter(bounds_predicates),\n-                        };\n+                        // return-position impl trait\n+                        //\n+                        // We don't inherit predicates from the parent here:\n+                        // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n+                        // then the return type is `f::<'static, T>::{{opaque}}`.\n+                        //\n+                        // If we inherited the predicates of `f` then we would\n+                        // require that `T: 'static` to show that the return\n+                        // type is well-formed.\n+                        //\n+                        // The only way to have something with this opaque type\n+                        // is from the return type of the containing function,\n+                        // which will ensure that the function's predicates\n+                        // hold.\n+                        return ty::GenericPredicates { parent: None, predicates: &[] };\n                     } else {\n-                        // named opaque types\n-                        predicates.extend(bounds_predicates);\n+                        // type-alias impl trait\n                         generics\n                     }\n                 }\n@@ -1825,7 +1830,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // and the explicit where-clauses, but to get the full set of predicates\n     // on a trait we need to add in the supertrait bounds and bounds found on\n     // associated types.\n-    if let Some((_trait_ref, _)) = is_trait {\n+    if let Some(_trait_ref) = is_trait {\n         predicates.extend(tcx.super_predicates_of(def_id).predicates.iter().cloned());\n     }\n \n@@ -1992,24 +1997,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    // Add predicates from associated type bounds (`type X: Bound`)\n-    if tcx.features().generic_associated_types {\n-        // New behavior: bounds declared on associate type are predicates of that\n-        // associated type. Not the default because it needs more testing.\n-        if let Some((bounds, span)) = is_trait_associated_type {\n-            let projection_ty =\n-                tcx.mk_projection(def_id, InternalSubsts::identity_for_item(tcx, def_id));\n-\n-            predicates.extend(associated_item_bounds(tcx, def_id, bounds, projection_ty, span))\n-        }\n-    } else if let Some((self_trait_ref, trait_items)) = is_trait {\n-        // Current behavior: bounds declared on associate type are predicates\n-        // of its parent trait.\n-        predicates.extend(trait_items.iter().flat_map(|trait_item_ref| {\n-            trait_associated_item_predicates(tcx, def_id, self_trait_ref, trait_item_ref)\n-        }))\n-    }\n-\n     if tcx.features().const_evaluatable_checked {\n         predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n     }\n@@ -2131,6 +2118,69 @@ fn const_evaluatable_predicates_of<'tcx>(\n     collector.preds\n }\n \n+fn trait_explicit_predicates_and_bounds(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+) -> ty::GenericPredicates<'_> {\n+    assert_eq!(tcx.def_kind(def_id), DefKind::Trait);\n+    gather_explicit_predicates_of(tcx, def_id.to_def_id())\n+}\n+\n+fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicates<'_> {\n+    if let DefKind::Trait = tcx.def_kind(def_id) {\n+        // Remove bounds on associated types from the predicates, they will be\n+        // returned by `explicit_item_bounds`.\n+        let predicates_and_bounds = tcx.trait_explicit_predicates_and_bounds(def_id.expect_local());\n+        let trait_identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n+\n+        let is_assoc_item_ty = |ty: Ty<'_>| {\n+            // For a predicate from a where clause to become a bound on an\n+            // associated type:\n+            // * It must use the identity substs of the item.\n+            //     * Since any generic parameters on the item are not in scope,\n+            //       this means that the item is not a GAT, and its identity\n+            //       substs are the same as the trait's.\n+            // * It must be an associated type for this trait (*not* a\n+            //   supertrait).\n+            if let ty::Projection(projection) = ty.kind() {\n+                if projection.substs == trait_identity_substs\n+                    && tcx.associated_item(projection.item_def_id).container.id() == def_id\n+                {\n+                    true\n+                } else {\n+                    false\n+                }\n+            } else {\n+                false\n+            }\n+        };\n+\n+        let predicates: Vec<_> = predicates_and_bounds\n+            .predicates\n+            .iter()\n+            .copied()\n+            .filter(|(pred, _)| match pred.skip_binders() {\n+                ty::PredicateAtom::Trait(tr, _) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateAtom::Projection(proj) => {\n+                    !is_assoc_item_ty(proj.projection_ty.self_ty())\n+                }\n+                ty::PredicateAtom::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n+                _ => true,\n+            })\n+            .collect();\n+        if predicates.len() == predicates_and_bounds.predicates.len() {\n+            predicates_and_bounds\n+        } else {\n+            ty::GenericPredicates {\n+                parent: predicates_and_bounds.parent,\n+                predicates: tcx.arena.alloc_slice(&predicates),\n+            }\n+        }\n+    } else {\n+        gather_explicit_predicates_of(tcx, def_id)\n+    }\n+}\n+\n fn projection_ty_from_predicates(\n     tcx: TyCtxt<'tcx>,\n     key: (\n@@ -2153,55 +2203,6 @@ fn projection_ty_from_predicates(\n     projection_ty\n }\n \n-fn trait_associated_item_predicates(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    self_trait_ref: ty::TraitRef<'tcx>,\n-    trait_item_ref: &hir::TraitItemRef,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    let trait_item = tcx.hir().trait_item(trait_item_ref.id);\n-    let item_def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n-    let bounds = match trait_item.kind {\n-        hir::TraitItemKind::Type(ref bounds, _) => bounds,\n-        _ => return Vec::new(),\n-    };\n-\n-    if !tcx.generics_of(item_def_id).params.is_empty() {\n-        // For GATs the substs provided to the mk_projection call below are\n-        // wrong. We should emit a feature gate error if we get here so skip\n-        // this type.\n-        tcx.sess.delay_span_bug(trait_item.span, \"gats used without feature gate\");\n-        return Vec::new();\n-    }\n-\n-    let assoc_ty = tcx.mk_projection(\n-        tcx.hir().local_def_id(trait_item.hir_id).to_def_id(),\n-        self_trait_ref.substs,\n-    );\n-\n-    associated_item_bounds(tcx, def_id, bounds, assoc_ty, trait_item.span)\n-}\n-\n-fn associated_item_bounds(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    bounds: &'tcx [hir::GenericBound<'tcx>],\n-    projection_ty: Ty<'tcx>,\n-    span: Span,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    let bounds = AstConv::compute_bounds(\n-        &ItemCtxt::new(tcx, def_id),\n-        projection_ty,\n-        bounds,\n-        SizedByDefault::Yes,\n-        span,\n-    );\n-\n-    let predicates = bounds.predicates(tcx, projection_ty);\n-\n-    predicates\n-}\n-\n /// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self type. A vector is returned\n /// because this can be anywhere from zero predicates (`T: ?Sized` adds no"}, {"sha": "9c29ceeb593df8a19f36ab11d491eb21152048a1", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,111 @@\n+use super::ItemCtxt;\n+use crate::astconv::{AstConv, SizedByDefault};\n+use rustc_hir as hir;\n+use rustc_infer::traits::util;\n+use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n+\n+/// For associated types we include both bounds written on the type\n+/// (`type X: Trait`) and predicates from the trait: `where Self::X: Trait`.\n+///\n+/// Note that this filtering is done with the items identity substs to\n+/// simplify checking that these bounds are met in impls. This means that\n+/// a bound such as `for<'b> <Self as X<'b>>::U: Clone` can't be used, as in\n+/// `hr-associated-type-bound-1.rs`.\n+fn associated_type_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    assoc_item_def_id: DefId,\n+    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    span: Span,\n+) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    let item_ty = tcx.mk_projection(\n+        assoc_item_def_id,\n+        InternalSubsts::identity_for_item(tcx, assoc_item_def_id),\n+    );\n+\n+    let bounds = AstConv::compute_bounds(\n+        &ItemCtxt::new(tcx, assoc_item_def_id),\n+        item_ty,\n+        bounds,\n+        SizedByDefault::Yes,\n+        span,\n+    );\n+\n+    let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n+    let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n+\n+    let bounds_from_parent =\n+        trait_predicates.predicates.iter().copied().filter(|(pred, _)| match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(tr, _) => tr.self_ty() == item_ty,\n+            ty::PredicateAtom::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n+            ty::PredicateAtom::TypeOutlives(outlives) => outlives.0 == item_ty,\n+            _ => false,\n+        });\n+\n+    let all_bounds = tcx\n+        .arena\n+        .alloc_from_iter(bounds.predicates(tcx, item_ty).into_iter().chain(bounds_from_parent));\n+    debug!(\"associated_type_bounds({}) = {:?}\", tcx.def_path_str(assoc_item_def_id), all_bounds);\n+    all_bounds\n+}\n+\n+/// Opaque types don't inherit bounds from their parent: for return position\n+/// impl trait it isn't possible to write a suitable predicate on the\n+/// containing function and for type-alias impl trait we don't have a backwards\n+/// compatibility issue.\n+fn opaque_type_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    opaque_def_id: DefId,\n+    bounds: &'tcx [hir::GenericBound<'tcx>],\n+    span: Span,\n+) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    let item_ty =\n+        tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n+\n+    let bounds = ty::print::with_no_queries(|| {\n+        AstConv::compute_bounds(\n+            &ItemCtxt::new(tcx, opaque_def_id),\n+            item_ty,\n+            bounds,\n+            SizedByDefault::Yes,\n+            span,\n+        )\n+    });\n+\n+    let bounds = bounds.predicates(tcx, item_ty);\n+    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n+\n+    tcx.arena.alloc_slice(&bounds)\n+}\n+\n+pub(super) fn explicit_item_bounds(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+) -> &'_ [(ty::Predicate<'_>, Span)] {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    match tcx.hir().get(hir_id) {\n+        hir::Node::TraitItem(hir::TraitItem {\n+            kind: hir::TraitItemKind::Type(bounds, _),\n+            span,\n+            ..\n+        }) => associated_type_bounds(tcx, def_id, bounds, *span),\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }),\n+            span,\n+            ..\n+        }) => opaque_type_bounds(tcx, def_id, bounds, *span),\n+        _ => bug!(\"item_bounds called on {:?}\", def_id),\n+    }\n+}\n+\n+pub(super) fn item_bounds(tcx: TyCtxt<'_>, def_id: DefId) -> &'_ ty::List<ty::Predicate<'_>> {\n+    tcx.mk_predicates(\n+        util::elaborate_predicates(\n+            tcx,\n+            tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n+        )\n+        .map(|obligation| obligation.predicate),\n+    )\n+}"}, {"sha": "4cf3efcf5136d254e834414e846d59ea15aa4ba5", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -337,6 +337,7 @@ fn check_predicates<'tcx>(\n             infcx,\n             tcx.param_env(impl1_def_id),\n             tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+            0,\n             arg,\n             span,\n         ) {"}, {"sha": "ac1e2b467045c5a03f8cf75926ba156c83cbba54", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::bug;\n use rustc_middle::middle::resolve_lifetime as rl;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::subst::InternalSubsts;\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, AdtKind, Lift, Ty, TyCtxt};\n use rustc_mir::const_eval::{is_const_fn, is_min_const_fn, is_unstable_const_fn};\n use rustc_span::hygiene::MacroKind;\n@@ -1268,13 +1268,10 @@ impl Clean<Item> for ty::AssocItem {\n             ty::AssocKind::Type => {\n                 let my_name = self.ident.name.clean(cx);\n \n-                if let ty::TraitContainer(did) = self.container {\n-                    // When loading a cross-crate associated type, the bounds for this type\n-                    // are actually located on the trait/impl itself, so we need to load\n-                    // all of the generics from there and then look for bounds that are\n-                    // applied to this associated type in question.\n-                    let predicates = cx.tcx.explicit_predicates_of(did);\n-                    let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n+                if let ty::TraitContainer(_) = self.container {\n+                    let bounds = cx.tcx.explicit_item_bounds(self.def_id);\n+                    let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n+                    let generics = (cx.tcx.generics_of(self.def_id), predicates).clean(cx);\n                     let mut bounds = generics\n                         .where_predicates\n                         .iter()\n@@ -1678,19 +1675,22 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Opaque(def_id, substs) => {\n                 // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the projections associated with the def_id.\n-                let predicates_of = cx.tcx.explicit_predicates_of(def_id);\n+                // by looking up the bounds associated with the def_id.\n                 let substs = cx.tcx.lift(&substs).expect(\"Opaque lift failed\");\n-                let bounds = predicates_of.instantiate(cx.tcx, substs);\n+                let bounds = cx\n+                    .tcx\n+                    .explicit_item_bounds(def_id)\n+                    .iter()\n+                    .map(|(bound, _)| bound.subst(cx.tcx, substs))\n+                    .collect::<Vec<_>>();\n                 let mut regions = vec![];\n                 let mut has_sized = false;\n                 let mut bounds = bounds\n-                    .predicates\n                     .iter()\n-                    .filter_map(|predicate| {\n+                    .filter_map(|bound| {\n                         // Note: The substs of opaque types can contain unbound variables,\n                         // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let trait_ref = match predicate.bound_atom(cx.tcx).skip_binder() {\n+                        let trait_ref = match bound.bound_atom(cx.tcx).skip_binder() {\n                             ty::PredicateAtom::Trait(tr, _constness) => {\n                                 ty::Binder::bind(tr.trait_ref)\n                             }\n@@ -1711,11 +1711,10 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         }\n \n                         let bounds: Vec<_> = bounds\n-                            .predicates\n                             .iter()\n-                            .filter_map(|pred| {\n+                            .filter_map(|bound| {\n                                 if let ty::PredicateAtom::Projection(proj) =\n-                                    pred.bound_atom(cx.tcx).skip_binder()\n+                                    bound.bound_atom(cx.tcx).skip_binder()\n                                 {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()\n@@ -2067,13 +2066,10 @@ impl Clean<Item> for doctree::OpaqueTy<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: OpaqueTyItem(\n-                OpaqueTy {\n-                    bounds: self.opaque_ty.bounds.clean(cx),\n-                    generics: self.opaque_ty.generics.clean(cx),\n-                },\n-                false,\n-            ),\n+            inner: OpaqueTyItem(OpaqueTy {\n+                bounds: self.opaque_ty.bounds.clean(cx),\n+                generics: self.opaque_ty.generics.clean(cx),\n+            }),\n         }\n     }\n }"}, {"sha": "bb6f449e3550d5768558f8185199351816e3fd91", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -252,7 +252,7 @@ pub enum ItemEnum {\n     FunctionItem(Function),\n     ModuleItem(Module),\n     TypedefItem(Typedef, bool /* is associated type */),\n-    OpaqueTyItem(OpaqueTy, bool /* is associated type */),\n+    OpaqueTyItem(OpaqueTy),\n     StaticItem(Static),\n     ConstantItem(Constant),\n     TraitItem(Trait),"}, {"sha": "afd1dc596427ff640dad0690b57f330047ab6a71", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1709,7 +1709,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n         clean::ForeignTypeItem => item_foreign_type(buf, cx, item, cache),\n         clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e, cache),\n+        clean::OpaqueTyItem(ref e) => item_opaque_ty(buf, cx, item, e, cache),\n         clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta, cache),\n         _ => {\n             // We don't generate pages for any other type."}, {"sha": "9e449de0cf5acdf4357ea119e43b5132f2cd53cd", "filename": "src/test/incremental/issue-54242.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fincremental%2Fissue-54242.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fincremental%2Fissue-54242.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-54242.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,6 +1,9 @@\n // revisions: rpass cfail\n \n-trait Tr {\n+trait Tr\n+where\n+    (Self::Arr,): Sized,\n+{\n     type Arr;\n \n     const C: usize = 0;"}, {"sha": "c1421f20a0ba23da67f9e3203b958aa58bc4cd3c", "filename": "src/test/mir-opt/issue_62289.test.ElaborateDrops.before.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -69,7 +69,7 @@ fn test() -> Option<Box<u32>> {\n \n     bb5: {\n         StorageDead(_9);                 // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n-        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb12]; // scope 2 at $DIR/issue-62289.rs:9:19: 9:20\n+        _0 = <Option<Box<u32>> as Try>::from_error(move _8) -> [return: bb6, unwind: bb12]; // scope 2 at $DIR/issue-62289.rs:9:15: 9:20\n                                          // mir::Constant\n                                          // + span: $DIR/issue-62289.rs:9:15: 9:20\n                                          // + literal: Const { ty: fn(<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::Error) -> std::option::Option<std::boxed::Box<u32>> {<std::option::Option<std::boxed::Box<u32>> as std::ops::Try>::from_error}, val: Value(Scalar(<ZST>)) }"}, {"sha": "a811a2c178f170877fb65f05aa07c213605258ae", "filename": "src/test/mir-opt/simplify_arm.id_try.SimplifyArmIdentity.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyArmIdentity.diff?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -29,7 +29,7 @@\n               scope 8 {\n -                 debug v => _8;           // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:14: 24:15\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:13: 24:15\n               }\n           }\n       }"}, {"sha": "b0cc3e88f35ac2bbe82087207dfc8b53b8e62d90", "filename": "src/test/mir-opt/simplify_arm.id_try.SimplifyBranchSame.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_arm.id_try.SimplifyBranchSame.diff?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -25,7 +25,7 @@\n               }\n               scope 8 {\n                   debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:14: 24:15\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify-arm.rs:24:13: 24:15\n               }\n           }\n       }"}, {"sha": "12a6617cc5a278f89adda828952f1f0d94d887b3", "filename": "src/test/mir-opt/simplify_try.try_identity.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -25,7 +25,7 @@\n               }\n               scope 8 {\n                   debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:14: 8:15\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n               }\n           }\n       }"}, {"sha": "534836eff7b2d1875e60a1eed5cc82aca063bb7c", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyArmIdentity.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -29,7 +29,7 @@\n               scope 8 {\n -                 debug v => _8;           // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:14: 8:15\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n               }\n           }\n       }"}, {"sha": "d2e37bf4e12ebcb10ece3686a3ac6b8c70f679fc", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyBranchSame.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -24,7 +24,7 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n             }\n             scope 8 {\n                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:14: 8:15\n+                let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:8:13: 8:15\n             }\n         }\n     }"}, {"sha": "49f11140741c2e45da3fbaa410b5e9c7b0f330bd", "filename": "src/test/ui/associated-type-bounds/assoc-type-bound-through-where-clause.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-bound-through-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-bound-through-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-bound-through-where-clause.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,16 @@\n+// Check that `where Self::Output: Copy` is turned into a bound on `Op::Output`.\n+\n+//check-pass\n+\n+trait Op\n+where\n+    Self::Output: Copy,\n+{\n+    type Output;\n+}\n+\n+fn duplicate<T: Op>(x: T::Output) -> (T::Output, T::Output) {\n+    (x, x)\n+}\n+\n+fn main() {}"}, {"sha": "73b23da5bcb66528d55385ef3179ca718852de42", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -12,19 +12,24 @@\n \n fn main() {}\n \n-trait Bar { type Assoc; }\n+trait Bar {\n+    type Assoc;\n+}\n \n trait Thing {\n     type Out;\n     fn func() -> Self::Out;\n }\n \n struct AssocNoCopy;\n-impl Bar for AssocNoCopy { type Assoc = String; }\n+impl Bar for AssocNoCopy {\n+    type Assoc = String;\n+}\n \n impl Thing for AssocNoCopy {\n     type Out = Box<dyn Bar<Assoc: Copy>>;\n     //~^ ERROR the trait bound `String: Copy` is not satisfied\n+    //~| ERROR the trait bound `String: Copy` is not satisfied\n \n     fn func() -> Self::Out {\n         Box::new(AssocNoCopy)"}, {"sha": "414d74d4786d97ce6d2da284b35b21a023ca975d", "filename": "src/test/ui/associated-type-bounds/assoc-type-eq-with-dyn-atb-fail.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassoc-type-eq-with-dyn-atb-fail.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,15 @@\n error[E0277]: the trait bound `String: Copy` is not satisfied\n-  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:26:28\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:30:28\n    |\n LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n    |                            ^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/assoc-type-eq-with-dyn-atb-fail.rs:30:28\n    |\n-   = note: the return type of a function must have a statically known size\n+LL |     type Out = Box<dyn Bar<Assoc: Copy>>;\n+   |                            ^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "d180de9be3bf310896f4f65b601240a691ebb9da", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,40 +6,49 @@\n use std::fmt::Debug;\n use std::iter::Once;\n \n-trait Lam<Binder> { type App; }\n+trait Lam<Binder> {\n+    type App;\n+}\n \n #[derive(Clone)]\n struct L1;\n-impl<'a> Lam<&'a u8> for L1 { type App = u8; }\n+impl<'a> Lam<&'a u8> for L1 {\n+    type App = u8;\n+}\n \n #[derive(Clone)]\n struct L2;\n-impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n+impl<'a, 'b> Lam<&'a &'b u8> for L2 {\n+    type App = u8;\n+}\n \n trait Case1 {\n-    type C: Clone + Iterator<Item:\n-        Send + Iterator<Item:\n-            for<'a> Lam<&'a u8, App:\n-                Debug\n-            >\n-        > + Sync>;\n+    type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n+    //~^ ERROR `<<Self as Case1>::C as Iterator>::Item` is not an iterator\n+    //~| ERROR `<<Self as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n+    //~| ERROR `<<Self as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n }\n \n pub struct S1;\n impl Case1 for S1 {\n-//~^ ERROR `<L1 as Lam<&'a u8>>::App` doesn't implement `Debug` [E0277]\n     type C = Once<Once<L1>>;\n }\n \n fn assume_case1<T: Case1>() {\n-//~^ ERROR `<_ as Lam<&'a u8>>::App` doesn't implement `Debug` [E0277]\n-//~| ERROR `<<T as Case1>::C as Iterator>::Item` is not an iterator [E0277]\n-//~| ERROR `<<T as Case1>::C as Iterator>::Item` cannot be sent between threads safely [E0277]\n-//~| ERROR `<<T as Case1>::C as Iterator>::Item` cannot be shared between threads safely [E0277]\n-    fn assert_a<_0, A>() where A: Iterator<Item = _0>, _0: Debug {}\n+    fn assert_a<_0, A>()\n+    where\n+        A: Iterator<Item = _0>,\n+        _0: Debug,\n+    {\n+    }\n     assert_a::<_, T::A>();\n \n-    fn assert_b<_0, B>() where B: Iterator<Item = _0>, _0: 'static {}\n+    fn assert_b<_0, B>()\n+    where\n+        B: Iterator<Item = _0>,\n+        _0: 'static,\n+    {\n+    }\n     assert_b::<_, T::B>();\n \n     fn assert_c<_0, _1, _2, C>()\n@@ -48,7 +57,8 @@ fn assume_case1<T: Case1>() {\n         _2: Send + Iterator<Item = _1>,\n         _1: for<'a> Lam<&'a u8, App = _0>,\n         _0: Debug,\n-    {}\n+    {\n+    }\n     assert_c::<_, _, _, T::C>();\n }\n "}, {"sha": "e68b5b342a40c825bb146f2a96abd2bf0403eb7e", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,79 +1,49 @@\n-error[E0277]: `<L1 as Lam<&'a u8>>::App` doesn't implement `Debug`\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:29:6\n+error[E0277]: `<<Self as Case1>::C as Iterator>::Item` is not an iterator\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:5\n    |\n-LL | trait Case1 {\n-   |       ----- required by a bound in this\n-...\n-LL |                 Debug\n-   |                 ----- required by this bound in `Case1`\n-...\n-LL | impl Case1 for S1 {\n-   |      ^^^^^ `<L1 as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `<<Self as Case1>::C as Iterator>::Item` is not an iterator\n    |\n-   = help: the trait `for<'a> Debug` is not implemented for `<L1 as Lam<&'a u8>>::App`\n-\n-error[E0277]: `<<T as Case1>::C as Iterator>::Item` is not an iterator\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:34:20\n-   |\n-LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^ `<<T as Case1>::C as Iterator>::Item` is not an iterator\n-   |\n-   = help: the trait `Iterator` is not implemented for `<<T as Case1>::C as Iterator>::Item`\n+   = help: the trait `Iterator` is not implemented for `<<Self as Case1>::C as Iterator>::Item`\n help: consider further restricting the associated type\n    |\n-LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as Iterator>::Item: Iterator {\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait Case1 where <<Self as Case1>::C as Iterator>::Item: Iterator {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: `<<T as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:34:20\n+error[E0277]: `<<Self as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:36\n+   |\n+LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n+   |                                    ^^^^ `<<Self as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n+   | \n+  ::: $SRC_DIR/core/src/marker.rs:LL:COL\n    |\n-LL | trait Case1 {\n-   |       ----- required by a bound in this\n-LL |     type C: Clone + Iterator<Item:\n-LL |         Send + Iterator<Item:\n-   |         ---- required by this bound in `Case1`\n-...\n-LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^ `<<T as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n+LL | pub unsafe auto trait Send {\n+   | -------------------------- required by this bound in `Send`\n    |\n-   = help: the trait `Send` is not implemented for `<<T as Case1>::C as Iterator>::Item`\n+   = help: the trait `Send` is not implemented for `<<Self as Case1>::C as Iterator>::Item`\n help: consider further restricting the associated type\n    |\n-LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as Iterator>::Item: Send {\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait Case1 where <<Self as Case1>::C as Iterator>::Item: Send {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: `<<T as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:34:20\n+error[E0277]: `<<Self as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:93\n    |\n-LL | trait Case1 {\n-   |       ----- required by a bound in this\n-...\n-LL |         > + Sync>;\n-   |             ---- required by this bound in `Case1`\n-...\n-LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^ `<<T as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n+LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n+   |                                                                                             ^^^^ `<<Self as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n+   | \n+  ::: $SRC_DIR/core/src/marker.rs:LL:COL\n    |\n-   = help: the trait `Sync` is not implemented for `<<T as Case1>::C as Iterator>::Item`\n-help: consider further restricting the associated type\n-   |\n-LL | fn assume_case1<T: Case1>() where <<T as Case1>::C as Iterator>::Item: Sync {\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: `<_ as Lam<&'a u8>>::App` doesn't implement `Debug`\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:34:20\n+LL | pub unsafe auto trait Sync {\n+   | -------------------------- required by this bound in `Sync`\n    |\n-LL | trait Case1 {\n-   |       ----- required by a bound in this\n-...\n-LL |                 Debug\n-   |                 ----- required by this bound in `Case1`\n-...\n-LL | fn assume_case1<T: Case1>() {\n-   |                    ^^^^^ `<_ as Lam<&'a u8>>::App` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   = help: the trait `Sync` is not implemented for `<<Self as Case1>::C as Iterator>::Item`\n+help: consider further restricting the associated type\n    |\n-   = help: the trait `for<'a> Debug` is not implemented for `<_ as Lam<&'a u8>>::App`\n+LL | trait Case1 where <<Self as Case1>::C as Iterator>::Item: Sync {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "23be735010bf3374d169fcd18944533ee1272b7a", "filename": "src/test/ui/associated-type-bounds/bounds-on-assoc-in-trait.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,5 +1,3 @@\n-// check-pass\n-\n #![feature(associated_type_bounds)]\n \n use std::fmt::Debug;\n@@ -18,6 +16,7 @@ impl<'a, 'b> Lam<&'a &'b u8> for L2 { type App = u8; }\n \n trait Case1 {\n     type A: Iterator<Item: Debug>;\n+    //~^ ERROR `<<Self as Case1>::A as Iterator>::Item` doesn't implement `Debug`\n \n     type B: Iterator<Item: 'static>;\n }\n@@ -30,7 +29,11 @@ impl Case1 for S1 {\n \n // Ensure we don't have opaque `impl Trait` desugaring:\n \n+// What is this supposed to mean? Rustc currently lowers `: Default` in the\n+// bounds of `Out`, but trait selection can't find the bound since it applies\n+// to a type other than `Self::Out`.\n pub trait Foo { type Out: Baz<Assoc: Default>; }\n+//~^ ERROR trait bound `<<Self as Foo>::Out as Baz>::Assoc: Default` is not satisfied\n pub trait Baz { type Assoc; }\n \n #[derive(Default)]"}, {"sha": "919b18632e61c1283b517432d034f092de2bca3b", "filename": "src/test/ui/associated-type-bounds/bounds-on-assoc-in-trait.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbounds-on-assoc-in-trait.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,36 @@\n+error[E0277]: `<<Self as Case1>::A as Iterator>::Item` doesn't implement `Debug`\n+  --> $DIR/bounds-on-assoc-in-trait.rs:18:28\n+   |\n+LL |     type A: Iterator<Item: Debug>;\n+   |                            ^^^^^ `<<Self as Case1>::A as Iterator>::Item` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   | \n+  ::: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+   |\n+LL | pub trait Debug {\n+   | --------------- required by this bound in `Debug`\n+   |\n+   = help: the trait `Debug` is not implemented for `<<Self as Case1>::A as Iterator>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | trait Case1 where <<Self as Case1>::A as Iterator>::Item: Debug {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `<<Self as Foo>::Out as Baz>::Assoc: Default` is not satisfied\n+  --> $DIR/bounds-on-assoc-in-trait.rs:35:38\n+   |\n+LL | pub trait Foo { type Out: Baz<Assoc: Default>; }\n+   |                                      ^^^^^^^ the trait `Default` is not implemented for `<<Self as Foo>::Out as Baz>::Assoc`\n+   | \n+  ::: $SRC_DIR/core/src/default.rs:LL:COL\n+   |\n+LL | pub trait Default: Sized {\n+   | ------------------------ required by this bound in `Default`\n+   |\n+help: consider further restricting the associated type\n+   |\n+LL | pub trait Foo where <<Self as Foo>::Out as Baz>::Assoc: Default { type Out: Baz<Assoc: Default>; }\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "de2876d6b60b8bcdb1ce410d2473b63f9d8825ae", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -511,30 +511,6 @@ LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:145:43\n-   |\n-LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n-   |                               ----------  ^^^^^^^^^^ re-bound here\n-   |                               |\n-   |                               `Item` bound here first\n-\n-error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:147:43\n-   |\n-LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n-   |                               ----------  ^^^^^^^^^^ re-bound here\n-   |                               |\n-   |                               `Item` bound here first\n-\n-error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n-  --> $DIR/duplicate.rs:149:46\n-   |\n-LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n-   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n-   |                               |\n-   |                               `Item` bound here first\n-\n error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n   --> $DIR/duplicate.rs:152:40\n    |\n@@ -559,6 +535,30 @@ LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n    |                            |\n    |                            `Item` bound here first\n \n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:145:43\n+   |\n+LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:147:43\n+   |\n+LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n+   |                               ----------  ^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n+error[E0719]: the value of the associated type `Item` (from trait `Iterator`) is already specified\n+  --> $DIR/duplicate.rs:149:46\n+   |\n+LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n+   |                               -------------  ^^^^^^^^^^^^^ re-bound here\n+   |                               |\n+   |                               `Item` bound here first\n+\n error: aborting due to 69 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0719`."}, {"sha": "db092970f79b88603e426dd821ebb6350b2c81e6", "filename": "src/test/ui/associated-types/associate-type-bound-normalization.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociate-type-bound-normalization.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,25 @@\n+// Make sure that we normalize bounds on associated types before checking them\n+// as candidates.\n+\n+// check-pass\n+\n+trait Mul<T> {\n+    type Output;\n+}\n+\n+trait Matrix: Mul<<Self as Matrix>::Row, Output = ()> {\n+    type Row;\n+\n+    type Transpose: Matrix<Row = Self::Row>;\n+}\n+\n+fn is_mul<S, T: Mul<S, Output = ()>>() {}\n+\n+fn f<T: Matrix>() {\n+    // The unnormalized bound on `T::Transpose` is\n+    // `Mul<<T::Transpose as Matrix>::Row` which has to be normalized to be\n+    // equal to `T::Row`.\n+    is_mul::<T::Row, T::Transpose>();\n+}\n+\n+fn main() {}"}, {"sha": "9f179b6454e5292dfa4345461a969685594f7d57", "filename": "src/test/ui/associated-types/associated-types-bound-ambiguity.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-ambiguity.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,23 @@\n+// Make sure that if there are multiple applicable bounds on a projection, we\n+// consider them ambiguous. In this test we are initially trying to solve\n+// `Self::Repr: From<_>`, which is ambiguous until we later infer `_` to\n+// `{integer}`.\n+\n+// check-pass\n+\n+trait PrimeField: Sized {\n+    type Repr: From<u64> + From<Self>;\n+    type Repr2: From<Self> + From<u64>;\n+\n+    fn method() {\n+        Self::Repr::from(10);\n+        Self::Repr2::from(10);\n+    }\n+}\n+\n+fn function<T: PrimeField>() {\n+    T::Repr::from(10);\n+    T::Repr2::from(10);\n+}\n+\n+fn main() {}"}, {"sha": "353f82e7c6e63e5f914fd63f76a3aa09193cdf1b", "filename": "src/test/ui/associated-types/associated-types-projection-bound-ambiguity.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-bound-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-bound-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-bound-ambiguity.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,16 @@\n+// Check that if we have multiple applicable projection bounds we pick one (for\n+// backwards compatibility reasons).\n+\n+// check-pass\n+use std::ops::Mul;\n+\n+trait A {\n+    type V;\n+    type U: Mul<Self::V, Output = ()> + Mul<(), Output = ()>;\n+}\n+\n+fn g<T: A<V = ()>>() {\n+    let y: <T::U as Mul<()>>::Output = ();\n+}\n+\n+fn main() {}"}, {"sha": "9d084203e3a8664c3962dedb90c85445bc1d1555", "filename": "src/test/ui/associated-types/associated-types-unconstrained.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unconstrained.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,14 @@\n-error[E0284]: type annotations needed\n+error[E0283]: type annotations needed\n   --> $DIR/associated-types-unconstrained.rs:14:20\n    |\n+LL |     fn bar() -> isize;\n+   |     ------------------ required by `Foo::bar`\n+...\n LL |     let x: isize = Foo::bar();\n    |                    ^^^^^^^^ cannot infer type\n    |\n-   = note: cannot satisfy `<_ as Foo>::A == _`\n+   = note: cannot satisfy `_: Foo`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0284`.\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "afb2b3df716ebda7e0b2828b9518dcfcbae60a06", "filename": "src/test/ui/associated-types/defaults-cyclic-fail-1.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,11 +6,8 @@ trait Tr {\n     type B = Self::A;\n }\n \n-// ...but is an error in any impl that doesn't override at least one of the defaults\n impl Tr for () {}\n-//~^ ERROR overflow evaluating the requirement\n \n-// As soon as at least one is redefined, it works:\n impl Tr for u8 {\n     type A = u8;\n }\n@@ -24,16 +21,14 @@ impl Tr for u32 {\n     type B = u8;\n }\n \n-// ...but only if this actually breaks the cycle\n+// ...but not in an impl that redefines one of the types.\n impl Tr for bool {\n-    //~^ ERROR type mismatch resolving `<bool as Tr>::B == _`\n     type A = Box<Self::B>;\n     //~^ ERROR type mismatch resolving `<bool as Tr>::B == _`\n }\n // (the error is shown twice for some reason)\n \n impl Tr for usize {\n-    //~^ ERROR type mismatch resolving `<usize as Tr>::B == _`\n     type B = &'static Self::A;\n     //~^ ERROR type mismatch resolving `<usize as Tr>::A == _`\n }"}, {"sha": "ae7150d47ca999e0921b6efc688d8109a3b96bd8", "filename": "src/test/ui/associated-types/defaults-cyclic-fail-1.stderr", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,34 +1,15 @@\n-error[E0275]: overflow evaluating the requirement `<() as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-1.rs:10:6\n-   |\n-LL | impl Tr for () {}\n-   |      ^^\n-\n-error[E0271]: type mismatch resolving `<bool as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-1.rs:28:6\n-   |\n-LL | impl Tr for bool {\n-   |      ^^ cyclic type of infinite size\n-\n-error[E0271]: type mismatch resolving `<usize as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-1.rs:35:6\n-   |\n-LL | impl Tr for usize {\n-   |      ^^ cyclic type of infinite size\n-\n error[E0271]: type mismatch resolving `<bool as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-1.rs:30:5\n+  --> $DIR/defaults-cyclic-fail-1.rs:26:5\n    |\n LL |     type A = Box<Self::B>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n \n error[E0271]: type mismatch resolving `<usize as Tr>::A == _`\n-  --> $DIR/defaults-cyclic-fail-1.rs:37:5\n+  --> $DIR/defaults-cyclic-fail-1.rs:32:5\n    |\n LL |     type B = &'static Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0271, E0275.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "ba4bb0d5a296bbc7fed770e052082ab0d3f4440c", "filename": "src/test/ui/associated-types/defaults-cyclic-fail-2.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,11 +8,8 @@ trait Tr {\n     type B = Box<Self::A>;\n }\n \n-// ...but is an error in any impl that doesn't override at least one of the defaults\n impl Tr for () {}\n-//~^ ERROR type mismatch resolving `<() as Tr>::B == _`\n \n-// As soon as at least one is redefined, it works:\n impl Tr for u8 {\n     type A = u8;\n }\n@@ -26,16 +23,13 @@ impl Tr for u32 {\n     type B = u8;\n }\n \n-// ...but only if this actually breaks the cycle\n impl Tr for bool {\n-    //~^ ERROR type mismatch resolving `<bool as Tr>::B == _`\n     type A = Box<Self::B>;\n     //~^ ERROR type mismatch resolving `<bool as Tr>::B == _`\n }\n // (the error is shown twice for some reason)\n \n impl Tr for usize {\n-    //~^ ERROR type mismatch resolving `<usize as Tr>::B == _`\n     type B = &'static Self::A;\n     //~^ ERROR type mismatch resolving `<usize as Tr>::A == _`\n }"}, {"sha": "0dfbac2dec5d5d4a0576e43708b029409413b0db", "filename": "src/test/ui/associated-types/defaults-cyclic-fail-2.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-cyclic-fail-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,33 +1,15 @@\n-error[E0271]: type mismatch resolving `<() as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-2.rs:12:6\n-   |\n-LL | impl Tr for () {}\n-   |      ^^ cyclic type of infinite size\n-\n-error[E0271]: type mismatch resolving `<bool as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-2.rs:30:6\n-   |\n-LL | impl Tr for bool {\n-   |      ^^ cyclic type of infinite size\n-\n-error[E0271]: type mismatch resolving `<usize as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-2.rs:37:6\n-   |\n-LL | impl Tr for usize {\n-   |      ^^ cyclic type of infinite size\n-\n error[E0271]: type mismatch resolving `<bool as Tr>::B == _`\n-  --> $DIR/defaults-cyclic-fail-2.rs:32:5\n+  --> $DIR/defaults-cyclic-fail-2.rs:27:5\n    |\n LL |     type A = Box<Self::B>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n \n error[E0271]: type mismatch resolving `<usize as Tr>::A == _`\n-  --> $DIR/defaults-cyclic-fail-2.rs:39:5\n+  --> $DIR/defaults-cyclic-fail-2.rs:33:5\n    |\n LL |     type B = &'static Self::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "504c957d98753f377e5764171ce3bf3e0dceb382", "filename": "src/test/ui/associated-types/defaults-suitability.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,10 +1,8 @@\n //! Checks that associated type defaults are properly validated.\n //!\n //! This means:\n-//! * Default types are wfchecked\n //! * Default types are checked against where clauses on the assoc. type\n-//!   (eg. `type Assoc: Clone = NotClone`), and also against where clauses on\n-//!   the trait itself when possible\n+//!   (eg. `type Assoc: Clone = NotClone`)\n \n #![feature(associated_type_defaults)]\n \n@@ -17,15 +15,12 @@ trait Tr {\n }\n \n // Where-clauses defined on the trait must also be considered\n-trait Tr2 where Self::Ty: Clone {\n-    //~^ ERROR the trait bound `NotClone: Clone` is not satisfied\n+trait Tr2\n+where\n+    Self::Ty: Clone,\n+{\n     type Ty = NotClone;\n-}\n-\n-// Independent of where-clauses (there are none here), default types must always be wf\n-trait Tr3 {\n-    type Ty = Vec<[u8]>;\n-    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+    //~^ ERROR the trait bound `NotClone: Clone` is not satisfied\n }\n \n // Involved type parameters must fulfill all bounds required by defaults that mention them\n@@ -43,7 +38,7 @@ trait Bar: Sized {\n trait IsU8<T> {}\n impl<T> IsU8<u8> for T {}\n \n-// Test that mentioning the assoc. type inside where clauses works\n+// Test that mentioning the assoc. type inside where clauses is not allowed\n trait C where\n     Vec<Self::Assoc>: Clone,\n     Self::Assoc: IsU8<Self::Assoc>,\n@@ -55,13 +50,11 @@ trait C where\n // Test that we get all expected errors if that default is unsuitable\n trait D where\n     Vec<Self::Assoc>: Clone,\n-    //~^ ERROR the trait bound `NotClone: Clone` is not satisfied\n     Self::Assoc: IsU8<Self::Assoc>,\n-    //~^ ERROR the trait bound `NotClone: IsU8<NotClone>` is not satisfied\n     bool: IsU8<Self::Assoc>,\n-    //~^ ERROR the trait bound `bool: IsU8<NotClone>` is not satisfied\n {\n     type Assoc = NotClone;\n+    //~^ ERROR the trait bound `NotClone: IsU8<NotClone>` is not satisfied\n }\n \n // Test behavior of the check when defaults refer to other defaults:\n@@ -85,18 +78,20 @@ trait Foo25<T: Clone> {\n \n // Adding the `Baz: Clone` bound isn't enough since the default is type\n // parameter `T`, which also might not be `Clone`.\n-trait Foo3<T> where\n+trait Foo3<T>\n+where\n     Self::Bar: Clone,\n     Self::Baz: Clone,\n-    //~^ ERROR the trait bound `T: Clone` is not satisfied\n {\n     type Bar = Vec<Self::Baz>;\n     type Baz = T;\n+    //~^ ERROR the trait bound `T: Clone` is not satisfied\n }\n \n // This one finally works, with `Clone` bounds on all assoc. types and the type\n // parameter.\n-trait Foo4<T> where\n+trait Foo4<T>\n+where\n     T: Clone,\n {\n     type Bar: Clone = Vec<Self::Baz>;"}, {"sha": "274d09fd09c867baa47ec605af44adc05d68edc1", "filename": "src/test/ui/associated-types/defaults-suitability.stderr", "status": "modified", "additions": 56, "deletions": 94, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-suitability.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,27 +1,32 @@\n error[E0277]: the trait bound `NotClone: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:15:14\n+  --> $DIR/defaults-suitability.rs:13:5\n    |\n-LL | trait Tr {\n-   | -------- required by `Tr`\n LL |     type Ty: Clone = NotClone;\n-   |              ^^^^^ the trait `Clone` is not implemented for `NotClone`\n+   |     ^^^^^^^^^-----^^^^^^^^^^^^\n+   |     |        |\n+   |     |        required by this bound in `Tr::Ty`\n+   |     the trait `Clone` is not implemented for `NotClone`\n \n error[E0277]: the trait bound `NotClone: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:20:27\n-   |\n-LL | trait Tr2 where Self::Ty: Clone {\n-   | --------------------------^^^^^\n-   | |                         |\n-   | |                         the trait `Clone` is not implemented for `NotClone`\n-   | required by `Tr2`\n+  --> $DIR/defaults-suitability.rs:22:5\n+   |\n+LL |     Self::Ty: Clone,\n+   |               ----- required by this bound in `Tr2::Ty`\n+LL | {\n+LL |     type Ty = NotClone;\n+   |     ^^^^^--^^^^^^^^^^^^\n+   |     |    |\n+   |     |    required by a bound in this\n+   |     the trait `Clone` is not implemented for `NotClone`\n \n error[E0277]: the trait bound `T: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:33:15\n+  --> $DIR/defaults-suitability.rs:28:5\n    |\n-LL | trait Foo<T> {\n-   | ------------ required by `Foo`\n LL |     type Bar: Clone = Vec<T>;\n-   |               ^^^^^ the trait `Clone` is not implemented for `T`\n+   |     ^^^^^^^^^^-----^^^^^^^^^^\n+   |     |         |\n+   |     |         required by this bound in `Foo::Bar`\n+   |     the trait `Clone` is not implemented for `T`\n    |\n    = note: required because of the requirements on the impl of `Clone` for `Vec<T>`\n help: consider restricting type parameter `T`\n@@ -30,64 +35,34 @@ LL | trait Foo<T: Clone> {\n    |            ^^^^^^^\n \n error[E0277]: the trait bound `(): Foo<Self>` is not satisfied\n-  --> $DIR/defaults-suitability.rs:39:17\n+  --> $DIR/defaults-suitability.rs:34:5\n    |\n-LL | trait Bar: Sized {\n-   | ---------------- required by `Bar`\n-LL |     // `(): Foo<Self>` might hold for some possible impls but not all.\n LL |     type Assoc: Foo<Self> = ();\n-   |                 ^^^^^^^^^ the trait `Foo<Self>` is not implemented for `()`\n+   |     ^^^^^^^^^^^^---------^^^^^^\n+   |     |           |\n+   |     |           required by this bound in `Bar::Assoc`\n+   |     the trait `Foo<Self>` is not implemented for `()`\n \n error[E0277]: the trait bound `NotClone: IsU8<NotClone>` is not satisfied\n-  --> $DIR/defaults-suitability.rs:59:18\n-   |\n-LL | / trait D where\n-LL | |     Vec<Self::Assoc>: Clone,\n-LL | |\n-LL | |     Self::Assoc: IsU8<Self::Assoc>,\n-   | |                  ^^^^^^^^^^^^^^^^^ the trait `IsU8<NotClone>` is not implemented for `NotClone`\n-...  |\n-LL | |     type Assoc = NotClone;\n-LL | | }\n-   | |_- required by `D`\n-\n-error[E0277]: the trait bound `bool: IsU8<NotClone>` is not satisfied\n-  --> $DIR/defaults-suitability.rs:61:11\n-   |\n-LL | / trait D where\n-LL | |     Vec<Self::Assoc>: Clone,\n-LL | |\n-LL | |     Self::Assoc: IsU8<Self::Assoc>,\n-LL | |\n-LL | |     bool: IsU8<Self::Assoc>,\n-   | |           ^^^^^^^^^^^^^^^^^ the trait `IsU8<NotClone>` is not implemented for `bool`\n-...  |\n-LL | |     type Assoc = NotClone;\n-LL | | }\n-   | |_- required by `D`\n-\n-error[E0277]: the trait bound `NotClone: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:57:23\n-   |\n-LL | / trait D where\n-LL | |     Vec<Self::Assoc>: Clone,\n-   | |                       ^^^^^ the trait `Clone` is not implemented for `NotClone`\n-LL | |\n-LL | |     Self::Assoc: IsU8<Self::Assoc>,\n-...  |\n-LL | |     type Assoc = NotClone;\n-LL | | }\n-   | |_- required by `D`\n-   |\n-   = note: required because of the requirements on the impl of `Clone` for `Vec<NotClone>`\n+  --> $DIR/defaults-suitability.rs:56:5\n+   |\n+LL |     Self::Assoc: IsU8<Self::Assoc>,\n+   |                  ----------------- required by this bound in `D::Assoc`\n+...\n+LL |     type Assoc = NotClone;\n+   |     ^^^^^-----^^^^^^^^^^^^\n+   |     |    |\n+   |     |    required by a bound in this\n+   |     the trait `IsU8<NotClone>` is not implemented for `NotClone`\n \n error[E0277]: the trait bound `<Self as Foo2<T>>::Baz: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:72:15\n+  --> $DIR/defaults-suitability.rs:65:5\n    |\n-LL | trait Foo2<T> {\n-   | ------------- required by `Foo2`\n LL |     type Bar: Clone = Vec<Self::Baz>;\n-   |               ^^^^^ the trait `Clone` is not implemented for `<Self as Foo2<T>>::Baz`\n+   |     ^^^^^^^^^^-----^^^^^^^^^^^^^^^^^^\n+   |     |         |\n+   |     |         required by this bound in `Foo2::Bar`\n+   |     the trait `Clone` is not implemented for `<Self as Foo2<T>>::Baz`\n    |\n    = note: required because of the requirements on the impl of `Clone` for `Vec<<Self as Foo2<T>>::Baz>`\n help: consider further restricting the associated type\n@@ -96,12 +71,13 @@ LL | trait Foo2<T> where <Self as Foo2<T>>::Baz: Clone {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `<Self as Foo25<T>>::Baz: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:81:15\n+  --> $DIR/defaults-suitability.rs:74:5\n    |\n-LL | trait Foo25<T: Clone> {\n-   | --------------------- required by `Foo25`\n LL |     type Bar: Clone = Vec<Self::Baz>;\n-   |               ^^^^^ the trait `Clone` is not implemented for `<Self as Foo25<T>>::Baz`\n+   |     ^^^^^^^^^^-----^^^^^^^^^^^^^^^^^^\n+   |     |         |\n+   |     |         required by this bound in `Foo25::Bar`\n+   |     the trait `Clone` is not implemented for `<Self as Foo25<T>>::Baz`\n    |\n    = note: required because of the requirements on the impl of `Clone` for `Vec<<Self as Foo25<T>>::Baz>`\n help: consider further restricting the associated type\n@@ -110,36 +86,22 @@ LL | trait Foo25<T: Clone> where <Self as Foo25<T>>::Baz: Clone {\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `T: Clone` is not satisfied\n-  --> $DIR/defaults-suitability.rs:90:16\n-   |\n-LL | / trait Foo3<T> where\n-LL | |     Self::Bar: Clone,\n-LL | |     Self::Baz: Clone,\n-   | |                ^^^^^ the trait `Clone` is not implemented for `T`\n-LL | |\n-...  |\n-LL | |     type Baz = T;\n-LL | | }\n-   | |_- required by `Foo3`\n+  --> $DIR/defaults-suitability.rs:87:5\n+   |\n+LL |     Self::Baz: Clone,\n+   |                ----- required by this bound in `Foo3::Baz`\n+...\n+LL |     type Baz = T;\n+   |     ^^^^^---^^^^^\n+   |     |    |\n+   |     |    required by a bound in this\n+   |     the trait `Clone` is not implemented for `T`\n    |\n help: consider further restricting type parameter `T`\n    |\n LL |     Self::Baz: Clone, T: Clone\n    |                     ^^^^^^^^^^\n \n-error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n-  --> $DIR/defaults-suitability.rs:27:5\n-   |\n-LL |     type Ty = Vec<[u8]>;\n-   |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n-   | \n-  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n-   |\n-LL | pub struct Vec<T> {\n-   |                - required by this bound in `Vec`\n-   |\n-   = help: the trait `Sized` is not implemented for `[u8]`\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "fa6a208b4f1baf287ab7e58c27d49b698e70d7a5", "filename": "src/test/ui/associated-types/defaults-unsound-62211-1.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,22 +11,17 @@\n \n use std::{\n     fmt::Display,\n-    ops::{AddAssign, Deref}\n+    ops::{AddAssign, Deref},\n };\n \n-\n trait UncheckedCopy: Sized {\n     // This Output is said to be Copy. Yet we default to Self\n     // and it's accepted, not knowing if Self ineed is Copy\n-    type Output: Copy\n+    type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n     //~^ ERROR the trait bound `Self: Copy` is not satisfied\n-    + Deref<Target = str>\n-    //~^ ERROR the trait bound `Self: Deref` is not satisfied\n-    + AddAssign<&'static str>\n-    //~^ ERROR cannot add-assign `&'static str` to `Self`\n-    + From<Self>\n-    + Display = Self;\n-    //~^ ERROR `Self` doesn't implement `std::fmt::Display`\n+    //~| ERROR the trait bound `Self: Deref` is not satisfied\n+    //~| ERROR cannot add-assign `&'static str` to `Self`\n+    //~| ERROR `Self` doesn't implement `std::fmt::Display`\n \n     // We said the Output type was Copy, so we can Copy it freely!\n     fn unchecked_copy(other: &Self::Output) -> Self::Output {\n@@ -39,10 +34,6 @@ trait UncheckedCopy: Sized {\n }\n \n impl<T> UncheckedCopy for T {}\n-//~^ ERROR `T` doesn't implement `std::fmt::Display`\n-//~| ERROR the trait bound `T: Deref` is not satisfied\n-//~| ERROR cannot add-assign `&'static str` to `T`\n-//~| ERROR the trait bound `T: Copy` is not satisfied\n \n fn bug<T: UncheckedCopy>(origin: T) {\n     let origin = T::make_origin(origin);"}, {"sha": "8e446cf051f477b8092bcf36806805869addb3bd", "filename": "src/test/ui/associated-types/defaults-unsound-62211-1.stderr", "status": "modified", "additions": 36, "deletions": 105, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,129 +1,60 @@\n-error[E0277]: the trait bound `Self: Copy` is not satisfied\n-  --> $DIR/defaults-unsound-62211-1.rs:21:18\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     type Output: Copy\n-   |                  ^^^^ the trait `Copy` is not implemented for `Self`\n-   |\n-help: consider further restricting `Self`\n-   |\n-LL | trait UncheckedCopy: Sized + Copy {\n-   |                            ^^^^^^\n-\n-error[E0277]: cannot add-assign `&'static str` to `Self`\n-  --> $DIR/defaults-unsound-62211-1.rs:25:7\n+error[E0277]: `Self` doesn't implement `std::fmt::Display`\n+  --> $DIR/defaults-unsound-62211-1.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + AddAssign<&'static str>\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Self += &'static str`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------^^^^^^^^\n+   |     |                                                                                |\n+   |     |                                                                                required by this bound in `UncheckedCopy::Output`\n+   |     `Self` cannot be formatted with the default formatter\n    |\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n help: consider further restricting `Self`\n    |\n-LL | trait UncheckedCopy: Sized + AddAssign<&'static str> {\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait UncheckedCopy: Sized + std::fmt::Display {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `Self: Deref` is not satisfied\n-  --> $DIR/defaults-unsound-62211-1.rs:23:7\n+  --> $DIR/defaults-unsound-62211-1.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + Deref<Target = str>\n-   |       ^^^^^^^^^^^^^^^^^^^ the trait `Deref` is not implemented for `Self`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^-------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |                   |\n+   |     |                   required by this bound in `UncheckedCopy::Output`\n+   |     the trait `Deref` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |\n LL | trait UncheckedCopy: Sized + Deref {\n    |                            ^^^^^^^\n \n-error[E0277]: `Self` doesn't implement `std::fmt::Display`\n-  --> $DIR/defaults-unsound-62211-1.rs:28:7\n+error[E0277]: cannot add-assign `&'static str` to `Self`\n+  --> $DIR/defaults-unsound-62211-1.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + Display = Self;\n-   |       ^^^^^^^ `Self` cannot be formatted with the default formatter\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |                                         |\n+   |     |                                         required by this bound in `UncheckedCopy::Output`\n+   |     no implementation for `Self += &'static str`\n    |\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n help: consider further restricting `Self`\n    |\n-LL | trait UncheckedCopy: Sized + std::fmt::Display {\n-   |                            ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: `T` doesn't implement `std::fmt::Display`\n-  --> $DIR/defaults-unsound-62211-1.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + Display = Self;\n-   |       ------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ `T` cannot be formatted with the default formatter\n-   |\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: std::fmt::Display> UncheckedCopy for T {}\n-   |       ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `T: Deref` is not satisfied\n-  --> $DIR/defaults-unsound-62211-1.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + Deref<Target = str>\n-   |       ------------------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ the trait `Deref` is not implemented for `T`\n-   |\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: Deref> UncheckedCopy for T {}\n-   |       ^^^^^^^\n-\n-error[E0277]: cannot add-assign `&'static str` to `T`\n-  --> $DIR/defaults-unsound-62211-1.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + AddAssign<&'static str>\n-   |       ----------------------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ no implementation for `T += &'static str`\n-   |\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: AddAssign<&'static str>> UncheckedCopy for T {}\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait UncheckedCopy: Sized + AddAssign<&'static str> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/defaults-unsound-62211-1.rs:41:9\n+error[E0277]: the trait bound `Self: Copy` is not satisfied\n+  --> $DIR/defaults-unsound-62211-1.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     type Output: Copy\n-   |                  ---- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |            |\n+   |     |            required by this bound in `UncheckedCopy::Output`\n+   |     the trait `Copy` is not implemented for `Self`\n    |\n-help: consider restricting type parameter `T`\n+help: consider further restricting `Self`\n    |\n-LL | impl<T: Copy> UncheckedCopy for T {}\n-   |       ^^^^^^\n+LL | trait UncheckedCopy: Sized + Copy {\n+   |                            ^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "c13ec776afe2bd15b79f6267900770e1f8556d29", "filename": "src/test/ui/associated-types/defaults-unsound-62211-2.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,22 +11,17 @@\n \n use std::{\n     fmt::Display,\n-    ops::{AddAssign, Deref}\n+    ops::{AddAssign, Deref},\n };\n \n-\n trait UncheckedCopy: Sized {\n     // This Output is said to be Copy. Yet we default to Self\n     // and it's accepted, not knowing if Self ineed is Copy\n-    type Output: Copy\n+    type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n     //~^ ERROR the trait bound `Self: Copy` is not satisfied\n-    + Deref<Target = str>\n-    //~^ ERROR the trait bound `Self: Deref` is not satisfied\n-    + AddAssign<&'static str>\n-    //~^ ERROR cannot add-assign `&'static str` to `Self`\n-    + From<Self>\n-    + Display = Self;\n-    //~^ ERROR `Self` doesn't implement `std::fmt::Display`\n+    //~| ERROR the trait bound `Self: Deref` is not satisfied\n+    //~| ERROR cannot add-assign `&'static str` to `Self`\n+    //~| ERROR `Self` doesn't implement `std::fmt::Display`\n \n     // We said the Output type was Copy, so we can Copy it freely!\n     fn unchecked_copy(other: &Self::Output) -> Self::Output {\n@@ -39,10 +34,6 @@ trait UncheckedCopy: Sized {\n }\n \n impl<T> UncheckedCopy for T {}\n-//~^ ERROR `T` doesn't implement `std::fmt::Display`\n-//~| ERROR the trait bound `T: Deref` is not satisfied\n-//~| ERROR cannot add-assign `&'static str` to `T`\n-//~| ERROR the trait bound `T: Copy` is not satisfied\n \n fn bug<T: UncheckedCopy>(origin: T) {\n     let origin = T::make_origin(origin);"}, {"sha": "93f4f497b38a2cf4ebbf3c9bbebb716d29ea71c8", "filename": "src/test/ui/associated-types/defaults-unsound-62211-2.stderr", "status": "modified", "additions": 36, "deletions": 105, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-unsound-62211-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,129 +1,60 @@\n-error[E0277]: the trait bound `Self: Copy` is not satisfied\n-  --> $DIR/defaults-unsound-62211-2.rs:21:18\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     type Output: Copy\n-   |                  ^^^^ the trait `Copy` is not implemented for `Self`\n-   |\n-help: consider further restricting `Self`\n-   |\n-LL | trait UncheckedCopy: Sized + Copy {\n-   |                            ^^^^^^\n-\n-error[E0277]: cannot add-assign `&'static str` to `Self`\n-  --> $DIR/defaults-unsound-62211-2.rs:25:7\n+error[E0277]: `Self` doesn't implement `std::fmt::Display`\n+  --> $DIR/defaults-unsound-62211-2.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + AddAssign<&'static str>\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `Self += &'static str`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-------^^^^^^^^\n+   |     |                                                                                |\n+   |     |                                                                                required by this bound in `UncheckedCopy::Output`\n+   |     `Self` cannot be formatted with the default formatter\n    |\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n help: consider further restricting `Self`\n    |\n-LL | trait UncheckedCopy: Sized + AddAssign<&'static str> {\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait UncheckedCopy: Sized + std::fmt::Display {\n+   |                            ^^^^^^^^^^^^^^^^^^^\n \n error[E0277]: the trait bound `Self: Deref` is not satisfied\n-  --> $DIR/defaults-unsound-62211-2.rs:23:7\n+  --> $DIR/defaults-unsound-62211-2.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + Deref<Target = str>\n-   |       ^^^^^^^^^^^^^^^^^^^ the trait `Deref` is not implemented for `Self`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^-------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |                   |\n+   |     |                   required by this bound in `UncheckedCopy::Output`\n+   |     the trait `Deref` is not implemented for `Self`\n    |\n help: consider further restricting `Self`\n    |\n LL | trait UncheckedCopy: Sized + Deref {\n    |                            ^^^^^^^\n \n-error[E0277]: `Self` doesn't implement `std::fmt::Display`\n-  --> $DIR/defaults-unsound-62211-2.rs:28:7\n+error[E0277]: cannot add-assign `&'static str` to `Self`\n+  --> $DIR/defaults-unsound-62211-2.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   | -------------------------- required by `UncheckedCopy`\n-...\n-LL |     + Display = Self;\n-   |       ^^^^^^^ `Self` cannot be formatted with the default formatter\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-----------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |                                         |\n+   |     |                                         required by this bound in `UncheckedCopy::Output`\n+   |     no implementation for `Self += &'static str`\n    |\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n help: consider further restricting `Self`\n    |\n-LL | trait UncheckedCopy: Sized + std::fmt::Display {\n-   |                            ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: `T` doesn't implement `std::fmt::Display`\n-  --> $DIR/defaults-unsound-62211-2.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + Display = Self;\n-   |       ------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ `T` cannot be formatted with the default formatter\n-   |\n-   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: std::fmt::Display> UncheckedCopy for T {}\n-   |       ^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `T: Deref` is not satisfied\n-  --> $DIR/defaults-unsound-62211-2.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + Deref<Target = str>\n-   |       ------------------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ the trait `Deref` is not implemented for `T`\n-   |\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: Deref> UncheckedCopy for T {}\n-   |       ^^^^^^^\n-\n-error[E0277]: cannot add-assign `&'static str` to `T`\n-  --> $DIR/defaults-unsound-62211-2.rs:41:9\n-   |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     + AddAssign<&'static str>\n-   |       ----------------------- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ no implementation for `T += &'static str`\n-   |\n-help: consider restricting type parameter `T`\n-   |\n-LL | impl<T: AddAssign<&'static str>> UncheckedCopy for T {}\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | trait UncheckedCopy: Sized + AddAssign<&'static str> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/defaults-unsound-62211-2.rs:41:9\n+error[E0277]: the trait bound `Self: Copy` is not satisfied\n+  --> $DIR/defaults-unsound-62211-2.rs:20:5\n    |\n-LL | trait UncheckedCopy: Sized {\n-   |       ------------- required by a bound in this\n-...\n-LL |     type Output: Copy\n-   |                  ---- required by this bound in `UncheckedCopy`\n-...\n-LL | impl<T> UncheckedCopy for T {}\n-   |         ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+LL |     type Output: Copy + Deref<Target = str> + AddAssign<&'static str> + From<Self> + Display = Self;\n+   |     ^^^^^^^^^^^^^----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |            |\n+   |     |            required by this bound in `UncheckedCopy::Output`\n+   |     the trait `Copy` is not implemented for `Self`\n    |\n-help: consider restricting type parameter `T`\n+help: consider further restricting `Self`\n    |\n-LL | impl<T: Copy> UncheckedCopy for T {}\n-   |       ^^^^^^\n+LL | trait UncheckedCopy: Sized + Copy {\n+   |                            ^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "99b512503346598df58a334ccf7128a3926460bc", "filename": "src/test/ui/associated-types/defaults-wf.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,11 @@\n+// Check that associated type defaults are wf checked.\n+\n+#![feature(associated_type_defaults)]\n+\n+// Default types must always be wf\n+trait Tr3 {\n+    type Ty = Vec<[u8]>;\n+    //~^ ERROR the size for values of type `[u8]` cannot be known at compilation time\n+}\n+\n+fn main() {}"}, {"sha": "f9044c2ea1b6658a26f3c3b1a20c0d269f1218ae", "filename": "src/test/ui/associated-types/defaults-wf.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-wf.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/defaults-wf.rs:7:5\n+   |\n+LL |     type Ty = Vec<[u8]>;\n+   |     ^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/alloc/src/vec.rs:LL:COL\n+   |\n+LL | pub struct Vec<T> {\n+   |                - required by this bound in `Vec`\n+   |\n+   = help: the trait `Sized` is not implemented for `[u8]`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b0e9e33a6c38ecffeda0cbef786f32659c24878f", "filename": "src/test/ui/associated-types/impl-trait-return-missing-constraint.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fimpl-trait-return-missing-constraint.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,7 +9,6 @@ LL | fn baz() -> impl Bar<Item = i32> {\n    |\n    = note: expected associated type `<impl Bar as Foo>::Item`\n                          found type `i32`\n-   = note: the return type of a function must have a statically known size\n help: consider constraining the associated type `<impl Bar as Foo>::Item` to `i32`\n    |\n LL | fn bar() -> impl Bar<Item = i32> {"}, {"sha": "6a63b3e0936742df7ba2e727c15b1ec2442e463f", "filename": "src/test/ui/associated-types/issue-43924.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -4,12 +4,13 @@\n // type-checked.\n \n trait Foo<T: Default + ToString> {\n-    type Out: Default + ToString + ?Sized = dyn ToString;  //~ error: not satisfied\n+    type Out: Default + ToString + ?Sized = dyn ToString;  //~ ERROR not satisfied\n }\n \n-impl Foo<u32> for () {}  //~ error: not satisfied\n-impl Foo<u64> for () {}  //~ error: not satisfied\n+impl Foo<u32> for () {}\n+impl Foo<u64> for () {}\n \n fn main() {\n     assert_eq!(<() as Foo<u32>>::Out::default().to_string(), \"false\");\n+    //~^ ERROR no function or associated item named `default` found for trait object\n }"}, {"sha": "8d4ecac750268f82f31b1e8f1403037d0ea0d549", "filename": "src/test/ui/associated-types/issue-43924.stderr", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-43924.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,33 +1,19 @@\n error[E0277]: the trait bound `(dyn ToString + 'static): Default` is not satisfied\n-  --> $DIR/issue-43924.rs:7:15\n+  --> $DIR/issue-43924.rs:7:5\n    |\n-LL | trait Foo<T: Default + ToString> {\n-   | -------------------------------- required by `Foo`\n LL |     type Out: Default + ToString + ?Sized = dyn ToString;\n-   |               ^^^^^^^ the trait `Default` is not implemented for `(dyn ToString + 'static)`\n+   |     ^^^^^^^^^^-------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |         |\n+   |     |         required by this bound in `Foo::Out`\n+   |     the trait `Default` is not implemented for `(dyn ToString + 'static)`\n \n-error[E0277]: the trait bound `(dyn ToString + 'static): Default` is not satisfied\n-  --> $DIR/issue-43924.rs:10:6\n-   |\n-LL | trait Foo<T: Default + ToString> {\n-   |       --- required by a bound in this\n-LL |     type Out: Default + ToString + ?Sized = dyn ToString;\n-   |               ------- required by this bound in `Foo`\n-...\n-LL | impl Foo<u32> for () {}\n-   |      ^^^^^^^^ the trait `Default` is not implemented for `(dyn ToString + 'static)`\n-\n-error[E0277]: the trait bound `(dyn ToString + 'static): Default` is not satisfied\n-  --> $DIR/issue-43924.rs:11:6\n+error[E0599]: no function or associated item named `default` found for trait object `(dyn ToString + 'static)` in the current scope\n+  --> $DIR/issue-43924.rs:14:39\n    |\n-LL | trait Foo<T: Default + ToString> {\n-   |       --- required by a bound in this\n-LL |     type Out: Default + ToString + ?Sized = dyn ToString;\n-   |               ------- required by this bound in `Foo`\n-...\n-LL | impl Foo<u64> for () {}\n-   |      ^^^^^^^^ the trait `Default` is not implemented for `(dyn ToString + 'static)`\n+LL |     assert_eq!(<() as Foo<u32>>::Out::default().to_string(), \"false\");\n+   |                                       ^^^^^^^ function or associated item not found in `(dyn ToString + 'static)`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0277`.\n+Some errors have detailed explanations: E0277, E0599.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "16ae07687e2c7f355dbd56a02d022201e08db5b8", "filename": "src/test/ui/associated-types/issue-63593.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-63593.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the size for values of type `Self` cannot be known at compilation time\n   --> $DIR/issue-63593.rs:9:5\n    |\n-LL | trait MyTrait {\n-   | ------------- required by `MyTrait`\n LL |     type This = Self;\n-   |     ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |     ^^^^^^^^^^^^^^^^^\n+   |     |\n+   |     doesn't have a size known at compile-time\n+   |     required by this bound in `MyTrait::This`\n    |\n help: consider further restricting `Self`\n    |"}, {"sha": "9345140558b079ba036890db7dea14cf5bdb7b21", "filename": "src/test/ui/associated-types/issue-65774-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,7 +14,6 @@ trait MPU {\n struct S;\n \n impl MPU for S { }\n-//~^ ERROR the trait bound `T: MyDisplay` is not satisfied\n \n trait MyWrite {\n     fn my_write(&self, _: &dyn MyDisplay) { }\n@@ -43,6 +42,7 @@ impl ProcessType for Process {\n         // FulfillmentError(Obligation(predicate=Binder(TraitPredicate(<T as MyDisplay>)),\n         // depth=1),Unimplemented)\n         let closure = |config: &mut <S as MPU>::MpuConfig| writer.my_write(&config);\n+        //~^ ERROR the trait bound `T: MyDisplay` is not satisfied\n         closure(valref);\n     }\n }"}, {"sha": "f644eb5a1f47887b8060e5957ca4e674918605cf", "filename": "src/test/ui/associated-types/issue-65774-1.stderr", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,21 +1,20 @@\n error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n-  --> $DIR/issue-65774-1.rs:10:21\n+  --> $DIR/issue-65774-1.rs:10:5\n    |\n-LL | trait MPU {\n-   | --------- required by `MPU`\n LL |     type MpuConfig: MyDisplay = T;\n-   |                     ^^^^^^^^^ the trait `MyDisplay` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^^---------^^^^^\n+   |     |               |\n+   |     |               required by this bound in `MPU::MpuConfig`\n+   |     the trait `MyDisplay` is not implemented for `T`\n \n error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n-  --> $DIR/issue-65774-1.rs:16:6\n+  --> $DIR/issue-65774-1.rs:44:76\n    |\n-LL | trait MPU {\n-   |       --- required by a bound in this\n-LL |     type MpuConfig: MyDisplay = T;\n-   |                     --------- required by this bound in `MPU`\n-...\n-LL | impl MPU for S { }\n-   |      ^^^ the trait `MyDisplay` is not implemented for `T`\n+LL |         let closure = |config: &mut <S as MPU>::MpuConfig| writer.my_write(&config);\n+   |                                                                            ^^^^^^^ the trait `MyDisplay` is not implemented for `T`\n+   |\n+   = note: required because of the requirements on the impl of `MyDisplay` for `&mut T`\n+   = note: required for the cast to the object type `dyn MyDisplay`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "171e0893b4719a570837dd78c84e672595a04154", "filename": "src/test/ui/associated-types/issue-65774-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,7 +14,6 @@ trait MPU {\n struct S;\n \n impl MPU for S { }\n-//~^ ERROR the trait bound `T: MyDisplay` is not satisfied\n \n trait MyWrite {\n     fn my_write(&self, _: &dyn MyDisplay) { }\n@@ -38,6 +37,7 @@ impl ProcessType for Process {\n         // // `Unimplemented` selecting `Binder(<T as MyDisplay>)` during codegen\n         //\n         writer.my_write(valref)\n+        //~^ ERROR the trait bound `T: MyDisplay` is not satisfied\n \n         // This one causes the ICE:\n         // FulfillmentError(Obligation(predicate=Binder(TraitPredicate(<T as MyDisplay>)),"}, {"sha": "572a9cf190952116463f1a238d6822e52c5442f9", "filename": "src/test/ui/associated-types/issue-65774-2.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,21 +1,19 @@\n error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n-  --> $DIR/issue-65774-2.rs:10:21\n+  --> $DIR/issue-65774-2.rs:10:5\n    |\n-LL | trait MPU {\n-   | --------- required by `MPU`\n LL |     type MpuConfig: MyDisplay = T;\n-   |                     ^^^^^^^^^ the trait `MyDisplay` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^^---------^^^^^\n+   |     |               |\n+   |     |               required by this bound in `MPU::MpuConfig`\n+   |     the trait `MyDisplay` is not implemented for `T`\n \n error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n-  --> $DIR/issue-65774-2.rs:16:6\n+  --> $DIR/issue-65774-2.rs:39:25\n    |\n-LL | trait MPU {\n-   |       --- required by a bound in this\n-LL |     type MpuConfig: MyDisplay = T;\n-   |                     --------- required by this bound in `MPU`\n-...\n-LL | impl MPU for S { }\n-   |      ^^^ the trait `MyDisplay` is not implemented for `T`\n+LL |         writer.my_write(valref)\n+   |                         ^^^^^^ the trait `MyDisplay` is not implemented for `T`\n+   |\n+   = note: required for the cast to the object type `dyn MyDisplay`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "94758250346d12329b81c0674d8115ec555a8d0c", "filename": "src/test/ui/associated-types/issue-72806.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,9 +9,10 @@ trait Bar2 {\n struct Foo;\n struct Foo2;\n \n-impl Bar for Foo {  //~ ERROR type mismatch resolving `<Foo2 as Bar2>::Ok == char`\n+impl Bar for Foo {\n     type Ok = ();\n     type Sibling = Foo2;\n+    //~^ ERROR type mismatch resolving `<Foo2 as Bar2>::Ok == char`\n }\n impl Bar2 for Foo2 {\n     type Ok = u32;"}, {"sha": "23fabbee1c5d4ba181d4c8465b7ccb46364f0d2e", "filename": "src/test/ui/associated-types/issue-72806.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-72806.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,11 @@\n error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == char`\n-  --> $DIR/issue-72806.rs:12:6\n+  --> $DIR/issue-72806.rs:14:5\n    |\n-LL | impl Bar for Foo {\n-   |      ^^^ expected `u32`, found `char`\n+LL |     type Sibling: Bar2<Ok=char>;\n+   |                        ------- required by this bound in `Bar::Sibling`\n+...\n+LL |     type Sibling = Foo2;\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected `char`, found `u32`\n \n error: aborting due to previous error\n "}, {"sha": "1f93248e10ec475416d45034720c235ab8fec85c", "filename": "src/test/ui/associated-types/object-normalization.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fobject-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fobject-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fobject-normalization.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+\n+// Check that we normalize super predicates for object candidates.\n+\n+// check-pass\n+\n+use std::ops::Index;\n+\n+fn next<'a, T>(s: &'a mut dyn SVec<Item = T, Output = T>) {\n+    // To prove\n+    // `dyn SVec<Item = T, Output = T>: SVec`\n+    // we need to show\n+    // `dyn SVec<Item = T, Output = T> as Index>::Output == <dyn SVec<Item = T, Output = T> as SVec>::Item`\n+    // which, with the current normalization strategy, has to be eagerly\n+    // normalized to:\n+    // `dyn SVec<Item = T, Output = T> as Index>::Output == T`.\n+    let _ = s.len();\n+}\n+\n+trait SVec: Index<usize, Output = <Self as SVec>::Item> {\n+    type Item;\n+\n+    fn len(&self) -> usize;\n+}\n+\n+fn main() {}"}, {"sha": "12db595ed2572aafc6ad548cb0777df1886c8dd4", "filename": "src/test/ui/associated-types/param-env-normalize-cycle.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fparam-env-normalize-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fparam-env-normalize-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fparam-env-normalize-cycle.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,39 @@\n+// Minimized case from typenum that didn't compile because:\n+// - We tried to normalize the ParamEnv of the second impl\n+// - This requires trying to normalize `GrEq<Self, Square<Square<U>>>`\n+// - This requires proving `Square<Square<U>>: Sized` so that the first impl\n+//   applies\n+// - This requires Providing `Square<Square<U>>` is well-formed, so that we\n+//   can use the `Sized` bound on `Mul::Output`\n+// - This requires proving `Square<U>: Mul`\n+// - But first we tried normalizing the whole obligation, including the\n+//   ParamEnv, which leads to a cycle error.\n+\n+// check-pass\n+\n+trait PrivateSquareRoot {}\n+\n+pub trait Mul<Rhs = Self> {\n+    type Output;\n+}\n+\n+pub trait IsGreaterOrEqual<Rhs> {\n+    type Output;\n+}\n+\n+pub type Square<A> = <A as Mul>::Output;\n+pub type GrEq<A, B> = <A as IsGreaterOrEqual<B>>::Output;\n+\n+impl<A, B> IsGreaterOrEqual<B> for A {\n+    type Output = ();\n+}\n+\n+impl<U> PrivateSquareRoot for U\n+where\n+    U: Mul,\n+    Square<U>: Mul,\n+    GrEq<Self, Square<Square<U>>>: Sized,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "4b3d6e9d6067f1a5842e54b026996656c44647f8", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,15 +8,21 @@ impl Foo for () {\n     type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n }\n \n-trait Baz where Self::Assoc: Bar {\n+trait Baz\n+where\n+    Self::Assoc: Bar,\n+{\n     type Assoc;\n }\n \n impl Baz for () {\n     type Assoc = bool; //~ ERROR the trait bound `bool: Bar` is not satisfied\n }\n \n-trait Bat where <Self as Bat>::Assoc: Bar {\n+trait Bat\n+where\n+    <Self as Bat>::Assoc: Bar,\n+{\n     type Assoc;\n }\n "}, {"sha": "b23030d7cb52b37b59bbb60e412328ab5cd6e736", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure-2.stderr", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,31 +1,35 @@\n error[E0277]: the trait bound `bool: Bar` is not satisfied\n-  --> $DIR/point-at-type-on-obligation-failure-2.rs:8:18\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:8:5\n    |\n-LL | trait Foo {\n-   |       --- required by a bound in this\n LL |     type Assoc: Bar;\n-   |                 --- required by this bound in `Foo`\n+   |                 --- required by this bound in `Foo::Assoc`\n ...\n LL |     type Assoc = bool;\n-   |                  ^^^^ the trait `Bar` is not implemented for `bool`\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n \n error[E0277]: the trait bound `bool: Bar` is not satisfied\n-  --> $DIR/point-at-type-on-obligation-failure-2.rs:16:18\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:19:5\n    |\n-LL | trait Baz where Self::Assoc: Bar {\n-   |                              --- required by this bound in `Baz`\n+LL |     Self::Assoc: Bar,\n+   |                  --- required by this bound in `Baz::Assoc`\n+LL | {\n+LL |     type Assoc;\n+   |          ----- required by a bound in this\n ...\n LL |     type Assoc = bool;\n-   |                  ^^^^ the trait `Bar` is not implemented for `bool`\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n \n error[E0277]: the trait bound `bool: Bar` is not satisfied\n-  --> $DIR/point-at-type-on-obligation-failure-2.rs:24:18\n+  --> $DIR/point-at-type-on-obligation-failure-2.rs:30:5\n    |\n-LL | trait Bat where <Self as Bat>::Assoc: Bar {\n-   |                                       --- required by this bound in `Bat`\n+LL |     <Self as Bat>::Assoc: Bar,\n+   |                           --- required by this bound in `Bat::Assoc`\n+LL | {\n+LL |     type Assoc;\n+   |          ----- required by a bound in this\n ...\n LL |     type Assoc = bool;\n-   |                  ^^^^ the trait `Bar` is not implemented for `bool`\n+   |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "66666006887e6b2a84b82c54775efc1d3ddd6c11", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,8 +10,9 @@ struct Foo;\n struct Foo2;\n \n impl Bar for Foo {\n-    type Ok = ();  //~ ERROR type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n+    type Ok = ();\n     type Sibling = Foo2;\n+    //~^ ERROR type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n }\n impl Bar2 for Foo2 {\n     type Ok = u32;"}, {"sha": "7417a5aa3d43a4adeeb4540891901d532ad22680", "filename": "src/test/ui/associated-types/point-at-type-on-obligation-failure.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fpoint-at-type-on-obligation-failure.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,11 @@\n error[E0271]: type mismatch resolving `<Foo2 as Bar2>::Ok == ()`\n-  --> $DIR/point-at-type-on-obligation-failure.rs:13:15\n+  --> $DIR/point-at-type-on-obligation-failure.rs:14:5\n    |\n-LL |     type Ok = ();\n-   |               ^^ expected `u32`, found `()`\n+LL |     type Sibling: Bar2<Ok=Self::Ok>;\n+   |                        ----------- required by this bound in `Bar::Sibling`\n+...\n+LL |     type Sibling = Foo2;\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected `()`, found `u32`\n \n error: aborting due to previous error\n "}, {"sha": "d7467ac22371f53bcc4fbcc2127a89ddb5286be6", "filename": "src/test/ui/associated-types/wf-cycle-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+trait IntoIt {\n+    type Item;\n+}\n+\n+impl<I> IntoIt for I {\n+    type Item = ();\n+}\n+\n+trait BaseGraph\n+where\n+    <Self::VertexIter as IntoIt>::Item: Sized,\n+{\n+    type VertexIter: IntoIt;\n+}\n+\n+fn main() {}"}, {"sha": "cf6508551a558a10de11bf031150cb1f6476f35a", "filename": "src/test/ui/associated-types/wf-cycle.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fwf-cycle.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+trait A {\n+    type U: Copy;\n+}\n+\n+trait B where\n+    <Self::V as A>::U: Copy,\n+{\n+    type V: A;\n+}\n+\n+fn main() {}"}, {"sha": "994bfd33ba42e37d2137b6035a29dee7cff67100", "filename": "src/test/ui/async-await/async-error-span.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-error-span.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,12 +3,8 @@ error[E0277]: `()` is not a future\n    |\n LL | fn get_future() -> impl Future<Output = ()> {\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not a future\n-LL |\n-LL |     panic!()\n-   |     -------- this returned value is of type `!`\n    |\n    = help: the trait `Future` is not implemented for `()`\n-   = note: the return type of a function must have a statically known size\n \n error[E0698]: type inside `async fn` body must be known in this context\n   --> $DIR/async-error-span.rs:13:9"}, {"sha": "88ea7251eaf1f8f5edc55de827ad3ab49e015a57", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -27,33 +27,18 @@ error[E0609]: no field `0` on type `impl Future`\n    |\n LL |     let _: i32 = tuple().0;\n    |                          ^\n-   |\n-help: consider awaiting before field access\n-   |\n-LL |     let _: i32 = tuple().await.0;\n-   |                         ^^^^^^\n \n error[E0609]: no field `a` on type `impl Future`\n   --> $DIR/issue-61076.rs:60:28\n    |\n LL |     let _: i32 = struct_().a;\n    |                            ^\n-   |\n-help: consider awaiting before field access\n-   |\n-LL |     let _: i32 = struct_().await.a;\n-   |                           ^^^^^^\n \n error[E0599]: no method named `method` found for opaque type `impl Future` in the current scope\n   --> $DIR/issue-61076.rs:62:15\n    |\n LL |     struct_().method();\n    |               ^^^^^^ method not found in `impl Future`\n-   |\n-help: consider awaiting before this method call\n-   |\n-LL |     struct_().await.method();\n-   |               ^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-61076.rs:69:9\n@@ -66,10 +51,6 @@ LL |         Tuple(_) => {}\n    |\n    = note: expected opaque type `impl Future`\n                    found struct `Tuple`\n-help: consider awaiting on the future\n-   |\n-LL |     match tuple().await {\n-   |                  ^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2d46dfb7269d1f93d3582e49e5ceeb556a5327a8", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,17 +1,8 @@\n error: future cannot be sent between threads safely\n   --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n-LL |   pub fn foo() -> impl Future + Send {\n-   |                   ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n-...\n-LL | /     async move {\n-LL | |         match client.status() {\n-LL | |             200 => {\n-LL | |                 let _x = get().await;\n-...  |\n-LL | |         }\n-LL | |     }\n-   | |_____- this returned value is of type `impl Future`\n+LL | pub fn foo() -> impl Future + Send {\n+   |                 ^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n    |\n    = help: the trait `Sync` is not implemented for `(dyn Any + Send + 'static)`\n note: future is not `Send` as this value is used across an await\n@@ -30,7 +21,6 @@ help: consider moving this into a `let` binding to create a shorter lived borrow\n    |\n LL |         match client.status() {\n    |               ^^^^^^^^^^^^^^^\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "832b736ad86424112888bff610d11007ab97c253", "filename": "src/test/ui/async-await/issue-67765-async-diagnostic.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-67765-async-diagnostic.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,11 @@\n error[E0515]: cannot return value referencing local variable `s`\n-  --> $DIR/issue-67765-async-diagnostic.rs:13:11\n+  --> $DIR/issue-67765-async-diagnostic.rs:13:5\n    |\n LL |     let b = &s[..];\n    |              - `s` is borrowed here\n LL | \n LL |     Err(b)?;\n-   |           ^ returns a value referencing data owned by the current function\n+   |     ^^^^^^^ returns a value referencing data owned by the current function\n \n error: aborting due to previous error\n "}, {"sha": "11fca2dd8ef4c53d464bcaa40a0259540c751b15", "filename": "src/test/ui/async-await/issue-70818.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70818.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,16 +3,12 @@ error: future cannot be sent between threads safely\n    |\n LL | fn foo<T: Send, U>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ future created by async block is not `Send`\n-LL |\n-LL |     async { (ty, ty1) }\n-   |     ------------------- this returned value is of type `impl Future`\n    |\n note: captured value is not `Send`\n   --> $DIR/issue-70818.rs:6:18\n    |\n LL |     async { (ty, ty1) }\n    |                  ^^^ has type `U` which is not `Send`\n-   = note: the return type of a function must have a statically known size\n help: consider restricting type parameter `U`\n    |\n LL | fn foo<T: Send, U: Send>(ty: T, ty1: U) -> impl Future<Output = (T, U)> + Send {"}, {"sha": "66f57c2d11009fe1a2d4ea82520b5968b88a326e", "filename": "src/test/ui/chalkify/impl_wf.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -15,19 +15,6 @@ impl Foo for str { }\n // Implicit `T: Sized` bound.\n impl<T> Foo for Option<T> { }\n \n-impl Bar for () {\n-    type Item = i32;\n-}\n-\n-impl<T> Bar for Option<T> {\n-    type Item = Option<T>;\n-}\n-\n-impl Bar for f32 {\n-    type Item = f32;\n-    //~^ ERROR the trait bound `f32: Foo` is not satisfied\n-}\n-\n trait Baz<U: ?Sized> where U: Foo { }\n \n impl Baz<i32> for i32 { }"}, {"sha": "24c7f0d82bdc8b4a3d40553f6b4728967303bb7d", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,25 +10,14 @@ LL | impl Foo for str { }\n    = help: the trait `Sized` is not implemented for `str`\n \n error[E0277]: the trait bound `f32: Foo` is not satisfied\n-  --> $DIR/impl_wf.rs:27:17\n-   |\n-LL | trait Bar {\n-   |       --- required by a bound in this\n-LL |     type Item: Foo;\n-   |                --- required by this bound in `Bar`\n-...\n-LL |     type Item = f32;\n-   |                 ^^^ the trait `Foo` is not implemented for `f32`\n-\n-error[E0277]: the trait bound `f32: Foo` is not satisfied\n-  --> $DIR/impl_wf.rs:35:6\n+  --> $DIR/impl_wf.rs:22:6\n    |\n LL | trait Baz<U: ?Sized> where U: Foo { }\n    |                               --- required by this bound in `Baz`\n ...\n LL | impl Baz<f32> for f32 { }\n    |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "758a7185e3912aac602c4363de7c6ee4b72c6363", "filename": "src/test/ui/chalkify/impl_wf_2.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,33 @@\n+// Split out of impl_wf.rs to work around rust aborting compilation early\n+\n+// compile-flags: -Z chalk\n+\n+trait Foo: Sized { }\n+\n+trait Bar {\n+    type Item: Foo;\n+}\n+\n+impl Foo for i32 { }\n+\n+// Implicit `T: Sized` bound.\n+impl<T> Foo for Option<T> { }\n+\n+impl Bar for () {\n+    type Item = i32;\n+}\n+\n+impl<T> Bar for Option<T> {\n+    type Item = Option<T>;\n+}\n+\n+impl Bar for f32 {\n+    type Item = f32;\n+    //~^ ERROR the trait bound `f32: Foo` is not satisfied\n+}\n+\n+trait Baz<U: ?Sized> where U: Foo { }\n+\n+impl Baz<i32> for i32 { }\n+\n+fn main() {}"}, {"sha": "1da2144c0a5d444f16a3f23a316d52f71f4362cc", "filename": "src/test/ui/chalkify/impl_wf_2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `f32: Foo` is not satisfied\n+  --> $DIR/impl_wf_2.rs:25:5\n+   |\n+LL |     type Item: Foo;\n+   |                --- required by this bound in `Bar::Item`\n+...\n+LL |     type Item = f32;\n+   |     ^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `f32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "909c33f642d31f581e7fafb31ac18b0d04a3293b", "filename": "src/test/ui/closures/issue-41366.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,4 +9,5 @@ impl<'g> T<'g> for u32 {\n fn main() {\n     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n     //~^ ERROR: type mismatch in closure arguments\n+    //~| ERROR: size for values of type `<u32 as T<'_>>::V` cannot be known at compilation time\n }"}, {"sha": "200d411b51194d0f6796f5b6edac73954f4958f4", "filename": "src/test/ui/closures/issue-41366.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-41366.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,6 +9,24 @@ LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n    |\n    = note: required for the cast to the object type `dyn for<'x> Fn(<u32 as T<'x>>::V)`\n \n-error: aborting due to previous error\n+error[E0277]: the size for values of type `<u32 as T<'_>>::V` cannot be known at compilation time\n+  --> $DIR/issue-41366.rs:10:8\n+   |\n+LL |     (&|_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |        ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `Sized` is not implemented for `<u32 as T<'_>>::V`\n+   = help: unsized locals are gated as an unstable feature\n+help: consider further restricting the associated type\n+   |\n+LL | fn main() where <u32 as T<'_>>::V: Sized {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: function arguments must have a statically known size, borrowed types always have a known size\n+   |\n+LL |     (&|&_| ()) as &dyn for<'x> Fn(<u32 as T<'x>>::V);\n+   |        ^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0631`.\n+Some errors have detailed explanations: E0277, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "63a4df242f85f9897247a8b24d4101dd16eaeb35", "filename": "src/test/ui/conservative_impl_trait.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconservative_impl_trait.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,7 +5,6 @@ LL | fn will_ice(something: &u32) -> impl Iterator<Item = &u32> {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ `()` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `()`\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "38be85ff8201ed77a5840269e0acacd6ef558284", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,6 +14,7 @@ impl Tr1 for S1 { type As1 = S2; }\n trait _Tr3 {\n     type A: Iterator<Item: Copy>;\n     //~^ ERROR associated type bounds are unstable\n+    //~| ERROR the trait bound `<<Self as _Tr3>::A as Iterator>::Item: Copy` is not satisfied\n \n     type B: Iterator<Item: 'static>;\n     //~^ ERROR associated type bounds are unstable"}, {"sha": "be5d35139b65c7db978aa46e1301d24f32071d65", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.stderr", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,7 +8,7 @@ LL |     type A: Iterator<Item: Copy>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:18:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:19:22\n    |\n LL |     type B: Iterator<Item: 'static>;\n    |                      ^^^^^^^^^^^^^\n@@ -17,7 +17,7 @@ LL |     type B: Iterator<Item: 'static>;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:22:20\n+  --> $DIR/feature-gate-associated_type_bounds.rs:23:20\n    |\n LL | struct _St1<T: Tr1<As1: Tr2>> {\n    |                    ^^^^^^^^\n@@ -26,7 +26,7 @@ LL | struct _St1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:29:18\n+  --> $DIR/feature-gate-associated_type_bounds.rs:30:18\n    |\n LL | enum _En1<T: Tr1<As1: Tr2>> {\n    |                  ^^^^^^^^\n@@ -35,7 +35,7 @@ LL | enum _En1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:36:19\n+  --> $DIR/feature-gate-associated_type_bounds.rs:37:19\n    |\n LL | union _Un1<T: Tr1<As1: Tr2>> {\n    |                   ^^^^^^^^\n@@ -44,7 +44,7 @@ LL | union _Un1<T: Tr1<As1: Tr2>> {\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:43:37\n+  --> $DIR/feature-gate-associated_type_bounds.rs:44:37\n    |\n LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    |                                     ^^^^^^^^^^\n@@ -53,7 +53,7 @@ LL | type _TaWhere1<T> where T: Iterator<Item: Copy> = T;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:46:22\n+  --> $DIR/feature-gate-associated_type_bounds.rs:47:22\n    |\n LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    |                      ^^^^^^^^^\n@@ -62,7 +62,7 @@ LL | fn _apit(_: impl Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:48:26\n+  --> $DIR/feature-gate-associated_type_bounds.rs:49:26\n    |\n LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    |                          ^^^^^^^^^\n@@ -71,7 +71,7 @@ LL | fn _apit_dyn(_: &dyn Tr1<As1: Copy>) {}\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:51:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:52:24\n    |\n LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    |                        ^^^^^^^^^\n@@ -80,7 +80,7 @@ LL | fn _rpit() -> impl Tr1<As1: Copy> { S1 }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:54:31\n+  --> $DIR/feature-gate-associated_type_bounds.rs:55:31\n    |\n LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    |                               ^^^^^^^^^\n@@ -89,7 +89,7 @@ LL | fn _rpit_dyn() -> Box<dyn Tr1<As1: Copy>> { Box::new(S1) }\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:57:23\n+  --> $DIR/feature-gate-associated_type_bounds.rs:58:23\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |                       ^^^^^^^^^\n@@ -98,7 +98,7 @@ LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:63:24\n+  --> $DIR/feature-gate-associated_type_bounds.rs:64:24\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |                        ^^^^^^^^^\n@@ -107,7 +107,7 @@ LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0658]: associated type bounds are unstable\n-  --> $DIR/feature-gate-associated_type_bounds.rs:70:21\n+  --> $DIR/feature-gate-associated_type_bounds.rs:71:21\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |                     ^^^^^^^^^\n@@ -116,30 +116,46 @@ LL |     let _: impl Tr1<As1: Copy> = S1;\n    = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-associated_type_bounds.rs:57:14\n+  --> $DIR/feature-gate-associated_type_bounds.rs:58:14\n    |\n LL | const _cdef: impl Tr1<As1: Copy> = S1;\n    |              ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-associated_type_bounds.rs:63:15\n+  --> $DIR/feature-gate-associated_type_bounds.rs:64:15\n    |\n LL | static _sdef: impl Tr1<As1: Copy> = S1;\n    |               ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n-  --> $DIR/feature-gate-associated_type_bounds.rs:70:12\n+  --> $DIR/feature-gate-associated_type_bounds.rs:71:12\n    |\n LL |     let _: impl Tr1<As1: Copy> = S1;\n    |            ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(impl_trait_in_bindings)]` to the crate attributes to enable\n \n-error: aborting due to 16 previous errors\n+error[E0277]: the trait bound `<<Self as _Tr3>::A as Iterator>::Item: Copy` is not satisfied\n+  --> $DIR/feature-gate-associated_type_bounds.rs:15:28\n+   |\n+LL |     type A: Iterator<Item: Copy>;\n+   |                            ^^^^ the trait `Copy` is not implemented for `<<Self as _Tr3>::A as Iterator>::Item`\n+   | \n+  ::: $SRC_DIR/core/src/marker.rs:LL:COL\n+   |\n+LL | pub trait Copy: Clone {\n+   | --------------------- required by this bound in `Copy`\n+   |\n+help: consider further restricting the associated type\n+   |\n+LL | trait _Tr3 where <<Self as _Tr3>::A as Iterator>::Item: Copy {\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n \n-Some errors have detailed explanations: E0562, E0658.\n-For more information about an error, try `rustc --explain E0562`.\n+Some errors have detailed explanations: E0277, E0562, E0658.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "1d2be3657ffb2b16379768d9d3a1dfa0c593ddaa", "filename": "src/test/ui/feature-gates/feature-gate-generic_associated_types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -15,6 +15,7 @@ impl PointerFamily<u32> for Foo {\n     //~^ ERROR generic associated types are unstable\n     type Pointer2<U32> = Box<U32>;\n     //~^ ERROR generic associated types are unstable\n+    //~| ERROR the trait bound `U32: Clone` is not satisfied\n }\n \n trait Bar {"}, {"sha": "266008cc0def4c268b9d129945ef4bb2c8930422", "filename": "src/test/ui/feature-gates/feature-gate-generic_associated_types.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-generic_associated_types.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -44,7 +44,7 @@ LL |     type Pointer2<U32> = Box<U32>;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: where clauses on associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:21:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:22:5\n    |\n LL |     type Assoc where Self: Sized;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,14 +53,26 @@ LL |     type Assoc where Self: Sized;\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n error[E0658]: where clauses on associated types are unstable\n-  --> $DIR/feature-gate-generic_associated_types.rs:26:5\n+  --> $DIR/feature-gate-generic_associated_types.rs:27:5\n    |\n LL |     type Assoc where Self: Sized = Foo;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n    = help: add `#![feature(generic_associated_types)]` to the crate attributes to enable\n \n-error: aborting due to 7 previous errors\n+error[E0277]: the trait bound `U32: Clone` is not satisfied\n+  --> $DIR/feature-gate-generic_associated_types.rs:16:5\n+   |\n+LL |     type Pointer2<U32> = Box<U32>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `U32`\n+   |\n+help: consider restricting type parameter `U32`\n+   |\n+LL |     type Pointer2<U32: Clone> = Box<U32>;\n+   |                      ^^^^^^^\n+\n+error: aborting due to 8 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors have detailed explanations: E0277, E0658.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "97a4ea53af583ce28e4b428721e5232495279c7a", "filename": "src/test/ui/for/for-c-in-str.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,16 @@\n-// E0277 should point exclusively at line 14, not the entire for loop span\n+// E0277 should point exclusively at line 6, not the entire for loop span\n \n fn main() {\n     for c in \"asdf\" {\n-    //~^ ERROR `&str` is not an iterator\n-    //~| NOTE `&str` is not an iterator\n-    //~| HELP the trait `Iterator` is not implemented for `&str`\n-    //~| NOTE required by `into_iter`\n-    //~| NOTE in this expansion of desugaring of `for` loop\n-    //~| NOTE in this expansion of desugaring of `for` loop\n-    //~| NOTE in this expansion of desugaring of `for` loop\n+        //~^ ERROR `&str` is not an iterator\n+        //~| NOTE `&str` is not an iterator\n+        //~| HELP the trait `Iterator` is not implemented for `&str`\n+        //~| NOTE required because of the requirements on the impl of `IntoIterator` for `&str`\n+        //~| NOTE required by `into_iter`\n+        //~| NOTE in this expansion of desugaring of `for` loop\n+        //~| NOTE in this expansion of desugaring of `for` loop\n+        //~| NOTE in this expansion of desugaring of `for` loop\n+        //~| NOTE in this expansion of desugaring of `for` loop\n         println!();\n     }\n }"}, {"sha": "18e46e1d7ded73b0320982a3b6ef3e36def7e344", "filename": "src/test/ui/for/for-c-in-str.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-c-in-str.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     for c in \"asdf\" {\n    |              ^^^^^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for `&str`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&str`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "0d9409626897fb35ba12899221f743195f9e6529", "filename": "src/test/ui/for/for-loop-bogosity.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-loop-bogosity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ffor%2Ffor-loop-bogosity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-bogosity.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     for x in bogus {\n    |              ^^^^^ `MyStruct` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `MyStruct`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `MyStruct`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "8e3c2f67ed165aa126f24765f021fde607cbd862", "filename": "src/test/ui/generator/sized-yield.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -16,6 +16,11 @@ error[E0277]: the size for values of type `str` cannot be known at compilation t\n    |\n LL |    Pin::new(&mut gen).resume(());\n    |                       ^^^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/core/src/ops/generator.rs:LL:COL\n+   |\n+LL | pub enum GeneratorState<Y, R> {\n+   |                         - required by this bound in `GeneratorState`\n    |\n    = help: the trait `Sized` is not implemented for `str`\n "}, {"sha": "8f6f87f78de707e5d1d998b06d20f1f8085262c0", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -15,7 +15,6 @@ LL | fn foo() -> impl Generator<Return = i32> {\n    |\n    = note: expected enum `std::result::Result<{integer}, _>`\n               found type `i32`\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0e8e14852d9db9a41a23c2b9828b9dd85e8b450e", "filename": "src/test/ui/generic-associated-types/auxiliary/foo_defn.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fauxiliary%2Ffoo_defn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fauxiliary%2Ffoo_defn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fauxiliary%2Ffoo_defn.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,8 @@\n+#![feature(generic_associated_types)]\n+\n+use std::{future::Future, pin::Pin};\n+\n+pub trait Foo {\n+    type Bar: AsRef<()>;\n+    fn foo(&self) -> Pin<Box<dyn Future<Output = Self::Bar> + '_>>;\n+}"}, {"sha": "8934a07fd4e3912284abb714b57b6cecf6a76345", "filename": "src/test/ui/generic-associated-types/cross-crate-bounds.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,32 @@\n+// regression test for #73816\n+// We handled bounds differently when `feature(generic_associated_types)` was enabled\n+\n+// edition:2018\n+// aux-build:foo_defn.rs\n+\n+extern crate foo_defn;\n+\n+use foo_defn::Foo;\n+use std::{future::Future, pin::Pin};\n+\n+pub struct FooImpl;\n+\n+impl Foo for FooImpl {\n+    type Bar = ();\n+    //~^ ERROR the trait bound `(): AsRef<()>` is not satisfied\n+    fn foo(&self) -> Pin<Box<dyn Future<Output = Self::Bar> + '_>> {\n+        panic!()\n+    }\n+}\n+\n+async fn foo() {\n+    bar(&FooImpl).await;\n+}\n+\n+async fn bar<F: Foo>(foo: &F) {\n+    foo.foo().await.as_ref();\n+}\n+\n+fn main() {\n+    // futures::executor::block_on(foo());\n+}"}, {"sha": "d96c5f4540ef5f3ac0043104bf830a6bd637d501", "filename": "src/test/ui/generic-associated-types/cross-crate-bounds.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fcross-crate-bounds.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `(): AsRef<()>` is not satisfied\n+  --> $DIR/cross-crate-bounds.rs:15:5\n+   |\n+LL |     type Bar = ();\n+   |     ^^^^^^^^^^^^^^ the trait `AsRef<()>` is not implemented for `()`\n+   | \n+  ::: $DIR/auxiliary/foo_defn.rs:6:15\n+   |\n+LL |     type Bar: AsRef<()>;\n+   |               --------- required by this bound in `foo_defn::Foo::Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "27970b15a411d6d94df825d1547de7b7691f6a46", "filename": "src/test/ui/generic-associated-types/generic-associated-types-where.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -19,8 +19,9 @@ struct Bar;\n impl Foo for Bar {\n     type Assoc = usize;\n     type Assoc2<T> = Vec<T>;\n+    //~^ ERROR `T` doesn't implement `std::fmt::Display`\n     type Assoc3<T> where T: Iterator = Vec<T>;\n-    //~^ impl has stricter requirements than trait\n+    //~^ ERROR impl has stricter requirements than trait\n     type WithDefault<'a, T: Debug + 'a> = &'a dyn Iterator<Item=T>;\n     type NoGenerics = ::std::cell::Cell<i32>;\n }"}, {"sha": "da8b625ea7f751ea01ed1ac1f474a1f353256673", "filename": "src/test/ui/generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fgeneric-associated-types-where.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,12 +1,25 @@\n+error[E0277]: `T` doesn't implement `std::fmt::Display`\n+  --> $DIR/generic-associated-types-where.rs:21:5\n+   |\n+LL |     type Assoc2<T> = Vec<T>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ `T` cannot be formatted with the default formatter\n+   |\n+   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n+help: consider restricting type parameter `T`\n+   |\n+LL |     type Assoc2<T: std::fmt::Display> = Vec<T>;\n+   |                  ^^^^^^^^^^^^^^^^^^^\n+\n error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/generic-associated-types-where.rs:22:5\n+  --> $DIR/generic-associated-types-where.rs:23:5\n    |\n LL |     type Assoc3<T>;\n    |     --------------- definition of `Assoc3` from trait\n ...\n LL |     type Assoc3<T> where T: Iterator = Vec<T>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `T: Iterator`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0276`.\n+Some errors have detailed explanations: E0276, E0277.\n+For more information about an error, try `rustc --explain E0276`."}, {"sha": "089a214667ea24f8ee05713f1d0b90c6dedd74c6", "filename": "src/test/ui/generic-associated-types/impl_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -16,6 +16,7 @@ impl<T> Foo for Fooy<T> {\n     //~^ ERROR the parameter type `T` may not live long enough\n     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n     //~^ ERROR lifetime bound not satisfied\n+    //~| ERROR lifetime bound not satisfied\n     type C where Self: Copy = String;\n     //~^ ERROR the trait bound `T: Copy` is not satisfied\n }"}, {"sha": "645d292714562213ebc4ea08c005f025656d3ef8", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -24,8 +24,25 @@ note: but lifetime parameter must outlive the lifetime `'a` as defined on the as\n LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n    |            ^^\n \n+error[E0478]: lifetime bound not satisfied\n+  --> $DIR/impl_bounds.rs:17:5\n+   |\n+LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lifetime parameter instantiated with the lifetime `'a` as defined on the associated item at 17:12\n+  --> $DIR/impl_bounds.rs:17:12\n+   |\n+LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n+   |            ^^\n+note: but lifetime parameter must outlive the lifetime `'b` as defined on the associated item at 17:16\n+  --> $DIR/impl_bounds.rs:17:16\n+   |\n+LL |     type B<'a, 'b> where 'b: 'a = (&'a(), &'b ());\n+   |                ^^\n+\n error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/impl_bounds.rs:19:5\n+  --> $DIR/impl_bounds.rs:20:5\n    |\n LL |     type C where Self: Copy = String;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n@@ -37,7 +54,7 @@ help: consider restricting type parameter `T`\n LL | impl<T: Copy> Foo for Fooy<T> {\n    |       ^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0277, E0310, E0478.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "98aa82aba83055a33a1f244a9365b454fe69c3ce", "filename": "src/test/ui/generic-associated-types/impl_bounds_ok.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds_ok.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,11 +10,12 @@ trait Foo {\n     type C where Self: Clone;\n }\n \n+#[derive(Clone)]\n struct Fooy;\n \n impl Foo for Fooy {\n     type A<'a> = (&'a ());\n-    type B<'a, 'b> = (&'a(), &'b ());\n+    type B<'a: 'b, 'b> = (&'a(), &'b ());\n     type C = String;\n }\n \n@@ -24,7 +25,7 @@ struct Fooer<T>(T);\n impl<T> Foo for Fooer<T> {\n     type A<'x> where T: 'x = (&'x ());\n     type B<'u, 'v> where 'u: 'v = (&'v &'u ());\n-    type C where Self: ToOwned = String;\n+    type C where Self: Clone + ToOwned = String;\n }\n \n fn main() {}"}, {"sha": "b380f0da2ea401846e7449ccb921758c847c7fde", "filename": "src/test/ui/generic-associated-types/issue-68641-check-gat-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68641-check-gat-bounds.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: the trait bound `T: Copy` is not satisfied\n   --> $DIR/issue-68641-check-gat-bounds.rs:15:5\n    |\n LL |     type Item<'a>: Copy;\n-   |     -------------------- required by `UnsafeCopy::Item`\n+   |                    ---- required by this bound in `UnsafeCopy::Item`\n ...\n LL |     type Item<'a> = T;\n    |     ^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`"}, {"sha": "61950478c32a8cf08f61c9c9fcdf1a99c72bb158", "filename": "src/test/ui/generic-associated-types/issue-68642-broken-llvm-ir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68642-broken-llvm-ir.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: expected a `Fn<()>` closure, found `T`\n   --> $DIR/issue-68642-broken-llvm-ir.rs:15:5\n    |\n LL |     type F<'a>: Fn() -> u32;\n-   |     ------------------------ required by `Fun::F`\n+   |                 ----------- required by this bound in `Fun::F`\n ...\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`"}, {"sha": "13980618987be8740ce34c39edbb1fa6910e8992", "filename": "src/test/ui/generic-associated-types/issue-68643-broken-mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68643-broken-mir.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: expected a `Fn<()>` closure, found `T`\n   --> $DIR/issue-68643-broken-mir.rs:15:5\n    |\n LL |     type F<'a>: Fn() -> u32;\n-   |     ------------------------ required by `Fun::F`\n+   |                 ----------- required by this bound in `Fun::F`\n ...\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`"}, {"sha": "811242514695914a66f2653f981c29767aace06b", "filename": "src/test/ui/generic-associated-types/issue-68644-codegen-selection.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68644-codegen-selection.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: expected a `Fn<()>` closure, found `T`\n   --> $DIR/issue-68644-codegen-selection.rs:15:5\n    |\n LL |     type F<'a>: Fn() -> u32;\n-   |     ------------------------ required by `Fun::F`\n+   |                 ----------- required by this bound in `Fun::F`\n ...\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`"}, {"sha": "22f50b394982831511f3e2a8777d771cd03c193a", "filename": "src/test/ui/generic-associated-types/issue-68645-codegen-fulfillment.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68645-codegen-fulfillment.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: expected a `Fn<()>` closure, found `T`\n   --> $DIR/issue-68645-codegen-fulfillment.rs:15:5\n    |\n LL |     type F<'a>: Fn() -> u32;\n-   |     ------------------------ required by `Fun::F`\n+   |                 ----------- required by this bound in `Fun::F`\n ...\n LL |     type F<'a> = Self;\n    |     ^^^^^^^^^^^^^^^^^^ expected an `Fn<()>` closure, found `T`"}, {"sha": "c4ee2c4e61872c4114d36e3e3069f703a58b87b4", "filename": "src/test/ui/generic-associated-types/issue-68656-unsized-values.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-68656-unsized-values.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0271]: type mismatch resolving `<T as Deref>::Target == T`\n   --> $DIR/issue-68656-unsized-values.rs:16:5\n    |\n LL |     type Item<'a>: std::ops::Deref<Target = T>;\n-   |     ------------------------------------------- required by `UnsafeCopy::Item`\n+   |                                    ---------- required by this bound in `UnsafeCopy::Item`\n ...\n LL | impl<T: Copy + std::ops::Deref> UnsafeCopy<T> for T {\n    |      - this type parameter"}, {"sha": "0cd676a9b37f3f9e3c69747846c047538929abd6", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle-generic.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,62 @@\n+// Like `projection-bound-cycle.rs` but this avoids using\n+// `feature(trivial_bounds)`.\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+\n+trait Print {\n+    fn print();\n+}\n+\n+trait Foo {\n+    type Item: Sized where <Self as Foo>::Item: Sized;\n+}\n+\n+struct Number<T> { t: T }\n+\n+impl<T> Foo for Number<T> {\n+    // Well-formedness checks require that the following\n+    // goal is true:\n+    // ```\n+    // if ([T]: Sized) { # if the where clauses hold\n+    //     [T]: Sized # then the bound on the associated type hold\n+    // }\n+    // ```\n+    // which it is :)\n+    type Item where [T]: Sized = [T];\n+}\n+\n+struct OnlySized<T> where T: Sized { f: T }\n+impl<T> Print for OnlySized<T> {\n+    fn print() {\n+        println!(\"{}\", std::mem::size_of::<T>());\n+    }\n+}\n+\n+trait Bar {\n+    type Assoc: Print;\n+}\n+\n+impl<T> Bar for T where T: Foo {\n+    // This is not ok, we need to prove `wf(<T as Foo>::Item)`, which requires\n+    // knowing that `<T as Foo>::Item: Sized` to satisfy the where clause. We\n+    // can use the bound on `Foo::Item` for this, but that requires\n+    // `wf(<T as Foo>::Item)`, which is an invalid cycle.\n+    type Assoc = OnlySized<<T as Foo>::Item>;\n+    //~^ ERROR overflow evaluating the requirement `<T as Foo>::Item: Sized`\n+}\n+\n+fn foo<T: Print>() {\n+    T::print() // oops, in fact `T = OnlySized<str>` which is ill-formed\n+}\n+\n+fn bar<T: Bar>() {\n+    // we have `FromEnv(T: Bar)` hence\n+    // `<T as Bar>::Assoc` is well-formed and\n+    // `Implemented(<T as Bar>::Assoc: Print)` hold\n+    foo::<<T as Bar>::Assoc>()\n+}\n+\n+fn main() {\n+    bar::<Number<u8>>()\n+}"}, {"sha": "d27e46f6836df9cf5483e53a07d5599732770704", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle-generic.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/projection-bound-cycle-generic.rs:4:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n+  --> $DIR/projection-bound-cycle-generic.rs:45:5\n+   |\n+LL | struct OnlySized<T> where T: Sized { f: T }\n+   |                  - required by this bound in `OnlySized`\n+...\n+LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "5043fe5c08f515d238611c6e838d7a85fbde6162", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,64 @@\n+// Test case from Chalk.\n+// Make sure that we make sure that we don't allow arbitrary bounds to be\n+// proven when a bound and a where clause of an associated type are the same.\n+\n+#![feature(generic_associated_types)]\n+//~^ WARNING the feature `generic_associated_types` is incomplete\n+#![feature(trivial_bounds)]\n+\n+trait Print {\n+    fn print();\n+}\n+\n+trait Foo {\n+    type Item: Sized where <Self as Foo>::Item: Sized;\n+}\n+\n+struct Number { }\n+\n+impl Foo for Number {\n+    // Well-formedness checks require that the following\n+    // goal is true:\n+    // ```\n+    // if (str: Sized) { # if the where clauses hold\n+    //     str: Sized # then the bound on the associated type hold\n+    // }\n+    // ```\n+    // which it is :)\n+    type Item where str: Sized = str;\n+}\n+\n+struct OnlySized<T> where T: Sized { f: T }\n+impl<T> Print for OnlySized<T> {\n+    fn print() {\n+        println!(\"{}\", std::mem::size_of::<T>());\n+    }\n+}\n+\n+trait Bar {\n+    type Assoc: Print;\n+}\n+\n+impl<T> Bar for T where T: Foo {\n+    // This is not ok, we need to prove `wf(<T as Foo>::Item)`, which requires\n+    // knowing that `<T as Foo>::Item: Sized` to satisfy the where clause. We\n+    // can use the bound on `Foo::Item` for this, but that requires\n+    // `wf(<T as Foo>::Item)`, which is an invalid cycle.\n+    type Assoc = OnlySized<<T as Foo>::Item>;\n+    //~^ ERROR overflow evaluating the requirement `<T as Foo>::Item: Sized`\n+}\n+\n+fn foo<T: Print>() {\n+    T::print() // oops, in fact `T = OnlySized<str>` which is ill-formed\n+}\n+\n+fn bar<T: Bar>() {\n+    // we have `FromEnv(T: Bar)` hence\n+    // `<T as Bar>::Assoc` is well-formed and\n+    // `Implemented(<T as Bar>::Assoc: Print)` hold\n+    foo::<<T as Bar>::Assoc>()\n+}\n+\n+fn main() {\n+    bar::<Number>()\n+}"}, {"sha": "400b664f97ca9401b097ec69830108a8590a8db2", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `generic_associated_types` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/projection-bound-cycle.rs:5:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44265 <https://github.com/rust-lang/rust/issues/44265> for more information\n+\n+error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n+  --> $DIR/projection-bound-cycle.rs:47:5\n+   |\n+LL | struct OnlySized<T> where T: Sized { f: T }\n+   |                  - required by this bound in `OnlySized`\n+...\n+LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "99d5bcf2bace9a3cb6abb00bf404c0f157fbcaad", "filename": "src/test/ui/generic-associated-types/unsatisfied-outlives-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Funsatisfied-outlives-bound.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -7,7 +7,7 @@ trait ATy {\n \n impl<'b> ATy for &'b () {\n     type Item<'a> = &'b ();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR  the type `&'b ()` does not fulfill the required lifetime\n }\n \n trait StaticTy {\n@@ -16,7 +16,7 @@ trait StaticTy {\n \n impl StaticTy for () {\n     type Item<'a> = &'a ();\n-    //~^ ERROR does not fulfill the required lifetime\n+    //~^ ERROR  the type `&'a ()` does not fulfill the required lifetime\n }\n \n fn main() {}"}, {"sha": "a7d06c71663de259f4d492da884c8df32a98f423", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -15,7 +15,6 @@ LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    |\n    = note:         expected type `()`\n            found associated type `<T as impl_trait::Trait>::Assoc`\n-   = note: the return type of a function must have a statically known size\n help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc` to `()`\n    |\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output=T::Assoc> {\n@@ -35,7 +34,6 @@ LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |\n    = note:         expected type `()`\n            found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n-   = note: the return type of a function must have a statically known size\n help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output=T::Assoc> {"}, {"sha": "64c536cf1fe30b5513c20a22027d00a22453744c", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,7 +14,6 @@ LL |     type E = impl Copy;\n    |              ^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `S`\n    |\n    = note: required because it appears within the type `(S, T)`\n-   = note: the return type of a function must have a statically known size\n help: consider further restricting this bound\n    |\n LL | impl<S: Default + Copy> Bar for S {\n@@ -27,7 +26,6 @@ LL |     type E = impl Copy;\n    |              ^^^^^^^^^ within `(S, T)`, the trait `Copy` is not implemented for `T`\n    |\n    = note: required because it appears within the type `(S, T)`\n-   = note: the return type of a function must have a statically known size\n help: consider further restricting this bound\n    |\n LL |     fn foo<T: Default + Copy>() -> Self::E {"}, {"sha": "58c5ee45051af2159fcfd9994ccc2ec5d69544cc", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,8 +3,6 @@ error[E0277]: the trait bound `impl Future: Copy` is not satisfied\n    |\n LL |     type E = impl std::marker::Copy;\n    |              ^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `impl Future`\n-   |\n-   = note: the return type of a function must have a statically known size\n \n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n   --> $DIR/issue-55872-2.rs:15:28"}, {"sha": "c7d6bb870962a27b0998a92610cb52d6485d52dc", "filename": "src/test/ui/impl-trait/wf-eval-order.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,39 @@\n+// Check that we handle evaluating `wf` predicates correctly.\n+\n+// check-pass\n+\n+struct X<T: B>(T)\n+where\n+    T::V: Clone;\n+\n+fn hide<T>(t: T) -> impl Sized {\n+    t\n+}\n+\n+trait A {\n+    type U;\n+}\n+\n+impl<T> A for T {\n+    type U = T;\n+}\n+\n+trait B {\n+    type V;\n+}\n+\n+impl<S: A<U = T>, T> B for S {\n+    type V = T;\n+}\n+\n+fn main() {\n+    // Evaluating `typeof(x): Sized` requires\n+    //\n+    // - `wf(typeof(x))` because we use a projection candidate.\n+    // - `<i32 as B>::V: Clone` because that's a bound on the trait.\n+    // - `<i32 as B>::V` normalizes to `_#1` where `<i32 as A>::U == _#1`\n+    //\n+    // This all works if we evaluate `<i32 as A>::U == _#1` before\n+    // `<i32 as B>::V`, but we previously had the opposite order.\n+    let x = hide(X(0));\n+}"}, {"sha": "2f630c2c9ad71a2fafc2b61376d5493bdd011585", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,12 +8,12 @@ LL | #![feature(impl_trait_in_bindings)]\n    = note: see issue #63065 <https://github.com/rust-lang/rust/issues/63065> for more information\n \n error[E0282]: type annotations needed for `impl Future`\n-  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:13:9\n+  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:13:20\n    |\n LL |     let fut = async {\n    |         --- consider giving `fut` the explicit type `impl Future`, with the type parameters specified\n LL |         make_unit()?;\n-   |         ^^^^^^^^^^^^ cannot infer type\n+   |                    ^ cannot infer type\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "92a9045f6db503c5e57ffe4e80f85480e3a56ef7", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,10 +1,10 @@\n error[E0282]: type annotations needed\n-  --> $DIR/cannot-infer-async.rs:11:9\n+  --> $DIR/cannot-infer-async.rs:11:20\n    |\n LL |     let fut = async {\n    |         --- consider giving `fut` a type\n LL |         make_unit()?;\n-   |         ^^^^^^^^^^^^ cannot infer type\n+   |                    ^ cannot infer type\n \n error: aborting due to previous error\n "}, {"sha": "d5366e422dbff9e1d4db97fa1f5acf3240af4269", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,8 @@\n error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result::Result<(), _>`\n-  --> $DIR/cannot-infer-closure.rs:3:9\n+  --> $DIR/cannot-infer-closure.rs:3:15\n    |\n LL |         Err(a)?;\n-   |         ^^^^^^^ cannot infer type\n+   |               ^ cannot infer type\n    |\n help: give this closure an explicit return type without `_` placeholders\n    |"}, {"sha": "bbcdd3e37a96ef141c6b7dc1800362396c1b0a53", "filename": "src/test/ui/issues-71798.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues-71798.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues-71798.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues-71798.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,11 +9,8 @@ error[E0277]: `u32` is not a future\n    |\n LL | fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `u32` is not a future\n-LL |     *x\n-   |     -- this returned value is of type `u32`\n    |\n    = help: the trait `Future` is not implemented for `u32`\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9940f43cc44404ce631f3d092015f4038da9edb5", "filename": "src/test/ui/issues/issue-20605.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20605.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     for item in *things { *item = 0 }\n    |                 ^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `dyn Iterator<Item = &'a mut u8>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `dyn Iterator<Item = &'a mut u8>`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "20d980763ea9cf65acf345f1c327099f509946fd", "filename": "src/test/ui/issues/issue-20831-debruijn.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -28,9 +28,6 @@ impl<'a> Publisher<'a> for MyStruct<'a> {\n     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n         // Not obvious, but there is an implicit lifetime here -------^\n         //~^^ ERROR cannot infer\n-        //~| ERROR cannot infer\n-        //~| ERROR mismatched types\n-        //~| ERROR mismatched types\n         //\n         // The fact that `Publisher` is using an implicit lifetime is\n         // what was causing the debruijn accounting to be off, so"}, {"sha": "bcfb6b70b2e5f3c21d9e5645581876a4e2aee853", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,77 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-20831-debruijn.rs:28:5\n-   |\n-LL | /     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-LL | |         // Not obvious, but there is an implicit lifetime here -------^\n-LL | |\n-LL | |\n-...  |\n-LL | |         self.sub = t;\n-LL | |     }\n-   | |_____^ lifetime mismatch\n-   |\n-   = note: expected type `'a`\n-              found type `'_`\n-note: the anonymous lifetime #2 defined on the method body at 28:5...\n-  --> $DIR/issue-20831-debruijn.rs:28:5\n-   |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...does not necessarily outlive the lifetime `'a` as defined on the impl at 26:6\n-  --> $DIR/issue-20831-debruijn.rs:26:6\n-   |\n-LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n-   |      ^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-20831-debruijn.rs:28:5\n-   |\n-LL | /     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-LL | |         // Not obvious, but there is an implicit lifetime here -------^\n-LL | |\n-LL | |\n-...  |\n-LL | |         self.sub = t;\n-LL | |     }\n-   | |_____^ lifetime mismatch\n-   |\n-   = note: expected type `'a`\n-              found type `'_`\n-note: the lifetime `'a` as defined on the impl at 26:6...\n-  --> $DIR/issue-20831-debruijn.rs:26:6\n-   |\n-LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n-   |      ^^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the method body at 28:5\n-  --> $DIR/issue-20831-debruijn.rs:28:5\n-   |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n-   |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the anonymous lifetime #2 defined on the method body at 28:5...\n-  --> $DIR/issue-20831-debruijn.rs:28:5\n-   |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...but the lifetime must also be valid for the lifetime `'a` as defined on the impl at 26:6...\n-  --> $DIR/issue-20831-debruijn.rs:26:6\n-   |\n-LL | impl<'a> Publisher<'a> for MyStruct<'a> {\n-   |      ^^\n-note: ...so that the types are compatible\n-  --> $DIR/issue-20831-debruijn.rs:28:33\n-   |\n-LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `Publisher<'_>`\n-              found `Publisher<'_>`\n-\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/issue-20831-debruijn.rs:28:33\n    |\n@@ -96,7 +22,6 @@ LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher\n    = note: expected `Publisher<'_>`\n               found `Publisher<'_>`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0495.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0495`."}, {"sha": "d0c052cb2fd39fadc69593720402422e887a07fb", "filename": "src/test/ui/issues/issue-21946.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21946.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,7 +5,6 @@ trait Foo {\n struct FooStruct;\n \n impl Foo for FooStruct {\n-    //~^ ERROR overflow evaluating the requirement `<FooStruct as Foo>::A == _`\n     type A = <FooStruct as Foo>::A;\n     //~^ ERROR overflow evaluating the requirement `<FooStruct as Foo>::A == _`\n }"}, {"sha": "0497bd20469a0e6bddaea19c5f4c408773890ca4", "filename": "src/test/ui/issues/issue-21946.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21946.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,15 +1,9 @@\n error[E0275]: overflow evaluating the requirement `<FooStruct as Foo>::A == _`\n-  --> $DIR/issue-21946.rs:7:6\n-   |\n-LL | impl Foo for FooStruct {\n-   |      ^^^\n-\n-error[E0275]: overflow evaluating the requirement `<FooStruct as Foo>::A == _`\n-  --> $DIR/issue-21946.rs:9:5\n+  --> $DIR/issue-21946.rs:8:5\n    |\n LL |     type A = <FooStruct as Foo>::A;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "0937e029ef45e142299fdc08a9018403a8c535f7", "filename": "src/test/ui/issues/issue-23122-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,7 +5,6 @@ trait Next {\n struct GetNext<T: Next> { t: T }\n \n impl<T: Next> Next for GetNext<T> {\n-    //~^ ERROR overflow evaluating the requirement\n     type Next = <GetNext<T> as Next>::Next;\n     //~^ ERROR overflow evaluating the requirement\n }"}, {"sha": "1f78b0d152d1b3adc0159b5b47a616df684db169", "filename": "src/test/ui/issues/issue-23122-1.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,15 +1,9 @@\n error[E0275]: overflow evaluating the requirement `<GetNext<T> as Next>::Next == _`\n-  --> $DIR/issue-23122-1.rs:7:15\n-   |\n-LL | impl<T: Next> Next for GetNext<T> {\n-   |               ^^^^\n-\n-error[E0275]: overflow evaluating the requirement `<GetNext<T> as Next>::Next == _`\n-  --> $DIR/issue-23122-1.rs:9:5\n+  --> $DIR/issue-23122-1.rs:8:5\n    |\n LL |     type Next = <GetNext<T> as Next>::Next;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "84abebf6b74a7cc1ba3fa92f87576fc0cdd386cb", "filename": "src/test/ui/issues/issue-23122-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,7 +5,6 @@ trait Next {\n struct GetNext<T: Next> { t: T }\n \n impl<T: Next> Next for GetNext<T> {\n-    //~^ ERROR overflow evaluating the requirement\n     type Next = <GetNext<T::Next> as Next>::Next;\n     //~^ ERROR overflow evaluating the requirement\n }"}, {"sha": "7ed04519b69caa15b341c285d5d3b867174e68a8", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,21 +1,12 @@\n-error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: Sized`\n-  --> $DIR/issue-23122-2.rs:7:15\n-   |\n-LL | impl<T: Next> Next for GetNext<T> {\n-   |               ^^^^\n-   |\n-   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_23122_2`)\n-   = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n-\n error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: Sized`\n-  --> $DIR/issue-23122-2.rs:9:5\n+  --> $DIR/issue-23122-2.rs:8:5\n    |\n LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate (`issue_23122_2`)\n    = note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "5a7b3459589eb77ea6a14457c02ad46b6c3f62b4", "filename": "src/test/ui/issues/issue-24204.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![allow(dead_code)]\n \n trait MultiDispatch<T> {\n@@ -8,10 +10,16 @@ trait Trait: Sized {\n     type A: MultiDispatch<Self::B, O = Self>;\n     type B;\n \n-    fn new<U>(u: U) -> <Self::A as MultiDispatch<U>>::O where Self::A : MultiDispatch<U>;\n+    fn new<U>(u: U) -> <Self::A as MultiDispatch<U>>::O\n+    where\n+        Self::A: MultiDispatch<U>;\n }\n \n-fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-//~^ ERROR type mismatch resolving\n+fn test<T: Trait<B = i32>>(b: i32) -> T\n+where\n+    T::A: MultiDispatch<i32>,\n+{\n+    T::new(b)\n+}\n \n fn main() {}"}, {"sha": "d5cbcf786bf1abfe5426869412c4f3fd01871c89", "filename": "src/test/ui/issues/issue-24204.stderr", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24204.stderr?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -1,20 +0,0 @@\n-error[E0271]: type mismatch resolving `<<T as Trait>::A as MultiDispatch<i32>>::O == T`\n-  --> $DIR/issue-24204.rs:14:12\n-   |\n-LL | trait Trait: Sized {\n-   |       ----- required by a bound in this\n-LL |     type A: MultiDispatch<Self::B, O = Self>;\n-   |                                    -------- required by this bound in `Trait`\n-...\n-LL | fn test<T: Trait<B=i32>>(b: i32) -> T where T::A: MultiDispatch<i32> { T::new(b) }\n-   |         -  ^^^^^^^^^^^^ expected type parameter `T`, found associated type\n-   |         |\n-   |         this type parameter\n-   |\n-   = note: expected type parameter `T`\n-             found associated type `<<T as Trait>::A as MultiDispatch<i32>>::O`\n-   = note: you might be missing a type parameter or trait bound\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0271`."}, {"sha": "4c927a0cb458f8c471b52398a0a024de39b5350c", "filename": "src/test/ui/issues/issue-28098.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-28098.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-28098.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28098.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,6 +14,7 @@ LL |     for _ in false {}\n    |              ^^^^^ `bool` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `bool`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `bool`\n    = note: required by `into_iter`\n \n error[E0277]: `()` is not an iterator\n@@ -58,6 +59,7 @@ LL |     for _ in false {}\n    |              ^^^^^ `bool` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `bool`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `bool`\n    = note: required by `into_iter`\n \n error[E0277]: `()` is not an iterator"}, {"sha": "e91dae08b3a331b36eeee730681efd1c3f6fc6a0", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -16,6 +16,8 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note:  expected tuple `(&_, &_)`\n            found reference `&_`\n    = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+   = note: required by `into_iter`\n \n error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n   --> $DIR/issue-33941.rs:4:14\n@@ -26,6 +28,7 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note:  expected tuple `(&_, &_)`\n            found reference `&_`\n    = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+   = note: required by `std::iter::Iterator::next`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "94c53216f50ac0f77560a4877b5c6223c824101d", "filename": "src/test/ui/issues/issue-41139.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41139.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,12 @@\n trait Trait {}\n \n-fn get_function<'a>() -> &'a dyn Fn() -> dyn Trait { panic!(\"\") }\n+fn get_function<'a>() -> &'a dyn Fn() -> dyn Trait {\n+    panic!(\"\")\n+}\n \n fn main() {\n-    let t : &dyn Trait = &get_function()();\n-    //~^ ERROR cannot move a value of type dyn Trait\n+    // This isn't great. The issue here is that `dyn Trait` is not sized, so\n+    // `dyn Fn() -> dyn Trait` is not well-formed.\n+    let t: &dyn Trait = &get_function()();\n+    //~^ ERROR expected function, found `&dyn Fn() -> (dyn Trait + 'static)`\n }"}, {"sha": "48b22bca20f067444040cd73b4c487343e31e8ee", "filename": "src/test/ui/issues/issue-41139.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41139.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,9 +1,14 @@\n-error[E0161]: cannot move a value of type dyn Trait: the size of dyn Trait cannot be statically determined\n-  --> $DIR/issue-41139.rs:6:27\n+error[E0618]: expected function, found `&dyn Fn() -> (dyn Trait + 'static)`\n+  --> $DIR/issue-41139.rs:10:26\n    |\n-LL |     let t : &dyn Trait = &get_function()();\n-   |                           ^^^^^^^^^^^^^^^^\n+LL | fn get_function<'a>() -> &'a dyn Fn() -> dyn Trait {\n+   | -------------------------------------------------- `get_function` defined here returns `&dyn Fn() -> (dyn Trait + 'static)`\n+...\n+LL |     let t: &dyn Trait = &get_function()();\n+   |                          ^^^^^^^^^^^^^^--\n+   |                          |\n+   |                          call expression requires function\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0161`.\n+For more information about this error, try `rustc --explain E0618`."}, {"sha": "d5105ae3b58157bf3731a6edb0879715198376a8", "filename": "src/test/ui/issues/issue-43784-associated-type.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,11 @@\n error[E0277]: the trait bound `T: Copy` is not satisfied\n-  --> $DIR/issue-43784-associated-type.rs:14:18\n+  --> $DIR/issue-43784-associated-type.rs:14:5\n    |\n+LL |     type Assoc: Partial<Self>;\n+   |                 ------------- required by this bound in `Complete::Assoc`\n+...\n LL |     type Assoc = T;\n-   |                  ^ the trait `Copy` is not implemented for `T`\n+   |     ^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `T`\n    |\n help: consider restricting type parameter `T`\n    |"}, {"sha": "c73536ba97332b3cbc715275a57cddf18ce04d6a", "filename": "src/test/ui/issues/issue-43784-supertrait.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the trait bound `T: Copy` is not satisfied\n   --> $DIR/issue-43784-supertrait.rs:8:9\n    |\n+LL | pub trait Complete: Partial {\n+   |                     ------- required by this bound in `Complete`\n+...\n LL | impl<T> Complete for T {}\n    |         ^^^^^^^^ the trait `Copy` is not implemented for `T`\n    |"}, {"sha": "0cb04dcb22a548c76459a20f3701b7d10a3e29f0", "filename": "src/test/ui/issues/issue-58344.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n use std::ops::Add;\n \n trait Trait<T> {\n@@ -18,30 +20,28 @@ enum Either<L, R> {\n }\n \n impl<L, R> Either<L, R> {\n-    fn converge<T>(self) -> T where L: Trait<T>, R: Trait<T> {\n+    fn converge<T>(self) -> T\n+    where\n+        L: Trait<T>,\n+        R: Trait<T>,\n+    {\n         match self {\n             Either::Left(val) => val.get(),\n             Either::Right(val) => val.get(),\n         }\n     }\n }\n \n-fn add_generic<A: Add<B>, B>(lhs: A, rhs: B) -> Either<\n-    impl Trait<<A as Add<B>>::Output>,\n-    impl Trait<<A as Add<B>>::Output>\n-> {\n-    if true {\n-        Either::Left(Holder(lhs + rhs))\n-    } else {\n-        Either::Right(Holder(lhs + rhs))\n-    }\n+fn add_generic<A: Add<B>, B>(\n+    lhs: A,\n+    rhs: B,\n+) -> Either<impl Trait<<A as Add<B>>::Output>, impl Trait<<A as Add<B>>::Output>> {\n+    if true { Either::Left(Holder(lhs + rhs)) } else { Either::Right(Holder(lhs + rhs)) }\n }\n \n fn add_one(\n     value: u32,\n ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-    //~^ ERROR: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>`\n-    //~| ERROR: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>`\n     add_generic(value, 1u32)\n }\n "}, {"sha": "ade85d8b0168c6227c72004ecd8e52da3b1fd758", "filename": "src/test/ui/issues/issue-58344.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -1,25 +0,0 @@\n-error[E0277]: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>` is not satisfied\n-  --> $DIR/issue-58344.rs:42:13\n-   |\n-LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as Add>::Output>`\n-...\n-LL |     add_generic(value, 1u32)\n-   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as Add>::Output>, impl Trait<<u32 as Add>::Output>>`\n-   |\n-   = note: the return type of a function must have a statically known size\n-\n-error[E0277]: the trait bound `impl Trait<<u32 as Add>::Output>: Trait<u32>` is not satisfied\n-  --> $DIR/issue-58344.rs:42:52\n-   |\n-LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n-   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as Add>::Output>`\n-...\n-LL |     add_generic(value, 1u32)\n-   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as Add>::Output>, impl Trait<<u32 as Add>::Output>>`\n-   |\n-   = note: the return type of a function must have a statically known size\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "c63b1544a5379d691feded61395b8610448b04b6", "filename": "src/test/ui/issues/issue-60283.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -16,4 +16,5 @@ where\n fn main() {\n     foo((), drop)\n     //~^ ERROR type mismatch in function arguments\n+    //~| ERROR size for values of type `<() as Trait<'_>>::Item` cannot be known at compilation time\n }"}, {"sha": "650570b6471eb13266ce99e8273e68350eaaf272", "filename": "src/test/ui/issues/issue-60283.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60283.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -13,6 +13,24 @@ LL |     foo((), drop)\n    |             expected signature of `fn(<() as Trait<'a>>::Item) -> _`\n    |             found signature of `fn(()) -> _`\n \n-error: aborting due to previous error\n+error[E0277]: the size for values of type `<() as Trait<'_>>::Item` cannot be known at compilation time\n+  --> $DIR/issue-60283.rs:17:13\n+   |\n+LL |     foo((), drop)\n+   |             ^^^^ doesn't have a size known at compile-time\n+   | \n+  ::: $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   |\n+LL | pub fn drop<T>(_x: T) {}\n+   |             - required by this bound in `std::mem::drop`\n+   |\n+   = help: the trait `Sized` is not implemented for `<() as Trait<'_>>::Item`\n+help: consider further restricting the associated type\n+   |\n+LL | fn main() where <() as Trait<'_>>::Item: Sized {\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0631`.\n+Some errors have detailed explanations: E0277, E0631.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "64cc0bab3f33c147724038ec3232b5c906a89bd7", "filename": "src/test/ui/issues/issue-65673.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-65673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fissues%2Fissue-65673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65673.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,13 +1,11 @@\n error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n-  --> $DIR/issue-65673.rs:9:16\n+  --> $DIR/issue-65673.rs:9:5\n    |\n-LL | trait WithType {\n-   |       -------- required by a bound in this\n LL |     type Ctx;\n-   |     --------- required by this bound in `WithType`\n+   |     --------- required by this bound in `WithType::Ctx`\n ...\n LL |     type Ctx = dyn Alias<T>;\n-   |                ^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented for `(dyn Trait + 'static)`\n "}, {"sha": "601983a6153fd736e2ca2dd7a7103bf91dcdc78f", "filename": "src/test/ui/iterators/array-of-ranges.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray-of-ranges.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,6 +6,7 @@ LL |     for _ in [0..1] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 1]`\n    = note: `[start..end]` is an array of one `Range`; you might have meant to have a `Range` without the brackets: `start..end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n@@ -16,6 +17,7 @@ LL |     for _ in [0..=1] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeFrom<{integer}>; 1]` is not an iterator\n@@ -26,6 +28,7 @@ LL |     for _ in [0..] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeFrom<{integer}>; 1]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[RangeFrom<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeTo<{integer}>; 1]` is not an iterator\n@@ -36,6 +39,7 @@ LL |     for _ in [..1] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeTo<{integer}>; 1]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[RangeTo<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeToInclusive<{integer}>; 1]` is not an iterator\n@@ -46,6 +50,7 @@ LL |     for _ in [..=1] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeToInclusive<{integer}>; 1]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[RangeToInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[std::ops::Range<{integer}>; 1]` is not an iterator\n@@ -56,6 +61,7 @@ LL |     for _ in [start..end] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 1]`\n    = note: `[start..end]` is an array of one `Range`; you might have meant to have a `Range` without the brackets: `start..end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[std::ops::Range<{integer}>; 1]` is not an iterator\n@@ -66,6 +72,7 @@ LL |     for _ in array_of_range {}\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 1]`\n    = note: `[start..end]` is an array of one `Range`; you might have meant to have a `Range` without the brackets: `start..end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error[E0277]: `[std::ops::Range<{integer}>; 2]` is not an iterator\n@@ -76,6 +83,7 @@ LL |     for _ in [0..1, 2..3] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[std::ops::Range<{integer}>; 2]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[std::ops::Range<{integer}>; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[RangeInclusive<{integer}>; 1]` is not an iterator\n@@ -86,6 +94,7 @@ LL |     for _ in [0..=1] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[RangeInclusive<{integer}>; 1]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[RangeInclusive<{integer}>; 1]`\n    = note: required by `into_iter`\n \n error: aborting due to 9 previous errors"}, {"sha": "68c6de5493f1343bfbf8b14f93b566b601780a60", "filename": "src/test/ui/iterators/array.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Farray.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Farray.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,6 +6,7 @@ LL |     for _ in [1, 2] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{integer}; 2]` is not an iterator\n@@ -16,6 +17,7 @@ LL |     for _ in x {}\n    |\n    = help: the trait `Iterator` is not implemented for `[{integer}; 2]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[{integer}; 2]`\n    = note: required by `into_iter`\n \n error[E0277]: `[{float}; 2]` is not an iterator\n@@ -26,6 +28,7 @@ LL |     for _ in [1.0, 2.0] {}\n    |\n    = help: the trait `Iterator` is not implemented for `[{float}; 2]`\n    = note: arrays are not iterators, but slices like the following are: `&[1, 2, 3]`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `[{float}; 2]`\n    = note: required by `into_iter`\n \n error: aborting due to 3 previous errors"}, {"sha": "e31ee59785c8b7ff48691be11a61a3fe184b661a", "filename": "src/test/ui/iterators/integral.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Fintegral.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Fintegral.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fintegral.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,6 +6,7 @@ LL |     for _ in 42 {}\n    |\n    = help: the trait `Iterator` is not implemented for `{integer}`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `{integer}`\n    = note: required by `into_iter`\n \n error[E0277]: `u8` is not an iterator\n@@ -16,6 +17,7 @@ LL |     for _ in 42 as u8 {}\n    |\n    = help: the trait `Iterator` is not implemented for `u8`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `u8`\n    = note: required by `into_iter`\n \n error[E0277]: `i8` is not an iterator\n@@ -26,6 +28,7 @@ LL |     for _ in 42 as i8 {}\n    |\n    = help: the trait `Iterator` is not implemented for `i8`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `i8`\n    = note: required by `into_iter`\n \n error[E0277]: `u16` is not an iterator\n@@ -36,6 +39,7 @@ LL |     for _ in 42 as u16 {}\n    |\n    = help: the trait `Iterator` is not implemented for `u16`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `u16`\n    = note: required by `into_iter`\n \n error[E0277]: `i16` is not an iterator\n@@ -46,6 +50,7 @@ LL |     for _ in 42 as i16 {}\n    |\n    = help: the trait `Iterator` is not implemented for `i16`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `i16`\n    = note: required by `into_iter`\n \n error[E0277]: `u32` is not an iterator\n@@ -56,6 +61,7 @@ LL |     for _ in 42 as u32 {}\n    |\n    = help: the trait `Iterator` is not implemented for `u32`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `u32`\n    = note: required by `into_iter`\n \n error[E0277]: `i32` is not an iterator\n@@ -66,6 +72,7 @@ LL |     for _ in 42 as i32 {}\n    |\n    = help: the trait `Iterator` is not implemented for `i32`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `i32`\n    = note: required by `into_iter`\n \n error[E0277]: `u64` is not an iterator\n@@ -76,6 +83,7 @@ LL |     for _ in 42 as u64 {}\n    |\n    = help: the trait `Iterator` is not implemented for `u64`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `u64`\n    = note: required by `into_iter`\n \n error[E0277]: `i64` is not an iterator\n@@ -86,6 +94,7 @@ LL |     for _ in 42 as i64 {}\n    |\n    = help: the trait `Iterator` is not implemented for `i64`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `i64`\n    = note: required by `into_iter`\n \n error[E0277]: `usize` is not an iterator\n@@ -96,6 +105,7 @@ LL |     for _ in 42 as usize {}\n    |\n    = help: the trait `Iterator` is not implemented for `usize`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `usize`\n    = note: required by `into_iter`\n \n error[E0277]: `isize` is not an iterator\n@@ -106,6 +116,7 @@ LL |     for _ in 42 as isize {}\n    |\n    = help: the trait `Iterator` is not implemented for `isize`\n    = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `isize`\n    = note: required by `into_iter`\n \n error[E0277]: `{float}` is not an iterator\n@@ -115,6 +126,7 @@ LL |     for _ in 42.0 {}\n    |              ^^^^ `{float}` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `{float}`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `{float}`\n    = note: required by `into_iter`\n \n error: aborting due to 12 previous errors"}, {"sha": "4678bafd196b57c8b0124dd52adb975b371984da", "filename": "src/test/ui/iterators/ranges.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Franges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Franges.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     for _ in ..10 {}\n    |              ^^^^ `RangeTo<{integer}>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `RangeTo<{integer}>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `RangeTo<{integer}>`\n    = note: required by `into_iter`\n \n error[E0277]: `RangeToInclusive<{integer}>` is not an iterator\n@@ -14,6 +15,7 @@ LL |     for _ in ..=10 {}\n    |              ^^^^^ `RangeToInclusive<{integer}>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `RangeToInclusive<{integer}>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `RangeToInclusive<{integer}>`\n    = note: required by `into_iter`\n \n error: aborting due to 2 previous errors"}, {"sha": "1653006682427736a5e0a889248ebd0d8f06acfe", "filename": "src/test/ui/iterators/string.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fstring.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     for _ in \"\".to_owned() {}\n    |              ^^^^^^^^^^^^^ `String` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `String`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n    = note: required by `into_iter`\n \n error[E0277]: `&str` is not an iterator\n@@ -14,6 +15,7 @@ LL |     for _ in \"\" {}\n    |              ^^ `&str` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented for `&str`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&str`\n    = note: required by `into_iter`\n \n error: aborting due to 2 previous errors"}, {"sha": "c3d597bec2e406e7a86e2099631664f756430972", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,11 +3,6 @@ error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisf\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n-LL |\n-LL |     Ok(())\n-   |     ------ this returned value is of type `std::result::Result<(), _>`\n-   |\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "670f76867ce45122b29e6ebba4a3c628318c9507", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,11 +3,6 @@ error[E0277]: the trait bound `(): T` is not satisfied\n    |\n LL | fn should_ret_unit() -> impl T {\n    |                         ^^^^^^ the trait `T` is not implemented for `()`\n-LL |\n-LL |     panic!()\n-   |     -------- this returned value is of type `!`\n-   |\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "16d93c18900a9f5000db201a8f5aeeb096a0f66d", "filename": "src/test/ui/never_type/issue-51506.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnever_type%2Fissue-51506.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnever_type%2Fissue-51506.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-51506.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -2,7 +2,7 @@ error[E0277]: `!` is not an iterator\n   --> $DIR/issue-51506.rs:13:5\n    |\n LL |     type Out: Iterator<Item = u32>;\n-   |     ------------------------------- required by `Trait::Out`\n+   |               -------------------- required by this bound in `Trait::Out`\n ...\n LL |     default type Out = !;\n    |     ^^^^^^^^^^^^^^^^^^^^^ `!` is not an iterator"}, {"sha": "44dcd191d1ba2d7aea1a1e5134858c982d2d219a", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -32,5 +32,4 @@ fn main() {\n     let _x = <fn(&())>::make_f();\n     //~^ higher-ranked subtype error\n     //~| higher-ranked subtype error\n-    //~| higher-ranked subtype error\n }"}, {"sha": "190b520c6786c61bef25883f1606ecb589d1d1c4", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -10,11 +10,5 @@ error: higher-ranked subtype error\n LL |     let _x = <fn(&())>::make_f();\n    |              ^^^^^^^^^^^^^^^^^^^\n \n-error: higher-ranked subtype error\n-  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n-   |\n-LL |     let _x = <fn(&())>::make_f();\n-   |              ^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "44bd369324a4b640345dc8c769f2d7034c28a927", "filename": "src/test/ui/object-safety/object-safety-bounds.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+// Traits with bounds mentioning `Self` are not object safe\n+\n+trait X {\n+    type U: PartialEq<Self>;\n+}\n+\n+fn f() -> Box<dyn X<U = u32>> {\n+    //~^ ERROR the trait `X` cannot be made into an object\n+    loop {}\n+}\n+\n+fn main() {}"}, {"sha": "af4548308631e2304a7873584fcc016a3a9340fc", "filename": "src/test/ui/object-safety/object-safety-bounds.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,14 @@\n+error[E0038]: the trait `X` cannot be made into an object\n+  --> $DIR/object-safety-bounds.rs:7:11\n+   |\n+LL | trait X {\n+   |       - this trait cannot be made into an object...\n+LL |     type U: PartialEq<Self>;\n+   |             --------------- ...because it uses `Self` as a type parameter in this\n+...\n+LL | fn f() -> Box<dyn X<U = u32>> {\n+   |           ^^^^^^^^^^^^^^^^^^^ the trait `X` cannot be made into an object\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "fe9c113710c3c09f71508f7d0a14ff50977dbcdf", "filename": "src/test/ui/parser/struct-literal-in-for.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -24,6 +24,7 @@ LL | |     }.hi() {\n    | |__________^ `bool` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `bool`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `bool`\n    = note: required by `into_iter`\n \n error: aborting due to 2 previous errors"}, {"sha": "fba72c13170feafd8a227547155f3134fb4c1b3f", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -21,15 +21,15 @@ mod m {\n     // \"Private-in-public in associated types is hard error\" in RFC 2145\n     // applies only to the aliased types, not bounds.\n     pub trait PubTr {\n+        type Alias1: PrivTr;\n         //~^ WARN private trait `PrivTr` in public interface\n         //~| WARN this was previously accepted\n-        //~| WARN private type `Priv` in public interface\n-        //~| WARN private type `Priv` in public interface\n-        //~| WARN this was previously accepted\n-        //~| WARN this was previously accepted\n-        type Alias1: PrivTr;\n         type Alias2: PubTrAux1<Priv> = u8;\n+        //~^ WARN private type `Priv` in public interface\n+        //~| WARN this was previously accepted\n         type Alias3: PubTrAux2<A = Priv> = u8;\n+        //~^ WARN private type `Priv` in public interface\n+        //~| WARN this was previously accepted\n \n         type Alias4 = Priv;\n         //~^ ERROR private type `Priv` in public interface"}, {"sha": "430be143f918778a5839f8dfbada510cdaab2ec7", "filename": "src/test/ui/privacy/private-in-public-assoc-ty.stderr", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-assoc-ty.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,47 +8,29 @@ LL |         type A = Priv;\n    |         ^^^^^^^^^^^^^^ can't leak private type\n \n warning: private trait `PrivTr` in public interface (error E0445)\n-  --> $DIR/private-in-public-assoc-ty.rs:23:5\n+  --> $DIR/private-in-public-assoc-ty.rs:24:9\n    |\n-LL | /     pub trait PubTr {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         fn infer_exist() -> Self::Exist;\n-LL | |     }\n-   | |_____^\n+LL |         type Alias1: PrivTr;\n+   |         ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(private_in_public)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n warning: private type `Priv` in public interface (error E0446)\n-  --> $DIR/private-in-public-assoc-ty.rs:23:5\n+  --> $DIR/private-in-public-assoc-ty.rs:27:9\n    |\n-LL | /     pub trait PubTr {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         fn infer_exist() -> Self::Exist;\n-LL | |     }\n-   | |_____^\n+LL |         type Alias2: PubTrAux1<Priv> = u8;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n warning: private type `Priv` in public interface (error E0446)\n-  --> $DIR/private-in-public-assoc-ty.rs:23:5\n+  --> $DIR/private-in-public-assoc-ty.rs:30:9\n    |\n-LL | /     pub trait PubTr {\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |         fn infer_exist() -> Self::Exist;\n-LL | |     }\n-   | |_____^\n+LL |         type Alias3: PubTrAux2<A = Priv> = u8;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>"}, {"sha": "1c8706d8ad2e1d5bec3556829a998a4c8b807fa4", "filename": "src/test/ui/privacy/private-in-public-warn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -55,9 +55,9 @@ mod traits {\n     pub trait Tr2<T: PrivTr> {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     pub trait Tr3 {\n+        type Alias: PrivTr;\n         //~^ ERROR private trait `traits::PrivTr` in public interface\n         //~| WARNING hard error\n-        type Alias: PrivTr;\n         fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n         //~^ WARNING hard error\n     }"}, {"sha": "f50dc48f8add36dc1c599e9df9f4977d7fcf0c9f", "filename": "src/test/ui/privacy/private-in-public-warn.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -130,16 +130,10 @@ LL |     pub trait Tr2<T: PrivTr> {}\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n error: private trait `traits::PrivTr` in public interface (error E0445)\n-  --> $DIR/private-in-public-warn.rs:57:5\n-   |\n-LL | /     pub trait Tr3 {\n-LL | |\n-LL | |\n-LL | |         type Alias: PrivTr;\n-LL | |         fn f<T: PrivTr>(arg: T) {}\n-LL | |\n-LL | |     }\n-   | |_____^\n+  --> $DIR/private-in-public-warn.rs:58:9\n+   |\n+LL |         type Alias: PrivTr;\n+   |         ^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>"}, {"sha": "f926eee9d92b282deddff6f52ff1437bc6edb05e", "filename": "src/test/ui/privacy/pub-priv-dep/pub-priv1.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,26 +1,26 @@\n- // aux-crate:priv:priv_dep=priv_dep.rs\n- // aux-build:pub_dep.rs\n+// aux-crate:priv:priv_dep=priv_dep.rs\n+// aux-build:pub_dep.rs\n #![deny(exported_private_dependencies)]\n \n // This crate is a private dependency\n extern crate priv_dep;\n // This crate is a public dependency\n extern crate pub_dep;\n \n-use priv_dep::{OtherType, OtherTrait};\n+use priv_dep::{OtherTrait, OtherType};\n use pub_dep::PubType;\n \n // Type from private dependency used in private\n // type - this is fine\n struct PrivateType {\n-    field: OtherType\n+    field: OtherType,\n }\n \n pub struct PublicType {\n     pub field: OtherType,\n     //~^ ERROR type `OtherType` from private dependency 'priv_dep' in public interface\n-    priv_field: OtherType, // Private field - this is fine\n-    pub other_field: PubType // Type from public dependency - this is fine\n+    priv_field: OtherType,    // Private field - this is fine\n+    pub other_field: PubType, // Type from public dependency - this is fine\n }\n \n impl PublicType {\n@@ -33,13 +33,11 @@ impl PublicType {\n pub trait MyPubTrait {\n     type Foo: OtherTrait;\n }\n-//~^^^ ERROR trait `OtherTrait` from private dependency 'priv_dep' in public interface\n+//~^^ ERROR trait `OtherTrait` from private dependency 'priv_dep' in public interface\n \n pub struct AllowedPrivType {\n     #[allow(exported_private_dependencies)]\n-    pub allowed: OtherType\n+    pub allowed: OtherType,\n }\n \n-\n-\n fn main() {}"}, {"sha": "e6b4d33f10316e4ee36e8644e0de76f4f9a2a819", "filename": "src/test/ui/privacy/pub-priv-dep/pub-priv1.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fpub-priv-dep%2Fpub-priv1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -17,12 +17,10 @@ LL |     pub fn pub_fn(param: OtherType) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: trait `OtherTrait` from private dependency 'priv_dep' in public interface\n-  --> $DIR/pub-priv1.rs:33:1\n+  --> $DIR/pub-priv1.rs:34:5\n    |\n-LL | / pub trait MyPubTrait {\n-LL | |     type Foo: OtherTrait;\n-LL | | }\n-   | |_^\n+LL |     type Foo: OtherTrait;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "381959b7ae4cda8b497da308bf3c35ae7b7042eb", "filename": "src/test/ui/question-mark-type-infer.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquestion-mark-type-infer.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,15 +1,16 @@\n-error[E0284]: type annotations needed\n+error[E0283]: type annotations needed\n   --> $DIR/question-mark-type-infer.rs:12:21\n    |\n LL |     l.iter().map(f).collect()?\n    |                     ^^^^^^^ cannot infer type\n    |\n-   = note: cannot satisfy `<_ as Try>::Ok == _`\n+   = note: cannot satisfy `_: Try`\n+   = note: required by `into_result`\n help: consider specifying the type argument in the method call\n    |\n LL |     l.iter().map(f).collect::<B>()?\n    |                            ^^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0284`.\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "2cebffec990f69177bf04e22d444b57824682c25", "filename": "src/test/ui/range/range-1.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,6 +11,8 @@ LL |     for i in false..true {}\n    |              ^^^^^^^^^^^ the trait `Step` is not implemented for `bool`\n    |\n    = note: required because of the requirements on the impl of `Iterator` for `std::ops::Range<bool>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `std::ops::Range<bool>`\n+   = note: required by `into_iter`\n \n error[E0277]: the size for values of type `[{integer}]` cannot be known at compilation time\n   --> $DIR/range-1.rs:14:17"}, {"sha": "575dfafe15efc4dc9e17b07011560a114d027133", "filename": "src/test/ui/regions/regions-assoc-type-region-bound-in-trait-not-met.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,7 +3,7 @@\n \n trait Foo<'a> {\n     type Value: 'a;\n-    fn dummy(&'a self) { }\n+    fn dummy(&'a self) {}\n }\n \n impl<'a> Foo<'a> for &'a i16 {\n@@ -12,13 +12,13 @@ impl<'a> Foo<'a> for &'a i16 {\n }\n \n impl<'a> Foo<'static> for &'a i32 {\n-    //~^ ERROR cannot infer\n     type Value = &'a i32;\n+    //~^ ERROR the type `&'a i32` does not fulfill the required lifetime\n }\n \n-impl<'a,'b> Foo<'b> for &'a i64 {\n-    //~^ ERROR cannot infer\n+impl<'a, 'b> Foo<'b> for &'a i64 {\n     type Value = &'a i32;\n+    //~^ ERROR the type `&'a i32` does not fulfill the required lifetime\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "03da33ae11ffe1ab5e15e8c7e02c5b4d95e0ffa2", "filename": "src/test/ui/regions/regions-assoc-type-region-bound-in-trait-not-met.stderr", "status": "modified", "additions": 14, "deletions": 48, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,57 +1,23 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:10\n+error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n+  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:15:5\n    |\n-LL | impl<'a> Foo<'static> for &'a i32 {\n-   |          ^^^^^^^^^^^^\n+LL |     type Value = &'a i32;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 14:6...\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:6\n-   |\n-LL | impl<'a> Foo<'static> for &'a i32 {\n-   |      ^^\n-note: ...so that the types are compatible\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:10\n-   |\n-LL | impl<'a> Foo<'static> for &'a i32 {\n-   |          ^^^^^^^^^^^^\n-   = note: expected `Foo<'static>`\n-              found `Foo<'static>`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the type `&i32` will meet its required lifetime bounds\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:10\n-   |\n-LL | impl<'a> Foo<'static> for &'a i32 {\n-   |          ^^^^^^^^^^^^\n+   = note: type must satisfy the static lifetime\n \n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:13\n-   |\n-LL | impl<'a,'b> Foo<'b> for &'a i64 {\n-   |             ^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 19:6...\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:6\n-   |\n-LL | impl<'a,'b> Foo<'b> for &'a i64 {\n-   |      ^^\n-note: ...so that the types are compatible\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:13\n+error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n+  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:20:5\n    |\n-LL | impl<'a,'b> Foo<'b> for &'a i64 {\n-   |             ^^^^^^^\n-   = note: expected `Foo<'b>`\n-              found `Foo<'_>`\n-note: but, the lifetime must be valid for the lifetime `'b` as defined on the impl at 19:9...\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:9\n+LL |     type Value = &'a i32;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | impl<'a,'b> Foo<'b> for &'a i64 {\n-   |         ^^\n-note: ...so that the type `&i32` will meet its required lifetime bounds\n-  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:13\n+note: type must outlive the lifetime `'b` as defined on the impl at 19:10\n+  --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:10\n    |\n-LL | impl<'a,'b> Foo<'b> for &'a i64 {\n-   |             ^^^^^^^\n+LL | impl<'a, 'b> Foo<'b> for &'a i64 {\n+   |          ^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0477`."}, {"sha": "00100e0e9ea75d129c78f98bcceb31139c402637", "filename": "src/test/ui/regions/regions-assoc-type-static-bound-in-trait-not-met.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,17 +3,17 @@\n \n trait Foo {\n     type Value: 'static;\n-    fn dummy(&self) { }\n+    fn dummy(&self) {}\n }\n \n impl<'a> Foo for &'a i32 {\n-    //~^ ERROR cannot infer\n     type Value = &'a i32;\n+    //~^ ERROR the type `&'a i32` does not fulfill the required lifetime\n }\n \n impl<'a> Foo for i32 {\n     // OK.\n     type Value = i32;\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "d8efeac5b8a30bc022ce72663bbc9148786ec3c9", "filename": "src/test/ui/regions/regions-assoc-type-static-bound-in-trait-not-met.stderr", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,28 +1,11 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:10\n+error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n+  --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:10:5\n    |\n-LL | impl<'a> Foo for &'a i32 {\n-   |          ^^^\n+LL |     type Value = &'a i32;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the impl at 9:6...\n-  --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:6\n-   |\n-LL | impl<'a> Foo for &'a i32 {\n-   |      ^^\n-note: ...so that the types are compatible\n-  --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:10\n-   |\n-LL | impl<'a> Foo for &'a i32 {\n-   |          ^^^\n-   = note: expected `Foo`\n-              found `Foo`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the type `&i32` will meet its required lifetime bounds\n-  --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:10\n-   |\n-LL | impl<'a> Foo for &'a i32 {\n-   |          ^^^\n+   = note: type must satisfy the static lifetime\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`.\n+For more information about this error, try `rustc --explain E0477`."}, {"sha": "6de08f66d7536920d7e11f80a45e3848de497ab0", "filename": "src/test/ui/regions/regions-enum-not-wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,36 +5,37 @@\n #![allow(dead_code)]\n \n trait Dummy<'a> {\n-  type Out;\n+    type Out;\n }\n impl<'a, T> Dummy<'a> for T\n-where T: 'a\n+where\n+    T: 'a,\n {\n-  type Out = ();\n+    type Out = ();\n }\n type RequireOutlives<'a, T> = <T as Dummy<'a>>::Out;\n \n enum Ref1<'a, T> {\n-    Ref1Variant1(RequireOutlives<'a, T>) //~ ERROR the parameter type `T` may not live long enough\n+    Ref1Variant1(RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n enum Ref2<'a, T> {\n     Ref2Variant1,\n     Ref2Variant2(isize, RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n-enum RefOk<'a, T:'a> {\n-    RefOkVariant1(&'a T)\n+enum RefOk<'a, T: 'a> {\n+    RefOkVariant1(&'a T),\n }\n \n // This is now well formed. RFC 2093\n enum RefIndirect<'a, T> {\n-    RefIndirectVariant1(isize, RefOk<'a,T>)\n+    RefIndirectVariant1(isize, RefOk<'a, T>),\n }\n \n-enum RefDouble<'a, 'b, T> { //~ ERROR the parameter type `T` may not live long enough [E0309]\n-    RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-        //~^ the parameter type `T` may not live long enough [E0309]\n+enum RefDouble<'a, 'b, T> {\n+    RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n+    //~^ the parameter type `T` may not live long enough [E0309]\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "36686eaf92f3213baf668f4f6bc4ecaf9c749696", "filename": "src/test/ui/regions/regions-enum-not-wf.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,13 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n+  --> $DIR/regions-enum-not-wf.rs:19:18\n    |\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n+LL |     Ref1Variant1(RequireOutlives<'a, T>),\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n+  --> $DIR/regions-enum-not-wf.rs:24:25\n    |\n LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n@@ -16,25 +16,13 @@ LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n    |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL |   enum RefDouble<'a, 'b, T> {\n-   |   ^                      - help: consider adding an explicit lifetime bound...: `T: 'b`\n-   |  _|\n-   | |\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^ ...so that the type `T` will meet its required lifetime bounds\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n+  --> $DIR/regions-enum-not-wf.rs:37:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n+LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "9912e88c2ec57546cf7a75be8e3fb03d8a2823ac", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,24 +6,27 @@ trait Project<'a, 'b> {\n }\n \n impl<'a, 'b> Project<'a, 'b> for ()\n-    where 'a: 'b\n+where\n+    'a: 'b,\n {\n     type Item = ();\n }\n \n // No error here, we have 'a: 'b. We used to report an error here\n // though, see https://github.com/rust-lang/rust/issues/45937.\n fn foo<'a: 'b, 'b>()\n-    where <() as Project<'a, 'b>>::Item : Eq\n+where\n+    <() as Project<'a, 'b>>::Item: Eq,\n {\n }\n \n // Here we get an error: we need `'a: 'b`.\n-fn bar<'a, 'b>() //~ ERROR cannot infer\n-                 //~| ERROR cannot infer\n-                 //~| ERROR cannot infer\n-    where <() as Project<'a, 'b>>::Item : Eq\n+fn bar<'a, 'b>()\n+//~^ ERROR cannot infer\n+//~| ERROR cannot infer\n+where\n+    <() as Project<'a, 'b>>::Item: Eq,\n {\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "ddb2b31ce10959540a652fac8f6caa3f5db9cb97", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.stderr", "status": "modified", "additions": 19, "deletions": 47, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,87 +1,59 @@\n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n    |\n LL | / fn bar<'a, 'b>()\n LL | |\n LL | |\n-LL | |     where <() as Project<'a, 'b>>::Item : Eq\n-   | |____________________________________________^\n+LL | | where\n+LL | |     <() as Project<'a, 'b>>::Item: Eq,\n+   | |______________________________________^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 24:8...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:8\n    |\n LL | fn bar<'a, 'b>()\n    |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 24:12...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:12\n    |\n LL | fn bar<'a, 'b>()\n    |            ^^\n note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:1\n    |\n LL | / fn bar<'a, 'b>()\n LL | |\n LL | |\n-LL | |     where <() as Project<'a, 'b>>::Item : Eq\n-   | |____________________________________________^\n+LL | | where\n+LL | |     <() as Project<'a, 'b>>::Item: Eq,\n+   | |______________________________________^\n    = note: expected `Project<'a, 'b>`\n               found `Project<'_, '_>`\n \n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n-   |\n-LL | / fn bar<'a, 'b>()\n-LL | |\n-LL | |\n-LL | |     where <() as Project<'a, 'b>>::Item : Eq\n-   | |____________________________________________^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n-   |\n-LL | fn bar<'a, 'b>()\n-   |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n-   |\n-LL | fn bar<'a, 'b>()\n-   |            ^^\n-note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n-   |\n-LL | / fn bar<'a, 'b>()\n-LL | |\n-LL | |\n-LL | |     where <() as Project<'a, 'b>>::Item : Eq\n-   | |____________________________________________^\n-   = note: expected `Project<'a, 'b>`\n-              found `Project<'_, '_>`\n-\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:4\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:4\n    |\n LL | fn bar<'a, 'b>()\n    |    ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 22:8...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:8\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 24:8...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:8\n    |\n LL | fn bar<'a, 'b>()\n    |        ^^\n-note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 22:12...\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:12\n+note: ...but the lifetime must also be valid for the lifetime `'b` as defined on the function body at 24:12...\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:12\n    |\n LL | fn bar<'a, 'b>()\n    |            ^^\n note: ...so that the types are compatible\n-  --> $DIR/regions-normalize-in-where-clause-list.rs:22:4\n+  --> $DIR/regions-normalize-in-where-clause-list.rs:24:4\n    |\n LL | fn bar<'a, 'b>()\n    |    ^^^\n    = note: expected `Project<'a, 'b>`\n               found `Project<'_, '_>`\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0495`."}, {"sha": "b6dab1c32e8b291e1212c9e322447d7afb926788", "filename": "src/test/ui/regions/regions-trait-1.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,30 +1,33 @@\n-#![feature(box_syntax)]\n+// check-pass\n \n-struct Ctxt { v: usize }\n+struct Ctxt {\n+    v: usize,\n+}\n \n trait GetCtxt {\n     // Here the `&` is bound in the method definition:\n     fn get_ctxt(&self) -> &Ctxt;\n }\n \n-struct HasCtxt<'a> { c: &'a Ctxt }\n+struct HasCtxt<'a> {\n+    c: &'a Ctxt,\n+}\n \n impl<'a> GetCtxt for HasCtxt<'a> {\n-\n-    // Here an error occurs because we used `&self` but\n-    // the definition used `&`:\n-    fn get_ctxt(&self) -> &'a Ctxt { //~ ERROR method not compatible with trait\n+    // Ok: Have implied bound of WF(&'b HasCtxt<'a>)\n+    // so know 'a: 'b\n+    // so know &'a Ctxt <: &'b Ctxt\n+    fn get_ctxt<'b>(&'b self) -> &'a Ctxt {\n         self.c\n     }\n-\n }\n \n-fn get_v(gc: Box<dyn GetCtxt>) -> usize {\n+fn get_v(gc: Box<dyn GetCtxt + '_>) -> usize {\n     gc.get_ctxt().v\n }\n \n fn main() {\n     let ctxt = Ctxt { v: 22 };\n     let hc = HasCtxt { c: &ctxt };\n-    assert_eq!(get_v(box hc as Box<dyn GetCtxt>), 22);\n+    assert_eq!(get_v(Box::new(hc) as Box<dyn GetCtxt>), 22);\n }"}, {"sha": "92d96a722d4e913e7e9ca0ae1691d1ac7837e35a", "filename": "src/test/ui/regions/regions-trait-1.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-1.stderr?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -1,22 +0,0 @@\n-error[E0308]: method not compatible with trait\n-  --> $DIR/regions-trait-1.rs:16:5\n-   |\n-LL |     fn get_ctxt(&self) -> &'a Ctxt {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected fn pointer `fn(&HasCtxt<'a>) -> &Ctxt`\n-              found fn pointer `fn(&HasCtxt<'a>) -> &'a Ctxt`\n-note: the lifetime `'a` as defined on the impl at 12:6...\n-  --> $DIR/regions-trait-1.rs:12:6\n-   |\n-LL | impl<'a> GetCtxt for HasCtxt<'a> {\n-   |      ^^\n-note: ...does not necessarily outlive the anonymous lifetime #1 defined on the method body at 16:5\n-  --> $DIR/regions-trait-1.rs:16:5\n-   |\n-LL |     fn get_ctxt(&self) -> &'a Ctxt {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "6de08f66d7536920d7e11f80a45e3848de497ab0", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,36 +5,37 @@\n #![allow(dead_code)]\n \n trait Dummy<'a> {\n-  type Out;\n+    type Out;\n }\n impl<'a, T> Dummy<'a> for T\n-where T: 'a\n+where\n+    T: 'a,\n {\n-  type Out = ();\n+    type Out = ();\n }\n type RequireOutlives<'a, T> = <T as Dummy<'a>>::Out;\n \n enum Ref1<'a, T> {\n-    Ref1Variant1(RequireOutlives<'a, T>) //~ ERROR the parameter type `T` may not live long enough\n+    Ref1Variant1(RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n enum Ref2<'a, T> {\n     Ref2Variant1,\n     Ref2Variant2(isize, RequireOutlives<'a, T>), //~ ERROR the parameter type `T` may not live long enough\n }\n \n-enum RefOk<'a, T:'a> {\n-    RefOkVariant1(&'a T)\n+enum RefOk<'a, T: 'a> {\n+    RefOkVariant1(&'a T),\n }\n \n // This is now well formed. RFC 2093\n enum RefIndirect<'a, T> {\n-    RefIndirectVariant1(isize, RefOk<'a,T>)\n+    RefIndirectVariant1(isize, RefOk<'a, T>),\n }\n \n-enum RefDouble<'a, 'b, T> { //~ ERROR the parameter type `T` may not live long enough [E0309]\n-    RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-        //~^ the parameter type `T` may not live long enough [E0309]\n+enum RefDouble<'a, 'b, T> {\n+    RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n+    //~^ the parameter type `T` may not live long enough [E0309]\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "36686eaf92f3213baf668f4f6bc4ecaf9c749696", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,13 +1,13 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n+  --> $DIR/regions-enum-not-wf.rs:19:18\n    |\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n+LL |     Ref1Variant1(RequireOutlives<'a, T>),\n    |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n+  --> $DIR/regions-enum-not-wf.rs:24:25\n    |\n LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n@@ -16,25 +16,13 @@ LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n    |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL |   enum RefDouble<'a, 'b, T> {\n-   |   ^                      - help: consider adding an explicit lifetime bound...: `T: 'b`\n-   |  _|\n-   | |\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^ ...so that the type `T` will meet its required lifetime bounds\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n+  --> $DIR/regions-enum-not-wf.rs:37:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n+LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>),\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "4c21f8db8fad864a88cb742ab75d3b61521ab213", "filename": "src/test/ui/specialization/deafult-associated-type-bound-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n   --> $DIR/deafult-associated-type-bound-1.rs:18:5\n    |\n LL |     type U: Clone;\n-   |     -------------- required by `X::U`\n+   |             ----- required by this bound in `X::U`\n ...\n LL |     default type U = str;\n    |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `str`"}, {"sha": "8c9da81d277efd4b454d86ffdbff2978995ead12", "filename": "src/test/ui/specialization/deafult-associated-type-bound-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-associated-type-bound-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -11,7 +11,7 @@ error[E0277]: can't compare `&'static B` with `B`\n   --> $DIR/deafult-associated-type-bound-2.rs:16:5\n    |\n LL |     type U: PartialEq<T>;\n-   |     --------------------- required by `X::U`\n+   |             ------------ required by this bound in `X::U`\n ...\n LL |     default type U = &'static B;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&'static B == B`"}, {"sha": "f14588e6e023c9aba6bad6125b87f4a1a7e6985a", "filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,7 +6,7 @@\n //~^^ WARNING the feature `generic_associated_types` is incomplete\n \n trait X {\n-    type U<'a>: PartialEq<&'a Self>;\n+    type U<'a>: PartialEq<&'a Self> where Self: 'a;\n     fn unsafe_compare<'b>(x: Option<Self::U<'b>>, y: Option<&'b Self>) {\n         match (x, y) {\n             (Some(a), Some(b)) => a == b,"}, {"sha": "f145b90f216ab9df0651e26921cfa2bdd7ff9ed6", "filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdeafult-generic-associated-type-bound.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -18,8 +18,8 @@ LL | #![feature(generic_associated_types)]\n error[E0277]: can't compare `T` with `T`\n   --> $DIR/deafult-generic-associated-type-bound.rs:19:5\n    |\n-LL |     type U<'a>: PartialEq<&'a Self>;\n-   |     -------------------------------- required by `X::U`\n+LL |     type U<'a>: PartialEq<&'a Self> where Self: 'a;\n+   |                 ------------------- required by this bound in `X::U`\n ...\n LL |     default type U<'a> = &'a T;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `T == T`"}, {"sha": "9ed0b240d0a0f43db02767c9762d977fb342b131", "filename": "src/test/ui/specialization/issue-38091-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,28 @@\n+// build-fail\n+//~^ ERROR overflow evaluating the requirement `i32: Check`\n+\n+#![feature(specialization)]\n+//~^ WARN the feature `specialization` is incomplete\n+\n+trait Iterate<'a> {\n+    type Ty: Valid;\n+    fn iterate(self);\n+}\n+impl<'a, T> Iterate<'a> for T\n+where\n+    T: Check,\n+{\n+    default type Ty = ();\n+    default fn iterate(self) {}\n+}\n+\n+trait Check {}\n+impl<'a, T> Check for T where <T as Iterate<'a>>::Ty: Valid {}\n+\n+trait Valid {}\n+\n+impl Valid for () {}\n+\n+fn main() {\n+    Iterate::iterate(0);\n+}"}, {"sha": "a314c26ad147db90096727bae35c4fa63d9e3813", "filename": "src/test/ui/specialization/issue-38091-2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,16 @@\n+warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-38091-2.rs:4:12\n+   |\n+LL | #![feature(specialization)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n+\n+error[E0275]: overflow evaluating the requirement `i32: Check`\n+   |\n+   = note: required because of the requirements on the impl of `Iterate` for `i32`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "5b398368a6733122040d7dc55662c3b6f0e695eb", "filename": "src/test/ui/specialization/issue-38091.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,7 +5,10 @@ trait Iterate<'a> {\n     type Ty: Valid;\n     fn iterate(self);\n }\n-impl<'a, T> Iterate<'a> for T where T: Check {\n+impl<'a, T> Iterate<'a> for T\n+where\n+    T: Check,\n+{\n     default type Ty = ();\n     //~^ ERROR the trait bound `(): Valid` is not satisfied\n     default fn iterate(self) {}", "previous_filename": "src/test/ui/issues/issue-38091.rs"}, {"sha": "6be0f26849f90717e19446a925ba5934b2f4ce7f", "filename": "src/test/ui/specialization/issue-38091.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-38091.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,10 +8,10 @@ LL | #![feature(specialization)]\n    = note: see issue #31844 <https://github.com/rust-lang/rust/issues/31844> for more information\n \n error[E0277]: the trait bound `(): Valid` is not satisfied\n-  --> $DIR/issue-38091.rs:9:5\n+  --> $DIR/issue-38091.rs:12:5\n    |\n LL |     type Ty: Valid;\n-   |     --------------- required by `Iterate::Ty`\n+   |              ----- required by this bound in `Iterate::Ty`\n ...\n LL |     default type Ty = ();\n    |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Valid` is not implemented for `()`", "previous_filename": "src/test/ui/issues/issue-38091.stderr"}, {"sha": "3935a4a5f9931b863c1efb910c99f862f1b66bb7", "filename": "src/test/ui/specialization/issue-44861.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-44861.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-44861.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-44861.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `(): CoerceUnsized<*const [u8]>` is not satisfied\n   --> $DIR/issue-44861.rs:21:5\n    |\n LL |     type Data2: CoerceUnsized<*const [u8]>;\n-   |     --------------------------------------- required by `Smartass::Data2`\n+   |                 -------------------------- required by this bound in `Smartass::Data2`\n ...\n LL |     default type Data2 = ();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `CoerceUnsized<*const [u8]>` is not implemented for `()`"}, {"sha": "f3f8b022b01e12309f19b125aa03bf9c352bbfcd", "filename": "src/test/ui/specialization/issue-59435.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-59435.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fspecialization%2Fissue-59435.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fissue-59435.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `MyStruct: Default` is not satisfied\n   --> $DIR/issue-59435.rs:11:5\n    |\n LL |     type MyType: Default;\n-   |     --------------------- required by `MyTrait::MyType`\n+   |                  ------- required by this bound in `MyTrait::MyType`\n ...\n LL |     default type MyType = MyStruct;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `MyStruct`"}, {"sha": "d826222a06ae5d95fbd5838bc2b3fac95821e218", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,8 +5,6 @@ LL | fn foo() -> impl Bar {\n    |             ^^^^^^^^ the trait `Bar` is not implemented for `()`\n LL |     5;\n    |      - consider removing this semicolon\n-   |\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "4954a8a6965be828ed807a35323845ec784e9797", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,5 +1,4 @@\n-// Running rustfix would cause the same suggestion to be applied multiple times, which results in\n-// invalid code.\n+// check-pass\n \n trait Parent {\n     type Ty;\n@@ -15,11 +14,8 @@ impl<A, T> Child<A> for ChildWrapper<T> where T: Child<A> {}\n struct ParentWrapper<T>(T);\n \n impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n-    //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n     type Ty = A;\n     type Assoc = ChildWrapper<T::Assoc>;\n-    //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-    //~| ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n }\n \n fn main() {}"}, {"sha": "a8ea2147961839c9fcda2bccd00c66660a0e6210", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.stderr", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -1,55 +0,0 @@\n-error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:17:19\n-   |\n-LL | trait Parent {\n-   |       ------ required by a bound in this\n-LL |     type Ty;\n-LL |     type Assoc: Child<Self::Ty>;\n-   |                 --------------- required by this bound in `Parent`\n-...\n-LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n-   |                   ^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n-   |\n-help: consider further restricting the associated type\n-   |\n-LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> where <T as Parent>::Assoc: Child<A> {\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:20:18\n-   |\n-LL | trait Parent {\n-   |       ------ required by a bound in this\n-LL |     type Ty;\n-LL |     type Assoc: Child<Self::Ty>;\n-   |                 --------------- required by this bound in `Parent`\n-...\n-LL |     type Assoc = ChildWrapper<T::Assoc>;\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n-   |\n-   = note: required because of the requirements on the impl of `Child<A>` for `ChildWrapper<<T as Parent>::Assoc>`\n-help: consider further restricting the associated type\n-   |\n-LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> where <T as Parent>::Assoc: Child<A> {\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n-  --> $DIR/missing-assoc-type-bound-restriction.rs:20:5\n-   |\n-LL | trait Parent {\n-   |       ------ required by a bound in this\n-LL |     type Ty;\n-LL |     type Assoc: Child<Self::Ty>;\n-   |                 --------------- required by this bound in `Parent`\n-...\n-LL |     type Assoc = ChildWrapper<T::Assoc>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n-   |\n-help: consider further restricting the associated type\n-   |\n-LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> where <T as Parent>::Assoc: Child<A> {\n-   |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "4aa0ad219cf25fc1c26e03255af628b6f9fdb4c3", "filename": "src/test/ui/suggestions/suggest-remove-refs-1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,6 +8,7 @@ LL |     for (i, _) in &v.iter().enumerate() {\n    |                   help: consider removing the leading `&`-reference\n    |\n    = help: the trait `Iterator` is not implemented for `&Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "15c4b7fcb8b3b089ba3950c18a06c84aec08b08d", "filename": "src/test/ui/suggestions/suggest-remove-refs-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,6 +8,7 @@ LL |     for (i, _) in & & & & &v.iter().enumerate() {\n    |                   help: consider removing 5 leading `&`-references\n    |\n    = help: the trait `Iterator` is not implemented for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "0bd6d956aff97196e00bb9d17151f98feeba0814", "filename": "src/test/ui/suggestions/suggest-remove-refs-3.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-remove-refs-3.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -12,6 +12,7 @@ LL | |          .enumerate() {\n    | |_____________________^ `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&&&&&Enumerate<std::slice::Iter<'_, {integer}>>`\n    = note: required by `into_iter`\n \n error: aborting due to previous error"}, {"sha": "b1f124c7ea26aedbb3774e02d6d8f99ba2f4d6e1", "filename": "src/test/ui/traits/check-trait-object-bounds-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,14 @@\n+// Check that we validate associated type bounds for trait objects\n+\n+trait X {\n+    type Y: Clone;\n+}\n+\n+fn f<T: X + ?Sized>() {\n+    None::<T::Y>.clone();\n+}\n+\n+fn main() {\n+    f::<dyn X<Y = str>>();\n+    //~^ ERROR the trait bound `str: Clone` is not satisfied\n+}"}, {"sha": "170ed6eacfd4174c43b4bbd86a909afe88662c1c", "filename": "src/test/ui/traits/check-trait-object-bounds-1.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-1.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `str: Clone` is not satisfied\n+  --> $DIR/check-trait-object-bounds-1.rs:12:5\n+   |\n+LL | fn f<T: X + ?Sized>() {\n+   |         - required by this bound in `f`\n+...\n+LL |     f::<dyn X<Y = str>>();\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1422dda276b9b0a78eba0956d6ac92543f909b3f", "filename": "src/test/ui/traits/check-trait-object-bounds-2-ok.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2-ok.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,15 @@\n+// Make sure that we're handling bound lifetimes correctly when validating trait\n+// bounds.\n+// run-pass\n+\n+trait X<'a> {\n+    type F: FnOnce(&i32) -> &'a i32;\n+}\n+\n+fn f<T: for<'r> X<'r> + ?Sized>() {\n+    None::<T::F>.map(|f| f(&0));\n+}\n+\n+fn main() {\n+    f::<dyn for<'x> X<'x, F = fn(&i32) -> &'x i32>>();\n+}"}, {"sha": "eb2fb6e841bce2e2b1454df1ad0cbd2489919f15", "filename": "src/test/ui/traits/check-trait-object-bounds-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,15 @@\n+// Check that we validate associated type bounds for trait objects when they\n+// have bound lifetimes\n+\n+trait X<'a> {\n+    type F: FnOnce(&i32) -> &'a i32;\n+}\n+\n+fn f<T: for<'r> X<'r> + ?Sized>() {\n+    None::<T::F>.map(|f| f(&0));\n+}\n+\n+fn main() {\n+    f::<dyn for<'x> X<'x, F = i32>>();\n+    //~^ expected a `FnOnce<(&i32,)>` closure, found `i32`\n+}"}, {"sha": "04e2348634ed805b54c55f6147d2df86a53159d4", "filename": "src/test/ui/traits/check-trait-object-bounds-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: expected a `FnOnce<(&i32,)>` closure, found `i32`\n+  --> $DIR/check-trait-object-bounds-2.rs:13:5\n+   |\n+LL | fn f<T: for<'r> X<'r> + ?Sized>() {\n+   |         ------------- required by this bound in `f`\n+...\n+LL |     f::<dyn for<'x> X<'x, F = i32>>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an `FnOnce<(&i32,)>` closure, found `i32`\n+   |\n+   = help: the trait `for<'r> FnOnce<(&'r i32,)>` is not implemented for `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ba04fd93accec2e8b417517f7b6ff36787c7207b", "filename": "src/test/ui/traits/check-trait-object-bounds-3.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,20 @@\n+// Check that we validate associated type bounds for trait objects\n+\n+trait X<'a> {\n+    type Y: Into<&'static str> + From<&'a str>;\n+}\n+\n+fn f<'a, T: X<'a> + ?Sized>(s: &'a str) -> &'static str {\n+    T::Y::from(s).into()\n+}\n+\n+pub fn main() {\n+    let z;\n+    {\n+        let s = String::from(\"abcdef\");\n+        z = f::<dyn X<Y = &str>>(&s);\n+        //~^ ERROR `s` does not live long enough\n+    }\n+\n+    println!(\"{}\", z)\n+}"}, {"sha": "ade552c4bab41a0dc45c5c500247cce82888300d", "filename": "src/test/ui/traits/check-trait-object-bounds-3.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-3.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `s` does not live long enough\n+  --> $DIR/check-trait-object-bounds-3.rs:15:34\n+   |\n+LL |         z = f::<dyn X<Y = &str>>(&s);\n+   |             ---------------------^^-\n+   |             |                    |\n+   |             |                    borrowed value does not live long enough\n+   |             argument requires that `s` is borrowed for `'static`\n+LL |\n+LL |     }\n+   |     - `s` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "e9ca1563f3b67cfa182ddac0e708d01adde405b9", "filename": "src/test/ui/traits/check-trait-object-bounds-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,17 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Super {\n+    type Y: Clone;\n+}\n+\n+trait X: Super {}\n+\n+fn f<T: X + ?Sized>() {\n+    None::<T::Y>.clone();\n+}\n+\n+fn main() {\n+    f::<dyn X<Y = str>>();\n+    //~^ ERROR the trait bound `str: Clone` is not satisfied\n+}"}, {"sha": "fc9f31c5ebc7e91a7fe600d27af57ef99dc3ffe1", "filename": "src/test/ui/traits/check-trait-object-bounds-4.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-4.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+error[E0277]: the trait bound `str: Clone` is not satisfied\n+  --> $DIR/check-trait-object-bounds-4.rs:15:5\n+   |\n+LL | fn f<T: X + ?Sized>() {\n+   |         - required by this bound in `f`\n+...\n+LL |     f::<dyn X<Y = str>>();\n+   |     ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7d733ad26b7528a45d1d98e8d7fc45eb5bcb0f91", "filename": "src/test/ui/traits/check-trait-object-bounds-5.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,27 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Super {\n+    type V;\n+}\n+\n+trait Obj: Super {\n+    type U: Is<T = Self::V>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i64>) {\n+    is_obj(x)\n+    //~^ type mismatch resolving `<i32 as Is>::T == i64`\n+}\n+\n+fn main() {}"}, {"sha": "bd2b789cd990896d29c3776659d051bd48f5bf89", "filename": "src/test/ui/traits/check-trait-object-bounds-5.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-5.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n+  --> $DIR/check-trait-object-bounds-5.rs:23:5\n+   |\n+LL | fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+   |                       --- required by this bound in `is_obj`\n+...\n+LL |     is_obj(x)\n+   |     ^^^^^^ expected `i64`, found `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "cb196d67f673d5467f5d3c3dccb76d9fbfd6d0f3", "filename": "src/test/ui/traits/check-trait-object-bounds-6.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,24 @@\n+// Check that we validate associated type bounds on super traits for trait\n+// objects\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i64>) {\n+    is_obj(x)\n+    //~^ ERROR type mismatch resolving `<i32 as Is>::T == i64`\n+}\n+\n+fn main() {}"}, {"sha": "ea1fdaf46f6ae602dc9be10ea72853b78595d68f", "filename": "src/test/ui/traits/check-trait-object-bounds-6.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcheck-trait-object-bounds-6.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,12 @@\n+error[E0271]: type mismatch resolving `<i32 as Is>::T == i64`\n+  --> $DIR/check-trait-object-bounds-6.rs:20:5\n+   |\n+LL | fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+   |                       --- required by this bound in `is_obj`\n+...\n+LL |     is_obj(x)\n+   |     ^^^^^^ expected `i64`, found `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "98bfcb8d67b516eafb8948ee05d6a0c8a48f32bb", "filename": "src/test/ui/traits/cycle-cache-err-60010.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -24,11 +24,13 @@ struct Runtime<DB: Database> {\n     _storage: Box<DB::Storage>,\n }\n struct SalsaStorage {\n-    _parse: <ParseQuery as Query<RootDatabase>>::Data, //~ ERROR overflow\n+    _parse: <ParseQuery as Query<RootDatabase>>::Data,\n }\n \n impl Database for RootDatabase {\n-    type Storage = SalsaStorage; //~ ERROR overflow\n+    // This would also be an error if we didn't abort compilation on the error\n+    // above.\n+    type Storage = SalsaStorage;\n }\n impl HasQueryGroup for RootDatabase {}\n impl<DB> Query<DB> for ParseQuery\n@@ -65,6 +67,7 @@ pub(crate) fn goto_implementation(db: &RootDatabase) -> u32 {\n     // we used to fail to report an error here because we got the\n     // caching wrong.\n     SourceDatabase::parse(db);\n+    //~^ ERROR overflow\n     22\n }\n "}, {"sha": "b2702d977f8b6c3152041abe0057f912e7d274e5", "filename": "src/test/ui/traits/cycle-cache-err-60010.stderr", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcycle-cache-err-60010.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,27 +1,19 @@\n-error[E0275]: overflow evaluating the requirement `RootDatabase: SourceDatabase`\n-  --> $DIR/cycle-cache-err-60010.rs:27:13\n+error[E0275]: overflow evaluating the requirement `SalsaStorage: RefUnwindSafe`\n+  --> $DIR/cycle-cache-err-60010.rs:69:5\n    |\n-LL |     _parse: <ParseQuery as Query<RootDatabase>>::Data,\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n-\n-error[E0275]: overflow evaluating the requirement `Runtime<RootDatabase>: RefUnwindSafe`\n-  --> $DIR/cycle-cache-err-60010.rs:31:20\n-   |\n-LL | trait Database {\n-   |       -------- required by a bound in this\n-LL |     type Storage;\n-   |     ------------- required by this bound in `Database`\n+LL |     fn parse(&self) {\n+   |     --------------- required by `SourceDatabase::parse`\n ...\n-LL |     type Storage = SalsaStorage;\n-   |                    ^^^^^^^^^^^^\n+LL |     SourceDatabase::parse(db);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: required because it appears within the type `*const SalsaStorage`\n+   = note: required because it appears within the type `Unique<SalsaStorage>`\n+   = note: required because it appears within the type `Box<SalsaStorage>`\n+   = note: required because it appears within the type `Runtime<RootDatabase>`\n    = note: required because it appears within the type `RootDatabase`\n    = note: required because of the requirements on the impl of `SourceDatabase` for `RootDatabase`\n-   = note: required because of the requirements on the impl of `Query<RootDatabase>` for `ParseQuery`\n-   = note: required because it appears within the type `SalsaStorage`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0275`."}, {"sha": "3146764927cd815393eee1cb41dc4ceb96782fce", "filename": "src/test/ui/traits/trait-object-bounds-cycle-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-1.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,24 @@\n+// Check that we don't have a cycle when we try to normalize `Self::U` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::U>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "4c1df38058dad702019acfcd1f4f34cdce0782e2", "filename": "src/test/ui/traits/trait-object-bounds-cycle-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,28 @@\n+// Check that we don't have a cycle when we try to normalize `Self::V` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Super {\n+    type V;\n+}\n+\n+trait Obj: Super {\n+    type U: Is<T = Self::V>;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "55726a5ae4557d21e6cd5cef7c1e5c0055d2f708", "filename": "src/test/ui/traits/trait-object-bounds-cycle-3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-3.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,25 @@\n+// Check that we don't have a cycle when we try to normalize `Self::V` in the\n+// bound below.\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<T: ?Sized + Obj>(_: &T) {}\n+\n+fn f(x: &dyn Obj<U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "f83cb75c7f29b8d46b244c177c9ab97f4447859f", "filename": "src/test/ui/traits/trait-object-bounds-cycle-4.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-bounds-cycle-4.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,25 @@\n+// Check that we don't have a cycle when we try to normalize `Self::U` in the\n+// bound below. Make sure that having a lifetime on the trait object doesn't break things\n+\n+// check-pass\n+\n+trait Is {\n+    type T;\n+}\n+\n+impl<U> Is for U {\n+    type T = U;\n+}\n+\n+trait Obj<'a> {\n+    type U: Is<T = Self::V>;\n+    type V;\n+}\n+\n+fn is_obj<'a, T: ?Sized + Obj<'a>>(_: &T) {}\n+\n+fn f<'a>(x: &dyn Obj<'a, U = i32, V = i32>) {\n+    is_obj(x)\n+}\n+\n+fn main() {}"}, {"sha": "9d834727a4a1bcf45754ec6db1ccef66ba9f78fc", "filename": "src/test/ui/traits/trait-object-supertrait-lifetime-bound.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-supertrait-lifetime-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-supertrait-lifetime-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-supertrait-lifetime-bound.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+use std::any::Any;\n+\n+trait A<T>: Any {\n+    fn m(&self) {}\n+}\n+\n+impl<S, T: 'static> A<S> for T {}\n+\n+fn call_obj<'a>() {\n+    let obj: &dyn A<&'a ()> = &();\n+    obj.m();\n+}\n+\n+fn main() {}"}, {"sha": "463b55d8581f8512d66b06ff0294f290fd6ac321", "filename": "src/test/ui/traits/traits-inductive-overflow-two-traits.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -9,6 +9,7 @@ pub trait Magic {\n }\n impl<T: Magic> Magic for T {\n     type X = Self;\n+    //~^ ERROR E0277\n }\n \n fn check<T: Trait>() {}"}, {"sha": "996544ae5162da06080dfb7523766174a43e23d2", "filename": "src/test/ui/traits/traits-inductive-overflow-two-traits.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-inductive-overflow-two-traits.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,12 +1,27 @@\n+error[E0277]: `T` cannot be shared between threads safely\n+  --> $DIR/traits-inductive-overflow-two-traits.rs:11:5\n+   |\n+LL |     type X: Trait;\n+   |             ----- required by this bound in `Magic::X`\n+...\n+LL |     type X = Self;\n+   |     ^^^^^^^^^^^^^^ `T` cannot be shared between threads safely\n+   |\n+help: consider further restricting this bound\n+   |\n+LL | impl<T: Magic + Sync> Magic for T {\n+   |               ^^^^^^\n+\n error[E0275]: overflow evaluating the requirement `*mut (): Magic`\n-  --> $DIR/traits-inductive-overflow-two-traits.rs:19:5\n+  --> $DIR/traits-inductive-overflow-two-traits.rs:20:5\n    |\n LL | fn wizard<T: Magic>() { check::<<T as Magic>::X>(); }\n    |              ----- required by this bound in `wizard`\n ...\n LL |     wizard::<*mut ()>();\n    |     ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0275`.\n+Some errors have detailed explanations: E0275, E0277.\n+For more information about an error, try `rustc --explain E0275`."}, {"sha": "496ba145810fbc526e989d9a195abeedf05e3412", "filename": "src/test/ui/try-block/try-block-bad-type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -14,7 +14,9 @@ pub fn main() {\n \n     let res: Result<i32, i32> = try { }; //~ ERROR type mismatch\n \n-    let res: () = try { }; //~ the trait bound `(): Try` is not satisfied\n+    let res: () = try { };\n+    //~^ ERROR the trait bound `(): Try` is not satisfied\n+    //~| ERROR the trait bound `(): Try` is not satisfied\n \n     let res: i32 = try { 5 }; //~ ERROR the trait bound `i32: Try` is not satisfied\n }"}, {"sha": "cadf3a841c961e5ea94c58da5d0bdbf98dcf25b7", "filename": "src/test/ui/try-block/try-block-bad-type.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -26,22 +26,28 @@ LL |     let res: Result<i32, i32> = try { };\n    |                                       ^ expected `i32`, found `()`\n \n error[E0277]: the trait bound `(): Try` is not satisfied\n-  --> $DIR/try-block-bad-type.rs:17:23\n+  --> $DIR/try-block-bad-type.rs:17:25\n    |\n LL |     let res: () = try { };\n-   |                       ^^^ the trait `Try` is not implemented for `()`\n+   |                         ^ the trait `Try` is not implemented for `()`\n    |\n    = note: required by `from_ok`\n \n+error[E0277]: the trait bound `(): Try` is not satisfied\n+  --> $DIR/try-block-bad-type.rs:17:25\n+   |\n+LL |     let res: () = try { };\n+   |                         ^ the trait `Try` is not implemented for `()`\n+\n error[E0277]: the trait bound `i32: Try` is not satisfied\n-  --> $DIR/try-block-bad-type.rs:19:24\n+  --> $DIR/try-block-bad-type.rs:21:26\n    |\n LL |     let res: i32 = try { 5 };\n-   |                        ^^^^^ the trait `Try` is not implemented for `i32`\n+   |                          ^ the trait `Try` is not implemented for `i32`\n    |\n    = note: required by `from_ok`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n Some errors have detailed explanations: E0271, E0277.\n For more information about an error, try `rustc --explain E0271`."}, {"sha": "75a4e8d065cab65dcd42b632014f1ff47ac30610", "filename": "src/test/ui/try-block/try-block-in-while.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `bool: Try` is not satisfied\n-  --> $DIR/try-block-in-while.rs:6:15\n+  --> $DIR/try-block-in-while.rs:6:17\n    |\n LL |     while try { false } {}\n-   |               ^^^^^^^^^ the trait `Try` is not implemented for `bool`\n+   |                 ^^^^^ the trait `Try` is not implemented for `bool`\n    |\n    = note: required by `from_ok`\n "}, {"sha": "c0359159aebeac4e0eaee315bf260c6351b100c1", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,19 @@\n+// Make sure that we check that impl trait types implement the traits that they\n+// claim to.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type X<T> = impl Clone;\n+//~^ ERROR the trait bound `T: Clone` is not satisfied\n+\n+fn f<T: Clone>(t: T) -> X<T> {\n+    t\n+}\n+\n+fn g<T>(o: Option<X<T>>) -> Option<X<T>> {\n+    o.clone()\n+}\n+\n+fn main() {\n+    g(None::<X<&mut ()>>);\n+}"}, {"sha": "26a2f4135cb0a8108a0fd9afbe2dcd1691b9dbfc", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked-2.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the trait bound `T: Clone` is not satisfied\n+  --> $DIR/bounds-are-checked-2.rs:6:13\n+   |\n+LL | type X<T> = impl Clone;\n+   |             ^^^^^^^^^^ the trait `Clone` is not implemented for `T`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | type X<T: Clone> = impl Clone;\n+   |         ^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "759bf4f4f0deec895cbf66c81e696a85154d4ebd", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,25 @@\n+// Make sure that we check that impl trait types implement the traits that they\n+// claim to.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type X<'a> = impl Into<&'static str> + From<&'a str>;\n+//~^ ERROR mismatched types\n+\n+fn f<'a: 'static>(t: &'a str) -> X<'a> {\n+    //~^ WARNING unnecessary lifetime parameter\n+    t\n+}\n+\n+fn extend_lt<'a>(o: &'a str) -> &'static str {\n+    X::<'_>::from(o).into()\n+}\n+\n+fn main() {\n+    let r =\n+    {\n+        let s = \"abcdef\".to_string();\n+        extend_lt(&s)\n+    };\n+    println!(\"{}\", r);\n+}"}, {"sha": "d5fafe05887b9e1175e473810bd85f587d3a9b8d", "filename": "src/test/ui/type-alias-impl-trait/bounds-are-checked.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbounds-are-checked.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -0,0 +1,26 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/bounds-are-checked.rs:9:6\n+   |\n+LL | fn f<'a: 'static>(t: &'a str) -> X<'a> {\n+   |      ^^^^^^^^^^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bounds-are-checked.rs:6:14\n+   |\n+LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected trait `From<&'a str>`\n+              found trait `From<&'static str>`\n+note: the lifetime `'a` as defined on the item at 6:8...\n+  --> $DIR/bounds-are-checked.rs:6:8\n+   |\n+LL | type X<'a> = impl Into<&'static str> + From<&'a str>;\n+   |        ^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c17d595dbb3ad23e07b33f73bad8e6b4dee960d8", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use10.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use10.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,11 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n #![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-type Two<T, U> = impl Debug;\n+type Two<T: Debug, U> = impl Debug;\n \n fn two<T: Debug, U: Debug>(t: T, _: U) -> Two<T, U> {\n     (t, 4u32)"}, {"sha": "dd2f202cf5dc0305b8d5283f31412de0093f5066", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use5.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,12 +6,14 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n+//~| ERROR `U` doesn't implement `Debug`\n \n fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n     (t, u)\n }\n \n fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n-//~^ concrete type differs from previous\n+    //~^ concrete type differs from previous\n     (u, t)\n }"}, {"sha": "b4aed4a6323bff2728d37f629dd22e8df4b0815e", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use5.stderr", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use5.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,39 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use5.rs:14:1\n+  --> $DIR/generic_duplicate_param_use5.rs:16:1\n    |\n LL | fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `(T, U)`, got `(U, T)`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use5.rs:10:1\n+  --> $DIR/generic_duplicate_param_use5.rs:12:1\n    |\n LL | fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use5.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(T, U)`\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: Debug, U> = impl Debug;\n+   |           ^^^^^^^\n+\n+error[E0277]: `U` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use5.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(T, U)`\n+help: consider restricting type parameter `U`\n+   |\n+LL | type Two<T, U: Debug> = impl Debug;\n+   |              ^^^^^^^\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d54d3cd62e0209c91734996228a2c51b1c33b103", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,12 +6,13 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n \n fn two<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n     (t, t)\n }\n \n fn three<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n-    //~^ concrete type differs from previous\n+    //~^ ERROR concrete type differs from previous\n     (u, t)\n }"}, {"sha": "22e4d006674929a6a3f750583b0442a7f530e24a", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,27 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use6.rs:14:1\n+  --> $DIR/generic_duplicate_param_use6.rs:15:1\n    |\n LL | fn three<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `(T, T)`, got `(U, T)`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use6.rs:10:1\n+  --> $DIR/generic_duplicate_param_use6.rs:11:1\n    |\n LL | fn two<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use6.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(T, T)`\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: Debug, U> = impl Debug;\n+   |           ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "feebf81eef2a7f87274fe42a3b7952fa261737f4", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use7.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use7.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,11 +1,11 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n #![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;\n \n fn main() {}\n \n-type Two<A, B> = impl Debug;\n+type Two<A: Debug, B> = impl Debug;\n \n fn two<T: Debug + Copy, U>(t: T, u: U) -> Two<T, U> {\n     (t, t)"}, {"sha": "4a723b64cdc4f372c517d0b808f9562c24683c8b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use8.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,12 +5,13 @@ use std::fmt::Debug;\n fn main() {}\n \n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n \n fn two<T: Debug, U: Debug>(t: T, _: U) -> Two<T, U> {\n     (t, 4u32)\n }\n \n fn three<T: Debug, U: Debug>(_: T, u: U) -> Two<T, U> {\n-//~^ concrete type differs from previous\n+    //~^ concrete type differs from previous\n     (u, 4u32)\n }"}, {"sha": "82da704c9ee22d8615ee2292de4b0fe184495619", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use8.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use8.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,27 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use8.rs:13:1\n+  --> $DIR/generic_duplicate_param_use8.rs:14:1\n    |\n LL | fn three<T: Debug, U: Debug>(_: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `(T, u32)`, got `(U, u32)`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use8.rs:9:1\n+  --> $DIR/generic_duplicate_param_use8.rs:10:1\n    |\n LL | fn two<T: Debug, U: Debug>(t: T, _: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use8.rs:7:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(T, u32)`\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: Debug, U> = impl Debug;\n+   |           ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "747081933172b50aca38ca1e5efeaca93a347e5b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use9.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,9 @@ use std::fmt::Debug;\n fn main() {}\n \n type Two<A, B> = impl Debug;\n+//~^ ERROR the trait bound `A: Foo` is not satisfied in `(A, B, <A as Foo>::Bar)`\n+//~| ERROR `A` doesn't implement `Debug`\n+//~| ERROR `B` doesn't implement `Debug`\n \n trait Foo {\n     type Bar: Debug;"}, {"sha": "63aa0f8a81c9a7218972ce4fecb362d582297b81", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use9.stderr", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use9.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,51 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/generic_duplicate_param_use9.rs:18:1\n+  --> $DIR/generic_duplicate_param_use9.rs:21:1\n    |\n LL | fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `(A, B, <A as Foo>::Bar)`, got `(A, B, i32)`\n    |\n note: previous use here\n-  --> $DIR/generic_duplicate_param_use9.rs:14:1\n+  --> $DIR/generic_duplicate_param_use9.rs:17:1\n    |\n LL | fn two<T: Debug + Foo, U: Debug>(t: T, u: U) -> Two<T, U> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0277]: the trait bound `A: Foo` is not satisfied in `(A, B, <A as Foo>::Bar)`\n+  --> $DIR/generic_duplicate_param_use9.rs:7:18\n+   |\n+LL | type Two<A, B> = impl Debug;\n+   |                  ^^^^^^^^^^ within `(A, B, <A as Foo>::Bar)`, the trait `Foo` is not implemented for `A`\n+   |\n+   = note: required because it appears within the type `(A, B, <A as Foo>::Bar)`\n+help: consider restricting type parameter `A`\n+   |\n+LL | type Two<A: Foo, B> = impl Debug;\n+   |           ^^^^^\n+\n+error[E0277]: `A` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use9.rs:7:18\n+   |\n+LL | type Two<A, B> = impl Debug;\n+   |                  ^^^^^^^^^^ `A` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(A, B, <A as Foo>::Bar)`\n+help: consider restricting type parameter `A`\n+   |\n+LL | type Two<A: Debug, B> = impl Debug;\n+   |           ^^^^^^^\n+\n+error[E0277]: `B` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use9.rs:7:18\n+   |\n+LL | type Two<A, B> = impl Debug;\n+   |                  ^^^^^^^^^^ `B` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(A, B, <A as Foo>::Bar)`\n+help: consider restricting type parameter `B`\n+   |\n+LL | type Two<A, B: Debug> = impl Debug;\n+   |              ^^^^^^^\n+\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ffd6f34c4b00e6879ae81a40ce1d0ed05a8214f2", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.nll.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.nll.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -18,6 +18,24 @@ LL | type WrongGeneric<T> = impl 'static;\n    = note:     expected type `i32`\n            found opaque type `impl Sized`\n \n-error: aborting due to 2 previous errors\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:14:30\n+   |\n+LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n+   |                              ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+   |\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                        ^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n+\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0308, E0310.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "f6d490960365adf64391a9c25ea909f45d7774ab", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -8,7 +8,8 @@ fn main() {\n \n type WrongGeneric<T> = impl 'static;\n //~^ ERROR the parameter type `T` may not live long enough\n-//~^^ ERROR: at least one trait must be specified\n+//~| ERROR the parameter type `T` may not live long enough\n+//~| ERROR: at least one trait must be specified\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n     t"}, {"sha": "4924c447d7e40485888cc313e9dc731ba6072012", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -27,7 +27,16 @@ LL | type WrongGeneric<T> = impl 'static;\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n \n-error: aborting due to 3 previous errors\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:24\n+   |\n+LL | type WrongGeneric<T> = impl 'static;\n+   |                        ^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: 'static`...\n+   = note: ...so that the type `T` will meet its required lifetime bounds\n+\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0308, E0310.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "790aea87510e6306e864f8191ab44cb87a6a54e7", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1,14 +1,33 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n+  --> $DIR/issue-57611-trait-alias.rs:25:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/issue-57611-trait-alias.rs:21:9\n+  --> $DIR/issue-57611-trait-alias.rs:25:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r X,)>`\n+              found type `Fn<(&'static X,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `FnOnce<(&X,)>`\n+              found type `FnOnce<(&'static X,)>`\n+\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3372b81404ecb4da25879f625de145602ad95201", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -16,6 +16,10 @@ struct X;\n impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n     //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n+    //~| ERROR mismatched types\n \n     fn bar(&self) -> Self::Bar {\n         |x| x"}, {"sha": "5e2a8db02867f3b70b8d006914b995985ec26c7c", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -7,6 +7,42 @@ LL |     type Bar = impl Baz<Self, Self>;\n    = note: expected type `FnOnce<(&X,)>`\n               found type `FnOnce<(&X,)>`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r X,)>`\n+              found type `Fn<(&'<empty> X,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `FnOnce<(&X,)>`\n+              found type `FnOnce<(&'<empty> X,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r X,)>`\n+              found type `Fn<(&'<empty> X,)>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:17:16\n+   |\n+LL |     type Bar = impl Baz<Self, Self>;\n+   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `FnOnce<(&X,)>`\n+              found type `FnOnce<(&'<empty> X,)>`\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "905248fb33755992d0ec2637edc0f48a0949304c", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -15,7 +15,6 @@ LL |     type Item = impl Bug;\n    |\n    = help: the following implementations were found:\n              <&() as Bug>\n-   = note: the return type of a function must have a statically known size\n \n error: could not find defining uses\n   --> $DIR/issue-60371.rs:8:17"}, {"sha": "8615b3f741bf53ea43ddb27cebcfe38b5b8f4b0d", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -6,7 +6,6 @@ LL | type Closure = impl FnOnce();\n    |\n    = note: expected opaque type `impl FnOnce<()>`\n                 found unit type `()`\n-   = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error\n "}, {"sha": "80192d19af98b5cd9d63f5f89b664570a558dc1d", "filename": "src/test/ui/type-alias-impl-trait/type-alias-impl-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Ftype-alias-impl-trait.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -70,14 +70,14 @@ fn my_other_iter<U>(u: U) -> MyOtherIter<U> {\n }\n \n trait Trait {}\n-type GenericBound<'a, T: Trait> = impl Sized + 'a;\n+type GenericBound<'a, T: Trait + 'a> = impl Sized + 'a;\n \n fn generic_bound<'a, T: Trait + 'a>(t: T) -> GenericBound<'a, T> {\n     t\n }\n \n mod pass_through {\n-    pub type Passthrough<T> = impl Sized + 'static;\n+    pub type Passthrough<T: 'static> = impl Sized + 'static;\n \n     fn define_passthrough<T: 'static>(t: T) -> Passthrough<T> {\n         t"}, {"sha": "a2bf963044582278e921e1872847b920b8de665f", "filename": "src/test/ui/ufcs/ufcs-qpath-self-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -5,6 +5,7 @@ LL |     <i32 as Add<u32>>::add(1, 2);\n    |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u32`\n    |\n    = help: the trait `Add<u32>` is not implemented for `i32`\n+   = note: required by `add`\n \n error[E0308]: mismatched types\n   --> $DIR/ufcs-qpath-self-mismatch.rs:6:28"}, {"sha": "d2a322e1223c660c6ff0b5977769f0b71ee76750", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -3,6 +3,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{Opaque, PredicateAtom::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n@@ -62,9 +63,10 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n         }\n         let ret_ty = utils::return_ty(cx, hir_id);\n         if let Opaque(id, subst) = *ret_ty.kind() {\n-            let preds = cx.tcx.predicates_of(id).instantiate(cx.tcx, subst);\n+            let preds = cx.tcx.explicit_item_bounds(id);\n             let mut is_future = false;\n-            for p in preds.predicates {\n+            for &(p, _span) in preds {\n+                let p = p.subst(cx.tcx, subst);\n                 if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n                     if Some(trait_ref.def_id()) == cx.tcx.lang_items().future_trait() {\n                         is_future = true;\n@@ -90,8 +92,13 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                         |db| {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n-                                    infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate.skip_binders() {\n+                                    infcx.maybe_note_obligation_cause_for_async_await(\n+                                        db,\n+                                        &obligation,\n+                                    );\n+                                    if let Trait(trait_pred, _) =\n+                                        obligation.predicate.skip_binders()\n+                                    {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "e0651f9ab5d6c7e58b1c2840167ca394c72efb0b", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1667,8 +1667,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             // if return type is impl trait, check the associated types\n             if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n                 // one of the associated types must be Self\n-                for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n-                    if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n+                for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n+                    if let ty::PredicateAtom::Projection(projection_predicate) =\n+                        predicate.skip_binders()\n+                    {\n                         // walk the associated type and check for Self\n                         if contains_ty(projection_predicate.ty, self_ty) {\n                             return;"}, {"sha": "247effde19b9c14302805ac6bc14f75fe74f5c94", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08e2d4616613716362b4b49980ff303f2b9ae654/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=08e2d4616613716362b4b49980ff303f2b9ae654", "patch": "@@ -1285,9 +1285,10 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         },\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n-            for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n+            for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateAtom::Trait(trait_predicate, _) = predicate.skip_binders() {\n-                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some()\n+                    {\n                         return true;\n                     }\n                 }"}]}