{"sha": "9036758191b0df7f80c1aaabaf149f67c35dd451", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzY3NTgxOTFiMGRmN2Y4MGMxYWFhYmFmMTQ5ZjY3YzM1ZGQ0NTE=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-14T00:06:27Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-14T00:07:16Z"}, "message": "Next step in the type system change. Add task_type to the context.", "tree": {"sha": "25b0b9b4074e7a9a227a6e16a76cc39c17cbb22e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b0b9b4074e7a9a227a6e16a76cc39c17cbb22e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9036758191b0df7f80c1aaabaf149f67c35dd451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9036758191b0df7f80c1aaabaf149f67c35dd451", "html_url": "https://github.com/rust-lang/rust/commit/9036758191b0df7f80c1aaabaf149f67c35dd451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9036758191b0df7f80c1aaabaf149f67c35dd451/comments", "author": null, "committer": null, "parents": [{"sha": "2a3ab10f207607f612ef2cf81a353e7ebf5cf090", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3ab10f207607f612ef2cf81a353e7ebf5cf090", "html_url": "https://github.com/rust-lang/rust/commit/2a3ab10f207607f612ef2cf81a353e7ebf5cf090"}], "stats": {"total": 80, "additions": 43, "deletions": 37}, "files": [{"sha": "53a30999a5b1634f7e473b8fdad16e771f46f569", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9036758191b0df7f80c1aaabaf149f67c35dd451/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036758191b0df7f80c1aaabaf149f67c35dd451/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=9036758191b0df7f80c1aaabaf149f67c35dd451", "patch": "@@ -16,7 +16,6 @@ import trans::T_opaque_vec_ptr;\n import trans::T_ptr;\n import trans::T_size_t;\n import trans::T_str;\n-import trans::T_taskptr;\n import trans::T_void;\n import lib::llvm::type_names;\n import lib::llvm::llvm::ModuleRef;\n@@ -61,17 +60,19 @@ type upcalls =\n         ValueRef ivec_resize_shared,\n         ValueRef ivec_spill_shared);\n \n-fn declare_upcalls(type_names tn, TypeRef tydesc_type, ModuleRef llmod)\n+fn declare_upcalls(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n+                   ModuleRef llmod)\n    -> @upcalls {\n-    fn decl(type_names tn, TypeRef tydesc_type, ModuleRef llmod, str name,\n-            vec[TypeRef] tys, TypeRef rv) -> ValueRef {\n-        let TypeRef[] arg_tys = ~[T_taskptr(tn)];\n+    fn decl(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n+            ModuleRef llmod, str name, vec[TypeRef] tys,\n+            TypeRef rv) -> ValueRef {\n+        let TypeRef[] arg_tys = ~[taskptr_type];\n         for (TypeRef t in tys) { arg_tys += ~[t]; }\n         auto fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    auto dv = bind decl(tn, tydesc_type, llmod, _, _, T_void());\n-    auto d = bind decl(tn, tydesc_type, llmod, _, _, _);\n+    auto dv = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, T_void());\n+    auto d = bind decl(tn, tydesc_type, taskptr_type, llmod, _, _, _);\n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n \n@@ -89,14 +90,14 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, ModuleRef llmod)\n                         T_opaque_chan_ptr()),\n              flush_chan=dv(\"flush_chan\", [T_opaque_chan_ptr()]),\n              del_chan=dv(\"del_chan\", [T_opaque_chan_ptr()]),\n-             clone_chan=d(\"clone_chan\", [T_taskptr(tn), T_opaque_chan_ptr()],\n+             clone_chan=d(\"clone_chan\", [taskptr_type, T_opaque_chan_ptr()],\n                           T_opaque_chan_ptr()),\n              _yield=dv(\"yield\", empty_vec),\n              sleep=dv(\"sleep\", [T_size_t()]),\n              send=dv(\"send\", [T_opaque_chan_ptr(), T_ptr(T_i8())]),\n              recv=dv(\"recv\", [T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n              _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-             kill=dv(\"kill\", [T_taskptr(tn)]),\n+             kill=dv(\"kill\", [taskptr_type]),\n              exit=dv(\"exit\", empty_vec),\n              malloc=d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)],\n                       T_ptr(T_i8())),\n@@ -107,7 +108,7 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, ModuleRef llmod)\n              mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n              new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n                        T_ptr(T_str())),\n-                     dup_str=d(\"dup_str\", [T_taskptr(tn), T_ptr(T_str())],\n+                     dup_str=d(\"dup_str\", [taskptr_type, T_ptr(T_str())],\n                        T_ptr(T_str())),\n              new_vec=d(\"new_vec\", [T_size_t(), T_ptr(tydesc_type)],\n                        T_opaque_vec_ptr()),\n@@ -119,10 +120,10 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, ModuleRef llmod)\n                              [T_ptr(T_nil()), T_size_t(), T_size_t(),\n                               T_size_t(), T_ptr(T_ptr(tydesc_type))],\n                              T_ptr(tydesc_type)),\n-             new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n+             new_task=d(\"new_task\", [T_ptr(T_str())], taskptr_type),\n              start_task=d(\"start_task\",\n-                          [T_taskptr(tn), T_int(), T_int(), T_size_t()],\n-                          T_taskptr(tn)),\n+                          [taskptr_type, T_int(), T_int(), T_size_t()],\n+                          taskptr_type),\n              ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n                            T_void()),\n              ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],"}, {"sha": "4f4ab48199821107b582900e58c39a38e9ecb007", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9036758191b0df7f80c1aaabaf149f67c35dd451/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9036758191b0df7f80c1aaabaf149f67c35dd451/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9036758191b0df7f80c1aaabaf149f67c35dd451", "patch": "@@ -147,7 +147,8 @@ type crate_ctxt =\n         ty::ctxt tcx,\n         stats stats,\n         @upcall::upcalls upcalls,\n-        TypeRef tydesc_type);\n+        TypeRef tydesc_type,\n+        TypeRef task_type);\n \n type local_ctxt =\n     rec(str[] path,\n@@ -477,9 +478,8 @@ fn T_struct(&TypeRef[] elts) -> TypeRef {\n \n fn T_opaque() -> TypeRef { ret llvm::LLVMOpaqueType(); }\n \n-fn T_task(&type_names tn) -> TypeRef {\n+fn T_task2() -> TypeRef {\n     auto s = \"task\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n     auto t =\n         T_struct(~[T_int(), // Refcount\n                    T_int(), // Delegate pointer\n@@ -491,7 +491,6 @@ fn T_task(&type_names tn) -> TypeRef {\n                    T_int(), // Domain pointer\n                             // Crate cache pointer\n                    T_int()]);\n-    tn.associate(s, t);\n     ret t;\n }\n \n@@ -527,16 +526,16 @@ fn T_cmp_glue_fn(&crate_ctxt cx) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc(&type_names tn) -> TypeRef {\n+fn T_tydesc(TypeRef taskptr_type) -> TypeRef {\n     auto th = mk_type_handle();\n     auto abs_tydesc = llvm::LLVMResolveTypeHandle(th.llth);\n     auto tydescpp = T_ptr(T_ptr(abs_tydesc));\n     auto pvoid = T_ptr(T_i8());\n     auto glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_nil()), T_taskptr(tn), T_ptr(T_nil()), tydescpp,\n+        T_ptr(T_fn(~[T_ptr(T_nil()), taskptr_type, T_ptr(T_nil()), tydescpp,\n                      pvoid], T_void()));\n     auto cmp_glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_i1()), T_taskptr(tn), T_ptr(T_nil()), tydescpp,\n+        T_ptr(T_fn(~[T_ptr(T_i1()), taskptr_type, T_ptr(T_nil()), tydescpp,\n                      pvoid, pvoid, T_i8()], T_void()));\n     auto tydesc =\n         T_struct(~[tydescpp,   // first_param\n@@ -633,7 +632,7 @@ fn T_chan(TypeRef t) -> TypeRef {\n \n }\n \n-fn T_taskptr(&type_names tn) -> TypeRef { ret T_ptr(T_task(tn)); }\n+fn T_taskptr(&crate_ctxt cx) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n@@ -766,7 +765,7 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n     }\n \n     // Arg 1: task pointer.\n-    atys += ~[T_taskptr(cx.tn)];\n+    atys += ~[T_taskptr(*cx)];\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n@@ -811,7 +810,7 @@ fn type_of_native_fn(&@crate_ctxt cx, &span sp, ast::native_abi abi,\n    -> TypeRef {\n     let TypeRef[] atys = ~[];\n     if (abi == ast::native_abi_rust) {\n-        atys += ~[T_taskptr(cx.tn)];\n+        atys += ~[T_taskptr(*cx)];\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += ~[T_ptr(cx.tydesc_type)];\n@@ -874,7 +873,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         case (ty::ty_chan(?t)) {\n             llty = T_ptr(T_chan(type_of_inner(cx, sp, t)));\n         }\n-        case (ty::ty_task) { llty = T_taskptr(cx.tn); }\n+        case (ty::ty_task) { llty = T_taskptr(*cx); }\n         case (ty::ty_tup(?elts)) {\n             let TypeRef[] tys = ~[];\n             for (ty::mt elt in elts) {\n@@ -1136,8 +1135,8 @@ fn decl_internal_fastcall_fn(ModuleRef llmod, &str name, TypeRef llty) ->\n     ret llfn;\n }\n \n-fn decl_glue(ModuleRef llmod, type_names tn, &str s) -> ValueRef {\n-    ret decl_cdecl_fn(llmod, s, T_fn(~[T_taskptr(tn)], T_void()));\n+fn decl_glue(ModuleRef llmod, &crate_ctxt cx, &str s) -> ValueRef {\n+    ret decl_cdecl_fn(llmod, s, T_fn(~[T_taskptr(cx)], T_void()));\n }\n \n fn get_extern_fn(&hashmap[str, ValueRef] externs, ModuleRef llmod, &str name,\n@@ -8999,7 +8998,7 @@ fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n }\n \n fn create_typedefs(&@crate_ctxt cx) {\n-    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"task\"), T_task(cx.tn));\n+    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"task\"), cx.task_type);\n     llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), cx.tydesc_type);\n }\n \n@@ -9057,8 +9056,8 @@ fn trap(&@block_ctxt bcx) {\n     }\n }\n \n-fn decl_no_op_type_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n-    auto ty = T_fn(~[T_taskptr(tn), T_ptr(T_i8())], T_void());\n+fn decl_no_op_type_glue(ModuleRef llmod, TypeRef taskptr_type) -> ValueRef {\n+    auto ty = T_fn(~[taskptr_type, T_ptr(T_i8())], T_void());\n     ret decl_fastcall_fn(llmod, abi::no_op_type_glue_name(), ty);\n }\n \n@@ -9078,24 +9077,26 @@ fn vec_p0(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n     ret bcx.build.PointerCast(p, T_ptr(T_i8()));\n }\n \n-fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n-    ret @rec(no_op_type_glue=decl_no_op_type_glue(llmod, tn));\n+fn make_glues(ModuleRef llmod, TypeRef taskptr_type) -> @glue_fns {\n+    ret @rec(no_op_type_glue=decl_no_op_type_glue(llmod, taskptr_type));\n }\n \n fn make_common_glue(&session::session sess, &str output) {\n     // FIXME: part of this is repetitive and is probably a good idea\n     // to autogen it.\n \n+    auto task_type = T_task2();\n+    auto taskptr_type = T_ptr(task_type);\n+\n     auto llmod =\n         llvm::LLVMModuleCreateWithNameInContext(str::buf(\"rust_out\"),\n                                                 llvm::LLVMGetGlobalContext());\n     llvm::LLVMSetDataLayout(llmod, str::buf(x86::get_data_layout()));\n     llvm::LLVMSetTarget(llmod, str::buf(x86::get_target_triple()));\n     mk_target_data(x86::get_data_layout());\n-    auto tn = mk_type_names();\n     declare_intrinsics(llmod);\n     llvm::LLVMSetModuleInlineAsm(llmod, str::buf(x86::get_module_asm()));\n-    make_glues(llmod, tn);\n+    make_glues(llmod, taskptr_type);\n     link::write::run_passes(sess, llmod, output);\n }\n \n@@ -9170,7 +9171,10 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     auto td = mk_target_data(x86::get_data_layout());\n     auto tn = mk_type_names();\n     auto intrinsics = declare_intrinsics(llmod);\n-    auto glues = make_glues(llmod, tn);\n+    auto task_type = T_task2();\n+    auto taskptr_type = T_ptr(task_type);\n+    auto tydesc_type = T_tydesc(taskptr_type);\n+    auto glues = make_glues(llmod, taskptr_type);\n     auto hasher = ty::hash_ty;\n     auto eqer = ty::eq_ty;\n     auto tag_sizes = map::mk_hashmap[ty::t, uint](hasher, eqer);\n@@ -9179,7 +9183,6 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     auto sha1s = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto sha = std::sha1::mk_sha1();\n-    auto tydesc_type = T_tydesc(tn);\n     auto ccx =\n         @rec(sess=sess,\n              llmod=llmod,\n@@ -9212,8 +9215,10 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                        mutable n_glues_created=0u,\n                        mutable n_null_glues=0u,\n                        mutable n_real_glues=0u),\n-             upcalls=upcall::declare_upcalls(tn, tydesc_type, llmod),\n-             tydesc_type=tydesc_type);\n+             upcalls=upcall::declare_upcalls(tn, tydesc_type, taskptr_type,\n+                                             llmod),\n+             tydesc_type=tydesc_type,\n+             task_type=task_type);\n     auto cx = new_local_ctxt(ccx);\n     create_typedefs(ccx);\n     collect_items(ccx, crate);"}]}