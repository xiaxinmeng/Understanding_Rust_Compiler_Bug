{"sha": "85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZmQzZjhlNDNmM2MyZDE1MWQ5ZjBhZGNhYzI5YjdiZGJhMjgxMWY=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-10T08:18:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-10T08:18:54Z"}, "message": "Merge pull request #297 from RalfJung/mir-validate\n\nValidation update", "tree": {"sha": "c7933e9cb901001718bcfe452b538502bbaac472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7933e9cb901001718bcfe452b538502bbaac472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "html_url": "https://github.com/rust-lang/rust/commit/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a31317a4f48aca99f73237a060be975f591663", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a31317a4f48aca99f73237a060be975f591663", "html_url": "https://github.com/rust-lang/rust/commit/65a31317a4f48aca99f73237a060be975f591663"}, {"sha": "8e8c9c862c50f7f29e99f9a80bdeb67d99393969", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e8c9c862c50f7f29e99f9a80bdeb67d99393969", "html_url": "https://github.com/rust-lang/rust/commit/8e8c9c862c50f7f29e99f9a80bdeb67d99393969"}], "stats": {"total": 529, "additions": 412, "deletions": 117}, "files": [{"sha": "ef15fa98d3fc83f4ed6ea9795e744a865d9dea62", "filename": ".travis.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -16,7 +16,7 @@ script:\n - |\n   # Test plain miri\n   cargo build --release --features \"cargo_miri\" &&\n-  cargo test --release &&\n+  cargo test --release --all &&\n   cargo install --features \"cargo_miri\"\n - |\n   # Test cargo miri"}, {"sha": "4189f240c582415ab1f512cce0d0689eb4ead000", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -8,7 +8,6 @@ version = \"0.1.0\"\n workspace = \"../..\"\n \n [lib]\n-test = false\n path = \"lib.rs\"\n \n [dependencies]"}, {"sha": "75acdbe778c3e1237b5fde49859e3661bda2faa1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 46, "deletions": 57, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -29,19 +29,14 @@ pub enum AccessKind {\n /// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n struct LockInfo {\n-    suspended: Vec<SuspendedWriteLock>,\n+    /// Stores for which lifetimes (of the original write lock) we got\n+    /// which suspensions.\n+    suspended: HashMap<DynamicLifetime, Vec<CodeExtent>>,\n+    /// The current state of the lock that's actually effective.\n     active: Lock,\n }\n \n-#[derive(Clone, Debug)]\n-struct SuspendedWriteLock  {\n-    /// Original lifetime of the lock that is now suspended\n-    lft: DynamicLifetime,\n-    /// Regions that all have to end to reenable this suspension\n-    suspensions: Vec<CodeExtent>,\n-}\n-\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),\n@@ -57,7 +52,7 @@ impl Default for LockInfo {\n \n impl LockInfo {\n     fn new(lock: Lock) -> LockInfo {\n-        LockInfo { suspended: Vec::new(), active: lock }\n+        LockInfo { suspended: HashMap::new(), active: lock }\n     }\n \n     fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n@@ -513,17 +508,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Release or suspend a write lock of the given lifetime prematurely.\n-    /// When releasing, if there is no write lock or someone else's write lock, that's an error.\n+    /// When releasing, if there is a read lock or someone else's write lock, that's an error.\n+    /// We *do* accept relasing a NoLock, as this can happen when a local is first acquired and later force_allocate'd.\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n-    pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n+    pub(crate) fn suspend_write_lock(&mut self, ptr: MemoryPointer, len: u64,\n                                      lock_region: Option<CodeExtent>, suspend: Option<CodeExtent>) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n         let lock_lft = DynamicLifetime { frame: cur_frame, region: lock_region };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         'locks: for lock in alloc.locks.iter_mut(ptr.offset, len) {\n-            trace!(\"Releasing {:?}\", lock);\n             let is_our_lock = match lock.active {\n                 WriteLock(lft) => {\n                     lft == lock_lft\n@@ -533,30 +528,25 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 }\n             };\n             if is_our_lock {\n+                trace!(\"Releasing {:?} at {:?}\", lock.active, lock_lft);\n                 // Disable the lock\n                 lock.active = NoLock;\n+            } else {\n+                trace!(\"Not touching {:?} at {:?} as its not our lock\", lock.active, lock_lft);\n             }\n             match suspend {\n                 Some(suspend_region) => {\n-                    if is_our_lock {\n-                        // We just released this lock, so add a new suspension\n-                        lock.suspended.push(SuspendedWriteLock { lft: lock_lft, suspensions: vec![suspend_region] });\n-                    } else {\n-                        // Find our lock in the suspended ones\n-                        for suspended_lock in lock.suspended.iter_mut().rev() {\n-                            if suspended_lock.lft == lock_lft {\n-                                // Found it!\n-                                suspended_lock.suspensions.push(suspend_region);\n-                                continue 'locks;\n-                            }\n-                        }\n-                        // We did not find it.  Someone else had the lock and we have not suspended it, that's just wrong.\n-                        return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.active.clone() });\n-                    }\n+                    trace!(\"Adding suspension to {:?} at {:?}\", lock.active, lock_lft);\n+                    // We just released this lock, so add a new suspension.\n+                    // FIXME: Really, if there ever already is a suspension when is_our_lock, or if there is no suspension when !is_our_lock, something is amiss.\n+                    // But this model is not good enough yet to prevent that.\n+                    lock.suspended.entry(lock_lft)\n+                        .or_insert_with(|| Vec::new())\n+                        .push(suspend_region);\n                 }\n                 None => {\n-                    // If we do not suspend, make sure we actually released something\n-                    if !is_our_lock {\n+                    // Make sure we did not try to release someone else's lock.\n+                    if !is_our_lock && lock.active != NoLock {\n                         return err!(InvalidMemoryLockRelease { ptr, len, frame: cur_frame, lock: lock.active.clone() });\n                     }\n                 }\n@@ -577,34 +567,33 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         for lock in alloc.locks.iter_mut(ptr.offset, len) {\n-            // If we have a suspension here, it will be the topmost one\n-            let (got_the_lock, pop_suspension) = match lock.suspended.last_mut() {\n-                None => (true, false),\n-                Some(suspended_lock) => {\n-                    if suspended_lock.lft == lock_lft {\n-                        // That's us!  Remove suspension (it should be in there).  The same suspension can\n-                        // occur multiple times (when there are multiple shared borrows of this that have the same\n-                        // lifetime); only remove one of them.\n-                        let idx = match suspended_lock.suspensions.iter().enumerate().find(|&(_, re)| re == &suspended_region) {\n-                            None => // TODO: Can the user trigger this?\n-                                bug!(\"We have this lock suspended, but not for the given region.\"),\n-                            Some((idx, _)) => idx\n-                        };\n-                        suspended_lock.suspensions.remove(idx);\n-                        let got_lock = suspended_lock.suspensions.is_empty();\n-                        (got_lock, got_lock)\n-                    } else {\n-                        // Someone else's suspension up top, we should be able to grab the lock\n-                        (true, false)\n+            // Check if we have a suspension here\n+            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_lft) {\n+                None => {\n+                    trace!(\"No suspension around, we can just acquire\");\n+                    (true, false)\n+                }\n+                Some(suspensions) => {\n+                    trace!(\"Found suspension of {:?}, removing it\", lock_lft);\n+                    // That's us!  Remove suspension (it should be in there).  The same suspension can\n+                    // occur multiple times (when there are multiple shared borrows of this that have the same\n+                    // lifetime); only remove one of them.\n+                    let idx = match suspensions.iter().enumerate().find(|&(_, re)| re == &suspended_region) {\n+                        None => // TODO: Can the user trigger this?\n+                            bug!(\"We have this lock suspended, but not for the given region.\"),\n+                        Some((idx, _)) => idx\n+                    };\n+                    suspensions.remove(idx);\n+                    let got_lock = suspensions.is_empty();\n+                    if got_lock {\n+                        trace!(\"All suspensions are gone, we can have the lock again\");\n                     }\n+                    (got_lock, got_lock)\n                 }\n             };\n-            if pop_suspension { // with NLL; we could do that up in the match above...\n-                lock.suspended.pop();\n-            } else {\n-                // Sanity check: Our lock should not be in the suspension list\n-                let found = lock.suspended.iter().find(|suspended_lock| suspended_lock.lft == lock_lft);\n-                assert!(found.is_none());\n+            if remove_suspension { // with NLL, we could do that up in the match above...\n+                assert!(got_the_lock);\n+                lock.suspended.remove(&lock_lft);\n             }\n             if got_the_lock {\n                 match lock.active {\n@@ -653,7 +642,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                     lock.active = NoLock;\n                 }\n                 // Also clean up suspended write locks\n-                lock.suspended.retain(|suspended_lock| !has_ended(&suspended_lock.lft));\n+                lock.suspended.retain(|lft, _suspensions| !has_ended(lft));\n             }\n             // Clean up the map\n             alloc.locks.retain(|lock| {"}, {"sha": "e4db9b0e0fc45bfd710dff018d9674e2cabbd9fb", "filename": "src/librustc_mir/interpret/range_map.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Frange_map.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -1,4 +1,9 @@\n-//! Implements a map from disjoint non-empty integer ranges to data associated with those ranges\n+//! Implements a map from integer indices to data.\n+//! Rather than storing data for every index, internally, this maps entire ranges to the data.\n+//! To this end, the APIs all work on ranges, not on individual integers. Ranges are split as\n+//! necessary (e.g. when [0,5) is first associated with X, and then [1,2) is mutated).\n+//! Users must not depend on whether a range is coalesced or not, even though this is observable\n+//! via the iteration APIs.\n use std::collections::{BTreeMap};\n use std::ops;\n \n@@ -21,6 +26,7 @@ struct Range {\n \n impl Range {\n     fn range(offset: u64, len: u64) -> ops::Range<Range> {\n+        assert!(len > 0);\n         // We select all elements that are within\n         // the range given by the offset into the allocation and the length.\n         // This is sound if all ranges that intersect with the argument range, are in the\n@@ -36,6 +42,7 @@ impl Range {\n         left..right\n     }\n \n+    /// Tests if all of [offset, offset+len) are contained in this range.\n     fn overlaps(&self, offset: u64, len: u64) -> bool {\n         assert!(len > 0);\n         offset < self.end && offset+len >= self.start\n@@ -48,6 +55,7 @@ impl<T> RangeMap<T> {\n     }\n \n     fn iter_with_range<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a Range, &'a T)> + 'a {\n+        assert!(len > 0);\n         self.map.range(Range::range(offset, len))\n             .filter_map(move |(range, data)| {\n                 if range.overlaps(offset, len) {\n@@ -63,7 +71,7 @@ impl<T> RangeMap<T> {\n     }\n \n     fn split_entry_at(&mut self, offset: u64) where T: Clone {\n-        let range = match self.iter_with_range(offset, 0).next() {\n+        let range = match self.iter_with_range(offset, 1).next() {\n             Some((&range, _)) => range,\n             None => return,\n         };\n@@ -88,6 +96,7 @@ impl<T> RangeMap<T> {\n     pub fn iter_mut_with_gaps<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=&'a mut T> + 'a\n         where T: Clone\n     {\n+        assert!(len > 0);\n         // Preparation: Split first and last entry as needed.\n         self.split_entry_at(offset);\n         self.split_entry_at(offset+len);\n@@ -112,14 +121,15 @@ impl<T> RangeMap<T> {\n     {\n         // Do a first iteration to collect the gaps\n         let mut gaps = Vec::new();\n-        let mut last_end = None;\n+        let mut last_end = offset;\n         for (range, _) in self.iter_with_range(offset, len) {\n-            if let Some(last_end) = last_end {\n-                if last_end < range.start {\n-                    gaps.push(Range { start: last_end, end: range.start });\n-                }\n+            if last_end < range.start {\n+                gaps.push(Range { start: last_end, end: range.start });\n             }\n-            last_end = Some(range.end);\n+            last_end = range.end;\n+        }\n+        if last_end < offset+len {\n+            gaps.push(Range { start: last_end, end: offset+len });\n         }\n \n         // Add default for all gaps\n@@ -147,3 +157,43 @@ impl<T> RangeMap<T> {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    /// Query the map at every offset in the range and collect the results.\n+    fn to_vec<T: Copy>(map: &RangeMap<T>, offset: u64, len: u64) -> Vec<T> {\n+        (offset..offset+len).into_iter().map(|i| *map.iter(i, 1).next().unwrap()).collect()\n+    }\n+\n+    #[test]\n+    fn basic_insert() {\n+        let mut map = RangeMap::<i32>::new();\n+        // Insert\n+        for x in map.iter_mut(10, 1) {\n+            *x = 42;\n+        }\n+        // Check\n+        assert_eq!(to_vec(&map, 10, 1), vec![42]);\n+    }\n+\n+    #[test]\n+    fn gaps() {\n+        let mut map = RangeMap::<i32>::new();\n+        for x in map.iter_mut(11, 1) {\n+            *x = 42;\n+        }\n+        for x in map.iter_mut(15, 1) {\n+            *x = 42;\n+        }\n+\n+        // Now request a range that needs three gaps filled\n+        for x in map.iter_mut(10, 10) {\n+            if *x != 42 { *x = 23; }\n+        }\n+\n+        assert_eq!(to_vec(&map, 10, 10), vec![23, 42, 23, 23, 23, 42, 23, 23, 23, 23]);\n+        assert_eq!(to_vec(&map, 13, 5), vec![23, 23, 42, 23, 23]);\n+    }\n+}"}, {"sha": "6a8df1b5246744541989ca54271750ece28afba6", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 152, "deletions": 48, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -1,10 +1,11 @@\n use rustc::hir::Mutability;\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::subst::{Substs, Subst};\n+use rustc::traits;\n+use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n-use rustc::infer::TransNormalize;\n use rustc::middle::region::CodeExtent;\n \n use super::{\n@@ -18,7 +19,7 @@ use super::{\n \n pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n enum ValidationMode {\n     Acquire,\n     /// Recover because the given region ended\n@@ -110,6 +111,109 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         Ok(())\n     }\n \n+    fn normalize_type_unerased(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        return normalize_associated_type(self.tcx, &ty);\n+\n+        use syntax::codemap::{Span, DUMMY_SP};\n+\n+        // We copy a bunch of stuff from rustc/infer/mod.rs to be able to tweak its behavior\n+        fn normalize_projections_in<'a, 'gcx, 'tcx, T>(\n+                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+                param_env: ty::ParamEnv<'tcx>,\n+                value: &T)\n+                -> T::Lifted\n+            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+        {\n+            let mut selcx = traits::SelectionContext::new(self_);\n+            let cause = traits::ObligationCause::dummy();\n+            let traits::Normalized { value: result, obligations } =\n+                traits::normalize(&mut selcx, param_env, cause, value);\n+\n+            let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+            for obligation in obligations {\n+                fulfill_cx.register_predicate_obligation(self_, obligation);\n+            }\n+\n+            drain_fulfillment_cx_or_panic(self_, DUMMY_SP, &mut fulfill_cx, &result)\n+        }\n+\n+        fn drain_fulfillment_cx_or_panic<'a, 'gcx, 'tcx, T>(\n+                                                self_: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                span: Span,\n+                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                                result: &T)\n+                                                -> T::Lifted\n+            where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+        {\n+            // In principle, we only need to do this so long as `result`\n+            // contains unbound type parameters. It could be a slight\n+            // optimization to stop iterating early.\n+            match fulfill_cx.select_all_or_error(self_) {\n+                Ok(()) => { }\n+                Err(errors) => {\n+                    span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                                errors);\n+                }\n+            }\n+\n+            let result = self_.resolve_type_vars_if_possible(result);\n+            let result = self_.tcx.fold_regions(&result, &mut false, |r, _| match *r { ty::ReVar(_) => self_.tcx.types.re_erased, _ => r });\n+\n+            match self_.tcx.lift_to_global(&result) {\n+                Some(result) => result,\n+                None => {\n+                    span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n+                }\n+            }\n+        }\n+\n+        trait MyTransNormalize<'gcx>: TypeFoldable<'gcx> {\n+            fn my_trans_normalize<'a, 'tcx>(&self,\n+                                        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        param_env: ty::ParamEnv<'tcx>)\n+                                        -> Self;\n+        }\n+\n+        macro_rules! items { ($($item:item)+) => ($($item)+) }\n+        macro_rules! impl_trans_normalize {\n+            ($lt_gcx:tt, $($ty:ty),+) => {\n+                items!($(impl<$lt_gcx> MyTransNormalize<$lt_gcx> for $ty {\n+                    fn my_trans_normalize<'a, 'tcx>(&self,\n+                                                infcx: &InferCtxt<'a, $lt_gcx, 'tcx>,\n+                                                param_env: ty::ParamEnv<'tcx>)\n+                                                -> Self {\n+                        normalize_projections_in(infcx, param_env, self)\n+                    }\n+                })+);\n+            }\n+        }\n+\n+        impl_trans_normalize!('gcx,\n+            Ty<'gcx>,\n+            &'gcx Substs<'gcx>,\n+            ty::FnSig<'gcx>,\n+            ty::PolyFnSig<'gcx>,\n+            ty::ClosureSubsts<'gcx>,\n+            ty::PolyTraitRef<'gcx>,\n+            ty::ExistentialTraitRef<'gcx>\n+        );\n+\n+        fn normalize_associated_type<'a, 'tcx, T>(self_: TyCtxt<'a, 'tcx, 'tcx>, value: &T) -> T\n+            where T: MyTransNormalize<'tcx>\n+        {\n+            let param_env = ty::ParamEnv::empty(Reveal::All);\n+\n+            if !value.has_projection_types() {\n+                return value.clone();\n+            }\n+\n+            self_.infer_ctxt().enter(|infcx| {\n+                value.my_trans_normalize(&infcx, param_env)\n+            })\n+        }\n+    }\n+\n     fn validate_variant(\n         &mut self,\n         query: ValidationQuery<'tcx>,\n@@ -142,16 +246,15 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn validate(&mut self, query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n     {\n         match self.try_validate(query, mode) {\n-            // Releasing an uninitalized variable is a NOP.  This is needed because\n+            // ReleaseUntil(None) of an uninitalized variable is a NOP.  This is needed because\n             // we have to release the return value of a function; due to destination-passing-style\n             // the callee may directly write there.\n             // TODO: Ideally we would know whether the destination is already initialized, and only\n-            // release if it is.\n-            res @ Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..}) => {\n-                if !mode.acquiring() {\n-                    return Ok(());\n-                }\n-                res\n+            // release if it is.  But of course that can't even always be statically determined.\n+            Err(EvalError{ kind: EvalErrorKind::ReadUndefBytes, ..})\n+                if mode == ValidationMode::ReleaseUntil(None)\n+            => {\n+                return Ok(());\n             }\n             res => res,\n         }\n@@ -190,14 +293,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             _ => {}\n         }\n \n-        // This is essentially a copy of normalize_associated_type, but without erasure\n-        if query.ty.has_projection_types() {\n-            let param_env = ty::ParamEnv::empty(Reveal::All);\n-            let old_ty = query.ty;\n-            query.ty = self.tcx.infer_ctxt().enter(move |infcx| {\n-                old_ty.trans_normalize(&infcx, param_env)\n-            })\n-        }\n+        query.ty = self.normalize_type_unerased(&query.ty);\n         trace!(\"{:?} on {:?}\", mode, query);\n \n         // Decide whether this type *owns* the memory it covers (like integers), or whether it\n@@ -212,38 +308,46 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => bug!(\"I got an incomplete/unnormalized type for validation\"),\n         };\n         if is_owning {\n-            match query.lval {\n-                Lvalue::Ptr { ptr, extra } => {\n-                    // Determine the size\n-                    // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n-                    let len = match self.type_size(query.ty)? {\n-                        Some(size) => {\n-                            assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n-                            size\n-                        }\n-                        None => {\n-                            // The only unsized typ we concider \"owning\" is TyStr.\n-                            assert_eq!(query.ty.sty, TyStr, \"Found a surprising unsized owning type\");\n-                            // The extra must be the length, in bytes.\n-                            match extra {\n-                                LvalueExtra::Length(len) => len,\n-                                _ => bug!(\"TyStr must have a length as extra\"),\n-                            }\n+            // We need to lock.  So we need memory.  So we have to force_acquire.\n+            // Tracking the same state for locals not backed by memory would just duplicate too\n+            // much machinery.\n+            // FIXME: We ignore alignment.\n+            let (ptr, extra) = self.force_allocation(query.lval)?.to_ptr_extra_aligned();\n+            // Determine the size\n+            // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n+            let len = match self.type_size(query.ty)? {\n+                Some(size) => {\n+                    assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n+                    size\n+                }\n+                None => {\n+                    // The only unsized typ we concider \"owning\" is TyStr.\n+                    assert_eq!(query.ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                    // The extra must be the length, in bytes.\n+                    match extra {\n+                        LvalueExtra::Length(len) => len,\n+                        _ => bug!(\"TyStr must have a length as extra\"),\n+                    }\n+                }\n+            };\n+            // Handle locking\n+            if len > 0 {\n+                let ptr = ptr.to_ptr()?;\n+                match query.mutbl {\n+                    MutImmutable =>\n+                        if mode.acquiring() {\n+                            self.memory.acquire_lock(ptr, len, query.re, AccessKind::Read)?;\n                         }\n-                    };\n-                    // Handle locking\n-                    if len > 0 {\n-                        let ptr = ptr.to_ptr()?;\n-                        let access = match query.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                        // No releasing of read locks, ever.\n+                    MutMutable =>\n                         match mode {\n-                            ValidationMode::Acquire => self.memory.acquire_lock(ptr, len, query.re, access)?,\n-                            ValidationMode::Recover(ending_ce) => self.memory.recover_write_lock(ptr, len, query.re, ending_ce)?,\n-                            ValidationMode::ReleaseUntil(suspended_ce) => self.memory.release_write_lock(ptr, len, query.re, suspended_ce)?,\n+                            ValidationMode::Acquire =>\n+                                self.memory.acquire_lock(ptr, len, query.re, AccessKind::Write)?,\n+                            ValidationMode::Recover(ending_ce) =>\n+                                self.memory.recover_write_lock(ptr, len, query.re, ending_ce)?,\n+                            ValidationMode::ReleaseUntil(suspended_ce) =>\n+                                self.memory.suspend_write_lock(ptr, len, query.re, suspended_ce)?,\n                         }\n-                    }\n-                }\n-                Lvalue::Local { .. }  => {\n-                    // Not backed by memory, so we have nothing to do.\n                 }\n             }\n         }"}, {"sha": "f439ac8c130e5c958a1b91d870966ac62b8132be", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -1,3 +1,5 @@\n+// Validation forces more allocation; disable it.\n+// compile-flags: -Zmir-emit-validate=0\n #![feature(box_syntax, custom_attribute, attr_literals)]\n #![miri(memory_size=2048)]\n "}, {"sha": "86aa57447fe609ac60b1fbd4470c02cc30bf0a99", "filename": "tests/compile-fail/validation_aliasing_mut1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut1.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,10 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    pub fn safe(x: &mut i32, y: &mut i32) {} //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn main() {\n+    let x = &mut 0 as *mut _;\n+    unsafe { safe::safe(&mut *x, &mut *x) };\n+}"}, {"sha": "ed7497e5e546029b102b05a2a47abb07d1288225", "filename": "tests/compile-fail/validation_aliasing_mut2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut2.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,10 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    pub fn safe(x: &i32, y: &mut i32) {} //~ ERROR: in conflict with lock ReadLock\n+}\n+\n+fn main() {\n+    let x = &mut 0 as *mut _;\n+    unsafe { safe::safe(&*x, &mut *x) };\n+}"}, {"sha": "69fbbc167ca0f49193399a3dce84b5fcabea62d9", "filename": "tests/compile-fail/validation_aliasing_mut3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut3.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,10 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    pub fn safe(x: &mut i32, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn main() {\n+    let x = &mut 0 as *mut _;\n+    unsafe { safe::safe(&mut *x, &*x) };\n+}"}, {"sha": "3dac55aeaac952071a9c9f707bcbddc66ead875b", "filename": "tests/compile-fail/validation_aliasing_mut4.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_aliasing_mut4.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,13 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    use std::cell::Cell;\n+\n+    // Make sure &mut UnsafeCell also has a lock to it\n+    pub fn safe(x: &mut Cell<i32>, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn main() {\n+    let x = &mut 0 as *mut _;\n+    unsafe { safe::safe(&mut *(x as *mut _), &*x) };\n+}"}, {"sha": "9e67b2a4ab18c9d48d84ad5f0b34090be915b88f", "filename": "tests/compile-fail/validation_buggy_split_at_mut.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_buggy_split_at_mut.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,22 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    use std::slice::from_raw_parts_mut;\n+\n+    pub fn split_at_mut<T>(self_: &mut [T], mid: usize) -> (&mut [T], &mut [T]) {\n+        let len = self_.len();\n+        let ptr = self_.as_mut_ptr();\n+\n+        unsafe {\n+            assert!(mid <= len);\n+\n+            (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+            from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut array = [1,2,3,4];\n+    let _x = safe::split_at_mut(&mut array, 0); //~ ERROR: in conflict with lock WriteLock\n+}"}, {"sha": "1432f4cc9f1720f5565c784d0b5b7a537013ed8b", "filename": "tests/compile-fail/validation_illegal_write.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_illegal_write.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,15 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    pub(crate) fn safe(x: &u32) {\n+        let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n+        *x = 42; //~ ERROR: in conflict with lock ReadLock\n+    }\n+}\n+\n+fn main() {\n+    let target = &mut 42;\n+    let target_ref = &target;\n+    // do a reborrow, but we keep the lock\n+    safe::safe(&*target);\n+}"}, {"sha": "3320d2a89d3551699c18bc540f4ad1ba2ca408fc", "filename": "tests/compile-fail/validation_pointer_smuggling.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_pointer_smuggling.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,20 @@\n+#![allow(unused_variables)]\n+\n+static mut PTR: *mut u8 = 0 as *mut _;\n+\n+fn fun1(x: &mut u8) {\n+    unsafe {\n+        PTR = x;\n+    }\n+}\n+\n+fn fun2() {\n+    // Now we use a pointer we are not allowed to use\n+    let _x = unsafe { *PTR }; //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn main() {\n+    let mut val = 0;\n+    fun1(&mut val);\n+    fun2();\n+}"}, {"sha": "55c38a694c55e04f61489081b0ee8af353124628", "filename": "tests/compile-fail/validation_recover1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover1.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,16 @@\n+#![allow(unused_variables)]\n+\n+#[repr(u32)]\n+enum Bool { True }\n+\n+mod safe {\n+    pub(crate) fn safe(x: &mut super::Bool) {\n+        let x = x as *mut _ as *mut u32;\n+        unsafe { *x = 44; } // out-of-bounds enum discriminant\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Bool::True;\n+    safe::safe(&mut x); //~ ERROR: invalid enum discriminant\n+}"}, {"sha": "756be9fde6fc58d85dd44044d58d26e0d6f06d4f", "filename": "tests/compile-fail/validation_recover2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover2.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,14 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    // This makes a ref that was passed to us via &mut alias with things it should not alias with\n+    pub(crate) fn safe(x: &mut &u32, target: &mut u32) {\n+        unsafe { *x = &mut *(target as *mut _); }\n+    }\n+}\n+\n+fn main() {\n+    let target = &mut 42;\n+    let mut target_alias = &42; // initial dummy value\n+    safe::safe(&mut target_alias, target); //~ ERROR: in conflict with lock ReadLock\n+}"}, {"sha": "afe6fe7c0bb9f69fe2a209072c775c6b2f073731", "filename": "tests/compile-fail/validation_recover3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Fcompile-fail%2Fvalidation_recover3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_recover3.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -0,0 +1,15 @@\n+#![allow(unused_variables)]\n+\n+mod safe {\n+    pub(crate) fn safe(x: *mut u32) {\n+        unsafe { *x = 42; } //~ ERROR: in conflict with lock WriteLock\n+    }\n+}\n+\n+fn main() {\n+    let target = &mut 42u32;\n+    let target2 = target as *mut _;\n+    drop(&mut *target); // reborrow\n+    // Now make sure we still got the lock\n+    safe::safe(target2);\n+}"}, {"sha": "439edc82dde259a1281baa1b4754740fb9f9fd25", "filename": "tests/run-pass-fullmir/catch.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fcatch.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "previous_filename": "tests/run-pass/catch.rs"}, {"sha": "892518011dbcf3ff78f2ee42360babd7c0553077", "filename": "tests/run-pass-fullmir/hashmap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fhashmap.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -1,3 +1,5 @@\n+// FIXME: disable validation until we figure out how to handle <https://github.com/solson/miri/issues/296>.\n+// compile-flags: -Zmir-emit-validate=0\n use std::collections::{self, HashMap};\n use std::hash::BuildHasherDefault;\n "}, {"sha": "44030c3301c7218a41c73125358cbe06c8a63d43", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: remove the next line once https://github.com/rust-lang/rust/issues/43359 is fixed\n-// compile-flags: -Zmir-opt-level=0\n+// FIXME: remove -Zmir-opt-level once https://github.com/rust-lang/rust/issues/43359 is fixed\n+// FIXME: remove -Zmir-emit-validate=0 once https://github.com/rust-lang/rust/pull/43748 is merged\n+// compile-flags: -Zmir-opt-level=0 -Zmir-emit-validate=0\n \n use std::i32;\n "}, {"sha": "e0387a5f405f35b7272fad2fb83e0c54e5b39098", "filename": "tests/run-pass/packed_struct.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f/tests%2Frun-pass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpacked_struct.rs?ref=85fd3f8e43f3c2d151d9f0adcac29b7bdba2811f", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: We have to disable this, force_allocation fails.\n+// TODO: I think this can be triggered even without validation.\n+// compile-flags: -Zmir-emit-validate=0\n #![allow(dead_code)]\n #![feature(unsize, coerce_unsized)]\n "}]}