{"sha": "b46f60a72968bd62560c0230b2e5dc63f107f468", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NmY2MGE3Mjk2OGJkNjI1NjBjMDIzMGIyZTVkYzYzZjEwN2Y0Njg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-17T00:05:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:57Z"}, "message": "Remove IoFactoryObject for ~IoFactory\n\nThis involved changing a fair amount of code, rooted in how we access the local\nIoFactory instance. I added a helper method to the rtio module to access the\noptional local IoFactory. This is different than before in which it was assumed\nthat a local IoFactory was *always* present. Now, a separate io_error is raised\nwhen an IoFactory is not present, yet I/O is requested.", "tree": {"sha": "df6fe4b607e94b3d9b4fb19a0abb5e45ad307176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df6fe4b607e94b3d9b4fb19a0abb5e45ad307176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b46f60a72968bd62560c0230b2e5dc63f107f468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b46f60a72968bd62560c0230b2e5dc63f107f468", "html_url": "https://github.com/rust-lang/rust/commit/b46f60a72968bd62560c0230b2e5dc63f107f468", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b46f60a72968bd62560c0230b2e5dc63f107f468/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9110a38cbfd801983a838775c690c83e9189b4c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9110a38cbfd801983a838775c690c83e9189b4c3", "html_url": "https://github.com/rust-lang/rust/commit/9110a38cbfd801983a838775c690c83e9189b4c3"}], "stats": {"total": 618, "additions": 303, "deletions": 315}, "files": [{"sha": "b2e68c8d20fa741e1fdc37cca63c07f906b6ac81", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -382,6 +382,7 @@ mod tests {\n     use libc;\n     use ptr;\n     use option::{Some, None};\n+    use vec;\n \n     #[test]\n     fn test_str_multistring_parsing() {\n@@ -391,7 +392,8 @@ mod tests {\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n             let result = do from_c_multistring(ptr as *libc::c_char, None) |c| {\n-                assert_eq!(c.as_str(), expected.next().unwrap());\n+                let cbytes = c.as_bytes().slice_to(c.len());\n+                assert_eq!(cbytes, it.next().unwrap().as_bytes());\n             };\n             assert_eq!(result, 2);\n             assert!(it.next().is_none());"}, {"sha": "0bd0213b5b06ee0d5282c58fe4c6e7a03a676bdc", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 50, "deletions": 64, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -34,12 +34,11 @@ use prelude::*;\n use c_str::ToCStr;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write};\n-use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n+use rt::rtio::{RtioFileStream, IoFactory, with_local_io};\n use rt::io::{io_error, read_error, EndOfFile,\n             FileMode, FileAccess, FileStat, IoError,\n             PathAlreadyExists, PathDoesntExist,\n             MismatchedFileTypeForOperation, ignore_io_error};\n-use rt::local::Local;\n use option::{Some, None};\n use path::Path;\n \n@@ -90,19 +89,17 @@ use path::Path;\n pub fn open<P: ToCStr>(path: &P,\n                        mode: FileMode,\n                        access: FileAccess\n-                       ) -> Option<FileStream> {\n-    let open_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_open(&path.to_c_str(), mode, access)\n-    };\n-    match open_result {\n-        Ok(fd) => Some(FileStream {\n-            fd: fd,\n-            last_nread: -1\n-        }),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+                      ) -> Option<FileStream> {\n+    do with_local_io |io| {\n+        match io.fs_open(&path.to_c_str(), mode, access) {\n+            Ok(fd) => Some(FileStream {\n+                fd: fd,\n+                last_nread: -1\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }\n@@ -129,16 +126,15 @@ pub fn open<P: ToCStr>(path: &P,\n /// This function will raise an `io_error` condition if the user lacks permissions to\n /// remove the file or if some other filesystem-level error occurs\n pub fn unlink<P: ToCStr>(path: &P) {\n-    let unlink_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_unlink(&path.to_c_str())\n-    };\n-    match unlink_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+    do with_local_io |io| {\n+        match io.fs_unlink(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Create a new, empty directory at the provided path\n@@ -158,16 +154,15 @@ pub fn unlink<P: ToCStr>(path: &P) {\n /// This call will raise an `io_error` condition if the user lacks permissions to make a\n /// new directory at the provided path, or if the directory already exists\n pub fn mkdir<P: ToCStr>(path: &P) {\n-    let mkdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_mkdir(&path.to_c_str())\n-    };\n-    match mkdir_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+    do with_local_io |io| {\n+        match io.fs_mkdir(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Remove an existing, empty directory\n@@ -187,16 +182,15 @@ pub fn mkdir<P: ToCStr>(path: &P) {\n /// This call will raise an `io_error` condition if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty\n pub fn rmdir<P: ToCStr>(path: &P) {\n-    let rmdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_rmdir(&path.to_c_str())\n-    };\n-    match rmdir_result {\n-        Ok(_) => (),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n+    do with_local_io |io| {\n+        match io.fs_rmdir(&path.to_c_str()) {\n+            Ok(_) => Some(()),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n-    }\n+    };\n }\n \n /// Get information on the file, directory, etc at the provided path\n@@ -235,17 +229,13 @@ pub fn rmdir<P: ToCStr>(path: &P) {\n /// permissions to perform a `stat` call on the given path or if there is no\n /// entry in the filesystem at the provided path.\n pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n-    let open_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_stat(&path.to_c_str())\n-    };\n-    match open_result {\n-        Ok(p) => {\n-            Some(p)\n-        },\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+    do with_local_io |io| {\n+        match io.fs_stat(&path.to_c_str()) {\n+            Ok(p) => Some(p),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }\n@@ -275,17 +265,13 @@ pub fn stat<P: ToCStr>(path: &P) -> Option<FileStat> {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir<P: ToCStr>(path: &P) -> Option<~[Path]> {\n-    let readdir_result = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).fs_readdir(&path.to_c_str(), 0)\n-    };\n-    match readdir_result {\n-        Ok(p) => {\n-            Some(p)\n-        },\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+    do with_local_io |io| {\n+        match io.fs_readdir(&path.to_c_str(), 0) {\n+            Ok(p) => Some(p),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }"}, {"sha": "1a5c197fd52716671f0bb94ea364f532644d5c09", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -369,7 +369,8 @@ pub enum IoErrorKind {\n     BrokenPipe,\n     PathAlreadyExists,\n     PathDoesntExist,\n-    MismatchedFileTypeForOperation\n+    MismatchedFileTypeForOperation,\n+    IoUnavailable,\n }\n \n // FIXME: #8242 implementing manually because deriving doesn't work for some reason\n@@ -389,7 +390,8 @@ impl ToStr for IoErrorKind {\n             BrokenPipe => ~\"BrokenPipe\",\n             PathAlreadyExists => ~\"PathAlreadyExists\",\n             PathDoesntExist => ~\"PathDoesntExist\",\n-            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\"\n+            MismatchedFileTypeForOperation => ~\"MismatchedFileTypeForOperation\",\n+            IoUnavailable => ~\"IoUnavailable\",\n         }\n     }\n }"}, {"sha": "e0c92730cd9056cafb17a8b16de7da5416350c5d", "filename": "src/libstd/rt/io/net/addrinfo.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -19,10 +19,9 @@ getaddrinfo()\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::io::io_error;\n+use rt::io::{io_error};\n use rt::io::net::ip::{SocketAddr, IpAddr};\n-use rt::rtio::{IoFactory, IoFactoryObject};\n-use rt::local::Local;\n+use rt::rtio::{IoFactory, with_local_io};\n \n /// Hints to the types of sockets that are desired when looking up hosts\n pub enum SocketType {\n@@ -94,16 +93,13 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n /// On failure, this will raise on the `io_error` condition.\n pub fn lookup(hostname: Option<&str>, servname: Option<&str>,\n               hint: Option<Hint>) -> Option<~[Info]> {\n-    let ipaddrs = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).get_host_addresses(hostname, servname, hint)\n-    };\n-\n-    match ipaddrs {\n-        Ok(i) => Some(i),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n+    do with_local_io |io| {\n+        match io.get_host_addresses(hostname, servname, hint) {\n+            Ok(i) => Some(i),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n         }\n     }\n }"}, {"sha": "bafde180d5c9eb00e3ffaeedde403d433794e441", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -13,9 +13,8 @@ use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer, Listener, Acceptor};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{IoFactory, IoFactoryObject, RtioTcpListenerObject,\n+use rt::rtio::{IoFactory, RtioTcpListenerObject, with_local_io,\n                RtioSocket, RtioTcpListener, RtioTcpAcceptor, RtioTcpStream};\n-use rt::local::Local;\n \n pub struct TcpStream {\n     priv obj: ~RtioTcpStream\n@@ -27,19 +26,13 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        let stream = unsafe {\n-            rtdebug!(\"borrowing io to connect\");\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            rtdebug!(\"about to connect\");\n-            (*io).tcp_connect(addr)\n-        };\n-\n-        match stream {\n-            Ok(s) => Some(TcpStream::new(s)),\n-            Err(ioerr) => {\n-                rtdebug!(\"failed to connect: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.tcp_connect(addr) {\n+                Ok(s) => Some(TcpStream::new(s)),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }\n@@ -101,15 +94,13 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        let listener = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).tcp_bind(addr)\n-        };\n-        match listener {\n-            Ok(l) => Some(TcpListener { obj: l }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                return None;\n+        do with_local_io |io| {\n+            match io.tcp_bind(addr) {\n+                Ok(l) => Some(TcpListener { obj: l }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "eee5dce7b6c688ee91546b631fdf5e64cdfb0bc1", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -13,24 +13,21 @@ use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n-use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, IoFactoryObject};\n-use rt::local::Local;\n+use rt::rtio::{RtioSocket, RtioUdpSocket, IoFactory, with_local_io};\n \n pub struct UdpSocket {\n     priv obj: ~RtioUdpSocket\n }\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        let socket = unsafe {\n-            let factory: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*factory).udp_bind(addr)\n-        };\n-        match socket {\n-            Ok(s) => Some(UdpSocket { obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.udp_bind(addr) {\n+                Ok(s) => Some(UdpSocket { obj: s }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "b98d5b52cb2bf3153ea874d4e64461e0fd5aa527", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -25,11 +25,10 @@ instances as clients.\n use prelude::*;\n \n use c_str::ToCStr;\n-use rt::rtio::{IoFactory, IoFactoryObject, RtioUnixListener};\n+use rt::rtio::{IoFactory, RtioUnixListener, with_local_io};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe, RtioUnixListenerObject};\n use rt::io::pipe::PipeStream;\n use rt::io::{io_error, Listener, Acceptor, Reader, Writer};\n-use rt::local::Local;\n \n /// A stream which communicates over a named pipe.\n pub struct UnixStream {\n@@ -60,16 +59,13 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        let pipe = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).unix_connect(path)\n-        };\n-\n-        match pipe {\n-            Ok(s) => Some(UnixStream::new(s)),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.unix_connect(&path.to_c_str()) {\n+                Ok(s) => Some(UnixStream::new(s)),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }\n@@ -113,15 +109,13 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        let listener = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).unix_bind(path)\n-        };\n-        match listener {\n-            Ok(s) => Some(UnixListener{ obj: s }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.unix_bind(&path.to_c_str()) {\n+                Ok(s) => Some(UnixListener{ obj: s }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "c45429ca2e6cd21e1d51b8d4e299127c922a55da", "filename": "src/libstd/rt/io/process.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fprocess.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -11,12 +11,12 @@\n //! Bindings for executing child processes\n \n use prelude::*;\n+use cell::Cell;\n \n use libc;\n use rt::io;\n use rt::io::io_error;\n-use rt::local::Local;\n-use rt::rtio::{RtioProcess, IoFactoryObject, IoFactory};\n+use rt::rtio::{RtioProcess, IoFactory, with_local_io};\n \n // windows values don't matter as long as they're at least one of unix's\n // TERM/KILL/INT signals\n@@ -83,20 +83,19 @@ impl Process {\n     /// Creates a new pipe initialized, but not bound to any particular\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n-        let process = unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            (*io).spawn(config)\n-        };\n-        match process {\n-            Ok((p, io)) => Some(Process{\n-                handle: p,\n-                io: io.move_iter().map(|p|\n-                    p.map(|p| io::PipeStream::new_bound(p))\n-                ).collect()\n-            }),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-                None\n+        let config = Cell::new(config);\n+        do with_local_io |io| {\n+            match io.spawn(config.take()) {\n+                Ok((p, io)) => Some(Process{\n+                    handle: p,\n+                    io: io.move_iter().map(|p|\n+                        p.map(|p| io::PipeStream::new_bound(p))\n+                    ).collect()\n+                }),\n+                Err(ioerr) => {\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n         }\n     }"}, {"sha": "a3cbe87431de00b34ac7d3fb6167f831731d118b", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -12,19 +12,22 @@ use fmt;\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::local::Local;\n-use rt::rtio::{IoFactoryObject, IoFactory, RtioTTY};\n+use rt::rtio::{IoFactory, RtioTTY, with_local_io};\n use super::{Reader, Writer, io_error};\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stdin() -> StdReader {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).tty_open(libc::STDIN_FILENO, true, false)\n-    }.unwrap();\n-    StdReader { inner: stream }\n+    do with_local_io |io| {\n+        match io.tty_open(libc::STDIN_FILENO, true, false) {\n+            Ok(tty) => Some(StdReader { inner: tty }),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n+            }\n+        }\n+    }.unwrap()\n }\n \n /// Creates a new non-blocking handle to the stdout of the current process.\n@@ -34,22 +37,30 @@ pub fn stdin() -> StdReader {\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).tty_open(libc::STDOUT_FILENO, false, false)\n-    }.unwrap();\n-    StdWriter { inner: stream }\n+    do with_local_io |io| {\n+        match io.tty_open(libc::STDOUT_FILENO, false, false) {\n+            Ok(tty) => Some(StdWriter { inner: tty }),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n+            }\n+        }\n+    }.unwrap()\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    let stream = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).tty_open(libc::STDERR_FILENO, false, false)\n-    }.unwrap();\n-    StdWriter { inner: stream }\n+    do with_local_io |io| {\n+        match io.tty_open(libc::STDERR_FILENO, false, false) {\n+            Ok(tty) => Some(StdWriter { inner: tty }),\n+            Err(e) => {\n+                io_error::cond.raise(e);\n+                None\n+            }\n+        }\n+    }.unwrap()\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted"}, {"sha": "fab0062ee0054ce2498ca30e8c790717a09116ed", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -10,9 +10,8 @@\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::io::{io_error};\n-use rt::rtio::{IoFactory, IoFactoryObject, RtioTimer};\n-use rt::local::Local;\n+use rt::io::io_error;\n+use rt::rtio::{IoFactory, RtioTimer, with_local_io};\n \n pub struct Timer {\n     priv obj: ~RtioTimer\n@@ -27,20 +26,19 @@ pub fn sleep(msecs: u64) {\n \n impl Timer {\n \n+    /// Creates a new timer which can be used to put the current task to sleep\n+    /// for a number of milliseconds.\n     pub fn new() -> Option<Timer> {\n-        let timer = unsafe {\n-            rtdebug!(\"Timer::init: borrowing io to init timer\");\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            rtdebug!(\"about to init timer\");\n-            (*io).timer_init()\n-        };\n-        match timer {\n-            Ok(t) => Some(Timer { obj: t }),\n-            Err(ioerr) => {\n-                rtdebug!(\"Timer::init: failed to init: {:?}\", ioerr);\n-                io_error::cond.raise(ioerr);\n-                None\n+        do with_local_io |io| {\n+            match io.timer_init() {\n+                Ok(t) => Some(Timer { obj: t }),\n+                Err(ioerr) => {\n+                    rtdebug!(\"Timer::init: failed to init: {:?}\", ioerr);\n+                    io_error::cond.raise(ioerr);\n+                    None\n+                }\n             }\n+\n         }\n     }\n "}, {"sha": "1ddc2f86f4bc40410f694b36d828534c84ec090a", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -12,8 +12,6 @@ use option::{Option, Some, None};\n use rt::sched::Scheduler;\n use rt::task::Task;\n use rt::local_ptr;\n-use rt::rtio::{EventLoop, IoFactoryObject};\n-//use borrow::to_uint;\n use cell::Cell;\n \n pub trait Local {\n@@ -122,24 +120,6 @@ impl Local for Scheduler {\n     }\n }\n \n-// XXX: This formulation won't work once ~IoFactoryObject is a real trait pointer\n-impl Local for IoFactoryObject {\n-    fn put(_value: ~IoFactoryObject) { rtabort!(\"unimpl\") }\n-    fn take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    fn exists(_: Option<IoFactoryObject>) -> bool { rtabort!(\"unimpl\") }\n-    fn borrow<T>(_f: &fn(&mut IoFactoryObject) -> T) -> T { rtabort!(\"unimpl\") }\n-    unsafe fn unsafe_take() -> ~IoFactoryObject { rtabort!(\"unimpl\") }\n-    unsafe fn unsafe_borrow() -> *mut IoFactoryObject {\n-        let sched: *mut Scheduler = Local::unsafe_borrow();\n-        let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n-        return io;\n-    }\n-    unsafe fn try_unsafe_borrow() -> Option<*mut IoFactoryObject> {\n-        rtabort!(\"unimpl\")\n-    }\n-}\n-\n-\n #[cfg(test)]\n mod test {\n     use option::None;"}, {"sha": "897bf328f23673bd4eef26e114e56c25a1f0d95b", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -33,8 +33,10 @@ pub trait EventLoop {\n     fn pausible_idle_callback(&mut self) -> ~PausibleIdleCallback;\n     fn callback_ms(&mut self, ms: u64, ~fn());\n     fn remote_callback(&mut self, ~fn()) -> ~RemoteCallback;\n+\n     /// The asynchronous I/O services. Not all event loops may provide one\n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory>;\n+    // FIXME(#9382) this is an awful interface\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory));\n }\n \n pub trait RemoteCallback {\n@@ -59,16 +61,36 @@ pub struct FileOpenConfig {\n     priv mode: int\n }\n \n+pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n+    use rt::sched::Scheduler;\n+    use rt::local::Local;\n+    use rt::io::{io_error, standard_error, IoUnavailable};\n+\n+    unsafe {\n+        let sched: *mut Scheduler = Local::unsafe_borrow();\n+        let mut io = None;\n+        (*sched).event_loop.io(|i| io = Some(i));\n+        match io {\n+            Some(io) => f(io),\n+            None => {\n+                io_error::cond.raise(standard_error(IoUnavailable));\n+                None\n+            }\n+        }\n+    }\n+}\n+\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError>;\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError>;\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n-    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n-                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n+    fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError>;\n     fn fs_mkdir(&mut self, path: &CString) -> Result<(), IoError>;\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError>;\n@@ -77,10 +99,9 @@ pub trait IoFactory {\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n \n-    fn unix_bind<P: PathLike>(&mut self, path: &P) ->\n+    fn unix_bind(&mut self, path: &CString) ->\n         Result<~RtioUnixListenerObject, IoError>;\n-    fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n-        Result<~RtioPipe, IoError>;\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool, close_on_drop: bool)\n             -> Result<~RtioTTY, IoError>;\n }"}, {"sha": "6e661884616175dd0d603ccc8cf9b9e4e022b238", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -905,6 +905,7 @@ mod test {\n     use cell::Cell;\n     use rt::thread::Thread;\n     use rt::task::{Task, Sched};\n+    use rt::rtio::EventLoop;\n     use rt::util;\n     use option::{Some};\n \n@@ -1020,7 +1021,7 @@ mod test {\n \n             // Our normal scheduler\n             let mut normal_sched = ~Scheduler::new(\n-                ~UvEventLoop::new(),\n+                ~UvEventLoop::new() as ~EventLoop,\n                 normal_queue,\n                 queues.clone(),\n                 sleepers.clone());\n@@ -1031,7 +1032,7 @@ mod test {\n \n             // Our special scheduler\n             let mut special_sched = ~Scheduler::new_special(\n-                ~UvEventLoop::new(),\n+                ~UvEventLoop::new() as ~EventLoop,\n                 special_queue.clone(),\n                 queues.clone(),\n                 sleepers.clone(),\n@@ -1202,7 +1203,7 @@ mod test {\n                 let queues = ~[queue.clone()];\n \n                 let mut sched = ~Scheduler::new(\n-                    ~UvEventLoop::new(),\n+                    ~UvEventLoop::new() as ~EventLoop,\n                     queue,\n                     queues.clone(),\n                     sleepers.clone());"}, {"sha": "c238b1dfba16a1527a3fc20cc80e1ace4d0f1b95", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -13,7 +13,7 @@ use rand::Rng;\n use os;\n use libc;\n use option::{Some, None};\n-use path::{Path, GenericPath};\n+use path::Path;\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n@@ -335,7 +335,7 @@ pub fn next_test_port() -> u16 {\n /// Get a temporary path which could be the location of a unix socket\n #[fixed_stack_segment] #[inline(never)]\n pub fn next_test_unix() -> Path {\n-    os::tmpdir().push(rand::task_rng().gen_ascii_str(20))\n+    os::tmpdir().join(rand::task_rng().gen_ascii_str(20))\n }\n \n /// Get a unique IPv4 localhost:port pair starting at 9600"}, {"sha": "78b3a88f5f1ba081c194b6943d72086fc57fb443", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -272,7 +272,6 @@ impl FsRequest {\n     }\n \n     pub fn each_path(&mut self, f: &fn(&CString)) {\n-        use str;\n         let ptr = self.get_ptr();\n         match self.get_result() {\n             n if (n <= 0) => {}\n@@ -350,7 +349,6 @@ mod test {\n     use vec;\n     use str;\n     use unstable::run_in_bare_thread;\n-    use path::Path;\n     use rt::uv::{Loop, Buf, slice_to_uv_buf};\n     use libc::{O_CREAT, O_RDWR, O_RDONLY, S_IWUSR, S_IRUSR};\n \n@@ -373,10 +371,9 @@ mod test {\n             let read_mem = vec::from_elem(read_buf_len, 0u8);\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n-            let p = Path::new(path_str);\n             let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &p, create_flags as int, mode as int)\n-            |req, uverr| {\n+            do open_req.open(&loop_, &path_str.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n                 assert!(uverr.is_none());\n                 let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n@@ -387,8 +384,8 @@ mod test {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let open_req = FsRequest::new();\n-                        do open_req.open(&loop_, &Path::new(path_str), read_flags as int,0)\n-                            |req, uverr| {\n+                        do open_req.open(&loop_, &path_str.to_c_str(),\n+                                         read_flags as int,0) |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n                             let fd = req.get_result();\n@@ -413,7 +410,8 @@ mod test {\n                                         assert!(uverr.is_none());\n                                         let loop_ = &req.get_loop();\n                                         let unlink_req = FsRequest::new();\n-                                        do unlink_req.unlink(loop_, &Path::new(path_str))\n+                                        do unlink_req.unlink(loop_,\n+                                                             &path_str.to_c_str())\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -447,8 +445,8 @@ mod test {\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n-                                                   create_flags as int, mode as int);\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n+                                            create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let fd = result.unwrap();\n             // write\n@@ -461,7 +459,7 @@ mod test {\n             assert!(result.is_ok());\n             // re-open\n             let open_req = FsRequest::new();\n-            let result = open_req.open_sync(&loop_, &Path::new(path_str),\n+            let result = open_req.open_sync(&loop_, &path_str.to_c_str(),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n@@ -485,7 +483,7 @@ mod test {\n                 assert!(result.is_ok());\n                 // unlink\n                 let unlink_req = FsRequest::new();\n-                let result = unlink_req.unlink_sync(&loop_, &Path::new(path_str));\n+                let result = unlink_req.unlink_sync(&loop_, &path_str.to_c_str());\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n@@ -521,8 +519,8 @@ mod test {\n             let write_buf  = slice_to_uv_buf(write_val);\n             let write_buf_ptr: *Buf = &write_buf;\n             let open_req = FsRequest::new();\n-            do open_req.open(&loop_, &path, create_flags as int, mode as int)\n-            |req, uverr| {\n+            do open_req.open(&loop_, &path.to_c_str(), create_flags as int,\n+                             mode as int) |req, uverr| {\n                 assert!(uverr.is_none());\n                 let fd = req.get_result();\n                 let buf = unsafe { *write_buf_ptr };\n@@ -531,7 +529,7 @@ mod test {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat_req = FsRequest::new();\n-                    do stat_req.stat(&loop_, &path) |req, uverr| {\n+                    do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let stat = req.get_stat();\n@@ -542,11 +540,13 @@ mod test {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n                             let unlink_req = FsRequest::new();\n-                            do unlink_req.unlink(&loop_, &path) |req,uverr| {\n+                            do unlink_req.unlink(&loop_,\n+                                                 &path.to_c_str()) |req,uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 let stat_req = FsRequest::new();\n-                                do stat_req.stat(&loop_, &path) |_, uverr| {\n+                                do stat_req.stat(&loop_,\n+                                                 &path.to_c_str()) |_, uverr| {\n                                     // should cause an error because the\n                                     // file doesn't exist anymore\n                                     assert!(uverr.is_some());\n@@ -569,22 +569,23 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                               mode as int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let stat_req = FsRequest::new();\n-                do stat_req.stat(&loop_, &path) |req, uverr| {\n+                do stat_req.stat(&loop_, &path.to_c_str()) |req, uverr| {\n                     assert!(uverr.is_none());\n                     let loop_ = req.get_loop();\n                     let stat = req.get_stat();\n                     naive_print(&loop_, format!(\"{:?}\", stat));\n                     assert!(stat.is_dir());\n                     let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n                         assert!(uverr.is_none());\n                         let loop_ = req.get_loop();\n                         let stat_req = FsRequest::new();\n-                        do stat_req.stat(&loop_, &path) |_req, uverr| {\n+                        do stat_req.stat(&loop_, &path.to_c_str()) |_req, uverr| {\n                             assert!(uverr.is_some());\n                         }\n                     }\n@@ -602,16 +603,17 @@ mod test {\n             let mode = S_IWUSR |\n                 S_IRUSR;\n             let mkdir_req = FsRequest::new();\n-            do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+            do mkdir_req.mkdir(&loop_, &path.to_c_str(), mode as int) |req,uverr| {\n                 assert!(uverr.is_none());\n                 let loop_ = req.get_loop();\n                 let mkdir_req = FsRequest::new();\n-                do mkdir_req.mkdir(&loop_, &path, mode as int) |req,uverr| {\n+                do mkdir_req.mkdir(&loop_, &path.to_c_str(),\n+                                   mode as int) |req,uverr| {\n                     assert!(uverr.is_some());\n                     let loop_ = req.get_loop();\n                     let _stat = req.get_stat();\n                     let rmdir_req = FsRequest::new();\n-                    do rmdir_req.rmdir(&loop_, &path) |req,uverr| {\n+                    do rmdir_req.rmdir(&loop_, &path.to_c_str()) |req,uverr| {\n                         assert!(uverr.is_none());\n                         let _loop = req.get_loop();\n                     }\n@@ -627,7 +629,7 @@ mod test {\n             let mut loop_ = Loop::new();\n             let path = \"./tmp/never_existed_dir\";\n             let rmdir_req = FsRequest::new();\n-            do rmdir_req.rmdir(&loop_, &path) |_req, uverr| {\n+            do rmdir_req.rmdir(&loop_, &path.to_c_str()) |_req, uverr| {\n                 assert!(uverr.is_some());\n             }\n             loop_.run();"}, {"sha": "96719e989721bc25c05c047ace18a1a610870349", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 83, "deletions": 74, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -18,7 +18,6 @@ use ops::Drop;\n use option::*;\n use ptr;\n use str;\n-use str::Str;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -234,8 +233,8 @@ impl EventLoop for UvEventLoop {\n         ~UvRemoteCallback::new(self.uvio.uv_loop(), f) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> {\n-        Some(&mut self.uvio as &mut IoFactory)\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+        f(&mut self.uvio as &mut IoFactory)\n     }\n }\n \n@@ -245,7 +244,7 @@ pub struct UvPausibleIdleCallback {\n     priv closed: bool\n }\n \n-impl RtioPausibleIdleCallback for UvPausibleIdleCallback {\n+impl PausibleIdleCallback for UvPausibleIdleCallback {\n     #[inline]\n     fn start(&mut self, f: ~fn()) {\n         do self.watcher.start |_idle_watcher, _status| {\n@@ -626,7 +625,9 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_instance = Cell::new(Path::new(path.as_bytes()));\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_instance = Cell::new(Path::new(slice));\n                 do stat_req.stat(self.uv_loop(), path) |req,err| {\n                     let res = match err {\n                         None => {\n@@ -720,14 +721,17 @@ impl IoFactory for UvIoFactory {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let path = path_cell.take();\n-                let path_parent = Cell::new(Path::new(path.as_bytes()));\n+                // Don't pick up the null byte\n+                let slice = path.as_bytes().slice(0, path.len());\n+                let path_parent = Cell::new(Path::new(slice));\n                 do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n                     let parent = path_parent.take();\n                     let res = match err {\n                         None => {\n                             let mut paths = ~[];\n                             do req.each_path |rel_path| {\n-                                paths.push(parent.join(rel_path.as_bytes()));\n+                                let p = rel_path.as_bytes();\n+                                paths.push(parent.join(p.slice_to(rel_path.len())));\n                             }\n                             Ok(paths)\n                         },\n@@ -799,10 +803,10 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn unix_bind<P: PathLike>(&mut self, path: &P) ->\n+    fn unix_bind(&mut self, path: &CString) ->\n         Result<~RtioUnixListenerObject, IoError> {\n         let mut pipe = Pipe::new(self.uv_loop(), false);\n-        match pipe.bind(&path.path_as_str(|s| s.to_c_str())) {\n+        match pipe.bind(path) {\n             Ok(()) => {\n                 let handle = get_handle_to_current_scheduler!();\n                 let pipe = UvUnboundPipe::new(pipe, handle);\n@@ -823,18 +827,15 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn unix_connect<P: PathLike>(&mut self, path: &P) ->\n-        Result<~RtioPipe, IoError>\n-    {\n+    fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n         let scheduler: ~Scheduler = Local::take();\n         let mut pipe = Pipe::new(self.uv_loop(), false);\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n \n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n-            let cstr = do path.path_as_str |s| { s.to_c_str() };\n-            do pipe.connect(&cstr) |stream, err| {\n+            do pipe.connect(path) |stream, err| {\n                 let res = match err {\n                     None => {\n                         let handle = stream.native_handle();\n@@ -1841,13 +1842,22 @@ impl RtioTTY for UvTTY {\n     }\n }\n \n+// this function is full of lies\n+unsafe fn local_io() -> &'static mut IoFactory {\n+    do Local::borrow |sched: &mut Scheduler| {\n+        let mut io = None;\n+        sched.event_loop.io(|i| io = Some(i));\n+        cast::transmute(io.unwrap())\n+    }\n+}\n+\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            let io = local_io();\n             let addr = next_test_ip4();\n-            let maybe_chan = (*io).tcp_connect(addr);\n+            let maybe_chan = io.tcp_connect(addr);\n             assert!(maybe_chan.is_err());\n         }\n     }\n@@ -1857,9 +1867,9 @@ fn test_simple_io_no_connect() {\n fn test_simple_udp_io_bind_only() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+            let io = local_io();\n             let addr = next_test_ip4();\n-            let maybe_socket = (*io).udp_bind(addr);\n+            let maybe_socket = io.udp_bind(addr);\n             assert!(maybe_socket.is_ok());\n         }\n     }\n@@ -1878,9 +1888,11 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         let work_queue2 = WorkQueue::new();\n         let queues = ~[work_queue1.clone(), work_queue2.clone()];\n \n-        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n                                          sleepers.clone());\n-        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n                                          sleepers.clone());\n \n         let handle1 = Cell::new(sched1.make_handle());\n@@ -1894,11 +1906,9 @@ fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n         };\n \n         let test_function: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n+            let io = unsafe { local_io() };\n             let addr = next_test_ip4();\n-            let maybe_socket = unsafe { (*io).udp_bind(addr) };\n+            let maybe_socket = io.udp_bind(addr);\n             // this socket is bound to this event loop\n             assert!(maybe_socket.is_ok());\n \n@@ -1957,9 +1967,11 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let work_queue2 = WorkQueue::new();\n         let queues = ~[work_queue1.clone(), work_queue2.clone()];\n \n-        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+        let loop1 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched1 = ~Scheduler::new(loop1, work_queue1, queues.clone(),\n                                          sleepers.clone());\n-        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+        let loop2 = ~UvEventLoop::new() as ~EventLoop;\n+        let mut sched2 = ~Scheduler::new(loop2, work_queue2, queues.clone(),\n                                          sleepers.clone());\n \n         let handle1 = Cell::new(sched1.make_handle());\n@@ -1970,11 +1982,9 @@ fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n         let chan = Cell::new(chan);\n \n         let body1: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n+            let io = unsafe { local_io() };\n             let addr = next_test_ip4();\n-            let socket = unsafe { (*io).udp_bind(addr) };\n+            let socket = io.udp_bind(addr);\n             assert!(socket.is_ok());\n             chan.take().send(socket);\n         };\n@@ -2028,8 +2038,8 @@ fn test_simple_tcp_server_and_client() {\n         // Start the server first so it's listening when we connect\n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let listener = (*io).tcp_bind(addr).unwrap();\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n                 let mut acceptor = listener.listen().unwrap();\n                 chan.take().send(());\n                 let mut stream = acceptor.accept().unwrap();\n@@ -2046,8 +2056,8 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n@@ -2071,9 +2081,11 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let client_work_queue = WorkQueue::new();\n         let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n \n-        let mut server_sched = ~Scheduler::new(~UvEventLoop::new(), server_work_queue,\n+        let sloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut server_sched = ~Scheduler::new(sloop, server_work_queue,\n                                                queues.clone(), sleepers.clone());\n-        let mut client_sched = ~Scheduler::new(~UvEventLoop::new(), client_work_queue,\n+        let cloop = ~UvEventLoop::new() as ~EventLoop;\n+        let mut client_sched = ~Scheduler::new(cloop, client_work_queue,\n                                                queues.clone(), sleepers.clone());\n \n         let server_handle = Cell::new(server_sched.make_handle());\n@@ -2090,8 +2102,8 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let server_fn: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n-            let listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(server_addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -2103,12 +2115,10 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let client_fn: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n-            let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n+            let io = unsafe { local_io() };\n+            let mut stream = io.tcp_connect(client_addr);\n             while stream.is_err() {\n-                stream = unsafe { (*io).tcp_connect(client_addr) };\n+                stream = io.tcp_connect(client_addr);\n             }\n             stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n         };\n@@ -2147,8 +2157,8 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n+                let io = local_io();\n+                let mut server_socket = io.udp_bind(server_addr).unwrap();\n                 chan.take().send(());\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n@@ -2163,8 +2173,8 @@ fn test_simple_udp_server_and_client() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n+                let io = local_io();\n+                let mut client_socket = io.udp_bind(client_addr).unwrap();\n                 port.take().recv();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n@@ -2181,8 +2191,8 @@ fn test_read_and_block() {\n         let chan = Cell::new(chan);\n \n         do spawntask {\n-            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n-            let listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let io = unsafe { local_io() };\n+            let listener = io.tcp_bind(addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             chan.take().send(());\n             let mut stream = acceptor.accept().unwrap();\n@@ -2220,8 +2230,8 @@ fn test_read_and_block() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -2243,8 +2253,8 @@ fn test_read_read_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let listener = (*io).tcp_bind(addr).unwrap();\n+                let io = local_io();\n+                let listener = io.tcp_bind(addr).unwrap();\n                 let mut acceptor = listener.listen().unwrap();\n                 chan.take().send(());\n                 let mut stream = acceptor.accept().unwrap();\n@@ -2260,8 +2270,8 @@ fn test_read_read_read() {\n         do spawntask {\n             unsafe {\n                 port.take().recv();\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let io = local_io();\n+                let mut stream = io.tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n@@ -2289,8 +2299,8 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client = (*io).udp_bind(client_addr).unwrap();\n+                let io = local_io();\n+                let mut client = io.udp_bind(client_addr).unwrap();\n                 port.take().recv();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n@@ -2299,8 +2309,8 @@ fn test_udp_twice() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server = (*io).udp_bind(server_addr).unwrap();\n+                let io = local_io();\n+                let mut server = io.udp_bind(server_addr).unwrap();\n                 chan.take().send(());\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n@@ -2334,9 +2344,9 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n-                let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n+                let io = local_io();\n+                let mut server_out = io.udp_bind(server_out_addr).unwrap();\n+                let mut server_in = io.udp_bind(server_in_addr).unwrap();\n                 let (port, chan) = first.take();\n                 chan.send(());\n                 port.recv();\n@@ -2360,9 +2370,9 @@ fn test_udp_many_read() {\n \n         do spawntask {\n             unsafe {\n-                let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n-                let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n+                let io = local_io();\n+                let mut client_out = io.udp_bind(client_out_addr).unwrap();\n+                let mut client_in = io.udp_bind(client_in_addr).unwrap();\n                 let (port, chan) = second.take();\n                 port.recv();\n                 chan.send(());\n@@ -2392,8 +2402,8 @@ fn test_udp_many_read() {\n fn test_timer_sleep_simple() {\n     do run_in_mt_newsched_task {\n         unsafe {\n-            let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-            let timer = (*io).timer_init();\n+            let io = local_io();\n+            let timer = io.timer_init();\n             do timer.map_move |mut t| { t.sleep(1) };\n         }\n     }\n@@ -2403,29 +2413,28 @@ fn file_test_uvio_full_simple_impl() {\n     use str::StrSlice; // why does this have to be explicitly imported to work?\n                        // compiler was complaining about no trait for str that\n                        // does .as_bytes() ..\n-    use path::Path;\n     use rt::io::{Open, Create, ReadWrite, Read};\n     unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        let io = local_io();\n         let write_val = \"hello uvio!\";\n         let path = \"./tmp/file_test_uvio_full.txt\";\n         {\n             let create_fm = Create;\n             let create_fa = ReadWrite;\n-            let mut fd = (*io).fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n+            let mut fd = io.fs_open(&path.to_c_str(), create_fm, create_fa).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf);\n         }\n         {\n             let ro_fm = Open;\n             let ro_fa = Read;\n-            let mut fd = (*io).fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n+            let mut fd = io.fs_open(&path.to_c_str(), ro_fm, ro_fa).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec).unwrap();\n             let read_val = str::from_utf8(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(&path.to_c_str());\n+        io.fs_unlink(&path.to_c_str());\n     }\n }\n \n@@ -2440,9 +2449,9 @@ fn uvio_naive_print(input: &str) {\n     use str::StrSlice;\n     unsafe {\n         use libc::{STDOUT_FILENO};\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        let io = local_io();\n         {\n-            let mut fd = (*io).fs_from_raw_fd(STDOUT_FILENO, false);\n+            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, false);\n             let write_buf = input.as_bytes();\n             fd.write(write_buf);\n         }"}, {"sha": "053076c5d89ec334022312657eadcec353b1f2f0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46f60a72968bd62560c0230b2e5dc63f107f468/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b46f60a72968bd62560c0230b2e5dc63f107f468", "patch": "@@ -1018,7 +1018,6 @@ static TAG_CONT_U8: u8 = 128u8;\n \n /// Unsafe operations\n pub mod raw {\n-    use option::{Option, Some};\n     use cast;\n     use libc;\n     use ptr;"}]}