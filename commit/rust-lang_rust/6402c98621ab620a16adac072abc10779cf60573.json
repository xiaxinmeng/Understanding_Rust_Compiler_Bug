{"sha": "6402c98621ab620a16adac072abc10779cf60573", "node_id": "C_kwDOAAsO6NoAKDY0MDJjOTg2MjFhYjYyMGExNmFkYWMwNzJhYmMxMDc3OWNmNjA1NzM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-16T03:04:08Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-18T19:45:02Z"}, "message": "Add consider_implied_clause", "tree": {"sha": "71a6f9634cdff7db113f24adfd0e48459198e13a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a6f9634cdff7db113f24adfd0e48459198e13a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6402c98621ab620a16adac072abc10779cf60573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6402c98621ab620a16adac072abc10779cf60573", "html_url": "https://github.com/rust-lang/rust/commit/6402c98621ab620a16adac072abc10779cf60573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6402c98621ab620a16adac072abc10779cf60573/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b52056fe99705b4234c5781eada2bd7ae6042e", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b52056fe99705b4234c5781eada2bd7ae6042e", "html_url": "https://github.com/rust-lang/rust/commit/82b52056fe99705b4234c5781eada2bd7ae6042e"}], "stats": {"total": 199, "additions": 97, "deletions": 102}, "files": [{"sha": "841169ac78d7d83e648c0190e898e85cc9b20c4c", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=6402c98621ab620a16adac072abc10779cf60573", "patch": "@@ -90,28 +90,20 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n-    fn consider_impl_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        impl_def_id: DefId,\n-    ) -> QueryResult<'tcx>;\n-\n-    // Consider a predicate we know holds (`assumption`) against a goal we're trying to prove.\n-    fn consider_assumption(\n+    // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n+    // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n+    // goal by equating it with the assumption.\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        Self::consider_assumption_with_certainty(ecx, goal, assumption, Certainty::Yes)\n-    }\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx>;\n \n-    // Consider a predicate we know holds (`assumption`) against a goal, unifying with\n-    // the `assumption_certainty` if it satisfies the goal.\n-    fn consider_assumption_with_certainty(\n+    fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-        assumption_certainty: Certainty,\n+        impl_def_id: DefId,\n     ) -> QueryResult<'tcx>;\n \n     // A type implements an `auto trait` if its components do as well. These components\n@@ -367,7 +359,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         for (i, assumption) in goal.param_env.caller_bounds().iter().enumerate() {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::ParamEnv(i), result })\n                 }\n@@ -414,7 +406,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_assumption(self, goal, assumption) {\n+            match G::consider_implied_clause(self, goal, assumption, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -464,7 +456,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         for assumption in\n             elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n         {\n-            match G::consider_assumption(self, goal, assumption.predicate) {\n+            match G::consider_implied_clause(self, goal, assumption.predicate, []) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "48153b465b7ec9487e2cef6c085032b82c7b6c0e", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 60, "deletions": 57, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=6402c98621ab620a16adac072abc10779cf60573", "patch": "@@ -168,6 +168,37 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n+    fn consider_implied_clause(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> QueryResult<'tcx> {\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n+            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n+        {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred =\n+                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n+                let mut nested_goals = ecx.infcx.eq(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                nested_goals.extend(requirements);\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n+            })\n+        } else {\n+            Err(NoSolution)\n+        }\n+    }\n+\n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n@@ -260,36 +291,6 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption_with_certainty(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-        assumption_certainty: Certainty,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.infcx.probe(|_| {\n-                let assumption_projection_pred =\n-                    ecx.infcx.instantiate_binder_with_infer(poly_projection_pred);\n-                let nested_goals = ecx.infcx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n-\n-                ecx.eq_term_and_make_canonical_response(\n-                    goal,\n-                    subst_certainty.unify_and(assumption_certainty),\n-                    assumption_projection_pred.term,\n-                )\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n     fn consider_auto_trait_candidate(\n         _ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -331,31 +332,27 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        if let Some(tupled_inputs_and_output) =\n-            structural_traits::extract_tupled_inputs_and_output_from_callable(\n-                tcx,\n-                goal.predicate.self_ty(),\n-                goal_kind,\n-            )?\n-        {\n-            // A built-in `Fn` trait needs to check that its output is `Sized`\n-            // (FIXME: technically we only need to check this if the type is a fn ptr...)\n-            let output_is_sized_pred = tupled_inputs_and_output\n-                .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n-            let (_, output_is_sized_certainty) =\n-                ecx.evaluate_goal(goal.with(tcx, output_is_sized_pred))?;\n-\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n-                    projection_ty: tcx\n-                        .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n-                    term: output.into(),\n-                })\n-                .to_predicate(tcx);\n-            Self::consider_assumption_with_certainty(ecx, goal, pred, output_is_sized_certainty)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+        let Some(tupled_inputs_and_output) =\n+        structural_traits::extract_tupled_inputs_and_output_from_callable(\n+            tcx,\n+            goal.predicate.self_ty(),\n+            goal_kind,\n+        )? else {\n+        return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+    };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, output)| ty::ProjectionPredicate {\n+                projection_ty: tcx\n+                    .mk_alias_ty(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs]),\n+                term: output.into(),\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -474,14 +471,17 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n \n         let term = substs.as_generator().return_ty().into();\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n                 projection_ty: ecx.tcx().mk_alias_ty(goal.predicate.def_id(), [self_ty]),\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n \n@@ -511,7 +511,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             bug!(\"unexpected associated item `<{self_ty} as Generator>::{name}`\")\n         };\n \n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(ty::ProjectionPredicate {\n@@ -521,6 +521,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 term,\n             })\n             .to_predicate(tcx),\n+            // Technically, we need to check that the future type is Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}, {"sha": "f2f25ef850a9a6ac92f203ec5b4b7d0aa515e8eb", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6402c98621ab620a16adac072abc10779cf60573/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=6402c98621ab620a16adac072abc10779cf60573", "patch": "@@ -62,11 +62,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_assumption_with_certainty(\n+    fn consider_implied_clause(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        assumption_certainty: Certainty,\n+        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -75,14 +75,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             ecx.infcx.probe(|_| {\n                 let assumption_trait_pred =\n                     ecx.infcx.instantiate_binder_with_infer(poly_trait_pred);\n-                let nested_goals = ecx.infcx.eq(\n+                let mut nested_goals = ecx.infcx.eq(\n                     goal.param_env,\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                ecx.evaluate_all(nested_goals).and_then(|certainty| {\n-                    ecx.make_canonical_response(certainty.unify_and(assumption_certainty))\n-                })\n+                nested_goals.extend(requirements);\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n             })\n         } else {\n             Err(NoSolution)\n@@ -178,29 +177,25 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n         let tcx = ecx.tcx();\n-        if let Some(tupled_inputs_and_output) =\n+        let Some(tupled_inputs_and_output) =\n             structural_traits::extract_tupled_inputs_and_output_from_callable(\n                 tcx,\n                 goal.predicate.self_ty(),\n                 goal_kind,\n-            )?\n-        {\n-            // A built-in `Fn` trait needs to check that its output is `Sized`\n-            // (FIXME: technically we only need to check this if the type is a fn ptr...)\n-            let output_is_sized_pred = tupled_inputs_and_output\n-                .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n-            let (_, output_is_sized_certainty) =\n-                ecx.evaluate_goal(goal.with(tcx, output_is_sized_pred))?;\n-\n-            let pred = tupled_inputs_and_output\n-                .map_bound(|(inputs, _)| {\n-                    tcx.mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n-                })\n-                .to_predicate(tcx);\n-            Self::consider_assumption_with_certainty(ecx, goal, pred, output_is_sized_certainty)\n-        } else {\n-            ecx.make_canonical_response(Certainty::AMBIGUOUS)\n-        }\n+            )? else {\n+            return ecx.make_canonical_response(Certainty::AMBIGUOUS);\n+        };\n+        let output_is_sized_pred = tupled_inputs_and_output\n+            .map_bound(|(_, output)| tcx.at(DUMMY_SP).mk_trait_ref(LangItem::Sized, [output]));\n+\n+        let pred = tupled_inputs_and_output\n+            .map_bound(|(inputs, _)| {\n+                tcx.mk_trait_ref(goal.predicate.def_id(), [goal.predicate.self_ty(), inputs])\n+            })\n+            .to_predicate(tcx);\n+        // A built-in `Fn` impl only holds if the output is sized.\n+        // (FIXME: technically we only need to check this if the type is a fn ptr...)\n+        Self::consider_implied_clause(ecx, goal, pred, [goal.with(tcx, output_is_sized_pred)])\n     }\n \n     fn consider_builtin_tuple_candidate(\n@@ -236,6 +231,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         // Async generator unconditionally implement `Future`\n+        // Technically, we need to check that the future output type is Sized,\n+        // but that's already proven by the generator being WF.\n         ecx.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -255,13 +252,16 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         }\n \n         let generator = substs.as_generator();\n-        Self::consider_assumption(\n+        Self::consider_implied_clause(\n             ecx,\n             goal,\n             ty::Binder::dummy(\n                 tcx.mk_trait_ref(goal.predicate.def_id(), [self_ty, generator.resume_ty()]),\n             )\n             .to_predicate(tcx),\n+            // Technically, we need to check that the generator types are Sized,\n+            // but that's already proven by the generator being WF.\n+            [],\n         )\n     }\n "}]}