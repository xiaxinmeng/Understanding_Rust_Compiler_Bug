{"sha": "421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "node_id": "C_kwDOAAsO6NoAKDQyMWJiNmFjNjJmNTYyNGEwNWQ5ZTRmZjBhMTJjOTFkYTkxZTQ5YTg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-24T11:00:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-03T16:44:18Z"}, "message": "Remove index from Region::EarlyBound.", "tree": {"sha": "9b909233d4d11263d602c4c09624d1ec57710cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b909233d4d11263d602c4c09624d1ec57710cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "html_url": "https://github.com/rust-lang/rust/commit/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63c3aabeb8fdde119384562341b2d3b201be54ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/63c3aabeb8fdde119384562341b2d3b201be54ed", "html_url": "https://github.com/rust-lang/rust/commit/63c3aabeb8fdde119384562341b2d3b201be54ed"}], "stats": {"total": 264, "additions": 50, "deletions": 214}, "files": [{"sha": "ddad72fdab93d9dfabeba68820cef3edfac199a1", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -133,7 +133,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                         Some(\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_, _)\n+                            | rl::Region::EarlyBound(_)\n                             | rl::Region::LateBound(_, _, _),\n                         )\n                         | None,\n@@ -188,7 +188,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n@@ -209,7 +209,7 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n             (\n                 Some(\n                     rl::Region::Static\n-                    | rl::Region::EarlyBound(_, _)\n+                    | rl::Region::EarlyBound(_)\n                     | rl::Region::LateBound(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )"}, {"sha": "7c49749137db5bdfd6558bf8a52fcb83543d0b99", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -2039,13 +2039,13 @@ declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMEN\n impl ExplicitOutlivesRequirements {\n     fn lifetimes_outliving_lifetime<'tcx>(\n         inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n-        index: u32,\n+        def_id: DefId,\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n             .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match *a {\n-                    ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n+                    ty::ReEarlyBound(ebr) if ebr.def_id == def_id => Some(b),\n                     _ => None,\n                 },\n                 _ => None,\n@@ -2082,8 +2082,12 @@ impl ExplicitOutlivesRequirements {\n             .filter_map(|(i, bound)| {\n                 if let hir::GenericBound::Outlives(lifetime) = bound {\n                     let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                        Some(Region::EarlyBound(index, ..)) => inferred_outlives.iter().any(|r| {\n-                            if let ty::ReEarlyBound(ebr) = **r { ebr.index == index } else { false }\n+                        Some(Region::EarlyBound(def_id)) => inferred_outlives.iter().any(|r| {\n+                            if let ty::ReEarlyBound(ebr) = **r {\n+                                ebr.def_id == def_id\n+                            } else {\n+                                false\n+                            }\n                         }),\n                         _ => false,\n                     };\n@@ -2177,11 +2181,14 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n                 let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n                     hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(index, ..)) =\n+                        if let Some(Region::EarlyBound(region_def_id)) =\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n                         {\n                             (\n-                                Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n+                                Self::lifetimes_outliving_lifetime(\n+                                    inferred_outlives,\n+                                    region_def_id,\n+                                ),\n                                 &predicate.bounds,\n                                 predicate.span,\n                                 predicate.in_where_clause,"}, {"sha": "a171f5711dcffd3304c86dc958f8651aecbcebd6", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -10,7 +10,7 @@ use rustc_macros::HashStable;\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n+    EarlyBound(/* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n }"}, {"sha": "01ada080b019cbbf805cd6476d4b91cefc045ef6", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 24, "deletions": 199, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -25,7 +25,7 @@ use rustc_span::Span;\n use std::fmt;\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n@@ -34,19 +34,13 @@ trait RegionExt {\n     fn shifted(self, amount: u32) -> Region;\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region;\n-\n-    fn subst<'a, L>(self, params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>;\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n-        let i = *index;\n-        *index += 1;\n+    fn early(hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let def_id = hir_map.local_def_id(param.hir_id);\n-        debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n+        debug!(\"Region::early: def_id={:?}\", def_id);\n+        (def_id, Region::EarlyBound(def_id.to_def_id()))\n     }\n \n     fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n@@ -63,9 +57,7 @@ impl RegionExt for Region {\n         match *self {\n             Region::Static => None,\n \n-            Region::EarlyBound(_, id) | Region::LateBound(_, _, id) | Region::Free(_, id) => {\n-                Some(id)\n-            }\n+            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n         }\n     }\n \n@@ -86,17 +78,6 @@ impl RegionExt for Region {\n             _ => self,\n         }\n     }\n-\n-    fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n-    where\n-        L: Iterator<Item = &'a hir::Lifetime>,\n-    {\n-        if let Region::EarlyBound(index, _) = self {\n-            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n-        } else {\n-            Some(self)\n-        }\n-    }\n }\n \n /// Maps the id of each lifetime reference to the lifetime decl\n@@ -142,25 +123,6 @@ enum Scope<'a> {\n         /// for diagnostics.\n         lifetimes: FxIndexMap<LocalDefId, Region>,\n \n-        /// if we extend this scope with another scope, what is the next index\n-        /// we should use for an early-bound region?\n-        next_early_index: u32,\n-\n-        /// Whether or not this binder would serve as the parent\n-        /// binder for opaque types introduced within. For example:\n-        ///\n-        /// ```text\n-        ///     fn foo<'a>() -> impl for<'b> Trait<Item = impl Trait2<'a>>\n-        /// ```\n-        ///\n-        /// Here, the opaque types we create for the `impl Trait`\n-        /// and `impl Trait2` references will both have the `foo` item\n-        /// as their parent. When we get to `impl Trait2`, we find\n-        /// that it is nested within the `for<>` binder -- this flag\n-        /// allows us to skip that when looking for the parent binder\n-        /// of the resulting opaque type.\n-        opaque_type_parent: bool,\n-\n         scope_type: BinderScopeType,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n@@ -240,19 +202,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder {\n-                lifetimes,\n-                next_early_index,\n-                opaque_type_parent,\n-                scope_type,\n-                hir_id,\n-                where_bound_origin,\n-                s: _,\n-            } => f\n+            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n-                .field(\"next_early_index\", next_early_index)\n-                .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -423,13 +375,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-/// In traits, there is an implicit `Self` type parameter which comes before the generics.\n-/// We have to account for this when computing the index of the other generic parameters.\n-/// This function returns whether there is such an implicit parameter defined on the given item.\n-fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n-    matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -549,7 +494,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let next_early_index = self.next_early_index();\n             let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n@@ -567,8 +511,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 hir_id: e.hir_id,\n                 lifetimes,\n                 s: self.scope,\n-                next_early_index,\n-                opaque_type_parent: false,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n             };\n@@ -594,7 +536,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         match item.kind {\n             hir::ItemKind::Fn(_, ref generics, _) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -661,31 +603,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n             | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let mut index = if sub_items_have_self_param(&item.kind) {\n-                    1 // Self comes before lifetimes\n-                } else {\n-                    0\n-                };\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                     where_bound_origin: None,\n@@ -703,7 +634,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(_, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), generics, |this| {\n+                self.visit_early_late(item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -720,7 +651,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(ref c) => {\n-                let next_early_index = self.next_early_index();\n                 let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n@@ -737,8 +667,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n                     s: self.scope,\n-                    next_early_index,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -877,32 +805,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut index = self.next_early_index_for_opaque_type();\n-                debug!(?index);\n-\n                 let mut lifetimes = FxIndexMap::default();\n-                let mut non_lifetime_count = 0;\n                 debug!(?generics.params);\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n                             lifetimes.insert(def_id, reg);\n                         }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n-                let next_early_index = index + non_lifetime_count;\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index,\n                     s: self.scope,\n-                    opaque_type_parent: false,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -924,39 +843,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n             Fn(_, _) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n-                    trait_item.hir_id(),\n-                    &trait_item.generics,\n-                    |this| intravisit::walk_trait_item(this, trait_item),\n-                );\n+                self.visit_early_late(trait_item.hir_id(), &trait_item.generics, |this| {\n+                    intravisit::walk_trait_item(this, trait_item)\n+                });\n             }\n             Type(bounds, ref ty) => {\n                 let generics = &trait_item.generics;\n-                let mut index = self.next_early_index();\n-                debug!(\"visit_ty: index = {}\", index);\n-                let mut non_lifetime_count = 0;\n                 let lifetimes = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -984,40 +891,26 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(..) => {\n-                let tcx = self.tcx;\n-                self.visit_early_late(\n-                    Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n-                    impl_item.hir_id(),\n-                    &impl_item.generics,\n-                    |this| intravisit::walk_impl_item(this, impl_item),\n-                );\n-            }\n+            Fn(..) => self.visit_early_late(impl_item.hir_id(), &impl_item.generics, |this| {\n+                intravisit::walk_impl_item(this, impl_item)\n+            }),\n             TyAlias(ref ty) => {\n                 let generics = &impl_item.generics;\n-                let mut index = self.next_early_index();\n-                let mut non_lifetime_count = 0;\n-                debug!(\"visit_ty: index = {}\", index);\n                 let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(self.tcx.hir(), &mut index, param))\n-                        }\n-                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n-                            non_lifetime_count += 1;\n-                            None\n+                            Some(Region::early(self.tcx.hir(), param))\n                         }\n+                        GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n                     })\n                     .collect();\n                 self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n                     lifetimes,\n-                    next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n-                    opaque_type_parent: true,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n                 };\n@@ -1120,7 +1013,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 })\n                                 .unzip();\n                         this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                        let next_early_index = this.next_early_index();\n                         // Even if there are no lifetimes defined here, we still wrap it in a binder\n                         // scope. If there happens to be a nested poly trait ref (an error), that\n                         // will be `Concatenating` anyways, so we don't have to worry about the depth\n@@ -1129,8 +1021,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             hir_id: bounded_ty.hir_id,\n                             lifetimes,\n                             s: this.scope,\n-                            next_early_index,\n-                            opaque_type_parent: false,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n                         };\n@@ -1201,8 +1091,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: *hir_id,\n                     lifetimes: FxIndexMap::default(),\n                     s: self.scope,\n-                    next_early_index: self.next_early_index(),\n-                    opaque_type_parent: false,\n                     scope_type,\n                     where_bound_origin: None,\n                 };\n@@ -1221,7 +1109,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref(trait_ref={:?})\", trait_ref);\n \n-        let next_early_index = self.next_early_index();\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n@@ -1251,8 +1138,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n             lifetimes,\n             s: self.scope,\n-            next_early_index,\n-            opaque_type_parent: false,\n             scope_type,\n             where_bound_origin: None,\n         };\n@@ -1354,30 +1239,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(\n         &mut self,\n-        parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        // Find the start of nested early scopes, e.g., in methods.\n-        let mut next_early_index = 0;\n-        if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item(parent_id);\n-            if sub_items_have_self_param(&parent.kind) {\n-                next_early_index += 1; // Self comes before lifetimes\n-            }\n-            match parent.kind {\n-                hir::ItemKind::Trait(_, _, ref generics, ..)\n-                | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                    next_early_index += generics.params.len() as u32;\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n         let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n@@ -1389,16 +1256,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(self.tcx.hir(), &mut next_early_index, param))\n+                        Some(Region::early(self.tcx.hir(), param))\n                     }\n                 }\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                    non_lifetime_count += 1;\n-                    None\n-                }\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n             })\n             .collect();\n-        let next_early_index = next_early_index + non_lifetime_count;\n \n         let binders: Vec<_> = generics\n             .params\n@@ -1417,51 +1280,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let scope = Scope::Binder {\n             hir_id,\n             lifetimes,\n-            next_early_index,\n             s: self.scope,\n-            opaque_type_parent: true,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n         };\n         self.with(scope, walk);\n     }\n \n-    fn next_early_index_helper(&self, only_opaque_type_parent: bool) -> u32 {\n-        let mut scope = self.scope;\n-        loop {\n-            match *scope {\n-                Scope::Root => return 0,\n-\n-                Scope::Binder { next_early_index, opaque_type_parent, .. }\n-                    if (!only_opaque_type_parent || opaque_type_parent) =>\n-                {\n-                    return next_early_index;\n-                }\n-\n-                Scope::Binder { s, .. }\n-                | Scope::Body { s, .. }\n-                | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => scope = s,\n-            }\n-        }\n-    }\n-\n-    /// Returns the next index one would use for an early-bound-region\n-    /// if extending the current scope.\n-    fn next_early_index(&self) -> u32 {\n-        self.next_early_index_helper(true)\n-    }\n-\n-    /// Returns the next index one would use for an `impl Trait` that\n-    /// is being converted into an opaque type alias `impl Trait`. This will be the\n-    /// next early index from the enclosing item, for the most\n-    /// part. See the `opaque_type_parent` field for more info.\n-    fn next_early_index_for_opaque_type(&self) -> u32 {\n-        self.next_early_index_helper(false)\n-    }\n-\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_lifetime_ref(\n         &mut self,"}, {"sha": "bb2c533aa16ec0b0856abc5f36f9ddf7bdb167b6", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -221,7 +221,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::EarlyBound(_, def_id)) => {\n+            Some(rl::Region::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n@@ -2840,10 +2840,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             );\n \n             if !infer_replacements.is_empty() {\n-                diag.multipart_suggestion(&format!(\n+                diag.multipart_suggestion(\n+                    &format!(\n                     \"try replacing `_` with the type{} in the corresponding trait method signature\",\n                     rustc_errors::pluralize!(infer_replacements.len()),\n-                ), infer_replacements, Applicability::MachineApplicable);\n+                ),\n+                    infer_replacements,\n+                    Applicability::MachineApplicable,\n+                );\n             }\n \n             diag.emit();"}, {"sha": "d8955a50cd2abfa61ecaa90c4ca9cb78711e53bf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/421bb6ac62f5624a05d9e4ff0a12c91da91e49a8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=421bb6ac62f5624a05d9e4ff0a12c91da91e49a8", "patch": "@@ -216,7 +216,7 @@ impl<'tcx> Clean<'tcx, GenericBound> for ty::PolyTraitRef<'tcx> {\n fn clean_lifetime<'tcx>(lifetime: hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n     let def = cx.tcx.named_region(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(_, node_id)\n+        rl::Region::EarlyBound(node_id)\n         | rl::Region::LateBound(_, _, node_id)\n         | rl::Region::Free(_, node_id),\n     ) = def"}]}