{"sha": "2fd4663feeec050379c91393474d3ecfd198b2b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZDQ2NjNmZWVlYzA1MDM3OWM5MTM5MzQ3NGQzZWNmZDE5OGIyYjQ=", "commit": {"author": {"name": "Ian Douglas Scott", "email": "ian@iandouglasscott.com", "date": "2017-08-04T04:13:44Z"}, "committer": {"name": "Ian Douglas Scott", "email": "ian@iandouglasscott.com", "date": "2017-08-04T04:13:44Z"}, "message": "Make backtraces work on Redox, copying Unix implementation", "tree": {"sha": "c902f7f44f57aef70a75e302382a808b7488588f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c902f7f44f57aef70a75e302382a808b7488588f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fd4663feeec050379c91393474d3ecfd198b2b4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEECYv1aaNg4jTOK4YaSSThDhmbWVkFAlmD9KwACgkQSSThDhmb\nWVl9FggAlJDKBswbwOjs33UFhmBSs3PylmzLts6T1SAP5ces34+yoJQVlO/nMQP3\nmnthxjLwi0ocwCxPD7K2f/f/zQPPviCp21ZRNItKCrfctKJDXXAGmeOcyYTVLvow\nJv3DP6mtjYLKJmLIozrHQch9blNimdU/o5ndD94Fum7qrDkX+vv4NM/riwmSrpya\nwc/H1Mym5AE2S+JbPTgCvFwUCVTjymGkKGpADlT2eg7PlMVVAKqmGe3vrcsJglhM\nqq7AFX3xZgK1aGpXhNtAoalBOmgUIU7JS4gq+iuW7N6XXjQTetaEG27GHfuUDnFv\nBYtAzx5QL7sCQrYQOi9z08PhaQL91w==\n=CZr9\n-----END PGP SIGNATURE-----", "payload": "tree c902f7f44f57aef70a75e302382a808b7488588f\nparent 0fad1b1cd8e6577590108c653e4818685e0f7b03\nauthor Ian Douglas Scott <ian@iandouglasscott.com> 1501820024 -0700\ncommitter Ian Douglas Scott <ian@iandouglasscott.com> 1501820024 -0700\n\nMake backtraces work on Redox, copying Unix implementation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fd4663feeec050379c91393474d3ecfd198b2b4", "html_url": "https://github.com/rust-lang/rust/commit/2fd4663feeec050379c91393474d3ecfd198b2b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fd4663feeec050379c91393474d3ecfd198b2b4/comments", "author": {"login": "ids1024", "id": 2263150, "node_id": "MDQ6VXNlcjIyNjMxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2263150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ids1024", "html_url": "https://github.com/ids1024", "followers_url": "https://api.github.com/users/ids1024/followers", "following_url": "https://api.github.com/users/ids1024/following{/other_user}", "gists_url": "https://api.github.com/users/ids1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/ids1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ids1024/subscriptions", "organizations_url": "https://api.github.com/users/ids1024/orgs", "repos_url": "https://api.github.com/users/ids1024/repos", "events_url": "https://api.github.com/users/ids1024/events{/privacy}", "received_events_url": "https://api.github.com/users/ids1024/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ids1024", "id": 2263150, "node_id": "MDQ6VXNlcjIyNjMxNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/2263150?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ids1024", "html_url": "https://github.com/ids1024", "followers_url": "https://api.github.com/users/ids1024/followers", "following_url": "https://api.github.com/users/ids1024/following{/other_user}", "gists_url": "https://api.github.com/users/ids1024/gists{/gist_id}", "starred_url": "https://api.github.com/users/ids1024/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ids1024/subscriptions", "organizations_url": "https://api.github.com/users/ids1024/orgs", "repos_url": "https://api.github.com/users/ids1024/repos", "events_url": "https://api.github.com/users/ids1024/events{/privacy}", "received_events_url": "https://api.github.com/users/ids1024/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fad1b1cd8e6577590108c653e4818685e0f7b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fad1b1cd8e6577590108c653e4818685e0f7b03", "html_url": "https://github.com/rust-lang/rust/commit/0fad1b1cd8e6577590108c653e4818685e0f7b03"}], "stats": {"total": 399, "additions": 366, "deletions": 33}, "files": [{"sha": "ab304f4c9652a53ebd6004a7f451606496666d0f", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n     let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     if cfg!(feature = \"backtrace\") && !target.contains(\"apple\") && !target.contains(\"msvc\") &&\n-        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") && !target.contains(\"redox\") {\n+        !target.contains(\"emscripten\") && !target.contains(\"fuchsia\") {\n         let _ = build_libbacktrace(&host, &target);\n     }\n "}, {"sha": "6cafe3e69bac12bc99f338ef3b0ca637e86d99cb", "filename": "src/libstd/sys/redox/backtrace.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0fad1b1cd8e6577590108c653e4818685e0f7b03/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fad1b1cd8e6577590108c653e4818685e0f7b03/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace.rs?ref=0fad1b1cd8e6577590108c653e4818685e0f7b03", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use io;\n-use sys_common::backtrace::Frame;\n-\n-pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n-pub struct BacktraceContext;\n-\n-#[inline(never)]\n-pub fn unwind_backtrace(_frames: &mut [Frame])\n-    -> io::Result<(usize, BacktraceContext)>\n-{\n-    Ok((0, BacktraceContext))\n-}\n-\n-pub mod gnu {\n-    use io;\n-    use fs;\n-    use libc::c_char;\n-\n-    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n-        Err(io::Error::new(io::ErrorKind::Other, \"Not implemented\"))\n-    }\n-}"}, {"sha": "2171494c499388d7b07377bb22f3e963c70bf776", "filename": "src/libstd/sys/redox/backtrace/mod.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fmod.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Backtrace support built on libgcc with some extra OS-specific support\n+///\n+/// Some methods of getting a backtrace:\n+///\n+/// * The backtrace() functions on unix. It turns out this doesn't work very\n+///   well for green threads on macOS, and the address to symbol portion of it\n+///   suffers problems that are described below.\n+///\n+/// * Using libunwind. This is more difficult than it sounds because libunwind\n+///   isn't installed everywhere by default. It's also a bit of a hefty library,\n+///   so possibly not the best option. When testing, libunwind was excellent at\n+///   getting both accurate backtraces and accurate symbols across platforms.\n+///   This route was not chosen in favor of the next option, however.\n+///\n+/// * We're already using libgcc_s for exceptions in rust (triggering thread\n+///   unwinding and running destructors on the stack), and it turns out that it\n+///   conveniently comes with a function that also gives us a backtrace. All of\n+///   these functions look like _Unwind_*, but it's not quite the full\n+///   repertoire of the libunwind API. Due to it already being in use, this was\n+///   the chosen route of getting a backtrace.\n+///\n+/// After choosing libgcc_s for backtraces, the sad part is that it will only\n+/// give us a stack trace of instruction pointers. Thankfully these instruction\n+/// pointers are accurate (they work for green and native threads), but it's\n+/// then up to us again to figure out how to translate these addresses to\n+/// symbols. As with before, we have a few options. Before, that, a little bit\n+/// of an interlude about symbols. This is my very limited knowledge about\n+/// symbol tables, and this information is likely slightly wrong, but the\n+/// general idea should be correct.\n+///\n+/// When talking about symbols, it's helpful to know a few things about where\n+/// symbols are located. Some symbols are located in the dynamic symbol table\n+/// of the executable which in theory means that they're available for dynamic\n+/// linking and lookup. Other symbols end up only in the local symbol table of\n+/// the file. This loosely corresponds to pub and priv functions in Rust.\n+///\n+/// Armed with this knowledge, we know that our solution for address to symbol\n+/// translation will need to consult both the local and dynamic symbol tables.\n+/// With that in mind, here's our options of translating an address to\n+/// a symbol.\n+///\n+/// * Use dladdr(). The original backtrace()-based idea actually uses dladdr()\n+///   behind the scenes to translate, and this is why backtrace() was not used.\n+///   Conveniently, this method works fantastically on macOS. It appears dladdr()\n+///   uses magic to consult the local symbol table, or we're putting everything\n+///   in the dynamic symbol table anyway. Regardless, for macOS, this is the\n+///   method used for translation. It's provided by the system and easy to do.o\n+///\n+///   Sadly, all other systems have a dladdr() implementation that does not\n+///   consult the local symbol table. This means that most functions are blank\n+///   because they don't have symbols. This means that we need another solution.\n+///\n+/// * Use unw_get_proc_name(). This is part of the libunwind api (not the\n+///   libgcc_s version of the libunwind api), but involves taking a dependency\n+///   to libunwind. We may pursue this route in the future if we bundle\n+///   libunwind, but libunwind was unwieldy enough that it was not chosen at\n+///   this time to provide this functionality.\n+///\n+/// * Shell out to a utility like `readelf`. Crazy though it may sound, it's a\n+///   semi-reasonable solution. The stdlib already knows how to spawn processes,\n+///   so in theory it could invoke readelf, parse the output, and consult the\n+///   local/dynamic symbol tables from there. This ended up not getting chosen\n+///   due to the craziness of the idea plus the advent of the next option.\n+///\n+/// * Use `libbacktrace`. It turns out that this is a small library bundled in\n+///   the gcc repository which provides backtrace and symbol translation\n+///   functionality. All we really need from it is the backtrace functionality,\n+///   and we only really need this on everything that's not macOS, so this is the\n+///   chosen route for now.\n+///\n+/// In summary, the current situation uses libgcc_s to get a trace of stack\n+/// pointers, and we use dladdr() or libbacktrace to translate these addresses\n+/// to symbols. This is a bit of a hokey implementation as-is, but it works for\n+/// all unix platforms we support right now, so it at least gets the job done.\n+\n+pub use self::tracing::unwind_backtrace;\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n+\n+// tracing impls:\n+mod tracing;\n+// symbol resolvers:\n+mod printing;\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"emscripten\")))]\n+pub mod gnu {\n+    use io;\n+    use fs;\n+    use libc::c_char;\n+    use vec::Vec;\n+    use ffi::OsStr;\n+    use os::unix::ffi::OsStrExt;\n+    use io::Read;\n+\n+    pub fn get_executable_filename() -> io::Result<(Vec<c_char>, fs::File)> {\n+        let mut exefile = fs::File::open(\"sys:exe\")?;\n+        let mut exename = Vec::new();\n+        exefile.read_to_end(&mut exename)?;\n+        if exename.last() == Some(&b'\\n') {\n+            exename.pop();\n+        }\n+        let file = fs::File::open(OsStr::from_bytes(&exename))?;\n+        Ok((exename.into_iter().map(|c| c as c_char).collect(), file))\n+    }\n+}\n+\n+pub struct BacktraceContext;"}, {"sha": "05a071a79783841072bd20c7bf505e5197cf8b1b", "filename": "src/libstd/sys/redox/backtrace/printing/dladdr.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fdladdr.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use intrinsics;\n+use ffi::CStr;\n+use libc;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n+\n+pub fn resolve_symname<F>(frame: Frame,\n+                          callback: F,\n+                          _: &BacktraceContext) -> io::Result<()>\n+    where F: FnOnce(Option<&str>) -> io::Result<()>\n+{\n+    unsafe {\n+        let mut info: Dl_info = intrinsics::init();\n+        let symname = if dladdr(frame.exact_position, &mut info) == 0 {\n+            None\n+        } else {\n+            CStr::from_ptr(info.dli_sname).to_str().ok()\n+        };\n+        callback(symname)\n+    }\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_symbol_addr: Frame,\n+                                  _f: F,\n+                                  _: &BacktraceContext) -> io::Result<bool>\n+    where F: FnMut(&[u8], libc::c_int) -> io::Result<()>\n+{\n+    Ok(false)\n+}\n+\n+#[repr(C)]\n+struct Dl_info {\n+    dli_fname: *const libc::c_char,\n+    dli_fbase: *mut libc::c_void,\n+    dli_sname: *const libc::c_char,\n+    dli_saddr: *mut libc::c_void,\n+}\n+\n+extern {\n+    fn dladdr(addr: *const libc::c_void,\n+              info: *mut Dl_info) -> libc::c_int;\n+}"}, {"sha": "1ae82e01100169e5cd451f317ce4eb944547e4b7", "filename": "src/libstd/sys/redox/backtrace/printing/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Fprinting%2Fmod.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::imp::{foreach_symbol_fileline, resolve_symname};\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\",\n+          target_os = \"emscripten\"))]\n+#[path = \"dladdr.rs\"]\n+mod imp;\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\",\n+              target_os = \"emscripten\")))]\n+mod imp {\n+    pub use sys_common::gnu::libbacktrace::{foreach_symbol_fileline, resolve_symname};\n+}"}, {"sha": "ecd32aa9462a904d5dea1ca929328892ed3dcebe", "filename": "src/libstd/sys/redox/backtrace/tracing/backtrace_fn.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fbacktrace_fn.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// As always - iOS on arm uses SjLj exceptions and\n+/// _Unwind_Backtrace is even not available there. Still,\n+/// backtraces could be extracted using a backtrace function,\n+/// which thanks god is public\n+///\n+/// As mentioned in a huge comment block in `super::super`, backtrace\n+/// doesn't play well with green threads, so while it is extremely nice and\n+/// simple to use it should be used only on iOS devices as the only viable\n+/// option.\n+\n+use io;\n+use libc;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    const FRAME_LEN: usize = 100;\n+    assert!(FRAME_LEN >= frames.len());\n+    let mut raw_frames = [::ptr::null_mut(); FRAME_LEN];\n+    let nb_frames = unsafe {\n+        backtrace(raw_frames.as_mut_ptr(), raw_frames.len() as libc::c_int)\n+    } as usize;\n+    for (from, to) in raw_frames.iter().zip(frames.iter_mut()).take(nb_frames) {\n+        *to = Frame {\n+            exact_position: *from,\n+            symbol_addr: *from,\n+        };\n+    }\n+    Ok((nb_frames as usize, BacktraceContext))\n+}\n+\n+extern {\n+    fn backtrace(buf: *mut *mut libc::c_void, sz: libc::c_int) -> libc::c_int;\n+}"}, {"sha": "cfeabaddda9859fea27aa88a3da3da5d40d7d50d", "filename": "src/libstd/sys/redox/backtrace/tracing/gcc_s.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fgcc_s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fgcc_s.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error;\n+use io;\n+use libc;\n+use sys::backtrace::BacktraceContext;\n+use sys_common::backtrace::Frame;\n+\n+use unwind as uw;\n+\n+struct Context<'a> {\n+    idx: usize,\n+    frames: &'a mut [Frame],\n+}\n+\n+#[derive(Debug)]\n+struct UnwindError(uw::_Unwind_Reason_Code);\n+\n+impl Error for UnwindError {\n+    fn description(&self) -> &'static str {\n+        \"unexpected return value while unwinding\"\n+    }\n+}\n+\n+impl ::fmt::Display for UnwindError {\n+    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        write!(f, \"{}: {:?}\", self.description(), self.0)\n+    }\n+}\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame])\n+    -> io::Result<(usize, BacktraceContext)>\n+{\n+    let mut cx = Context {\n+        idx: 0,\n+        frames: frames,\n+    };\n+    let result_unwind = unsafe {\n+        uw::_Unwind_Backtrace(trace_fn,\n+                              &mut cx as *mut Context\n+                              as *mut libc::c_void)\n+    };\n+    // See libunwind:src/unwind/Backtrace.c for the return values.\n+    // No, there is no doc.\n+    match result_unwind {\n+        // These return codes seem to be benign and need to be ignored for backtraces\n+        // to show up properly on all tested platforms.\n+        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n+            Ok((cx.idx, BacktraceContext))\n+        }\n+        _ => {\n+            Err(io::Error::new(io::ErrorKind::Other,\n+                               UnwindError(result_unwind)))\n+        }\n+    }\n+}\n+\n+extern fn trace_fn(ctx: *mut uw::_Unwind_Context,\n+                   arg: *mut libc::c_void) -> uw::_Unwind_Reason_Code {\n+    let cx = unsafe { &mut *(arg as *mut Context) };\n+    let mut ip_before_insn = 0;\n+    let mut ip = unsafe {\n+        uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void\n+    };\n+    if !ip.is_null() && ip_before_insn == 0 {\n+        // this is a non-signaling frame, so `ip` refers to the address\n+        // after the calling instruction. account for that.\n+        ip = (ip as usize - 1) as *mut _;\n+    }\n+\n+    // dladdr() on osx gets whiny when we use FindEnclosingFunction, and\n+    // it appears to work fine without it, so we only use\n+    // FindEnclosingFunction on non-osx platforms. In doing so, we get a\n+    // slightly more accurate stack trace in the process.\n+    //\n+    // This is often because panic involves the last instruction of a\n+    // function being \"call std::rt::begin_unwind\", with no ret\n+    // instructions after it. This means that the return instruction\n+    // pointer points *outside* of the calling function, and by\n+    // unwinding it we go back to the original function.\n+    let symaddr = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n+        ip\n+    } else {\n+        unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n+    };\n+\n+    if cx.idx < cx.frames.len() {\n+        cx.frames[cx.idx] = Frame {\n+            symbol_addr: symaddr,\n+            exact_position: ip,\n+        };\n+        cx.idx += 1;\n+    }\n+\n+    uw::_URC_NO_REASON\n+}"}, {"sha": "c9c8e260d2f6336390144234d86c9cb12f533744", "filename": "src/libstd/sys/redox/backtrace/tracing/mod.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fbacktrace%2Ftracing%2Fmod.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::imp::*;\n+\n+#[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))]\n+#[path = \"gcc_s.rs\"]\n+mod imp;\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n+#[path = \"backtrace_fn.rs\"]\n+mod imp;"}, {"sha": "cb8cb90e9ca7afac208baafed43bcc180d32c542", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fd4663feeec050379c91393474d3ecfd198b2b4/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=2fd4663feeec050379c91393474d3ecfd198b2b4", "patch": "@@ -41,5 +41,7 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=unwind\");\n     } else if target.contains(\"haiku\") {\n         println!(\"cargo:rustc-link-lib=gcc_s\");\n+    } else if target.contains(\"redox\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n     }\n }"}]}