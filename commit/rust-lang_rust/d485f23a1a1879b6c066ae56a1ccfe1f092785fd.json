{"sha": "d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ODVmMjNhMWExODc5YjZjMDY2YWU1NmExY2NmZTFmMDkyNzg1ZmQ=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-15T22:21:35Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-22T22:31:38Z"}, "message": "Added most of the Graph500 validation routine. It's very slow.", "tree": {"sha": "69994aaad0a3b78ba5ad8d1f5958b8763ed62ffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69994aaad0a3b78ba5ad8d1f5958b8763ed62ffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "html_url": "https://github.com/rust-lang/rust/commit/d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d485f23a1a1879b6c066ae56a1ccfe1f092785fd/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b9ebffa0a1390a6783547e1d1f5e20913756eb", "html_url": "https://github.com/rust-lang/rust/commit/f5b9ebffa0a1390a6783547e1d1f5e20913756eb"}], "stats": {"total": 113, "additions": 109, "deletions": 4}, "files": [{"sha": "3295ab2f07c991c4157e8f1c4737f5ad23884116", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d485f23a1a1879b6c066ae56a1ccfe1f092785fd/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d485f23a1a1879b6c066ae56a1ccfe1f092785fd/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=d485f23a1a1879b6c066ae56a1ccfe1f092785fd", "patch": "@@ -11,11 +11,12 @@ import std::map::hashmap;\n import std::deque;\n import std::deque::t;\n import io::writer_util;\n-import vec::extensions;\n import comm::*;\n+import int::abs;\n \n type node_id = i64;\n type graph = [map::set<node_id>];\n+type bfs_result = [node_id];\n \n iface queue<T: send> {\n     fn add_back(T);\n@@ -118,7 +119,7 @@ fn make_graph(N: uint, edges: [(node_id, node_id)]) -> graph {\n #[doc=\"Returns a vector of all the parents in the BFS tree rooted at key.\n \n Nodes that are unreachable have a parent of -1.\"]\n-fn bfs(graph: graph, key: node_id) -> [node_id] {\n+fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let marks : [mut node_id] \n         = vec::to_mut(vec::from_elem(vec::len(graph), -1));\n \n@@ -142,6 +143,101 @@ fn bfs(graph: graph, key: node_id) -> [node_id] {\n     vec::from_mut(marks)\n }\n \n+#[doc=\"Performs at least some of the validation in the Graph500 spec.\"]\n+fn validate(edges: [(node_id, node_id)], \n+            root: node_id, tree: bfs_result) -> bool {\n+    // There are 5 things to test. Below is code for each of them.\n+\n+    // 1. The BFS tree is a tree and does not contain cycles.\n+    //\n+    // We do this by iterating over the tree, and tracing each of the\n+    // parent chains back to the root. While we do this, we also\n+    // compute the levels for each node.\n+\n+    log(info, \"Verifying tree structure...\");\n+\n+    let mut status = true;\n+    let level = tree.map() {|parent| \n+        let mut parent = parent;\n+        let mut path = [];\n+\n+        if parent == -1 {\n+            // This node was not in the tree.\n+            -1\n+        }\n+        else {\n+            while parent != root {\n+                if vec::contains(path, parent) {\n+                    status = false;\n+                }\n+\n+                path += [parent];\n+                parent = tree[parent];\n+            }\n+\n+            // The length of the path back to the root is the current\n+            // level.\n+            path.len() as int\n+        }\n+    };\n+    \n+    if !status { ret status }\n+\n+    // 2. Each tree edge connects vertices whose BFS levels differ by\n+    //    exactly one.\n+\n+    log(info, \"Verifying tree edges...\");\n+\n+    let status = tree.alli() {|k, parent|\n+        if parent != root && parent != -1 {\n+            level[parent] == level[k] - 1\n+        }\n+        else {\n+            true\n+        }\n+    };\n+\n+    if !status { ret status }\n+\n+    // 3. Every edge in the input list has vertices with levels that\n+    //    differ by at most one or that both are not in the BFS tree.\n+\n+    log(info, \"Verifying graph edges...\");\n+\n+    let status = edges.all() {|e| \n+        let (u, v) = e;\n+\n+        abs(level[u] - level[v]) <= 1\n+    };\n+\n+    if !status { ret status }    \n+\n+    // 4. The BFS tree spans an entire connected component's vertices.\n+\n+    // This is harder. We'll skip it for now...\n+\n+    // 5. A node and its parent are joined by an edge of the original\n+    //    graph.\n+\n+    log(info, \"Verifying tree and graph edges...\");\n+\n+    let status = tree.alli() {|u, v|\n+        if v == -1 || u as int == root {\n+            true\n+        }\n+        else {\n+            log(info, #fmt(\"Checking for %? or %?\",\n+                           (u, v), (v, u)));\n+            edges.contains((u as int, v)) || edges.contains((v, u as int))\n+        }\n+    };\n+\n+    if !status { ret status }    \n+\n+    // If we get through here, all the tests passed!\n+    true\n+}\n+\n fn main() {\n     let scale = 14u;\n \n@@ -162,11 +258,20 @@ fn main() {\n     io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n                                  stop - start));\n+\n+    let root = 0;\n     \n     let start = time::precise_time_s();\n-    let bfs_tree = bfs(graph, 0);\n+    let bfs_tree = bfs(graph, root);\n     let stop = time::precise_time_s();\n \n     io::stdout().write_line(#fmt(\"BFS completed in %? seconds.\",\n                                  stop - start));\n-}\n\\ No newline at end of file\n+\n+    let start = time::precise_time_s();\n+    assert(validate(graph, edges, root, bfs_tree));\n+    let stop = time::precise_time_s();\n+\n+    io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n+                                 stop - start));\n+}"}]}