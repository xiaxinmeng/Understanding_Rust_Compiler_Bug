{"sha": "5768385615c61f6c9d63dccfb3548812f1ba1320", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NjgzODU2MTVjNjFmNmM5ZDYzZGNjZmIzNTQ4ODEyZjFiYTEzMjA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-06T22:31:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-06T22:31:36Z"}, "message": "Rollup merge of #70612 - Thomasdezeeuw:issue_70436, r=LukasKalbertodt\n\nAdd io::Write::write_all_vectored\n\nSimilar to io::Write::write_all but uses io::Write::write_vectored\ninstead.\n\nUpdates #70436\n\n/cc @cramertj @sfackler", "tree": {"sha": "6218d64308bc92a633b3be25f033e62167ef1948", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6218d64308bc92a633b3be25f033e62167ef1948"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5768385615c61f6c9d63dccfb3548812f1ba1320", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJei63ICRBK7hj4Ov3rIwAAdHIIAIf4bpp7+vlHjRDz/WTyMy1p\npDfQD5/Tx9FpuQ4XmqdWeJ/SBnEWEuEwzzHdBfw/i10f4Pbjz+MmNpeUqstkLy8c\nDP3VVw+VjOL6oAiICJaGOYX78wKwN49izHbEa/qQAR17AYYP7pB4cHBHDKBs9E7h\nTCCWDoGjm7P/F7BC/IXf2HzHmVF9E47TnH1rC3N6pUGa+jTW0Qdre1xNa7NngNRV\neEWg3fegjB4bsVNId8xjVBFmNNPGawyl//kMo0ChASx3hg+jw7E0Cc/G+3HHLsJo\nlVuAST0LlogvtZJCU4K062el3V/iW67CiVJftkM94O0WJ2IsFKyZz5pE/cO+ktE=\n=p4Yt\n-----END PGP SIGNATURE-----\n", "payload": "tree 6218d64308bc92a633b3be25f033e62167ef1948\nparent 6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257\nparent 5d09f9f0512a6b6c0082314897198a2cae52be70\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586212296 +0200\ncommitter GitHub <noreply@github.com> 1586212296 +0200\n\nRollup merge of #70612 - Thomasdezeeuw:issue_70436, r=LukasKalbertodt\n\nAdd io::Write::write_all_vectored\n\nSimilar to io::Write::write_all but uses io::Write::write_vectored\ninstead.\n\nUpdates #70436\n\n/cc @cramertj @sfackler\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5768385615c61f6c9d63dccfb3548812f1ba1320", "html_url": "https://github.com/rust-lang/rust/commit/5768385615c61f6c9d63dccfb3548812f1ba1320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5768385615c61f6c9d63dccfb3548812f1ba1320/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257", "html_url": "https://github.com/rust-lang/rust/commit/6dee5f1126dfd5c9314ee5ae9d9eb010e35ef257"}, {"sha": "5d09f9f0512a6b6c0082314897198a2cae52be70", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d09f9f0512a6b6c0082314897198a2cae52be70", "html_url": "https://github.com/rust-lang/rust/commit/5d09f9f0512a6b6c0082314897198a2cae52be70"}], "stats": {"total": 170, "additions": 169, "deletions": 1}, "files": [{"sha": "5ab88260d6ac1888fd3d9657da14094d60d2342a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 169, "deletions": 1, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5768385615c61f6c9d63dccfb3548812f1ba1320/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5768385615c61f6c9d63dccfb3548812f1ba1320/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5768385615c61f6c9d63dccfb3548812f1ba1320", "patch": "@@ -261,6 +261,7 @@\n \n use crate::cmp;\n use crate::fmt;\n+use crate::mem;\n use crate::memchr;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n@@ -1376,6 +1377,70 @@ pub trait Write {\n         Ok(())\n     }\n \n+    /// Attempts to write multiple buffers into this writer.\n+    ///\n+    /// This method will continuously call [`write_vectored`] until there is no\n+    /// more data to be written or an error of non-[`ErrorKind::Interrupted`]\n+    /// kind is returned. This method will not return until all buffers have\n+    /// been successfully written or such an error occurs. The first error that\n+    /// is not of [`ErrorKind::Interrupted`] kind generated from this method\n+    /// will be returned.\n+    ///\n+    /// If the buffer contains no data, this will never call [`write_vectored`].\n+    ///\n+    /// [`write_vectored`]: #method.write_vectored\n+    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    ///\n+    /// # Notes\n+    ///\n+    ///\n+    /// Unlike `io::Write::write_vectored`, this takes a *mutable* reference to\n+    /// a slice of `IoSlice`s, not an immutable one. That's because we need to\n+    /// modify the slice to keep track of the bytes already written.\n+    ///\n+    /// Once this function returns, the contents of `bufs` are unspecified, as\n+    /// this depends on how many calls to `write_vectored` were necessary. It is\n+    /// best to understand this function as taking ownership of `bufs` and to\n+    /// not use `bufs` afterwards. The underlying buffers, to which the\n+    /// `IoSlice`s point (but not the `IoSlice`s themselves), are unchanged and\n+    /// can be reused.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(write_all_vectored)]\n+    /// # fn main() -> std::io::Result<()> {\n+    ///\n+    /// use std::io::{Write, IoSlice};\n+    ///\n+    /// let mut writer = Vec::new();\n+    /// let bufs = &mut [\n+    ///     IoSlice::new(&[1]),\n+    ///     IoSlice::new(&[2, 3]),\n+    ///     IoSlice::new(&[4, 5, 6]),\n+    /// ];\n+    ///\n+    /// writer.write_all_vectored(bufs)?;\n+    /// // Note: the contents of `bufs` is now undefined, see the Notes section.\n+    ///\n+    /// assert_eq!(writer, &[1, 2, 3, 4, 5, 6]);\n+    /// # Ok(()) }\n+    /// ```\n+    #[unstable(feature = \"write_all_vectored\", issue = \"70436\")]\n+    fn write_all_vectored(&mut self, mut bufs: &mut [IoSlice<'_>]) -> Result<()> {\n+        while !bufs.is_empty() {\n+            match self.write_vectored(bufs) {\n+                Ok(0) => {\n+                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                }\n+                Ok(n) => bufs = IoSlice::advance(mem::take(&mut bufs), n),\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n@@ -2423,7 +2488,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n #[cfg(test)]\n mod tests {\n     use super::{repeat, Cursor, SeekFrom};\n-    use crate::cmp;\n+    use crate::cmp::{self, min};\n     use crate::io::prelude::*;\n     use crate::io::{self, IoSlice, IoSliceMut};\n     use crate::ops::Deref;\n@@ -2812,4 +2877,107 @@ mod tests {\n         bufs = IoSlice::advance(bufs, 9);\n         assert!(bufs.is_empty());\n     }\n+\n+    /// Create a new writer that reads from at most `n_bufs` and reads\n+    /// `per_call` bytes (in total) per call to write.\n+    fn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n+        TestWriter { n_bufs, per_call, written: Vec::new() }\n+    }\n+\n+    struct TestWriter {\n+        n_bufs: usize,\n+        per_call: usize,\n+        written: Vec<u8>,\n+    }\n+\n+    impl Write for TestWriter {\n+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+            self.write_vectored(&[IoSlice::new(buf)])\n+        }\n+\n+        fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+            let mut left = self.per_call;\n+            let mut written = 0;\n+            for buf in bufs.iter().take(self.n_bufs) {\n+                let n = min(left, buf.len());\n+                self.written.extend_from_slice(&buf[0..n]);\n+                left -= n;\n+                written += n;\n+            }\n+            Ok(written)\n+        }\n+\n+        fn flush(&mut self) -> io::Result<()> {\n+            Ok(())\n+        }\n+    }\n+\n+    #[test]\n+    fn test_writer_read_from_one_buf() {\n+        let mut writer = test_writer(1, 2);\n+\n+        assert_eq!(writer.write(&[]).unwrap(), 0);\n+        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+\n+        // Read at most 2 bytes.\n+        assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n+        let bufs = &[IoSlice::new(&[2, 2, 2])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n+\n+        // Only read from first buf.\n+        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n+\n+        assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_writer_read_from_multiple_bufs() {\n+        let mut writer = test_writer(3, 3);\n+\n+        // Read at most 3 bytes from two buffers.\n+        let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+        // Read at most 3 bytes from three buffers.\n+        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n+        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+        assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n+    }\n+\n+    #[test]\n+    fn test_write_all_vectored() {\n+        #[rustfmt::skip] // Becomes unreadable otherwise.\n+        let tests: Vec<(_, &'static [u8])> = vec![\n+            (vec![], &[]),\n+            (vec![IoSlice::new(&[1])], &[1]),\n+            (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n+            (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n+            (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n+            (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n+            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n+            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n+            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n+        ];\n+\n+        let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n+\n+        for (n_bufs, per_call) in writer_configs.iter().copied() {\n+            for (mut input, wanted) in tests.clone().into_iter() {\n+                let mut writer = test_writer(n_bufs, per_call);\n+                assert!(writer.write_all_vectored(&mut *input).is_ok());\n+                assert_eq!(&*writer.written, &*wanted);\n+            }\n+        }\n+    }\n }"}]}