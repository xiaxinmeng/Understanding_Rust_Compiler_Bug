{"sha": "98fa0f89b1cd406594bedc5803a1b6db53990a15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZmEwZjg5YjFjZDQwNjU5NGJlZGM1ODAzYTFiNmRiNTM5OTBhMTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-14T01:41:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-14T01:41:35Z"}, "message": "auto merge of #12798 : pczarn/rust/inline-asm, r=alexcrichton\n\n## read+write modifier '+'\r\nThis small sugar was left out in the original implementation (#5359).\r\n \r\nWhen an output operand with the '+' modifier is encountered, we store the index of that operand alongside the expression to create and append an input operand later. The following lines are equivalent:\r\n```\r\nasm!(\"\" : \"+m\"(expr));\r\nasm!(\"\" : \"=m\"(expr) : \"0\"(expr));\r\n```\r\n## misplaced options and clobbers give a warning\r\nIt's really annoying when a small typo might change behavior without any warning.\r\n```\r\nasm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(8u) : \"cc\" , \"volatile\");\r\n//~^ WARNING expected a clobber, but found an option\r\n```\r\n## liveness\r\nFixed incorrect order of propagation.\r\nSometimes it caused spurious warnings in code: `warning: value assigned to `i` is never read, #[warn(dead_assignment)] on by default`\r\n\r\n~~Note: Rebased on top of another PR. (uses other changes)~~\r\n\r\n* [x] Implement read+write\r\n* [x] Warn about misplaced options\r\n* [x] Fix liveness (`dead_assignment` lint)\r\n* [x] Add all tests", "tree": {"sha": "b36eb4e868e24d2b8880e88870cef74df9d2f3a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b36eb4e868e24d2b8880e88870cef74df9d2f3a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98fa0f89b1cd406594bedc5803a1b6db53990a15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98fa0f89b1cd406594bedc5803a1b6db53990a15", "html_url": "https://github.com/rust-lang/rust/commit/98fa0f89b1cd406594bedc5803a1b6db53990a15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98fa0f89b1cd406594bedc5803a1b6db53990a15/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d324334cb48198c27d782002d75eba14a6abde", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d324334cb48198c27d782002d75eba14a6abde", "html_url": "https://github.com/rust-lang/rust/commit/b4d324334cb48198c27d782002d75eba14a6abde"}, {"sha": "2a1bd2ff9f9039df4b3c0158eac3589a222a2833", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1bd2ff9f9039df4b3c0158eac3589a222a2833", "html_url": "https://github.com/rust-lang/rust/commit/2a1bd2ff9f9039df4b3c0158eac3589a222a2833"}], "stats": {"total": 236, "additions": 182, "deletions": 54}, "files": [{"sha": "fa435378ab7df555c2bedd19dc1993e89b0fc2fe", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=98fa0f89b1cd406594bedc5803a1b6db53990a15", "patch": "@@ -1259,14 +1259,15 @@ impl Liveness {\n           }\n \n           ExprInlineAsm(ref ia) => {\n-            let succ = ia.inputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n-                self.propagate_through_expr(expr, succ)\n-            });\n-            ia.outputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n+            let succ = ia.outputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n                 // see comment on lvalues in\n                 // propagate_through_lvalue_components()\n                 let succ = self.write_lvalue(expr, succ, ACC_WRITE);\n                 self.propagate_through_lvalue_components(expr, succ)\n+            });\n+            // Inputs are executed first. Propagate last because of rev order\n+            ia.inputs.rev_iter().fold(succ, |succ, &(_, expr)| {\n+                self.propagate_through_expr(expr, succ)\n             })\n           }\n "}, {"sha": "8c1e27d8b019a6218dc2da05b00fb7c499034ee1", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 69, "deletions": 50, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=98fa0f89b1cd406594bedc5803a1b6db53990a15", "patch": "@@ -27,19 +27,25 @@ enum State {\n     Outputs,\n     Inputs,\n     Clobbers,\n-    Options\n+    Options,\n+    StateNone\n }\n \n-fn next_state(s: State) -> Option<State> {\n-    match s {\n-        Asm      => Some(Outputs),\n-        Outputs  => Some(Inputs),\n-        Inputs   => Some(Clobbers),\n-        Clobbers => Some(Options),\n-        Options  => None\n+impl State {\n+    fn next(&self) -> State {\n+        match *self {\n+            Asm       => Outputs,\n+            Outputs   => Inputs,\n+            Inputs    => Clobbers,\n+            Clobbers  => Options,\n+            Options   => StateNone,\n+            StateNone => StateNone\n+        }\n     }\n }\n \n+static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n+\n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n@@ -59,9 +65,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let mut state = Asm;\n \n-    // Not using labeled break to get us through one round of bootstrapping.\n-    let mut continue_ = true;\n-    while continue_ {\n+    let mut read_write_operands = Vec::new();\n+\n+    'statement: loop {\n         match state {\n             Asm => {\n                 let (s, style) = match expr_to_str(cx, p.parse_expr(),\n@@ -84,18 +90,33 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (constraint, _str_style) = p.parse_str();\n \n-                    if constraint.get().starts_with(\"+\") {\n-                        cx.span_unimpl(p.last_span,\n-                                       \"'+' (read+write) output operand constraint modifier\");\n-                    } else if !constraint.get().starts_with(\"=\") {\n-                        cx.span_err(p.last_span, \"output operand constraint lacks '='\");\n-                    }\n+                    let span = p.last_span;\n \n                     p.expect(&token::LPAREN);\n                     let out = p.parse_expr();\n                     p.expect(&token::RPAREN);\n \n-                    outputs.push((constraint, out));\n+                    // Expands a read+write operand into two operands.\n+                    //\n+                    // Use '+' modifier when you want the same expression\n+                    // to be both an input and an output at the same time.\n+                    // It's the opposite of '=&' which means that the memory\n+                    // cannot be shared with any other operand (usually when\n+                    // a register is clobbered early.)\n+                    let output = match constraint.get().slice_shift_char() {\n+                        (Some('='), _) => None,\n+                        (Some('+'), operand) => {\n+                            // Save a reference to the output\n+                            read_write_operands.push((outputs.len(), out));\n+                            Some(token::intern_and_get_ident(\"=\" + operand))\n+                        }\n+                        _ => {\n+                            cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n+                            None\n+                        }\n+                    };\n+\n+                    outputs.push((output.unwrap_or(constraint), out));\n                 }\n             }\n             Inputs => {\n@@ -135,6 +156,10 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                     let (s, _str_style) = p.parse_str();\n                     let clob = format!(\"~\\\\{{}\\\\}\", s);\n                     clobs.push(clob);\n+\n+                    if OPTIONS.iter().any(|opt| s.equiv(opt)) {\n+                        cx.span_warn(p.last_span, \"expected a clobber, but found an option\");\n+                    }\n                 }\n \n                 cons = clobs.connect(\",\");\n@@ -143,56 +168,50 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 let (option, _str_style) = p.parse_str();\n \n                 if option.equiv(&(\"volatile\")) {\n+                    // Indicates that the inline assembly has side effects\n+                    // and must not be optimized out along with its outputs.\n                     volatile = true;\n                 } else if option.equiv(&(\"alignstack\")) {\n                     alignstack = true;\n                 } else if option.equiv(&(\"intel\")) {\n                     dialect = ast::AsmIntel;\n+                } else {\n+                    cx.span_warn(p.last_span, \"unrecognized option\");\n                 }\n \n                 if p.token == token::COMMA {\n                     p.eat(&token::COMMA);\n                 }\n             }\n+            StateNone => ()\n         }\n \n-        while p.token == token::COLON   ||\n-              p.token == token::MOD_SEP ||\n-              p.token == token::EOF {\n-            state = if p.token == token::COLON {\n-                p.bump();\n-                match next_state(state) {\n-                    Some(x) => x,\n-                    None    => {\n-                        continue_ = false;\n-                        break\n-                    }\n+        loop {\n+            // MOD_SEP is a double colon '::' without space in between.\n+            // When encountered, the state must be advanced twice.\n+            match (&p.token, state.next(), state.next().next()) {\n+                (&token::COLON, StateNone, _)   |\n+                (&token::MOD_SEP, _, StateNone) => {\n+                    p.bump();\n+                    break 'statement;\n                 }\n-            } else if p.token == token::MOD_SEP {\n-                p.bump();\n-                let s = match next_state(state) {\n-                    Some(x) => x,\n-                    None    => {\n-                        continue_ = false;\n-                        break\n-                    }\n-                };\n-                match next_state(s) {\n-                    Some(x) => x,\n-                    None    => {\n-                        continue_ = false;\n-                        break\n-                    }\n+                (&token::COLON, st, _)   |\n+                (&token::MOD_SEP, _, st) => {\n+                    p.bump();\n+                    state = st;\n                 }\n-            } else if p.token == token::EOF {\n-                continue_ = false;\n-                break;\n-            } else {\n-               state\n-            };\n+                (&token::EOF, _, _) => break 'statement,\n+                _ => break\n+            }\n         }\n     }\n \n+    // Append an input operand, with the form of (\"0\", expr)\n+    // that links to an output operand.\n+    for &(i, out) in read_write_operands.iter() {\n+        inputs.push((token::intern_and_get_ident(i.to_str()), out));\n+    }\n+\n     MRExpr(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {"}, {"sha": "595247143edca2e0e31db08299c259827e256804", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=98fa0f89b1cd406594bedc5803a1b6db53990a15", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast #[feature] doesn't work with check-fast\n+#[feature(asm)];\n+\n+#[allow(dead_code)];\n+\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+pub fn main() {\n+    // assignment not dead\n+    let mut x: int = 0;\n+    unsafe {\n+        // extra colon\n+        asm!(\"mov $1, $0\" : \"=r\"(x) : \"r\"(5u), \"0\"(x) : : \"cc\");\n+        //~^ WARNING unrecognized option\n+    }\n+    assert_eq!(x, 5);\n+\n+    unsafe {\n+        // comma in place of a colon\n+        asm!(\"add $2, $1; mov $1, $0\" : \"=r\"(x) : \"r\"(x), \"r\"(8u) : \"cc\", \"volatile\");\n+        //~^ WARNING expected a clobber, but found an option\n+    }\n+    assert_eq!(x, 13);\n+}\n+\n+// #[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n+// pub fn main() {}\n+\n+// At least one error is needed so that compilation fails\n+#[static_assert]\n+static b: bool = false; //~ ERROR static assertion failed"}, {"sha": "11d4321b3e9ec4b2fb1d68df33d5be1052f1c6c4", "filename": "src/test/run-pass/asm-in-out-operand.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98fa0f89b1cd406594bedc5803a1b6db53990a15/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasm-in-out-operand.rs?ref=98fa0f89b1cd406594bedc5803a1b6db53990a15", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-fast #[feature] doesn't work with check-fast\n+#[feature(asm)];\n+\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+unsafe fn next_power_of_2(n: u32) -> u32 {\n+    let mut tmp = n;\n+    asm!(\"dec $0\" : \"+rm\"(tmp) :: \"cc\");\n+    let mut shift = 1u;\n+    while shift <= 16 {\n+        asm!(\n+            \"shr %cl, $2\n+            or $2, $0\n+            shl $$1, $1\"\n+            : \"+&rm\"(tmp), \"+{ecx}\"(shift) : \"r\"(tmp) : \"cc\"\n+        );\n+    }\n+    asm!(\"inc $0\" : \"+rm\"(tmp) :: \"cc\");\n+    return tmp;\n+}\n+\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+pub fn main() {\n+    unsafe {\n+        assert_eq!(64, next_power_of_2(37));\n+        assert_eq!(2147483648, next_power_of_2(2147483647));\n+    }\n+\n+    let mut y: int = 5;\n+    let x: int;\n+    unsafe {\n+        // Treat the output as initialization.\n+        asm!(\n+            \"shl $2, $1\n+            add $3, $1\n+            mov $1, $0\"\n+            : \"=r\"(x), \"+r\"(y) : \"i\"(3u), \"ir\"(7u) : \"cc\"\n+        );\n+    }\n+    assert_eq!(x, 47);\n+    assert_eq!(y, 47);\n+\n+    let mut x = x + 1;\n+    assert_eq!(x, 48);\n+\n+    unsafe {\n+        // Assignment to mutable.\n+        // Early clobber \"&\":\n+        // Forbids the use of a single register by both operands.\n+        asm!(\"shr $$2, $1; add $1, $0\" : \"+&r\"(x) : \"r\"(x) : \"cc\");\n+    }\n+    assert_eq!(x, 60);\n+}\n+\n+#[cfg(not(target_arch = \"x86\"), not(target_arch = \"x86_64\"))]\n+pub fn main() {}"}]}