{"sha": "c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYjk4Y2FiZTFkN2JlZTQ4NzhhOTY3NTA3YWU3NDVlOWJmZTEzYWM=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-27T22:21:50Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-27T22:22:06Z"}, "message": "Removed pretty much all the vector+ from core (issue #2719)", "tree": {"sha": "720ff03680709fdb72283e1835d0e9912fc15a6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/720ff03680709fdb72283e1835d0e9912fc15a6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "html_url": "https://github.com/rust-lang/rust/commit/c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2205659e323b510686f594818e2f206e88e98f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2205659e323b510686f594818e2f206e88e98f3", "html_url": "https://github.com/rust-lang/rust/commit/e2205659e323b510686f594818e2f206e88e98f3"}], "stats": {"total": 138, "additions": 84, "deletions": 54}, "files": [{"sha": "85bde3b7c5908360cef6204643dd7b49dcdeaaa2", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -150,7 +150,8 @@ impl extensions<A> for dvec<A> {\n             let data_ptr: *() = unsafe::reinterpret_cast(data);\n             if data_ptr.is_null() { fail \"Recursive use of dvec\"; }\n             log(error, \"a\");\n-            self.data <- [mut t]/~ + data;\n+            self.data <- [mut t]/~;\n+            vec::push_all_move(self.data, data);\n             log(error, \"b\");\n         }\n     }"}, {"sha": "0a1c9ce9e6bae87e26f289f39a2399b6507bd6a5", "filename": "src/libcore/either.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -26,7 +26,7 @@ fn lefts<T: copy, U>(eithers: [either<T, U>]/~) -> [T]/~ {\n \n     let mut result: [T]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { left(l) { result += [l]/~; } _ {/* fallthrough */ } }\n+        alt elt { left(l) { vec::push(result, l); } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n@@ -36,7 +36,7 @@ fn rights<T, U: copy>(eithers: [either<T, U>]/~) -> [U]/~ {\n \n     let mut result: [U]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { right(r) { result += [r]/~; } _ {/* fallthrough */ } }\n+        alt elt { right(r) { vec::push(result, r); } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n@@ -53,7 +53,10 @@ fn partition<T: copy, U: copy>(eithers: [either<T, U>]/~)\n     let mut lefts: [T]/~ = []/~;\n     let mut rights: [U]/~ = []/~;\n     for vec::each(eithers) {|elt|\n-        alt elt { left(l) { lefts += [l]/~; } right(r) { rights += [r]/~; } }\n+        alt elt {\n+          left(l) { vec::push(lefts, l); }\n+          right(r) { vec::push(rights, r); }\n+        }\n     }\n     ret {lefts: lefts, rights: rights};\n }"}, {"sha": "d738b4f6615105790a5d536cd6c8cce591716b12", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -88,7 +88,7 @@ mod ct {\n         fn flush_buf(buf: str, &pieces: [piece]/~) -> str {\n             if str::len(buf) > 0u {\n                 let piece = piece_string(buf);\n-                pieces += [piece]/~;\n+                vec::push(pieces, piece);\n             }\n             ret \"\";\n         }\n@@ -108,7 +108,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece]/~;\n+                    vec::push(pieces, rs.piece);\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += size; }\n@@ -172,7 +172,7 @@ mod ct {\n             let rest = next.flags;\n             let j = next.next;\n             let curr: [flag]/~ = [f]/~;\n-            ret {flags: curr + rest, next: j};\n+            ret {flags: vec::append(curr, rest), next: j};\n         }\n         let more = {|x|more_(x, s, i, lim)};\n         let f = s[i];"}, {"sha": "8fdc1a28df5ca49ab133f4c425e16f7c02d5f28c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -65,7 +65,7 @@ fn foldl<A,B,IA:base_iter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n }\n \n fn to_vec<A:copy,IA:base_iter<A>>(self: IA) -> [A]/~ {\n-    foldl::<A,[A]/~,IA>(self, []/~, {|r, a| r + [a]/~})\n+    foldl::<A,[A]/~,IA>(self, []/~, {|r, a| vec::append(r, [a]/~) })\n }\n \n fn contains<A,IA:base_iter<A>>(self: IA, x: A) -> bool {"}, {"sha": "059529a79f76701c4332c819814fdce0b905d8e3", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -204,7 +204,7 @@ impl extensions for rng {\n         let mut r = []/~;\n         for v.each {|item|\n             for uint::range(0u, item.weight) {|_i|\n-                r += [item.item]/~;\n+                vec::push(r, item.item);\n             }\n         }\n         r"}, {"sha": "e9d3847ab934075d04c5508dd3fee704b47930d2", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -256,7 +256,7 @@ fn map_vec<T,U:copy,V:copy>(\n     vec::reserve(vs, vec::len(ts));\n     for vec::each(ts) {|t|\n         alt op(t) {\n-          ok(v) { vs += [v]/~; }\n+          ok(v) { vec::push(vs, v); }\n           err(u) { ret err(u); }\n         }\n     }\n@@ -294,7 +294,7 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: [S]/~, ts: [T]/~,\n     let mut i = 0u;\n     while i < n {\n         alt op(ss[i],ts[i]) {\n-          ok(v) { vs += [v]/~; }\n+          ok(v) { vec::push(vs, v); }\n           err(u) { ret err(u); }\n         }\n         i += 1u;"}, {"sha": "f51e5993bbc0eee7820189955564ca5b14e62f45", "filename": "src/libcore/run.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -83,10 +83,10 @@ fn with_argv<T>(prog: str, args: [str]/~,\n     let mut tmps = []/~;\n     for vec::each(args) {|arg|\n         let t = @arg;\n-        tmps += [t]/~;\n-        argptrs += str::as_c_str(*t) {|b| [b]/~ };\n+        vec::push(tmps, t);\n+        vec::push_all(argptrs, str::as_c_str(*t) {|b| [b]/~ });\n     }\n-    argptrs += [ptr::null()]/~;\n+    vec::push(argptrs, ptr::null());\n     vec::as_buf(argptrs, cb)\n }\n \n@@ -104,9 +104,9 @@ fn with_envp<T>(env: option<[(str,str)]/~>,\n             let (k,v) = e;\n             let t = @(#fmt(\"%s=%s\", k, v));\n             vec::push(tmps, t);\n-            ptrs += str::as_c_str(*t) {|b| [b]/~};\n+            vec::push_all(ptrs, str::as_c_str(*t) {|b| [b]/~});\n         }\n-        ptrs += [ptr::null()]/~;\n+        vec::push(ptrs, ptr::null());\n         vec::as_buf(ptrs) { |p|\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n         }"}, {"sha": "35d2edd608ae55597fa1b3dba61b0730169884d9", "filename": "src/libcore/str.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -347,7 +347,7 @@ pure fn chars(s: str/&) -> [char]/~ {\n     let len = len(s);\n     while i < len {\n         let {ch, next} = char_range_at(s, i);\n-        buf += [ch]/~;\n+        unchecked { vec::push(buf, ch); }\n         i = next;\n     }\n     ret buf;\n@@ -407,16 +407,17 @@ pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n         let mut i = 0u, start = 0u;\n         while i < l && done < count {\n             if s[i] == b {\n-                if allow_empty || start < i {\n-                    result += [unsafe { unsafe::slice_bytes(s, start, i) }]/~;\n+                if allow_empty || start < i unchecked {\n+                    vec::push(result,\n+                              unsafe { unsafe::slice_bytes(s, start, i) });\n                 }\n                 start = i + 1u;\n                 done += 1u;\n             }\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            result += [unsafe { unsafe::slice_bytes(s, start, l) }]/~;\n+            unsafe { vec::push(result, unsafe::slice_bytes(s, start, l) ) };\n         }\n         result\n     } else {\n@@ -450,16 +451,16 @@ pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n     while i < l && done < count {\n         let {ch, next} = char_range_at(s, i);\n         if sepfn(ch) {\n-            if allow_empty || start < i {\n-                result += [unsafe { unsafe::slice_bytes(s, start, i) }]/~;\n+            if allow_empty || start < i unchecked {\n+                vec::push(result, unsafe { unsafe::slice_bytes(s, start, i)});\n             }\n             start = next;\n             done += 1u;\n         }\n         i = next;\n     }\n-    if allow_empty || start < l {\n-        result += [unsafe { unsafe::slice_bytes(s, start, l) }]/~;\n+    if allow_empty || start < l unchecked {\n+        vec::push(result, unsafe { unsafe::slice_bytes(s, start, l) });\n     }\n     result\n }\n@@ -513,7 +514,7 @@ assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n pure fn split_str(s: str/&a, sep: str/&b) -> [str]/~ {\n     let mut result = []/~;\n     iter_between_matches(s, sep) {|from, to|\n-        unsafe { result += [unsafe::slice_bytes(s, from, to)]/~; }\n+        unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n     }\n     result\n }\n@@ -522,7 +523,7 @@ pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str]/~ {\n     let mut result = []/~;\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n-            unsafe { result += [unsafe::slice_bytes(s, from, to)]/~; }\n+            unsafe { vec::push(result, unsafe::slice_bytes(s, from, to)); }\n         }\n     }\n     result\n@@ -1270,17 +1271,17 @@ pure fn to_utf16(s: str/&) -> [u16]/~ {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = cch as u32;\n \n-        if (ch & 0xFFFF_u32) == ch {\n+        if (ch & 0xFFFF_u32) == ch unchecked {\n             // The BMP falls through (assuming non-surrogate, as it should)\n             assert ch <= 0xD7FF_u32 || ch >= 0xE000_u32;\n-            u += [ch as u16]/~\n-        } else {\n+            vec::push(u, ch as u16)\n+        } else unchecked {\n             // Supplementary planes break into surrogates.\n             assert ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32;\n             ch -= 0x1_0000_u32;\n             let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n             let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u += [w1, w2]/~\n+            vec::push_all(u, [w1, w2]/~)\n         }\n     }\n     ret u;\n@@ -1788,7 +1789,7 @@ mod unsafe {\n                    ptr::memcpy(vbuf, src, end - begin);\n                }\n                vec::unsafe::set_len(v, end - begin);\n-               v += [0u8]/~;\n+               vec::push(v, 0u8);\n                ::unsafe::transmute(v)\n            }\n        }"}, {"sha": "97a1bca4ddaaf389110c51ebfe40dd7147999e53", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b98cabe1d7bee4878a967507ae745e9bfe13ac/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c3b98cabe1d7bee4878a967507ae745e9bfe13ac", "patch": "@@ -31,7 +31,7 @@ export rsplit;\n export rsplitn;\n export shift;\n export pop;\n-export push, push_all;\n+export push, push_all, push_all_move;\n export grow;\n export grow_fn;\n export grow_set;\n@@ -468,6 +468,20 @@ fn push_all<T: copy>(&v: [const T]/~, rhs: [const T]/&) {\n     }\n }\n \n+#[inline(always)]\n+fn push_all_move<T>(&v: [const T]/~, -rhs: [const T]/~) {\n+    reserve(v, v.len() + rhs.len());\n+    unsafe {\n+        unpack_slice(rhs) {|p, len|\n+            for uint::range(0, len) {|i|\n+                let x <- *ptr::offset(p, i);\n+                push(v, x);\n+            }\n+        }\n+        unsafe::set_len(rhs, 0);\n+    }\n+}\n+\n // Appending\n #[inline(always)]\n pure fn append<T: copy>(lhs: [T]/&, rhs: [const T]/&) -> [T]/~ {\n@@ -577,7 +591,7 @@ of each result vector\n \"]\n pure fn flat_map<T, U>(v: [T]/&, f: fn(T) -> [U]/~) -> [U]/~ {\n     let mut result = []/~;\n-    for each(v) {|elem| result += f(elem); }\n+    for each(v) {|elem| unchecked{ push_all_move(result, f(elem)); } }\n     ret result;\n }\n \n@@ -649,7 +663,7 @@ pure fn connect<T: copy>(v: [[T]/~]/&, sep: T) -> [T]/~ {\n     let mut first = true;\n     for each(v) {|inner|\n         if first { first = false; } else { unsafe { push(r, sep); } }\n-        r += inner;\n+        unchecked { push_all(r, inner) };\n     }\n     ret r;\n }\n@@ -873,7 +887,13 @@ of the i-th tuple of the input vector.\n \"]\n pure fn unzip<T: copy, U: copy>(v: [(T, U)]/&) -> ([T]/~, [U]/~) {\n     let mut as = []/~, bs = []/~;\n-    for each(v) {|p| let (a, b) = p; as += [a]/~; bs += [b]/~; }\n+    for each(v) {|p|\n+        let (a, b) = p;\n+        unchecked {\n+            vec::push(as, a);\n+            vec::push(bs, b);\n+        }\n+    }\n     ret (as, bs);\n }\n \n@@ -888,7 +908,7 @@ pure fn zip<T: copy, U: copy>(v: [const T]/&, u: [const U]/&) -> [(T, U)]/~ {\n     let sz = len(v);\n     let mut i = 0u;\n     assert sz == len(u);\n-    while i < sz { zipped += [(v[i], u[i])]/~; i += 1u; }\n+    while i < sz unchecked { vec::push(zipped, (v[i], u[i])); i += 1u; }\n     ret zipped;\n }\n \n@@ -914,12 +934,14 @@ fn reverse<T>(v: [mut T]/~) {\n \n \n #[doc = \"Returns a vector with the order of elements reversed\"]\n-fn reversed<T: copy>(v: [const T]/&) -> [T]/~ {\n+pure fn reversed<T: copy>(v: [const T]/&) -> [T]/~ {\n     let mut rs: [T]/~ = []/~;\n     let mut i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n-    while i != 0u { rs += [v[i]]/~; i -= 1u; }\n-    rs += [v[0]]/~;\n+    unchecked {\n+        while i != 0u { vec::push(rs, v[i]); i -= 1u; }\n+        vec::push(rs, v[0]);\n+    }\n     ret rs;\n }\n \n@@ -1063,27 +1085,30 @@ The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n \"]\n pure fn permute<T: copy>(v: [T]/&, put: fn([T]/~)) {\n-  let ln = len(v);\n-  if ln == 0u {\n-    put([]/~);\n-  } else {\n-    let mut i = 0u;\n-    while i < ln {\n-      let elt = v[i];\n-      let rest = slice(v, 0u, i) + slice(v, i+1u, ln);\n-      permute(rest) {|permutation| put([elt]/~ + permutation)}\n-      i += 1u;\n+    let ln = len(v);\n+    if ln == 0u {\n+        put([]/~);\n+    } else {\n+        let mut i = 0u;\n+        while i < ln {\n+            let elt = v[i];\n+            let mut rest = slice(v, 0u, i);\n+            unchecked {\n+                push_all(rest, view(v, i+1u, ln));\n+            }\n+            permute(rest) {|permutation| put([elt]/~ + permutation)}\n+            i += 1u;\n+        }\n     }\n-  }\n }\n \n pure fn windowed<TT: copy>(nn: uint, xx: [TT]/&) -> [[TT]/~]/~ {\n     let mut ww = []/~;\n     assert 1u <= nn;\n     vec::iteri (xx, {|ii, _x|\n         let len = vec::len(xx);\n-        if ii+nn <= len {\n-            ww += [vec::slice(xx, ii, ii+nn)]/~;\n+        if ii+nn <= len unchecked {\n+            vec::push(ww, vec::slice(xx, ii, ii+nn));\n         }\n     });\n     ret ww;\n@@ -2195,10 +2220,10 @@ mod tests {\n     #[test]\n     fn test_windowed () {\n         assert [[1u,2u,3u]/~,[2u,3u,4u]/~,[3u,4u,5u]/~,[4u,5u,6u]/~]/~\n-              == windowed (3u, [1u,2u,3u,4u,5u,6u]/~);\n+            == windowed (3u, [1u,2u,3u,4u,5u,6u]/~);\n \n         assert [[1u,2u,3u,4u]/~,[2u,3u,4u,5u]/~,[3u,4u,5u,6u]/~]/~\n-              == windowed (4u, [1u,2u,3u,4u,5u,6u]/~);\n+            == windowed (4u, [1u,2u,3u,4u,5u,6u]/~);\n \n         assert []/~ == windowed (7u, [1u,2u,3u,4u,5u,6u]/~);\n     }"}]}