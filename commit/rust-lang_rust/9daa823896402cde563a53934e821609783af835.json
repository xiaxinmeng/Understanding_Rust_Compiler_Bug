{"sha": "9daa823896402cde563a53934e821609783af835", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYWE4MjM4OTY0MDJjZGU1NjNhNTM5MzRlODIxNjA5NzgzYWY4MzU=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2018-12-13T13:35:54Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2018-12-14T23:39:40Z"}, "message": "Improve `match` MIR generation for ranges\n\nMakes testing a range rule out ranges/constant\ncovered by the range that is being tested", "tree": {"sha": "48573abdf64e6cf534487290405cb2e771a7e3c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48573abdf64e6cf534487290405cb2e771a7e3c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9daa823896402cde563a53934e821609783af835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9daa823896402cde563a53934e821609783af835", "html_url": "https://github.com/rust-lang/rust/commit/9daa823896402cde563a53934e821609783af835", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9daa823896402cde563a53934e821609783af835/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2ac11ce5f4da057f3075ceb1c081668e5a883bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ac11ce5f4da057f3075ceb1c081668e5a883bc", "html_url": "https://github.com/rust-lang/rust/commit/d2ac11ce5f4da057f3075ceb1c081668e5a883bc"}], "stats": {"total": 212, "additions": 207, "deletions": 5}, "files": [{"sha": "77db74685cd2f8424219b8d2b88ee59488074e2c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 118, "deletions": 2, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9daa823896402cde563a53934e821609783af835/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9daa823896402cde563a53934e821609783af835/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9daa823896402cde563a53934e821609783af835", "patch": "@@ -18,6 +18,7 @@\n use build::Builder;\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n+use hair::pattern::compare_const_vals;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::{self, Ty};\n@@ -136,7 +137,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Variant { .. } => {\n                 panic!(\"you should have called add_variants_to_switch instead!\");\n             }\n-            PatternKind::Range { .. } |\n+            PatternKind::Range { ty, lo, hi, end } => {\n+                indices\n+                    .keys()\n+                    .all(|value| {\n+                        !self\n+                            .const_range_contains(ty, lo, hi, end, value)\n+                            .unwrap_or(true)\n+                    })\n+            }\n             PatternKind::Slice { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n@@ -529,6 +538,28 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 resulting_candidates[index].push(new_candidate);\n                 true\n             }\n+\n+            (&TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n+             &PatternKind::Range { ty, lo, hi, end }) => {\n+                let not_contained = indices\n+                    .keys()\n+                    .all(|value| {\n+                        !self\n+                            .const_range_contains(ty, lo, hi, end, value)\n+                            .unwrap_or(true)\n+                    });\n+\n+                if not_contained {\n+                    // No values are contained in the pattern range,\n+                    // so the pattern can be matched only if this test fails.\n+                    let otherwise = options.len();\n+                    resulting_candidates[otherwise].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n             (&TestKind::SwitchInt { .. }, _) => false,\n \n \n@@ -607,8 +638,70 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            (&TestKind::Range {\n+                lo: test_lo, hi: test_hi, ty: test_ty, end: test_end,\n+            }, &PatternKind::Range {\n+                lo: pat_lo, hi: pat_hi, ty: _, end: pat_end,\n+            }) => {\n+                if (test_lo, test_hi, test_end) == (pat_lo, pat_hi, pat_end) {\n+                    resulting_candidates[0]\n+                        .push(self.candidate_without_match_pair(\n+                            match_pair_index,\n+                            candidate,\n+                        ));\n+                    return true;\n+                }\n+\n+                let no_overlap = (|| {\n+                    use std::cmp::Ordering::*;\n+                    use rustc::hir::RangeEnd::*;\n+\n+                    let param_env = ty::ParamEnv::empty().and(test_ty);\n+                    let tcx = self.hir.tcx();\n+\n+                    let lo = compare_const_vals(tcx, test_lo, pat_hi, param_env)?;\n+                    let hi = compare_const_vals(tcx, test_hi, pat_lo, param_env)?;\n+\n+                    match (test_end, pat_end, lo, hi) {\n+                        // pat < test\n+                        (_, _, Greater, _) |\n+                        (_, Excluded, Equal, _) |\n+                        // pat > test\n+                        (_, _, _, Less) |\n+                        (Excluded, _, _, Equal) => Some(true),\n+                        _ => Some(false),\n+                    }\n+                })();\n+\n+                if no_overlap == Some(true) {\n+                    // Testing range does not overlap with pattern range,\n+                    // so the pattern can be matched only if this test fails.\n+                    resulting_candidates[1].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n+            (&TestKind::Range {\n+                lo, hi, ty, end\n+            }, &PatternKind::Constant {\n+                ref value\n+            }) => {\n+                if self.const_range_contains(ty, lo, hi, end, value) == Some(false) {\n+                    // `value` is not contained in the testing range,\n+                    // so `value` can be matched only if this test fails.\n+                    resulting_candidates[1].push(candidate.clone());\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+\n+            (&TestKind::Range { .. }, _) => false,\n+\n+\n             (&TestKind::Eq { .. }, _) |\n-            (&TestKind::Range { .. }, _) |\n             (&TestKind::Len { .. }, _) => {\n                 // These are all binary tests.\n                 //\n@@ -719,6 +812,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                   \"simplifyable pattern found: {:?}\",\n                   match_pair.pattern)\n     }\n+\n+    fn const_range_contains(\n+        &self,\n+        ty: Ty<'tcx>,\n+        lo: &'tcx ty::Const<'tcx>,\n+        hi: &'tcx ty::Const<'tcx>,\n+        end: RangeEnd,\n+        value: &'tcx ty::Const<'tcx>,\n+    ) -> Option<bool> {\n+        use std::cmp::Ordering::*;\n+\n+        let param_env = ty::ParamEnv::empty().and(ty);\n+        let tcx = self.hir.tcx();\n+\n+        let a = compare_const_vals(tcx, lo, value, param_env)?;\n+        let b = compare_const_vals(tcx, value, hi, param_env)?;\n+\n+        match (b, end) {\n+            (Less, _) |\n+            (Equal, RangeEnd::Included) if a != Greater => Some(true),\n+            _ => Some(false),\n+        }\n+    }\n }\n \n fn is_switch_ty<'tcx>(ty: Ty<'tcx>) -> bool {"}, {"sha": "864f242a304e01b5455c968ce1db9abeca801f5f", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9daa823896402cde563a53934e821609783af835/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9daa823896402cde563a53934e821609783af835/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=9daa823896402cde563a53934e821609783af835", "patch": "@@ -24,7 +24,7 @@ use hair::constant::*;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -1210,8 +1210,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n     }\n }\n \n-pub fn compare_const_vals<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n@@ -1233,6 +1233,9 @@ pub fn compare_const_vals<'a, 'tcx>(\n         return fallback();\n     }\n \n+    let tcx = tcx.global_tcx();\n+    let (a, b, ty) = (a, b, ty).lift_to_tcx(tcx).unwrap();\n+\n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {"}, {"sha": "1f96d6737e0afaae370a342638f7190c7b4df20b", "filename": "src/test/run-pass/mir/mir_match_test.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9daa823896402cde563a53934e821609783af835/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9daa823896402cde563a53934e821609783af835/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir%2Fmir_match_test.rs?ref=9daa823896402cde563a53934e821609783af835", "patch": "@@ -0,0 +1,83 @@\n+#![feature(exclusive_range_pattern)]\n+\n+// run-pass\n+\n+fn main() {\n+    let incl_range = |x, b| {\n+        match x {\n+            0..=5 if b => 0,\n+            5..=10 if b => 1,\n+            1..=4 if !b => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(incl_range(3, false), 2);\n+    assert_eq!(incl_range(3, true), 0);\n+    assert_eq!(incl_range(5, false), 3);\n+    assert_eq!(incl_range(5, true), 0);\n+\n+    let excl_range = |x, b| {\n+        match x {\n+            0..5 if b => 0,\n+            5..10 if b => 1,\n+            1..4 if !b => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(excl_range(3, false), 2);\n+    assert_eq!(excl_range(3, true), 0);\n+    assert_eq!(excl_range(5, false), 3);\n+    assert_eq!(excl_range(5, true), 1);\n+\n+    let incl_range_vs_const = |x, b| {\n+        match x {\n+            0..=5 if b => 0,\n+            7 => 1,\n+            3 => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(incl_range_vs_const(5, false), 3);\n+    assert_eq!(incl_range_vs_const(5, true), 0);\n+    assert_eq!(incl_range_vs_const(3, false), 2);\n+    assert_eq!(incl_range_vs_const(3, true), 0);\n+    assert_eq!(incl_range_vs_const(7, false), 1);\n+    assert_eq!(incl_range_vs_const(7, true), 1);\n+\n+    let excl_range_vs_const = |x, b| {\n+        match x {\n+            0..5 if b => 0,\n+            7 => 1,\n+            3 => 2,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(excl_range_vs_const(5, false), 3);\n+    assert_eq!(excl_range_vs_const(5, true), 3);\n+    assert_eq!(excl_range_vs_const(3, false), 2);\n+    assert_eq!(excl_range_vs_const(3, true), 0);\n+    assert_eq!(excl_range_vs_const(7, false), 1);\n+    assert_eq!(excl_range_vs_const(7, true), 1);\n+\n+    let const_vs_incl_range = |x, b| {\n+        match x {\n+            3 if b => 0,\n+            5..=7 => 2,\n+            1..=4 => 1,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(const_vs_incl_range(3, false), 1);\n+    assert_eq!(const_vs_incl_range(3, true), 0);\n+\n+    let const_vs_excl_range = |x, b| {\n+        match x {\n+            3 if b => 0,\n+            5..7 => 2,\n+            1..4 => 1,\n+            _ => 3,\n+        }\n+    };\n+    assert_eq!(const_vs_excl_range(3, false), 1);\n+    assert_eq!(const_vs_excl_range(3, true), 0);\n+}"}]}