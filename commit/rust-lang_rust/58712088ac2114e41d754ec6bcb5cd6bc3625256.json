{"sha": "58712088ac2114e41d754ec6bcb5cd6bc3625256", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NzEyMDg4YWMyMTE0ZTQxZDc1NGVjNmJjYjVjZDZiYzM2MjUyNTY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T18:23:59Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T19:37:06Z"}, "message": "minor: make diagnostics more similar", "tree": {"sha": "396054e4e67546aa158ab2bca0ad2f0f0b9d8fff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/396054e4e67546aa158ab2bca0ad2f0f0b9d8fff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58712088ac2114e41d754ec6bcb5cd6bc3625256", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58712088ac2114e41d754ec6bcb5cd6bc3625256", "html_url": "https://github.com/rust-lang/rust/commit/58712088ac2114e41d754ec6bcb5cd6bc3625256", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58712088ac2114e41d754ec6bcb5cd6bc3625256/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38ae18b7592f97a7058d97928307bccbd881a582", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ae18b7592f97a7058d97928307bccbd881a582", "html_url": "https://github.com/rust-lang/rust/commit/38ae18b7592f97a7058d97928307bccbd881a582"}], "stats": {"total": 405, "additions": 204, "deletions": 201}, "files": [{"sha": "33152e284583d587c28db9ff92bb6ca5933bd0bc", "filename": "crates/ide_diagnostics/src/handlers/field_shorthand.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Ffield_shorthand.rs?ref=58712088ac2114e41d754ec6bcb5cd6bc3625256", "patch": "@@ -7,7 +7,7 @@ use text_edit::TextEdit;\n \n use crate::{fix, Diagnostic, Severity};\n \n-pub(super) fn check(acc: &mut Vec<Diagnostic>, file_id: FileId, node: &SyntaxNode) {\n+pub(crate) fn field_shorthand(acc: &mut Vec<Diagnostic>, file_id: FileId, node: &SyntaxNode) {\n     match_ast! {\n         match node {\n             ast::RecordExpr(it) => check_expr_field_shorthand(acc, file_id, it),", "previous_filename": "crates/ide_diagnostics/src/field_shorthand.rs"}, {"sha": "0dd36fb23673195ff8cba72b56be34416a94dcfd", "filename": "crates/ide_diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=58712088ac2114e41d754ec6bcb5cd6bc3625256", "patch": "@@ -323,4 +323,33 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn import_extern_crate_clash_with_inner_item() {\n+        // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n+\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib deps:jwt\n+mod permissions;\n+\n+use permissions::jwt;\n+\n+fn f() {\n+    fn inner() {}\n+    jwt::Claims {}; // should resolve to the local one with 0 fields, and not get a diagnostic\n+}\n+\n+//- /permissions.rs\n+pub mod jwt  {\n+    pub struct Claims {}\n+}\n+\n+//- /jwt/lib.rs crate:jwt\n+pub struct Claims {\n+    field: u8,\n+}\n+        \"#,\n+        );\n+    }\n }"}, {"sha": "8e601fa48dffab71db9e27dd1f2253a01c5fe44c", "filename": "crates/ide_diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=58712088ac2114e41d754ec6bcb5cd6bc3625256", "patch": "@@ -14,32 +14,29 @@ use text_edit::TextEdit;\n \n use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n \n-#[derive(Debug)]\n-pub(crate) struct UnlinkedFile {\n-    pub(crate) file: FileId,\n-}\n-\n // Diagnostic: unlinked-file\n //\n // This diagnostic is shown for files that are not included in any crate, or files that are part of\n // crates rust-analyzer failed to discover. The file will not have IDE features available.\n-pub(crate) fn unlinked_file(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Diagnostic {\n+pub(crate) fn unlinked_file(ctx: &DiagnosticsContext, acc: &mut Vec<Diagnostic>, file_id: FileId) {\n     // Limit diagnostic to the first few characters in the file. This matches how VS Code\n     // renders it with the full span, but on other editors, and is less invasive.\n-    let range = ctx.sema.db.parse(d.file).syntax_node().text_range();\n+    let range = ctx.sema.db.parse(file_id).syntax_node().text_range();\n     // FIXME: This is wrong if one of the first three characters is not ascii: `//\u042b`.\n     let range = range.intersect(TextRange::up_to(TextSize::of(\"...\"))).unwrap_or(range);\n \n-    Diagnostic::new(\"unlinked-file\", \"file not included in module tree\", range)\n-        .with_fixes(fixes(ctx, d))\n+    acc.push(\n+        Diagnostic::new(\"unlinked-file\", \"file not included in module tree\", range)\n+            .with_fixes(fixes(ctx, file_id)),\n+    );\n }\n \n-fn fixes(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Option<Vec<Assist>> {\n+fn fixes(ctx: &DiagnosticsContext, file_id: FileId) -> Option<Vec<Assist>> {\n     // If there's an existing module that could add `mod` or `pub mod` items to include the unlinked file,\n     // suggest that as a fix.\n \n-    let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(d.file));\n-    let our_path = source_root.path_for_file(&d.file)?;\n+    let source_root = ctx.sema.db.source_root(ctx.sema.db.file_source_root(file_id));\n+    let our_path = source_root.path_for_file(&file_id)?;\n     let module_name = our_path.name_and_extension()?.0;\n \n     // Candidates to look for:\n@@ -68,7 +65,7 @@ fn fixes(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Option<Vec<Assist>> {\n                     }\n \n                     if module.origin.file_id() == Some(*parent_id) {\n-                        return make_fixes(ctx.sema.db, *parent_id, module_name, d.file);\n+                        return make_fixes(ctx.sema.db, *parent_id, module_name, file_id);\n                     }\n                 }\n             }"}, {"sha": "8b9330e040137a183977f3ef2ddcf1dd95d55249", "filename": "crates/ide_diagnostics/src/handlers/useless_braces.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fuseless_braces.rs?ref=58712088ac2114e41d754ec6bcb5cd6bc3625256", "patch": "@@ -0,0 +1,148 @@\n+use ide_db::{base_db::FileId, source_change::SourceChange};\n+use itertools::Itertools;\n+use syntax::{ast, AstNode, SyntaxNode, TextRange};\n+use text_edit::TextEdit;\n+\n+use crate::{fix, Diagnostic, Severity};\n+\n+// Diagnostic: unnecessary-braces\n+//\n+// Diagnostic for unnecessary braces in `use` items.\n+pub(crate) fn useless_braces(\n+    acc: &mut Vec<Diagnostic>,\n+    file_id: FileId,\n+    node: &SyntaxNode,\n+) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n+    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+        // If there is a comment inside the bracketed `use`,\n+        // assume it is a commented out module path and don't show diagnostic.\n+        if use_tree_list.has_inner_comment() {\n+            return Some(());\n+        }\n+\n+        let use_range = use_tree_list.syntax().text_range();\n+        let edit = remove_braces(&single_use_tree).unwrap_or_else(|| {\n+            let to_replace = single_use_tree.syntax().text().to_string();\n+            let mut edit_builder = TextEdit::builder();\n+            edit_builder.delete(use_range);\n+            edit_builder.insert(use_range.start(), to_replace);\n+            edit_builder.finish()\n+        });\n+\n+        acc.push(\n+            Diagnostic::new(\n+                \"unnecessary-braces\",\n+                \"Unnecessary braces in use statement\".to_string(),\n+                use_range,\n+            )\n+            .severity(Severity::WeakWarning)\n+            .with_fixes(Some(vec![fix(\n+                \"remove_braces\",\n+                \"Remove unnecessary braces\",\n+                SourceChange::from_text_edit(file_id, edit),\n+                use_range,\n+            )])),\n+        );\n+    }\n+\n+    Some(())\n+}\n+\n+fn remove_braces(single_use_tree: &ast::UseTree) -> Option<TextEdit> {\n+    let use_tree_list_node = single_use_tree.syntax().parent()?;\n+    if single_use_tree.path()?.segment()?.self_token().is_some() {\n+        let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n+        let end = use_tree_list_node.text_range().end();\n+        return Some(TextEdit::delete(TextRange::new(start, end)));\n+    }\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn test_check_unnecessary_braces_in_use_statement() {\n+        check_diagnostics(\n+            r#\"\n+use a;\n+use a::{c, d::e};\n+\n+mod a {\n+    mod c {}\n+    mod d {\n+        mod e {}\n+    }\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+use a;\n+use a::{\n+    c,\n+    // d::e\n+};\n+\n+mod a {\n+    mod c {}\n+    mod d {\n+        mod e {}\n+    }\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+mod b {}\n+use {$0b};\n+\"#,\n+            r#\"\n+mod b {}\n+use b;\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+mod b {}\n+use {b$0};\n+\"#,\n+            r#\"\n+mod b {}\n+use b;\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+mod a { mod c {} }\n+use a::{c$0};\n+\"#,\n+            r#\"\n+mod a { mod c {} }\n+use a::c;\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+mod a {}\n+use a::{self$0};\n+\"#,\n+            r#\"\n+mod a {}\n+use a;\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+mod a { mod c {} mod d { mod e {} } }\n+use a::{c, d::{e$0}};\n+\"#,\n+            r#\"\n+mod a { mod c {} mod d { mod e {} } }\n+use a::{c, d::e};\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "52474eeab4f37e93ce39bc703124de4549b6622a", "filename": "crates/ide_diagnostics/src/lib.rs", "status": "modified", "additions": 16, "deletions": 187, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58712088ac2114e41d754ec6bcb5cd6bc3625256/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Flib.rs?ref=58712088ac2114e41d754ec6bcb5cd6bc3625256", "patch": "@@ -37,15 +37,17 @@ mod handlers {\n     pub(crate) mod remove_this_semicolon;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod unimplemented_builtin_macro;\n-    pub(crate) mod unlinked_file;\n     pub(crate) mod unresolved_extern_crate;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n     pub(crate) mod unresolved_proc_macro;\n-}\n \n-mod field_shorthand;\n+    // The handlers bellow are unusual, the implement the diagnostics as well.\n+    pub(crate) mod field_shorthand;\n+    pub(crate) mod useless_braces;\n+    pub(crate) mod unlinked_file;\n+}\n \n use hir::{diagnostics::AnyDiagnostic, Semantics};\n use ide_db::{\n@@ -55,15 +57,8 @@ use ide_db::{\n     source_change::SourceChange,\n     RootDatabase,\n };\n-use itertools::Itertools;\n use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode, TextRange,\n-};\n-use text_edit::TextEdit;\n-\n-use crate::handlers::unlinked_file::UnlinkedFile;\n+use syntax::{ast::AstNode, TextRange};\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct DiagnosticCode(pub &'static str);\n@@ -123,6 +118,8 @@ impl Diagnostic {\n #[derive(Debug, Copy, Clone)]\n pub enum Severity {\n     Error,\n+    // We don't actually emit this one yet, but we should at some point.\n+    // Warning,\n     WeakWarning,\n }\n \n@@ -157,21 +154,20 @@ pub fn diagnostics(\n     );\n \n     for node in parse.tree().syntax().descendants() {\n-        check_unnecessary_braces_in_use_statement(&mut res, file_id, &node);\n-        field_shorthand::check(&mut res, file_id, &node);\n+        handlers::useless_braces::useless_braces(&mut res, file_id, &node);\n+        handlers::field_shorthand::field_shorthand(&mut res, file_id, &node);\n     }\n \n-    let mut diags = Vec::new();\n     let module = sema.to_module_def(file_id);\n-    if let Some(m) = module {\n-        m.diagnostics(db, &mut diags)\n-    }\n \n     let ctx = DiagnosticsContext { config, sema, resolve };\n     if module.is_none() {\n-        let d = UnlinkedFile { file: file_id };\n-        let d = handlers::unlinked_file::unlinked_file(&ctx, &d);\n-        res.push(d)\n+        handlers::unlinked_file::unlinked_file(&ctx, &mut res, file_id);\n+    }\n+\n+    let mut diags = Vec::new();\n+    if let Some(m) = module {\n+        m.diagnostics(db, &mut diags)\n     }\n \n     for diag in diags {\n@@ -211,61 +207,6 @@ pub fn diagnostics(\n     res\n }\n \n-fn check_unnecessary_braces_in_use_statement(\n-    acc: &mut Vec<Diagnostic>,\n-    file_id: FileId,\n-    node: &SyntaxNode,\n-) -> Option<()> {\n-    let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n-    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-        // If there is a comment inside the bracketed `use`,\n-        // assume it is a commented out module path and don't show diagnostic.\n-        if use_tree_list.has_inner_comment() {\n-            return Some(());\n-        }\n-\n-        let use_range = use_tree_list.syntax().text_range();\n-        let edit =\n-            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(&single_use_tree)\n-                .unwrap_or_else(|| {\n-                    let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEdit::builder();\n-                    edit_builder.delete(use_range);\n-                    edit_builder.insert(use_range.start(), to_replace);\n-                    edit_builder.finish()\n-                });\n-\n-        acc.push(\n-            Diagnostic::new(\n-                \"unnecessary-braces\",\n-                \"Unnecessary braces in use statement\".to_string(),\n-                use_range,\n-            )\n-            .severity(Severity::WeakWarning)\n-            .with_fixes(Some(vec![fix(\n-                \"remove_braces\",\n-                \"Remove unnecessary braces\",\n-                SourceChange::from_text_edit(file_id, edit),\n-                use_range,\n-            )])),\n-        );\n-    }\n-\n-    Some(())\n-}\n-\n-fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: &ast::UseTree,\n-) -> Option<TextEdit> {\n-    let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree.path()?.segment()?.self_token().is_some() {\n-        let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n-        let end = use_tree_list_node.text_range().end();\n-        return Some(TextEdit::delete(TextRange::new(start, end)));\n-    }\n-    None\n-}\n-\n fn fix(id: &'static str, label: &str, source_change: SourceChange, target: TextRange) -> Assist {\n     let mut res = unresolved_fix(id, label, target);\n     res.source_change = Some(source_change);\n@@ -397,89 +338,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_check_unnecessary_braces_in_use_statement() {\n-        check_diagnostics(\n-            r#\"\n-use a;\n-use a::{c, d::e};\n-\n-mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n-    }\n-}\n-\"#,\n-        );\n-        check_diagnostics(\n-            r#\"\n-use a;\n-use a::{\n-    c,\n-    // d::e\n-};\n-\n-mod a {\n-    mod c {}\n-    mod d {\n-        mod e {}\n-    }\n-}\n-\"#,\n-        );\n-        check_fix(\n-            r\"\n-            mod b {}\n-            use {$0b};\n-            \",\n-            r\"\n-            mod b {}\n-            use b;\n-            \",\n-        );\n-        check_fix(\n-            r\"\n-            mod b {}\n-            use {b$0};\n-            \",\n-            r\"\n-            mod b {}\n-            use b;\n-            \",\n-        );\n-        check_fix(\n-            r\"\n-            mod a { mod c {} }\n-            use a::{c$0};\n-            \",\n-            r\"\n-            mod a { mod c {} }\n-            use a::c;\n-            \",\n-        );\n-        check_fix(\n-            r\"\n-            mod a {}\n-            use a::{self$0};\n-            \",\n-            r\"\n-            mod a {}\n-            use a;\n-            \",\n-        );\n-        check_fix(\n-            r\"\n-            mod a { mod c {} mod d { mod e {} } }\n-            use a::{c, d::{e$0}};\n-            \",\n-            r\"\n-            mod a { mod c {} mod d { mod e {} } }\n-            use a::{c, d::e};\n-            \",\n-        );\n-    }\n-\n     #[test]\n     fn test_disabled_diagnostics() {\n         let mut config = DiagnosticsConfig::default();\n@@ -498,33 +356,4 @@ mod a {\n         );\n         assert!(!diagnostics.is_empty());\n     }\n-\n-    #[test]\n-    fn import_extern_crate_clash_with_inner_item() {\n-        // This is more of a resolver test, but doesn't really work with the hir_def testsuite.\n-\n-        check_diagnostics(\n-            r#\"\n-//- /lib.rs crate:lib deps:jwt\n-mod permissions;\n-\n-use permissions::jwt;\n-\n-fn f() {\n-    fn inner() {}\n-    jwt::Claims {}; // should resolve to the local one with 0 fields, and not get a diagnostic\n-}\n-\n-//- /permissions.rs\n-pub mod jwt  {\n-    pub struct Claims {}\n-}\n-\n-//- /jwt/lib.rs crate:jwt\n-pub struct Claims {\n-    field: u8,\n-}\n-        \"#,\n-        );\n-    }\n }"}]}