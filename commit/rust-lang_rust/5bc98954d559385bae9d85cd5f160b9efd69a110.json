{"sha": "5bc98954d559385bae9d85cd5f160b9efd69a110", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzk4OTU0ZDU1OTM4NWJhZTlkODVjZDVmMTYwYjllZmQ2OWExMTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-29T19:11:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-11-19T04:24:34Z"}, "message": "rustc: fix fallout of adding the `'tcx` lifetime to `Ty`.", "tree": {"sha": "db671c45fb806123776d731084e853354bfa99ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db671c45fb806123776d731084e853354bfa99ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc98954d559385bae9d85cd5f160b9efd69a110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc98954d559385bae9d85cd5f160b9efd69a110", "html_url": "https://github.com/rust-lang/rust/commit/5bc98954d559385bae9d85cd5f160b9efd69a110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc98954d559385bae9d85cd5f160b9efd69a110/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea", "html_url": "https://github.com/rust-lang/rust/commit/92ae0c6c255e826632f37e7b90d669d0cd4bb2ea"}], "stats": {"total": 7738, "additions": 4003, "deletions": 3735}, "files": [{"sha": "e805868274ab2dd1d1ae7e92e820289b65c5907c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -474,7 +474,8 @@ declare_lint!(BOX_POINTERS, Allow,\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type(&self, cx: &Context, span: Span, ty: Ty) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &Context<'a, 'tcx>,\n+                                 span: Span, ty: Ty<'tcx>) {\n         let mut n_uniq = 0i;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {"}, {"sha": "83f14d3a0db54868a2da890a1b9f6a15fab1ed8c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -546,30 +546,30 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx, id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         ty::lookup_trait_def(self.tcx, id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> Ty {\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n                                            -> bool {\n         // FIXME(pcwalton): This is wrong.\n         true\n     }\n \n     fn associated_type_binding(&self,\n                                _: Span,\n-                               _: Option<Ty>,\n+                               _: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         // FIXME(pcwalton): This is wrong.\n         let trait_def = self.get_trait_def(trait_id);\n         let index = ty::associated_type_parameter_index(self.tcx,"}, {"sha": "20e3f27f2ae18d2418af1a7622478c784cb42ce4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -123,8 +123,8 @@ pub fn get_enum_variant_defs(cstore: &cstore::CStore, enum_id: ast::DefId)\n     decoder::get_enum_variant_defs(&*cstore.intr, &*cdata, enum_id.node)\n }\n \n-pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n-                      -> Vec<Rc<ty::VariantInfo>> {\n+pub fn get_enum_variants<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                               -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n@@ -137,8 +137,8 @@ pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: ast::DefId)\n     decoder::get_impl_items(&*cdata, impl_def_id.node)\n }\n \n-pub fn get_impl_or_trait_item(tcx: &ty::ctxt, def: ast::DefId)\n-                              -> ty::ImplOrTraitItem {\n+pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                    -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n                                     &*cdata,\n@@ -166,15 +166,17 @@ pub fn get_item_variances(cstore: &cstore::CStore,\n     decoder::get_item_variances(&*cdata, def.node)\n }\n \n-pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n-                                  def: ast::DefId)\n-                               -> Vec<Rc<ty::Method>> {\n+pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        def: ast::DefId)\n+                                        -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<Rc<ty::TraitRef>> {\n+pub fn get_supertraits<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             def: ast::DefId)\n+                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(&*cdata, def.node, tcx)\n@@ -213,22 +215,22 @@ pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: ast::DefId) -> HashM\n     decoder::get_struct_field_attrs(&*cdata)\n }\n \n-pub fn get_type(tcx: &ty::ctxt,\n-                def: ast::DefId)\n-             -> ty::Polytype {\n+pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      def: ast::DefId)\n+                      -> ty::Polytype<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(&*cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n+pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(&*cdata, def.node, tcx)\n }\n \n-pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n-                      def: ast::DefId) -> ty::Polytype {\n+pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n+                            def: ast::DefId) -> ty::Polytype<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n@@ -255,17 +257,18 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n \n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n-pub fn get_impl_trait(tcx: &ty::ctxt,\n-                      def: ast::DefId) -> Option<Rc<ty::TraitRef>> {\n+pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            def: ast::DefId)\n+                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n-pub fn get_impl_vtables(tcx: &ty::ctxt,\n-                        def: ast::DefId)\n-                        -> typeck::vtable_res {\n+pub fn get_impl_vtables<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              def: ast::DefId)\n+                              -> typeck::vtable_res<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(&*cdata, def.node, tcx)"}, {"sha": "ffb847db1893302deba89a79907d64e0c323cc2a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -224,39 +224,44 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n     })\n }\n \n-fn doc_type(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> Ty {\n+fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n+                        cdata: Cmd) -> ty::BareFnTy<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n-pub fn item_type(_item_id: ast::DefId, item: rbml::Doc,\n-                 tcx: &ty::ctxt, cdata: Cmd) -> Ty {\n+pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n+                       tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                       -> ty::TraitRef<'tcx> {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                        -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn doc_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+fn doc_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                    -> ty::ParamBounds<'tcx> {\n     parse_bounds_data(doc.data, cdata.cnum, doc.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n }\n \n-fn trait_def_bounds(doc: rbml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::ParamBounds {\n+fn trait_def_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n+                          -> ty::ParamBounds<'tcx> {\n     let d = reader::get_doc(doc, tag_trait_def_bounds);\n     doc_bounds(d, tcx, cdata)\n }\n@@ -353,9 +358,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn get_trait_def(cdata: Cmd,\n-                     item_id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> ty::TraitDef\n+pub fn get_trait_def<'tcx>(cdata: Cmd,\n+                           item_id: ast::NodeId,\n+                           tcx: &ty::ctxt<'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -368,8 +373,8 @@ pub fn get_trait_def(cdata: Cmd,\n     }\n }\n \n-pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-    -> ty::Polytype {\n+pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+    -> ty::Polytype<'tcx> {\n \n     let item = lookup_item(id, cdata.data());\n \n@@ -403,20 +408,21 @@ pub fn get_repr_attrs(cdata: Cmd, id: ast::NodeId) -> Vec<attr::ReprAttr> {\n     }\n }\n \n-pub fn get_impl_trait(cdata: Cmd,\n-                      id: ast::NodeId,\n-                      tcx: &ty::ctxt) -> Option<Rc<ty::TraitRef>>\n+pub fn get_impl_trait<'tcx>(cdata: Cmd,\n+                            id: ast::NodeId,\n+                            tcx: &ty::ctxt<'tcx>)\n+                            -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n         Rc::new(doc_trait_ref(tp, tcx, cdata))\n     })\n }\n \n-pub fn get_impl_vtables(cdata: Cmd,\n-                        id: ast::NodeId,\n-                        tcx: &ty::ctxt)\n-                        -> typeck::vtable_res\n+pub fn get_impl_vtables<'tcx>(cdata: Cmd,\n+                              id: ast::NodeId,\n+                              tcx: &ty::ctxt<'tcx>)\n+                              -> typeck::vtable_res<'tcx>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n@@ -682,8 +688,8 @@ pub fn get_enum_variant_defs(intr: &IdentInterner,\n     }).collect()\n }\n \n-pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n+pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n+                               tcx: &ty::ctxt<'tcx>) -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n     let data = cdata.data();\n     let items = reader::get_doc(rbml::Doc::new(data), tag_items);\n     let item = find_item(id, items);\n@@ -786,11 +792,11 @@ pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n     }\n }\n \n-pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n-                              cdata: Cmd,\n-                              id: ast::NodeId,\n-                              tcx: &ty::ctxt)\n-                              -> ty::ImplOrTraitItem {\n+pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n+                                    cdata: Cmd,\n+                                    id: ast::NodeId,\n+                                    tcx: &ty::ctxt<'tcx>)\n+                                    -> ty::ImplOrTraitItem<'tcx> {\n     let method_doc = lookup_item(id, cdata.data());\n \n     let def_id = item_def_id(method_doc, cdata);\n@@ -860,11 +866,11 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n-                                  cdata: Cmd,\n-                                  id: ast::NodeId,\n-                                  tcx: &ty::ctxt)\n-                                  -> Vec<Rc<ty::Method>> {\n+pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n+                                        cdata: Cmd,\n+                                        id: ast::NodeId,\n+                                        tcx: &ty::ctxt<'tcx>)\n+                                        -> Vec<Rc<ty::Method<'tcx>>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n@@ -892,8 +898,8 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                    -> Vec<Rc<ty::TraitRef>> {\n+pub fn get_supertraits<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n+                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n@@ -1388,11 +1394,11 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n-fn doc_generics(base_doc: rbml::Doc,\n-                tcx: &ty::ctxt,\n-                cdata: Cmd,\n-                tag: uint)\n-                -> ty::Generics\n+fn doc_generics<'tcx>(base_doc: rbml::Doc,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: Cmd,\n+                      tag: uint)\n+                      -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n "}, {"sha": "7e4d2621f1837ab4dee232b4640e4a882ac20640", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -82,7 +82,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub link_meta: &'a LinkMeta,\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n-    pub type_abbrevs: tyencode::abbrev_map,\n+    pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n }\n \n@@ -104,10 +104,10 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn encode_trait_ref(rbml_w: &mut Encoder,\n-                    ecx: &EncodeContext,\n-                    trait_ref: &ty::TraitRef,\n-                    tag: uint) {\n+fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n+                              ecx: &EncodeContext<'a, 'tcx>,\n+                              trait_ref: &ty::TraitRef<'tcx>,\n+                              tag: uint) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -140,9 +140,9 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_bounds_and_type(rbml_w: &mut Encoder,\n-                          ecx: &EncodeContext,\n-                          pty: &ty::Polytype) {\n+fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n+                                    ecx: &EncodeContext<'a, 'tcx>,\n+                                    pty: &ty::Polytype<'tcx>) {\n     encode_generics(rbml_w, ecx, &pty.generics, tag_item_generics);\n     encode_type(ecx, rbml_w, pty.ty);\n }\n@@ -158,9 +158,9 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n }\n \n-pub fn write_closure_type(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          closure_type: &ty::ClosureTy) {\n+pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    closure_type: &ty::ClosureTy<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -170,9 +170,9 @@ pub fn write_closure_type(ecx: &EncodeContext,\n     tyencode::enc_closure_ty(rbml_w.writer, ty_str_ctxt, closure_type);\n }\n \n-pub fn write_type(ecx: &EncodeContext,\n-                  rbml_w: &mut Encoder,\n-                  typ: Ty) {\n+pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                            rbml_w: &mut Encoder,\n+                            typ: Ty<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -182,9 +182,9 @@ pub fn write_type(ecx: &EncodeContext,\n     tyencode::enc_ty(rbml_w.writer, ty_str_ctxt, typ);\n }\n \n-pub fn write_trait_ref(ecx: &EncodeContext,\n-                       rbml_w: &mut Encoder,\n-                       trait_ref: &ty::TraitRef) {\n+pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                 rbml_w: &mut Encoder,\n+                                trait_ref: &ty::TraitRef<'tcx>) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -206,10 +206,10 @@ pub fn write_region(ecx: &EncodeContext,\n     tyencode::enc_region(rbml_w.writer, ty_str_ctxt, r);\n }\n \n-fn encode_bounds(rbml_w: &mut Encoder,\n-                 ecx: &EncodeContext,\n-                 bounds: &ty::ParamBounds,\n-                 tag: uint) {\n+fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n+                           ecx: &EncodeContext<'a, 'tcx>,\n+                           bounds: &ty::ParamBounds<'tcx>,\n+                           tag: uint) {\n     rbml_w.start_tag(tag);\n \n     let ty_str_ctxt = &tyencode::ctxt { diag: ecx.diag,\n@@ -221,9 +221,9 @@ fn encode_bounds(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_type(ecx: &EncodeContext,\n-               rbml_w: &mut Encoder,\n-               typ: Ty) {\n+fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                         rbml_w: &mut Encoder,\n+                         typ: Ty<'tcx>) {\n     rbml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, rbml_w, typ);\n     rbml_w.end_tag();\n@@ -237,9 +237,9 @@ fn encode_region(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_method_fty(ecx: &EncodeContext,\n-                     rbml_w: &mut Encoder,\n-                     typ: &ty::BareFnTy) {\n+fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                               rbml_w: &mut Encoder,\n+                               typ: &ty::BareFnTy<'tcx>) {\n     rbml_w.start_tag(tag_item_method_fty);\n \n     let ty_str_ctxt = &tyencode::ctxt {\n@@ -781,10 +781,10 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_generics(rbml_w: &mut Encoder,\n-                   ecx: &EncodeContext,\n-                   generics: &ty::Generics,\n-                   tag: uint)\n+fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n+                             ecx: &EncodeContext<'a, 'tcx>,\n+                             generics: &ty::Generics<'tcx>,\n+                             tag: uint)\n {\n     rbml_w.start_tag(tag);\n \n@@ -828,9 +828,9 @@ fn encode_generics(rbml_w: &mut Encoder,\n     rbml_w.end_tag();\n }\n \n-fn encode_method_ty_fields(ecx: &EncodeContext,\n-                           rbml_w: &mut Encoder,\n-                           method_ty: &ty::Method) {\n+fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                     rbml_w: &mut Encoder,\n+                                     method_ty: &ty::Method<'tcx>) {\n     encode_def_id(rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n     encode_generics(rbml_w, ecx, &method_ty.generics,\n@@ -847,13 +847,13 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n \n-fn encode_info_for_method(ecx: &EncodeContext,\n-                          rbml_w: &mut Encoder,\n-                          m: &ty::Method,\n-                          impl_path: PathElems,\n-                          is_default_impl: bool,\n-                          parent_id: NodeId,\n-                          ast_item_opt: Option<&ast::ImplItem>) {\n+fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                    rbml_w: &mut Encoder,\n+                                    m: &ty::Method<'tcx>,\n+                                    impl_path: PathElems,\n+                                    is_default_impl: bool,\n+                                    parent_id: NodeId,\n+                                    ast_item_opt: Option<&ast::ImplItem>) {\n \n     debug!(\"encode_info_for_method: {} {}\", m.def_id,\n            token::get_name(m.name));\n@@ -2167,7 +2167,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: &ty::ctxt, t: Ty) -> String {\n+pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n     let mut wr = SeekableMemWriter::new();\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "34b57c5b437ed3e26bdbcb60d905683cd39464f9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -139,18 +139,18 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     buf\n }\n \n-pub fn parse_ty_closure_data(data: &[u8],\n-                             crate_num: ast::CrateNum,\n-                             pos: uint,\n-                             tcx: &ty::ctxt,\n-                             conv: conv_did)\n-                             -> ty::ClosureTy {\n+pub fn parse_ty_closure_data<'tcx>(data: &[u8],\n+                                   crate_num: ast::CrateNum,\n+                                   pos: uint,\n+                                   tcx: &ty::ctxt<'tcx>,\n+                                   conv: conv_did)\n+                                   -> ty::ClosureTy<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_closure_ty(&mut st, conv)\n }\n \n-pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                     conv: conv_did) -> Ty {\n+pub fn parse_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                           tcx: &ty::ctxt<'tcx>, conv: conv_did) -> Ty<'tcx> {\n     debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n@@ -163,30 +163,32 @@ pub fn parse_region_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_region(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                             conv: conv_did) -> ty::BareFnTy {\n+pub fn parse_bare_fn_ty_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                   tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                   -> ty::BareFnTy<'tcx> {\n     debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                            conv: conv_did) -> ty::TraitRef {\n+pub fn parse_trait_ref_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                                  tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                                  -> ty::TraitRef<'tcx> {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n-                         conv: conv_did) -> subst::Substs {\n+pub fn parse_substs_data<'tcx>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+                               tcx: &ty::ctxt<'tcx>, conv: conv_did) -> subst::Substs<'tcx> {\n     debug!(\"parse_substs_data {}\", data_log_string(data, pos));\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n }\n \n-pub fn parse_bounds_data(data: &[u8], crate_num: ast::CrateNum,\n-                         pos: uint, tcx: &ty::ctxt, conv: conv_did)\n-                         -> ty::ParamBounds {\n+pub fn parse_bounds_data<'tcx>(data: &[u8], crate_num: ast::CrateNum,\n+                               pos: uint, tcx: &ty::ctxt<'tcx>, conv: conv_did)\n+                               -> ty::ParamBounds<'tcx> {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bounds(&mut st, conv)\n }\n@@ -229,9 +231,9 @@ fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     }\n }\n \n-fn parse_vec_per_param_space<T>(st: &mut PState,\n-                                f: |&mut PState| -> T)\n-                                -> VecPerParamSpace<T>\n+fn parse_vec_per_param_space<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>,\n+                                          f: |&mut PState<'a, 'tcx>| -> T)\n+                                          -> VecPerParamSpace<T>\n {\n     let mut r = VecPerParamSpace::empty();\n     for &space in subst::ParamSpace::all().iter() {\n@@ -244,7 +246,8 @@ fn parse_vec_per_param_space<T>(st: &mut PState,\n     r\n }\n \n-fn parse_substs(st: &mut PState, conv: conv_did) -> subst::Substs {\n+fn parse_substs<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                          conv: conv_did) -> subst::Substs<'tcx> {\n     let regions =\n         parse_region_substs(st, |x,y| conv(x,y));\n \n@@ -334,7 +337,8 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n+fn parse_opt<'a, 'tcx, T>(st: &mut PState<'a, 'tcx>, f: |&mut PState<'a, 'tcx>| -> T)\n+                          -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),\n@@ -353,13 +357,14 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     result\n }\n \n-fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n+fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                             -> ty::TraitRef<'tcx> {\n     let def = parse_def(st, NominalType, |x,y| conv(x,y));\n     let substs = parse_substs(st, |x,y| conv(x,y));\n     ty::TraitRef {def_id: def, substs: substs}\n }\n \n-fn parse_ty(st: &mut PState, conv: conv_did) -> Ty {\n+fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n     match next(st) {\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n@@ -486,7 +491,7 @@ fn parse_mutability(st: &mut PState) -> ast::Mutability {\n     }\n }\n \n-fn parse_mt(st: &mut PState, conv: conv_did) -> ty::mt {\n+fn parse_mt<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::mt<'tcx> {\n     let m = parse_mutability(st);\n     ty::mt { ty: parse_ty(st, |x,y| conv(x,y)), mutbl: m }\n }\n@@ -548,7 +553,8 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n+fn parse_closure_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                              conv: conv_did) -> ty::ClosureTy<'tcx> {\n     let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n     let store = parse_trait_store(st, |x,y| conv(x,y));\n@@ -565,7 +571,8 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     }\n }\n \n-fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n+fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n+                              conv: conv_did) -> ty::BareFnTy<'tcx> {\n     let fn_style = parse_fn_style(next(st));\n     let abi = parse_abi_set(st);\n     let sig = parse_sig(st, |x,y| conv(x,y));\n@@ -576,7 +583,7 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     }\n }\n \n-fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n+fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'tcx> {\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n@@ -626,15 +633,16 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n-pub fn parse_type_param_def_data(data: &[u8], start: uint,\n-                                 crate_num: ast::CrateNum, tcx: &ty::ctxt,\n-                                 conv: conv_did) -> ty::TypeParameterDef\n+pub fn parse_type_param_def_data<'tcx>(data: &[u8], start: uint,\n+                                       crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n+                                       conv: conv_did) -> ty::TypeParameterDef<'tcx>\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);\n     parse_type_param_def(&mut st, conv)\n }\n \n-fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef {\n+fn parse_type_param_def<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                                  -> ty::TypeParameterDef<'tcx> {\n     let name = parse_name(st, ':');\n     let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n     let space = parse_param_space(st);\n@@ -692,7 +700,8 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n     }\n }\n \n-fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n+fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n+                          -> ty::ParamBounds<'tcx> {\n     let builtin_bounds = parse_builtin_bounds(st, |x,y| conv(x,y));\n \n     let mut param_bounds = ty::ParamBounds {"}, {"sha": "2a445e17b203b6fc0b5d5caddbc904218fedf68c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -36,19 +36,19 @@ pub struct ctxt<'a, 'tcx: 'a> {\n     pub ds: fn(ast::DefId) -> String,\n     // The type context.\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub abbrevs: &'a abbrev_map\n+    pub abbrevs: &'a abbrev_map<'tcx>\n }\n \n-// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// Compact string representation for Ty values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n pub struct ty_abbrev {\n     s: String\n }\n \n-pub type abbrev_map = RefCell<FnvHashMap<Ty, ty_abbrev>>;\n+pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n-pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: Ty) {\n+pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}\n@@ -79,7 +79,8 @@ fn enc_mutability(w: &mut SeekableMemWriter, mt: ast::Mutability) {\n     }\n }\n \n-fn enc_mt(w: &mut SeekableMemWriter, cx: &ctxt, mt: ty::mt) {\n+fn enc_mt<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                    mt: ty::mt<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n@@ -94,10 +95,10 @@ fn enc_opt<T>(w: &mut SeekableMemWriter, t: Option<T>, enc_f: |&mut SeekableMemW\n     }\n }\n \n-fn enc_vec_per_param_space<T>(w: &mut SeekableMemWriter,\n-                              cx: &ctxt,\n-                              v: &VecPerParamSpace<T>,\n-                              op: |&mut SeekableMemWriter, &ctxt, &T|) {\n+fn enc_vec_per_param_space<'a, 'tcx, T>(w: &mut SeekableMemWriter,\n+                                        cx: &ctxt<'a, 'tcx>,\n+                                        v: &VecPerParamSpace<T>,\n+                                        op: |&mut SeekableMemWriter, &ctxt<'a, 'tcx>, &T|) {\n     for &space in subst::ParamSpace::all().iter() {\n         mywrite!(w, \"[\");\n         for t in v.get_slice(space).iter() {\n@@ -107,7 +108,8 @@ fn enc_vec_per_param_space<T>(w: &mut SeekableMemWriter,\n     }\n }\n \n-pub fn enc_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Substs) {\n+pub fn enc_substs<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                            substs: &subst::Substs<'tcx>) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n@@ -180,7 +182,8 @@ fn enc_bound_region(w: &mut SeekableMemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref(w: &mut SeekableMemWriter, cx: &ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                               s: &ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n@@ -196,7 +199,8 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n     }\n }\n \n-fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n+fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                     st: &ty::sty<'tcx>) {\n     match *st {\n         ty::ty_bool => mywrite!(w, \"b\"),\n         ty::ty_char => mywrite!(w, \"c\"),\n@@ -314,13 +318,15 @@ fn enc_onceness(w: &mut SeekableMemWriter, o: ast::Onceness) {\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                ft: &ty::BareFnTy<'tcx>) {\n     enc_fn_style(w, ft.fn_style);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n+pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                ft: &ty::ClosureTy<'tcx>) {\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n     enc_trait_store(w, cx, ft.store);\n@@ -329,7 +335,8 @@ pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy)\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                        fsig: &ty::FnSig<'tcx>) {\n     mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -368,7 +375,8 @@ pub fn enc_existential_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::Exi\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n }\n \n-pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n+pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                            bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n     for &r in bs.region_bounds.iter() {\n@@ -384,7 +392,8 @@ pub fn enc_bounds(w: &mut SeekableMemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n+                                    v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);"}, {"sha": "3cebb7236b64001e2d80c80e5b65f426c99db9df", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 142, "deletions": 121, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -577,15 +577,15 @@ impl tr for ty::UpvarBorrow {\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n-trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, dcx: &DecodeContext)\n-        -> (typeck::ExprAdjustment, MethodCallee);\n+trait read_method_callee_helper<'tcx> {\n+    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+        -> (typeck::ExprAdjustment, MethodCallee<'tcx>);\n }\n \n-fn encode_method_callee(ecx: &e::EncodeContext,\n-                        rbml_w: &mut Encoder,\n-                        adjustment: typeck::ExprAdjustment,\n-                        method: &MethodCallee) {\n+fn encode_method_callee<'a, 'tcx>(ecx: &e::EncodeContext<'a, 'tcx>,\n+                                  rbml_w: &mut Encoder,\n+                                  adjustment: typeck::ExprAdjustment,\n+                                  method: &MethodCallee<'tcx>) {\n     use serialize::Encoder;\n \n     rbml_w.emit_struct(\"MethodCallee\", 4, |rbml_w| {\n@@ -604,9 +604,9 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n     }).unwrap();\n }\n \n-impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, dcx: &DecodeContext)\n-        -> (typeck::ExprAdjustment, MethodCallee) {\n+impl<'a, 'tcx> read_method_callee_helper<'tcx> for reader::Decoder<'a> {\n+    fn read_method_callee<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+        -> (typeck::ExprAdjustment, MethodCallee<'tcx>) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n             let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n@@ -627,8 +627,8 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n     }\n }\n \n-impl tr for MethodOrigin {\n-    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin {\n+impl<'tcx> tr for MethodOrigin<'tcx> {\n+    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin<'tcx> {\n         match *self {\n             typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(dcx)),\n             typeck::MethodStaticUnboxedClosure(did) => {\n@@ -683,26 +683,26 @@ pub fn encode_unboxed_closure_kind(ebml_w: &mut Encoder,\n     }).unwrap()\n }\n \n-pub trait vtable_decoder_helpers {\n+pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut Self| -> T)\n                                    -> VecPerParamSpace<T>;\n     fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt,\n+                                tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (typeck::ExprAdjustment, typeck::vtable_res);\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res<'tcx>);\n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_res;\n+                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_res<'tcx>;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_param_res;\n+                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_param_res<'tcx>;\n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                          -> typeck::vtable_origin;\n+                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                          -> typeck::vtable_origin<'tcx>;\n }\n \n-impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n+impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_vec_per_param_space<T>(&mut self,\n                                    f: |&mut reader::Decoder<'a>| -> T)\n                                    -> VecPerParamSpace<T>\n@@ -715,9 +715,9 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt,\n+                                tcx: &ty::ctxt<'tcx>,\n                                 cdata: &cstore::crate_metadata)\n-                                -> (typeck::ExprAdjustment, typeck::vtable_res) {\n+                                -> (typeck::ExprAdjustment, typeck::vtable_res<'tcx>) {\n         self.read_struct(\"VtableWithKey\", 2, |this| {\n             let adjustment = this.read_struct_field(\"adjustment\", 0, |this| {\n                 Decodable::decode(this)\n@@ -729,24 +729,24 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt,\n+                       tcx: &ty::ctxt<'tcx>,\n                        cdata: &cstore::crate_metadata)\n-                       -> typeck::vtable_res\n+                       -> typeck::vtable_res<'tcx>\n     {\n         self.read_vec_per_param_space(\n             |this| this.read_vtable_param_res(tcx, cdata))\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-                      -> typeck::vtable_param_res {\n+                             tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+                      -> typeck::vtable_param_res<'tcx> {\n         self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n              .unwrap().into_iter().collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n-        -> typeck::vtable_origin {\n+                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n+        -> typeck::vtable_origin<'tcx> {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant(&[\"vtable_static\",\n                                      \"vtable_param\",\n@@ -824,43 +824,46 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n     }\n }\n \n-trait rbml_writer_helpers {\n-    fn emit_closure_type(&mut self,\n-                         ecx: &e::EncodeContext,\n-                         closure_type: &ty::ClosureTy);\n-    fn emit_method_origin(&mut self,\n-                          ecx: &e::EncodeContext,\n-                          method_origin: &typeck::MethodOrigin);\n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: Ty);\n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[Ty]);\n-    fn emit_type_param_def(&mut self,\n-                           ecx: &e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef);\n-    fn emit_trait_ref(&mut self, ecx: &e::EncodeContext, ty: &ty::TraitRef);\n-    fn emit_polytype(&mut self,\n-                     ecx: &e::EncodeContext,\n-                     pty: ty::Polytype);\n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs);\n+trait rbml_writer_helpers<'tcx> {\n+    fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                             closure_type: &ty::ClosureTy<'tcx>);\n+    fn emit_method_origin<'a>(&mut self,\n+                              ecx: &e::EncodeContext<'a, 'tcx>,\n+                              method_origin: &typeck::MethodOrigin<'tcx>);\n+    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n+    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n+    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               type_param_def: &ty::TypeParameterDef<'tcx>);\n+    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          ty: &ty::TraitRef<'tcx>);\n+    fn emit_polytype<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                         pty: ty::Polytype<'tcx>);\n+    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                       substs: &subst::Substs<'tcx>);\n     fn emit_existential_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::ExistentialBounds);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n-    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n-    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef);\n-    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef);\n-    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind);\n-}\n-\n-impl<'a> rbml_writer_helpers for Encoder<'a> {\n-    fn emit_closure_type(&mut self,\n-                         ecx: &e::EncodeContext,\n-                         closure_type: &ty::ClosureTy) {\n+    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                                adj: &ty::AutoAdjustment<'tcx>);\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>);\n+    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n+    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            uk: &ty::UnsizeKind<'tcx>);\n+}\n+\n+impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n+    fn emit_closure_type<'a>(&mut self,\n+                             ecx: &e::EncodeContext<'a, 'tcx>,\n+                             closure_type: &ty::ClosureTy<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(e::write_closure_type(ecx, this, closure_type))\n         });\n     }\n \n-    fn emit_method_origin(&mut self,\n-                          ecx: &e::EncodeContext,\n-                          method_origin: &typeck::MethodOrigin)\n+    fn emit_method_origin<'a>(&mut self,\n+                              ecx: &e::EncodeContext<'a, 'tcx>,\n+                              method_origin: &typeck::MethodOrigin<'tcx>)\n     {\n         use serialize::Encoder;\n \n@@ -915,33 +918,31 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: Ty) {\n+    fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n-    fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[Ty]) {\n+    fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]) {\n         self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n-    fn emit_trait_ref(&mut self,\n-                      ecx: &e::EncodeContext,\n-                      trait_ref: &ty::TraitRef) {\n+    fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                          trait_ref: &ty::TraitRef<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n     }\n \n-    fn emit_type_param_def(&mut self,\n-                           ecx: &e::EncodeContext,\n-                           type_param_def: &ty::TypeParameterDef) {\n+    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               type_param_def: &ty::TypeParameterDef<'tcx>) {\n         self.emit_opaque(|this| {\n             Ok(tyencode::enc_type_param_def(this.writer,\n                                          &ecx.ty_str_ctxt(),\n                                          type_param_def))\n         });\n     }\n \n-    fn emit_polytype(&mut self,\n-                 ecx: &e::EncodeContext,\n-                 pty: ty::Polytype) {\n+    fn emit_polytype<'a>(&mut self,\n+                         ecx: &e::EncodeContext<'a, 'tcx>,\n+                         pty: ty::Polytype<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"Polytype\", 2, |this| {\n@@ -977,13 +978,15 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n-    fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &subst::Substs) {\n+    fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                       substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n \n-    fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n+    fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                                adj: &ty::AutoAdjustment<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n@@ -1004,7 +1007,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref(&mut self, ecx: &e::EncodeContext, autoref: &ty::AutoRef) {\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n@@ -1053,7 +1057,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_auto_deref_ref(&mut self, ecx: &e::EncodeContext, auto_deref_ref: &ty::AutoDerefRef) {\n+    fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                               auto_deref_ref: &ty::AutoDerefRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_struct(\"AutoDerefRef\", 2, |this| {\n@@ -1069,7 +1074,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n         });\n     }\n \n-    fn emit_unsize_kind(&mut self, ecx: &e::EncodeContext, uk: &ty::UnsizeKind) {\n+    fn emit_unsize_kind<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                            uk: &ty::UnsizeKind<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"UnsizeKind\", |this| {\n@@ -1325,23 +1331,31 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n     }\n }\n \n-trait rbml_decoder_decoder_helpers {\n-    fn read_method_origin(&mut self, dcx: &DecodeContext) -> typeck::MethodOrigin;\n-    fn read_ty(&mut self, dcx: &DecodeContext) -> Ty;\n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<Ty>;\n-    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef>;\n-    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n-                           -> ty::TypeParameterDef;\n-    fn read_polytype(&mut self, dcx: &DecodeContext)\n-                     -> ty::Polytype;\n-    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds;\n-    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs;\n-    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment;\n-    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n-                            -> ty::UnboxedClosure;\n-    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef;\n-    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef;\n-    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind;\n+trait rbml_decoder_decoder_helpers<'tcx> {\n+    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> typeck::MethodOrigin<'tcx>;\n+    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n+    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n+    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> Rc<ty::TraitRef<'tcx>>;\n+    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::TypeParameterDef<'tcx>;\n+    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                             -> ty::Polytype<'tcx>;\n+    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                       -> ty::ExistentialBounds;\n+    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                           -> subst::Substs<'tcx>;\n+    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::AutoAdjustment<'tcx>;\n+    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::UnboxedClosure<'tcx>;\n+    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::AutoDerefRef<'tcx>;\n+    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                            -> ty::AutoRef<'tcx>;\n+    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::UnsizeKind<'tcx>;\n     fn convert_def_id(&mut self,\n                       dcx: &DecodeContext,\n                       source: DefIdSource,\n@@ -1351,18 +1365,18 @@ trait rbml_decoder_decoder_helpers {\n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> Ty;\n+                     tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n     fn read_tys_nodcx(&mut self,\n-                      tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty>;\n-    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt,\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt<'tcx>,\n                          cdata: &cstore::crate_metadata)\n-                         -> subst::Substs;\n+                         -> subst::Substs<'tcx>;\n }\n \n-impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n+impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> Ty {\n+                     tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n                 doc.data,\n@@ -1374,18 +1388,18 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys_nodcx(&mut self,\n-                      tcx: &ty::ctxt,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty> {\n+                      tcx: &ty::ctxt<'tcx>,\n+                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n     fn read_substs_nodcx(&mut self,\n-                         tcx: &ty::ctxt,\n+                         tcx: &ty::ctxt<'tcx>,\n                          cdata: &cstore::crate_metadata)\n-                         -> subst::Substs\n+                         -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_substs_data(\n@@ -1397,8 +1411,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_method_origin(&mut self, dcx: &DecodeContext)\n-                          -> typeck::MethodOrigin\n+    fn read_method_origin<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> typeck::MethodOrigin<'tcx>\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n             let variants = &[\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n@@ -1468,7 +1482,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n \n-    fn read_ty(&mut self, dcx: &DecodeContext) -> Ty {\n+    fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx> {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1496,11 +1510,13 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<Ty> {\n+    fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                        -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n-    fn read_trait_ref(&mut self, dcx: &DecodeContext) -> Rc<ty::TraitRef> {\n+    fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                              -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,\n@@ -1512,8 +1528,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n-    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n-                           -> ty::TypeParameterDef {\n+    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n                 doc.data,\n@@ -1524,8 +1540,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_polytype(&mut self, dcx: &DecodeContext)\n-                                   -> ty::Polytype {\n+    fn read_polytype<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                             -> ty::Polytype<'tcx> {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n                 generics: this.read_struct_field(\"generics\", 0, |this| {\n@@ -1552,7 +1568,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds\n+    fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                       -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,\n@@ -1563,7 +1580,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs {\n+    fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                           -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n                                         dcx.cdata.cnum,\n@@ -1573,7 +1591,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment {\n+    fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1597,7 +1616,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef {\n+    fn read_auto_deref_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> ty::AutoDerefRef<'tcx> {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n@@ -1616,7 +1636,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef {\n+    fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> ty::AutoRef<'tcx> {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1674,7 +1694,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind {\n+    fn read_unsize_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                -> ty::UnsizeKind<'tcx> {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1716,8 +1737,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n-                            -> ty::UnboxedClosure {\n+    fn read_unboxed_closure<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                    -> ty::UnboxedClosure<'tcx> {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,"}, {"sha": "d91d666511dd5fe40fe82cd49d44cbf17b881f7a", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -86,11 +86,11 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: &'a [Loan],\n }\n \n-impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n@@ -100,7 +100,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n                consume_pat.repr(self.tcx()),\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> euv::Delegate for CheckLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n@@ -737,7 +737,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     fn check_assignment(&self,\n                         assignment_id: ast::NodeId,\n                         assignment_span: Span,\n-                        assignee_cmt: mc::cmt,\n+                        assignee_cmt: mc::cmt<'tcx>,\n                         mode: euv::MutateMode) {\n         debug!(\"check_assignment(assignee_cmt={})\", assignee_cmt.repr(self.tcx()));\n \n@@ -820,8 +820,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         }\n         return;\n \n-        fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n-                                     mut cmt: mc::cmt) {\n+        fn mark_variable_as_used_mut<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                               mut cmt: mc::cmt<'tcx>) {\n             //! If the mutability of the `cmt` being written is inherited\n             //! from a local variable, liveness will\n             //! not have been able to detect that this variable's mutability\n@@ -868,9 +868,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn check_for_aliasable_mutable_writes(this: &CheckLoanCtxt,\n-                                              span: Span,\n-                                              cmt: mc::cmt) -> bool {\n+        fn check_for_aliasable_mutable_writes<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                                        span: Span,\n+                                                        cmt: mc::cmt<'tcx>) -> bool {\n             //! Safety checks related to writes to aliasable, mutable locations\n \n             let guarantor = cmt.guarantor();\n@@ -889,10 +889,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             return true; // no errors reported\n         }\n \n-        fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n-                                            span: Span,\n-                                            cmt: mc::cmt)\n-                                            -> bool {\n+        fn check_for_aliasability_violation<'a, 'tcx>(this: &CheckLoanCtxt<'a, 'tcx>,\n+                                                      span: Span,\n+                                                      cmt: mc::cmt<'tcx>)\n+                                                      -> bool {\n             match cmt.freely_aliasable(this.tcx()) {\n                 None => {\n                     return true;"}, {"sha": "2ca42a42a0255c5b8ddf95616e143587c20124f3", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -25,10 +25,10 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n \n-struct GatherMoveInfo {\n+struct GatherMoveInfo<'tcx> {\n     id: ast::NodeId,\n     kind: MoveKind,\n-    cmt: mc::cmt,\n+    cmt: mc::cmt<'tcx>,\n     span_path_opt: Option<MoveSpanAndPath>\n }\n \n@@ -41,12 +41,12 @@ pub fn gather_decl(bccx: &BorrowckCtxt,\n     move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n }\n \n-pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n-                             move_data: &MoveData,\n-                             move_error_collector: &MoveErrorCollector,\n-                             move_expr_id: ast::NodeId,\n-                             cmt: mc::cmt,\n-                             move_reason: euv::MoveReason) {\n+pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                       move_data: &MoveData,\n+                                       move_error_collector: &MoveErrorCollector<'tcx>,\n+                                       move_expr_id: ast::NodeId,\n+                                       cmt: mc::cmt<'tcx>,\n+                                       move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n         euv::DirectRefMove | euv::PatBindingMove => MoveExpr,\n         euv::CaptureMove => Captured\n@@ -60,11 +60,11 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n-                            move_data: &MoveData,\n-                            move_error_collector: &MoveErrorCollector,\n-                            move_pat: &ast::Pat,\n-                            cmt: mc::cmt) {\n+pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      move_data: &MoveData,\n+                                      move_error_collector: &MoveErrorCollector<'tcx>,\n+                                      move_pat: &ast::Pat,\n+                                      cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n         ast::PatIdent(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n@@ -81,10 +81,10 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-fn gather_move(bccx: &BorrowckCtxt,\n-               move_data: &MoveData,\n-               move_error_collector: &MoveErrorCollector,\n-               move_info: GatherMoveInfo) {\n+fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                         move_data: &MoveData,\n+                         move_error_collector: &MoveErrorCollector<'tcx>,\n+                         move_info: GatherMoveInfo<'tcx>) {\n     debug!(\"gather_move(move_id={}, cmt={})\",\n            move_info.id, move_info.cmt.repr(bccx.tcx));\n \n@@ -127,8 +127,9 @@ pub fn gather_assignment(bccx: &BorrowckCtxt,\n                              mode);\n }\n \n-fn check_and_get_illegal_move_origin(bccx: &BorrowckCtxt,\n-                                     cmt: &mc::cmt) -> Option<mc::cmt> {\n+fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                               cmt: &mc::cmt<'tcx>)\n+                                               -> Option<mc::cmt<'tcx>> {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |"}, {"sha": "99795fb3009021720934c7caef47718835430df5", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -23,14 +23,14 @@ use syntax::codemap::Span;\n \n type R = Result<(),()>;\n \n-pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n-                          item_scope_id: ast::NodeId,\n-                          span: Span,\n-                          cause: euv::LoanCause,\n-                          cmt: mc::cmt,\n-                          loan_region: ty::Region,\n-                          _: ty::BorrowKind)\n-                          -> Result<(),()> {\n+pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                    item_scope_id: ast::NodeId,\n+                                    span: Span,\n+                                    cause: euv::LoanCause,\n+                                    cmt: mc::cmt<'tcx>,\n+                                    loan_region: ty::Region,\n+                                    _: ty::BorrowKind)\n+                                    -> Result<(),()> {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -54,12 +54,12 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     span: Span,\n     cause: euv::LoanCause,\n     loan_region: ty::Region,\n-    cmt_original: mc::cmt\n+    cmt_original: mc::cmt<'tcx>\n }\n \n impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n-    fn check(&self, cmt: &mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n+    fn check(&self, cmt: &mc::cmt<'tcx>, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n         debug!(\"guarantee_lifetime.check(cmt={}, loan_region={})\",\n                cmt.repr(self.bccx.tcx),"}, {"sha": "6bb511b2077c9659334036b271060ffa9c8a2bd6", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -60,16 +60,16 @@ pub fn gather_loans_in_fn(bccx: &BorrowckCtxt,\n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     move_data: move_data::MoveData,\n-    move_error_collector: move_error::MoveErrorCollector,\n+    move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan>,\n     item_ub: ast::NodeId,\n }\n \n-impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={}, mode={})\",\n                consume_id, cmt.repr(self.tcx()), mode);\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n \n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: euv::ConsumeMode) {\n         debug!(\"consume_pat(consume_pat={}, cmt={}, mode={})\",\n                consume_pat.repr(self.tcx()),\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: euv::MutateMode)\n     {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={})\",\n@@ -153,12 +153,12 @@ impl<'a, 'tcx> euv::Delegate for GatherLoanCtxt<'a, 'tcx> {\n }\n \n /// Implements the A-* rules in doc.rs.\n-fn check_aliasability(bccx: &BorrowckCtxt,\n-                      borrow_span: Span,\n-                      loan_cause: euv::LoanCause,\n-                      cmt: mc::cmt,\n-                      req_kind: ty::BorrowKind)\n-                      -> Result<(),()> {\n+fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                borrow_span: Span,\n+                                loan_cause: euv::LoanCause,\n+                                cmt: mc::cmt<'tcx>,\n+                                req_kind: ty::BorrowKind)\n+                                -> Result<(),()> {\n \n     match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n         (None, _) => {\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     fn guarantee_valid(&mut self,\n                        borrow_id: ast::NodeId,\n                        borrow_span: Span,\n-                       cmt: mc::cmt,\n+                       cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region,\n                        cause: euv::LoanCause) {\n@@ -349,12 +349,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             //    }\n         // }\n \n-        fn check_mutability(bccx: &BorrowckCtxt,\n-                            borrow_span: Span,\n-                            cause: euv::LoanCause,\n-                            cmt: mc::cmt,\n-                            req_kind: ty::BorrowKind)\n-                            -> Result<(),()> {\n+        fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      borrow_span: Span,\n+                                      cause: euv::LoanCause,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      req_kind: ty::BorrowKind)\n+                                      -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_kind {"}, {"sha": "a8440507949f41497d808a35b9ceb3a2b75de0bb", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -18,35 +18,35 @@ use syntax::codemap;\n use syntax::print::pprust;\n use util::ppaux::UserString;\n \n-pub struct MoveErrorCollector {\n-    errors: RefCell<Vec<MoveError>>\n+pub struct MoveErrorCollector<'tcx> {\n+    errors: RefCell<Vec<MoveError<'tcx>>>\n }\n \n-impl MoveErrorCollector {\n-    pub fn new() -> MoveErrorCollector {\n+impl<'tcx> MoveErrorCollector<'tcx> {\n+    pub fn new() -> MoveErrorCollector<'tcx> {\n         MoveErrorCollector {\n             errors: RefCell::new(Vec::new())\n         }\n     }\n \n-    pub fn add_error(&self, error: MoveError) {\n+    pub fn add_error(&self, error: MoveError<'tcx>) {\n         self.errors.borrow_mut().push(error);\n     }\n \n-    pub fn report_potential_errors(&self, bccx: &BorrowckCtxt) {\n+    pub fn report_potential_errors<'a>(&self, bccx: &BorrowckCtxt<'a, 'tcx>) {\n         report_move_errors(bccx, self.errors.borrow().deref())\n     }\n }\n \n-pub struct MoveError {\n-    move_from: mc::cmt,\n+pub struct MoveError<'tcx> {\n+    move_from: mc::cmt<'tcx>,\n     move_to: Option<MoveSpanAndPath>\n }\n \n-impl MoveError {\n-    pub fn with_move_info(move_from: mc::cmt,\n+impl<'tcx> MoveError<'tcx> {\n+    pub fn with_move_info(move_from: mc::cmt<'tcx>,\n                           move_to: Option<MoveSpanAndPath>)\n-                          -> MoveError {\n+                          -> MoveError<'tcx> {\n         MoveError {\n             move_from: move_from,\n             move_to: move_to,\n@@ -60,12 +60,13 @@ pub struct MoveSpanAndPath {\n     pub ident: ast::Ident\n }\n \n-pub struct GroupedMoveErrors {\n-    move_from: mc::cmt,\n+pub struct GroupedMoveErrors<'tcx> {\n+    move_from: mc::cmt<'tcx>,\n     move_to_places: Vec<MoveSpanAndPath>\n }\n \n-fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n+fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                errors: &Vec<MoveError<'tcx>>) {\n     let grouped_errors = group_errors_with_same_origin(errors);\n     for error in grouped_errors.iter() {\n         report_cannot_move_out_of(bccx, error.move_from.clone());\n@@ -78,16 +79,16 @@ fn report_move_errors(bccx: &BorrowckCtxt, errors: &Vec<MoveError>) {\n     }\n }\n \n-fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n-                                 -> Vec<GroupedMoveErrors> {\n+fn group_errors_with_same_origin<'tcx>(errors: &Vec<MoveError<'tcx>>)\n+                                       -> Vec<GroupedMoveErrors<'tcx>> {\n     let mut grouped_errors = Vec::new();\n     for error in errors.iter() {\n         append_to_grouped_errors(&mut grouped_errors, error)\n     }\n     return grouped_errors;\n \n-    fn append_to_grouped_errors(grouped_errors: &mut Vec<GroupedMoveErrors>,\n-                                error: &MoveError) {\n+    fn append_to_grouped_errors<'tcx>(grouped_errors: &mut Vec<GroupedMoveErrors<'tcx>>,\n+                                      error: &MoveError<'tcx>) {\n         let move_from_id = error.move_from.id;\n         debug!(\"append_to_grouped_errors(move_from_id={})\", move_from_id);\n         let move_to = if error.move_to.is_some() {\n@@ -110,7 +111,8 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n     }\n }\n \n-fn report_cannot_move_out_of(bccx: &BorrowckCtxt, move_from: mc::cmt) {\n+fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                       move_from: mc::cmt<'tcx>) {\n     match move_from.cat {\n         mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n         mc::cat_deref(_, _, mc::Implicit(..)) |"}, {"sha": "9b9a5e61393f888fe43448b9f284b67ea6c08f5b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -29,11 +29,12 @@ pub enum RestrictionResult {\n     SafeIf(Rc<LoanPath>, Vec<Rc<LoanPath>>)\n }\n \n-pub fn compute_restrictions(bccx: &BorrowckCtxt,\n-                            span: Span,\n-                            cause: euv::LoanCause,\n-                            cmt: mc::cmt,\n-                            loan_region: ty::Region) -> RestrictionResult {\n+pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      span: Span,\n+                                      cause: euv::LoanCause,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      loan_region: ty::Region)\n+                                      -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n@@ -56,7 +57,7 @@ struct RestrictionsContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn restrict(&self,\n-                cmt: mc::cmt) -> RestrictionResult {\n+                cmt: mc::cmt<'tcx>) -> RestrictionResult {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n         match cmt.cat.clone() {"}, {"sha": "dff70b92031a94c1d88a33cf9f65960903443f16", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -247,7 +247,7 @@ struct BorrowStats {\n     guaranteed_paths: uint\n }\n \n-pub type BckResult<T> = Result<T, BckError>;\n+pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n \n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n@@ -405,10 +405,10 @@ pub enum bckerr_code {\n // Combination of an error code and the categorization of the expression\n // that caused it\n #[deriving(PartialEq)]\n-pub struct BckError {\n+pub struct BckError<'tcx> {\n     span: Span,\n     cause: euv::LoanCause,\n-    cmt: mc::cmt,\n+    cmt: mc::cmt<'tcx>,\n     code: bckerr_code\n }\n \n@@ -436,7 +436,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         mc::MemCategorizationContext::new(self.tcx)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt<'tcx> {\n         match self.mc().cat_expr(expr) {\n             Ok(c) => c,\n             Err(()) => {\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn report(&self, err: BckError) {\n+    pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n             self.bckerr_to_string(&err).as_slice());\n@@ -586,8 +586,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn move_suggestion(tcx: &ty::ctxt, ty: Ty, default_msgs: (&'static str, &'static str))\n-                          -> (&'static str, &'static str) {\n+        fn move_suggestion<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>,\n+                                 default_msgs: (&'static str, &'static str))\n+                                 -> (&'static str, &'static str) {\n             match ty::get(ty).sty {\n                 ty::ty_closure(box ty::ClosureTy {\n                         store: ty::RegionTraitStore(..),\n@@ -631,7 +632,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_help(s, m);\n     }\n \n-    pub fn bckerr_to_string(&self, err: &BckError) -> String {\n+    pub fn bckerr_to_string(&self, err: &BckError<'tcx>) -> String {\n         match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n@@ -766,7 +767,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn note_and_explain_bckerr(&self, err: BckError) {\n+    pub fn note_and_explain_bckerr(&self, err: BckError<'tcx>) {\n         let code = err.code;\n         match code {\n             err_mutbl(..) => {\n@@ -893,7 +894,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         result\n     }\n \n-    pub fn cmt_to_string(&self, cmt: &mc::cmt_) -> String {\n+    pub fn cmt_to_string(&self, cmt: &mc::cmt_<'tcx>) -> String {\n         self.mc().cmt_to_string(cmt)\n     }\n }\n@@ -924,7 +925,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     }\n }\n \n-impl Repr for Loan {\n+impl<'tcx> Repr<'tcx> for Loan {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"Loan_{}({}, {}, {}-{}, {})\",\n                  self.index,\n@@ -936,7 +937,7 @@ impl Repr for Loan {\n     }\n }\n \n-impl Repr for LoanPath {\n+impl<'tcx> Repr<'tcx> for LoanPath {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match self {\n             &LpVar(id) => {"}, {"sha": "c161bf6b34877218535bf56f038fc890bee3348c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -1024,7 +1024,7 @@ struct MutationChecker<'a, 'tcx: 'a> {\n     cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,"}, {"sha": "dbba9288cbbc4cb0d9874655cdd272453a78be2b", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -45,11 +45,11 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> euv::Delegate for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {}; type: {}\", *cmt, ty_to_string(self.tcx, cmt.ty));\n         if !ty::type_is_sized(self.tcx, cmt.ty) {"}, {"sha": "dab6339ad533758a9eafb445fc818c4125305c31", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -53,7 +53,7 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     checker: &'a mut GlobalChecker,\n }\n \n-struct GlobalVisitor<'a, 'b, 't: 'b>(euv::ExprUseVisitor<'a, 'b, ty::ctxt<'t>>);\n+struct GlobalVisitor<'a, 'b, 'tcx: 'b>(euv::ExprUseVisitor<'a, 'b, 'tcx, ty::ctxt<'tcx>>);\n struct GlobalChecker {\n     static_consumptions: NodeSet,\n     const_borrows: NodeSet,\n@@ -256,7 +256,7 @@ impl<'a, 'b, 't, 'v> Visitor<'v> for GlobalVisitor<'a, 'b, 't> {\n     }\n }\n \n-impl euv::Delegate for GlobalChecker {\n+impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "e86fb18259c79dac36abe6cc15d29acfc804a182", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -40,28 +40,28 @@ use syntax::codemap::Span;\n \n /// This trait defines the callbacks you can expect to receive when\n /// employing the ExprUseVisitor.\n-pub trait Delegate {\n+pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n     fn consume(&mut self,\n                consume_id: ast::NodeId,\n                consume_span: Span,\n-               cmt: mc::cmt,\n+               cmt: mc::cmt<'tcx>,\n                mode: ConsumeMode);\n \n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n-                   cmt: mc::cmt,\n+                   cmt: mc::cmt<'tcx>,\n                    mode: ConsumeMode);\n \n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n-              cmt: mc::cmt,\n+              cmt: mc::cmt<'tcx>,\n               loan_region: ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n@@ -75,7 +75,7 @@ pub trait Delegate {\n     fn mutate(&mut self,\n               assignment_id: ast::NodeId,\n               assignment_span: Span,\n-              assignee_cmt: mc::cmt,\n+              assignee_cmt: mc::cmt<'tcx>,\n               mode: MutateMode);\n }\n \n@@ -201,10 +201,10 @@ impl OverloadedCallType {\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n \n-pub struct ExprUseVisitor<'d,'t,TYPER:'t> {\n+pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n     typer: &'t TYPER,\n     mc: mc::MemCategorizationContext<'t,TYPER>,\n-    delegate: &'d mut Delegate+'d,\n+    delegate: &'d mut Delegate<'tcx>+'d,\n }\n \n // If the TYPER results in an error, it's because the type check\n@@ -223,10 +223,10 @@ macro_rules! return_if_err(\n     )\n )\n \n-impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n-    pub fn new(delegate: &'d mut Delegate,\n+impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n+    pub fn new(delegate: &'d mut Delegate<'tcx>,\n                typer: &'t TYPER)\n-               -> ExprUseVisitor<'d,'t,TYPER> {\n+               -> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         ExprUseVisitor { typer: typer,\n                          mc: mc::MemCategorizationContext::new(typer),\n                          delegate: delegate }\n@@ -262,7 +262,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn delegate_consume(&mut self,\n                         consume_id: ast::NodeId,\n                         consume_span: Span,\n-                        cmt: mc::cmt) {\n+                        cmt: mc::cmt<'tcx>) {\n         let mode = copy_or_move(self.tcx(), cmt.ty, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n@@ -823,7 +823,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         return true;\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) {\n         for pat in arm.pats.iter() {\n             self.walk_pat(discr_cmt.clone(), &**pat);\n         }\n@@ -835,7 +835,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: &ast::Pat) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n@@ -990,7 +990,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n                         upvar_def: def::Def)\n-                        -> mc::McResult<mc::cmt> {\n+                        -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.def_id().node;\n@@ -999,7 +999,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     }\n }\n \n-fn copy_or_move(tcx: &ty::ctxt, ty: Ty, move_reason: MoveReason) -> ConsumeMode {\n+fn copy_or_move<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>,\n+                      move_reason: MoveReason) -> ConsumeMode {\n     if ty::type_moves_by_default(tcx, ty) { Move(move_reason) } else { Copy }\n }\n "}, {"sha": "1880a8fce8426ff91268c6d142d16d8e80ede27e", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -23,8 +23,8 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: Ty)\n-                                            -> bool {\n+fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<'tcx>)\n+                                                  -> bool {\n     let mut result = false;\n     ty::maybe_walk_ty(typ, |typ| {\n         match ty::get(typ).sty {\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty, to: Ty, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n         if type_size_is_affected_by_type_parameters(self.tcx, from) {\n             span_err!(self.tcx.sess, span, E0139,\n                       \"cannot transmute from a type that contains type parameters\");"}, {"sha": "320cdae826ccb21d4507010d952a01564815eafc", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -1518,7 +1518,7 @@ fn check_fn(_v: &Liveness,\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn fn_ret(&self, id: NodeId) -> ty::FnOutput {\n+    fn fn_ret(&self, id: NodeId) -> ty::FnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match ty::get(fn_ty).sty {\n             ty::ty_unboxed_closure(closure_def_id, _, _) =>"}, {"sha": "cf1e58d17c78864e21c3baf3415afc4b232f11c7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -90,14 +90,14 @@ use std::cell::RefCell;\n use std::rc::Rc;\n \n #[deriving(Clone, PartialEq, Show)]\n-pub enum categorization {\n-    cat_rvalue(ty::Region),            // temporary val, argument is its scope\n+pub enum categorization<'tcx> {\n+    cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n     cat_static_item,\n-    cat_upvar(Upvar),                  // upvar referenced by closure env\n-    cat_local(ast::NodeId),            // local variable\n-    cat_deref(cmt, uint, PointerKind), // deref of a ptr\n-    cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n-    cat_downcast(cmt),                 // selects a particular enum variant (*1)\n+    cat_upvar(Upvar),                          // upvar referenced by closure env\n+    cat_local(ast::NodeId),                    // local variable\n+    cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n+    cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n+    cat_downcast(cmt<'tcx>),                   // selects a particular enum variant (*1)\n \n     // (*1) downcast is only required if the enum has more than one variant\n }\n@@ -175,16 +175,16 @@ pub enum Note {\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n #[deriving(Clone, PartialEq, Show)]\n-pub struct cmt_ {\n-    pub id: ast::NodeId,          // id of expr/pat producing this value\n+pub struct cmt_<'tcx> {\n+    pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n-    pub cat: categorization,       // categorization of expr\n+    pub cat: categorization<'tcx>, // categorization of expr\n     pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n-    pub ty: Ty,                    // type of the expr (*see WARNING above*)\n+    pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n }\n \n-pub type cmt = Rc<cmt_>;\n+pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n@@ -232,7 +232,7 @@ pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n     }\n }\n \n-pub fn deref_kind(tcx: &ty::ctxt, t: Ty) -> deref_kind {\n+pub fn deref_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> deref_kind {\n     debug!(\"deref_kind {}\", ty_to_string(tcx, t));\n     match opt_deref_kind(t) {\n       Some(k) => k,\n@@ -285,16 +285,16 @@ pub type McResult<T> = Result<T, ()>;\n  */\n pub trait Typer<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty>;\n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty>;\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>>;\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>>;\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>;\n     fn is_method_call(&self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause;\n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>>;\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>;\n }\n \n impl MutabilityCategory {\n@@ -393,26 +393,26 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<Ty<'tcx>> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n                          self.typer.adjustments().borrow().get(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty> {\n+    fn pat_ty(&self, pat: &ast::Pat) -> McResult<Ty<'tcx>> {\n         self.typer.node_ty(pat.id)\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -455,7 +455,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                autoderefs: uint)\n-                               -> McResult<cmt> {\n+                               -> McResult<cmt<'tcx>> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n@@ -466,7 +466,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt<'tcx>> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n@@ -546,9 +546,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n-                   expr_ty: Ty,\n+                   expr_ty: Ty<'tcx>,\n                    def: def::Def)\n-                   -> McResult<cmt> {\n+                   -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={} def={}\",\n                id, expr_ty.repr(self.tcx()), def);\n \n@@ -644,7 +644,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  kind: ty::UnboxedClosureKind,\n                  mode: ast::CaptureClause,\n                  is_unboxed: bool)\n-                 -> McResult<cmt> {\n+                 -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n         // environment pointer with an anonymous free region 'env and\n@@ -804,8 +804,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n-                           expr_ty: Ty)\n-                           -> cmt {\n+                           expr_ty: Ty<'tcx>)\n+                           -> cmt<'tcx> {\n         match self.typer.temporary_scope(id) {\n             Some(scope) => {\n                 match ty::get(expr_ty).sty {\n@@ -823,7 +823,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n-                      expr_ty: Ty) -> cmt {\n+                      expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id:cmt_id,\n             span:span,\n@@ -836,10 +836,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n-                                 base_cmt: cmt,\n+                                 base_cmt: cmt<'tcx>,\n                                  f_name: ast::Name,\n-                                 f_ty: Ty)\n-                                 -> cmt {\n+                                 f_ty: Ty<'tcx>)\n+                                 -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -852,10 +852,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_tup_field<N:ast_node>(&self,\n                                      node: &N,\n-                                     base_cmt: cmt,\n+                                     base_cmt: cmt<'tcx>,\n                                      f_idx: uint,\n-                                     f_ty: Ty)\n-                                     -> cmt {\n+                                     f_ty: Ty<'tcx>)\n+                                     -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -868,10 +868,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n-                             base_cmt: cmt,\n+                             base_cmt: cmt<'tcx>,\n                              deref_cnt: uint,\n                              implicit: bool)\n-                             -> cmt {\n+                             -> cmt<'tcx> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n@@ -907,11 +907,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n-                                    base_cmt: cmt,\n+                                    base_cmt: cmt<'tcx>,\n                                     deref_cnt: uint,\n-                                    deref_ty: Ty,\n+                                    deref_ty: Ty<'tcx>,\n                                     implicit: bool)\n-                                    -> cmt {\n+                                    -> cmt<'tcx> {\n         let (m, cat) = match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 let ptr = if implicit {\n@@ -944,8 +944,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n-                                 mut base_cmt: cmt)\n-                                 -> cmt {\n+                                 mut base_cmt: cmt<'tcx>)\n+                                 -> cmt<'tcx> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -988,11 +988,11 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         let m = base_cmt.mutbl.inherit();\n         return interior(elt, base_cmt.clone(), base_cmt.ty, m, element_ty);\n \n-        fn interior<N: ast_node>(elt: &N,\n-                                 of_cmt: cmt,\n-                                 vec_ty: Ty,\n-                                 mutbl: MutabilityCategory,\n-                                 element_ty: Ty) -> cmt\n+        fn interior<'tcx, N: ast_node>(elt: &N,\n+                                       of_cmt: cmt<'tcx>,\n+                                       vec_ty: Ty<'tcx>,\n+                                       mutbl: MutabilityCategory,\n+                                       element_ty: Ty<'tcx>) -> cmt<'tcx>\n         {\n             Rc::new(cmt_ {\n                 id:elt.id(),\n@@ -1009,8 +1009,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     // underlying vec.\n     fn deref_vec<N:ast_node>(&self,\n                              elt: &N,\n-                             base_cmt: cmt)\n-                             -> cmt {\n+                             base_cmt: cmt<'tcx>)\n+                             -> cmt<'tcx> {\n         match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n@@ -1038,9 +1038,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_slice_pattern(&self,\n-                             vec_cmt: cmt,\n+                             vec_cmt: cmt<'tcx>,\n                              slice_pat: &ast::Pat)\n-                             -> McResult<(cmt, ast::Mutability, ty::Region)> {\n+                             -> McResult<(cmt<'tcx>, ast::Mutability, ty::Region)> {\n         /*!\n          * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n          * the cmt for `P`, `slice_pat` is the pattern `Q`, returns:\n@@ -1085,10 +1085,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n-                                        base_cmt: cmt,\n-                                        interior_ty: Ty,\n+                                        base_cmt: cmt<'tcx>,\n+                                        interior_ty: Ty<'tcx>,\n                                         interior: InteriorKind)\n-                                        -> cmt {\n+                                        -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -1101,9 +1101,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n-                                    base_cmt: cmt,\n-                                    downcast_ty: Ty)\n-                                    -> cmt {\n+                                    base_cmt: cmt<'tcx>,\n+                                    downcast_ty: Ty<'tcx>)\n+                                    -> cmt<'tcx> {\n         Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n@@ -1115,10 +1115,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_pattern(&self,\n-                       cmt: cmt,\n+                       cmt: cmt<'tcx>,\n                        pat: &ast::Pat,\n                        op: |&MemCategorizationContext<TYPER>,\n-                            cmt,\n+                            cmt<'tcx>,\n                             &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n@@ -1291,7 +1291,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         Ok(())\n     }\n \n-    pub fn cmt_to_string(&self, cmt: &cmt_) -> String {\n+    pub fn cmt_to_string(&self, cmt: &cmt_<'tcx>) -> String {\n         fn upvar_to_string(upvar: &Upvar, is_copy: bool) -> String {\n             if upvar.is_unboxed {\n                 let kind = match upvar.kind {\n@@ -1376,8 +1376,8 @@ pub enum AliasableReason {\n     AliasableStaticMut(InteriorSafety),\n }\n \n-impl cmt_ {\n-    pub fn guarantor(&self) -> cmt {\n+impl<'tcx> cmt_<'tcx> {\n+    pub fn guarantor(&self) -> cmt<'tcx> {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1400,7 +1400,8 @@ impl cmt_ {\n         }\n     }\n \n-    pub fn freely_aliasable(&self, ctxt: &ty::ctxt) -> Option<AliasableReason> {\n+    pub fn freely_aliasable(&self, ctxt: &ty::ctxt<'tcx>)\n+                            -> Option<AliasableReason> {\n         /*!\n          * Returns `Some(_)` if this lvalue represents a freely aliasable\n          * pointer type.\n@@ -1455,7 +1456,7 @@ impl cmt_ {\n \n     // Digs down through one or two layers of deref and grabs the cmt\n     // for the upvar if a note indicates there is one.\n-    pub fn upvar(&self) -> Option<cmt> {\n+    pub fn upvar(&self) -> Option<cmt<'tcx>> {\n         match self.note {\n             NoteClosureEnv(..) | NoteUpvarRef(..) => {\n                 Some(match self.cat {\n@@ -1474,8 +1475,8 @@ impl cmt_ {\n     }\n }\n \n-impl Repr for cmt_ {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for cmt_<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"{{{} id:{} m:{} ty:{}}}\",\n                 self.cat.repr(tcx),\n                 self.id,\n@@ -1484,8 +1485,8 @@ impl Repr for cmt_ {\n     }\n }\n \n-impl Repr for categorization {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for categorization<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1519,7 +1520,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl Repr for InteriorKind {\n+impl<'tcx> Repr<'tcx> for InteriorKind {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         match *self {\n             InteriorField(NamedField(fld)) => {"}, {"sha": "c334d98daadea5f81fe29eac6ae6905d2f5a5df3", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -32,7 +32,7 @@ use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-type Context<'a> = (&'a MethodMap, &'a resolve::ExportMap2);\n+type Context<'a, 'tcx> = (&'a MethodMap<'tcx>, &'a resolve::ExportMap2);\n \n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = NodeSet;"}, {"sha": "acfce00b360bacc42d21bee6a8fba6ee57fd428b", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -31,8 +31,8 @@ use syntax::codemap::{Span, DUMMY_SP};\n  * `ParamSpace`).\n  */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct Substs {\n-    pub types: VecPerParamSpace<Ty>,\n+pub struct Substs<'tcx> {\n+    pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n }\n \n@@ -46,45 +46,45 @@ pub enum RegionSubsts {\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n }\n \n-impl Substs {\n-    pub fn new(t: VecPerParamSpace<Ty>,\n+impl<'tcx> Substs<'tcx> {\n+    pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n-               -> Substs\n+               -> Substs<'tcx>\n     {\n         Substs { types: t, regions: NonerasedRegions(r) }\n     }\n \n-    pub fn new_type(t: Vec<Ty>,\n+    pub fn new_type(t: Vec<Ty<'tcx>>,\n                     r: Vec<ty::Region>)\n-                    -> Substs\n+                    -> Substs<'tcx>\n     {\n         Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn new_trait(t: Vec<Ty>,\n+    pub fn new_trait(t: Vec<Ty<'tcx>>,\n                      r: Vec<ty::Region>,\n-                     a: Vec<Ty>,\n-                     s: Ty)\n-                    -> Substs\n+                     a: Vec<Ty<'tcx>>,\n+                     s: Ty<'tcx>)\n+                    -> Substs<'tcx>\n     {\n         Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n-    pub fn erased(t: VecPerParamSpace<Ty>) -> Substs\n+    pub fn erased(t: VecPerParamSpace<Ty<'tcx>>) -> Substs<'tcx>\n     {\n         Substs { types: t, regions: ErasedRegions }\n     }\n \n-    pub fn empty() -> Substs {\n+    pub fn empty() -> Substs<'tcx> {\n         Substs {\n             types: VecPerParamSpace::empty(),\n             regions: NonerasedRegions(VecPerParamSpace::empty()),\n         }\n     }\n \n-    pub fn trans_empty() -> Substs {\n+    pub fn trans_empty() -> Substs<'tcx> {\n         Substs {\n             types: VecPerParamSpace::empty(),\n             regions: ErasedRegions\n@@ -111,18 +111,18 @@ impl Substs {\n         }\n     }\n \n-    pub fn self_ty(&self) -> Option<Ty> {\n+pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         self.types.get_self().map(|&t| t)\n     }\n \n-    pub fn with_self_ty(&self, self_ty: Ty) -> Substs {\n+    pub fn with_self_ty(&self, self_ty: Ty<'tcx>) -> Substs<'tcx> {\n         assert!(self.self_ty().is_none());\n         let mut s = (*self).clone();\n         s.types.push(SelfSpace, self_ty);\n         s\n     }\n \n-    pub fn erase_regions(self) -> Substs {\n+    pub fn erase_regions(self) -> Substs<'tcx> {\n         let Substs { types, regions: _ } = self;\n         Substs { types: types, regions: ErasedRegions }\n     }\n@@ -154,9 +154,9 @@ impl Substs {\n     }\n \n     pub fn with_method(self,\n-                       m_types: Vec<Ty>,\n+                       m_types: Vec<Ty<'tcx>>,\n                        m_regions: Vec<ty::Region>)\n-                       -> Substs\n+                       -> Substs<'tcx>\n     {\n         let Substs { types, regions } = self;\n         let types = types.with_vec(FnSpace, m_types);\n@@ -536,21 +536,21 @@ impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n // `foo`. Or use `foo.subst_spanned(tcx, substs, Some(span))` when\n // there is more information available (for better errors).\n \n-pub trait Subst {\n-    fn subst(&self, tcx: &ty::ctxt, substs: &Substs) -> Self {\n+pub trait Subst<'tcx> {\n+    fn subst(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(&self, tcx: &ty::ctxt,\n-                     substs: &Substs,\n+    fn subst_spanned(&self, tcx: &ty::ctxt<'tcx>,\n+                     substs: &Substs<'tcx>,\n                      span: Option<Span>)\n                      -> Self;\n }\n \n-impl<T:TypeFoldable> Subst for T {\n+impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n     fn subst_spanned(&self,\n-                     tcx: &ty::ctxt,\n-                     substs: &Substs,\n+                     tcx: &ty::ctxt<'tcx>,\n+                     substs: &Substs<'tcx>,\n                      span: Option<Span>)\n                      -> T\n     {\n@@ -569,13 +569,13 @@ impl<T:TypeFoldable> Subst for T {\n \n struct SubstFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    substs: &'a Substs,\n+    substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n     span: Option<Span>,\n \n     // The root type that is being substituted, if available.\n-    root_ty: Option<Ty>,\n+    root_ty: Option<Ty<'tcx>>,\n \n     // Depth of type stack\n     ty_stack_depth: uint,\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty::type_needs_subst(t) {\n             return t;\n         }\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n }\n \n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n-    fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty) -> Ty {\n+    fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n         let ty = match opt_ty {\n@@ -684,7 +684,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n         self.shift_regions_through_binders(ty)\n     }\n \n-    fn shift_regions_through_binders(&self, ty: Ty) -> Ty {\n+    fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         /*!\n          * It is sometimes necessary to adjust the debruijn indices\n          * during substitution. This occurs when we are substituting a"}, {"sha": "ebd7c68877347f2748218e0fc7bb663cc6cc8e9a", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -76,7 +76,7 @@ pub fn impl_is_local(tcx: &ty::ctxt,\n     trait_ref.input_types().iter().any(|&t| ty_is_local(tcx, t))\n }\n \n-pub fn ty_is_local(tcx: &ty::ctxt, ty: Ty) -> bool {\n+pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n     match ty::get(ty).sty {"}, {"sha": "5b8edacb28d67e775484c55fcc2aeda262011132", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -31,39 +31,39 @@ use super::select::SelectionContext;\n  * method `select_all_or_error` can be used to report any remaining\n  * ambiguous cases as errors.\n  */\n-pub struct FulfillmentContext {\n+pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    trait_obligations: Vec<Obligation>,\n+    trait_obligations: Vec<Obligation<'tcx>>,\n \n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n     attempted_mark: uint,\n }\n \n-impl FulfillmentContext {\n-    pub fn new() -> FulfillmentContext {\n+impl<'tcx> FulfillmentContext<'tcx> {\n+    pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             trait_obligations: Vec::new(),\n             attempted_mark: 0,\n         }\n     }\n \n     pub fn register_obligation(&mut self,\n-                               tcx: &ty::ctxt,\n-                               obligation: Obligation)\n+                               tcx: &ty::ctxt<'tcx>,\n+                               obligation: Obligation<'tcx>)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n         assert!(!obligation.trait_ref.has_escaping_regions());\n         self.trait_obligations.push(obligation);\n     }\n \n-    pub fn select_all_or_error<'a,'tcx>(&mut self,\n-                                        infcx: &InferCtxt<'a,'tcx>,\n-                                        param_env: &ty::ParameterEnvironment,\n-                                        typer: &Typer<'tcx>)\n-                                        -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_all_or_error<'a>(&mut self,\n+                                   infcx: &InferCtxt<'a,'tcx>,\n+                                   param_env: &ty::ParameterEnvironment<'tcx>,\n+                                   typer: &Typer<'tcx>)\n+                                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx, param_env, typer));\n \n@@ -81,11 +81,11 @@ impl FulfillmentContext {\n         }\n     }\n \n-    pub fn select_new_obligations<'a,'tcx>(&mut self,\n-                                           infcx: &InferCtxt<'a,'tcx>,\n-                                           param_env: &ty::ParameterEnvironment,\n-                                           typer: &Typer<'tcx>)\n-                                           -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_new_obligations<'a>(&mut self,\n+                                      infcx: &InferCtxt<'a,'tcx>,\n+                                      param_env: &ty::ParameterEnvironment<'tcx>,\n+                                      typer: &Typer<'tcx>)\n+                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         /*!\n          * Attempts to select obligations that were registered since\n@@ -99,20 +99,20 @@ impl FulfillmentContext {\n         self.select(&mut selcx, true)\n     }\n \n-    pub fn select_where_possible<'a,'tcx>(&mut self,\n-                                          infcx: &InferCtxt<'a,'tcx>,\n-                                          param_env: &ty::ParameterEnvironment,\n-                                          typer: &Typer<'tcx>)\n-                                          -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_where_possible<'a>(&mut self,\n+                                     infcx: &InferCtxt<'a,'tcx>,\n+                                     param_env: &ty::ParameterEnvironment<'tcx>,\n+                                     typer: &Typer<'tcx>)\n+                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx, param_env, typer);\n         self.select(&mut selcx, false)\n     }\n \n-    fn select(&mut self,\n-              selcx: &mut SelectionContext,\n-              only_new_obligations: bool)\n-              -> Result<(),Vec<FulfillmentError>>\n+    fn select<'a>(&mut self,\n+                  selcx: &mut SelectionContext<'a, 'tcx>,\n+                  only_new_obligations: bool)\n+                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         /*!\n          * Attempts to select obligations using `selcx`. If"}, {"sha": "c5eacf35da92fd6e09bed8d9b46d2836fe8f25d4", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 60, "deletions": 56, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -50,23 +50,23 @@ mod util;\n  * scope. The eventual result is usually a `Selection` (defined below).\n  */\n #[deriving(Clone)]\n-pub struct Obligation {\n-    pub cause: ObligationCause,\n+pub struct Obligation<'tcx> {\n+    pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n }\n \n /**\n  * Why did we incur this obligation? Used for error reporting.\n  */\n #[deriving(Clone)]\n-pub struct ObligationCause {\n+pub struct ObligationCause<'tcx> {\n     pub span: Span,\n-    pub code: ObligationCauseCode\n+    pub code: ObligationCauseCode<'tcx>\n }\n \n #[deriving(Clone)]\n-pub enum ObligationCauseCode {\n+pub enum ObligationCauseCode<'tcx> {\n     /// Not well classified or should be obvious from span.\n     MiscObligation,\n \n@@ -75,7 +75,7 @@ pub enum ObligationCauseCode {\n     ItemObligation(ast::DefId),\n \n     /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty),\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n \n     /// To implement drop, type must be sendable.\n     DropTrait,\n@@ -99,25 +99,25 @@ pub enum ObligationCauseCode {\n #[deriving(Clone,Show)]\n pub struct ErrorReported;\n \n-pub type Obligations = subst::VecPerParamSpace<Obligation>;\n+pub type Obligations<'tcx> = subst::VecPerParamSpace<Obligation<'tcx>>;\n \n-pub type Selection = Vtable<Obligation>;\n+pub type Selection<'tcx> = Vtable<'tcx, Obligation<'tcx>>;\n \n #[deriving(Clone,Show)]\n-pub enum SelectionError {\n+pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef>, ty::type_err)\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>)\n }\n \n-pub struct FulfillmentError {\n-    pub obligation: Obligation,\n-    pub code: FulfillmentErrorCode\n+pub struct FulfillmentError<'tcx> {\n+    pub obligation: Obligation<'tcx>,\n+    pub code: FulfillmentErrorCode<'tcx>\n }\n \n #[deriving(Clone)]\n-pub enum FulfillmentErrorCode {\n-    CodeSelectionError(SelectionError),\n+pub enum FulfillmentErrorCode<'tcx> {\n+    CodeSelectionError(SelectionError<'tcx>),\n     CodeAmbiguity,\n }\n \n@@ -130,7 +130,7 @@ pub enum FulfillmentErrorCode {\n  *   to inconclusive type inference.\n  * - `Err(e)`: error `e` occurred\n  */\n-pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n \n /**\n  * Given the successful resolution of an obligation, the `Vtable`\n@@ -173,19 +173,19 @@ pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n  * See explanation on `VtableImplData`.\n  */\n #[deriving(Show,Clone)]\n-pub enum Vtable<N> {\n+pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<N>),\n+    VtableImpl(VtableImplData<'tcx, N>),\n \n     /// Vtable automatically generated for an unboxed closure. The def\n     /// ID is the ID of the closure expression. This is a `VtableImpl`\n     /// in spirit, but the impl is generated by the compiler and does\n     /// not appear in the source.\n-    VtableUnboxedClosure(ast::DefId, subst::Substs),\n+    VtableUnboxedClosure(ast::DefId, subst::Substs<'tcx>),\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParamData),\n+    VtableParam(VtableParamData<'tcx>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -204,9 +204,9 @@ pub enum Vtable<N> {\n  * impl, and nested obligations are satisfied later.\n  */\n #[deriving(Clone)]\n-pub struct VtableImplData<N> {\n+pub struct VtableImplData<'tcx, N> {\n     pub impl_def_id: ast::DefId,\n-    pub substs: subst::Substs,\n+    pub substs: subst::Substs<'tcx>,\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n@@ -221,18 +221,19 @@ pub struct VtableBuiltinData<N> {\n  * on an instance of `T`, the vtable would be of type `VtableParam`.\n  */\n #[deriving(PartialEq,Eq,Clone)]\n-pub struct VtableParamData {\n+pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`\n-    pub bound: Rc<ty::TraitRef>,\n+    pub bound: Rc<ty::TraitRef<'tcx>>,\n }\n \n pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                     param_env: &ty::ParameterEnvironment,\n+                                     param_env: &ty::ParameterEnvironment<'tcx>,\n                                      typer: &Typer<'tcx>,\n-                                     cause: ObligationCause,\n+                                     cause: ObligationCause<'tcx>,\n                                      impl_def_id: ast::DefId,\n-                                     self_ty: Ty)\n-                                     -> SelectionResult<VtableImplData<Obligation>>\n+                                     self_ty: Ty<'tcx>)\n+                                     -> SelectionResult<'tcx,\n+                                            VtableImplData<'tcx, Obligation<'tcx>>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -281,11 +282,11 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-pub fn obligations_for_generics(tcx: &ty::ctxt,\n-                                cause: ObligationCause,\n-                                generic_bounds: &ty::GenericBounds,\n-                                type_substs: &subst::VecPerParamSpace<Ty>)\n-                                -> subst::VecPerParamSpace<Obligation>\n+pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      generic_bounds: &ty::GenericBounds<'tcx>,\n+                                      type_substs: &subst::VecPerParamSpace<Ty<'tcx>>)\n+                                      -> subst::VecPerParamSpace<Obligation<'tcx>>\n {\n     /*!\n      * Given generic bounds from an impl like:\n@@ -305,46 +306,48 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n     util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n }\n \n-pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,\n-                                    cause: ObligationCause,\n-                                    source_ty: Ty,\n-                                    builtin_bound: ty::BuiltinBound)\n-                                    -> Result<Obligation, ErrorReported>\n+pub fn obligation_for_builtin_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          cause: ObligationCause<'tcx>,\n+                                          source_ty: Ty<'tcx>,\n+                                          builtin_bound: ty::BuiltinBound)\n+                                          -> Result<Obligation<'tcx>, ErrorReported>\n {\n     util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n }\n \n-impl Obligation {\n-    pub fn new(cause: ObligationCause, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+impl<'tcx> Obligation<'tcx> {\n+    pub fn new(cause: ObligationCause<'tcx>, trait_ref: Rc<ty::TraitRef<'tcx>>)\n+               -> Obligation<'tcx> {\n         Obligation { cause: cause,\n                      recursion_depth: 0,\n                      trait_ref: trait_ref }\n     }\n \n-    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef<'tcx>>) -> Obligation<'tcx> {\n         Obligation::new(ObligationCause::misc(span), trait_ref)\n     }\n \n-    pub fn self_ty(&self) -> Ty {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }\n }\n \n-impl ObligationCause {\n-    pub fn new(span: Span, code: ObligationCauseCode) -> ObligationCause {\n+impl<'tcx> ObligationCause<'tcx> {\n+    pub fn new(span: Span, code: ObligationCauseCode<'tcx>)\n+               -> ObligationCause<'tcx> {\n         ObligationCause { span: span, code: code }\n     }\n \n-    pub fn misc(span: Span) -> ObligationCause {\n+    pub fn misc(span: Span) -> ObligationCause<'tcx> {\n         ObligationCause { span: span, code: MiscObligation }\n     }\n \n-    pub fn dummy() -> ObligationCause {\n+    pub fn dummy() -> ObligationCause<'tcx> {\n         ObligationCause { span: DUMMY_SP, code: MiscObligation }\n     }\n }\n \n-impl<N> Vtable<N> {\n+impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn iter_nested(&self) -> Items<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n@@ -354,7 +357,7 @@ impl<N> Vtable<N> {\n         }\n     }\n \n-    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {\n+    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<'tcx, M> {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n             VtableUnboxedClosure(d, ref s) => VtableUnboxedClosure(d, s.clone()),\n@@ -363,7 +366,7 @@ impl<N> Vtable<N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<M> {\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<'tcx, M> {\n         match self {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableUnboxedClosure(d, s) => VtableUnboxedClosure(d, s),\n@@ -373,14 +376,14 @@ impl<N> Vtable<N> {\n     }\n }\n \n-impl<N> VtableImplData<N> {\n+impl<'tcx, N> VtableImplData<'tcx, N> {\n     pub fn iter_nested(&self) -> Items<N> {\n         self.nested.iter()\n     }\n \n     pub fn map_nested<M>(&self,\n                          op: |&N| -> M)\n-                         -> VtableImplData<M>\n+                         -> VtableImplData<'tcx, M>\n     {\n         VtableImplData {\n             impl_def_id: self.impl_def_id,\n@@ -389,7 +392,8 @@ impl<N> VtableImplData<N> {\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImplData<M> {\n+    pub fn map_move_nested<M>(self, op: |N| -> M)\n+                              -> VtableImplData<'tcx, M> {\n         let VtableImplData { impl_def_id, substs, nested } = self;\n         VtableImplData {\n             impl_def_id: impl_def_id,\n@@ -420,9 +424,9 @@ impl<N> VtableBuiltinData<N> {\n     }\n }\n \n-impl FulfillmentError {\n-    fn new(obligation: Obligation, code: FulfillmentErrorCode)\n-           -> FulfillmentError\n+impl<'tcx> FulfillmentError<'tcx> {\n+    fn new(obligation: Obligation<'tcx>, code: FulfillmentErrorCode<'tcx>)\n+           -> FulfillmentError<'tcx>\n     {\n         FulfillmentError { obligation: obligation, code: code }\n     }"}, {"sha": "217830bcb4e63b22dbaafc39a9374632fff5872a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 159, "deletions": 154, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -42,7 +42,7 @@ use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    param_env: &'cx ty::ParameterEnvironment,\n+    param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     typer: &'cx Typer<'tcx>+'cx,\n \n     /// Skolemizer used specifically for skolemizing entries on the\n@@ -70,18 +70,19 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n }\n \n // A stack that walks back up the stack frame.\n-struct ObligationStack<'prev> {\n-    obligation: &'prev Obligation,\n+struct ObligationStack<'prev, 'tcx: 'prev> {\n+    obligation: &'prev Obligation<'tcx>,\n \n     /// Trait ref from `obligation` but skolemized with the\n     /// selection-context's skolemizer. Used to check for recursion.\n-    skol_trait_ref: Rc<ty::TraitRef>,\n+    skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n-    previous: Option<&'prev ObligationStack<'prev>>\n+    previous: Option<&'prev ObligationStack<'prev, 'tcx>>\n }\n \n-pub struct SelectionCache {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef>, SelectionResult<Candidate>>>,\n+pub struct SelectionCache<'tcx> {\n+    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+                             SelectionResult<'tcx, Candidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -128,21 +129,21 @@ pub enum MethodMatchedData {\n  * parameters) that would have to be inferred from the impl.\n  */\n #[deriving(PartialEq,Eq,Show,Clone)]\n-enum Candidate {\n+enum Candidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n-    ParamCandidate(VtableParamData),\n+    ParamCandidate(VtableParamData<'tcx>),\n     ImplCandidate(ast::DefId),\n-    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs),\n+    UnboxedClosureCandidate(/* closure */ ast::DefId, Substs<'tcx>),\n     ErrorCandidate,\n }\n \n-struct CandidateSet {\n-    vec: Vec<Candidate>,\n+struct CandidateSet<'tcx> {\n+    vec: Vec<Candidate<'tcx>>,\n     ambiguous: bool\n }\n \n-enum BuiltinBoundConditions {\n-    If(Vec<Ty>),\n+enum BuiltinBoundConditions<'tcx> {\n+    If(Vec<Ty<'tcx>>),\n     ParameterBuiltin,\n     AmbiguousBuiltin\n }\n@@ -156,7 +157,7 @@ enum EvaluationResult {\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-               param_env: &'cx ty::ParameterEnvironment,\n+               param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                typer: &'cx Typer<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -169,7 +170,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>,\n-                      param_env: &'cx ty::ParameterEnvironment,\n+                      param_env: &'cx ty::ParameterEnvironment<'tcx>,\n                       typer: &'cx Typer<'tcx>)\n                       -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -200,7 +201,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    pub fn select(&mut self, obligation: &Obligation) -> SelectionResult<Selection> {\n+    pub fn select(&mut self, obligation: &Obligation<'tcx>)\n+                  -> SelectionResult<'tcx, Selection<'tcx>> {\n         /*!\n          * Evaluates whether the obligation can be satisfied. Returns\n          * an indication of whether the obligation can be satisfied\n@@ -220,9 +222,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     pub fn select_inherent_impl(&mut self,\n                                 impl_def_id: ast::DefId,\n-                                obligation_cause: ObligationCause,\n-                                obligation_self_ty: Ty)\n-                                -> SelectionResult<VtableImplData<Obligation>>\n+                                obligation_cause: ObligationCause<'tcx>,\n+                                obligation_self_ty: Ty<'tcx>)\n+                                -> SelectionResult<'tcx, VtableImplData<'tcx, Obligation<'tcx>>>\n     {\n         debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n                impl_def_id.repr(self.tcx()),\n@@ -252,7 +254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // we can be sure it does not.\n \n     pub fn evaluate_obligation(&mut self,\n-                               obligation: &Obligation)\n+                               obligation: &Obligation<'tcx>)\n                                -> bool\n     {\n         /*!\n@@ -268,11 +270,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.evaluate_stack(&stack).may_apply()\n     }\n \n-    fn evaluate_builtin_bound_recursively(&mut self,\n-                                          bound: ty::BuiltinBound,\n-                                          previous_stack: &ObligationStack,\n-                                          ty: Ty)\n-                                          -> EvaluationResult\n+    fn evaluate_builtin_bound_recursively<'o>(&mut self,\n+                                              bound: ty::BuiltinBound,\n+                                              previous_stack: &ObligationStack<'o, 'tcx>,\n+                                              ty: Ty<'tcx>)\n+                                              -> EvaluationResult\n     {\n         let obligation =\n             util::obligation_for_builtin_bound(\n@@ -292,10 +294,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn evaluate_obligation_recursively(&mut self,\n-                                       previous_stack: Option<&ObligationStack>,\n-                                       obligation: &Obligation)\n-                                       -> EvaluationResult\n+    fn evaluate_obligation_recursively<'o>(&mut self,\n+                                           previous_stack: Option<&ObligationStack<'o, 'tcx>>,\n+                                           obligation: &Obligation<'tcx>)\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n@@ -308,9 +310,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    fn evaluate_stack(&mut self,\n-                      stack: &ObligationStack)\n-                      -> EvaluationResult\n+    fn evaluate_stack<'o>(&mut self,\n+                          stack: &ObligationStack<'o, 'tcx>)\n+                          -> EvaluationResult\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -387,7 +389,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n-                         obligation: &Obligation)\n+                         obligation: &Obligation<'tcx>)\n                          -> bool\n     {\n         /*!\n@@ -434,9 +436,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // the algorithm.\n \n     pub fn evaluate_method_obligation(&mut self,\n-                                      rcvr_ty: Ty,\n-                                      xform_self_ty: Ty,\n-                                      obligation: &Obligation)\n+                                      rcvr_ty: Ty<'tcx>,\n+                                      xform_self_ty: Ty<'tcx>,\n+                                      obligation: &Obligation<'tcx>)\n                                       -> MethodMatchResult\n     {\n         /*!\n@@ -562,9 +564,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn confirm_method_match(&mut self,\n-                                rcvr_ty: Ty,\n-                                xform_self_ty: Ty,\n-                                obligation: &Obligation,\n+                                rcvr_ty: Ty<'tcx>,\n+                                xform_self_ty: Ty<'tcx>,\n+                                obligation: &Obligation<'tcx>,\n                                 data: MethodMatchedData)\n     {\n         /*!\n@@ -596,9 +598,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_method_precise(&mut self,\n-                            rcvr_ty: Ty,\n-                            xform_self_ty: Ty,\n-                            obligation: &Obligation)\n+                            rcvr_ty: Ty<'tcx>,\n+                            xform_self_ty: Ty<'tcx>,\n+                            obligation: &Obligation<'tcx>)\n                             -> Result<(),()>\n     {\n         /*!\n@@ -622,9 +624,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_method_candidates_from_impls(&mut self,\n-                                             rcvr_ty: Ty,\n-                                             xform_self_ty: Ty,\n-                                             obligation: &Obligation)\n+                                             rcvr_ty: Ty<'tcx>,\n+                                             xform_self_ty: Ty<'tcx>,\n+                                             obligation: &Obligation<'tcx>)\n                                              -> Vec<ast::DefId>\n     {\n         /*!\n@@ -650,10 +652,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_method_coerce(&mut self,\n                            impl_def_id: ast::DefId,\n-                           rcvr_ty: Ty,\n-                           xform_self_ty: Ty,\n-                           obligation: &Obligation)\n-                           -> Result<Substs, ()>\n+                           rcvr_ty: Ty<'tcx>,\n+                           xform_self_ty: Ty<'tcx>,\n+                           obligation: &Obligation<'tcx>)\n+                           -> Result<Substs<'tcx>, ()>\n     {\n         /*!\n          * Applies the *coercive match* procedure described in\n@@ -683,9 +685,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn winnow_method_impl(&mut self,\n                           impl_def_id: ast::DefId,\n-                          rcvr_ty: Ty,\n-                          xform_self_ty: Ty,\n-                          obligation: &Obligation)\n+                          rcvr_ty: Ty<'tcx>,\n+                          xform_self_ty: Ty<'tcx>,\n+                          obligation: &Obligation<'tcx>)\n                           -> bool\n     {\n         /*!\n@@ -724,9 +726,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // caller obligations, and so forth and assembling a list of\n     // candidates. See `doc.rs` and the `Candidate` type for more details.\n \n-    fn candidate_from_obligation(&mut self,\n-                                 stack: &ObligationStack)\n-                                 -> SelectionResult<Candidate>\n+    fn candidate_from_obligation<'o>(&mut self,\n+                                     stack: &ObligationStack<'o, 'tcx>)\n+                                     -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n@@ -767,9 +769,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n-    fn candidate_from_obligation_no_cache(&mut self,\n-                                          stack: &ObligationStack)\n-                                          -> SelectionResult<Candidate>\n+    fn candidate_from_obligation_no_cache<'o>(&mut self,\n+                                              stack: &ObligationStack<'o, 'tcx>)\n+                                              -> SelectionResult<'tcx, Candidate<'tcx>>\n     {\n         if ty::type_is_error(stack.obligation.self_ty()) {\n             return Ok(Some(ErrorCandidate));\n@@ -863,8 +865,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_skol_trait_ref: &Rc<ty::TraitRef>)\n-                            -> &SelectionCache\n+                            cache_skol_trait_ref: &Rc<ty::TraitRef<'tcx>>)\n+                            -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n         // cache that is specific to this scope, or to consult the\n@@ -910,26 +912,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_skol_trait_ref: Rc<ty::TraitRef>)\n-                             -> Option<SelectionResult<Candidate>>\n+                             cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                             -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n         hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_skol_trait_ref: Rc<ty::TraitRef>,\n-                              candidate: SelectionResult<Candidate>)\n+                              cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                              candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let mut hashmap = cache.hashmap.borrow_mut();\n         hashmap.insert(cache_skol_trait_ref, candidate);\n     }\n \n-    fn assemble_candidates(&mut self,\n-                           stack: &ObligationStack)\n-                           -> Result<CandidateSet, SelectionError>\n+    fn assemble_candidates<'o>(&mut self,\n+                               stack: &ObligationStack<'o, 'tcx>)\n+                               -> Result<CandidateSet<'tcx>, SelectionError<'tcx>>\n     {\n         // Check for overflow.\n \n@@ -961,9 +963,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_caller_bounds(&mut self,\n-                                              obligation: &Obligation,\n-                                              candidates: &mut CandidateSet)\n-                                              -> Result<(),SelectionError>\n+                                              obligation: &Obligation<'tcx>,\n+                                              candidates: &mut CandidateSet<'tcx>)\n+                                              -> Result<(),SelectionError<'tcx>>\n     {\n         /*!\n          * Given an obligation like `<SomeTrait for T>`, search the obligations\n@@ -1001,9 +1003,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_unboxed_candidates(&mut self,\n-                                   obligation: &Obligation,\n-                                   candidates: &mut CandidateSet)\n-                                   -> Result<(),SelectionError>\n+                                   obligation: &Obligation<'tcx>,\n+                                   candidates: &mut CandidateSet<'tcx>)\n+                                   -> Result<(),SelectionError<'tcx>>\n     {\n         /*!\n          * Check for the artificial impl that the compiler will create\n@@ -1059,9 +1061,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn assemble_candidates_from_impls(&mut self,\n-                                      obligation: &Obligation,\n-                                      candidates: &mut CandidateSet)\n-                                      -> Result<(), SelectionError>\n+                                      obligation: &Obligation<'tcx>,\n+                                      candidates: &mut CandidateSet<'tcx>)\n+                                      -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * Search for impls that might apply to `obligation`.\n@@ -1090,10 +1092,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // attempt to evaluate recursive bounds to see if they are\n     // satisfied.\n \n-    fn winnow_candidate(&mut self,\n-                        stack: &ObligationStack,\n-                        candidate: &Candidate)\n-                        -> EvaluationResult\n+    fn winnow_candidate<'o>(&mut self,\n+                            stack: &ObligationStack<'o, 'tcx>,\n+                            candidate: &Candidate<'tcx>)\n+                            -> EvaluationResult\n     {\n         /*!\n          * Further evaluate `candidate` to decide whether all type parameters match\n@@ -1111,10 +1113,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n-    fn winnow_selection(&mut self,\n-                        stack: Option<&ObligationStack>,\n-                        selection: Selection)\n-                        -> EvaluationResult\n+    fn winnow_selection<'o>(&mut self,\n+                            stack: Option<&ObligationStack<'o, 'tcx>>,\n+                            selection: Selection<'tcx>)\n+                            -> EvaluationResult\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in selection.iter_nested() {\n@@ -1127,11 +1129,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    fn candidate_should_be_dropped_in_favor_of(&mut self,\n-                                               stack: &ObligationStack,\n-                                               candidate_i: &Candidate,\n-                                               candidate_j: &Candidate)\n-                                               -> bool\n+    fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n+                                                   stack: &ObligationStack<'o, 'tcx>,\n+                                                   candidate_i: &Candidate<'tcx>,\n+                                                   candidate_j: &Candidate<'tcx>)\n+                                                   -> bool\n     {\n         /*!\n          * Returns true if `candidate_i` should be dropped in favor of `candidate_j`.\n@@ -1194,11 +1196,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // those will hopefully change to library-defined traits in the\n     // future.\n \n-    fn assemble_builtin_bound_candidates(&mut self,\n-                                         bound: ty::BuiltinBound,\n-                                         stack: &ObligationStack,\n-                                         candidates: &mut CandidateSet)\n-                                         -> Result<(),SelectionError>\n+    fn assemble_builtin_bound_candidates<'o>(&mut self,\n+                                             bound: ty::BuiltinBound,\n+                                             stack: &ObligationStack<'o, 'tcx>,\n+                                             candidates: &mut CandidateSet<'tcx>)\n+                                             -> Result<(),SelectionError<'tcx>>\n     {\n         // FIXME -- To be more like a normal impl, we should just\n         // ignore the nested cases here, and instead generate nested\n@@ -1227,8 +1229,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn builtin_bound(&mut self,\n                      bound: ty::BuiltinBound,\n-                     self_ty: Ty)\n-                     -> Result<BuiltinBoundConditions,SelectionError>\n+                     self_ty: Ty<'tcx>)\n+                     -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n         let self_ty = self.infcx.shallow_resolve(self_ty);\n         return match ty::get(self_ty).sty {\n@@ -1505,11 +1507,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        fn nominal(this: &mut SelectionContext,\n-                   bound: ty::BuiltinBound,\n-                   def_id: ast::DefId,\n-                   types: Vec<Ty>)\n-                   -> Result<BuiltinBoundConditions,SelectionError>\n+        fn nominal<'cx, 'tcx>(this: &mut SelectionContext<'cx, 'tcx>,\n+                              bound: ty::BuiltinBound,\n+                              def_id: ast::DefId,\n+                              types: Vec<Ty<'tcx>>)\n+                              -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n         {\n             // First check for markers and other nonsense.\n             let tcx = this.tcx();\n@@ -1564,9 +1566,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // type error.  See `doc.rs` for more details.\n \n     fn confirm_candidate(&mut self,\n-                         obligation: &Obligation,\n-                         candidate: Candidate)\n-                         -> Result<Selection,SelectionError>\n+                         obligation: &Obligation<'tcx>,\n+                         candidate: Candidate<'tcx>)\n+                         -> Result<Selection<'tcx>,SelectionError<'tcx>>\n     {\n         debug!(\"confirm_candidate({}, {})\",\n                obligation.repr(self.tcx()),\n@@ -1598,9 +1600,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_param_candidate(&mut self,\n-                               obligation: &Obligation,\n-                               param: VtableParamData)\n-                               -> Result<VtableParamData,SelectionError>\n+                               obligation: &Obligation<'tcx>,\n+                               param: VtableParamData<'tcx>)\n+                               -> Result<VtableParamData<'tcx>,\n+                                         SelectionError<'tcx>>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1613,9 +1616,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_builtin_candidate(&mut self,\n-                                 obligation: &Obligation,\n+                                 obligation: &Obligation<'tcx>,\n                                  bound: ty::BuiltinBound)\n-                                 -> Result<VtableBuiltinData<Obligation>,SelectionError>\n+                                 -> Result<VtableBuiltinData<Obligation<'tcx>>,\n+                                           SelectionError<'tcx>>\n     {\n         debug!(\"confirm_builtin_candidate({})\",\n                obligation.repr(self.tcx()));\n@@ -1633,10 +1637,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn vtable_builtin_data(&mut self,\n-                           obligation: &Obligation,\n+                           obligation: &Obligation<'tcx>,\n                            bound: ty::BuiltinBound,\n-                           nested: Vec<Ty>)\n-                           -> VtableBuiltinData<Obligation>\n+                           nested: Vec<Ty<'tcx>>)\n+                           -> VtableBuiltinData<Obligation<'tcx>>\n     {\n         let obligations = nested.iter().map(|&t| {\n             util::obligation_for_builtin_bound(\n@@ -1656,9 +1660,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_impl_candidate(&mut self,\n-                              obligation: &Obligation,\n+                              obligation: &Obligation<'tcx>,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImplData<Obligation>,SelectionError>\n+                              -> Result<VtableImplData<'tcx, Obligation<'tcx>>,\n+                                        SelectionError<'tcx>>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -1672,10 +1677,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: ast::DefId,\n-                   substs: Substs,\n-                   cause: ObligationCause,\n+                   substs: Substs<'tcx>,\n+                   cause: ObligationCause<'tcx>,\n                    recursion_depth: uint)\n-                   -> VtableImplData<Obligation>\n+                   -> VtableImplData<'tcx, Obligation<'tcx>>\n     {\n         let impl_obligations =\n             self.impl_obligations(cause,\n@@ -1688,10 +1693,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_unboxed_closure_candidate(&mut self,\n-                                         obligation: &Obligation,\n+                                         obligation: &Obligation<'tcx>,\n                                          closure_def_id: ast::DefId,\n-                                         substs: &Substs)\n-                                         -> Result<(),SelectionError>\n+                                         substs: &Substs<'tcx>)\n+                                         -> Result<(),SelectionError<'tcx>>\n     {\n         debug!(\"confirm_unboxed_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n@@ -1739,8 +1744,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn rematch_impl(&mut self,\n                     impl_def_id: ast::DefId,\n-                    obligation: &Obligation)\n-                    -> Substs\n+                    obligation: &Obligation<'tcx>)\n+                    -> Substs<'tcx>\n     {\n         match self.match_impl(impl_def_id, obligation) {\n             Ok(substs) => {\n@@ -1758,8 +1763,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_impl(&mut self,\n                   impl_def_id: ast::DefId,\n-                  obligation: &Obligation)\n-                  -> Result<Substs, ()>\n+                  obligation: &Obligation<'tcx>)\n+                  -> Result<Substs<'tcx>, ()>\n     {\n         let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n                                                 impl_def_id).unwrap();\n@@ -1808,8 +1813,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn match_trait_refs(&mut self,\n-                        obligation: &Obligation,\n-                        trait_ref: Rc<ty::TraitRef>)\n+                        obligation: &Obligation<'tcx>,\n+                        trait_ref: Rc<ty::TraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n         debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n@@ -1829,8 +1834,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n-                           obligation_self_ty: Ty)\n-                           -> Result<Substs,()>\n+                           obligation_self_ty: Ty<'tcx>)\n+                           -> Result<Substs<'tcx>,()>\n     {\n         /*!\n          * Determines whether the self type declared against\n@@ -1878,10 +1883,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         cause: ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n-                        provided_self_ty: Ty,\n+                        provided_self_ty: Ty<'tcx>,\n \n                         // The self type the obligation is for:\n-                        required_self_ty: Ty)\n+                        required_self_ty: Ty<'tcx>)\n                         -> Result<(),()>\n     {\n         // FIXME(#5781) -- equating the types is stronger than\n@@ -1908,10 +1913,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm_impl_vtable(&mut self,\n                            impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause,\n-                           obligation_trait_ref: Rc<ty::TraitRef>,\n-                           substs: &Substs)\n-                           -> Result<(), SelectionError>\n+                           obligation_cause: ObligationCause<'tcx>,\n+                           obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           substs: &Substs<'tcx>)\n+                           -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * Relates the output type parameters from an impl to the\n@@ -1938,9 +1943,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn confirm(&mut self,\n                obligation_cause: ObligationCause,\n-               obligation_trait_ref: Rc<ty::TraitRef>,\n-               expected_trait_ref: Rc<ty::TraitRef>)\n-               -> Result<(), SelectionError>\n+               obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+               expected_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+               -> Result<(), SelectionError<'tcx>>\n     {\n         /*!\n          * After we have determined which impl applies, and with what\n@@ -1984,9 +1989,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Miscellany\n \n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s ObligationStack<'s>>,\n-                            obligation: &'o Obligation)\n-                            -> ObligationStack<'o>\n+                            previous_stack: Option<&'s ObligationStack<'s, 'tcx>>,\n+                            obligation: &'o Obligation<'tcx>)\n+                            -> ObligationStack<'o, 'tcx>\n     {\n         let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n \n@@ -2011,11 +2016,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn impl_obligations(&self,\n-                        cause: ObligationCause,\n+                        cause: ObligationCause<'tcx>,\n                         recursion_depth: uint,\n                         impl_def_id: ast::DefId,\n-                        impl_substs: &Substs)\n-                        -> VecPerParamSpace<Obligation>\n+                        impl_substs: &Substs<'tcx>)\n+                        -> VecPerParamSpace<Obligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n@@ -2024,8 +2029,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({})\", b),\n@@ -2038,22 +2043,22 @@ impl Repr for Candidate {\n     }\n }\n \n-impl SelectionCache {\n-    pub fn new() -> SelectionCache {\n+impl<'tcx> SelectionCache<'tcx> {\n+    pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n             hashmap: RefCell::new(HashMap::new())\n         }\n     }\n }\n \n-impl<'o> ObligationStack<'o> {\n-    fn iter(&self) -> Option<&ObligationStack> {\n+impl<'o, 'tcx> ObligationStack<'o, 'tcx> {\n+    fn iter(&self) -> Option<&ObligationStack<'o, 'tcx>> {\n         Some(self)\n     }\n }\n \n-impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n-    fn next(&mut self) -> Option<&'o ObligationStack<'o>> {\n+impl<'o, 'tcx> Iterator<&'o ObligationStack<'o, 'tcx>> for Option<&'o ObligationStack<'o, 'tcx>> {\n+    fn next(&mut self) -> Option<&'o ObligationStack<'o, 'tcx>> {\n         match *self {\n             Some(o) => {\n                 *self = o.previous;\n@@ -2066,8 +2071,8 @@ impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n     }\n }\n \n-impl<'o> Repr for ObligationStack<'o> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'o, 'tcx> Repr<'tcx> for ObligationStack<'o, 'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"ObligationStack({})\",\n                 self.obligation.repr(tcx))\n     }"}, {"sha": "dfd436bdc4d306458f0b49869612690b66b6232f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -28,17 +28,17 @@ use super::{ErrorReported, Obligation, ObligationCause, VtableImpl,\n \n pub struct Supertraits<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<SupertraitEntry>,\n-    visited: HashSet<Rc<ty::TraitRef>>,\n+    stack: Vec<SupertraitEntry<'tcx>>,\n+    visited: HashSet<Rc<ty::TraitRef<'tcx>>>,\n }\n \n-struct SupertraitEntry {\n+struct SupertraitEntry<'tcx> {\n     position: uint,\n-    supertraits: Vec<Rc<ty::TraitRef>>,\n+    supertraits: Vec<Rc<ty::TraitRef<'tcx>>>,\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef>)\n+                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     /*!\n@@ -61,7 +61,7 @@ pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef>])\n+                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n@@ -76,7 +76,7 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n }\n \n impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n-    fn push(&mut self, trait_ref: &ty::TraitRef) {\n+    fn push(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n         let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n             ty::bounds_for_trait_ref(self.tcx, trait_ref);\n         for builtin_bound in builtin_bounds.iter() {\n@@ -106,8 +106,8 @@ impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n             let next_trait = match self.stack.last_mut() {\n@@ -148,34 +148,34 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n-                             span: Span,\n-                             impl_def_id: ast::DefId)\n-                             -> Substs\n+pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       span: Span,\n+                                       impl_def_id: ast::DefId)\n+                                       -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<N> fmt::Show for VtableImplData<N> {\n+impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({})\", self.impl_def_id)\n     }\n }\n \n-impl fmt::Show for VtableParamData {\n+impl<'tcx> fmt::Show for VtableParamData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableParam(...)\")\n     }\n }\n \n-pub fn obligations_for_generics(tcx: &ty::ctxt,\n-                                cause: ObligationCause,\n-                                recursion_depth: uint,\n-                                generic_bounds: &ty::GenericBounds,\n-                                type_substs: &VecPerParamSpace<Ty>)\n-                                -> VecPerParamSpace<Obligation>\n+pub fn obligations_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      recursion_depth: uint,\n+                                      generic_bounds: &ty::GenericBounds<'tcx>,\n+                                      type_substs: &VecPerParamSpace<Ty<'tcx>>)\n+                                      -> VecPerParamSpace<Obligation<'tcx>>\n {\n     /*! See `super::obligations_for_generics` */\n \n@@ -200,15 +200,15 @@ pub fn obligations_for_generics(tcx: &ty::ctxt,\n     return obligations;\n }\n \n-fn push_obligations_for_param_bounds(\n-    tcx: &ty::ctxt,\n-    cause: ObligationCause,\n+fn push_obligations_for_param_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    cause: ObligationCause<'tcx>,\n     recursion_depth: uint,\n     space: subst::ParamSpace,\n     index: uint,\n-    param_bounds: &ty::ParamBounds,\n-    param_type_substs: &VecPerParamSpace<Ty>,\n-    obligations: &mut VecPerParamSpace<Obligation>)\n+    param_bounds: &ty::ParamBounds<'tcx>,\n+    param_type_substs: &VecPerParamSpace<Ty<'tcx>>,\n+    obligations: &mut VecPerParamSpace<Obligation<'tcx>>)\n {\n     let param_ty = *param_type_substs.get(space, index);\n     for builtin_bound in param_bounds.builtin_bounds.iter() {\n@@ -232,11 +232,11 @@ fn push_obligations_for_param_bounds(\n     }\n }\n \n-pub fn trait_ref_for_builtin_bound(\n-    tcx: &ty::ctxt,\n+pub fn trait_ref_for_builtin_bound<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n-    param_ty: Ty)\n-    -> Option<Rc<ty::TraitRef>>\n+    param_ty: Ty<'tcx>)\n+    -> Option<Rc<ty::TraitRef<'tcx>>>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n@@ -252,13 +252,13 @@ pub fn trait_ref_for_builtin_bound(\n     }\n }\n \n-pub fn obligation_for_builtin_bound(\n-    tcx: &ty::ctxt,\n-    cause: ObligationCause,\n+pub fn obligation_for_builtin_bound<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: uint,\n-    param_ty: Ty)\n-    -> Result<Obligation, ErrorReported>\n+    param_ty: Ty<'tcx>)\n+    -> Result<Obligation<'tcx>, ErrorReported>\n {\n     let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);\n     match trait_ref {\n@@ -271,10 +271,10 @@ pub fn obligation_for_builtin_bound(\n     }\n }\n \n-pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n-                                               caller_bound: Rc<ty::TraitRef>,\n-                                               test: |ast::DefId| -> bool)\n-                                               -> Option<VtableParamData>\n+pub fn search_trait_and_supertraits_from_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                     caller_bound: Rc<ty::TraitRef<'tcx>>,\n+                                                     test: |ast::DefId| -> bool)\n+                                                     -> Option<VtableParamData<'tcx>>\n {\n     /*!\n      * Starting from a caller obligation `caller_bound` (which has\n@@ -295,16 +295,16 @@ pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n     return None;\n }\n \n-impl Repr for super::Obligation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::Obligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Obligation(trait_ref={},depth={})\",\n                 self.trait_ref.repr(tcx),\n                 self.recursion_depth)\n     }\n }\n \n-impl<N:Repr> Repr for super::Vtable<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::VtableImpl(ref v) =>\n                 v.repr(tcx),\n@@ -323,31 +323,31 @@ impl<N:Repr> Repr for super::Vtable<N> {\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableImplData<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableImplData<'tcx, N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n                 self.impl_def_id.repr(tcx),\n                 self.substs.repr(tcx),\n                 self.nested.repr(tcx))\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableBuiltinData<N> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableBuiltin(nested={})\",\n                 self.nested.repr(tcx))\n     }\n }\n \n-impl Repr for super::VtableParamData {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::VtableParamData<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableParam(bound={})\",\n                 self.bound.repr(tcx))\n     }\n }\n \n-impl Repr for super::SelectionError {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::Overflow =>\n                 format!(\"Overflow\"),\n@@ -363,24 +363,24 @@ impl Repr for super::SelectionError {\n     }\n }\n \n-impl Repr for super::FulfillmentError {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::FulfillmentError<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"FulfillmentError({},{})\",\n                 self.obligation.repr(tcx),\n                 self.code.repr(tcx))\n     }\n }\n \n-impl Repr for super::FulfillmentErrorCode {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             super::CodeSelectionError(ref o) => o.repr(tcx),\n             super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n }\n \n-impl fmt::Show for super::FulfillmentErrorCode {\n+impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n@@ -389,8 +389,8 @@ impl fmt::Show for super::FulfillmentErrorCode {\n     }\n }\n \n-impl Repr for ty::type_err {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         ty::type_err_to_str(tcx, self)\n     }\n }"}, {"sha": "2aa50d90b09b129b40691fce2f17144957c974a0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 407, "deletions": 378, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -90,9 +90,9 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n // Data types\n \n #[deriving(PartialEq, Eq, Hash)]\n-pub struct field {\n+pub struct field<'tcx> {\n     pub name: ast::Name,\n-    pub mt: mt\n+    pub mt: mt<'tcx>\n }\n \n #[deriving(Clone, Show)]\n@@ -111,12 +111,12 @@ impl ImplOrTraitItemContainer {\n }\n \n #[deriving(Clone)]\n-pub enum ImplOrTraitItem {\n-    MethodTraitItem(Rc<Method>),\n+pub enum ImplOrTraitItem<'tcx> {\n+    MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n }\n \n-impl ImplOrTraitItem {\n+impl<'tcx> ImplOrTraitItem<'tcx> {\n     fn id(&self) -> ImplOrTraitItemId {\n         match *self {\n             MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n@@ -147,7 +147,7 @@ impl ImplOrTraitItem {\n         }\n     }\n \n-    pub fn as_opt_method(&self) -> Option<Rc<Method>> {\n+    pub fn as_opt_method(&self) -> Option<Rc<Method<'tcx>>> {\n         match *self {\n             MethodTraitItem(ref m) => Some((*m).clone()),\n             TypeTraitItem(_) => None\n@@ -171,10 +171,10 @@ impl ImplOrTraitItemId {\n }\n \n #[deriving(Clone, Show)]\n-pub struct Method {\n+pub struct Method<'tcx> {\n     pub name: ast::Name,\n-    pub generics: ty::Generics,\n-    pub fty: BareFnTy,\n+    pub generics: ty::Generics<'tcx>,\n+    pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n@@ -184,16 +184,16 @@ pub struct Method {\n     pub provided_source: Option<ast::DefId>\n }\n \n-impl Method {\n+impl<'tcx> Method<'tcx> {\n     pub fn new(name: ast::Name,\n-               generics: ty::Generics,\n-               fty: BareFnTy,\n+               generics: ty::Generics<'tcx>,\n+               fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: ast::Visibility,\n                def_id: ast::DefId,\n                container: ImplOrTraitItemContainer,\n                provided_source: Option<ast::DefId>)\n-               -> Method {\n+               -> Method<'tcx> {\n        Method {\n             name: name,\n             generics: generics,\n@@ -223,8 +223,8 @@ pub struct AssociatedType {\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct mt {\n-    pub ty: Ty,\n+pub struct mt<'tcx> {\n+    pub ty: Ty<'tcx>,\n     pub mutbl: ast::Mutability,\n }\n \n@@ -253,9 +253,9 @@ pub struct creader_cache_key {\n     pub len: uint\n }\n \n-pub enum ast_ty_to_ty_cache_entry {\n+pub enum ast_ty_to_ty_cache_entry<'tcx> {\n     atttce_unresolved,  /* not resolved yet */\n-    atttce_resolved(Ty)  /* resolved to a type, irrespective of region */\n+    atttce_resolved(Ty<'tcx>)  /* resolved to a type, irrespective of region */\n }\n \n #[deriving(Clone, PartialEq, Decodable, Encodable)]\n@@ -273,44 +273,44 @@ pub enum Variance {\n }\n \n #[deriving(Clone, Show)]\n-pub enum AutoAdjustment {\n+pub enum AutoAdjustment<'tcx> {\n     AdjustAddEnv(ty::TraitStore),\n-    AdjustDerefRef(AutoDerefRef)\n+    AdjustDerefRef(AutoDerefRef<'tcx>)\n }\n \n #[deriving(Clone, PartialEq, Show)]\n-pub enum UnsizeKind {\n+pub enum UnsizeKind<'tcx> {\n     // [T, ..n] -> [T], the uint field is n.\n     UnsizeLength(uint),\n     // An unsize coercion applied to the tail field of a struct.\n     // The uint is the index of the type parameter which is unsized.\n-    UnsizeStruct(Box<UnsizeKind>, uint),\n-    UnsizeVtable(TyTrait, /* the self type of the trait */ Ty)\n+    UnsizeStruct(Box<UnsizeKind<'tcx>>, uint),\n+    UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>)\n }\n \n #[deriving(Clone, Show)]\n-pub struct AutoDerefRef {\n+pub struct AutoDerefRef<'tcx> {\n     pub autoderefs: uint,\n-    pub autoref: Option<AutoRef>\n+    pub autoref: Option<AutoRef<'tcx>>\n }\n \n #[deriving(Clone, PartialEq, Show)]\n-pub enum AutoRef {\n+pub enum AutoRef<'tcx> {\n     /// Convert from T to &T\n     /// The third field allows us to wrap other AutoRef adjustments.\n-    AutoPtr(Region, ast::Mutability, Option<Box<AutoRef>>),\n+    AutoPtr(Region, ast::Mutability, Option<Box<AutoRef<'tcx>>>),\n \n     /// Convert [T, ..n] to [T] (or similar, depending on the kind)\n-    AutoUnsize(UnsizeKind),\n+    AutoUnsize(UnsizeKind<'tcx>),\n \n     /// Convert Box<[T, ..n]> to Box<[T]> or something similar in a Box.\n     /// With DST and Box a library type, this should be replaced by UnsizeStruct.\n-    AutoUnsizeUniq(UnsizeKind),\n+    AutoUnsizeUniq(UnsizeKind<'tcx>),\n \n     /// Convert from T to *T\n     /// Value to thin pointer\n     /// The second field allows us to wrap other AutoRef adjustments.\n-    AutoUnsafe(ast::Mutability, Option<Box<AutoRef>>),\n+    AutoUnsafe(ast::Mutability, Option<Box<AutoRef<'tcx>>>),\n }\n \n // Ugly little helper function. The first bool in the returned tuple is true if\n@@ -372,8 +372,8 @@ pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n \n // If possible, returns the type expected from the given adjustment. This is not\n // possible if the adjustment depends on the type of the adjusted expression.\n-pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<Ty> {\n-    fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<Ty> {\n+pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Option<Ty<'tcx>> {\n+    fn type_of_autoref<'tcx>(cx: &ctxt<'tcx>, autoref: &AutoRef<'tcx>) -> Option<Ty<'tcx>> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n                 &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n@@ -415,13 +415,13 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<Ty> {\n \n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n-pub struct TransmuteRestriction {\n+pub struct TransmuteRestriction<'tcx> {\n     /// The span from whence the restriction comes.\n     pub span: Span,\n     /// The type being transmuted from.\n-    pub from: Ty,\n+    pub from: Ty<'tcx>,\n     /// The type being transmuted to.\n-    pub to: Ty,\n+    pub to: Ty<'tcx>,\n     /// NodeIf of the transmute intrinsic.\n     pub id: ast::NodeId,\n }\n@@ -431,11 +431,11 @@ pub struct TransmuteRestriction {\n /// later on.\n pub struct ctxt<'tcx> {\n     /// The arena that types are allocated from.\n-    type_arena: &'tcx TypedArena<TyS>,\n+    type_arena: &'tcx TypedArena<TyS<'tcx>>,\n \n     /// Specifically use a speedy hash algorithm for this hash map, it's used\n     /// quite often.\n-    // TODO(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n+    // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n     // queried from a HashSet.\n     interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n     pub sess: Session,\n@@ -448,45 +448,45 @@ pub struct ctxt<'tcx> {\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: RefCell<NodeMap<Ty>>,\n+    pub node_types: RefCell<NodeMap<Ty<'tcx>>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub item_substs: RefCell<NodeMap<ItemSubsts>>,\n+    pub item_substs: RefCell<NodeMap<ItemSubsts<'tcx>>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DefIdMap<ImplOrTraitItem>>,\n+    pub impl_or_trait_items: RefCell<DefIdMap<ImplOrTraitItem<'tcx>>>,\n \n     /// Maps from a trait def-id to a list of the def-ids of its trait items\n     pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItemId>>>>,\n \n     /// A cache for the trait_items() routine\n-    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem>>>>,\n+    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef>>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n \n-    pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n-    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n+    pub trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n+    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n \n     /// Maps from node-id of a trait object cast (like `foo as\n     /// Box<Trait>`) to the trait reference.\n-    pub object_cast_map: typeck::ObjectCastMap,\n+    pub object_cast_map: typeck::ObjectCastMap<'tcx>,\n \n     pub map: ast_map::Map<'tcx>,\n-    pub intrinsic_defs: RefCell<DefIdMap<Ty>>,\n+    pub intrinsic_defs: RefCell<DefIdMap<Ty<'tcx>>>,\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: RefCell<DefIdMap<Polytype>>,\n-    pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty>>,\n-    pub short_names_cache: RefCell<FnvHashMap<Ty, String>>,\n-    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty, bool>>,\n-    pub tc_cache: RefCell<FnvHashMap<Ty, TypeContents>>,\n-    pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n-    pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo>>>>>,\n-    pub ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n-    pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n-    pub normalized_cache: RefCell<FnvHashMap<Ty, Ty>>,\n+    pub tcache: RefCell<DefIdMap<Polytype<'tcx>>>,\n+    pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n+    pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n+    pub needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n+    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry<'tcx>>>,\n+    pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n+    pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n+    pub adjustments: RefCell<NodeMap<AutoAdjustment<'tcx>>>,\n+    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n@@ -547,21 +547,21 @@ pub struct ctxt<'tcx> {\n     pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n \n-    pub method_map: typeck::MethodMap,\n+    pub method_map: typeck::MethodMap<'tcx>,\n \n     pub dependency_formats: RefCell<dependency_format::Dependencies>,\n \n     /// Records the type of each unboxed closure. The def ID is the ID of the\n     /// expression defining the unboxed closure.\n-    pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure>>,\n+    pub unboxed_closures: RefCell<DefIdMap<UnboxedClosure<'tcx>>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(ast::NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n     /// The types that must be asserted to be the same size for `transmute`\n     /// to be valid. We gather up these restrictions in the intrinsicck pass\n     /// and check them in trans.\n-    pub transmute_restrictions: RefCell<Vec<TransmuteRestriction>>,\n+    pub transmute_restrictions: RefCell<Vec<TransmuteRestriction<'tcx>>>,\n \n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index>,\n@@ -574,7 +574,7 @@ pub struct ctxt<'tcx> {\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache,\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n \n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n@@ -599,8 +599,8 @@ bitflags! {\n }\n \n #[deriving(Show)]\n-pub struct TyS {\n-    pub sty: sty,\n+pub struct TyS<'tcx> {\n+    pub sty: sty<'tcx>,\n     pub flags: TypeFlags,\n \n     // the maximal depth of any bound regions appearing in this type.\n@@ -613,23 +613,23 @@ impl fmt::Show for TypeFlags {\n     }\n }\n \n-impl PartialEq for TyS {\n-    fn eq(&self, other: &TyS) -> bool {\n+impl<'tcx> PartialEq for TyS<'tcx> {\n+    fn eq(&self, other: &TyS<'tcx>) -> bool {\n         (self as *const _) == (other as *const _)\n     }\n }\n-impl Eq for TyS {}\n+impl<'tcx> Eq for TyS<'tcx> {}\n \n-impl<S: Writer> Hash<S> for TyS {\n+impl<'tcx, S: Writer> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)\n     }\n }\n \n-pub type Ty<'tcx> = &'tcx TyS;\n+pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n /// An entry in the type interner.\n-struct InternedTy<'tcx> {\n+pub struct InternedTy<'tcx> {\n     ty: Ty<'tcx>\n }\n \n@@ -653,12 +653,12 @@ impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n     }\n }\n \n-pub fn get(ty: Ty) -> Ty {\n+pub fn get<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     ty\n }\n \n-fn tbox_has_flag(ty: Ty, flag: TypeFlags) -> bool {\n-    ty.flags.intersects(flag)\n+pub fn tbox_has_flag(tb: &TyS, flag: TypeFlags) -> bool {\n+    tb.flags.intersects(flag)\n }\n pub fn type_has_params(ty: Ty) -> bool {\n     tbox_has_flag(get(ty), HAS_PARAMS)\n@@ -718,32 +718,32 @@ pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct BareFnTy {\n+pub struct BareFnTy<'tcx> {\n     pub fn_style: ast::FnStyle,\n     pub abi: abi::Abi,\n-    pub sig: FnSig,\n+    pub sig: FnSig<'tcx>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct ClosureTy {\n+pub struct ClosureTy<'tcx> {\n     pub fn_style: ast::FnStyle,\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n     pub bounds: ExistentialBounds,\n-    pub sig: FnSig,\n+    pub sig: FnSig<'tcx>,\n     pub abi: abi::Abi,\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub enum FnOutput {\n-    FnConverging(Ty),\n+pub enum FnOutput<'tcx> {\n+    FnConverging(Ty<'tcx>),\n     FnDiverging\n }\n \n-impl FnOutput {\n-    pub fn unwrap(&self) -> Ty {\n-        match *self {\n-            ty::FnConverging(ref t) => *t,\n+impl<'tcx> FnOutput<'tcx> {\n+    pub fn unwrap(self) -> Ty<'tcx> {\n+        match self {\n+            ty::FnConverging(t) => t,\n             ty::FnDiverging => unreachable!()\n         }\n     }\n@@ -762,9 +762,9 @@ impl FnOutput {\n  * fn's arguments or the fn's return type.\n  */\n #[deriving(Clone, PartialEq, Eq, Hash)]\n-pub struct FnSig {\n-    pub inputs: Vec<Ty>,\n-    pub output: FnOutput,\n+pub struct FnSig<'tcx> {\n+    pub inputs: Vec<Ty<'tcx>>,\n+    pub output: FnOutput<'tcx>,\n     pub variadic: bool\n }\n \n@@ -1025,7 +1025,7 @@ mod primitives {\n \n     macro_rules! def_prim_ty(\n         ($name:ident, $sty:expr) => (\n-            pub static $name: TyS = TyS {\n+            pub static $name: TyS<'static> = TyS {\n                 sty: $sty,\n                 flags: super::NO_TYPE_FLAGS,\n                 region_depth: 0,\n@@ -1048,7 +1048,7 @@ mod primitives {\n     def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32))\n     def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64))\n \n-    pub static TY_ERR: TyS = TyS {\n+    pub static TY_ERR: TyS<'static> = TyS {\n         sty: super::ty_err,\n         flags: super::HAS_TY_ERR,\n         region_depth: 0,\n@@ -1058,7 +1058,7 @@ mod primitives {\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub enum sty {\n+pub enum sty<'tcx> {\n     ty_bool,\n     ty_char,\n     ty_int(ast::IntTy),\n@@ -1071,25 +1071,25 @@ pub enum sty {\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n     /// well.`\n-    ty_enum(DefId, Substs),\n-    ty_uniq(Ty),\n+    ty_enum(DefId, Substs<'tcx>),\n+    ty_uniq(Ty<'tcx>),\n     ty_str,\n-    ty_vec(Ty, Option<uint>), // Second field is length.\n-    ty_ptr(mt),\n-    ty_rptr(Region, mt),\n-    ty_bare_fn(BareFnTy),\n-    ty_closure(Box<ClosureTy>),\n-    ty_trait(Box<TyTrait>),\n-    ty_struct(DefId, Substs),\n-    ty_unboxed_closure(DefId, Region, Substs),\n-    ty_tup(Vec<Ty>),\n+    ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n+    ty_ptr(mt<'tcx>),\n+    ty_rptr(Region, mt<'tcx>),\n+    ty_bare_fn(BareFnTy<'tcx>),\n+    ty_closure(Box<ClosureTy<'tcx>>),\n+    ty_trait(Box<TyTrait<'tcx>>),\n+    ty_struct(DefId, Substs<'tcx>),\n+    ty_unboxed_closure(DefId, Region, Substs<'tcx>),\n+    ty_tup(Vec<Ty<'tcx>>),\n \n     ty_param(ParamTy), // type parameter\n-    ty_open(Ty), // A deref'ed fat pointer, i.e., a dynamically sized value\n-                 // and its size. Only ever used in trans. It is not necessary\n-                 // earlier since we don't need to distinguish a DST with its\n-                 // size (e.g., in a deref) vs a DST with the size elsewhere (\n-                 // e.g., in a field).\n+    ty_open(Ty<'tcx>), // A deref'ed fat pointer, i.e., a dynamically sized value\n+                       // and its size. Only ever used in trans. It is not necessary\n+                       // earlier since we don't need to distinguish a DST with its\n+                       // size (e.g., in a deref) vs a DST with the size elsewhere (\n+                       // e.g., in a field).\n \n     ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n@@ -1098,9 +1098,9 @@ pub enum sty {\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct TyTrait {\n+pub struct TyTrait<'tcx> {\n     // Principal trait reference.\n-    pub principal: TraitRef, // would use Rc<TraitRef>, but it runs afoul of some static rules\n+    pub principal: TraitRef<'tcx>, // would use Rc<TraitRef>, but it runs afoul of some static rules\n     pub bounds: ExistentialBounds\n }\n \n@@ -1122,9 +1122,9 @@ pub struct TyTrait {\n  * U>` or higher-ranked object types.\n  */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct TraitRef {\n+pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n-    pub substs: Substs,\n+    pub substs: Substs<'tcx>,\n }\n \n /**\n@@ -1166,7 +1166,7 @@ pub struct expected_found<T> {\n \n // Data structures used in type unification\n #[deriving(Clone, Show)]\n-pub enum type_err {\n+pub enum type_err<'tcx> {\n     terr_mismatch,\n     terr_fn_style_mismatch(expected_found<FnStyle>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n@@ -1187,7 +1187,7 @@ pub enum type_err {\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n-    terr_sorts(expected_found<Ty>),\n+    terr_sorts(expected_found<Ty<'tcx>>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n     terr_float_mismatch(expected_found<ast::FloatTy>),\n@@ -1201,10 +1201,10 @@ pub enum type_err {\n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n /// as well as the existential type parameter in an object type.\n #[deriving(PartialEq, Eq, Hash, Clone, Show)]\n-pub struct ParamBounds {\n+pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<Rc<TraitRef>>\n+    pub trait_bounds: Vec<Rc<TraitRef<'tcx>>>\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -1339,7 +1339,7 @@ impl fmt::Show for RegionVid {\n     }\n }\n \n-impl fmt::Show for FnSig {\n+impl<'tcx> fmt::Show for FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // grr, without tcx not much we can do.\n         write!(f, \"(...)\")\n@@ -1368,14 +1368,14 @@ impl fmt::Show for IntVarValue {\n }\n \n #[deriving(Clone, Show)]\n-pub struct TypeParameterDef {\n+pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: uint,\n     pub associated_with: Option<ast::DefId>,\n-    pub bounds: ParamBounds,\n-    pub default: Option<Ty>,\n+    pub bounds: ParamBounds<'tcx>,\n+    pub default: Option<Ty<'tcx>>,\n }\n \n #[deriving(Encodable, Decodable, Clone, Show)]\n@@ -1390,13 +1390,13 @@ pub struct RegionParameterDef {\n /// Information about the type/lifetime parameters associated with an\n /// item or method. Analogous to ast::Generics.\n #[deriving(Clone, Show)]\n-pub struct Generics {\n-    pub types: VecPerParamSpace<TypeParameterDef>,\n+pub struct Generics<'tcx> {\n+    pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n }\n \n-impl Generics {\n-    pub fn empty() -> Generics {\n+impl<'tcx> Generics<'tcx> {\n+    pub fn empty() -> Generics<'tcx> {\n         Generics { types: VecPerParamSpace::empty(),\n                    regions: VecPerParamSpace::empty() }\n     }\n@@ -1409,7 +1409,8 @@ impl Generics {\n         !self.regions.is_empty_in(space)\n     }\n \n-    pub fn to_bounds(&self, tcx: &ty::ctxt, substs: &Substs) -> GenericBounds {\n+    pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n+                     -> GenericBounds<'tcx> {\n         GenericBounds {\n             types: self.types.map(|d| d.bounds.subst(tcx, substs)),\n             regions: self.regions.map(|d| d.bounds.subst(tcx, substs)),\n@@ -1439,13 +1440,13 @@ impl Generics {\n  * [uint:Bar<int>]]`.\n  */\n #[deriving(Clone, Show)]\n-pub struct GenericBounds {\n-    pub types: VecPerParamSpace<ParamBounds>,\n+pub struct GenericBounds<'tcx> {\n+    pub types: VecPerParamSpace<ParamBounds<'tcx>>,\n     pub regions: VecPerParamSpace<Vec<Region>>,\n }\n \n-impl GenericBounds {\n-    pub fn empty() -> GenericBounds {\n+impl<'tcx> GenericBounds<'tcx> {\n+    pub fn empty() -> GenericBounds<'tcx> {\n         GenericBounds { types: VecPerParamSpace::empty(),\n                         regions: VecPerParamSpace::empty() }\n     }\n@@ -1456,16 +1457,16 @@ impl GenericBounds {\n     }\n }\n \n-impl TraitRef {\n-    pub fn new(def_id: ast::DefId, substs: Substs) -> TraitRef {\n+impl<'tcx> TraitRef<'tcx> {\n+    pub fn new(def_id: ast::DefId, substs: Substs<'tcx>) -> TraitRef<'tcx> {\n         TraitRef { def_id: def_id, substs: substs }\n     }\n \n-    pub fn self_ty(&self) -> Ty {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n         self.substs.self_ty().unwrap()\n     }\n \n-    pub fn input_types(&self) -> &[Ty] {\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -1494,16 +1495,16 @@ impl TraitRef {\n /// bound lifetime parameters are replaced with free ones, but in the\n /// future I hope to refine the representation of types so as to make\n /// more distinctions clearer.\n-pub struct ParameterEnvironment {\n+pub struct ParameterEnvironment<'tcx> {\n     /// A substitution that can be applied to move from\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub free_substs: Substs,\n+    pub free_substs: Substs<'tcx>,\n \n     /// Bounds on the various type parameters\n-    pub bounds: VecPerParamSpace<ParamBounds>,\n+    pub bounds: VecPerParamSpace<ParamBounds<'tcx>>,\n \n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n@@ -1517,15 +1518,15 @@ pub struct ParameterEnvironment {\n     ///\n     /// Note: This effectively *duplicates* the `bounds` array for\n     /// now.\n-    pub caller_obligations: VecPerParamSpace<traits::Obligation>,\n+    pub caller_obligations: VecPerParamSpace<traits::Obligation<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache,\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n }\n \n-impl ParameterEnvironment {\n-    pub fn for_item(cx: &ctxt, id: NodeId) -> ParameterEnvironment {\n+impl<'tcx> ParameterEnvironment<'tcx> {\n+    pub fn for_item(cx: &ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match **impl_item {\n@@ -1635,37 +1636,37 @@ impl ParameterEnvironment {\n /// - `ty`: the base types, which may reference the parameters defined\n ///   in `generics`\n #[deriving(Clone, Show)]\n-pub struct Polytype {\n-    pub generics: Generics,\n-    pub ty: Ty\n+pub struct Polytype<'tcx> {\n+    pub generics: Generics<'tcx>,\n+    pub ty: Ty<'tcx>\n }\n \n /// As `Polytype` but for a trait ref.\n-pub struct TraitDef {\n+pub struct TraitDef<'tcx> {\n     /// Generic type definitions. Note that `Self` is listed in here\n     /// as having a single bound, the trait itself (e.g., in the trait\n     /// `Eq`, there is a single bound `Self : Eq`). This is so that\n     /// default methods get to assume that the `Self` parameters\n     /// implements the trait.\n-    pub generics: Generics,\n+    pub generics: Generics<'tcx>,\n \n     /// The \"supertrait\" bounds.\n-    pub bounds: ParamBounds,\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub bounds: ParamBounds<'tcx>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n }\n \n /// Records the substitutions used to translate the polytype for an\n /// item into the monotype of an item reference.\n #[deriving(Clone)]\n-pub struct ItemSubsts {\n-    pub substs: Substs,\n+pub struct ItemSubsts<'tcx> {\n+    pub substs: Substs<'tcx>,\n }\n \n /// Records information about each unboxed closure.\n #[deriving(Clone)]\n-pub struct UnboxedClosure {\n+pub struct UnboxedClosure<'tcx> {\n     /// The type of the unboxed closure.\n-    pub closure_type: ClosureTy,\n+    pub closure_type: ClosureTy<'tcx>,\n     /// The kind of unboxed closure this is.\n     pub kind: UnboxedClosureKind,\n }\n@@ -1696,7 +1697,7 @@ impl UnboxedClosureKind {\n }\n \n pub fn mk_ctxt<'tcx>(s: Session,\n-                     type_arena: &'tcx TypedArena<TyS>,\n+                     type_arena: &'tcx TypedArena<TyS<'tcx>>,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n@@ -1768,7 +1769,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-pub fn mk_t(cx: &ctxt, st: sty) -> Ty {\n+pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n     // Check for primitive types.\n     match st {\n         ty_err => return mk_err(),\n@@ -1781,7 +1782,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> Ty {\n     };\n \n     match cx.interner.borrow().get(&st) {\n-        Some(ty) => return ty,\n+        Some(ty) => return *ty,\n         _ => ()\n     }\n \n@@ -1795,7 +1796,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> Ty {\n \n     cx.interner.borrow_mut().insert(InternedTy { ty: ty }, ty);\n \n-    Ty { inner: ty }\n+    ty\n }\n \n struct FlagComputation {\n@@ -1981,53 +1982,54 @@ impl FlagComputation {\n }\n \n #[inline]\n-pub fn mk_prim_t(primitive: &'static TyS) -> Ty {\n-    Ty { inner: primitive }\n+pub fn mk_prim_t<'tcx>(primitive: &'tcx TyS<'static>) -> Ty<'tcx> {\n+    // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n+    unsafe { &*(primitive as *const _ as *const TyS<'tcx>) }\n }\n \n #[inline]\n-pub fn mk_err() -> Ty { mk_prim_t(&primitives::TY_ERR) }\n+pub fn mk_err<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_ERR) }\n \n #[inline]\n-pub fn mk_bool() -> Ty { mk_prim_t(&primitives::TY_BOOL) }\n+pub fn mk_bool<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_BOOL) }\n \n #[inline]\n-pub fn mk_int() -> Ty { mk_prim_t(&primitives::TY_INT) }\n+pub fn mk_int<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_INT) }\n \n #[inline]\n-pub fn mk_i8() -> Ty { mk_prim_t(&primitives::TY_I8) }\n+pub fn mk_i8<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_I8) }\n \n #[inline]\n-pub fn mk_i16() -> Ty { mk_prim_t(&primitives::TY_I16) }\n+pub fn mk_i16<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_I16) }\n \n #[inline]\n-pub fn mk_i32() -> Ty { mk_prim_t(&primitives::TY_I32) }\n+pub fn mk_i32<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_I32) }\n \n #[inline]\n-pub fn mk_i64() -> Ty { mk_prim_t(&primitives::TY_I64) }\n+pub fn mk_i64<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_I64) }\n \n #[inline]\n-pub fn mk_f32() -> Ty { mk_prim_t(&primitives::TY_F32) }\n+pub fn mk_f32<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_F32) }\n \n #[inline]\n-pub fn mk_f64() -> Ty { mk_prim_t(&primitives::TY_F64) }\n+pub fn mk_f64<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_F64) }\n \n #[inline]\n-pub fn mk_uint() -> Ty { mk_prim_t(&primitives::TY_UINT) }\n+pub fn mk_uint<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_UINT) }\n \n #[inline]\n-pub fn mk_u8() -> Ty { mk_prim_t(&primitives::TY_U8) }\n+pub fn mk_u8<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_U8) }\n \n #[inline]\n-pub fn mk_u16() -> Ty { mk_prim_t(&primitives::TY_U16) }\n+pub fn mk_u16<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_U16) }\n \n #[inline]\n-pub fn mk_u32() -> Ty { mk_prim_t(&primitives::TY_U32) }\n+pub fn mk_u32<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_U32) }\n \n #[inline]\n-pub fn mk_u64() -> Ty { mk_prim_t(&primitives::TY_U64) }\n+pub fn mk_u64<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_U64) }\n \n-pub fn mk_mach_int(tm: ast::IntTy) -> Ty {\n+pub fn mk_mach_int<'tcx>(tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n         ast::TyI    => mk_int(),\n         ast::TyI8   => mk_i8(),\n@@ -2037,7 +2039,7 @@ pub fn mk_mach_int(tm: ast::IntTy) -> Ty {\n     }\n }\n \n-pub fn mk_mach_uint(tm: ast::UintTy) -> Ty {\n+pub fn mk_mach_uint<'tcx>(tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n         ast::TyU    => mk_uint(),\n         ast::TyU8   => mk_u8(),\n@@ -2047,89 +2049,91 @@ pub fn mk_mach_uint(tm: ast::UintTy) -> Ty {\n     }\n }\n \n-pub fn mk_mach_float(tm: ast::FloatTy) -> Ty {\n+pub fn mk_mach_float<'tcx>(tm: ast::FloatTy) -> Ty<'tcx> {\n     match tm {\n         ast::TyF32  => mk_f32(),\n         ast::TyF64  => mk_f64(),\n     }\n }\n \n #[inline]\n-pub fn mk_char() -> Ty { mk_prim_t(&primitives::TY_CHAR) }\n+pub fn mk_char<'tcx>() -> Ty<'tcx> { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: &ctxt) -> Ty {\n+pub fn mk_str<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_str)\n }\n \n-pub fn mk_str_slice(cx: &ctxt, r: Region, m: ast::Mutability) -> Ty {\n+pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, m: ast::Mutability) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_t(cx, ty_str),\n                 mutbl: m\n             })\n }\n \n-pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: Substs) -> Ty {\n+pub fn mk_enum<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_uniq(cx: &ctxt, ty: Ty) -> Ty { mk_t(cx, ty_uniq(ty)) }\n+pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_uniq(ty)) }\n \n-pub fn mk_ptr(cx: &ctxt, tm: mt) -> Ty { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr(cx: &ctxt, r: Region, tm: mt) -> Ty { mk_t(cx, ty_rptr(r, tm)) }\n+pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+    mk_t(cx, ty_rptr(r, tm))\n+}\n \n-pub fn mk_mut_rptr(cx: &ctxt, r: Region, ty: Ty) -> Ty {\n+pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr(cx: &ctxt, r: Region, ty: Ty) -> Ty {\n+pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_mut_ptr(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn mk_mut_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n }\n \n-pub fn mk_imm_ptr(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn mk_imm_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_nil_ptr(cx: &ctxt) -> Ty {\n+pub fn mk_nil_ptr<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: &ctxt, ty: Ty, sz: Option<uint>) -> Ty {\n+pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<uint>) -> Ty<'tcx> {\n     mk_t(cx, ty_vec(ty, sz))\n }\n \n-pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> Ty {\n+pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_vec(cx, tm.ty, None),\n                 mutbl: tm.mutbl\n             })\n }\n \n-pub fn mk_tup(cx: &ctxt, ts: Vec<Ty>) -> Ty {\n+pub fn mk_tup<'tcx>(cx: &ctxt<'tcx>, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n     mk_t(cx, ty_tup(ts))\n }\n \n-pub fn mk_nil(cx: &ctxt) -> Ty {\n+pub fn mk_nil<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_tup(cx, Vec::new())\n }\n \n-pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> Ty {\n+pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, fty: ClosureTy<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_closure(box fty))\n }\n \n-pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> Ty {\n+pub fn mk_bare_fn<'tcx>(cx: &ctxt<'tcx>, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n-pub fn mk_ctor_fn(cx: &ctxt,\n-                  input_tys: &[Ty],\n-                  output: Ty) -> Ty {\n+pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n+                        input_tys: &[Ty<'tcx>],\n+                        output: Ty<'tcx>) -> Ty<'tcx> {\n     let input_args = input_tys.iter().map(|ty| *ty).collect();\n     mk_bare_fn(cx,\n                BareFnTy {\n@@ -2144,10 +2148,10 @@ pub fn mk_ctor_fn(cx: &ctxt,\n }\n \n \n-pub fn mk_trait(cx: &ctxt,\n-                principal: ty::TraitRef,\n-                bounds: ExistentialBounds)\n-                -> Ty {\n+pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n+                      principal: ty::TraitRef<'tcx>,\n+                      bounds: ExistentialBounds)\n+                      -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     let inner = box TyTrait {\n         principal: principal,\n@@ -2156,43 +2160,54 @@ pub fn mk_trait(cx: &ctxt,\n     mk_t(cx, ty_trait(inner))\n }\n \n-pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: Substs) -> Ty {\n+pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n+                       substs: Substs<'tcx>) -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_unboxed_closure(cx: &ctxt, closure_id: ast::DefId, region: Region, substs: Substs)\n-                          -> Ty {\n+pub fn mk_unboxed_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n+                                region: Region, substs: Substs<'tcx>)\n+                                -> Ty<'tcx> {\n     mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n }\n \n-pub fn mk_var(cx: &ctxt, v: TyVid) -> Ty { mk_infer(cx, TyVar(v)) }\n+pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n+    mk_infer(cx, TyVar(v))\n+}\n \n-pub fn mk_int_var(cx: &ctxt, v: IntVid) -> Ty { mk_infer(cx, IntVar(v)) }\n+pub fn mk_int_var<'tcx>(cx: &ctxt<'tcx>, v: IntVid) -> Ty<'tcx> {\n+    mk_infer(cx, IntVar(v))\n+}\n \n-pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> Ty { mk_infer(cx, FloatVar(v)) }\n+pub fn mk_float_var<'tcx>(cx: &ctxt<'tcx>, v: FloatVid) -> Ty<'tcx> {\n+    mk_infer(cx, FloatVar(v))\n+}\n \n-pub fn mk_infer(cx: &ctxt, it: InferTy) -> Ty { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer<'tcx>(cx: &ctxt<'tcx>, it: InferTy) -> Ty<'tcx> {\n+    mk_t(cx, ty_infer(it))\n+}\n \n-pub fn mk_param(cx: &ctxt, space: subst::ParamSpace, n: uint, k: DefId) -> Ty {\n+pub fn mk_param<'tcx>(cx: &ctxt<'tcx>, space: subst::ParamSpace,\n+                      n: uint, k: DefId) -> Ty<'tcx> {\n     mk_t(cx, ty_param(ParamTy { space: space, idx: n, def_id: k }))\n }\n \n-pub fn mk_self_type(cx: &ctxt, did: ast::DefId) -> Ty {\n+pub fn mk_self_type<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId) -> Ty<'tcx> {\n     mk_param(cx, subst::SelfSpace, 0, did)\n }\n \n-pub fn mk_param_from_def(cx: &ctxt, def: &TypeParameterDef) -> Ty {\n+pub fn mk_param_from_def<'tcx>(cx: &ctxt<'tcx>, def: &TypeParameterDef) -> Ty<'tcx> {\n     mk_param(cx, def.space, def.index, def.def_id)\n }\n \n-pub fn mk_open(cx: &ctxt, ty: Ty) -> Ty { mk_t(cx, ty_open(ty)) }\n+pub fn mk_open<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_open(ty)) }\n \n-pub fn walk_ty(ty: Ty, f: |Ty|) {\n+pub fn walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>|) {\n     maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n-pub fn maybe_walk_ty(ty: Ty, f: |Ty| -> bool) {\n+pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n     if !f(ty) {\n         return;\n     }\n@@ -2232,7 +2247,9 @@ pub fn maybe_walk_ty(ty: Ty, f: |Ty| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: &ctxt, t0: Ty, fldop: |Ty| -> Ty) -> Ty {\n+pub fn fold_ty<'tcx>(cx: &ctxt<'tcx>, t0: Ty<'tcx>,\n+                     fldop: |Ty<'tcx>| -> Ty<'tcx>)\n+                     -> Ty<'tcx> {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n@@ -2253,7 +2270,7 @@ impl ParamTy {\n         ParamTy::new(def.space, def.index, def.def_id)\n     }\n \n-    pub fn to_ty(self, tcx: &ty::ctxt) -> Ty {\n+    pub fn to_ty<'tcx>(self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         ty::mk_param(tcx, self.space, self.idx, self.def_id)\n     }\n \n@@ -2262,8 +2279,8 @@ impl ParamTy {\n     }\n }\n \n-impl ItemSubsts {\n-    pub fn empty() -> ItemSubsts {\n+impl<'tcx> ItemSubsts<'tcx> {\n+    pub fn empty() -> ItemSubsts<'tcx> {\n         ItemSubsts { substs: Substs::empty() }\n     }\n \n@@ -2272,8 +2289,8 @@ impl ItemSubsts {\n     }\n }\n \n-impl ParamBounds {\n-    pub fn empty() -> ParamBounds {\n+impl<'tcx> ParamBounds<'tcx> {\n+    pub fn empty() -> ParamBounds<'tcx> {\n         ParamBounds {\n             builtin_bounds: empty_builtin_bounds(),\n             trait_bounds: Vec::new(),\n@@ -2356,7 +2373,7 @@ pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n     }\n }\n \n-pub fn sequence_element_type(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(ast::TyU8),\n@@ -2366,7 +2383,7 @@ pub fn sequence_element_type(cx: &ctxt, ty: Ty) -> Ty {\n     }\n }\n \n-pub fn simd_type(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -2410,7 +2427,7 @@ pub fn type_is_unique(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_fat_ptr(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_is_fat_ptr<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match get(ty).sty {\n         ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n         | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n@@ -2441,20 +2458,21 @@ pub fn type_is_floating_point(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_needs_drop(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_needs_drop<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_needs_unwind_cleanup<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     return memoized(&cx.needs_unwind_cleanup_cache, ty, |ty| {\n         type_needs_unwind_cleanup_(cx, ty, &mut FnvHashSet::new())\n     });\n \n-    fn type_needs_unwind_cleanup_(cx: &ctxt, ty: Ty, tycache: &mut FnvHashSet<Ty>) -> bool {\n+    fn type_needs_unwind_cleanup_<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>,\n+                                        tycache: &mut FnvHashSet<Ty<'tcx>>) -> bool {\n         // Prevent infinite recursion\n         if !tycache.insert(ty) {\n             return false;\n@@ -2670,18 +2688,18 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_interior_is_unsafe(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_interior_is_unsafe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     type_contents(cx, ty).interior_unsafe()\n }\n \n-pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n+pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     return memoized(&cx.tc_cache, ty, |ty| {\n         tc_ty(cx, ty, &mut FnvHashMap::new())\n     });\n \n-    fn tc_ty(cx: &ctxt,\n-             ty: Ty,\n-             cache: &mut FnvHashMap<Ty, TypeContents>) -> TypeContents\n+    fn tc_ty<'tcx>(cx: &ctxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n     {\n         // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n         // private cache for this walk.  This is needed in the case of cyclic\n@@ -2886,9 +2904,9 @@ pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n         result\n     }\n \n-    fn tc_mt(cx: &ctxt,\n-             mt: mt,\n-             cache: &mut FnvHashMap<Ty, TypeContents>) -> TypeContents\n+    fn tc_mt<'tcx>(cx: &ctxt<'tcx>,\n+                   mt: mt<'tcx>,\n+                   cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n     {\n         let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n         mc | tc_ty(cx, mt.ty, cache)\n@@ -2956,10 +2974,10 @@ pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n         kind_bounds_to_contents(cx, bounds.builtin_bounds, &[])\n     }\n \n-    fn kind_bounds_to_contents(cx: &ctxt,\n-                               bounds: BuiltinBounds,\n-                               traits: &[Rc<TraitRef>])\n-                               -> TypeContents {\n+    fn kind_bounds_to_contents<'tcx>(cx: &ctxt<'tcx>,\n+                                     bounds: BuiltinBounds,\n+                                     traits: &[Rc<TraitRef<'tcx>>])\n+                                     -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n         each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n@@ -2973,10 +2991,10 @@ pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound(cx: &ctxt,\n-                                        bounds: BuiltinBounds,\n-                                        traits: &[Rc<TraitRef>],\n-                                        f: |BuiltinBound|) {\n+        fn each_inherited_builtin_bound<'tcx>(cx: &ctxt<'tcx>,\n+                                              bounds: BuiltinBounds,\n+                                              traits: &[Rc<TraitRef<'tcx>>],\n+                                              f: |BuiltinBound|) {\n             for bound in bounds.iter() {\n                 f(bound);\n             }\n@@ -2992,18 +3010,18 @@ pub fn type_contents(cx: &ctxt, ty: Ty) -> TypeContents {\n     }\n }\n \n-pub fn type_moves_by_default(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_moves_by_default<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n-pub fn is_ffi_safe(cx: &ctxt, ty: Ty) -> bool {\n+pub fn is_ffi_safe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     !type_contents(cx, ty).intersects(TC::ReachesFfiUnsafe)\n }\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-pub fn is_instantiable(cx: &ctxt, r_ty: Ty) -> bool {\n-    fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n-                     r_ty: Ty, ty: Ty) -> bool {\n+pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n+    fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+                           r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n@@ -3020,8 +3038,8 @@ pub fn is_instantiable(cx: &ctxt, r_ty: Ty) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: &ctxt, seen: &mut Vec<DefId>,\n-                        r_ty: Ty, ty: Ty) -> bool {\n+    fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<DefId>,\n+                              r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_string(cx, r_ty),\n                ::util::ppaux::ty_to_string(cx, ty));\n@@ -3130,17 +3148,21 @@ pub enum Representability {\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn is_type_representable(cx: &ctxt, sp: Span, ty: Ty) -> Representability {\n+pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n+                                   -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<Ty>>(cx: &ctxt, sp: Span, seen: &mut Vec<Ty>,\n-                                              mut iter: It) -> Representability {\n+    fn find_nonrepresentable<'tcx, It: Iterator<Ty<'tcx>>>(cx: &ctxt<'tcx>, sp: Span,\n+                                                           seen: &mut Vec<Ty<'tcx>>,\n+                                                           mut iter: It)\n+                                                           -> Representability {\n         iter.fold(Representable,\n                   |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n     }\n \n-    fn are_inner_types_recursive(cx: &ctxt, sp: Span,\n-                                 seen: &mut Vec<Ty>, ty: Ty) -> Representability {\n+    fn are_inner_types_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n+                                       seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n+                                       -> Representability {\n         match get(ty).sty {\n             ty_tup(ref ts) => {\n                 find_nonrepresentable(cx, sp, seen, ts.iter().map(|ty| *ty))\n@@ -3179,7 +3201,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: Ty) -> Representability {\n         }\n     }\n \n-    fn same_type(a: Ty, b: Ty) -> bool {\n+    fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&get(a).sty, &get(b).sty) {\n             (&ty_struct(did_a, ref substs_a), &ty_struct(did_b, ref substs_b)) |\n             (&ty_enum(did_a, ref substs_a), &ty_enum(did_b, ref substs_b)) => {\n@@ -3202,8 +3224,9 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: Ty) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn is_type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<Ty>,\n-                                      ty: Ty) -> Representability {\n+    fn is_type_structurally_recursive<'tcx>(cx: &ctxt<'tcx>, sp: Span,\n+                                            seen: &mut Vec<Ty<'tcx>>,\n+                                            ty: Ty<'tcx>) -> Representability {\n         debug!(\"is_type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_string(cx, ty));\n \n@@ -3283,7 +3306,7 @@ pub fn type_is_trait(ty: Ty) -> bool {\n     type_trait_info(ty).is_some()\n }\n \n-pub fn type_trait_info(ty: Ty) -> Option<&'static TyTrait> {\n+pub fn type_trait_info<'tcx>(ty: Ty<'tcx>) -> Option<&'tcx TyTrait<'tcx>> {\n     match get(ty).sty {\n         ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n             ty_trait(ref t) => Some(&**t),\n@@ -3357,11 +3380,11 @@ pub fn type_is_machine(ty: Ty) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-pub fn type_is_sized(cx: &ctxt, ty: Ty) -> bool {\n+pub fn type_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     type_contents(cx, ty).is_sized(cx)\n }\n \n-pub fn lltype_is_sized(cx: &ctxt, ty: Ty) -> bool {\n+pub fn lltype_is_sized<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match get(ty).sty {\n         ty_open(_) => true,\n         _ => type_contents(cx, ty).is_sized(cx)\n@@ -3371,7 +3394,7 @@ pub fn lltype_is_sized(cx: &ctxt, ty: Ty) -> bool {\n // Return the smallest part of ty which is unsized. Fails if ty is sized.\n // 'Smallest' here means component of the static representation of the type; not\n // the size of an object at runtime.\n-pub fn unsized_part_of_type(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_str | ty_trait(..) | ty_vec(..) => ty,\n         ty_struct(def_id, ref substs) => {\n@@ -3410,7 +3433,7 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-pub fn deref(ty: Ty, explicit: bool) -> Option<mt> {\n+pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n     match get(ty).sty {\n         ty_uniq(ty) => {\n             Some(mt {\n@@ -3424,23 +3447,23 @@ pub fn deref(ty: Ty, explicit: bool) -> Option<mt> {\n     }\n }\n \n-pub fn deref_or_dont(ty: Ty) -> Ty {\n+pub fn deref_or_dont<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n         _ => ty\n     }\n }\n \n-pub fn close_type(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n                                  ty_to_string(cx, ty)).as_slice())\n     }\n }\n \n-pub fn type_content(ty: Ty) -> Ty {\n+pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_uniq(ty) => ty,\n         ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n@@ -3449,15 +3472,15 @@ pub fn type_content(ty: Ty) -> Ty {\n }\n \n // Extract the unsized type in an open type (or just return ty if it is not open).\n-pub fn unopen_type(ty: Ty) -> Ty {\n+pub fn unopen_type<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match get(ty).sty {\n         ty_open(ty) => ty,\n         _ => ty\n     }\n }\n \n // Returns the type of ty[i]\n-pub fn index(ty: Ty) -> Option<Ty> {\n+pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match get(ty).sty {\n         ty_vec(ty, _) => Some(ty),\n         _ => None\n@@ -3467,15 +3490,16 @@ pub fn index(ty: Ty) -> Option<Ty> {\n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty(ty: Ty) -> Option<Ty> {\n+pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match get(ty).sty {\n         ty_vec(ty, _) => Some(ty),\n         ty_str => Some(mk_u8()),\n         _ => None\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n+pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n+                                  -> Rc<ty::TraitRef<'tcx>> {\n     match cx.trait_refs.borrow().get(&id) {\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n@@ -3484,11 +3508,11 @@ pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n     }\n }\n \n-pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<Ty> {\n+pub fn try_node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Option<Ty<'tcx>> {\n     cx.node_types.borrow().get(&id).cloned()\n }\n \n-pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Ty {\n+pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     match try_node_id_to_type(cx, id) {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n@@ -3497,14 +3521,14 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Ty {\n     }\n }\n \n-pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<Ty> {\n+pub fn node_id_to_type_opt<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Option<Ty<'tcx>> {\n     match cx.node_types.borrow().get(&id) {\n        Some(&ty) => Some(ty),\n        None => None\n     }\n }\n \n-pub fn node_id_item_substs(cx: &ctxt, id: ast::NodeId) -> ItemSubsts {\n+pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts<'tcx> {\n     match cx.item_substs.borrow().get(&id) {\n       None => ItemSubsts::empty(),\n       Some(ts) => ts.clone(),\n@@ -3521,7 +3545,7 @@ pub fn fn_is_variadic(fty: Ty) -> bool {\n     }\n }\n \n-pub fn ty_fn_sig(fty: Ty) -> FnSig {\n+pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> FnSig<'tcx> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.clone(),\n         ty_closure(ref f) => f.sig.clone(),\n@@ -3541,7 +3565,7 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n }\n \n // Type accessors for substructures of types\n-pub fn ty_fn_args(fty: Ty) -> Vec<Ty> {\n+pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.inputs.clone(),\n         ty_closure(ref f) => f.sig.inputs.clone(),\n@@ -3565,7 +3589,7 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n     }\n }\n \n-pub fn ty_fn_ret(fty: Ty) -> FnOutput {\n+pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.sig.output,\n         ty_closure(ref f) => f.sig.output,\n@@ -3607,7 +3631,7 @@ pub fn free_region_from_def(free_id: ast::NodeId, def: &RegionParameterDef)\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> Ty {\n+pub fn pat_ty<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Ty<'tcx> {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -3622,15 +3646,15 @@ pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> Ty {\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(ty) -> T with T = int\".\n-pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> Ty {\n+pub fn expr_ty<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<Ty> {\n+pub fn expr_ty_opt<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Option<Ty<'tcx>> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> Ty {\n+pub fn expr_ty_adjusted<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     /*!\n      *\n      * Returns the type of `expr`, considering any `AutoAdjustment`\n@@ -3689,13 +3713,13 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n     }\n }\n \n-pub fn adjust_ty(cx: &ctxt,\n-                 span: Span,\n-                 expr_id: ast::NodeId,\n-                 unadjusted_ty: Ty,\n-                 adjustment: Option<&AutoAdjustment>,\n-                 method_type: |typeck::MethodCall| -> Option<Ty>)\n-                 -> Ty {\n+pub fn adjust_ty<'tcx>(cx: &ctxt<'tcx>,\n+                       span: Span,\n+                       expr_id: ast::NodeId,\n+                       unadjusted_ty: Ty<'tcx>,\n+                       adjustment: Option<&AutoAdjustment<'tcx>>,\n+                       method_type: |typeck::MethodCall| -> Option<Ty<'tcx>>)\n+                       -> Ty<'tcx> {\n     /*! See `expr_ty_adjusted` */\n \n     match get(unadjusted_ty).sty {\n@@ -3769,11 +3793,11 @@ pub fn adjust_ty(cx: &ctxt,\n     };\n }\n \n-pub fn adjust_ty_for_autoref(cx: &ctxt,\n-                             span: Span,\n-                             ty: Ty,\n-                             autoref: Option<&AutoRef>)\n-                             -> Ty\n+pub fn adjust_ty_for_autoref<'tcx>(cx: &ctxt<'tcx>,\n+                                   span: Span,\n+                                   ty: Ty<'tcx>,\n+                                   autoref: Option<&AutoRef<'tcx>>)\n+                                   -> Ty<'tcx>\n {\n     match autoref {\n         None => ty,\n@@ -3805,11 +3829,11 @@ pub fn adjust_ty_for_autoref(cx: &ctxt,\n \n // Take a sized type and a sizing adjustment and produce an unsized version of\n // the type.\n-pub fn unsize_ty(cx: &ctxt,\n-                 ty: Ty,\n-                 kind: &UnsizeKind,\n-                 span: Span)\n-                 -> Ty {\n+pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       kind: &UnsizeKind<'tcx>,\n+                       span: Span)\n+                       -> Ty<'tcx> {\n     match kind {\n         &UnsizeLength(len) => match get(ty).sty {\n             ty_vec(ty, Some(n)) => {\n@@ -4070,7 +4094,7 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n-pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n+pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n     match get(ty).sty {\n         ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n@@ -4111,7 +4135,7 @@ pub fn ty_sort_string(cx: &ctxt, ty: Ty) -> String {\n     }\n }\n \n-pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> String {\n+pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -4293,7 +4317,8 @@ pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.borrow().get(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n+pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                                    -> Vec<Rc<Method<'tcx>>> {\n     if is_local(id) {\n         match cx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n@@ -4362,14 +4387,14 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n-                  -> ImplOrTraitItem {\n+pub fn trait_item<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId, idx: uint)\n+                        -> ImplOrTraitItem<'tcx> {\n     let method_def_id = (*ty::trait_item_def_ids(cx, trait_did))[idx].def_id();\n     impl_or_trait_item(cx, method_def_id)\n }\n \n-pub fn trait_items(cx: &ctxt, trait_did: ast::DefId)\n-                   -> Rc<Vec<ImplOrTraitItem>> {\n+pub fn trait_items<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId)\n+                         -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n     let mut trait_items = cx.trait_items_cache.borrow_mut();\n     match trait_items.get(&trait_did).cloned() {\n         Some(trait_items) => trait_items,\n@@ -4385,7 +4410,8 @@ pub fn trait_items(cx: &ctxt, trait_did: ast::DefId)\n     }\n }\n \n-pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n+pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                                -> ImplOrTraitItem<'tcx> {\n     lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n                                      id,\n                                      &mut *cx.impl_or_trait_items\n@@ -4457,7 +4483,8 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n     })\n }\n \n-pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n+pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                            -> Option<Rc<TraitRef<'tcx>>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {}\", id);\n@@ -4522,24 +4549,24 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n \n // Enum information\n #[deriving(Clone)]\n-pub struct VariantInfo {\n-    pub args: Vec<Ty>,\n+pub struct VariantInfo<'tcx> {\n+    pub args: Vec<Ty<'tcx>>,\n     pub arg_names: Option<Vec<ast::Ident>>,\n-    pub ctor_ty: Option<Ty>,\n+    pub ctor_ty: Option<Ty<'tcx>>,\n     pub name: ast::Name,\n     pub id: ast::DefId,\n     pub disr_val: Disr,\n     pub vis: Visibility\n }\n \n-impl VariantInfo {\n+impl<'tcx> VariantInfo<'tcx> {\n \n     /// Creates a new VariantInfo from the corresponding ast representation.\n     ///\n     /// Does not do any caching of the value in the type context.\n-    pub fn from_ast_variant(cx: &ctxt,\n+    pub fn from_ast_variant(cx: &ctxt<'tcx>,\n                             ast_variant: &ast::Variant,\n-                            discriminant: Disr) -> VariantInfo {\n+                            discriminant: Disr) -> VariantInfo<'tcx> {\n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n \n         match ast_variant.node.kind {\n@@ -4590,10 +4617,10 @@ impl VariantInfo {\n     }\n }\n \n-pub fn substd_enum_variants(cx: &ctxt,\n-                            id: ast::DefId,\n-                            substs: &Substs)\n-                         -> Vec<Rc<VariantInfo>> {\n+pub fn substd_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n+                                  id: ast::DefId,\n+                                  substs: &Substs<'tcx>)\n+                                  -> Vec<Rc<VariantInfo<'tcx>>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| aty.subst(cx, substs)).collect::<Vec<_>>();\n@@ -4669,7 +4696,8 @@ pub fn type_is_empty(cx: &ctxt, ty: Ty) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n+pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n+                           -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n     memoized(&cx.enum_var_cache, id, |id: ast::DefId| {\n         if ast::LOCAL_CRATE != id.krate {\n             Rc::new(csearch::get_enum_variants(cx, id))\n@@ -4732,10 +4760,10 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n }\n \n // Returns information about the enum variant with the given ID:\n-pub fn enum_variant_with_id(cx: &ctxt,\n-                            enum_id: ast::DefId,\n-                            variant_id: ast::DefId)\n-                         -> Rc<VariantInfo> {\n+pub fn enum_variant_with_id<'tcx>(cx: &ctxt<'tcx>,\n+                                  enum_id: ast::DefId,\n+                                  variant_id: ast::DefId)\n+                                  -> Rc<VariantInfo<'tcx>> {\n     enum_variants(cx, enum_id).iter()\n                               .find(|variant| variant.id == variant_id)\n                               .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n@@ -4745,16 +4773,17 @@ pub fn enum_variant_with_id(cx: &ctxt,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-pub fn lookup_item_type(cx: &ctxt,\n-                        did: ast::DefId)\n-                     -> Polytype {\n+pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n+                              did: ast::DefId)\n+                              -> Polytype<'tcx> {\n     lookup_locally_or_in_crate_store(\n         \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n         || csearch::get_type(cx, did))\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: &ctxt, did: DefId) -> Rc<ty::TraitDef> {\n+pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                              -> Rc<ty::TraitDef<'tcx>> {\n     memoized(&cx.trait_defs, did, |did: DefId| {\n         assert!(did.krate != ast::LOCAL_CRATE);\n         Rc::new(csearch::get_trait_def(cx, did))\n@@ -4763,9 +4792,9 @@ pub fn lookup_trait_def(cx: &ctxt, did: DefId) -> Rc<ty::TraitDef> {\n \n /// Given a reference to a trait, returns the bounds declared on the\n /// trait, with appropriate substitutions applied.\n-pub fn bounds_for_trait_ref(tcx: &ctxt,\n-                            trait_ref: &TraitRef)\n-                            -> ty::ParamBounds\n+pub fn bounds_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n+                                  trait_ref: &TraitRef<'tcx>)\n+                                  -> ty::ParamBounds<'tcx>\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n \n@@ -4926,11 +4955,11 @@ pub fn lookup_repr_hints(tcx: &ctxt, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n-pub fn lookup_field_type(tcx: &ctxt,\n-                         struct_id: DefId,\n-                         id: DefId,\n-                         substs: &Substs)\n-                      -> Ty {\n+pub fn lookup_field_type<'tcx>(tcx: &ctxt<'tcx>,\n+                               struct_id: DefId,\n+                               id: DefId,\n+                               substs: &Substs<'tcx>)\n+                               -> Ty<'tcx> {\n     let ty = if id.krate == ast::LOCAL_CRATE {\n         node_id_to_type(tcx, id.node)\n     } else {\n@@ -4969,8 +4998,8 @@ pub fn is_tuple_struct(cx: &ctxt, did: ast::DefId) -> bool {\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n-pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n-                     -> Vec<field> {\n+pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tcx>)\n+                           -> Vec<field<'tcx>> {\n     lookup_struct_fields(cx, did).iter().map(|f| {\n        field {\n             name: f.name,\n@@ -4984,7 +5013,7 @@ pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &Substs)\n \n // Returns a list of fields corresponding to the tuple's items. trans uses\n // this.\n-pub fn tup_fields(v: &[Ty]) -> Vec<field> {\n+pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n             name: token::intern(i.to_string().as_slice()),\n@@ -4996,15 +5025,15 @@ pub fn tup_fields(v: &[Ty]) -> Vec<field> {\n     }).collect()\n }\n \n-pub struct UnboxedClosureUpvar {\n+pub struct UnboxedClosureUpvar<'tcx> {\n     pub def: def::Def,\n     pub span: Span,\n-    pub ty: Ty,\n+    pub ty: Ty<'tcx>,\n }\n \n // Returns a list of `UnboxedClosureUpvar`s for each upvar.\n-pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Substs)\n-                              -> Vec<UnboxedClosureUpvar> {\n+pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &Substs<'tcx>)\n+                                    -> Vec<UnboxedClosureUpvar<'tcx>> {\n     // Presently an unboxed closure type cannot \"escape\" out of a\n     // function, so we will only encounter ones that originated in the\n     // local crate or were inlined into it along with some function.\n@@ -5039,7 +5068,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     }\n }\n \n-pub fn is_binopable(cx: &ctxt, ty: Ty, op: ast::BinOp) -> bool {\n+pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool {\n     #![allow(non_upper_case_globals)]\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n@@ -5081,7 +5110,7 @@ pub fn is_binopable(cx: &ctxt, ty: Ty, op: ast::BinOp) -> bool {\n         }\n     }\n \n-    fn tycat(cx: &ctxt, ty: Ty) -> int {\n+    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> int {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -5112,7 +5141,7 @@ pub fn is_binopable(cx: &ctxt, ty: Ty, op: ast::BinOp) -> bool {\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty(cx: &ctxt, ty: Ty) -> Ty {\n+pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     let u = TypeNormalizer(cx).fold_ty(ty);\n     return u;\n \n@@ -5121,7 +5150,7 @@ pub fn normalize_ty(cx: &ctxt, ty: Ty) -> Ty {\n     impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n         fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n-        fn fold_ty(&mut self, ty: Ty) -> Ty {\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n                 None => {}\n                 Some(u) => return u\n@@ -5137,15 +5166,15 @@ pub fn normalize_ty(cx: &ctxt, ty: Ty) -> Ty {\n         }\n \n         fn fold_substs(&mut self,\n-                       substs: &subst::Substs)\n-                       -> subst::Substs {\n+                       substs: &subst::Substs<'tcx>)\n+                       -> subst::Substs<'tcx> {\n             subst::Substs { regions: subst::ErasedRegions,\n                             types: substs.types.fold_with(self) }\n         }\n \n         fn fold_fn_sig(&mut self,\n-                       sig: &ty::FnSig)\n-                       -> ty::FnSig {\n+                       sig: &ty::FnSig<'tcx>)\n+                       -> ty::FnSig<'tcx> {\n             // The binder-id is only relevant to bound regions, which\n             // are erased at trans time.\n             ty::FnSig {\n@@ -5203,10 +5232,10 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n-                                        bounds: &[Rc<TraitRef>],\n-                                        f: |Rc<TraitRef>| -> bool)\n-                                        -> bool\n+pub fn each_bound_trait_and_supertraits<'tcx>(tcx: &ctxt<'tcx>,\n+                                              bounds: &[Rc<TraitRef<'tcx>>],\n+                                              f: |Rc<TraitRef<'tcx>>| -> bool)\n+                                              -> bool\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -5216,11 +5245,11 @@ pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n     return true;\n }\n \n-pub fn required_region_bounds(tcx: &ctxt,\n-                              region_bounds: &[ty::Region],\n-                              builtin_bounds: BuiltinBounds,\n-                              trait_bounds: &[Rc<TraitRef>])\n-                              -> Vec<ty::Region>\n+pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n+                                    region_bounds: &[ty::Region],\n+                                    builtin_bounds: BuiltinBounds,\n+                                    trait_bounds: &[Rc<TraitRef<'tcx>>])\n+                                    -> Vec<ty::Region>\n {\n     /*!\n      * Given a type which must meet the builtin bounds and trait\n@@ -5271,7 +5300,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n     }\n }\n \n-pub fn get_tydesc_ty(tcx: &ctxt) -> Result<Ty, String> {\n+pub fn get_tydesc_ty<'tcx>(tcx: &ctxt<'tcx>) -> Result<Ty<'tcx>, String> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         tcx.intrinsic_defs.borrow().get(&tydesc_lang_item).cloned()\n             .expect(\"Failed to resolve TyDesc\")\n@@ -5614,7 +5643,7 @@ impl Variance {\n     }\n }\n \n-pub fn empty_parameter_environment() -> ParameterEnvironment {\n+pub fn empty_parameter_environment<'tcx>() -> ParameterEnvironment<'tcx> {\n     /*!\n      * Construct a parameter environment suitable for static contexts\n      * or other contexts where there are no free type/lifetime\n@@ -5628,12 +5657,12 @@ pub fn empty_parameter_environment() -> ParameterEnvironment {\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n-pub fn construct_parameter_environment(\n-    tcx: &ctxt,\n+pub fn construct_parameter_environment<'tcx>(\n+    tcx: &ctxt<'tcx>,\n     span: Span,\n-    generics: &ty::Generics,\n+    generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment\n+    -> ParameterEnvironment<'tcx>\n {\n     /*! See `ParameterEnvironment` struct def'n for details */\n \n@@ -5708,10 +5737,10 @@ pub fn construct_parameter_environment(\n         }\n     }\n \n-    fn push_types_from_defs(tcx: &ty::ctxt,\n-                            types: &mut subst::VecPerParamSpace<Ty>,\n-                            space: subst::ParamSpace,\n-                            defs: &[TypeParameterDef]) {\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut subst::VecPerParamSpace<Ty<'tcx>>,\n+                                  space: subst::ParamSpace,\n+                                  defs: &[TypeParameterDef<'tcx>]) {\n         for (i, def) in defs.iter().enumerate() {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: \\\n                     space={} def={} index={}\",\n@@ -5723,10 +5752,10 @@ pub fn construct_parameter_environment(\n         }\n     }\n \n-    fn record_region_bounds(tcx: &ty::ctxt,\n-                            space: subst::ParamSpace,\n-                            free_substs: &Substs,\n-                            bound_sets: &[Vec<ty::Region>]) {\n+    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  space: subst::ParamSpace,\n+                                  free_substs: &Substs<'tcx>,\n+                                  bound_sets: &[Vec<ty::Region>]) {\n         for (subst_region, bound_set) in\n             free_substs.regions().get_slice(space).iter().zip(\n                 bound_sets.iter())\n@@ -5796,15 +5825,15 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n         self\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         Ok(ty::node_id_to_type(self, id))\n     }\n \n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>> {\n         self.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.adjustments\n     }\n \n@@ -5826,7 +5855,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<UnboxedClosure>> {\n+                        -> &'a RefCell<DefIdMap<UnboxedClosure<'tcx>>> {\n         &self.unboxed_closures\n     }\n }\n@@ -5920,7 +5949,7 @@ pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T)\n     }\n }\n \n-impl AutoAdjustment {\n+impl<'tcx> AutoAdjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         match *self {\n             AdjustAddEnv(..) => false,\n@@ -5929,18 +5958,18 @@ impl AutoAdjustment {\n     }\n }\n \n-impl AutoDerefRef {\n+impl<'tcx> AutoDerefRef<'tcx> {\n     pub fn is_identity(&self) -> bool {\n         self.autoderefs == 0 && self.autoref.is_none()\n     }\n }\n \n-pub fn liberate_late_bound_regions<HR>(\n-    tcx: &ty::ctxt,\n+pub fn liberate_late_bound_regions<'tcx, HR>(\n+    tcx: &ty::ctxt<'tcx>,\n     scope_id: ast::NodeId,\n     value: &HR)\n     -> HR\n-    where HR : HigherRankedFoldable\n+    where HR : HigherRankedFoldable<'tcx>\n {\n     /*!\n      * Replace any late-bound regions bound in `value` with free variants\n@@ -5952,11 +5981,11 @@ pub fn liberate_late_bound_regions<HR>(\n         |br, _| ty::ReFree(ty::FreeRegion{scope_id: scope_id, bound_region: br})).0\n }\n \n-pub fn erase_late_bound_regions<HR>(\n-    tcx: &ty::ctxt,\n+pub fn erase_late_bound_regions<'tcx, HR>(\n+    tcx: &ty::ctxt<'tcx>,\n     value: &HR)\n     -> HR\n-    where HR : HigherRankedFoldable\n+    where HR : HigherRankedFoldable<'tcx>\n {\n     /*!\n      * Replace any late-bound regions bound in `value` with `'static`.\n@@ -5967,12 +5996,12 @@ pub fn erase_late_bound_regions<HR>(\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n \n-pub fn replace_late_bound_regions<HR>(\n-    tcx: &ty::ctxt,\n+pub fn replace_late_bound_regions<'tcx, HR>(\n+    tcx: &ty::ctxt<'tcx>,\n     value: &HR,\n     mapf: |BoundRegion, DebruijnIndex| -> ty::Region)\n     -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n-    where HR : HigherRankedFoldable\n+    where HR : HigherRankedFoldable<'tcx>\n {\n     /*!\n      * Replaces the late-bound-regions in `value` that are bound by `value`."}, {"sha": "7c6148459d18f9d0b0a59a217800b124f642b6d9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 135, "deletions": 131, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -50,8 +50,8 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+pub trait TypeFoldable<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n /// The TypeFolder trait defines the actual *folding*. There is a\n@@ -73,50 +73,50 @@ pub trait TypeFolder<'tcx> {\n     /// track the Debruijn index nesting level.\n     fn exit_region_binder(&mut self) { }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         super_fold_ty(self, t)\n     }\n \n-    fn fold_mt(&mut self, t: &ty::mt) -> ty::mt {\n+    fn fold_mt(&mut self, t: &ty::mt<'tcx>) -> ty::mt<'tcx> {\n         super_fold_mt(self, t)\n     }\n \n-    fn fold_trait_ref(&mut self, t: &ty::TraitRef) -> ty::TraitRef {\n+    fn fold_trait_ref(&mut self, t: &ty::TraitRef<'tcx>) -> ty::TraitRef<'tcx> {\n         super_fold_trait_ref(self, t)\n     }\n \n-    fn fold_sty(&mut self, sty: &ty::sty) -> ty::sty {\n+    fn fold_sty(&mut self, sty: &ty::sty<'tcx>) -> ty::sty<'tcx> {\n         super_fold_sty(self, sty)\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &subst::Substs)\n-                   -> subst::Substs {\n+                   substs: &subst::Substs<'tcx>)\n+                   -> subst::Substs<'tcx> {\n         super_fold_substs(self, substs)\n     }\n \n     fn fold_fn_sig(&mut self,\n-                sig: &ty::FnSig)\n-                -> ty::FnSig {\n+                sig: &ty::FnSig<'tcx>)\n+                -> ty::FnSig<'tcx> {\n         super_fold_fn_sig(self, sig)\n     }\n \n     fn fold_output(&mut self,\n-                      output: &ty::FnOutput)\n-                      -> ty::FnOutput {\n+                      output: &ty::FnOutput<'tcx>)\n+                      -> ty::FnOutput<'tcx> {\n         super_fold_output(self, output)\n     }\n \n     fn fold_bare_fn_ty(&mut self,\n-                       fty: &ty::BareFnTy)\n-                       -> ty::BareFnTy\n+                       fty: &ty::BareFnTy<'tcx>)\n+                       -> ty::BareFnTy<'tcx>\n     {\n         super_fold_bare_fn_ty(self, fty)\n     }\n \n     fn fold_closure_ty(&mut self,\n-                       fty: &ty::ClosureTy)\n-                       -> ty::ClosureTy {\n+                       fty: &ty::ClosureTy<'tcx>)\n+                       -> ty::ClosureTy<'tcx> {\n         super_fold_closure_ty(self, fty)\n     }\n \n@@ -133,15 +133,16 @@ pub trait TypeFolder<'tcx> {\n         super_fold_existential_bounds(self, s)\n     }\n \n-    fn fold_autoref(&mut self, ar: &ty::AutoRef) -> ty::AutoRef {\n+    fn fold_autoref(&mut self, ar: &ty::AutoRef<'tcx>) -> ty::AutoRef<'tcx> {\n         super_fold_autoref(self, ar)\n     }\n \n-    fn fold_item_substs(&mut self, i: ty::ItemSubsts) -> ty::ItemSubsts {\n+    fn fold_item_substs(&mut self, i: ty::ItemSubsts<'tcx>) -> ty::ItemSubsts<'tcx> {\n         super_fold_item_substs(self, i)\n     }\n \n-    fn fold_obligation(&mut self, o: &traits::Obligation) -> traits::Obligation {\n+    fn fold_obligation(&mut self, o: &traits::Obligation<'tcx>)\n+                       -> traits::Obligation<'tcx> {\n         super_fold_obligation(self, o)\n     }\n }\n@@ -157,53 +158,53 @@ pub trait TypeFolder<'tcx> {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-impl TypeFoldable for () {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n+impl<'tcx> TypeFoldable<'tcx> for () {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n         ()\n     }\n }\n \n-impl<T:TypeFoldable,U:TypeFoldable> TypeFoldable for (T, U) {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Option<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Rc<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_with(folder))\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for ty::Binder<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.enter_region_binder();\n         let result = ty::bind(self.value.fold_with(folder));\n         folder.exit_region_binder();\n         result\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n }\n \n-impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n \n         // Things in the Fn space take place under an additional level\n         // of region binding relative to the other spaces. This is\n@@ -225,88 +226,88 @@ impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n     }\n }\n \n-impl TypeFoldable for ty::TraitStore {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitStore {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n         folder.fold_trait_store(*self)\n     }\n }\n \n-impl TypeFoldable for Ty {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty {\n+impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n     }\n }\n \n-impl TypeFoldable for ty::BareFnTy {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy {\n+impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n         folder.fold_bare_fn_ty(self)\n     }\n }\n \n-impl TypeFoldable for ty::ClosureTy {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n         folder.fold_closure_ty(self)\n     }\n }\n \n-impl TypeFoldable for ty::mt {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt {\n+impl<'tcx> TypeFoldable<'tcx> for ty::mt<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::mt<'tcx> {\n         folder.fold_mt(self)\n     }\n }\n \n-impl TypeFoldable for ty::FnOutput {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput {\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n         folder.fold_output(self)\n     }\n }\n \n-impl TypeFoldable for ty::FnSig {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n         folder.fold_fn_sig(self)\n     }\n }\n \n-impl TypeFoldable for ty::sty {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty {\n+impl<'tcx> TypeFoldable<'tcx> for ty::sty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::sty<'tcx> {\n         folder.fold_sty(self)\n     }\n }\n \n-impl TypeFoldable for ty::TraitRef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         folder.fold_trait_ref(self)\n     }\n }\n \n-impl TypeFoldable for ty::Region {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n     }\n }\n \n-impl TypeFoldable for subst::Substs {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs {\n+impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n         folder.fold_substs(self)\n     }\n }\n \n-impl TypeFoldable for ty::ItemSubsts {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::AutoRef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n         folder.fold_autoref(self)\n     }\n }\n \n-impl TypeFoldable for typeck::MethodOrigin {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::MethodOrigin {\n+impl<'tcx> TypeFoldable<'tcx> for typeck::MethodOrigin<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::MethodOrigin<'tcx> {\n         match *self {\n             typeck::MethodStatic(def_id) => {\n                 typeck::MethodStatic(def_id)\n@@ -332,8 +333,8 @@ impl TypeFoldable for typeck::MethodOrigin {\n     }\n }\n \n-impl TypeFoldable for typeck::vtable_origin {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin {\n+impl<'tcx> TypeFoldable<'tcx> for typeck::vtable_origin<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> typeck::vtable_origin<'tcx> {\n         match *self {\n             typeck::vtable_static(def_id, ref substs, ref origins) => {\n                 let r_substs = substs.fold_with(folder);\n@@ -353,20 +354,20 @@ impl TypeFoldable for typeck::vtable_origin {\n     }\n }\n \n-impl TypeFoldable for ty::BuiltinBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self\n     }\n }\n \n-impl TypeFoldable for ty::ExistentialBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds {\n         folder.fold_existential_bounds(*self)\n     }\n }\n \n-impl TypeFoldable for ty::ParamBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ParamBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParamBounds<'tcx> {\n         ty::ParamBounds {\n             region_bounds: self.region_bounds.fold_with(folder),\n             builtin_bounds: self.builtin_bounds.fold_with(folder),\n@@ -375,8 +376,8 @@ impl TypeFoldable for ty::ParamBounds {\n     }\n }\n \n-impl TypeFoldable for ty::TypeParameterDef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -389,8 +390,8 @@ impl TypeFoldable for ty::TypeParameterDef {\n     }\n }\n \n-impl TypeFoldable for ty::RegionParameterDef {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -401,26 +402,26 @@ impl TypeFoldable for ty::RegionParameterDef {\n     }\n }\n \n-impl TypeFoldable for ty::Generics {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::GenericBounds {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n         ty::GenericBounds {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n         }\n     }\n }\n \n-impl TypeFoldable for ty::UnsizeKind {\n-    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n+impl<'tcx> TypeFoldable<'tcx> for ty::UnsizeKind<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind<'tcx> {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n@@ -436,14 +437,14 @@ impl TypeFoldable for ty::UnsizeKind {\n     }\n }\n \n-impl TypeFoldable for traits::Obligation {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation {\n+impl<'tcx> TypeFoldable<'tcx> for traits::Obligation<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx> {\n         folder.fold_obligation(self)\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.fold_with(folder),\n@@ -452,16 +453,16 @@ impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableBuiltinData<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n         traits::VtableBuiltinData {\n             nested: self.nested.fold_with(folder),\n         }\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<N> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableUnboxedClosure(d, ref s) => {\n@@ -473,8 +474,8 @@ impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n     }\n }\n \n-impl TypeFoldable for traits::VtableParamData {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData {\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData<'tcx> {\n         traits::VtableParamData {\n             bound: self.bound.fold_with(folder),\n         }\n@@ -487,15 +488,15 @@ impl TypeFoldable for traits::VtableParamData {\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                t: Ty)\n-                                                -> Ty {\n+                                                t: Ty<'tcx>)\n+                                                -> Ty<'tcx> {\n     let sty = ty::get(t).sty.fold_with(this);\n     ty::mk_t(this.tcx(), sty)\n }\n \n pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    substs: &subst::Substs)\n-                                                    -> subst::Substs {\n+                                                    substs: &subst::Substs<'tcx>)\n+                                                    -> subst::Substs<'tcx> {\n     let regions = match substs.regions {\n         subst::ErasedRegions => {\n             subst::ErasedRegions\n@@ -510,8 +511,8 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    sig: &ty::FnSig)\n-                                                    -> ty::FnSig\n+                                                    sig: &ty::FnSig<'tcx>)\n+                                                    -> ty::FnSig<'tcx>\n {\n     this.enter_region_binder();\n     let result = super_fold_fn_sig_contents(this, sig);\n@@ -520,35 +521,35 @@ pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                             sig: &ty::FnSig)\n-                                                             -> ty::FnSig\n+                                                             sig: &ty::FnSig<'tcx>)\n+                                                             -> ty::FnSig<'tcx>\n {\n     ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n \n pub fn super_fold_output<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                    output: &ty::FnOutput)\n-                                                    -> ty::FnOutput {\n+                                                    output: &ty::FnOutput<'tcx>)\n+                                                    -> ty::FnOutput<'tcx> {\n     match *output {\n         ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(this)),\n         ty::FnDiverging => ty::FnDiverging\n     }\n }\n \n pub fn super_fold_bare_fn_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::BareFnTy)\n-                                                        -> ty::BareFnTy\n+                                                        fty: &ty::BareFnTy<'tcx>)\n+                                                        -> ty::BareFnTy<'tcx>\n {\n     ty::BareFnTy { sig: fty.sig.fold_with(this),\n                    abi: fty.abi,\n                    fn_style: fty.fn_style }\n }\n \n pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                        fty: &ty::ClosureTy)\n-                                                        -> ty::ClosureTy\n+                                                        fty: &ty::ClosureTy<'tcx>)\n+                                                        -> ty::ClosureTy<'tcx>\n {\n     ty::ClosureTy {\n         store: fty.store.fold_with(this),\n@@ -561,8 +562,8 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                       t: &ty::TraitRef)\n-                                                       -> ty::TraitRef\n+                                                       t: &ty::TraitRef<'tcx>)\n+                                                       -> ty::TraitRef<'tcx>\n {\n     this.enter_region_binder();\n     let result = super_fold_trait_ref_contents(this, t);\n@@ -571,8 +572,8 @@ pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                t: &ty::TraitRef)\n-                                                                -> ty::TraitRef\n+                                                                t: &ty::TraitRef<'tcx>)\n+                                                                -> ty::TraitRef<'tcx>\n {\n     ty::TraitRef {\n         def_id: t.def_id,\n@@ -581,13 +582,15 @@ pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                mt: &ty::mt) -> ty::mt {\n+                                                mt: &ty::mt<'tcx>)\n+                                                -> ty::mt<'tcx> {\n     ty::mt {ty: mt.ty.fold_with(this),\n             mutbl: mt.mutbl}\n }\n \n pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sty: &ty::sty) -> ty::sty {\n+                                                 sty: &ty::sty<'tcx>)\n+                                                 -> ty::sty<'tcx> {\n     match *sty {\n         ty::ty_uniq(typ) => {\n             ty::ty_uniq(typ.fold_with(this))\n@@ -658,8 +661,8 @@ pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                     autoref: &ty::AutoRef)\n-                                                     -> ty::AutoRef\n+                                                     autoref: &ty::AutoRef<'tcx>)\n+                                                     -> ty::AutoRef<'tcx>\n {\n     match *autoref {\n         ty::AutoPtr(r, m, None) => ty::AutoPtr(this.fold_region(r), m, None),\n@@ -676,17 +679,17 @@ pub fn super_fold_autoref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n }\n \n pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         substs: ty::ItemSubsts)\n-                                                         -> ty::ItemSubsts\n+                                                         substs: ty::ItemSubsts<'tcx>)\n+                                                         -> ty::ItemSubsts<'tcx>\n {\n     ty::ItemSubsts {\n         substs: substs.substs.fold_with(this),\n     }\n }\n \n pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n-                                                       obligation: &traits::Obligation)\n-                                                       -> traits::Obligation\n+                                                       obligation: &traits::Obligation<'tcx>)\n+                                                       -> traits::Obligation<'tcx>\n {\n     traits::Obligation {\n         cause: obligation.cause,\n@@ -701,32 +704,32 @@ pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n /**\n  * Designates a \"binder\" for late-bound regions.\n  */\n-pub trait HigherRankedFoldable : Repr {\n+pub trait HigherRankedFoldable<'tcx>: Repr<'tcx> {\n     /// Folds the contents of `self`, ignoring the region binder created\n     /// by `self`.\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n-impl HigherRankedFoldable for ty::FnSig {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+impl<'tcx> HigherRankedFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n         super_fold_fn_sig_contents(folder, self)\n     }\n }\n \n-impl HigherRankedFoldable for ty::TraitRef {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+impl<'tcx> HigherRankedFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n         super_fold_trait_ref_contents(folder, self)\n     }\n }\n \n-impl<T:TypeFoldable+Repr> HigherRankedFoldable for ty::Binder<T> {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> HigherRankedFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         ty::bind(self.value.fold_with(folder))\n     }\n }\n \n-impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n-    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n+    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n         Rc::new((**self).fold_contents(folder))\n     }\n }\n@@ -736,13 +739,13 @@ impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n \n pub struct BottomUpFolder<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n-    pub fldop: |Ty|: 'a -> Ty,\n+    pub fldop: |Ty<'tcx>|: 'a -> Ty<'tcx>,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn fold_ty(&mut self, ty: Ty) -> Ty {\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = super_fold_ty(self, ty);\n         (self.fldop)(t1)\n     }\n@@ -816,7 +819,7 @@ pub struct RegionEraser<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n }\n \n-pub fn erase_regions<T:TypeFoldable>(tcx: &ty::ctxt, t: T) -> T {\n+pub fn erase_regions<'tcx, T: TypeFoldable<'tcx>>(tcx: &ty::ctxt<'tcx>, t: T) -> T {\n     let mut eraser = RegionEraser { tcx: tcx };\n     t.fold_with(&mut eraser)\n }\n@@ -852,7 +855,8 @@ pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<T:TypeFoldable+Repr>(tcx: &ty::ctxt, amount: uint, value: &T) -> T {\n+pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>,\n+                                                            amount: uint, value: &T) -> T {\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n "}, {"sha": "8e04e8b1f79d844ec6de4183d63a925e5aed5672", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -71,26 +71,26 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx>;\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n-    fn ty_infer(&self, span: Span) -> Ty;\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx>;\n \n     /// Returns true if associated types from the given trait and type are\n     /// allowed to be used here and false otherwise.\n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool;\n \n     /// Returns the binding of the given associated type for some type.\n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty;\n+                               -> Ty<'tcx>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -205,11 +205,11 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n-    decl_generics: &ty::Generics,\n-    self_ty: Option<Ty>,\n-    associated_ty: Option<Ty>,\n+    decl_generics: &ty::Generics<'tcx>,\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n-    -> Substs\n+    -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     /*!\n@@ -251,12 +251,12 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     rscope: &RS,\n     span: Span,\n     decl_def_id: ast::DefId,\n-    decl_generics: &ty::Generics,\n-    self_ty: Option<Ty>,\n-    types: Vec<Ty>,\n+    decl_generics: &ty::Generics<'tcx>,\n+    self_ty: Option<Ty<'tcx>>,\n+    types: Vec<Ty<'tcx>>,\n     regions: Vec<ty::Region>,\n-    associated_ty: Option<Ty>)\n-    -> Substs\n+    associated_ty: Option<Ty<'tcx>>)\n+    -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n@@ -377,7 +377,7 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>, Vec<Ty>)\n+                                                    -> (Vec<ty::Region>, Vec<Ty<'tcx>>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -395,7 +395,7 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n \n fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                                              data: &ast::ParenthesizedParameterData)\n-                                             -> Vec<Ty>\n+                                             -> Vec<Ty<'tcx>>\n     where AC: AstConv<'tcx>\n {\n     let binding_rscope = BindingRscope::new();\n@@ -417,9 +417,9 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     ast_trait_ref: &ast::PolyTraitRef,\n-    self_ty: Option<Ty>,\n-    associated_type: Option<Ty>)\n-    -> Rc<ty::TraitRef>\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_type: Option<Ty<'tcx>>)\n+    -> Rc<ty::TraitRef<'tcx>>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n@@ -428,9 +428,9 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty>,\n-                                         associated_type: Option<Ty>)\n-                                         -> Rc<ty::TraitRef>\n+                                         self_ty: Option<Ty<'tcx>>,\n+                                         associated_type: Option<Ty<'tcx>>)\n+                                         -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n {\n@@ -462,10 +462,10 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n-    self_ty: Option<Ty>,\n-    associated_type: Option<Ty>,\n+    self_ty: Option<Ty<'tcx>>,\n+    associated_type: Option<Ty<'tcx>>,\n     path: &ast::Path)\n-    -> ty::TraitRef\n+    -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let trait_def = this.get_trait_def(trait_def_id);\n@@ -504,7 +504,7 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     rscope: &RS,\n     did: ast::DefId,\n     path: &ast::Path)\n-    -> TypeAndSubsts\n+    -> TypeAndSubsts<'tcx>\n {\n     let tcx = this.tcx();\n     let ty::Polytype {\n@@ -533,7 +533,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     rscope: &RS,\n     did: ast::DefId,\n     path: &ast::Path)\n-    -> TypeAndSubsts\n+    -> TypeAndSubsts<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n@@ -589,7 +589,8 @@ fn check_path_args(tcx: &ty::ctxt,\n     }\n }\n \n-pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<Ty> {\n+pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n+                               -> Option<Ty<'tcx>> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -641,7 +642,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n         ast_ty: &ast::Ty)\n-        -> Option<Ty> {\n+        -> Option<Ty<'tcx>> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n         Some(typ) => return Some(typ),\n         None => {}\n@@ -697,8 +698,8 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_mutbl: ast::Mutability,\n         a_seq_ty: &ast::Ty,\n         region: ty::Region,\n-        constr: |Ty| -> Ty)\n-        -> Ty\n+        constr: |Ty<'tcx>| -> Ty<'tcx>)\n+        -> Ty<'tcx>\n {\n     let tcx = this.tcx();\n \n@@ -755,7 +756,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    for_ast_type: &ast::Ty,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n-                                   -> Ty\n+                                   -> Ty<'tcx>\n                                    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n@@ -811,7 +812,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1060,28 +1061,28 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n                                                            a: &ast::Arg,\n-                                                           expected_ty: Option<Ty>)\n-                                                           -> Ty {\n+                                                           expected_ty: Option<Ty<'tcx>>)\n+                                                           -> Ty<'tcx> {\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, &*a.ty),\n     }\n }\n \n-struct SelfInfo<'a> {\n-    untransformed_self_ty: Ty,\n+struct SelfInfo<'a, 'tcx> {\n+    untransformed_self_ty: Ty<'tcx>,\n     explicit_self: &'a ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     fn_style: ast::FnStyle,\n-                    untransformed_self_ty: Ty,\n+                    untransformed_self_ty: Ty<'tcx>,\n                     explicit_self: &ast::ExplicitSelf,\n                     decl: &ast::FnDecl,\n                     abi: abi::Abi)\n-                    -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n+                    -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self,\n@@ -1096,18 +1097,18 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n }\n \n pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, fn_style: ast::FnStyle, abi: abi::Abi,\n-                                              decl: &ast::FnDecl) -> ty::BareFnTy {\n+                                              decl: &ast::FnDecl) -> ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n+fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n                            fn_style: ast::FnStyle,\n                            abi: abi::Abi,\n-                           opt_self_info: Option<SelfInfo>,\n+                           opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n                            decl: &ast::FnDecl)\n-                           -> (ty::BareFnTy,\n+                           -> (ty::BareFnTy<'tcx>,\n                                Option<ty::ExplicitSelfCategory>) {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1229,11 +1230,11 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n+fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n                                     RS:RegionScope>(\n                                     this: &AC,\n                                     rscope: &RS,\n-                                    self_info: &SelfInfo)\n+                                    self_info: &SelfInfo<'a, 'tcx>)\n                                     -> ty::ExplicitSelfCategory\n {\n     return match self_info.explicit_self.node {\n@@ -1319,8 +1320,8 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n-    expected_sig: Option<ty::FnSig>)\n-    -> ty::ClosureTy\n+    expected_sig: Option<ty::FnSig<'tcx>>)\n+    -> ty::ClosureTy<'tcx>\n {\n     debug!(\"ty_of_closure(expected_sig={})\",\n            expected_sig.repr(this.tcx()));\n@@ -1373,7 +1374,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef>],\n+    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1402,7 +1403,7 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     rscope: &RS,\n     span: Span,\n     ast_bounds: &[ast::TyParamBound])\n-    -> Ty\n+    -> Ty<'tcx>\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let ast_bounds: Vec<&ast::TyParamBound> = ast_bounds.iter().collect();\n@@ -1436,7 +1437,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    main_trait_refs: &[Rc<ty::TraitRef>],\n+    main_trait_refs: &[Rc<ty::TraitRef<'tcx>>],\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1483,12 +1484,12 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     }\n }\n \n-pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n-                                span: Span,\n-                                builtin_bounds: ty::BuiltinBounds,\n-                                region_bounds: &[&ast::Lifetime],\n-                                trait_bounds: &[Rc<ty::TraitRef>])\n-                                -> Option<ty::Region>\n+pub fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                      span: Span,\n+                                      builtin_bounds: ty::BuiltinBounds,\n+                                      region_bounds: &[&ast::Lifetime],\n+                                      trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                      -> Option<ty::Region>\n {\n     /*!\n      * Given the bounds on a type parameter / existential type,\n@@ -1552,7 +1553,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     span: Span,\n     builtin_bounds: ty::BuiltinBounds,\n     region_bounds: &[&ast::Lifetime],\n-    trait_bounds: &[Rc<ty::TraitRef>])\n+    trait_bounds: &[Rc<ty::TraitRef<'tcx>>])\n     -> ty::Region\n {\n     /*!"}, {"sha": "7b5a37148c033d80176394849a0bbd2a2c506411", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -27,7 +27,8 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n-pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: Ty) {\n+pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                           pat: &ast::Pat, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -207,8 +208,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: Ty) {\n     }\n }\n \n-pub fn check_dereferencable(pcx: &pat_ctxt, span: Span, expected: Ty,\n-                            inner: &ast::Pat) -> bool {\n+pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                      span: Span, expected: Ty<'tcx>,\n+                                      inner: &ast::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n     match infer::resolve_type(\n@@ -290,9 +292,9 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n     pub map: PatIdMap,\n }\n \n-pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n-                        path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n-                        etc: bool, expected: Ty) {\n+pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n+                                  path: &ast::Path, fields: &[Spanned<ast::FieldPat>],\n+                                  etc: bool, expected: Ty<'tcx>) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -349,9 +351,9 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n                             variant_def_id, etc);\n }\n \n-pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n-                      path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n-                      expected: Ty) {\n+pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n+                                path: &ast::Path, subpats: &Option<Vec<P<ast::Pat>>>,\n+                                expected: Ty<'tcx>) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -434,12 +436,12 @@ pub fn check_pat_enum(pcx: &pat_ctxt, pat: &ast::Pat,\n /// `struct_fields` describes the type of each field of the struct.\n /// `struct_id` is the ID of the struct.\n /// `etc` is true if the pattern said '...' and false otherwise.\n-pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n-                               span: Span,\n-                               fields: &[Spanned<ast::FieldPat>],\n-                               struct_fields: &[ty::field],\n-                               struct_id: ast::DefId,\n-                               etc: bool) {\n+pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n+                                         span: Span,\n+                                         fields: &[Spanned<ast::FieldPat>],\n+                                         struct_fields: &[ty::field<'tcx>],\n+                                         struct_id: ast::DefId,\n+                                         etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the struct fields' types."}, {"sha": "1e45d059b849ba018c79427659bae56d06639d0f", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -23,22 +23,24 @@ use util::ppaux::Repr;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n+pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     suptype_with_fn(fcx, sp, false, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn subtype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n+pub fn subtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     suptype_with_fn(fcx, sp, true, actual, expected,\n         |sp, a, e, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: &FnCtxt,\n-                       sp: Span,\n-                       b_is_expected: bool,\n-                       ty_a: Ty,\n-                       ty_b: Ty,\n-                       handle_err: |Span, Ty, Ty, &ty::type_err|) {\n+pub fn suptype_with_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 sp: Span,\n+                                 b_is_expected: bool,\n+                                 ty_a: Ty<'tcx>,\n+                                 ty_b: Ty<'tcx>,\n+                                 handle_err: |Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>|) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {\n@@ -49,7 +51,8 @@ pub fn suptype_with_fn(fcx: &FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n+pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                        expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -59,7 +62,8 @@ pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: Ty, actual: Ty) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: &FnCtxt, sp: Span, expected: Ty, expr: &ast::Expr) {\n+pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                        expected: Ty<'tcx>, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),"}, {"sha": "8a337421b87e2c0feeda8a1b648602d4418351b8", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -33,34 +33,33 @@ struct ConfirmContext<'a, 'tcx:'a> {\n     self_expr: &'a ast::Expr,\n }\n \n-struct InstantiatedMethodSig {\n+struct InstantiatedMethodSig<'tcx> {\n     /// Function signature of the method being invoked. The 0th\n     /// argument is the receiver.\n-    method_sig: ty::FnSig,\n+    method_sig: ty::FnSig<'tcx>,\n \n     /// Substitutions for all types/early-bound-regions declared on\n     /// the method.\n-    all_substs: subst::Substs,\n+    all_substs: subst::Substs<'tcx>,\n \n     /// Substitution to use when adding obligations from the method\n     /// bounds. Normally equal to `all_substs` except for object\n     /// receivers. See FIXME in instantiate_method_sig() for\n     /// explanation.\n-    method_bounds_substs: subst::Substs,\n+    method_bounds_substs: subst::Substs<'tcx>,\n \n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n-    method_bounds: ty::GenericBounds,\n+    method_bounds: ty::GenericBounds<'tcx>,\n }\n \n-\n-pub fn confirm(fcx: &FnCtxt,\n-               span: Span,\n-               self_expr: &ast::Expr,\n-               unadjusted_self_ty: Ty,\n-               pick: probe::Pick,\n-               supplied_method_types: Vec<Ty>)\n-               -> MethodCallee\n+pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                         span: Span,\n+                         self_expr: &ast::Expr,\n+                         unadjusted_self_ty: Ty<'tcx>,\n+                         pick: probe::Pick<'tcx>,\n+                         supplied_method_types: Vec<Ty<'tcx>>)\n+                         -> MethodCallee<'tcx>\n {\n     debug!(\"confirm(unadjusted_self_ty={}, pick={}, supplied_method_types={})\",\n            unadjusted_self_ty.repr(fcx.tcx()),\n@@ -81,10 +80,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn confirm(&mut self,\n-               unadjusted_self_ty: Ty,\n-               pick: probe::Pick,\n-               supplied_method_types: Vec<Ty>)\n-               -> MethodCallee\n+               unadjusted_self_ty: Ty<'tcx>,\n+               pick: probe::Pick<'tcx>,\n+               supplied_method_types: Vec<Ty<'tcx>>)\n+               -> MethodCallee<'tcx>\n     {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick.adjustment);\n@@ -136,9 +135,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     // ADJUSTMENTS\n \n     fn adjust_self_ty(&mut self,\n-                      unadjusted_self_ty: Ty,\n+                      unadjusted_self_ty: Ty<'tcx>,\n                       adjustment: &probe::PickAdjustment)\n-                      -> Ty\n+                      -> Ty<'tcx>\n     {\n         // Construct the actual adjustment and write it into the table\n         let auto_deref_ref = self.create_ty_adjustment(adjustment);\n@@ -164,7 +163,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn create_ty_adjustment(&mut self,\n                             adjustment: &probe::PickAdjustment)\n-                            -> ty::AutoDerefRef\n+                            -> ty::AutoDerefRef<'tcx>\n     {\n         match *adjustment {\n             probe::AutoDeref(num) => {\n@@ -191,9 +190,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     //\n \n     fn fresh_receiver_substs(&mut self,\n-                             self_ty: Ty,\n-                             pick: &probe::Pick)\n-                             -> (subst::Substs, MethodOrigin)\n+                             self_ty: Ty<'tcx>,\n+                             pick: &probe::Pick<'tcx>)\n+                             -> (subst::Substs<'tcx>, MethodOrigin<'tcx>)\n     {\n         /*!\n          * Returns a set of substitutions for the method *receiver*\n@@ -292,8 +291,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn extract_trait_ref<R>(&mut self,\n-                            self_ty: Ty,\n-                            closure: |&mut ConfirmContext<'a,'tcx>, Ty, &ty::TyTrait| -> R)\n+                            self_ty: Ty<'tcx>,\n+                            closure: |&mut ConfirmContext<'a,'tcx>,\n+                                      Ty<'tcx>, &ty::TyTrait<'tcx>| -> R)\n                             -> R\n     {\n         // If we specified that this is an object method, then the\n@@ -323,9 +323,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn instantiate_method_substs(&mut self,\n-                                 pick: &probe::Pick,\n-                                 supplied_method_types: Vec<Ty>)\n-                                 -> (Vec<Ty>, Vec<ty::Region>)\n+                                 pick: &probe::Pick<'tcx>,\n+                                 supplied_method_types: Vec<Ty<'tcx>>)\n+                                 -> (Vec<Ty<'tcx>>, Vec<ty::Region>)\n     {\n         // Determine the values for the generic parameters of the method.\n         // If they were not explicitly supplied, just construct fresh\n@@ -361,8 +361,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn unify_receivers(&mut self,\n-                       self_ty: Ty,\n-                       method_self_ty: Ty)\n+                       self_ty: Ty<'tcx>,\n+                       method_self_ty: Ty<'tcx>)\n     {\n         match self.fcx.mk_subty(false, infer::Misc(self.span), self_ty, method_self_ty) {\n             Ok(_) => {}\n@@ -381,9 +381,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     //\n \n     fn instantiate_method_sig(&mut self,\n-                              pick: &probe::Pick,\n-                              all_substs: subst::Substs)\n-                              -> InstantiatedMethodSig\n+                              pick: &probe::Pick<'tcx>,\n+                              all_substs: subst::Substs<'tcx>)\n+                              -> InstantiatedMethodSig<'tcx>\n     {\n         // If this method comes from an impl (as opposed to a trait),\n         // it may have late-bound regions from the impl that appear in\n@@ -457,9 +457,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn add_obligations(&mut self,\n-                       pick: &probe::Pick,\n-                       method_bounds_substs: &subst::Substs,\n-                       method_bounds: &ty::GenericBounds) {\n+                       pick: &probe::Pick<'tcx>,\n+                       method_bounds_substs: &subst::Substs<'tcx>,\n+                       method_bounds: &ty::GenericBounds<'tcx>) {\n         debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n                pick.repr(self.tcx()),\n                method_bounds_substs.repr(self.tcx()),\n@@ -647,9 +647,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::TraitRef>,\n+              source_trait_ref: Rc<ty::TraitRef<'tcx>>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::TraitRef>\n+              -> Rc<ty::TraitRef<'tcx>>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n             if super_trait_ref.def_id == target_trait_def_id {\n@@ -665,16 +665,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0\n     }\n }\n \n-fn wrap_autoref(mut deref: ty::AutoDerefRef,\n-                base_fn: |Option<Box<ty::AutoRef>>| -> ty::AutoRef)\n-                -> ty::AutoDerefRef {\n+fn wrap_autoref<'tcx>(mut deref: ty::AutoDerefRef<'tcx>,\n+                      base_fn: |Option<Box<ty::AutoRef<'tcx>>>| -> ty::AutoRef<'tcx>)\n+                      -> ty::AutoDerefRef<'tcx> {\n     let autoref = mem::replace(&mut deref.autoref, None);\n     let autoref = autoref.map(|r| box r);\n     deref.autoref = Some(base_fn(autoref));"}, {"sha": "69a55bf0906a5be671a0adc4ccf6f1f49506c517", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -56,12 +56,12 @@ pub enum CandidateSource {\n \n type MethodIndex = uint; // just for doc purposes\n \n-pub fn exists(fcx: &FnCtxt,\n-              span: Span,\n-              method_name: ast::Name,\n-              self_ty: Ty,\n-              call_expr_id: ast::NodeId)\n-              -> bool\n+pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        span: Span,\n+                        method_name: ast::Name,\n+                        self_ty: Ty<'tcx>,\n+                        call_expr_id: ast::NodeId)\n+                        -> bool\n {\n     /*!\n      * Determines whether the type `self_ty` supports a method name `method_name` or not.\n@@ -74,14 +74,14 @@ pub fn exists(fcx: &FnCtxt,\n     }\n }\n \n-pub fn lookup(fcx: &FnCtxt,\n-              span: Span,\n-              method_name: ast::Name,\n-              self_ty: Ty,\n-              supplied_method_types: Vec<Ty>,\n-              call_expr_id: ast::NodeId,\n-              self_expr: &ast::Expr)\n-              -> Result<MethodCallee, MethodError>\n+pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        span: Span,\n+                        method_name: ast::Name,\n+                        self_ty: Ty<'tcx>,\n+                        supplied_method_types: Vec<Ty<'tcx>>,\n+                        call_expr_id: ast::NodeId,\n+                        self_expr: &ast::Expr)\n+                        -> Result<MethodCallee<'tcx>, MethodError>\n {\n     /*!\n      * Performs method lookup. If lookup is successful, it will return the callee\n@@ -115,9 +115,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                  self_expr: Option<&'a ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n-                                 self_ty: Ty,\n-                                 opt_input_types: Option<Vec<Ty>>)\n-                                 -> Option<MethodCallee>\n+                                 self_ty: Ty<'tcx>,\n+                                 opt_input_types: Option<Vec<Ty<'tcx>>>)\n+                                 -> Option<MethodCallee<'tcx>>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n                              ty::AutoDerefRef { autoderefs: 0, autoref: None },\n@@ -129,10 +129,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                           self_expr: Option<&'a ast::Expr>,\n                                           m_name: ast::Name,\n                                           trait_def_id: DefId,\n-                                          autoderefref: ty::AutoDerefRef,\n-                                          self_ty: Ty,\n-                                          opt_input_types: Option<Vec<Ty>>)\n-                                          -> Option<MethodCallee>\n+                                          autoderefref: ty::AutoDerefRef<'tcx>,\n+                                          self_ty: Ty<'tcx>,\n+                                          opt_input_types: Option<Vec<Ty<'tcx>>>)\n+                                          -> Option<MethodCallee<'tcx>>\n {\n     /*!\n      * `lookup_in_trait_adjusted` is used for overloaded operators. It\n@@ -308,11 +308,11 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     Some(callee)\n }\n \n-pub fn report_error(fcx: &FnCtxt,\n-                    span: Span,\n-                    rcvr_ty: Ty,\n-                    method_name: ast::Name,\n-                    error: MethodError)\n+pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              rcvr_ty: Ty<'tcx>,\n+                              method_name: ast::Name,\n+                              error: MethodError)\n {\n     match error {\n         NoMatch(static_sources) => {\n@@ -408,10 +408,10 @@ pub fn report_error(fcx: &FnCtxt,\n     }\n }\n \n-fn trait_method(tcx: &ty::ctxt,\n-                trait_def_id: ast::DefId,\n-                method_name: ast::Name)\n-                -> Option<(uint, Rc<ty::Method>)>\n+fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      trait_def_id: ast::DefId,\n+                      method_name: ast::Name)\n+                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     /*!\n      * Find method with name `method_name` defined in `trait_def_id` and return it,\n@@ -426,10 +426,10 @@ fn trait_method(tcx: &ty::ctxt,\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n }\n \n-fn impl_method(tcx: &ty::ctxt,\n-               impl_def_id: ast::DefId,\n-               method_name: ast::Name)\n-               -> Option<Rc<ty::Method>>\n+fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     impl_def_id: ast::DefId,\n+                     method_name: ast::Name)\n+                     -> Option<Rc<ty::Method<'tcx>>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();"}, {"sha": "921fd5bed8bd09e099c3c7a49dcebaaadf7950df", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 98, "deletions": 83, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -37,49 +37,50 @@ struct ProbeContext<'a, 'tcx:'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     span: Span,\n     method_name: ast::Name,\n-    steps: Rc<Vec<CandidateStep>>,\n+    steps: Rc<Vec<CandidateStep<'tcx>>>,\n     opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>,\n-    inherent_candidates: Vec<Candidate>,\n-    extension_candidates: Vec<Candidate>,\n+    inherent_candidates: Vec<Candidate<'tcx>>,\n+    extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n     static_candidates: Vec<CandidateSource>,\n }\n \n-struct CandidateStep {\n-    self_ty: Ty,\n+struct CandidateStep<'tcx> {\n+    self_ty: Ty<'tcx>,\n     adjustment: PickAdjustment,\n }\n \n-struct Candidate {\n-    xform_self_ty: Ty,\n-    method_ty: Rc<ty::Method>,\n-    kind: CandidateKind,\n+struct Candidate<'tcx> {\n+    xform_self_ty: Ty<'tcx>,\n+    method_ty: Rc<ty::Method<'tcx>>,\n+    kind: CandidateKind<'tcx>,\n }\n \n-enum CandidateKind {\n-    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs),\n-    ObjectCandidate(MethodObject),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef>, subst::Substs, MethodIndex),\n+enum CandidateKind<'tcx> {\n+    InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n+    ObjectCandidate(MethodObject<'tcx>),\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n+                           subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::TraitRef>, MethodIndex),\n+    WhereClauseCandidate(Rc<ty::TraitRef<'tcx>>, MethodIndex),\n }\n \n-pub struct Pick {\n-    pub method_ty: Rc<ty::Method>,\n+pub struct Pick<'tcx> {\n+    pub method_ty: Rc<ty::Method<'tcx>>,\n     pub adjustment: PickAdjustment,\n-    pub kind: PickKind,\n+    pub kind: PickKind<'tcx>,\n }\n \n #[deriving(Clone,Show)]\n-pub enum PickKind {\n+pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::TraitRef>, MethodIndex),\n+    WhereClausePick(/* Trait */ Rc<ty::TraitRef<'tcx>>, MethodIndex),\n }\n \n-pub type PickResult = Result<Pick, MethodError>;\n+pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n \n // This is a kind of \"abstracted\" version of ty::AutoAdjustment.  The\n // difference is that it doesn't embed any regions or other\n@@ -105,12 +106,12 @@ pub enum PickAdjustment {\n     AutoRef(ast::Mutability, Box<PickAdjustment>),\n }\n \n-pub fn probe(fcx: &FnCtxt,\n-             span: Span,\n-             method_name: ast::Name,\n-             self_ty: Ty,\n-             call_expr_id: ast::NodeId)\n-             -> PickResult\n+pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                       span: Span,\n+                       method_name: ast::Name,\n+                       self_ty: Ty<'tcx>,\n+                       call_expr_id: ast::NodeId)\n+                       -> PickResult<'tcx>\n {\n     debug!(\"probe(self_ty={}, method_name={}, call_expr_id={})\",\n            self_ty.repr(fcx.tcx()),\n@@ -157,7 +158,10 @@ pub fn probe(fcx: &FnCtxt,\n     })\n }\n \n-fn create_steps(fcx: &FnCtxt, span: Span, self_ty: Ty) -> Vec<CandidateStep> {\n+fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                          span: Span,\n+                          self_ty: Ty<'tcx>)\n+                          -> Vec<CandidateStep<'tcx>> {\n     let mut steps = Vec::new();\n \n     let (fully_dereferenced_ty, dereferences, _) =\n@@ -195,7 +199,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn new(fcx: &'a FnCtxt<'a,'tcx>,\n            span: Span,\n            method_name: ast::Name,\n-           steps: Vec<CandidateStep>,\n+           steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<fast_reject::SimplifiedType>>)\n            -> ProbeContext<'a,'tcx>\n     {\n@@ -230,7 +234,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn assemble_probe(&mut self, self_ty: Ty) {\n+    fn assemble_probe(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_probe: self_ty={}\",\n                self_ty.repr(self.tcx()));\n \n@@ -293,8 +297,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n-                                                self_ty: Ty,\n-                                                principal: &ty::TraitRef,\n+                                                self_ty: Ty<'tcx>,\n+                                                principal: &ty::TraitRef<'tcx>,\n                                                 _bounds: ty::ExistentialBounds) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n@@ -353,8 +357,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self,\n-                                           _rcvr_ty: Ty,\n-                                           param_ty: ty::ParamTy) {\n+                                               _rcvr_ty: Ty<'tcx>,\n+                                               param_ty: ty::ParamTy) {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let ty::ParamTy { space, idx: index, .. } = param_ty;\n@@ -397,11 +401,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::TraitRef>],\n-        mk_cand: |this: &mut ProbeContext,\n-                  tr: Rc<ty::TraitRef>,\n-                  m: Rc<ty::Method>,\n-                  method_num: uint|)\n+        bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n+                          tr: Rc<ty::TraitRef<'tcx>>,\n+                          m: Rc<ty::Method<'tcx>>,\n+                          method_num: uint|)\n     {\n         let tcx = self.tcx();\n         let mut cache = HashSet::new();\n@@ -475,7 +479,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n-                                                     method: Rc<ty::Method>,\n+                                                     method: Rc<ty::Method<'tcx>>,\n                                                      method_index: uint)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n@@ -539,7 +543,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_unboxed_closure_candidates(&mut self,\n                                            trait_def_id: ast::DefId,\n-                                           method_ty: Rc<ty::Method>,\n+                                           method_ty: Rc<ty::Method<'tcx>>,\n                                            method_index: uint)\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -600,7 +604,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // THE ACTUAL SEARCH\n \n-    fn pick(mut self) -> PickResult {\n+    fn pick(mut self) -> PickResult<'tcx> {\n         let steps = self.steps.clone();\n \n         for step in steps.iter() {\n@@ -615,7 +619,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         Err(NoMatch(self.static_candidates))\n     }\n \n-    fn pick_step(&mut self, step: &CandidateStep) -> Option<PickResult> {\n+    fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n \n         if ty::type_is_error(step.self_ty) {\n@@ -641,15 +645,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_adjusted_method(&mut self,\n-                            step: &CandidateStep)\n-                            -> Option<PickResult>\n+                            step: &CandidateStep<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n     {\n         self.pick_method(step.self_ty).map(|r| self.adjust(r, step.adjustment.clone()))\n     }\n \n     fn pick_autorefd_method(&mut self,\n-                            step: &CandidateStep)\n-                            -> Option<PickResult>\n+                            step: &CandidateStep<'tcx>)\n+                            -> Option<PickResult<'tcx>>\n     {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n@@ -658,8 +662,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn pick_autorefrefd_method(&mut self,\n-                               step: &CandidateStep)\n-                               -> Option<PickResult>\n+                               step: &CandidateStep<'tcx>)\n+                               -> Option<PickResult<'tcx>>\n     {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n@@ -671,8 +675,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn search_mutabilities(&mut self,\n                            mk_adjustment: |ast::Mutability| -> PickAdjustment,\n-                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty)\n-                           -> Option<PickResult>\n+                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty<'tcx>)\n+                           -> Option<PickResult<'tcx>>\n     {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n@@ -690,7 +694,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             .nth(0)\n     }\n \n-    fn adjust(&mut self, result: PickResult, adjustment: PickAdjustment) -> PickResult {\n+    fn adjust(&mut self,\n+              result: PickResult<'tcx>,\n+              adjustment: PickAdjustment)\n+              -> PickResult<'tcx> {\n         match result {\n             Err(e) => Err(e),\n             Ok(mut pick) => {\n@@ -700,7 +707,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n-    fn pick_method(&mut self, self_ty: Ty) -> Option<PickResult> {\n+    fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n@@ -715,7 +722,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.consider_candidates(self_ty, self.extension_candidates[])\n     }\n \n-    fn consider_candidates(&self, self_ty: Ty, probes: &[Candidate]) -> Option<PickResult> {\n+    fn consider_candidates(&self,\n+                           self_ty: Ty<'tcx>,\n+                           probes: &[Candidate<'tcx>])\n+                           -> Option<PickResult<'tcx>> {\n         let mut applicable_candidates: Vec<_> =\n             probes.iter()\n                   .filter(|&probe| self.consider_probe(self_ty, probe))\n@@ -741,7 +751,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn consider_probe(&self, self_ty: Ty, probe: &Candidate) -> bool {\n+    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n         debug!(\"consider_probe: self_ty={} probe={}\",\n                self_ty.repr(self.tcx()),\n                probe.repr(self.tcx()));\n@@ -797,7 +807,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate]) -> Option<Pick> {\n+    fn collapse_candidates_to_trait_pick(&self,\n+                                         probes: &[&Candidate<'tcx>])\n+                                         -> Option<Pick<'tcx>> {\n         /*!\n          * Sometimes we get in a situation where we have multiple\n          * probes that are all impls of the same trait, but we don't\n@@ -844,7 +856,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn make_sub_ty(&self, sub: Ty, sup: Ty) -> infer::ures {\n+    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::ures<'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n \n@@ -874,7 +886,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.static_candidates.push(source);\n     }\n \n-    fn xform_self_ty(&self, method: &Rc<ty::Method>, substs: &subst::Substs) -> Ty {\n+    fn xform_self_ty(&self,\n+                     method: &Rc<ty::Method<'tcx>>,\n+                     substs: &subst::Substs<'tcx>)\n+                     -> Ty<'tcx> {\n         debug!(\"xform_self_ty(self_ty={}, substs={})\",\n                method.fty.sig.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n@@ -922,7 +937,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn impl_substs(&self,\n                    impl_def_id: ast::DefId)\n-                   -> subst::Substs\n+                   -> subst::Substs<'tcx>\n     {\n         let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n \n@@ -938,7 +953,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n \n     fn erase_late_bound_regions<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         /*!\n          * Replace late-bound-regions bound by `value` with `'static`\n@@ -971,10 +986,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     }\n }\n \n-fn impl_method(tcx: &ty::ctxt,\n-               impl_def_id: ast::DefId,\n-               method_name: ast::Name)\n-               -> Option<Rc<ty::Method>>\n+fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     impl_def_id: ast::DefId,\n+                     method_name: ast::Name)\n+                     -> Option<Rc<ty::Method<'tcx>>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n@@ -985,10 +1000,10 @@ fn impl_method(tcx: &ty::ctxt,\n         .and_then(|item| item.as_opt_method())\n }\n \n-fn trait_method(tcx: &ty::ctxt,\n-                trait_def_id: ast::DefId,\n-                method_name: ast::Name)\n-                -> Option<(uint, Rc<ty::Method>)>\n+fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      trait_def_id: ast::DefId,\n+                      method_name: ast::Name)\n+                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     /*!\n      * Find method with name `method_name` defined in `trait_def_id` and return it,\n@@ -1005,10 +1020,10 @@ fn trait_method(tcx: &ty::ctxt,\n \n // Determine the index of a method in the list of all methods belonging\n // to a trait and its supertraits.\n-fn get_method_index(tcx: &ty::ctxt,\n-                    trait_ref: &ty::TraitRef,\n-                    subtrait: Rc<ty::TraitRef>,\n-                    n_method: uint) -> uint {\n+fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          trait_ref: &ty::TraitRef<'tcx>,\n+                          subtrait: Rc<ty::TraitRef<'tcx>>,\n+                          n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until\n@@ -1032,8 +1047,8 @@ fn get_method_index(tcx: &ty::ctxt,\n     method_count + n_method\n }\n \n-impl Candidate {\n-    fn to_unadjusted_pick(&self) -> Pick {\n+impl<'tcx> Candidate<'tcx> {\n+    fn to_unadjusted_pick(&self) -> Pick<'tcx> {\n         Pick {\n             method_ty: self.method_ty.clone(),\n             adjustment: AutoDeref(0),\n@@ -1091,16 +1106,16 @@ impl Candidate {\n     }\n }\n \n-impl Repr for Candidate {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Candidate<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Candidate(xform_self_ty={}, kind={})\",\n                 self.xform_self_ty.repr(tcx),\n                 self.kind.repr(tcx))\n     }\n }\n \n-impl Repr for CandidateKind {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             InherentImplCandidate(ref a, ref b) =>\n                 format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n@@ -1117,28 +1132,28 @@ impl Repr for CandidateKind {\n     }\n }\n \n-impl Repr for CandidateStep {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for CandidateStep<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"CandidateStep({},{})\",\n                 self.self_ty.repr(tcx),\n                 self.adjustment)\n     }\n }\n \n-impl Repr for PickAdjustment {\n+impl<'tcx> Repr<'tcx> for PickAdjustment {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for PickKind {\n+impl<'tcx> Repr<'tcx> for PickKind<'tcx> {\n     fn repr(&self, _tcx: &ty::ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for Pick {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Pick<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"Pick(method_ty={}, adjustment={}, kind={})\",\n                 self.method_ty.repr(tcx),\n                 self.adjustment,"}, {"sha": "dcc5cfa760eaad971764f3ffe186e3a66a695680", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 345, "deletions": 333, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -160,22 +160,22 @@ pub mod wf;\n /// share the inherited fields.\n pub struct Inherited<'a, 'tcx: 'a> {\n     infcx: infer::InferCtxt<'a, 'tcx>,\n-    locals: RefCell<NodeMap<Ty>>,\n-    param_env: ty::ParameterEnvironment,\n+    locals: RefCell<NodeMap<Ty<'tcx>>>,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n \n     // Temporary tables:\n-    node_types: RefCell<NodeMap<Ty>>,\n-    item_substs: RefCell<NodeMap<ty::ItemSubsts>>,\n-    adjustments: RefCell<NodeMap<ty::AutoAdjustment>>,\n-    method_map: MethodMap,\n+    node_types: RefCell<NodeMap<Ty<'tcx>>>,\n+    item_substs: RefCell<NodeMap<ty::ItemSubsts<'tcx>>>,\n+    adjustments: RefCell<NodeMap<ty::AutoAdjustment<'tcx>>>,\n+    method_map: MethodMap<'tcx>,\n     upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n-    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure>>,\n-    object_cast_map: ObjectCastMap,\n+    unboxed_closures: RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>>,\n+    object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n     // one is never copied into the tcx: it is only used by regionck.\n-    fn_sig_map: RefCell<NodeMap<Vec<Ty>>>,\n+    fn_sig_map: RefCell<NodeMap<Vec<Ty<'tcx>>>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -201,29 +201,29 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // regionck to be sure that it has found *all* the region\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n-    region_obligations: RefCell<NodeMap<Vec<RegionObligation>>>,\n+    region_obligations: RefCell<NodeMap<Vec<RegionObligation<'tcx>>>>,\n \n     // Tracks trait obligations incurred during this function body.\n-    fulfillment_cx: RefCell<traits::FulfillmentContext>,\n+    fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n }\n \n-struct RegionObligation {\n+struct RegionObligation<'tcx> {\n     sub_region: ty::Region,\n-    sup_type: Ty,\n-    origin: infer::SubregionOrigin,\n+    sup_type: Ty<'tcx>,\n+    origin: infer::SubregionOrigin<'tcx>,\n }\n \n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n-enum Expectation {\n+enum Expectation<'tcx> {\n     /// We know nothing about what type this expression should have.\n     NoExpectation,\n \n     /// This expression should have the type given (or some subtype)\n-    ExpectHasType(Ty),\n+    ExpectHasType(Ty<'tcx>),\n \n     /// This expression will be cast to the `Ty`\n-    ExpectCastableToType(Ty),\n+    ExpectCastableToType(Ty<'tcx>),\n }\n \n #[deriving(Clone)]\n@@ -282,7 +282,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     // expects the types within the function to be consistent.\n     err_count_on_creation: uint,\n \n-    ret_ty: ty::FnOutput,\n+    ret_ty: ty::FnOutput<'tcx>,\n \n     ps: RefCell<FnStyleState>,\n \n@@ -295,14 +295,14 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n         Ok(self.node_ty(id))\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n-                      -> Option<Ty> {\n+                      -> Option<Ty<'tcx>> {\n         self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n@@ -318,14 +318,15 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self) -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+    fn unboxed_closures<'a>(&'a self)\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.inh.unboxed_closures\n     }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           param_env: ty::ParameterEnvironment)\n+           param_env: ty::ParameterEnvironment<'tcx>)\n            -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n@@ -348,7 +349,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                inh: &'a Inherited<'a, 'tcx>,\n-                               rty: ty::FnOutput,\n+                               rty: ty::FnOutput<'tcx>,\n                                body_id: ast::NodeId)\n                                -> FnCtxt<'a, 'tcx> {\n     FnCtxt {\n@@ -394,12 +395,12 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_errors();\n }\n \n-fn check_bare_fn(ccx: &CrateCtxt,\n-                 decl: &ast::FnDecl,\n-                 body: &ast::Block,\n-                 id: ast::NodeId,\n-                 fty: Ty,\n-                 param_env: ty::ParameterEnvironment) {\n+fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           decl: &ast::FnDecl,\n+                           body: &ast::Block,\n+                           id: ast::NodeId,\n+                           fty: Ty<'tcx>,\n+                           param_env: ty::ParameterEnvironment<'tcx>) {\n     // Compute the fty from point of view of inside fn\n     // (replace any type-scheme with a type)\n     let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n@@ -425,7 +426,7 @@ struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n-    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty>) -> Ty {\n+    fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n@@ -507,7 +508,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       fn_style: ast::FnStyle,\n                       fn_style_id: ast::NodeId,\n-                      fn_sig: &ty::FnSig,\n+                      fn_sig: &ty::FnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n@@ -719,9 +720,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn check_method_body(ccx: &CrateCtxt,\n-                     item_generics: &ty::Generics,\n-                     method: &ast::Method) {\n+fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               item_generics: &ty::Generics<'tcx>,\n+                               method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n      *\n@@ -752,11 +753,11 @@ fn check_method_body(ccx: &CrateCtxt,\n                   param_env);\n }\n \n-fn check_impl_items_against_trait(ccx: &CrateCtxt,\n-                                  impl_span: Span,\n-                                  ast_trait_ref: &ast::TraitRef,\n-                                  impl_trait_ref: &ty::TraitRef,\n-                                  impl_items: &[ast::ImplItem]) {\n+fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                            impl_span: Span,\n+                                            ast_trait_ref: &ast::TraitRef,\n+                                            impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                            impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_items = ty::trait_items(tcx, impl_trait_ref.def_id);\n@@ -927,12 +928,12 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n  * - trait_m: the method in the trait\n  * - trait_to_impl_substs: the substitutions used on the type of the trait\n  */\n-fn compare_impl_method(tcx: &ty::ctxt,\n-                       impl_m: &ty::Method,\n-                       impl_m_span: Span,\n-                       impl_m_body_id: ast::NodeId,\n-                       trait_m: &ty::Method,\n-                       impl_trait_ref: &ty::TraitRef) {\n+fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             impl_m: &ty::Method<'tcx>,\n+                             impl_m_span: Span,\n+                             impl_m_body_id: ast::NodeId,\n+                             trait_m: &ty::Method<'tcx>,\n+                             impl_trait_ref: &ty::TraitRef<'tcx>) {\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n@@ -1236,15 +1237,15 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     // parameters.\n     infcx.resolve_regions_and_report_errors();\n \n-    fn check_region_bounds_on_impl_method(tcx: &ty::ctxt,\n-                                          span: Span,\n-                                          impl_m: &ty::Method,\n-                                          impl_m_body_id: ast::NodeId,\n-                                          trait_generics: &ty::Generics,\n-                                          impl_generics: &ty::Generics,\n-                                          trait_to_skol_substs: &Substs,\n-                                          impl_to_skol_substs: &Substs)\n-                                          -> bool\n+    fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                span: Span,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m_body_id: ast::NodeId,\n+                                                trait_generics: &ty::Generics<'tcx>,\n+                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_to_skol_substs: &Substs<'tcx>,\n+                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                -> bool\n     {\n         /*!\n \n@@ -1514,8 +1515,8 @@ fn check_cast(fcx: &FnCtxt,\n         span_err!(fcx.tcx().sess, span, E0054,\n             \"cannot cast as `bool`, compare with zero instead\");\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible(fcx: &FnCtxt, sp: Span,\n-                            t1: Ty, t2: Ty) -> bool {\n+        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n             match ty::get(t1).sty {\n                 ty::ty_vec(_, Some(_)) => {}\n                 _ => return false\n@@ -1580,15 +1581,15 @@ fn check_cast(fcx: &FnCtxt,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n-    fn ty_infer(&self, _span: Span) -> Ty {\n+    fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.infcx().next_ty_var()\n     }\n \n@@ -1599,10 +1600,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<Ty>,\n+                               _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n         ty::mk_err()\n     }\n@@ -1642,7 +1643,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         format!(\"{}\", self as *const FnCtxt)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n         match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -1663,21 +1664,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty) {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {}) in fcx {}\",\n                node_id, ppaux::ty_to_string(self.tcx(), ty), self.tag());\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::TraitRef>) {\n+                             trait_ref: Rc<ty::TraitRef<'tcx>>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts) {\n+    pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n                    node_id,\n@@ -1705,7 +1706,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n                             span: Span,\n-                            adj: ty::AutoAdjustment) {\n+                            adj: ty::AutoAdjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1724,7 +1725,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_adjustment_obligations(&self,\n                                        span: Span,\n-                                       adj: &ty::AutoAdjustment) {\n+                                       adj: &ty::AutoAdjustment<'tcx>) {\n         match *adj {\n             ty::AdjustAddEnv(..) => { }\n             ty::AdjustDerefRef(ref d_r) => {\n@@ -1740,7 +1741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_autoref_obligations(&self,\n                                     span: Span,\n-                                    autoref: &ty::AutoRef) {\n+                                    autoref: &ty::AutoRef<'tcx>) {\n         match *autoref {\n             ty::AutoUnsize(ref unsize) => {\n                 self.register_unsize_obligations(span, unsize);\n@@ -1760,7 +1761,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn register_unsize_obligations(&self,\n                                    span: Span,\n-                                   unsize: &ty::UnsizeKind) {\n+                                   unsize: &ty::UnsizeKind<'tcx>) {\n         debug!(\"register_unsize_obligations: unsize={}\", unsize);\n \n         match *unsize {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn instantiate_type(&self,\n                             span: Span,\n                             def_id: ast::DefId)\n-                            -> TypeAndSubsts\n+                            -> TypeAndSubsts<'tcx>\n     {\n         /*!\n          * Returns the type of `def_id` with all generics replaced by\n@@ -1833,9 +1834,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_meets(&self,\n-                              ty: Ty,\n+                              ty: Ty<'tcx>,\n                               span: Span,\n-                              code: traits::ObligationCauseCode,\n+                              code: traits::ObligationCauseCode<'tcx>,\n                               bound: ty::BuiltinBound)\n     {\n         let obligation = traits::obligation_for_builtin_bound(\n@@ -1850,22 +1851,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn require_type_is_sized(&self,\n-                                 ty: Ty,\n+                                 ty: Ty<'tcx>,\n                                  span: Span,\n-                                 code: traits::ObligationCauseCode)\n+                                 code: traits::ObligationCauseCode<'tcx>)\n     {\n         self.require_type_meets(ty, span, code, ty::BoundSized);\n     }\n \n     pub fn require_expr_have_sized_type(&self,\n                                         expr: &ast::Expr,\n-                                        code: traits::ObligationCauseCode)\n+                                        code: traits::ObligationCauseCode<'tcx>)\n     {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n     pub fn register_obligation(&self,\n-                               obligation: traits::Obligation)\n+                               obligation: traits::Obligation<'tcx>)\n     {\n         debug!(\"register_obligation({})\",\n                obligation.repr(self.tcx()));\n@@ -1875,7 +1876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .register_obligation(self.tcx(), obligation);\n     }\n \n-    pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n         let t = ast_ty_to_ty(self, self.infcx(), ast_t);\n \n         let mut bounds_checker = wf::BoundsChecker::new(self,\n@@ -1891,7 +1892,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat.repr(self.tcx())\n     }\n \n-    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty {\n+    pub fn expr_ty(&self, ex: &ast::Expr) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n@@ -1901,7 +1902,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty {\n+    pub fn expr_ty_adjusted(&self, expr: &ast::Expr) -> Ty<'tcx> {\n         /*!\n          * Fetch type of `expr` after applying adjustments that\n          * have been recorded in the fcx.\n@@ -1914,8 +1915,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn adjust_expr_ty(&self,\n                           expr: &ast::Expr,\n-                          adjustment: Option<&ty::AutoAdjustment>)\n-                          -> Ty\n+                          adjustment: Option<&ty::AutoAdjustment<'tcx>>)\n+                          -> Ty<'tcx>\n     {\n         /*!\n          * Apply `adjustment` to the type of `expr`\n@@ -1933,7 +1934,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                        .map(|method| method.ty))\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> Ty {\n+    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.inh.node_types.borrow().get(&id) {\n             Some(&t) => t,\n             None => {\n@@ -1945,13 +1946,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts>> {\n+    pub fn item_substs<'a>(&'a self) -> Ref<'a, NodeMap<ty::ItemSubsts<'tcx>>> {\n         self.inh.item_substs.borrow()\n     }\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: |&ty::ItemSubsts|) {\n+                              f: |&ty::ItemSubsts<'tcx>|) {\n         match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n@@ -1961,27 +1962,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_subty(&self,\n                     a_is_expected: bool,\n                     origin: infer::TypeOrigin,\n-                    sub: Ty,\n-                    sup: Ty)\n-                    -> Result<(), ty::type_err> {\n+                    sub: Ty<'tcx>,\n+                    sup: Ty<'tcx>)\n+                    -> Result<(), ty::type_err<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn can_mk_subty(&self, sub: Ty, sup: Ty)\n-                        -> Result<(), ty::type_err> {\n+    pub fn can_mk_subty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n+                        -> Result<(), ty::type_err<'tcx>> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    pub fn can_mk_eqty(&self, sub: Ty, sup: Ty)\n-                       -> Result<(), ty::type_err> {\n+    pub fn can_mk_eqty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>)\n+                       -> Result<(), ty::type_err<'tcx>> {\n         infer::can_mk_eqty(self.infcx(), sub, sup)\n     }\n \n     pub fn mk_assignty(&self,\n                        expr: &ast::Expr,\n-                       sub: Ty,\n-                       sup: Ty)\n-                       -> Result<(), ty::type_err> {\n+                       sub: Ty<'tcx>,\n+                       sup: Ty<'tcx>)\n+                       -> Result<(), ty::type_err<'tcx>> {\n         match infer::mk_coercety(self.infcx(),\n                                  false,\n                                  infer::ExprAssignable(expr.span),\n@@ -1999,14 +2000,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,\n-                   sub: Ty,\n-                   sup: Ty)\n-                   -> Result<(), ty::type_err> {\n+                   sub: Ty<'tcx>,\n+                   sup: Ty<'tcx>)\n+                   -> Result<(), ty::type_err<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n     pub fn mk_subr(&self,\n-                   origin: infer::SubregionOrigin,\n+                   origin: infer::SubregionOrigin<'tcx>,\n                    sub: ty::Region,\n                    sup: ty::Region) {\n         infer::mk_subr(self.infcx(), origin, sub, sup)\n@@ -2015,22 +2016,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: Ty,\n-                              err: Option<&ty::type_err>) {\n+                              actual_ty: Ty<'tcx>,\n+                              err: Option<&ty::type_err<'tcx>>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n     pub fn report_mismatched_types(&self,\n                                    sp: Span,\n-                                   e: Ty,\n-                                   a: Ty,\n-                                   err: &ty::type_err) {\n+                                   e: Ty<'tcx>,\n+                                   a: Ty<'tcx>,\n+                                   err: &ty::type_err<'tcx>) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n     pub fn register_region_obligation(&self,\n-                                      origin: infer::SubregionOrigin,\n-                                      ty: Ty,\n+                                      origin: infer::SubregionOrigin<'tcx>,\n+                                      ty: Ty<'tcx>,\n                                       r: ty::Region)\n     {\n         /*!\n@@ -2050,9 +2051,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn add_obligations_for_parameters(&self,\n-                                          cause: traits::ObligationCause,\n-                                          substs: &Substs,\n-                                          generic_bounds: &ty::GenericBounds)\n+                                          cause: traits::ObligationCause<'tcx>,\n+                                          substs: &Substs<'tcx>,\n+                                          generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         /*!\n          * Given a fully substituted set of bounds (`generic_bounds`),\n@@ -2085,9 +2086,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn add_trait_obligations_for_generics(&self,\n-                                          cause: traits::ObligationCause,\n-                                          substs: &Substs,\n-                                          generic_bounds: &ty::GenericBounds) {\n+                                          cause: traits::ObligationCause<'tcx>,\n+                                          substs: &Substs<'tcx>,\n+                                          generic_bounds: &ty::GenericBounds<'tcx>) {\n         assert!(!generic_bounds.has_escaping_regions());\n         assert!(!substs.has_regions_escaping_depth(0));\n \n@@ -2100,9 +2101,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn add_region_obligations_for_generics(&self,\n-                                           cause: traits::ObligationCause,\n-                                           substs: &Substs,\n-                                           generic_bounds: &ty::GenericBounds)\n+                                           cause: traits::ObligationCause<'tcx>,\n+                                           substs: &Substs<'tcx>,\n+                                           generic_bounds: &ty::GenericBounds<'tcx>)\n     {\n         assert!(!generic_bounds.has_escaping_regions());\n         assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n@@ -2128,8 +2129,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn add_region_obligations_for_type_parameter(&self,\n                                                  span: Span,\n-                                                 param_bound: &ty::ParamBounds,\n-                                                 ty: Ty)\n+                                                 param_bound: &ty::ParamBounds<'tcx>,\n+                                                 ty: Ty<'tcx>)\n     {\n         // For each declared region bound `T:r`, `T` must outlive `r`.\n         let region_bounds =\n@@ -2164,11 +2165,12 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: Ty,\n-                    expr_id: Option<ast::NodeId>,\n-                    mut lvalue_pref: LvaluePreference,\n-                    should_stop: |Ty, uint| -> Option<T>)\n-                    -> (Ty, uint, Option<T>) {\n+pub fn autoderef<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                              base_ty: Ty<'tcx>,\n+                              expr_id: Option<ast::NodeId>,\n+                              mut lvalue_pref: LvaluePreference,\n+                              should_stop: |Ty<'tcx>, uint| -> Option<T>)\n+                              -> (Ty<'tcx>, uint, Option<T>) {\n     /*!\n      * Executes an autoderef loop for the type `t`. At each step, invokes\n      * `should_stop` to decide whether to terminate the loop. Returns\n@@ -2219,12 +2221,12 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: Ty,\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n-fn try_overloaded_call(fcx: &FnCtxt,\n-                       call_expression: &ast::Expr,\n-                       callee: &ast::Expr,\n-                       callee_type: Ty,\n-                       args: &[&P<ast::Expr>])\n-                       -> bool {\n+fn try_overloaded_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 call_expression: &ast::Expr,\n+                                 callee: &ast::Expr,\n+                                 callee_type: Ty<'tcx>,\n+                                 args: &[&P<ast::Expr>])\n+                                 -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n     match *structure_of(fcx, callee.span, callee_type) {\n@@ -2278,13 +2280,13 @@ fn try_overloaded_call(fcx: &FnCtxt,\n     false\n }\n \n-fn try_overloaded_deref(fcx: &FnCtxt,\n-                        span: Span,\n-                        method_call: Option<MethodCall>,\n-                        base_expr: Option<&ast::Expr>,\n-                        base_ty: Ty,\n-                        lvalue_pref: LvaluePreference)\n-                        -> Option<ty::mt>\n+fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  method_call: Option<MethodCall>,\n+                                  base_expr: Option<&ast::Expr>,\n+                                  base_ty: Ty<'tcx>,\n+                                  lvalue_pref: LvaluePreference)\n+                                  -> Option<ty::mt<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n@@ -2309,10 +2311,10 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n     make_overloaded_lvalue_return_type(fcx, method_call, method)\n }\n \n-fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n-                                      method_call: Option<MethodCall>,\n-                                      method: Option<MethodCallee>)\n-                                      -> Option<ty::mt>\n+fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                method_call: Option<MethodCall>,\n+                                                method: Option<MethodCallee<'tcx>>)\n+                                                -> Option<ty::mt<'tcx>>\n {\n     /*!\n      * For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n@@ -2345,12 +2347,12 @@ fn make_overloaded_lvalue_return_type(fcx: &FnCtxt,\n     }\n }\n \n-fn autoderef_for_index<T>(fcx: &FnCtxt,\n-                          base_expr: &ast::Expr,\n-                          base_ty: Ty,\n-                          lvalue_pref: LvaluePreference,\n-                          step: |Ty, ty::AutoDerefRef| -> Option<T>)\n-                          -> Option<T>\n+fn autoderef_for_index<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    base_expr: &ast::Expr,\n+                                    base_ty: Ty<'tcx>,\n+                                    lvalue_pref: LvaluePreference,\n+                                    step: |Ty<'tcx>, ty::AutoDerefRef<'tcx>| -> Option<T>)\n+                                    -> Option<T>\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n     // autoderef that normal method probing does. They could likely be\n@@ -2383,15 +2385,15 @@ fn autoderef_for_index<T>(fcx: &FnCtxt,\n     }\n }\n \n-fn try_overloaded_slice(fcx: &FnCtxt,\n-                        method_call: MethodCall,\n-                        expr: &ast::Expr,\n-                        base_expr: &ast::Expr,\n-                        base_ty: Ty,\n-                        start_expr: &Option<P<ast::Expr>>,\n-                        end_expr: &Option<P<ast::Expr>>,\n-                        mutbl: ast::Mutability)\n-                        -> Option<Ty> // return type is result of slice\n+fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  method_call: MethodCall,\n+                                  expr: &ast::Expr,\n+                                  base_expr: &ast::Expr,\n+                                  base_ty: Ty<'tcx>,\n+                                  start_expr: &Option<P<ast::Expr>>,\n+                                  end_expr: &Option<P<ast::Expr>>,\n+                                  mutbl: ast::Mutability)\n+                                  -> Option<Ty<'tcx>> // return type is result of slice\n {\n     /*!\n      * Autoderefs `base_expr`, looking for a `Slice` impl. If it\n@@ -2439,16 +2441,17 @@ fn try_overloaded_slice(fcx: &FnCtxt,\n     })\n }\n \n-fn try_overloaded_slice_step(fcx: &FnCtxt,\n-                             method_call: MethodCall,\n-                             expr: &ast::Expr,\n-                             base_expr: &ast::Expr,\n-                             base_ty: Ty, // autoderef'd type\n-                             autoderefref: ty::AutoDerefRef,\n-                             mutbl: ast::Mutability,\n-                             start_expr: &Option<P<ast::Expr>>,\n-                             end_expr: &Option<P<ast::Expr>>)\n-                             -> Option<Ty> // result type is type of method being called\n+fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       method_call: MethodCall,\n+                                       expr: &ast::Expr,\n+                                       base_expr: &ast::Expr,\n+                                       base_ty: Ty<'tcx>, // autoderef'd type\n+                                       autoderefref: ty::AutoDerefRef<'tcx>,\n+                                       mutbl: ast::Mutability,\n+                                       start_expr: &Option<P<ast::Expr>>,\n+                                       end_expr: &Option<P<ast::Expr>>)\n+                                       // result type is type of method being called\n+                                       -> Option<Ty<'tcx>>\n {\n     /*!\n      * Checks for a `Slice` (or `SliceMut`) impl at the relevant level\n@@ -2512,14 +2515,14 @@ fn try_overloaded_slice_step(fcx: &FnCtxt,\n     })\n }\n \n-fn try_index_step(fcx: &FnCtxt,\n-                  method_call: MethodCall,\n-                  expr: &ast::Expr,\n-                  base_expr: &ast::Expr,\n-                  adjusted_ty: Ty,\n-                  adjustment: ty::AutoDerefRef,\n-                  lvalue_pref: LvaluePreference)\n-                  -> Option<(/*index type*/ Ty, /*element type*/ Ty)>\n+fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            method_call: MethodCall,\n+                            expr: &ast::Expr,\n+                            base_expr: &ast::Expr,\n+                            adjusted_ty: Ty<'tcx>,\n+                            adjustment: ty::AutoDerefRef<'tcx>,\n+                            lvalue_pref: LvaluePreference)\n+                            -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n     /*!\n      * To type-check `base_expr[index_expr]`, we progressively autoderef (and otherwise adjust)\n@@ -2591,10 +2594,10 @@ fn try_index_step(fcx: &FnCtxt,\n ///\n /// The return type of this function represents the concrete element type\n /// `A` in the type `Iterator<A>` that the method returns.\n-fn lookup_method_for_for_loop(fcx: &FnCtxt,\n-                              iterator_expr: &ast::Expr,\n-                              loop_id: ast::NodeId)\n-                              -> Ty {\n+fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        iterator_expr: &ast::Expr,\n+                                        loop_id: ast::NodeId)\n+                                        -> Ty<'tcx> {\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n@@ -2672,14 +2675,14 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     }\n }\n \n-fn check_method_argument_types(fcx: &FnCtxt,\n-                               sp: Span,\n-                               method_fn_ty: Ty,\n-                               callee_expr: &ast::Expr,\n-                               args_no_rcvr: &[&P<ast::Expr>],\n-                               deref_args: DerefArgs,\n-                               tuple_arguments: TupleArgumentsFlag)\n-                               -> ty::FnOutput {\n+fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         sp: Span,\n+                                         method_fn_ty: Ty<'tcx>,\n+                                         callee_expr: &ast::Expr,\n+                                         args_no_rcvr: &[&P<ast::Expr>],\n+                                         deref_args: DerefArgs,\n+                                         tuple_arguments: TupleArgumentsFlag)\n+                                         -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n        let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n@@ -2713,14 +2716,14 @@ fn check_method_argument_types(fcx: &FnCtxt,\n     }\n }\n \n-fn check_argument_types(fcx: &FnCtxt,\n-                        sp: Span,\n-                        fn_inputs: &[Ty],\n-                        _callee_expr: &ast::Expr,\n-                        args: &[&P<ast::Expr>],\n-                        deref_args: DerefArgs,\n-                        variadic: bool,\n-                        tuple_arguments: TupleArgumentsFlag) {\n+fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  sp: Span,\n+                                  fn_inputs: &[Ty<'tcx>],\n+                                  _callee_expr: &ast::Expr,\n+                                  args: &[&P<ast::Expr>],\n+                                  deref_args: DerefArgs,\n+                                  variadic: bool,\n+                                  tuple_arguments: TupleArgumentsFlag) {\n     /*!\n      *\n      * Generic function that factors out common logic from\n@@ -2891,22 +2894,25 @@ fn check_argument_types(fcx: &FnCtxt,\n     }\n }\n \n-fn err_args(len: uint) -> Vec<Ty> {\n+// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n+fn err_args<'tcx>(len: uint) -> Vec<Ty<'tcx>> {\n     Vec::from_fn(len, |_| ty::mk_err())\n }\n \n-fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::FnOutput) {\n+fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        call_expr: &ast::Expr,\n+                        output: ty::FnOutput<'tcx>) {\n     fcx.write_ty(call_expr.id, match output {\n         ty::FnConverging(output_ty) => output_ty,\n         ty::FnDiverging => fcx.infcx().next_diverging_ty_var()\n     });\n }\n \n // AST fragment checking\n-fn check_lit(fcx: &FnCtxt,\n-             lit: &ast::Lit,\n-             expected: Expectation)\n-             -> Ty\n+fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                       lit: &ast::Lit,\n+                       expected: Expectation<'tcx>)\n+                       -> Ty<'tcx>\n {\n     let tcx = fcx.ccx.tcx;\n \n@@ -2958,40 +2964,41 @@ pub fn valid_range_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn check_expr_has_type(fcx: &FnCtxt,\n-                           expr: &ast::Expr,\n-                           expected: Ty) {\n+pub fn check_expr_has_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr)));\n }\n \n-fn check_expr_coercable_to_type(fcx: &FnCtxt,\n-                                expr: &ast::Expr,\n-                                expected: Ty) {\n+fn check_expr_coercable_to_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          expr: &ast::Expr,\n+                                          expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || demand::coerce(fcx, expr.span, expected, expr));\n }\n \n-fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: Ty) {\n+fn check_expr_with_hint<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, expr: &ast::Expr,\n+                                  expected: Ty<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, ExpectHasType(expected), NoPreference,\n         || ())\n }\n \n-fn check_expr_with_expectation(fcx: &FnCtxt,\n-                               expr: &ast::Expr,\n-                               expected: Expectation) {\n+fn check_expr_with_expectation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         expr: &ast::Expr,\n+                                         expected: Expectation<'tcx>) {\n     check_expr_with_unifier(\n         fcx, expr, expected, NoPreference,\n         || ())\n }\n \n-fn check_expr_with_expectation_and_lvalue_pref(fcx: &FnCtxt,\n-                                            expr: &ast::Expr,\n-                                            expected: Expectation,\n-                                            lvalue_pref: LvaluePreference)\n+fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                         expr: &ast::Expr,\n+                                                         expected: Expectation<'tcx>,\n+                                                         lvalue_pref: LvaluePreference)\n {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n@@ -3009,10 +3016,10 @@ fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn impl_self_ty(fcx: &FnCtxt,\n-                    span: Span, // (potential) receiver for this impl\n-                    did: ast::DefId)\n-                    -> TypeAndSubsts {\n+pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span, // (potential) receiver for this impl\n+                              did: ast::DefId)\n+                              -> TypeAndSubsts<'tcx> {\n     let tcx = fcx.tcx();\n \n     let ity = ty::lookup_item_type(tcx, did);\n@@ -3031,21 +3038,23 @@ pub fn impl_self_ty(fcx: &FnCtxt,\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-pub fn lookup_field_ty(tcx: &ty::ctxt,\n-                       class_id: ast::DefId,\n-                       items: &[ty::field_ty],\n-                       fieldname: ast::Name,\n-                       substs: &subst::Substs) -> Option<Ty> {\n+pub fn lookup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             class_id: ast::DefId,\n+                             items: &[ty::field_ty],\n+                             fieldname: ast::Name,\n+                             substs: &subst::Substs<'tcx>)\n+                             -> Option<Ty<'tcx>> {\n \n     let o_field = items.iter().find(|f| f.name == fieldname);\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n }\n \n-pub fn lookup_tup_field_ty(tcx: &ty::ctxt,\n-                           class_id: ast::DefId,\n-                           items: &[ty::field_ty],\n-                           idx: uint,\n-                           substs: &subst::Substs) -> Option<Ty> {\n+pub fn lookup_tup_field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 class_id: ast::DefId,\n+                                 items: &[ty::field_ty],\n+                                 idx: uint,\n+                                 substs: &subst::Substs<'tcx>)\n+                                 -> Option<Ty<'tcx>> {\n \n     let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n     o_field.map(|f| ty::lookup_field_type(tcx, class_id, f.id, substs))\n@@ -3090,20 +3099,20 @@ enum TupleArgumentsFlag {\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier(fcx: &FnCtxt,\n-                           expr: &ast::Expr,\n-                           expected: Expectation,\n-                           lvalue_pref: LvaluePreference,\n-                           unifier: ||)\n+fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     expr: &ast::Expr,\n+                                     expected: Expectation<'tcx>,\n+                                     lvalue_pref: LvaluePreference,\n+                                     unifier: ||)\n {\n     debug!(\">> typechecking: expr={} expected={}\",\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call<'a>(fcx: &FnCtxt,\n-                      call_expr: &ast::Expr,\n-                      f: &ast::Expr,\n-                      args: &[&'a P<ast::Expr>]) {\n+    fn check_call(fcx: &FnCtxt,\n+                  call_expr: &ast::Expr,\n+                  f: &ast::Expr,\n+                  args: &[&P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -3201,13 +3210,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: &FnCtxt,\n-                       cond_expr: &ast::Expr,\n-                       then_blk: &ast::Block,\n-                       opt_else_expr: Option<&ast::Expr>,\n-                       id: ast::NodeId,\n-                       sp: Span,\n-                       expected: Expectation) {\n+    fn check_then_else<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 cond_expr: &ast::Expr,\n+                                 then_blk: &ast::Block,\n+                                 opt_else_expr: Option<&ast::Expr>,\n+                                 id: ast::NodeId,\n+                                 sp: Span,\n+                                 expected: Expectation<'tcx>) {\n         check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n \n         // Disregard \"castable to\" expectations because they\n@@ -3271,12 +3280,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                   op_ex: &ast::Expr,\n-                                  lhs_ty: Ty,\n+                                  lhs_ty: Ty<'tcx>,\n                                   opname: ast::Name,\n                                   trait_did: Option<ast::DefId>,\n                                   lhs: &'a ast::Expr,\n                                   rhs: Option<&P<ast::Expr>>,\n-                                  unbound_method: ||) -> Ty {\n+                                  unbound_method: ||) -> Ty<'tcx> {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 // We do eager coercions to make using operators\n@@ -3454,12 +3463,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: &FnCtxt,\n-                        ex: &ast::Expr,\n-                        lhs_expr: &ast::Expr,\n-                        lhs_resolved_t: Ty,\n-                        op: ast::BinOp,\n-                        rhs: &P<ast::Expr>) -> Ty {\n+    fn check_user_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  ex: &ast::Expr,\n+                                  lhs_expr: &ast::Expr,\n+                                  lhs_resolved_t: Ty<'tcx>,\n+                                  op: ast::BinOp,\n+                                  rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -3494,13 +3503,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         })\n     }\n \n-    fn check_user_unop(fcx: &FnCtxt,\n-                       op_str: &str,\n-                       mname: &str,\n-                       trait_did: Option<ast::DefId>,\n-                       ex: &ast::Expr,\n-                       rhs_expr: &ast::Expr,\n-                       rhs_t: Ty) -> Ty {\n+    fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                 op_str: &str,\n+                                 mname: &str,\n+                                 trait_did: Option<ast::DefId>,\n+                                 ex: &ast::Expr,\n+                                 rhs_expr: &ast::Expr,\n+                                 rhs_t: Ty<'tcx>) -> Ty<'tcx> {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n                         trait_did, rhs_expr, None, || {\n             fcx.type_error_message(ex.span, |actual| {\n@@ -3579,12 +3588,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n            .insert(local_def(expr.id), unboxed_closure);\n     }\n \n-    fn check_expr_fn(fcx: &FnCtxt,\n-                     expr: &ast::Expr,\n-                     store: ty::TraitStore,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     expected: Expectation) {\n+    fn check_expr_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                               expr: &ast::Expr,\n+                               store: ty::TraitStore,\n+                               decl: &ast::FnDecl,\n+                               body: &ast::Block,\n+                               expected: Expectation<'tcx>) {\n         let tcx = fcx.ccx.tcx;\n \n         debug!(\"check_expr_fn(expr={}, expected={})\",\n@@ -3799,15 +3808,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: &FnCtxt,\n-                                      struct_ty: Ty,\n-                                      span: Span,\n-                                      class_id: ast::DefId,\n-                                      node_id: ast::NodeId,\n-                                      substitutions: subst::Substs,\n-                                      field_types: &[ty::field_ty],\n-                                      ast_fields: &[ast::Field],\n-                                      check_completeness: bool)  {\n+    fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                struct_ty: Ty<'tcx>,\n+                                                span: Span,\n+                                                class_id: ast::DefId,\n+                                                node_id: ast::NodeId,\n+                                                substitutions: subst::Substs<'tcx>,\n+                                                field_types: &[ty::field_ty],\n+                                                ast_fields: &[ast::Field],\n+                                                check_completeness: bool)  {\n         let tcx = fcx.ccx.tcx;\n \n         let mut class_field_map = FnvHashMap::new();\n@@ -4692,8 +4701,8 @@ fn constrain_path_type_parameters(fcx: &FnCtxt,\n     });\n }\n \n-impl Expectation {\n-    fn only_has_type(self) -> Expectation {\n+impl<'tcx> Expectation<'tcx> {\n+    fn only_has_type(self) -> Expectation<'tcx> {\n         match self {\n             NoExpectation | ExpectCastableToType(..) => NoExpectation,\n             ExpectHasType(t) => ExpectHasType(t)\n@@ -4703,7 +4712,7 @@ impl Expectation {\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n-    fn resolve(self, fcx: &FnCtxt) -> Expectation {\n+    fn resolve<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => {\n                 NoExpectation\n@@ -4719,17 +4728,19 @@ impl Expectation {\n         }\n     }\n \n-    fn map(self, fcx: &FnCtxt, unpack: |&ty::sty| -> Expectation) -> Expectation {\n+    fn map<'a>(self, fcx: &FnCtxt<'a, 'tcx>,\n+               unpack: |&ty::sty<'tcx>| -> Expectation<'tcx>)\n+               -> Expectation<'tcx> {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) | ExpectHasType(t) => unpack(&ty::get(t).sty),\n         }\n     }\n \n-    fn map_to_option<O>(self,\n-                        fcx: &FnCtxt,\n-                        unpack: |&ty::sty| -> Option<O>)\n-                        -> Option<O>\n+    fn map_to_option<'a, O>(self,\n+                            fcx: &FnCtxt<'a, 'tcx>,\n+                            unpack: |&ty::sty<'tcx>| -> Option<O>)\n+                            -> Option<O>\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n@@ -4738,8 +4749,8 @@ impl Expectation {\n     }\n }\n \n-impl Repr for Expectation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             NoExpectation => format!(\"NoExpectation\"),\n             ExpectHasType(t) => format!(\"ExpectHasType({})\",\n@@ -4842,9 +4853,9 @@ pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-fn check_block_with_expected(fcx: &FnCtxt,\n-                             blk: &ast::Block,\n-                             expected: Expectation) {\n+fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       blk: &ast::Block,\n+                                       expected: Expectation<'tcx>) {\n     let prev = {\n         let mut fcx_ps = fcx.ps.borrow_mut();\n         let fn_style_state = fcx_ps.recurse(blk);\n@@ -4925,9 +4936,9 @@ fn check_block_with_expected(fcx: &FnCtxt,\n /// Checks a constant appearing in a type. At the moment this is just the\n /// length expression in a fixed-length vector, but someday it might be\n /// extended to type-level numeric literals.\n-pub fn check_const_in_type(tcx: &ty::ctxt,\n-                           expr: &ast::Expr,\n-                           expected_type: Ty) {\n+pub fn check_const_in_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 expr: &ast::Expr,\n+                                 expected_type: Ty<'tcx>) {\n     // Synthesize a crate context. The trait map is not needed here (though I\n     // imagine it will be if we have associated statics --pcwalton), so we\n     // leave it blank.\n@@ -4951,10 +4962,10 @@ pub fn check_const(ccx: &CrateCtxt,\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: &FnCtxt,\n-                           _: Span,\n-                           e: &ast::Expr,\n-                           declty: Ty) {\n+pub fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                     _: Span,\n+                                     e: &ast::Expr,\n+                                     declty: Ty<'tcx>) {\n     // Gather locals in statics (because of block expressions).\n     // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly\n@@ -5086,11 +5097,11 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         }\n     }\n \n-    fn do_check(ccx: &CrateCtxt,\n-                vs: &[P<ast::Variant>],\n-                id: ast::NodeId,\n-                hint: attr::ReprAttr)\n-                -> Vec<Rc<ty::VariantInfo>> {\n+    fn do_check<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                          vs: &[P<ast::Variant>],\n+                          id: ast::NodeId,\n+                          hint: attr::ReprAttr)\n+                          -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n@@ -5211,10 +5222,10 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn polytype_for_def(fcx: &FnCtxt,\n-                        sp: Span,\n-                        defn: def::Def)\n-                        -> Polytype {\n+pub fn polytype_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  sp: Span,\n+                                  defn: def::Def)\n+                                  -> Polytype<'tcx> {\n     match defn {\n       def::DefLocal(nid) | def::DefUpvar(nid, _, _) => {\n           let typ = fcx.local_ty(sp, nid);\n@@ -5255,12 +5266,12 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: &FnCtxt,\n-                        path: &ast::Path,\n-                        polytype: Polytype,\n-                        def: def::Def,\n-                        span: Span,\n-                        node_id: ast::NodeId) {\n+pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  path: &ast::Path,\n+                                  polytype: Polytype<'tcx>,\n+                                  def: def::Def,\n+                                  span: Span,\n+                                  node_id: ast::NodeId) {\n     debug!(\"instantiate_path(path={}, def={}, node_id={}, polytype={})\",\n            path.repr(fcx.tcx()),\n            def.repr(fcx.tcx()),\n@@ -5472,14 +5483,14 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n         span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         /*!\n          * Finds the parameters that the user provided and adds them\n@@ -5511,13 +5522,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_angle_bracketed_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         data: &ast::AngleBracketedParameterData,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         {\n             let type_count = type_defs.len(space);\n@@ -5556,13 +5567,13 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn push_explicit_parenthesized_parameters_from_segment_to_substs(\n-        fcx: &FnCtxt,\n+    fn push_explicit_parenthesized_parameters_from_segment_to_substs<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         space: subst::ParamSpace,\n         span: Span,\n-        type_defs: &VecPerParamSpace<ty::TypeParameterDef>,\n+        type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         data: &ast::ParenthesizedParameterData,\n-        substs: &mut Substs)\n+        substs: &mut Substs<'tcx>)\n     {\n         /*!\n          * As with\n@@ -5602,12 +5613,12 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         }\n     }\n \n-    fn adjust_type_parameters(\n-        fcx: &FnCtxt,\n+    fn adjust_type_parameters<'a, 'tcx>(\n+        fcx: &FnCtxt<'a, 'tcx>,\n         span: Span,\n         space: ParamSpace,\n-        defs: &VecPerParamSpace<ty::TypeParameterDef>,\n-        substs: &mut Substs)\n+        defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n+        substs: &mut Substs<'tcx>)\n     {\n         let provided_len = substs.types.len(space);\n         let desired = defs.get_slice(space);\n@@ -5707,7 +5718,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: Ty) -> Ty {\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                            mut ty: Ty<'tcx>) -> Ty<'tcx> {\n     // If `ty` is a type variable, see whether we already know what it is.\n     ty = fcx.infcx().shallow_resolve(ty);\n \n@@ -5736,8 +5748,8 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, mut ty: Ty) -> Ty {\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: Ty)\n-                        -> &'a ty::sty {\n+pub fn structure_of<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span, typ: Ty<'tcx>)\n+                        -> &'tcx ty::sty<'tcx> {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n@@ -5765,10 +5777,10 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: &CrateCtxt,\n-                             span: Span,\n-                             tps: &OwnedSlice<ast::TyParam>,\n-                             ty: Ty) {\n+pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                       span: Span,\n+                                       tps: &OwnedSlice<ast::TyParam>,\n+                                       ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={})\",\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n@@ -5796,7 +5808,7 @@ pub fn check_bounds_are_used(ccx: &CrateCtxt,\n }\n \n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param(ccx: &CrateCtxt, n: uint) -> Ty {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: uint) -> Ty<'tcx> {\n         ty::mk_param(ccx.tcx, subst::FnSpace, n, local_def(0))\n     }\n \n@@ -6077,8 +6089,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     }\n }\n \n-impl Repr for RegionObligation {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionObligation<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"RegionObligation(sub_region={}, sup_type={}, origin={})\",\n                 self.sub_region.repr(tcx),\n                 self.sup_type.repr(tcx),"}, {"sha": "ced8b4870874a09f7235dc168016251e94010182", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -176,9 +176,9 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_ensure_component_tys_wf(fcx: &FnCtxt,\n-                                        span: Span,\n-                                        component_tys: &[Ty]) {\n+pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  component_tys: &[Ty<'tcx>]) {\n     /*!\n      * Checks that the types in `component_tys` are well-formed.\n      * This will add constraints into the region graph.\n@@ -215,15 +215,15 @@ macro_rules! ignore_err(\n // Stores parameters for a potential call to link_region()\n // to perform if an upvar reference is marked unique/mutable after\n // it has already been processed before.\n-struct MaybeLink {\n+struct MaybeLink<'tcx> {\n     span: Span,\n     borrow_region: ty::Region,\n     borrow_kind: ty::BorrowKind,\n-    borrow_cmt: mc::cmt\n+    borrow_cmt: mc::cmt<'tcx>\n }\n \n // A map associating an upvar ID to a vector of the above\n-type MaybeLinkMap = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink>>>;\n+type MaybeLinkMap<'tcx> = RefCell<FnvHashMap<ty::UpvarId, Vec<MaybeLink<'tcx>>>>;\n \n pub struct Rcx<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -235,7 +235,7 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // Possible region links we will establish if an upvar\n     // turns out to be unique/mutable\n-    maybe_links: MaybeLinkMap\n+    maybe_links: MaybeLinkMap<'tcx>\n }\n \n fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         old_scope\n     }\n \n-    pub fn resolve_type(&self, unresolved_ty: Ty) -> Ty {\n+    pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -319,19 +319,19 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> Ty {\n+    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty> {\n+    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n         let method_ty = self.fcx.inh.method_map.borrow()\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> Ty<'tcx> {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) {\n             ty_unadjusted\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     }\n \n     fn relate_free_regions(&mut self,\n-                           fn_sig_tys: &[Ty],\n+                           fn_sig_tys: &[Ty<'tcx>],\n                            body_id: ast::NodeId) {\n         /*!\n          * This method populates the region map's `free_region_map`.\n@@ -457,16 +457,16 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         let t = self.resolve_node_type(id);\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty> {\n+    fn node_method_ty(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n         self.resolve_method_type(method_call)\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.fcx.inh.adjustments\n     }\n \n@@ -488,7 +488,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.fcx.inh.unboxed_closures\n     }\n }\n@@ -807,10 +807,10 @@ fn constrain_cast(rcx: &mut Rcx,\n \n     walk_cast(rcx, cast_expr, source_ty, target_ty);\n \n-    fn walk_cast(rcx: &mut Rcx,\n-                 cast_expr: &ast::Expr,\n-                 from_ty: Ty,\n-                 to_ty: Ty) {\n+    fn walk_cast<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                           cast_expr: &ast::Expr,\n+                           from_ty: Ty<'tcx>,\n+                           to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={}, to_ty={})\",\n                from_ty.repr(rcx.tcx()),\n                to_ty.repr(rcx.tcx()));\n@@ -1182,10 +1182,10 @@ fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_autoderefs(rcx: &mut Rcx,\n-                        deref_expr: &ast::Expr,\n-                        derefs: uint,\n-                        mut derefd_ty: Ty) {\n+fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                  deref_expr: &ast::Expr,\n+                                  derefs: uint,\n+                                  mut derefd_ty: Ty<'tcx>) {\n     /*!\n      * Invoked on any auto-dereference that occurs.  Checks that if\n      * this is a region pointer being dereferenced, the lifetime of\n@@ -1258,9 +1258,9 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n }\n \n \n-fn constrain_index(rcx: &mut Rcx,\n-                   index_expr: &ast::Expr,\n-                   indexed_ty: Ty)\n+fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                             index_expr: &ast::Expr,\n+                             indexed_ty: Ty<'tcx>)\n {\n     /*!\n      * Invoked on any index expression that occurs.  Checks that if\n@@ -1285,9 +1285,9 @@ fn constrain_index(rcx: &mut Rcx,\n     }\n }\n \n-fn type_of_node_must_outlive(\n-    rcx: &mut Rcx,\n-    origin: infer::SubregionOrigin,\n+fn type_of_node_must_outlive<'a, 'tcx>(\n+    rcx: &mut Rcx<'a, 'tcx>,\n+    origin: infer::SubregionOrigin<'tcx>,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region)\n {\n@@ -1365,10 +1365,10 @@ fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     }\n }\n \n-fn link_pattern(rcx: &Rcx,\n-                mc: mc::MemCategorizationContext<Rcx>,\n-                discr_cmt: mc::cmt,\n-                root_pat: &ast::Pat) {\n+fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                          mc: mc::MemCategorizationContext<Rcx<'a, 'tcx>>,\n+                          discr_cmt: mc::cmt<'tcx>,\n+                          root_pat: &ast::Pat) {\n     /*!\n      * Link lifetimes of any ref bindings in `root_pat` to\n      * the pointers found in the discriminant, if needed.\n@@ -1441,11 +1441,11 @@ fn link_by_ref(rcx: &Rcx,\n     link_region(rcx, expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n-fn link_region_from_node_type(rcx: &Rcx,\n-                              span: Span,\n-                              id: ast::NodeId,\n-                              mutbl: ast::Mutability,\n-                              cmt_borrowed: mc::cmt) {\n+fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                        span: Span,\n+                                        id: ast::NodeId,\n+                                        mutbl: ast::Mutability,\n+                                        cmt_borrowed: mc::cmt<'tcx>) {\n     /*!\n      * Like `link_region()`, except that the region is\n      * extracted from the type of `id`, which must be some\n@@ -1462,11 +1462,11 @@ fn link_region_from_node_type(rcx: &Rcx,\n     }\n }\n \n-fn link_region(rcx: &Rcx,\n-               span: Span,\n-               borrow_region: ty::Region,\n-               borrow_kind: ty::BorrowKind,\n-               borrow_cmt: mc::cmt) {\n+fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                         span: Span,\n+                         borrow_region: ty::Region,\n+                         borrow_kind: ty::BorrowKind,\n+                         borrow_cmt: mc::cmt<'tcx>) {\n     /*!\n      * Informs the inference engine that `borrow_cmt` is being\n      * borrowed with kind `borrow_kind` and lifetime `borrow_region`.\n@@ -1524,15 +1524,15 @@ fn link_region(rcx: &Rcx,\n     }\n }\n \n-fn link_reborrowed_region(rcx: &Rcx,\n-                          span: Span,\n-                          borrow_region: ty::Region,\n-                          borrow_kind: ty::BorrowKind,\n-                          ref_cmt: mc::cmt,\n-                          ref_region: ty::Region,\n-                          mut ref_kind: ty::BorrowKind,\n-                          note: mc::Note)\n-                          -> Option<(mc::cmt, ty::BorrowKind)>\n+fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                    span: Span,\n+                                    borrow_region: ty::Region,\n+                                    borrow_kind: ty::BorrowKind,\n+                                    ref_cmt: mc::cmt<'tcx>,\n+                                    ref_region: ty::Region,\n+                                    mut ref_kind: ty::BorrowKind,\n+                                    note: mc::Note)\n+                                    -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n {\n     /*!\n      * This is the most complicated case: the path being borrowed is\n@@ -1727,8 +1727,8 @@ fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n     adjust_upvar_borrow_kind_for_mut(rcx, cmt);\n }\n \n-fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n-                                    cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_mut<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                              cmt: mc::cmt<'tcx>) {\n     /*!\n      * Indicates that `cmt` is being directly mutated (e.g., assigned\n      * to).  If cmt contains any by-ref upvars, this implies that\n@@ -1785,7 +1785,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n     }\n }\n \n-fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_unique<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, cmt: mc::cmt<'tcx>) {\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n@@ -1910,10 +1910,10 @@ fn adjust_upvar_borrow_kind(rcx: &Rcx,\n     }\n }\n \n-fn type_must_outlive(rcx: &mut Rcx,\n-                     origin: infer::SubregionOrigin,\n-                     ty: Ty,\n-                     region: ty::Region)\n+fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                               origin: infer::SubregionOrigin<'tcx>,\n+                               ty: Ty<'tcx>,\n+                               region: ty::Region)\n {\n     /*!\n      * Ensures that all borrowed data reachable via `ty` outlives `region`.\n@@ -1949,10 +1949,10 @@ fn type_must_outlive(rcx: &mut Rcx,\n     }\n }\n \n-fn param_must_outlive(rcx: &Rcx,\n-                      origin: infer::SubregionOrigin,\n-                      region: ty::Region,\n-                      param_ty: ty::ParamTy) {\n+fn param_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                                origin: infer::SubregionOrigin<'tcx>,\n+                                region: ty::Region,\n+                                param_ty: ty::ParamTy) {\n     let param_env = &rcx.fcx.inh.param_env;\n \n     debug!(\"param_must_outlive(region={}, param_ty={})\","}, {"sha": "d23131962873f6d2c38c1073e92446344c598f70", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -22,22 +22,22 @@ use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub enum WfConstraint {\n-    RegionSubRegionConstraint(Option<Ty>, ty::Region, ty::Region),\n-    RegionSubParamConstraint(Option<Ty>, ty::Region, ty::ParamTy),\n+pub enum WfConstraint<'tcx> {\n+    RegionSubRegionConstraint(Option<Ty<'tcx>>, ty::Region, ty::Region),\n+    RegionSubParamConstraint(Option<Ty<'tcx>>, ty::Region, ty::ParamTy),\n }\n \n struct Wf<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    stack: Vec<(ty::Region, Option<Ty>)>,\n-    out: Vec<WfConstraint>,\n+    stack: Vec<(ty::Region, Option<Ty<'tcx>>)>,\n+    out: Vec<WfConstraint<'tcx>>,\n }\n \n-pub fn region_wf_constraints(\n-    tcx: &ty::ctxt,\n-    ty: Ty,\n+pub fn region_wf_constraints<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    ty: Ty<'tcx>,\n     outer_region: ty::Region)\n-    -> Vec<WfConstraint>\n+    -> Vec<WfConstraint<'tcx>>\n {\n     /*!\n      * This routine computes the well-formedness constraints that must\n@@ -55,7 +55,7 @@ pub fn region_wf_constraints(\n }\n \n impl<'a, 'tcx> Wf<'a, 'tcx> {\n-    fn accumulate_from_ty(&mut self, ty: Ty) {\n+    fn accumulate_from_ty(&mut self, ty: Ty<'tcx>) {\n         debug!(\"Wf::accumulate_from_ty(ty={})\",\n                ty.repr(self.tcx));\n \n@@ -146,9 +146,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_rptr(&mut self,\n-                            ty: Ty,\n+                            ty: Ty<'tcx>,\n                             r_b: ty::Region,\n-                            ty_b: Ty) {\n+                            ty_b: Ty<'tcx>) {\n         // We are walking down a type like this, and current\n         // position is indicated by caret:\n         //\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn push_sub_region_constraint(&mut self,\n-                                  opt_ty: Option<Ty>,\n+                                  opt_ty: Option<Ty<'tcx>>,\n                                   r_a: ty::Region,\n                                   r_b: ty::Region) {\n         /*! Pushes a constraint that `r_a <= r_b`, due to `opt_ty` */\n@@ -213,16 +213,16 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n     fn push_param_constraint(&mut self,\n                              region: ty::Region,\n-                             opt_ty: Option<Ty>,\n+                             opt_ty: Option<Ty<'tcx>>,\n                              param_ty: ty::ParamTy) {\n         /*! Pushes a constraint that `region <= param_ty`, due to `opt_ty` */\n         self.out.push(RegionSubParamConstraint(opt_ty, region, param_ty));\n     }\n \n     fn accumulate_from_adt(&mut self,\n-                           ty: Ty,\n+                           ty: Ty<'tcx>,\n                            def_id: ast::DefId,\n-                           substs: &Substs)\n+                           substs: &Substs<'tcx>)\n     {\n         // The generic declarations from the type, appropriately\n         // substituted for the actual substitutions.\n@@ -322,8 +322,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_closure_ty(&mut self,\n-                                  ty: Ty,\n-                                  c: &ty::ClosureTy)\n+                                  ty: Ty<'tcx>,\n+                                  c: &ty::ClosureTy<'tcx>)\n     {\n         match c.store {\n             ty::RegionTraitStore(r_b, _) => {\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n     }\n \n     fn accumulate_from_object_ty(&mut self,\n-                                 ty: Ty,\n+                                 ty: Ty<'tcx>,\n                                  bounds: &ty::ExistentialBounds)\n     {\n         // Imagine a type like this:"}, {"sha": "5b5c6fe51e8c4fd76c5a2729cede6a2ade941894", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -23,10 +23,10 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{UserString, Repr, ty_to_string};\n \n-pub fn check_object_cast(fcx: &FnCtxt,\n-                         cast_expr: &ast::Expr,\n-                         source_expr: &ast::Expr,\n-                         target_object_ty: Ty)\n+pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   cast_expr: &ast::Expr,\n+                                   source_expr: &ast::Expr,\n+                                   target_object_ty: Ty<'tcx>)\n {\n     debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n            cast_expr.repr(fcx.tcx()),\n@@ -96,10 +96,7 @@ pub fn check_object_cast(fcx: &FnCtxt,\n         }\n     }\n \n-    // Because we currently give unsound lifetimes to the \"t_box\", I\n-    // could have written &'static ty::TyTrait here, but it seems\n-    // gratuitously unsafe.\n-    fn object_trait<'a>(t: &'a Ty) -> &'a ty::TyTrait {\n+    fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n         match ty::get(*t).sty {\n             ty::ty_trait(ref ty_trait) => &**ty_trait,\n             _ => panic!(\"expected ty_trait\")\n@@ -113,10 +110,10 @@ pub fn check_object_cast(fcx: &FnCtxt,\n             (a_mutbl == ast::MutMutable && b_mutbl == ast::MutImmutable)\n     }\n \n-    fn push_cast_obligation(fcx: &FnCtxt,\n-                            cast_expr: &ast::Expr,\n-                            object_trait: &ty::TyTrait,\n-                            referent_ty: Ty) {\n+    fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      cast_expr: &ast::Expr,\n+                                      object_trait: &ty::TyTrait<'tcx>,\n+                                      referent_ty: Ty<'tcx>) {\n         let object_trait_ref =\n             register_object_cast_obligations(fcx,\n                                              cast_expr.span,\n@@ -135,7 +132,9 @@ pub fn check_object_cast(fcx: &FnCtxt,\n // methods are object-safe. A trait method is object-safe if it does not take\n // self by value, has no type parameters and does not use the `Self` type, except\n // in self position.\n-pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Span) {\n+pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 object_trait: &ty::TyTrait<'tcx>,\n+                                 span: Span) {\n     // Skip the fn_once lang item trait since only the compiler should call\n     // `call_once` which is the method which takes self by value. What could go\n     // wrong?\n@@ -169,7 +168,9 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n     }\n \n     // Returns a vec of error messages. If hte vec is empty - no errors!\n-    fn check_object_safety_of_method(tcx: &ty::ctxt, method: &ty::Method) -> Vec<String> {\n+    fn check_object_safety_of_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           method: &ty::Method<'tcx>)\n+                                           -> Vec<String> {\n         /*!\n          * There are some limitations to calling functions through an\n          * object, because (a) the self type is not known\n@@ -231,11 +232,11 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n     }\n }\n \n-pub fn register_object_cast_obligations(fcx: &FnCtxt,\n-                                        span: Span,\n-                                        object_trait: &ty::TyTrait,\n-                                        referent_ty: Ty)\n-                                        -> Rc<ty::TraitRef>\n+pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  span: Span,\n+                                                  object_trait: &ty::TyTrait<'tcx>,\n+                                                  referent_ty: Ty<'tcx>)\n+                                                  -> Rc<ty::TraitRef<'tcx>>\n {\n     // This is just for better error reporting. Kinda goofy. The object type stuff\n     // needs some refactoring so there is a more convenient type to pass around.\n@@ -299,8 +300,8 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     }\n }\n \n-fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n-                     -> (Rc<ty::TraitRef>, Ty)\n+fn resolve_trait_ref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, obligation: &Obligation<'tcx>)\n+                               -> (Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)\n {\n     let trait_ref =\n         fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n@@ -310,15 +311,15 @@ fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n     (Rc::new(trait_ref), self_ty)\n }\n \n-pub fn report_fulfillment_errors(fcx: &FnCtxt,\n-                                 errors: &Vec<FulfillmentError>) {\n+pub fn report_fulfillment_errors<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                           errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors.iter() {\n         report_fulfillment_error(fcx, error);\n     }\n }\n \n-pub fn report_fulfillment_error(fcx: &FnCtxt,\n-                                error: &FulfillmentError) {\n+pub fn report_fulfillment_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          error: &FulfillmentError<'tcx>) {\n     match error.code {\n         CodeSelectionError(ref e) => {\n             report_selection_error(fcx, &error.obligation, e);\n@@ -329,9 +330,9 @@ pub fn report_fulfillment_error(fcx: &FnCtxt,\n     }\n }\n \n-pub fn report_selection_error(fcx: &FnCtxt,\n-                              obligation: &Obligation,\n-                              error: &SelectionError)\n+pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        obligation: &Obligation<'tcx>,\n+                                        error: &SelectionError<'tcx>)\n {\n     match *error {\n         Overflow => {\n@@ -377,7 +378,8 @@ pub fn report_selection_error(fcx: &FnCtxt,\n     }\n }\n \n-pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n+pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        obligation: &Obligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n     // ambiguous impls. The latter *ought* to be a\n@@ -469,8 +471,8 @@ pub fn select_new_fcx_obligations(fcx: &FnCtxt) {\n     }\n }\n \n-fn note_obligation_cause(fcx: &FnCtxt,\n-                         obligation: &Obligation) {\n+fn note_obligation_cause<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   obligation: &Obligation<'tcx>) {\n     let tcx = fcx.tcx();\n     let trait_name = ty::item_path_str(tcx, obligation.trait_ref.def_id);\n     match obligation.cause.code {"}, {"sha": "3557059951500d8cc9f467dda46b370892e9a912", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -29,15 +29,15 @@ use syntax::visit::Visitor;\n \n pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n     ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n-    cache: HashSet<Ty>\n+    cache: HashSet<Ty<'tcx>>\n }\n \n impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>) -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         CheckTypeWellFormedVisitor { ccx: ccx, cache: HashSet::new() }\n     }\n \n-    fn check_item_well_formed(&mut self, ccx: &CrateCtxt, item: &ast::Item) {\n+    fn check_item_well_formed(&mut self, item: &ast::Item) {\n         /*!\n          * Checks that the field types (in a struct def'n) or\n          * argument types (in an enum def'n) are well-formed,\n@@ -55,6 +55,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n          * the types first.\n          */\n \n+        let ccx = self.ccx;\n         debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n                item.id,\n                ty::item_path_str(ccx.tcx, local_def(item.id)));\n@@ -87,9 +88,10 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn with_fcx(&mut self,\n-                ccx: &CrateCtxt,\n                 item: &ast::Item,\n-                f: |&mut CheckTypeWellFormedVisitor, &FnCtxt|) {\n+                f: for<'fcx> |&mut CheckTypeWellFormedVisitor<'ccx, 'tcx>,\n+                              &FnCtxt<'fcx, 'tcx>|) {\n+        let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n         let polytype = ty::lookup_item_type(ccx.tcx, item_def_id);\n         let param_env =\n@@ -106,14 +108,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn check_type_defn(&mut self,\n                        item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<AdtVariant>)\n+                       lookup_fields: for<'fcx> |&FnCtxt<'fcx, 'tcx>|\n+                                                 -> Vec<AdtVariant<'tcx>>)\n     {\n         /*!\n          * In a type definition, we check that to ensure that the types of the fields are\n          * well-formed.\n          */\n \n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let variants = lookup_fields(fcx);\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n@@ -150,7 +153,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_item_type(&mut self,\n                        item: &ast::Item)\n     {\n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n             let polytype = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n@@ -162,7 +165,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_impl(&mut self,\n                   item: &ast::Item)\n     {\n-        self.with_fcx(self.ccx, item, |this, fcx| {\n+        self.with_fcx(item, |this, fcx| {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n \n@@ -245,8 +248,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n }\n \n impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        self.check_item_well_formed(self.ccx, i);\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        self.check_item_well_formed(i);\n         visit::walk_item(self, i);\n     }\n }\n@@ -256,20 +259,20 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     span: Span,\n     scope_id: ast::NodeId,\n     binding_count: uint,\n-    cache: Option<&'cx mut HashSet<Ty>>,\n+    cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n \n impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     pub fn new(fcx: &'cx FnCtxt<'cx,'tcx>,\n                span: Span,\n                scope_id: ast::NodeId,\n-               cache: Option<&'cx mut HashSet<Ty>>)\n+               cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n                -> BoundsChecker<'cx,'tcx> {\n         BoundsChecker { fcx: fcx, span: span, scope_id: scope_id,\n                         cache: cache, binding_count: 0 }\n     }\n \n-    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef) {\n+    pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n         /*!\n          * Given a trait ref like `A : Trait<B>`, where `Trait` is\n          * defined as (say):\n@@ -300,11 +303,11 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         }\n     }\n \n-    pub fn check_ty(&mut self, ty: Ty) {\n+    pub fn check_ty(&mut self, ty: Ty<'tcx>) {\n         ty.fold_with(self);\n     }\n \n-    fn check_traits_in_ty(&mut self, ty: Ty) {\n+    fn check_traits_in_ty(&mut self, ty: Ty<'tcx>) {\n         // When checking types outside of a type def'n, we ignore\n         // region obligations. See discussion below in fold_ty().\n         self.binding_count += 1;\n@@ -318,7 +321,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"BoundsChecker t={}\",\n                t.repr(self.tcx()));\n \n@@ -401,16 +404,18 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // ADT\n \n-struct AdtVariant {\n-    fields: Vec<AdtField>,\n+struct AdtVariant<'tcx> {\n+    fields: Vec<AdtField<'tcx>>,\n }\n \n-struct AdtField {\n-    ty: Ty,\n+struct AdtField<'tcx> {\n+    ty: Ty<'tcx>,\n     span: Span,\n }\n \n-fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n+fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            struct_def: &ast::StructDef)\n+                            -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields\n         .iter()\n@@ -423,7 +428,9 @@ fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n     AdtVariant { fields: fields }\n }\n \n-fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n+fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                           enum_def: &ast::EnumDef)\n+                           -> Vec<AdtVariant<'tcx>> {\n     enum_def.variants.iter()\n         .map(|variant| {\n             match variant.node.kind {\n@@ -457,10 +464,10 @@ fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n ///////////////////////////////////////////////////////////////////////////\n // Special drop trait checking\n \n-fn check_struct_safe_for_destructor(fcx: &FnCtxt,\n-                                    span: Span,\n-                                    self_ty: Ty,\n-                                    struct_did: ast::DefId) {\n+fn check_struct_safe_for_destructor<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                              span: Span,\n+                                              self_ty: Ty<'tcx>,\n+                                              struct_did: ast::DefId) {\n     let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n     if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n         && !struct_tpt.generics.has_region_params(subst::TypeSpace)"}, {"sha": "76d9ed15e518018f08c0c5a239e1fb0bf7fa57b3", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -340,7 +340,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T:ResolveIn>(&self, t: &T, reason: ResolveReason) -> T {\n+    fn resolve<T:ResolveIn<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n         t.resolve_in(&mut Resolver::new(self.fcx, reason))\n     }\n }\n@@ -379,12 +379,12 @@ impl ResolveReason {\n ///////////////////////////////////////////////////////////////////////////\n // Convenience methods for resolving different kinds of things.\n \n-trait ResolveIn {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> Self;\n+trait ResolveIn<'tcx> {\n+    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> Self;\n }\n \n-impl<T:TypeFoldable> ResolveIn for T {\n-    fn resolve_in(&self, resolver: &mut Resolver) -> T {\n+impl<'tcx, T: TypeFoldable<'tcx>> ResolveIn<'tcx> for T {\n+    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> T {\n         self.fold_with(resolver)\n     }\n }\n@@ -465,7 +465,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         if !ty::type_needs_infer(t) {\n             return t;\n         }"}, {"sha": "c12aed77342746411f5a6650609fb317af7ca358", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -55,10 +55,10 @@ use util::ppaux::Repr;\n mod orphan;\n mod overlap;\n \n-fn get_base_type(inference_context: &InferCtxt,\n-                 span: Span,\n-                 original_type: Ty)\n-                 -> Option<Ty> {\n+fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                           span: Span,\n+                           original_type: Ty<'tcx>)\n+                           -> Option<Ty<'tcx>> {\n     let resolved_type = match resolve_type(inference_context,\n                                            Some(span),\n                                            original_type,\n@@ -95,10 +95,10 @@ fn get_base_type(inference_context: &InferCtxt,\n }\n \n // Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id(inference_context: &InferCtxt,\n-                        span: Span,\n-                        original_type: Ty)\n-                        -> Option<DefId> {\n+fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  original_type: Ty<'tcx>)\n+                                  -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n         None => None,\n         Some(base_type) => {\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     fn instantiate_default_methods(\n             &self,\n             impl_id: DefId,\n-            trait_ref: &ty::TraitRef,\n+            trait_ref: &ty::TraitRef<'tcx>,\n             all_impl_items: &mut Vec<ImplOrTraitItemId>) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={}, trait_ref={})\",\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> Polytype {\n+                                        -> Polytype<'tcx> {\n         self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n     }\n \n@@ -478,10 +478,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n-pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n-                                      trait_ref: &ty::TraitRef,\n-                                      method: &ty::Method)\n-                                      -> subst::Substs\n+pub fn make_substs_for_receiver_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            trait_ref: &ty::TraitRef<'tcx>,\n+                                            method: &ty::Method<'tcx>)\n+                                            -> subst::Substs<'tcx>\n {\n     /*!\n      * Substitutes the values for the receiver's type parameters\n@@ -503,14 +503,14 @@ pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n     trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n }\n \n-fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n-                                     impl_id: ast::DefId,\n-                                     impl_poly_type: &ty::Polytype,\n-                                     trait_ref: &ty::TraitRef,\n-                                     new_def_id: ast::DefId,\n-                                     method: &ty::Method,\n-                                     provided_source: Option<ast::DefId>)\n-                                     -> ty::Method\n+fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                           impl_id: ast::DefId,\n+                                           impl_poly_type: &ty::Polytype<'tcx>,\n+                                           trait_ref: &ty::TraitRef<'tcx>,\n+                                           new_def_id: ast::DefId,\n+                                           method: &ty::Method<'tcx>,\n+                                           provided_source: Option<ast::DefId>)\n+                                           -> ty::Method<'tcx>\n {\n     let combined_substs = make_substs_for_receiver_types(tcx, trait_ref, method);\n "}, {"sha": "8ed630e88618954cba5eabe3a3cfb8e6a15e732e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 156, "deletions": 151, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -136,26 +136,26 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-pub trait ToTy {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty;\n+pub trait ToTy<'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n }\n \n-impl<'a,'tcx> ToTy for ImplCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty {\n+impl<'a,'tcx> ToTy<'tcx> for ImplCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl<'a,'tcx> ToTy for CrateCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty {\n+impl<'a,'tcx> ToTy<'tcx> for CrateCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         if id.krate != ast::LOCAL_CRATE {\n             return csearch::get_type(self.tcx, id)\n         }\n@@ -177,37 +177,37 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         get_trait_def(self, id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx.sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures.\");\n         ty::mk_err()\n     }\n \n-    fn associated_types_of_trait_are_valid(&self, _: Ty, _: ast::DefId)\n+    fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)\n                                            -> bool {\n         false\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               _: Option<Ty>,\n+                               _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         self.tcx().sess.span_err(span, \"associated types may not be \\\n                                         referenced here\");\n         ty::mk_err()\n     }\n }\n \n-pub fn get_enum_variant_types(ccx: &CrateCtxt,\n-                              enum_ty: Ty,\n-                              variants: &[P<ast::Variant>],\n-                              generics: &ast::Generics) {\n+pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        enum_ty: Ty<'tcx>,\n+                                        variants: &[P<ast::Variant>],\n+                                        generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -253,9 +253,9 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     }\n }\n \n-fn collect_trait_methods(ccx: &CrateCtxt,\n-                         trait_id: ast::NodeId,\n-                         trait_def: &ty::TraitDef) {\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   trait_id: ast::NodeId,\n+                                   trait_def: &ty::TraitDef<'tcx>) {\n     let tcx = ccx.tcx;\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n@@ -365,26 +365,26 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n         _ => { /* Ignore things that aren't traits */ }\n     }\n \n-    fn make_method_ty(ccx: &CrateCtxt, m: &ty::Method) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             Polytype {\n                 generics: m.generics.clone(),\n                 ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n     }\n \n-    fn ty_method_of_trait_method(ccx: &CrateCtxt,\n-                                 trait_id: ast::NodeId,\n-                                 trait_generics: &ty::Generics,\n-                                 trait_items: &[ast::TraitItem],\n-                                 m_id: &ast::NodeId,\n-                                 m_name: &ast::Name,\n-                                 m_explicit_self: &ast::ExplicitSelf,\n-                                 m_abi: abi::Abi,\n-                                 m_generics: &ast::Generics,\n-                                 m_fn_style: &ast::FnStyle,\n-                                 m_decl: &ast::FnDecl)\n-                                 -> ty::Method {\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                           trait_id: ast::NodeId,\n+                                           trait_generics: &ty::Generics<'tcx>,\n+                                           trait_items: &[ast::TraitItem],\n+                                           m_id: &ast::NodeId,\n+                                           m_name: &ast::Name,\n+                                           m_explicit_self: &ast::ExplicitSelf,\n+                                           m_abi: abi::Abi,\n+                                           m_generics: &ast::Generics,\n+                                           m_fn_style: &ast::FnStyle,\n+                                           m_decl: &ast::FnDecl)\n+                                           -> ty::Method<'tcx> {\n         let ty_generics =\n             ty_generics_for_fn_or_method(\n                 ccx,\n@@ -423,10 +423,10 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert_field(ccx: &CrateCtxt,\n-                     struct_generics: &ty::Generics,\n-                     v: &ast::StructField,\n-                     origin: ast::DefId) -> ty::field_ty {\n+pub fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                struct_generics: &ty::Generics<'tcx>,\n+                                v: &ast::StructField,\n+                                origin: ast::DefId) -> ty::field_ty {\n     let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n@@ -456,10 +456,10 @@ pub fn convert_field(ccx: &CrateCtxt,\n     }\n }\n \n-fn convert_associated_type(ccx: &CrateCtxt,\n-                           trait_def: &ty::TraitDef,\n-                           associated_type: &ast::AssociatedType)\n-                           -> ty::Polytype {\n+fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                     trait_def: &ty::TraitDef<'tcx>,\n+                                     associated_type: &ast::AssociatedType)\n+                                     -> ty::Polytype<'tcx> {\n     // Find the type parameter ID corresponding to this\n     // associated type.\n     let type_parameter_def = trait_def.generics\n@@ -515,14 +515,14 @@ enum ConvertMethodContext<'a> {\n     TraitConvertMethodContext(ast::DefId, &'a [ast::TraitItem]),\n }\n \n-fn convert_methods<'a,I>(ccx: &CrateCtxt,\n-                         convert_method_context: ConvertMethodContext,\n-                         container: ImplOrTraitItemContainer,\n-                         mut ms: I,\n-                         untransformed_rcvr_ty: Ty,\n-                         rcvr_ty_generics: &ty::Generics,\n-                         rcvr_visibility: ast::Visibility)\n-                         where I: Iterator<&'a ast::Method> {\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                 convert_method_context: ConvertMethodContext,\n+                                 container: ImplOrTraitItemContainer,\n+                                 mut ms: I,\n+                                 untransformed_rcvr_ty: Ty<'tcx>,\n+                                 rcvr_ty_generics: &ty::Generics<'tcx>,\n+                                 rcvr_visibility: ast::Visibility)\n+                                 where I: Iterator<&'i ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n             rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -564,14 +564,14 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method(ccx: &CrateCtxt,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     convert_method_context: ConvertMethodContext,\n-                    container: ImplOrTraitItemContainer,\n-                    m: &ast::Method,\n-                    untransformed_rcvr_ty: Ty,\n-                    rcvr_ty_generics: &ty::Generics,\n-                    rcvr_visibility: ast::Visibility)\n-                    -> ty::Method {\n+                              container: ImplOrTraitItemContainer,\n+                              m: &ast::Method,\n+                              untransformed_rcvr_ty: Ty<'tcx>,\n+                              rcvr_ty_generics: &ty::Generics<'tcx>,\n+                              rcvr_visibility: ast::Visibility)\n+                              -> ty::Method<'tcx> {\n         let m_ty_generics =\n             ty_generics_for_fn_or_method(\n                 ccx,\n@@ -679,12 +679,12 @@ fn is_associated_type_valid_for_param(ty: Ty,\n     false\n }\n \n-fn find_associated_type_in_generics(tcx: &ty::ctxt,\n-                                    span: Span,\n-                                    ty: Option<Ty>,\n-                                    associated_type_id: ast::DefId,\n-                                    generics: &ty::Generics)\n-                                    -> Ty {\n+fn find_associated_type_in_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          span: Span,\n+                                          ty: Option<Ty<'tcx>>,\n+                                          associated_type_id: ast::DefId,\n+                                          generics: &ty::Generics<'tcx>)\n+                                          -> Ty<'tcx> {\n     let ty = match ty {\n         None => {\n             tcx.sess.span_bug(span,\n@@ -732,28 +732,28 @@ struct ImplCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     opt_trait_ref_id: Option<ast::DefId>,\n     impl_items: &'a [ast::ImplItem],\n-    impl_generics: &'a ty::Generics,\n+    impl_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is the trait we're\n@@ -774,10 +774,10 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty\n+                               -> Ty<'tcx>\n     {\n         let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n@@ -821,28 +821,28 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n \n struct FnCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n-    generics: &'a ty::Generics,\n+    generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -852,10 +852,10 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::FnCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -870,39 +870,39 @@ impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n \n struct ImplMethodCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n-    method_generics: &'a ty::Generics,\n+    method_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n     }\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -919,28 +919,28 @@ struct TraitMethodCtxt<'a,'tcx:'a> {\n     ccx: &'a CrateCtxt<'a,'tcx>,\n     trait_id: ast::DefId,\n     trait_items: &'a [ast::TraitItem],\n-    method_generics: &'a ty::Generics,\n+    method_generics: &'a ty::Generics<'tcx>,\n }\n \n impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.ccx.tcx\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.ccx.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.ccx.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.ccx.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is this trait.\n@@ -955,10 +955,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n \n         // If this is one of our own associated types, return it.\n@@ -997,30 +997,30 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n     }\n }\n \n-struct GenericsCtxt<'a,AC:'a> {\n+struct GenericsCtxt<'a,'tcx:'a,AC:'a> {\n     chain: &'a AC,\n-    associated_types_generics: &'a ty::Generics,\n+    associated_types_generics: &'a ty::Generics<'tcx>,\n }\n \n-impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n+impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,'tcx,AC> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n         self.chain.tcx()\n     }\n \n-    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype<'tcx> {\n         self.chain.get_item_ty(id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n         self.chain.get_trait_def(id)\n     }\n \n-    fn ty_infer(&self, span: Span) -> Ty {\n+    fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         self.chain.ty_infer(span)\n     }\n \n     fn associated_types_of_trait_are_valid(&self,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            trait_id: ast::DefId)\n                                            -> bool {\n         // OK if the trait with the associated type is one of the traits in\n@@ -1032,10 +1032,10 @@ impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty>,\n+                               ty: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty {\n+                               -> Ty<'tcx> {\n         debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n \n         // The ID should map to an associated type on one of the traits in\n@@ -1241,10 +1241,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-pub fn convert_struct(ccx: &CrateCtxt,\n-                      struct_def: &ast::StructDef,\n-                      pty: ty::Polytype,\n-                      id: ast::NodeId) {\n+pub fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                struct_def: &ast::StructDef,\n+                                pty: ty::Polytype<'tcx>,\n+                                id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n@@ -1324,7 +1324,9 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n-fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n+fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           trait_id: ast::DefId)\n+                           -> Rc<ty::TraitDef<'tcx>> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n@@ -1338,7 +1340,9 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n+pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   it: &ast::Item)\n+                                   -> Rc<ty::TraitDef<'tcx>> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.trait_defs.borrow().get(&def_id) {\n@@ -1387,11 +1391,11 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n \n     return trait_def;\n \n-    fn mk_trait_substs(ccx: &CrateCtxt,\n-                       trait_id: ast::NodeId,\n-                       generics: &ast::Generics,\n-                       items: &[ast::TraitItem])\n-                        -> subst::Substs\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                 trait_id: ast::NodeId,\n+                                 generics: &ast::Generics,\n+                                 items: &[ast::TraitItem])\n+                                 -> subst::Substs<'tcx>\n     {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n@@ -1437,8 +1441,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     }\n }\n \n-pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n-                  -> ty::Polytype {\n+pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n+                            -> ty::Polytype<'tcx> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.borrow().get(&def_id) {\n@@ -1537,9 +1541,9 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n     }\n }\n \n-pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n-                          it: &ast::ForeignItem,\n-                          abi: abi::Abi) -> ty::Polytype\n+pub fn ty_of_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                    it: &ast::ForeignItem,\n+                                    abi: abi::Abi) -> ty::Polytype<'tcx>\n {\n     match it.node {\n         ast::ForeignItemFn(ref fn_decl, ref generics) => {\n@@ -1558,8 +1562,9 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n-fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n-                    -> ty::Polytype {\n+fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                              trait_item: &ast::TraitItem)\n+                              -> ty::Polytype<'tcx> {\n     match *trait_item {\n         ast::RequiredMethod(ref m) => {\n             ccx.tcx.sess.span_bug(m.span,\n@@ -1584,11 +1589,11 @@ fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n     }\n }\n \n-fn ty_generics_for_type(ccx: &CrateCtxt,\n-                        generics: &ast::Generics,\n-                        create_type_parameters_for_associated_types:\n-                            CreateTypeParametersForAssociatedTypesFlag)\n-                        -> ty::Generics {\n+fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                  generics: &ast::Generics,\n+                                  create_type_parameters_for_associated_types:\n+                                      CreateTypeParametersForAssociatedTypesFlag)\n+                                  -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes.as_slice(),\n@@ -1598,12 +1603,12 @@ fn ty_generics_for_type(ccx: &CrateCtxt,\n                 create_type_parameters_for_associated_types)\n }\n \n-fn ty_generics_for_trait(ccx: &CrateCtxt,\n-                         trait_id: ast::NodeId,\n-                         substs: &subst::Substs,\n-                         ast_generics: &ast::Generics,\n-                         items: &[ast::TraitItem])\n-                         -> ty::Generics {\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                   trait_id: ast::NodeId,\n+                                   substs: &subst::Substs<'tcx>,\n+                                   ast_generics: &ast::Generics,\n+                                   items: &[ast::TraitItem])\n+                                   -> ty::Generics<'tcx> {\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n@@ -1667,10 +1672,10 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n-        base_generics: ty::Generics,\n+        base_generics: ty::Generics<'tcx>,\n         create_type_parameters_for_associated_types:\n         CreateTypeParametersForAssociatedTypesFlag)\n-        -> ty::Generics\n+        -> ty::Generics<'tcx>\n         where AC: AstConv<'tcx> {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(this,\n@@ -1730,11 +1735,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n-                        base_generics: ty::Generics,\n+                        base_generics: ty::Generics<'tcx>,\n                         where_clause: &ast::WhereClause,\n                         create_type_parameters_for_associated_types_flag:\n                         CreateTypeParametersForAssociatedTypesFlag)\n-                        -> ty::Generics\n+                        -> ty::Generics<'tcx>\n                         where AC: AstConv<'tcx>\n {\n     let mut result = base_generics;\n@@ -1801,7 +1806,7 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         this: &AC,\n         space: subst::ParamSpace,\n         types: &[ast::TyParam],\n-        associated_types_generics: &mut ty::Generics)\n+        associated_types_generics: &mut ty::Generics<'tcx>)\n         where AC: AstConv<'tcx>\n     {\n         // The idea here is roughly as follows. We start with\n@@ -1880,7 +1885,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              index: uint,\n                                              where_clause: &ast::WhereClause,\n                                              associated_with: Option<ast::DefId>)\n-                                             -> ty::TypeParameterDef\n+                                             -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n {\n     match this.tcx().ty_param_defs.borrow().get(&param.id) {\n@@ -1939,7 +1944,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            unbound: &Option<ast::TraitRef>,\n                            span: Span,\n                            where_clause: &ast::WhereClause)\n-                           -> ty::ParamBounds\n+                           -> ty::ParamBounds<'tcx>\n                            where AC: AstConv<'tcx> {\n     /*!\n      * Translate the AST's notion of ty param bounds (which are an\n@@ -1971,10 +1976,10 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n     param_bounds\n }\n \n-fn check_bounds_compatible(tcx: &ty::ctxt,\n-                           name_of_bounded_thing: ast::Name,\n-                           param_bounds: &ty::ParamBounds,\n-                           span: Span) {\n+fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 name_of_bounded_thing: ast::Name,\n+                                 param_bounds: &ty::ParamBounds<'tcx>,\n+                                 span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n     // Sized/Unsized.\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n@@ -2000,7 +2005,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                               param_ty: ty::ParamTy,\n                               ast_bounds: &[ast::TyParamBound],\n                               where_clause: &ast::WhereClause)\n-                              -> ty::ParamBounds\n+                              -> ty::ParamBounds<'tcx>\n                               where AC: AstConv<'tcx> {\n     let all_bounds =\n         merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n@@ -2064,12 +2069,12 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n     result\n }\n \n-pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n-                             decl: &ast::FnDecl,\n-                             def_id: ast::DefId,\n-                             ast_generics: &ast::Generics,\n-                             abi: abi::Abi)\n-                             -> ty::Polytype {\n+pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                       decl: &ast::FnDecl,\n+                                       def_id: ast::DefId,\n+                                       ast_generics: &ast::Generics,\n+                                       abi: abi::Abi)\n+                                       -> ty::Polytype<'tcx> {\n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n@@ -2117,9 +2122,9 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     return pty;\n }\n \n-pub fn mk_item_substs(ccx: &CrateCtxt,\n-                      ty_generics: &ty::Generics)\n-                      -> subst::Substs\n+pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                ty_generics: &ty::Generics<'tcx>)\n+                                -> subst::Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -2135,10 +2140,10 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n \n /// Verifies that the explicit self type of a method matches the impl or\n /// trait.\n-fn check_method_self_type<RS:RegionScope>(\n-    crate_context: &CrateCtxt,\n+fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n+    crate_context: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n-    required_type: Ty,\n+    required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {"}, {"sha": "c2e9a5d513325a73cbadc8047f044b4efca9ad54", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -88,7 +88,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let Coerce(ref v) = *self; v\n     }\n \n-    pub fn tys(&self, a: Ty, b: Ty) -> CoerceResult {\n+    pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.get_ref().infcx.tcx),\n                b.repr(self.get_ref().infcx.tcx));\n@@ -190,14 +190,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn subtype(&self, a: Ty, b: Ty) -> CoerceResult {\n+    pub fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n         match Sub(self.get_ref().clone()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n     }\n \n-    pub fn unpack_actual_value<T>(&self, a: Ty, f: |&ty::sty| -> T)\n+    pub fn unpack_actual_value<T>(&self, a: Ty<'tcx>, f: |&ty::sty<'tcx>| -> T)\n                                   -> T {\n         match resolve_type(self.get_ref().infcx, None,\n                            a, try_resolve_tvar_shallow) {\n@@ -215,11 +215,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n     pub fn coerce_borrowed_pointer(&self,\n-                                   a: Ty,\n-                                   sty_a: &ty::sty,\n-                                   b: Ty,\n+                                   a: Ty<'tcx>,\n+                                   sty_a: &ty::sty<'tcx>,\n+                                   b: Ty<'tcx>,\n                                    mutbl_b: ast::Mutability)\n-                                   -> CoerceResult {\n+                                   -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -258,10 +258,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // or &mut [T, ..n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n     fn coerce_unsized(&self,\n-                      a: Ty,\n-                      sty_a: &ty::sty,\n-                      b: Ty)\n-                      -> CoerceResult {\n+                      a: Ty<'tcx>,\n+                      sty_a: &ty::sty<'tcx>,\n+                      b: Ty<'tcx>)\n+                      -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsized(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -349,10 +349,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // performed to unsize it.\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n-                 ty_a: Ty,\n-                 sty_a: &ty::sty,\n-                 ty_b: Ty)\n-                 -> Option<(Ty, ty::UnsizeKind)> {\n+                 ty_a: Ty<'tcx>,\n+                 sty_a: &ty::sty<'tcx>,\n+                 ty_b: Ty<'tcx>)\n+                 -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n         debug!(\"unsize_ty(sty_a={}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n@@ -425,10 +425,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_borrowed_object(&self,\n-                              a: Ty,\n-                              sty_a: &ty::sty,\n-                              b: Ty,\n-                              b_mutbl: ast::Mutability) -> CoerceResult\n+                              a: Ty<'tcx>,\n+                              sty_a: &ty::sty<'tcx>,\n+                              b: Ty<'tcx>,\n+                              b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -445,10 +445,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_unsafe_object(&self,\n-                            a: Ty,\n-                            sty_a: &ty::sty,\n-                            b: Ty,\n-                            b_mutbl: ast::Mutability) -> CoerceResult\n+                            a: Ty<'tcx>,\n+                            sty_a: &ty::sty<'tcx>,\n+                            b: Ty<'tcx>,\n+                            b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -462,12 +462,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     fn coerce_object(&self,\n-                     a: Ty,\n-                     sty_a: &ty::sty,\n-                     b: Ty,\n+                     a: Ty<'tcx>,\n+                     sty_a: &ty::sty<'tcx>,\n+                     b: Ty<'tcx>,\n                      b_mutbl: ast::Mutability,\n-                     mk_ty: |Ty| -> Ty,\n-                     mk_adjust: || -> ty::AutoRef) -> CoerceResult\n+                     mk_ty: |Ty<'tcx>| -> Ty<'tcx>,\n+                     mk_adjust: || -> ty::AutoRef<'tcx>) -> CoerceResult<'tcx>\n     {\n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -494,10 +494,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_borrowed_fn(&self,\n-                              a: Ty,\n-                              sty_a: &ty::sty,\n-                              b: Ty)\n-                              -> CoerceResult {\n+                              a: Ty<'tcx>,\n+                              sty_a: &ty::sty<'tcx>,\n+                              b: Ty<'tcx>)\n+                              -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_fn(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));\n@@ -512,8 +512,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    fn coerce_from_bare_fn(&self, a: Ty, fn_ty_a: &ty::BareFnTy, b: Ty)\n-                           -> CoerceResult {\n+    fn coerce_from_bare_fn(&self, a: Ty<'tcx>, fn_ty_a: &ty::BareFnTy<'tcx>, b: Ty<'tcx>)\n+                           -> CoerceResult<'tcx> {\n         /*!\n          *\n          * Attempts to coerce from a bare Rust function (`extern\n@@ -546,11 +546,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n \n     pub fn coerce_unsafe_ptr(&self,\n-                             a: Ty,\n-                             sty_a: &ty::sty,\n-                             b: Ty,\n+                             a: Ty<'tcx>,\n+                             sty_a: &ty::sty<'tcx>,\n+                             b: Ty<'tcx>,\n                              mutbl_b: ast::Mutability)\n-                             -> CoerceResult {\n+                             -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n                b.repr(self.get_ref().infcx.tcx));"}, {"sha": "811284cdd727892c558bbe38a422fd79f06f7bc5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -62,22 +62,22 @@ pub trait Combine<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n-    fn trace(&self) -> TypeTrace;\n+    fn trace(&self) -> TypeTrace<'tcx>;\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx>;\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx>;\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx>;\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx>;\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n-    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty>;\n-    fn tys(&self, a: Ty, b: Ty) -> cres<Ty>;\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>>;\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n \n     fn tps(&self,\n            _: subst::ParamSpace,\n-           as_: &[Ty],\n-           bs: &[Ty])\n-           -> cres<Vec<Ty>> {\n+           as_: &[Ty<'tcx>],\n+           bs: &[Ty<'tcx>])\n+           -> cres<'tcx, Vec<Ty<'tcx>>> {\n         // FIXME -- In general, we treat variance a bit wrong\n         // here. For historical reasons, we treat tps and Self\n         // as invariant. This is overly conservative.\n@@ -96,9 +96,9 @@ pub trait Combine<'tcx> {\n \n     fn substs(&self,\n               item_def_id: ast::DefId,\n-              a_subst: &subst::Substs,\n-              b_subst: &subst::Substs)\n-              -> cres<subst::Substs>\n+              a_subst: &subst::Substs<'tcx>,\n+              b_subst: &subst::Substs<'tcx>)\n+              -> cres<'tcx, subst::Substs<'tcx>>\n     {\n         let variances = if self.infcx().tcx.variance_computed.get() {\n             Some(ty::item_variances(self.infcx().tcx, item_def_id))\n@@ -110,9 +110,9 @@ pub trait Combine<'tcx> {\n \n     fn substs_variances(&self,\n                         variances: Option<&ty::ItemVariances>,\n-                        a_subst: &subst::Substs,\n-                        b_subst: &subst::Substs)\n-                        -> cres<subst::Substs>\n+                        a_subst: &subst::Substs<'tcx>,\n+                        b_subst: &subst::Substs<'tcx>)\n+                        -> cres<'tcx, subst::Substs<'tcx>>\n     {\n         let mut substs = subst::Substs::empty();\n \n@@ -161,7 +161,7 @@ pub trait Combine<'tcx> {\n                                                         variances: &[ty::Variance],\n                                                         a_rs: &[ty::Region],\n                                                         b_rs: &[ty::Region])\n-                                                        -> cres<Vec<ty::Region>> {\n+                                                        -> cres<'tcx, Vec<ty::Region>> {\n             let tcx = this.infcx().tcx;\n             let num_region_params = variances.len();\n \n@@ -192,8 +192,8 @@ pub trait Combine<'tcx> {\n         }\n     }\n \n-    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy<'tcx>,\n+                   b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n         let fn_style = try!(self.fn_styles(a.fn_style, b.fn_style));\n         let abi = try!(self.abi(a.abi, b.abi));\n         let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n@@ -202,8 +202,8 @@ pub trait Combine<'tcx> {\n                 sig: sig})\n     }\n \n-    fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+    fn closure_tys(&self, a: &ty::ClosureTy<'tcx>,\n+                   b: &ty::ClosureTy<'tcx>) -> cres<'tcx, ty::ClosureTy<'tcx>> {\n \n         let store = match (a.store, b.store) {\n             (ty::RegionTraitStore(a_r, a_m),\n@@ -235,28 +235,28 @@ pub trait Combine<'tcx> {\n         })\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>>;\n \n-    fn args(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle>;\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle>;\n \n-    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {\n+    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<'tcx, abi::Abi> {\n         if a == b {\n             Ok(a)\n         } else {\n             Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness>;\n \n     fn existential_bounds(&self,\n                           a: ty::ExistentialBounds,\n                           b: ty::ExistentialBounds)\n-                          -> cres<ty::ExistentialBounds>\n+                          -> cres<'tcx, ty::ExistentialBounds>\n     {\n         let r = try!(self.contraregions(a.region_bound, b.region_bound));\n         let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n@@ -267,18 +267,18 @@ pub trait Combine<'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds>;\n+                      -> cres<'tcx, ty::BuiltinBounds>;\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                  -> cres<ty::Region>;\n+                  -> cres<'tcx, ty::Region>;\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n     fn trait_stores(&self,\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                    -> cres<ty::TraitStore> {\n+                    -> cres<'tcx, ty::TraitStore> {\n         debug!(\"{}.trait_stores(a={}, b={})\", self.tag(), a, b);\n \n         match (a, b) {\n@@ -300,9 +300,9 @@ pub trait Combine<'tcx> {\n     }\n \n     fn trait_refs(&self,\n-                  a: &ty::TraitRef,\n-                  b: &ty::TraitRef)\n-                  -> cres<ty::TraitRef>;\n+                  a: &ty::TraitRef<'tcx>,\n+                  b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>;\n     // this must be overridden to do correctly, so as to account for higher-ranked\n     // behavior\n }\n@@ -311,7 +311,7 @@ pub trait Combine<'tcx> {\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n-    pub trace: TypeTrace,\n+    pub trace: TypeTrace<'tcx>,\n }\n \n pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n@@ -323,7 +323,10 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n     }\n }\n \n-pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: Ty, b: Ty) -> cres<Ty> {\n+pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n+                                         a: Ty<'tcx>,\n+                                         b: Ty<'tcx>)\n+                                         -> cres<'tcx, Ty<'tcx>> {\n \n     let tcx = this.infcx().tcx;\n     let a_sty = &ty::get(a).sty;\n@@ -513,7 +516,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: Ty, b: Ty) -> cres<Ty> {\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::IntVid,\n-        val: ty::IntVarValue) -> cres<Ty>\n+        val: ty::IntVarValue) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n@@ -526,7 +529,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: Ty, b: Ty) -> cres<Ty> {\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n-        val: ast::FloatTy) -> cres<Ty>\n+        val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))\n@@ -550,10 +553,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     pub fn instantiate(&self,\n-                       a_ty: Ty,\n+                       a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n-                       -> cres<()>\n+                       -> cres<'tcx, ()>\n     {\n         let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n@@ -640,10 +643,10 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n     }\n \n     fn generalize(&self,\n-                  ty: Ty,\n+                  ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> cres<Ty>\n+                  -> cres<'tcx, Ty<'tcx>>\n     {\n         /*!\n          * Attempts to generalize `ty` for the type variable\n@@ -681,7 +684,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         // Check to see whether the type we are genealizing references\n         // `vid`. At the same time, also update any type variables to\n         // the values that they are bound to. This is needed to truly"}, {"sha": "86c51fff640e79aab0e834816df67802caf2c3bf", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -36,22 +36,22 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"eq\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.tys(a, b)\n     }\n \n-    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         self.regions(a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n@@ -60,7 +60,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         Ok(a)\n     }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         debug!(\"mts({} <: {})\",\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n@@ -70,15 +70,15 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         Ok(ty::mt { mutbl: a.mutbl, ty: t })\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         if a != b {\n             Err(ty::terr_fn_style_mismatch(expected_found(self, a, b)))\n         } else {\n             Ok(a)\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         if a != b {\n             Err(ty::terr_onceness_mismatch(expected_found(self, a, b)))\n         } else {\n@@ -89,7 +89,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: BuiltinBounds,\n                       b: BuiltinBounds)\n-                      -> cres<BuiltinBounds>\n+                      -> cres<'tcx, BuiltinBounds>\n     {\n         // More bounds is a subtype of fewer bounds.\n         //\n@@ -103,7 +103,7 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -133,12 +133,14 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         try!(self.sub().fn_sigs(a, b));\n         self.sub().fn_sigs(b, a)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         try!(self.sub().trait_refs(a, b));\n         self.sub().trait_refs(b, a)\n     }"}, {"sha": "7a7a7c796740aa646feab24154e764124edb56e3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -97,65 +97,65 @@ use util::ppaux::note_and_explain_region;\n // messages shouldn't include debug serializations.\n use util::ppaux::UserString;\n \n-pub trait ErrorReporting {\n+pub trait ErrorReporting<'tcx> {\n     fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError>);\n+                            errors: &Vec<RegionResolutionError<'tcx>>);\n \n-    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n-                      -> Vec<RegionResolutionError>;\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n+                      -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>);\n \n     fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace,\n-                                     terr: &ty::type_err);\n+                                     trace: TypeTrace<'tcx>,\n+                                     terr: &ty::type_err<'tcx>);\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<String>;\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n-    fn expected_found_str<T: UserString + Resolvable>(\n+    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin,\n+                               origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n                                sup: Region);\n \n     fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin,\n+                                  origin: SubregionOrigin<'tcx>,\n                                   param_ty: ty::ParamTy,\n                                   sub: Region,\n                                   sups: Vec<Region>);\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin,\n+                               sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region,\n-                               sup_origin: SubregionOrigin,\n+                               sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region);\n \n     fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               origin1: SubregionOrigin,\n+                               origin1: SubregionOrigin<'tcx>,\n                                region1: Region,\n-                               origin2: SubregionOrigin,\n+                               origin2: SubregionOrigin<'tcx>,\n                                region2: Region);\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace, ty::type_err)],\n+                               trace_origin: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n }\n \n-trait ErrorReportingHelpers {\n+trait ErrorReportingHelpers<'tcx> {\n     fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin);\n \n     fn note_region_origin(&self,\n-                          origin: &SubregionOrigin);\n+                          origin: &SubregionOrigin<'tcx>);\n \n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n@@ -166,9 +166,9 @@ trait ErrorReportingHelpers {\n                                 span: codemap::Span);\n }\n \n-impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError>) {\n+                            errors: &Vec<RegionResolutionError<'tcx>>) {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n@@ -216,8 +216,8 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     // complete view of what lifetimes should be the same.\n     // If the return value is an empty vector, it means that processing\n     // failed (so the return value of this method should not be used)\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError>)\n-                      -> Vec<RegionResolutionError> {\n+    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n+                      -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"process_errors()\");\n         let mut var_origins = Vec::new();\n         let mut trace_origins = Vec::new();\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace, terr: &ty::type_err) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::type_err<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -385,13 +385,13 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace,\n-                                     terr: &ty::type_err) {\n+                                     trace: TypeTrace<'tcx>,\n+                                     terr: &ty::type_err<'tcx>) {\n         self.report_type_error(trace, terr);\n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(&self, values: &ValuePairs) -> Option<String> {\n+    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String> {\n         /*!\n          * Returns a string of the form \"expected `{}`, found `{}`\",\n          * or None if this is a derived error.\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString + Resolvable>(\n+    fn expected_found_str<T: UserString<'tcx> + Resolvable<'tcx>>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_param_bound_failure(&self,\n-                                  origin: SubregionOrigin,\n+                                  origin: SubregionOrigin<'tcx>,\n                                   param_ty: ty::ParamTy,\n                                   sub: Region,\n                                   _sups: Vec<Region>) {\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin,\n+                               origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n                                sup: Region) {\n         match origin {\n@@ -786,9 +786,9 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin,\n+                               sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region,\n-                               sup_origin: SubregionOrigin,\n+                               sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region) {\n         self.report_inference_failure(var_origin);\n \n@@ -811,9 +811,9 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n-                               origin1: SubregionOrigin,\n+                               origin1: SubregionOrigin<'tcx>,\n                                region1: Region,\n-                               origin2: SubregionOrigin,\n+                               origin2: SubregionOrigin<'tcx>,\n                                region2: Region) {\n         self.report_inference_failure(var_origin);\n \n@@ -836,7 +836,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace, ty::type_err)],\n+                               trace_origins: &[(TypeTrace<'tcx>, ty::type_err<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins.iter() {\n             self.report_inference_failure(vo.clone());\n@@ -1430,7 +1430,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n@@ -1483,7 +1483,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                     var_description).as_slice());\n     }\n \n-    fn note_region_origin(&self, origin: &SubregionOrigin) {\n+    fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -1674,22 +1674,23 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub trait Resolvable {\n-    fn resolve(&self, infcx: &InferCtxt) -> Self;\n+pub trait Resolvable<'tcx> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n     fn contains_error(&self) -> bool;\n }\n \n-impl Resolvable for Ty {\n-    fn resolve(&self, infcx: &InferCtxt) -> Ty {\n+impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {\n         ty::type_is_error(*self)\n     }\n }\n \n-impl Resolvable for Rc<ty::TraitRef> {\n-    fn resolve(&self, infcx: &InferCtxt) -> Rc<ty::TraitRef> {\n+impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n+                   -> Rc<ty::TraitRef<'tcx>> {\n         Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "671d2e3837c798d8bad9bc820be0e4c4edd602d8", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -39,14 +39,14 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"glb\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.fields.infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n@@ -77,18 +77,18 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.lub().tys(a, b)\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         match (a, b) {\n           (NormalFn, _) | (_, NormalFn) => Ok(NormalFn),\n           (UnsafeFn, UnsafeFn) => Ok(UnsafeFn)\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         match (a, b) {\n             (Many, _) | (_, Many) => Ok(Many),\n             (Once, Once) => Ok(Once)\n@@ -98,13 +98,13 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds> {\n+                      -> cres<'tcx, ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the GLB (mutual subtype) is the union.\n         Ok(a.union(b))\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n@@ -114,19 +114,21 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n+                    -> cres<'tcx, ty::Region> {\n         self.lub().regions(a, b)\n     }\n \n-    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_glb(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "812aa5c55572814c22e4df034da1b32fbc31d5b9", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -22,26 +22,27 @@ use syntax::codemap::Span;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{bound_region_to_string, Repr};\n \n-pub trait HigherRankedCombineable : HigherRankedFoldable + TypeFoldable + Repr {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<Self>;\n+pub trait HigherRankedCombineable<'tcx>: HigherRankedFoldable<'tcx> +\n+                                         TypeFoldable<'tcx> + Repr<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n }\n \n-pub trait HigherRankedRelations {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+pub trait HigherRankedRelations<'tcx> {\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable;\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>;\n }\n \n-impl<'tcx,C> HigherRankedRelations for C\n+impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     where C : Combine<'tcx>\n {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n                a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -121,8 +122,8 @@ impl<'tcx,C> HigherRankedRelations for C\n         return Ok(result);\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         // Make a mark so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -209,8 +210,8 @@ impl<'tcx,C> HigherRankedRelations for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n-        where T : HigherRankedCombineable\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n+        where T : HigherRankedCombineable<'tcx>\n     {\n         debug!(\"{}.higher_ranked_glb({}, {})\",\n                self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -345,9 +346,9 @@ impl<'tcx,C> HigherRankedRelations for C\n     }\n }\n \n-impl HigherRankedCombineable for ty::FnSig {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig, b: &ty::FnSig)\n-                                           -> cres<ty::FnSig>\n+impl<'tcx> HigherRankedCombineable<'tcx> for ty::FnSig<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+                                      -> cres<'tcx, ty::FnSig<'tcx>>\n     {\n         if a.variadic != b.variadic {\n             return Err(ty::terr_variadic_mismatch(\n@@ -374,9 +375,9 @@ impl HigherRankedCombineable for ty::FnSig {\n \n \n         fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[Ty],\n-                                           b_args: &[Ty])\n-                                           -> cres<Vec<Ty>>\n+                                           a_args: &[Ty<'tcx>],\n+                                           b_args: &[Ty<'tcx>])\n+                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n         {\n             if a_args.len() == b_args.len() {\n                 a_args.iter().zip(b_args.iter())\n@@ -388,9 +389,11 @@ impl HigherRankedCombineable for ty::FnSig {\n     }\n }\n \n-impl HigherRankedCombineable for ty::TraitRef {\n-    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::TraitRef, b: &ty::TraitRef)\n-                                           -> cres<ty::TraitRef>\n+impl<'tcx> HigherRankedCombineable<'tcx> for ty::TraitRef<'tcx> {\n+    fn super_combine<C:Combine<'tcx>>(combiner: &C,\n+                                      a: &ty::TraitRef<'tcx>,\n+                                      b: &ty::TraitRef<'tcx>)\n+                                      -> cres<'tcx, ty::TraitRef<'tcx>>\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n@@ -424,10 +427,11 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<T:HigherRankedFoldable>(tcx: &ty::ctxt,\n-                                           value: &T,\n-                                           fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n-                                           -> T\n+fn fold_regions_in<'tcx, T>(tcx: &ty::ctxt<'tcx>,\n+                            value: &T,\n+                            fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n+                            -> T\n+    where T: HigherRankedFoldable<'tcx>\n {\n     value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "4767aa258ba9c7c8fe21ba8a05cd69a2eeb4c525", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -39,34 +39,34 @@ use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use util::ppaux::Repr;\n \n-pub trait LatticeDir {\n+pub trait LatticeDir<'tcx> {\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()>;\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()>;\n }\n \n-impl<'a, 'tcx> LatticeDir for Lub<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()> {\n+impl<'a, 'tcx> LatticeDir<'tcx> for Lub<'a, 'tcx> {\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n         let sub = self.sub();\n         try!(sub.tys(a, v));\n         try!(sub.tys(b, v));\n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir for Glb<'a, 'tcx> {\n-    fn relate_bound<'a>(&'a self, v: Ty, a: Ty, b: Ty) -> cres<()> {\n+impl<'a, 'tcx> LatticeDir<'tcx> for Glb<'a, 'tcx> {\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n         let sub = self.sub();\n         try!(sub.tys(v, a));\n         try!(sub.tys(v, b));\n         Ok(())\n     }\n }\n \n-pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n-                                                           a: Ty,\n-                                                           b: Ty)\n-                                                           -> cres<Ty>\n+pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n+                                                                 a: Ty<'tcx>,\n+                                                                 b: Ty<'tcx>)\n+                                                                 -> cres<'tcx, Ty<'tcx>>\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),"}, {"sha": "e7bd1f3716c12e3ddef4bef12f63be027fbc8399", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -39,14 +39,14 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"lub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         let tcx = self.tcx();\n \n         debug!(\"{}.mts({}, {})\",\n@@ -72,18 +72,18 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         }\n     }\n \n-    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.glb().tys(a, b)\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         match (a, b) {\n           (UnsafeFn, _) | (_, UnsafeFn) => Ok(UnsafeFn),\n           (NormalFn, NormalFn) => Ok(NormalFn),\n         }\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         match (a, b) {\n             (Once, _) | (_, Once) => Ok(Once),\n             (Many, Many) => Ok(Many)\n@@ -93,18 +93,18 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn builtin_bounds(&self,\n                       a: ty::BuiltinBounds,\n                       b: ty::BuiltinBounds)\n-                      -> cres<ty::BuiltinBounds> {\n+                      -> cres<'tcx, ty::BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds, so\n         // the LUB (mutual supertype) is the intersection.\n         Ok(a.intersection(b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                    -> cres<ty::Region> {\n+                    -> cres<'tcx, ty::Region> {\n         self.glb().regions(a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n@@ -113,15 +113,17 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_lub(a, b)\n     }\n \n-    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_lub(a, b)\n     }\n }"}, {"sha": "729fbd6b337b5e5e23bda561c052b80f2a9f42a3", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 137, "deletions": 129, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -72,18 +72,18 @@ pub mod unify;\n \n pub type Bound<T> = Option<T>;\n \n-pub type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n-pub type ures = cres<()>; // \"unify result\"\n+pub type cres<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n+pub type ures<'tcx> = cres<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-pub type CoerceResult = cres<Option<ty::AutoAdjustment>>;\n+pub type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n \n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable>,\n+    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table:\n@@ -134,28 +134,28 @@ pub enum TypeOrigin {\n \n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum ValuePairs {\n-    Types(ty::expected_found<Ty>),\n-    TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n+pub enum ValuePairs<'tcx> {\n+    Types(ty::expected_found<Ty<'tcx>>),\n+    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n }\n \n /// The trace designates the path through inference that we took to\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n #[deriving(Clone, Show)]\n-pub struct TypeTrace {\n+pub struct TypeTrace<'tcx> {\n     origin: TypeOrigin,\n-    values: ValuePairs,\n+    values: ValuePairs<'tcx>,\n }\n \n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum SubregionOrigin {\n+pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n-    Subtype(TypeTrace),\n+    Subtype(TypeTrace<'tcx>),\n \n     // Stack-allocated closures cannot outlive innermost loop\n     // or function so as to ensure we only require finite stack\n@@ -182,19 +182,19 @@ pub enum SubregionOrigin {\n \n     // When closing over a variable in a closure/proc, ensure that the\n     // type of the variable outlives the lifetime bound.\n-    RelateProcBound(Span, ast::NodeId, Ty),\n+    RelateProcBound(Span, ast::NodeId, Ty<'tcx>),\n \n     // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n-    RelateParamBound(Span, Ty),\n+    RelateParamBound(Span, Ty<'tcx>),\n \n     // The given region parameter was instantiated with a region\n     // that must outlive some other region.\n     RelateRegionParamBound(Span),\n \n     // A bound placed on type parameters that states that must outlive\n     // the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty),\n+    RelateDefaultParamBound(Span, Ty<'tcx>),\n \n     // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n@@ -203,10 +203,10 @@ pub enum SubregionOrigin {\n     ReborrowUpvar(Span, ty::UpvarId),\n \n     // (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(Ty, Span),\n+    ReferenceOutlivesReferent(Ty<'tcx>, Span),\n \n     // The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty, Span),\n+    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n \n     // A `ref b` whose region does not enclose the decl site\n     BindingTypeIsNotValidAtDecl(Span),\n@@ -241,7 +241,7 @@ pub enum LateBoundRegionConversionTime {\n ///\n /// See `error_reporting.rs` for more details\n #[deriving(Clone, Show)]\n-pub enum RegionVariableOrigin {\n+pub enum RegionVariableOrigin<'tcx> {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n     MiscVariable(Span),\n@@ -259,7 +259,7 @@ pub enum RegionVariableOrigin {\n     Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(TypeTrace),\n+    Coercion(TypeTrace<'tcx>),\n \n     // Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, ast::Name),\n@@ -305,12 +305,12 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>)\n     }\n }\n \n-pub fn common_supertype(cx: &InferCtxt,\n-                        origin: TypeOrigin,\n-                        a_is_expected: bool,\n-                        a: Ty,\n-                        b: Ty)\n-                        -> Ty\n+pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                  origin: TypeOrigin,\n+                                  a_is_expected: bool,\n+                                  a: Ty<'tcx>,\n+                                  b: Ty<'tcx>)\n+                                  -> Ty<'tcx>\n {\n     /*!\n      * Computes the least upper-bound of `a` and `b`. If this is\n@@ -336,20 +336,23 @@ pub fn common_supertype(cx: &InferCtxt,\n     }\n }\n \n-pub fn mk_subty(cx: &InferCtxt,\n-                a_is_expected: bool,\n-                origin: TypeOrigin,\n-                a: Ty,\n-                b: Ty)\n-                -> ures\n+pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                          a_is_expected: bool,\n+                          origin: TypeOrigin,\n+                          a: Ty<'tcx>,\n+                          b: Ty<'tcx>)\n+                          -> ures<'tcx>\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(|| {\n         cx.sub_types(a_is_expected, origin, a, b)\n     })\n }\n \n-pub fn can_mk_subty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n+pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                              a: Ty<'tcx>,\n+                              b: Ty<'tcx>)\n+                              -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -360,7 +363,9 @@ pub fn can_mk_subty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n     })\n }\n \n-pub fn can_mk_eqty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                             a: Ty<'tcx>, b: Ty<'tcx>)\n+                             -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|| {\n         let trace = TypeTrace {\n@@ -371,21 +376,21 @@ pub fn can_mk_eqty(cx: &InferCtxt, a: Ty, b: Ty) -> ures {\n     }).to_ures()\n }\n \n-pub fn mk_subr(cx: &InferCtxt,\n-               origin: SubregionOrigin,\n-               a: ty::Region,\n-               b: ty::Region) {\n+pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                         origin: SubregionOrigin<'tcx>,\n+                         a: ty::Region,\n+                         b: ty::Region) {\n     debug!(\"mk_subr({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     let snapshot = cx.region_vars.start_snapshot();\n     cx.region_vars.make_subregion(origin, a, b);\n     cx.region_vars.commit(snapshot);\n }\n \n-pub fn verify_param_bound(cx: &InferCtxt,\n-                          origin: SubregionOrigin,\n-                          param_ty: ty::ParamTy,\n-                          a: ty::Region,\n-                          bs: Vec<ty::Region>) {\n+pub fn verify_param_bound<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                    origin: SubregionOrigin<'tcx>,\n+                                    param_ty: ty::ParamTy,\n+                                    a: ty::Region,\n+                                    bs: Vec<ty::Region>) {\n     debug!(\"verify_param_bound({}, {} <: {})\",\n            param_ty.repr(cx.tcx),\n            a.repr(cx.tcx),\n@@ -394,24 +399,24 @@ pub fn verify_param_bound(cx: &InferCtxt,\n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n \n-pub fn mk_eqty(cx: &InferCtxt,\n-               a_is_expected: bool,\n-               origin: TypeOrigin,\n-               a: Ty,\n-               b: Ty)\n-            -> ures\n+pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                         a_is_expected: bool,\n+                         origin: TypeOrigin,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>)\n+                         -> ures<'tcx>\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(\n         || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n-pub fn mk_sub_trait_refs(cx: &InferCtxt,\n-                         a_is_expected: bool,\n-                         origin: TypeOrigin,\n-                         a: Rc<ty::TraitRef>,\n-                         b: Rc<ty::TraitRef>)\n-                         -> ures\n+pub fn mk_sub_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                                   a_is_expected: bool,\n+                                   origin: TypeOrigin,\n+                                   a: Rc<ty::TraitRef<'tcx>>,\n+                                   b: Rc<ty::TraitRef<'tcx>>)\n+                                   -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n@@ -431,12 +436,12 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety(cx: &InferCtxt,\n-                   a_is_expected: bool,\n-                   origin: TypeOrigin,\n-                   a: Ty,\n-                   b: Ty)\n-                -> CoerceResult {\n+pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                             a_is_expected: bool,\n+                             origin: TypeOrigin,\n+                             a: Ty<'tcx>,\n+                             b: Ty<'tcx>)\n+                             -> CoerceResult<'tcx> {\n     debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     indent(|| {\n         cx.commit_if_ok(|| {\n@@ -450,11 +455,11 @@ pub fn mk_coercety(cx: &InferCtxt,\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: &InferCtxt,\n-                    span: Option<Span>,\n-                    a: Ty,\n-                    modes: uint)\n-                    -> fres<Ty> {\n+pub fn resolve_type<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+                              span: Option<Span>,\n+                              a: Ty<'tcx>,\n+                              modes: uint)\n+                              -> fres<Ty<'tcx>> {\n     let mut resolver = resolver(cx, modes, span);\n     cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n }\n@@ -465,37 +470,37 @@ pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n     resolver.resolve_region_chk(r)\n }\n \n-trait then {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err>;\n+trait then<'tcx> {\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n+        -> Result<T,ty::type_err<'tcx>>;\n }\n \n-impl then for ures {\n-    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n-        -> Result<T,ty::type_err> {\n+impl<'tcx> then<'tcx> for ures<'tcx> {\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err<'tcx>>)\n+        -> Result<T,ty::type_err<'tcx>> {\n         self.and_then(|_i| f())\n     }\n }\n \n-trait ToUres {\n-    fn to_ures(&self) -> ures;\n+trait ToUres<'tcx> {\n+    fn to_ures(&self) -> ures<'tcx>;\n }\n \n-impl<T> ToUres for cres<T> {\n-    fn to_ures(&self) -> ures {\n+impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n+    fn to_ures(&self) -> ures<'tcx> {\n         match *self {\n           Ok(ref _v) => Ok(()),\n           Err(ref e) => Err((*e))\n         }\n     }\n }\n \n-trait CresCompare<T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T>;\n+trait CresCompare<'tcx, T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T>;\n }\n \n-impl<T:Clone + PartialEq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n+impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err<'tcx>) -> cres<'tcx, T> {\n         (*self).clone().and_then(|s| {\n             if s == t {\n                 (*self).clone()\n@@ -506,7 +511,7 @@ impl<T:Clone + PartialEq> CresCompare<T> for cres<T> {\n     }\n }\n \n-pub fn uok() -> ures {\n+pub fn uok<'tcx>() -> ures<'tcx> {\n     Ok(())\n }\n \n@@ -518,7 +523,7 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn skolemize<T:TypeFoldable>(&self, t: T) -> T {\n+    pub fn skolemize<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.skolemizer())\n     }\n \n@@ -533,22 +538,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         skolemize::TypeSkolemizer::new(self)\n     }\n \n-    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n+    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n                               -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Equate<'a, 'tcx> {\n+    pub fn equate<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> Equate<'a, 'tcx> {\n         Equate(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a, 'tcx> {\n+    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Sub<'a, 'tcx> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a, 'tcx> {\n+    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                   -> Lub<'a, 'tcx> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -651,9 +659,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_types(&self,\n                      a_is_expected: bool,\n                      origin: TypeOrigin,\n-                     a: Ty,\n-                     b: Ty)\n-                     -> ures\n+                     a: Ty<'tcx>,\n+                     b: Ty<'tcx>)\n+                     -> ures<'tcx>\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.commit_if_ok(|| {\n@@ -668,9 +676,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     origin: TypeOrigin,\n-                    a: Ty,\n-                    b: Ty)\n-                    -> ures\n+                    a: Ty<'tcx>,\n+                    b: Ty<'tcx>)\n+                    -> ures<'tcx>\n     {\n         self.commit_if_ok(|| {\n             let trace = TypeTrace {\n@@ -684,9 +692,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_trait_refs(&self,\n                           a_is_expected: bool,\n                           origin: TypeOrigin,\n-                          a: Rc<ty::TraitRef>,\n-                          b: Rc<ty::TraitRef>)\n-                          -> ures\n+                          a: Rc<ty::TraitRef<'tcx>>,\n+                          b: Rc<ty::TraitRef<'tcx>>)\n+                          -> ures<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n@@ -709,15 +717,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_var(diverging)\n     }\n \n-    pub fn next_ty_var(&self) -> Ty {\n+    pub fn next_ty_var(&self) -> Ty<'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(false))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> Ty {\n+    pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty> {\n+    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n         Vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n@@ -733,7 +741,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -748,8 +756,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n-                                     generics: &ty::Generics)\n-                                     -> subst::Substs\n+                                     generics: &ty::Generics<'tcx>)\n+                                     -> subst::Substs<'tcx>\n     {\n         /*!\n          * Given a set of generics defined on a type or impl, returns\n@@ -768,9 +776,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn fresh_substs_for_trait(&self,\n                                   span: Span,\n-                                  generics: &ty::Generics,\n-                                  self_ty: Ty)\n-                                  -> subst::Substs\n+                                  generics: &ty::Generics<'tcx>,\n+                                  self_ty: Ty<'tcx>)\n+                                  -> subst::Substs<'tcx>\n     {\n         /*!\n          * Given a set of generics defined on a trait, returns a\n@@ -805,22 +813,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_string(&self, t: Ty) -> String {\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         ty_to_string(self.tcx,\n                      self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_string(&self, ts: &[Ty]) -> String {\n+    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n         let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef>) -> String {\n+    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n-    pub fn contains_unbound_type_variables(&self, typ: Ty) -> Ty {\n+    pub fn contains_unbound_type_variables(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -829,7 +837,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn shallow_resolve(&self, typ: Ty) -> Ty {\n+    pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match ty::get(typ).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.type_variables.borrow()\n@@ -853,7 +861,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type_vars_if_possible(&self, typ: Ty) -> Ty {\n+    pub fn resolve_type_vars_if_possible(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match resolve_type(self,\n                            None,\n                            typ, resolve_nested_tvar | resolve_ivar) {\n@@ -863,8 +871,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n-                                                      trait_ref: &ty::TraitRef)\n-                                                      -> ty::TraitRef {\n+                                                      trait_ref: &ty::TraitRef<'tcx>)\n+                                                      -> ty::TraitRef<'tcx> {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n                                   (*trait_ref).clone(),\n@@ -899,7 +907,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                   sp: Span,\n                                   mk_msg: |Option<String>, String| -> String,\n                                   actual_ty: String,\n-                                  err: Option<&ty::type_err>) {\n+                                  err: Option<&ty::type_err<'tcx>>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n@@ -908,9 +916,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                 mk_msg: |Option<String>,\n                                                          String|\n                                                          -> String,\n-                                                expected_ty: Option<Ty>,\n+                                                expected_ty: Option<Ty<'tcx>>,\n                                                 actual_ty: String,\n-                                                err: Option<&ty::type_err>) {\n+                                                err: Option<&ty::type_err<'tcx>>) {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n         let resolved_expected = expected_ty.map(|e_ty| {\n@@ -938,8 +946,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |String| -> String,\n-                              actual_ty: Ty,\n-                              err: Option<&ty::type_err>) {\n+                              actual_ty: Ty<'tcx>,\n+                              err: Option<&ty::type_err<'tcx>>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n@@ -952,9 +960,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_mismatched_types(&self,\n                                    span: Span,\n-                                   expected: Ty,\n-                                   actual: Ty,\n-                                   err: &ty::type_err) {\n+                                   expected: Ty<'tcx>,\n+                                   actual: Ty<'tcx>,\n+                                   err: &ty::type_err<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n             values: Types(ty::expected_found {\n@@ -971,7 +979,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         lbrct: LateBoundRegionConversionTime,\n         value: &T)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : HigherRankedFoldable\n+        where T : HigherRankedFoldable<'tcx>\n     {\n         ty::replace_late_bound_regions(\n             self.tcx,\n@@ -980,12 +988,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-impl TypeTrace {\n+impl<'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n \n-    pub fn dummy() -> TypeTrace {\n+    pub fn dummy() -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(ty::expected_found {\n@@ -996,7 +1004,7 @@ impl TypeTrace {\n     }\n }\n \n-impl Repr for TypeTrace {\n+impl<'tcx> Repr<'tcx> for TypeTrace<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n@@ -1018,7 +1026,7 @@ impl TypeOrigin {\n     }\n }\n \n-impl Repr for TypeOrigin {\n+impl<'tcx> Repr<'tcx> for TypeOrigin {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             MethodCompatCheck(a) => {\n@@ -1050,7 +1058,7 @@ impl Repr for TypeOrigin {\n     }\n }\n \n-impl SubregionOrigin {\n+impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             Subtype(ref a) => a.span(),\n@@ -1079,8 +1087,8 @@ impl SubregionOrigin {\n     }\n }\n \n-impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             Subtype(ref a) => {\n                 format!(\"Subtype({})\", a.repr(tcx))\n@@ -1150,7 +1158,7 @@ impl Repr for SubregionOrigin {\n     }\n }\n \n-impl RegionVariableOrigin {\n+impl<'tcx> RegionVariableOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n@@ -1167,8 +1175,8 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             MiscVariable(a) => {\n                 format!(\"MiscVariable({})\", a.repr(tcx))"}, {"sha": "5452a99127fc47f643af5fca363e28d3daf00a14", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -52,17 +52,17 @@ pub enum Constraint {\n \n // Something we have to verify after region inference is done, but\n // which does not directly influence the inference process\n-pub enum Verify {\n+pub enum Verify<'tcx> {\n     // VerifyRegSubReg(a, b): Verify that `a <= b`. Neither `a` nor\n     // `b` are inference variables.\n-    VerifyRegSubReg(SubregionOrigin, Region, Region),\n+    VerifyRegSubReg(SubregionOrigin<'tcx>, Region, Region),\n \n     // VerifyParamBound(T, _, R, RS): The parameter type `T` must\n     // outlive the region `R`. `T` is known to outlive `RS`. Therefore\n     // verify that `R <= RS[i]` for some `i`. Inference variables may\n     // be involved (but this verification step doesn't influence\n     // inference).\n-    VerifyParamBound(ty::ParamTy, SubregionOrigin, Region, Vec<Region>),\n+    VerifyParamBound(ty::ParamTy, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n #[deriving(PartialEq, Eq, Hash)]\n@@ -89,43 +89,43 @@ pub enum CombineMapType {\n }\n \n #[deriving(Clone, Show)]\n-pub enum RegionResolutionError {\n+pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n \n     /// `ParamBoundFailure(p, s, a, bs)\n     ///\n     /// The parameter type `p` must be known to outlive the lifetime\n     /// `a`, but it is only known to outlive `bs` (and none of the\n     /// regions in `bs` outlive `a`).\n-    ParamBoundFailure(SubregionOrigin, ty::ParamTy, Region, Vec<Region>),\n+    ParamBoundFailure(SubregionOrigin<'tcx>, ty::ParamTy, Region, Vec<Region>),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin, Region,\n-                   SubregionOrigin, Region),\n+    SubSupConflict(RegionVariableOrigin<'tcx>,\n+                   SubregionOrigin<'tcx>, Region,\n+                   SubregionOrigin<'tcx>, Region),\n \n     /// `SupSupConflict(v, origin1, r1, origin2, r2)`:\n     ///\n     /// Could not infer a value for `v` because `v <= r1` (due to\n     /// `origin1`) and `v <= r2` (due to `origin2`) and\n     /// `r1` and `r2` have no intersection.\n-    SupSupConflict(RegionVariableOrigin,\n-                   SubregionOrigin, Region,\n-                   SubregionOrigin, Region),\n+    SupSupConflict(RegionVariableOrigin<'tcx>,\n+                   SubregionOrigin<'tcx>, Region,\n+                   SubregionOrigin<'tcx>, Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace, ty::type_err)>,\n+    ProcessedErrors(Vec<RegionVariableOrigin<'tcx>>,\n+                    Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n                     Vec<SameRegions>),\n }\n \n@@ -160,19 +160,19 @@ pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin<'tcx>>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin>>,\n+    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n     //\n     // An example is a `A <= B` where neither `A` nor `B` are\n     // inference variables.\n-    verifys: RefCell<Vec<Verify>>,\n+    verifys: RefCell<Vec<Verify<'tcx>>>,\n \n     // A \"given\" is a relationship that is known to hold. In particular,\n     // we often know from closure fn signatures that a particular free\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.var_origins.borrow().len()\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { index: id };\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn add_constraint(&self,\n                       constraint: Constraint,\n-                      origin: SubregionOrigin) {\n+                      origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -382,7 +382,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn add_verify(&self,\n-                  verify: Verify) {\n+                  verify: Verify<'tcx>) {\n         // cannot add verifys once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -414,7 +414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn make_eqregion(&self,\n-                         origin: SubregionOrigin,\n+                         origin: SubregionOrigin<'tcx>,\n                          sub: Region,\n                          sup: Region) {\n         if sub != sup {\n@@ -426,7 +426,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn make_subregion(&self,\n-                          origin: SubregionOrigin,\n+                          origin: SubregionOrigin<'tcx>,\n                           sub: Region,\n                           sup: Region) {\n         // cannot add constraints once regions are resolved\n@@ -474,15 +474,15 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn verify_param_bound(&self,\n-                              origin: SubregionOrigin,\n+                              origin: SubregionOrigin<'tcx>,\n                               param_ty: ty::ParamTy,\n                               sub: Region,\n                               sups: Vec<Region>) {\n         self.add_verify(VerifyParamBound(param_ty, origin, sub, sups));\n     }\n \n     pub fn lub_regions(&self,\n-                       origin: SubregionOrigin,\n+                       origin: SubregionOrigin<'tcx>,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     pub fn glb_regions(&self,\n-                       origin: SubregionOrigin,\n+                       origin: SubregionOrigin<'tcx>,\n                        a: Region,\n                        b: Region)\n                        -> Region {\n@@ -560,8 +560,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         t: CombineMapType,\n                         a: Region,\n                         b: Region,\n-                        origin: SubregionOrigin,\n-                        relate: |this: &RegionVarBindings,\n+                        origin: SubregionOrigin<'tcx>,\n+                        relate: |this: &RegionVarBindings<'a, 'tcx>,\n                                  old_r: Region,\n                                  new_r: Region|)\n                         -> Region {\n@@ -700,7 +700,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    pub fn resolve_regions(&self) -> Vec<RegionResolutionError> {\n+    pub fn resolve_regions(&self) -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n         let v = self.infer_variable_values(&mut errors);\n@@ -815,7 +815,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_concrete_regions(&self,\n                             a: Region,\n                             b: Region)\n-                         -> cres<Region> {\n+                         -> cres<'tcx, Region> {\n         debug!(\"glb_concrete_regions({}, {})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n@@ -885,7 +885,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn glb_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> cres<ty::Region>\n+                        b: &FreeRegion) -> cres<'tcx, ty::Region>\n     {\n         /*!\n          * Computes a region that is enclosed by both free region arguments,\n@@ -899,9 +899,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             Equal => Ok(ty::ReFree(*a))\n         };\n \n-        fn helper(this: &RegionVarBindings,\n-                  a: &FreeRegion,\n-                  b: &FreeRegion) -> cres<ty::Region>\n+        fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n+                            a: &FreeRegion,\n+                            b: &FreeRegion) -> cres<'tcx, ty::Region>\n         {\n             if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n                         scope_a: ast::NodeId,\n-                        scope_b: ast::NodeId) -> cres<Region>\n+                        scope_b: ast::NodeId) -> cres<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of\n@@ -946,16 +946,16 @@ struct VarData {\n     value: VarValue,\n }\n \n-struct RegionAndOrigin {\n+struct RegionAndOrigin<'tcx> {\n     region: Region,\n-    origin: SubregionOrigin,\n+    origin: SubregionOrigin<'tcx>,\n }\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n-                             errors: &mut Vec<RegionResolutionError>)\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n                              -> Vec<VarValue>\n     {\n         let mut var_data = self.construct_var_data();\n@@ -1188,7 +1188,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn collect_concrete_region_errors(&self,\n                                       values: &Vec<VarValue>,\n-                                      errors: &mut Vec<RegionResolutionError>)\n+                                      errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         let mut reg_reg_dups = FnvHashSet::new();\n         for verify in self.verifys.borrow().iter() {\n@@ -1230,7 +1230,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn extract_values_and_collect_conflicts(\n         &self,\n         var_data: &[VarData],\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n         -> Vec<VarValue>\n     {\n         debug!(\"extract_values_and_collect_conflicts()\");\n@@ -1353,7 +1353,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError>)\n+        errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in contracting nodes result from two upper-bounds\n         // that have no intersection.\n@@ -1458,11 +1458,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [uint])\n-                                -> (Vec<RegionAndOrigin> , bool) {\n-        struct WalkState {\n+                                -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+        struct WalkState<'tcx> {\n             set: FnvHashSet<RegionVid>,\n-            stack: Vec<RegionVid> ,\n-            result: Vec<RegionAndOrigin> ,\n+            stack: Vec<RegionVid>,\n+            result: Vec<RegionAndOrigin<'tcx>>,\n             dup_found: bool\n         }\n         let mut state = WalkState {\n@@ -1505,8 +1505,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let WalkState {result, dup_found, ..} = state;\n         return (result, dup_found);\n \n-        fn process_edges(this: &RegionVarBindings,\n-                         state: &mut WalkState,\n+        fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n+                         state: &mut WalkState<'tcx>,\n                          graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n@@ -1559,7 +1559,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n }\n \n-impl Repr for Constraint {\n+impl<'tcx> Repr<'tcx> for Constraint {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             ConstrainVarSubVar(a, b) => {\n@@ -1575,8 +1575,8 @@ impl Repr for Constraint {\n     }\n }\n \n-impl Repr for Verify {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for Verify<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             VerifyRegSubReg(_, ref a, ref b) => {\n                 format!(\"VerifyRegSubReg({}, {})\", a.repr(tcx), b.repr(tcx))\n@@ -1604,7 +1604,7 @@ fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n     }\n }\n \n-impl Repr for VarValue {\n+impl<'tcx> Repr<'tcx> for VarValue {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n             NoValue => format!(\"NoValue\"),\n@@ -1614,8 +1614,8 @@ impl Repr for VarValue {\n     }\n }\n \n-impl Repr for RegionAndOrigin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for RegionAndOrigin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"RegionAndOrigin({},{})\",\n                 self.region.repr(tcx),\n                 self.origin.repr(tcx))"}, {"sha": "f4bff7eeb7bdb0f32e0c8039ec5f4d702ad29ae1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         self.resolve_type(t)\n     }\n \n@@ -112,7 +112,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         (self.modes & mode) == mode\n     }\n \n-    pub fn resolve_type_chk(&mut self, typ: Ty) -> fres<Ty> {\n+    pub fn resolve_type_chk(&mut self, typ: Ty<'tcx>) -> fres<Ty<'tcx>> {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type(&mut self, typ: Ty) -> Ty {\n+    pub fn resolve_type(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n \n         if !ty::type_needs_infer(typ) {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty {\n+    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty<'tcx> {\n         let tcx = self.infcx.tcx;\n         let tv = self.infcx.type_variables.borrow();\n         match tv.probe(vid) {\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty {\n+    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty<'tcx> {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n@@ -237,7 +237,7 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty {\n+    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty<'tcx> {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }"}, {"sha": "3c9a1345c47bf17e9c93ef4e7a514830a9cc5752", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -52,7 +52,7 @@ use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n pub struct TypeSkolemizer<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     skolemization_count: uint,\n-    skolemization_map: hash_map::HashMap<ty::InferTy, Ty>,\n+    skolemization_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n@@ -65,10 +65,10 @@ impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n     }\n \n     fn skolemize(&mut self,\n-                 opt_ty: Option<Ty>,\n+                 opt_ty: Option<Ty<'tcx>>,\n                  key: ty::InferTy,\n                  skolemizer: |uint| -> ty::InferTy)\n-                 -> Ty\n+                 -> Ty<'tcx>\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n         }\n     }\n \n-    fn fold_ty(&mut self, t: Ty) -> Ty {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match ty::get(t).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 self.skolemize(self.infcx.type_variables.borrow().probe(v),"}, {"sha": "ec260c6c363040e82ccd0169b2d09dc7975111c1", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -40,27 +40,27 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields.infcx }\n     fn tag(&self) -> String { \"sub\".to_string() }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.fields.trace.clone() }\n+    fn trace(&self) -> TypeTrace<'tcx> { self.fields.trace.clone() }\n \n     fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { Equate(self.fields.clone()) }\n     fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { Sub(self.fields.clone()) }\n     fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields.clone()) }\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n-    fn contratys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn contratys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         Sub(self.fields.switch_expected()).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n-                     -> cres<ty::Region> {\n+                     -> cres<'tcx, ty::Region> {\n                          let opp = CombineFields {\n                              a_is_expected: !self.fields.a_is_expected,\n                              ..self.fields.clone()\n                          };\n                          Sub(opp).regions(b, a)\n                      }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n@@ -69,7 +69,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         Ok(a)\n     }\n \n-    fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n         debug!(\"mts({} <: {})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -93,20 +93,20 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         Ok(*a) // return is meaningless in sub, just return *a\n     }\n \n-    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n+    fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<'tcx, FnStyle> {\n         self.lub().fn_styles(a, b).compare(b, || {\n             ty::terr_fn_style_mismatch(expected_found(self, a, b))\n         })\n     }\n \n-    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<'tcx, Onceness> {\n         self.lub().oncenesses(a, b).compare(b, || {\n             ty::terr_onceness_mismatch(expected_found(self, a, b))\n         })\n     }\n \n     fn builtin_bounds(&self, a: BuiltinBounds, b: BuiltinBounds)\n-                      -> cres<BuiltinBounds> {\n+                      -> cres<'tcx, BuiltinBounds> {\n         // More bounds is a subtype of fewer bounds.\n         //\n         // e.g., fn:Copy() <: fn(), because the former is a function\n@@ -119,7 +119,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn tys(&self, a: Ty, b: Ty) -> cres<Ty> {\n+    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n@@ -155,11 +155,13 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n+               -> cres<'tcx, ty::FnSig<'tcx>> {\n         self.higher_ranked_sub(a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n         self.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "aaa77d251933ffa72d23755510adbc1fe71fce9e", "filename": "src/librustc/middle/typeck/infer/type_variable.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftype_variable.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -16,17 +16,17 @@ use middle::ty::{mod, Ty};\n use std::mem;\n use util::snapshot_vec as sv;\n \n-pub struct TypeVariableTable {\n-    values: sv::SnapshotVec<TypeVariableData,UndoEntry,Delegate>,\n+pub struct TypeVariableTable<'tcx> {\n+    values: sv::SnapshotVec<TypeVariableData<'tcx>,UndoEntry,Delegate>,\n }\n \n-struct TypeVariableData {\n-    value: TypeVariableValue,\n+struct TypeVariableData<'tcx> {\n+    value: TypeVariableValue<'tcx>,\n     diverging: bool\n }\n \n-enum TypeVariableValue {\n-    Known(Ty),\n+enum TypeVariableValue<'tcx> {\n+    Known(Ty<'tcx>),\n     Bounded(Vec<Relation>),\n }\n \n@@ -59,8 +59,8 @@ impl RelationDir {\n     }\n }\n \n-impl TypeVariableTable {\n-    pub fn new() -> TypeVariableTable {\n+impl<'tcx> TypeVariableTable<'tcx> {\n+    pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable { values: sv::SnapshotVec::new(Delegate) }\n     }\n \n@@ -89,8 +89,8 @@ impl TypeVariableTable {\n     pub fn instantiate_and_push(\n         &mut self,\n         vid: ty::TyVid,\n-        ty: Ty,\n-        stack: &mut Vec<(Ty, RelationDir, ty::TyVid)>)\n+        ty: Ty<'tcx>,\n+        stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         /*!\n          * Instantiates `vid` with the type `ty` and then pushes an\n@@ -125,14 +125,14 @@ impl TypeVariableTable {\n         ty::TyVid { index: index }\n     }\n \n-    pub fn probe(&self, vid: ty::TyVid) -> Option<Ty> {\n+    pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n         match self.values.get(vid.index).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n     }\n \n-    pub fn replace_if_possible(&self, t: Ty) -> Ty {\n+    pub fn replace_if_possible(&self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match ty::get(t).sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n                 match self.probe(v) {\n@@ -157,7 +157,7 @@ impl TypeVariableTable {\n     }\n }\n \n-impl sv::SnapshotVecDelegate<TypeVariableData,UndoEntry> for Delegate {\n+impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {\n     fn reverse(&mut self,\n                values: &mut Vec<TypeVariableData>,\n                action: UndoEntry) {"}, {"sha": "fcf042b3f8b80e4cb56f1e565c809bbd7304b5a8", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -34,7 +34,7 @@ use util::snapshot_vec as sv;\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n-pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n+pub trait UnifyKey<'tcx, V> : Clone + Show + PartialEq + Repr<'tcx> {\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n@@ -57,7 +57,7 @@ pub trait UnifyKey<V> : Clone + Show + PartialEq + Repr {\n  *\n  * Implementations of this trait are at the end of this file.\n  */\n-pub trait UnifyValue : Clone + Repr + PartialEq {\n+pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n }\n \n /**\n@@ -114,7 +114,7 @@ pub struct Delegate;\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n+impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K,V> {\n     pub fn new() -> UnificationTable<K,V> {\n         UnificationTable {\n             values: sv::SnapshotVec::new(Delegate),\n@@ -189,7 +189,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n \n     pub fn set(&mut self,\n-               tcx: &ty::ctxt,\n+               tcx: &ty::ctxt<'tcx>,\n                key: K,\n                new_value: VarValue<K,V>)\n     {\n@@ -208,7 +208,7 @@ impl<V:PartialEq+Clone+Repr,K:UnifyKey<V>> UnificationTable<K,V> {\n     }\n \n     pub fn unify(&mut self,\n-                 tcx: &ty::ctxt,\n+                 tcx: &ty::ctxt<'tcx>,\n                  node_a: &Node<K,V>,\n                  node_b: &Node<K,V>)\n                  -> (K, uint)\n@@ -259,15 +259,15 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n  * Indicates a type that does not have any kind of subtyping\n  * relationship.\n  */\n-pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n-    fn to_type(&self) -> Ty;\n-    fn to_type_err(expected_found<Self>) -> ty::type_err;\n+pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n+    fn to_type(&self) -> Ty<'tcx>;\n+    fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n \n-pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n-                              a_t: V,\n-                              b_t: V)\n-                              -> ures {\n+pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n+                                          a_t: V,\n+                                          b_t: V)\n+                                          -> ures<'tcx> {\n     if a_is_expected {\n         Err(SimplyUnifiable::to_type_err(\n             ty::expected_found {expected: a_t, found: b_t}))\n@@ -277,29 +277,29 @@ pub fn err<V:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n-                                                  K:UnifyKey<Option<V>>> {\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n+                                                  K:UnifyKey<'tcx, Option<V>>> {\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n                    b_id: K)\n-                   -> ures;\n+                   -> ures<'tcx>;\n     fn simple_var_t(&self,\n                     a_is_expected: bool,\n                     a_id: K,\n                     b: V)\n-                    -> ures;\n-    fn probe_var(&self, a_id: K) -> Option<Ty>;\n+                    -> ures<'tcx>;\n+    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n }\n \n-impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<V,K> for InferCtxt<'a, 'tcx>\n+impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n+    InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V, K> for InferCtxt<'a, 'tcx>\n {\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n                    b_id: K)\n-                   -> ures\n+                   -> ures<'tcx>\n     {\n         /*!\n          * Unifies two simple keys.  Because simple keys do\n@@ -345,7 +345,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n                     a_is_expected: bool,\n                     a_id: K,\n                     b: V)\n-                    -> ures\n+                    -> ures<'tcx>\n     {\n         /*!\n          * Sets the value of the key `a_id` to `b`.  Because\n@@ -375,7 +375,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<Ty> {\n+    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n         let node_a = table.borrow_mut().get(tcx, a_id);\n@@ -390,7 +390,7 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n \n // Integral type keys\n \n-impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n+impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n     fn index(&self) -> uint { self.index }\n \n     fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i } }\n@@ -406,24 +406,24 @@ impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n     }\n }\n \n-impl SimplyUnifiable for IntVarValue {\n-    fn to_type(&self) -> Ty {\n+impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n+    fn to_type(&self) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(i),\n             ty::UintType(i) => ty::mk_mach_uint(i),\n         }\n     }\n \n-    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err {\n+    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err<'tcx> {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n-impl UnifyValue for Option<IntVarValue> { }\n+impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n \n // Floating point type keys\n \n-impl UnifyKey<Option<ast::FloatTy>> for ty::FloatVid {\n+impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n     fn index(&self) -> uint { self.index }\n \n     fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i } }\n@@ -439,21 +439,21 @@ impl UnifyKey<Option<ast::FloatTy>> for ty::FloatVid {\n     }\n }\n \n-impl UnifyValue for Option<ast::FloatTy> {\n+impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n }\n \n-impl SimplyUnifiable for ast::FloatTy {\n-    fn to_type(&self) -> Ty {\n+impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n+    fn to_type(&self) -> Ty<'tcx> {\n         ty::mk_mach_float(*self)\n     }\n \n-    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n-        return ty::terr_float_mismatch(err);\n+    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {\n+        ty::terr_float_mismatch(err)\n     }\n }\n \n-impl<K:Repr,V:Repr> Repr for VarValue<K,V> {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx, K:Repr<'tcx>, V:Repr<'tcx>> Repr<'tcx> for VarValue<K,V> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n             Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)"}, {"sha": "b322dacfb1a846ce78554180bd9f55c5e5d694ef", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -97,38 +97,38 @@ pub struct param_index {\n }\n \n #[deriving(Clone, Show)]\n-pub enum MethodOrigin {\n+pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n \n     // fully statically resolved unboxed closure invocation\n     MethodStaticUnboxedClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n-    MethodTypeParam(MethodParam),\n+    MethodTypeParam(MethodParam<'tcx>),\n \n     // method invoked on a trait instance\n-    MethodTraitObject(MethodObject),\n+    MethodTraitObject(MethodObject<'tcx>),\n \n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n #[deriving(Clone, Show)]\n-pub struct MethodParam {\n+pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed.\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // index of uint in the list of methods for the trait\n     pub method_num: uint,\n }\n \n // details for a method invoked with a receiver whose type is an object\n #[deriving(Clone, Show)]\n-pub struct MethodObject {\n+pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::TraitRef>,\n+    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -144,10 +144,10 @@ pub struct MethodObject {\n }\n \n #[deriving(Clone)]\n-pub struct MethodCallee {\n-    pub origin: MethodOrigin,\n-    pub ty: Ty,\n-    pub substs: subst::Substs\n+pub struct MethodCallee<'tcx> {\n+    pub origin: MethodOrigin<'tcx>,\n+    pub ty: Ty<'tcx>,\n+    pub substs: subst::Substs<'tcx>\n }\n \n /**\n@@ -177,9 +177,9 @@ pub enum ExprAdjustment {\n     AutoObject\n }\n \n-pub struct TypeAndSubsts {\n-    pub substs: subst::Substs,\n-    pub ty: Ty,\n+pub struct TypeAndSubsts<'tcx> {\n+    pub substs: subst::Substs<'tcx>,\n+    pub ty: Ty<'tcx>,\n }\n \n impl MethodCall {\n@@ -207,21 +207,21 @@ impl MethodCall {\n \n // maps from an expression id that corresponds to a method call to the details\n // of the method to be invoked\n-pub type MethodMap = RefCell<FnvHashMap<MethodCall, MethodCallee>>;\n+pub type MethodMap<'tcx> = RefCell<FnvHashMap<MethodCall, MethodCallee<'tcx>>>;\n \n-pub type vtable_param_res = Vec<vtable_origin>;\n+pub type vtable_param_res<'tcx> = Vec<vtable_origin<'tcx>>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res = VecPerParamSpace<vtable_param_res>;\n+pub type vtable_res<'tcx> = VecPerParamSpace<vtable_param_res<'tcx>>;\n \n #[deriving(Clone)]\n-pub enum vtable_origin {\n+pub enum vtable_origin<'tcx> {\n     /*\n       Statically known vtable. def_id gives the impl item\n       from whence comes the vtable, and tys are the type substs.\n       vtable_res is the vtable itself.\n      */\n-    vtable_static(ast::DefId, subst::Substs, vtable_res),\n+    vtable_static(ast::DefId, subst::Substs<'tcx>, vtable_res<'tcx>),\n \n     /*\n       Dynamic vtable, comes from a parameter that has a bound on it:\n@@ -248,8 +248,8 @@ pub enum vtable_origin {\n     vtable_error,\n }\n \n-impl Repr for vtable_origin {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 format!(\"vtable_static({}:{}, {}, {})\",\n@@ -276,7 +276,7 @@ impl Repr for vtable_origin {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap = RefCell<NodeMap<Rc<ty::TraitRef>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::TraitRef<'tcx>>>>;\n \n pub struct CrateCtxt<'a, 'tcx: 'a> {\n     // A mapping from method call sites to traits that have that method.\n@@ -285,15 +285,15 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: Ty) {\n+pub fn write_ty_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>, node_id: ast::NodeId, ty: Ty<'tcx>) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_string(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     tcx.node_types.borrow_mut().insert(node_id, ty);\n }\n \n-pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n-                           node_id: ast::NodeId,\n-                           item_substs: ty::ItemSubsts) {\n+pub fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 node_id: ast::NodeId,\n+                                 item_substs: ty::ItemSubsts<'tcx>) {\n     if !item_substs.is_noop() {\n         debug!(\"write_substs_to_tcx({}, {})\",\n                node_id,\n@@ -318,22 +318,22 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-pub fn no_params(t: Ty) -> ty::Polytype {\n+pub fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n     ty::Polytype {\n         generics: ty::Generics {types: VecPerParamSpace::empty(),\n                                 regions: VecPerParamSpace::empty()},\n         ty: t\n     }\n }\n \n-pub fn require_same_types(tcx: &ty::ctxt,\n-                          maybe_infcx: Option<&infer::InferCtxt>,\n-                          t1_is_expected: bool,\n-                          span: Span,\n-                          t1: Ty,\n-                          t2: Ty,\n-                          msg: || -> String)\n-                          -> bool {\n+pub fn require_same_types<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                    t1_is_expected: bool,\n+                                    span: Span,\n+                                    t1: Ty<'tcx>,\n+                                    t2: Ty<'tcx>,\n+                                    msg: || -> String)\n+                                    -> bool {\n     let result = match maybe_infcx {\n         None => {\n             let infcx = infer::new_infer_ctxt(tcx);"}, {"sha": "27b9d9d19da3cc74aa4af1b3e653b3971c4dbaf7", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -725,7 +725,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for an instance of `ty` appearing\n     /// in a context with ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n-                               ty: Ty,\n+                               ty: Ty<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n@@ -854,9 +854,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// object, etc) appearing in a context with ambient variance `variance`\n     fn add_constraints_from_substs(&mut self,\n                                    def_id: ast::DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef],\n+                                   type_param_defs: &[ty::TypeParameterDef<'tcx>],\n                                    region_param_defs: &[ty::RegionParameterDef],\n-                                   substs: &subst::Substs,\n+                                   substs: &subst::Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={})\", def_id);\n \n@@ -882,7 +882,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                sig: &ty::FnSig,\n+                                sig: &ty::FnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.inputs.iter() {\n@@ -929,7 +929,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a mutability-type pair\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n-                               mt: &ty::mt,\n+                               mt: &ty::mt<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             ast::MutMutable => {"}, {"sha": "76055372a61491ca7dbe612008bbabaf24fe5f1e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 155, "deletions": 154, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -37,13 +37,13 @@ use syntax::{ast, ast_util};\n use syntax::owned_slice::OwnedSlice;\n \n /// Produces a string suitable for debugging output.\n-pub trait Repr for Sized? {\n-    fn repr(&self, tcx: &ctxt) -> String;\n+pub trait Repr<'tcx> for Sized? {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n /// Produces a string suitable for showing to the user.\n-pub trait UserString {\n-    fn user_string(&self, tcx: &ctxt) -> String;\n+pub trait UserString<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -231,7 +231,7 @@ pub fn mutability_to_string(m: ast::Mutability) -> String {\n     }\n }\n \n-pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n+pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n     format!(\"{}{}\",\n         mutability_to_string(m.mutbl),\n         ty_to_string(cx, m.ty))\n@@ -251,21 +251,22 @@ pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_string(cx: &ctxt, typ: &ty::FnSig) -> String {\n+pub fn fn_sig_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::FnSig<'tcx>) -> String {\n     format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n+pub fn trait_ref_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                 trait_ref: &ty::TraitRef<'tcx>) -> String {\n     trait_ref.user_string(cx).to_string()\n }\n \n-pub fn ty_to_string(cx: &ctxt, typ: Ty) -> String {\n-    fn bare_fn_to_string(cx: &ctxt,\n-                         fn_style: ast::FnStyle,\n-                         abi: abi::Abi,\n-                         ident: Option<ast::Ident>,\n-                         sig: &ty::FnSig)\n-                         -> String {\n+pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n+    fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                               fn_style: ast::FnStyle,\n+                               abi: abi::Abi,\n+                               ident: Option<ast::Ident>,\n+                               sig: &ty::FnSig<'tcx>)\n+                               -> String {\n         let mut s = String::new();\n         match fn_style {\n             ast::NormalFn => {}\n@@ -294,7 +295,7 @@ pub fn ty_to_string(cx: &ctxt, typ: Ty) -> String {\n         s\n     }\n \n-    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n+    fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n \n         match cty.store {\n@@ -334,12 +335,12 @@ pub fn ty_to_string(cx: &ctxt, typ: Ty) -> String {\n         s\n     }\n \n-    fn push_sig_to_string(cx: &ctxt,\n-                       s: &mut String,\n-                       bra: char,\n-                       ket: char,\n-                       sig: &ty::FnSig,\n-                       bounds: &str) {\n+    fn push_sig_to_string<'tcx>(cx: &ctxt<'tcx>,\n+                                s: &mut String,\n+                                bra: char,\n+                                ket: char,\n+                                sig: &ty::FnSig<'tcx>,\n+                                bounds: &str) {\n         s.push(bra);\n         let strs = sig.inputs\n             .iter()\n@@ -382,7 +383,7 @@ pub fn ty_to_string(cx: &ctxt, typ: Ty) -> String {\n     }\n \n     // pretty print the structural type representation:\n-    match ty::get(typ).sty {\n+    match typ.sty {\n         ty_bool => \"bool\".to_string(),\n         ty_char => \"char\".to_string(),\n         ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n@@ -476,11 +477,11 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n     }\n }\n \n-pub fn parameterized(cx: &ctxt,\n-                     base: &str,\n-                     substs: &subst::Substs,\n-                     generics: &ty::Generics)\n-                     -> String\n+pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n+                           base: &str,\n+                           substs: &subst::Substs<'tcx>,\n+                           generics: &ty::Generics<'tcx>)\n+                           -> String\n {\n     if cx.sess.verbose() {\n         if substs.is_noop() {\n@@ -539,102 +540,102 @@ pub fn parameterized(cx: &ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: &ctxt, typ: Ty) -> String {\n+pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n         s = s.as_slice().slice(0u, 32u).to_string();\n     }\n     return s;\n }\n \n-impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Option<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &None => \"None\".to_string(),\n             &Some(ref t) => t.repr(tcx),\n         }\n     }\n }\n \n-impl<T:Repr> Repr for P<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for P<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (*self).repr(tcx)\n     }\n }\n \n-impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx,T:Repr<'tcx>,U:Repr<'tcx>> Repr<'tcx> for Result<T,U> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n             &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n         }\n     }\n }\n \n-impl Repr for () {\n+impl<'tcx> Repr<'tcx> for () {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         \"()\".to_string()\n     }\n }\n \n-impl<'a, Sized? T:Repr> Repr for &'a T {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'a, 'tcx, Sized? T:Repr<'tcx>> Repr<'tcx> for &'a T {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         Repr::repr(*self, tcx)\n     }\n }\n \n-impl<T:Repr> Repr for Rc<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Rc<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-impl<T:Repr> Repr for Box<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Box<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> String {\n+fn repr_vec<'tcx, T:Repr<'tcx>>(tcx: &ctxt<'tcx>, v: &[T]) -> String {\n     vec_map_to_string(v, |t| t.repr(tcx))\n }\n \n-impl<T:Repr> Repr for [T] {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self)\n     }\n }\n \n-impl<T:Repr> Repr for OwnedSlice<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n-impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n-impl<T:UserString> UserString for Vec<T> {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:UserString<'tcx>> UserString<'tcx> for Vec<T> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let strs: Vec<String> =\n             self.iter().map(|t| t.user_string(tcx)).collect();\n         strs.connect(\", \")\n     }\n }\n \n-impl Repr for def::Def {\n+impl<'tcx> Repr<'tcx> for def::Def {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TypeParameterDef({}, {}, {}/{})\",\n                 self.def_id,\n                 self.bounds.repr(tcx),\n@@ -643,7 +644,7 @@ impl Repr for ty::TypeParameterDef {\n     }\n }\n \n-impl Repr for ty::RegionParameterDef {\n+impl<'tcx> Repr<'tcx> for ty::RegionParameterDef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"RegionParameterDef(name={}, def_id={}, bounds={})\",\n                 token::get_name(self.name),\n@@ -652,28 +653,28 @@ impl Repr for ty::RegionParameterDef {\n     }\n }\n \n-impl Repr for Ty {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        ty_to_string(tcx, *self)\n+impl<'tcx> Repr<'tcx> for ty::TyS<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        ty_to_string(tcx, self)\n     }\n }\n \n-impl Repr for ty::mt {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::mt<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         mt_to_string(tcx, self)\n     }\n }\n \n-impl Repr for subst::Substs {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for subst::Substs<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Substs[types={}, regions={}]\",\n                        self.types.repr(tcx),\n                        self.regions.repr(tcx))\n     }\n }\n \n-impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for subst::VecPerParamSpace<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"[{};{};{};{}]\",\n                 self.get_slice(subst::TypeSpace).repr(tcx),\n                 self.get_slice(subst::SelfSpace).repr(tcx),\n@@ -682,13 +683,13 @@ impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     }\n }\n \n-impl Repr for ty::ItemSubsts {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"ItemSubsts({})\", self.substs.repr(tcx))\n     }\n }\n \n-impl Repr for subst::RegionSubsts {\n+impl<'tcx> Repr<'tcx> for subst::RegionSubsts {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             subst::ErasedRegions => \"erased\".to_string(),\n@@ -697,7 +698,7 @@ impl Repr for subst::RegionSubsts {\n     }\n }\n \n-impl Repr for ty::BuiltinBounds {\n+impl<'tcx> Repr<'tcx> for ty::BuiltinBounds {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         let mut res = Vec::new();\n         for b in self.iter() {\n@@ -712,14 +713,14 @@ impl Repr for ty::BuiltinBounds {\n     }\n }\n \n-impl Repr for ty::ExistentialBounds {\n+impl<'tcx> Repr<'tcx> for ty::ExistentialBounds {\n     fn repr(&self, tcx: &ctxt) -> String {\n         self.user_string(tcx)\n     }\n }\n \n-impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::ParamBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut res = Vec::new();\n         res.push(self.builtin_bounds.repr(tcx));\n         for t in self.trait_bounds.iter() {\n@@ -729,8 +730,8 @@ impl Repr for ty::ParamBounds {\n     }\n }\n \n-impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         // when printing out the debug representation, we don't need\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n@@ -742,16 +743,16 @@ impl Repr for ty::TraitRef {\n     }\n }\n \n-impl Repr for ty::TraitDef {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"TraitDef(generics={}, bounds={}, trait_ref={})\",\n                 self.generics.repr(tcx),\n                 self.bounds.repr(tcx),\n                 self.trait_ref.repr(tcx))\n     }\n }\n \n-impl Repr for ast::TraitItem {\n+impl<'tcx> Repr<'tcx> for ast::TraitItem {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         match *self {\n             ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n@@ -764,57 +765,57 @@ impl Repr for ast::TraitItem {\n     }\n }\n \n-impl Repr for ast::Expr {\n+impl<'tcx> Repr<'tcx> for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n     }\n }\n \n-impl Repr for ast::Path {\n+impl<'tcx> Repr<'tcx> for ast::Path {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"path({})\", pprust::path_to_string(self))\n     }\n }\n \n-impl UserString for ast::Path {\n+impl<'tcx> UserString<'tcx> for ast::Path {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         pprust::path_to_string(self)\n     }\n }\n \n-impl Repr for ast::Ty {\n+impl<'tcx> Repr<'tcx> for ast::Ty {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"type({})\", pprust::ty_to_string(self))\n     }\n }\n \n-impl Repr for ast::Item {\n+impl<'tcx> Repr<'tcx> for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n     }\n }\n \n-impl Repr for ast::Lifetime {\n+impl<'tcx> Repr<'tcx> for ast::Lifetime {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"lifetime({}: {})\", self.id, pprust::lifetime_to_string(self))\n     }\n }\n \n-impl Repr for ast::Stmt {\n+impl<'tcx> Repr<'tcx> for ast::Stmt {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n                 pprust::stmt_to_string(self))\n     }\n }\n \n-impl Repr for ast::Pat {\n+impl<'tcx> Repr<'tcx> for ast::Pat {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"pat({}: {})\", self.id, pprust::pat_to_string(self))\n     }\n }\n \n-impl Repr for ty::BoundRegion {\n+impl<'tcx> Repr<'tcx> for ty::BoundRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n@@ -827,7 +828,7 @@ impl Repr for ty::BoundRegion {\n     }\n }\n \n-impl Repr for ty::Region {\n+impl<'tcx> Repr<'tcx> for ty::Region {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             ty::ReEarlyBound(id, space, index, name) => {\n@@ -869,21 +870,21 @@ impl Repr for ty::Region {\n     }\n }\n \n-impl UserString for ty::Region {\n+impl<'tcx> UserString<'tcx> for ty::Region {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         region_to_string(tcx, \"\", false, *self)\n     }\n }\n \n-impl Repr for ty::FreeRegion {\n+impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ReFree({}, {})\",\n                 self.scope_id,\n                 self.bound_region.repr(tcx))\n     }\n }\n \n-impl Repr for ast::DefId {\n+impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n@@ -908,31 +909,31 @@ impl Repr for ast::DefId {\n     }\n }\n \n-impl Repr for ty::Polytype {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Polytype<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Polytype {{generics: {}, ty: {}}}\",\n                 self.generics.repr(tcx),\n                 self.ty.repr(tcx))\n     }\n }\n \n-impl Repr for ty::Generics {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Generics<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Generics(types: {}, regions: {})\",\n                 self.types.repr(tcx),\n                 self.regions.repr(tcx))\n     }\n }\n \n-impl Repr for ty::GenericBounds {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::GenericBounds<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"GenericBounds(types: {}, regions: {})\",\n                 self.types.repr(tcx),\n                 self.regions.repr(tcx))\n     }\n }\n \n-impl Repr for ty::ItemVariances {\n+impl<'tcx> Repr<'tcx> for ty::ItemVariances {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ItemVariances(types={}, \\\n                 regions={})\",\n@@ -941,7 +942,7 @@ impl Repr for ty::ItemVariances {\n     }\n }\n \n-impl Repr for ty::Variance {\n+impl<'tcx> Repr<'tcx> for ty::Variance {\n     fn repr(&self, _: &ctxt) -> String {\n         // The first `.to_string()` returns a &'static str (it is not an implementation\n         // of the ToString trait). Because of that, we need to call `.to_string()` again\n@@ -951,8 +952,8 @@ impl Repr for ty::Variance {\n     }\n }\n \n-impl Repr for ty::Method {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::Method<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"method(name: {}, generics: {}, fty: {}, \\\n                  explicit_self: {}, vis: {}, def_id: {})\",\n                 self.name.repr(tcx),\n@@ -964,53 +965,53 @@ impl Repr for ty::Method {\n     }\n }\n \n-impl Repr for ast::Name {\n+impl<'tcx> Repr<'tcx> for ast::Name {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n \n-impl UserString for ast::Name {\n+impl<'tcx> UserString<'tcx> for ast::Name {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         token::get_name(*self).get().to_string()\n     }\n }\n \n-impl Repr for ast::Ident {\n+impl<'tcx> Repr<'tcx> for ast::Ident {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         token::get_ident(*self).get().to_string()\n     }\n }\n \n-impl Repr for ast::ExplicitSelf_ {\n+impl<'tcx> Repr<'tcx> for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::Visibility {\n+impl<'tcx> Repr<'tcx> for ast::Visibility {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"BareFnTy {{fn_style: {}, abi: {}, sig: {}}}\",\n                 self.fn_style,\n                 self.abi.to_string(),\n                 self.sig.repr(tcx))\n     }\n }\n \n-impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         fn_sig_to_string(tcx, self)\n     }\n }\n \n-impl Repr for ty::FnOutput {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for ty::FnOutput<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             ty::FnConverging(ty) =>\n                 format!(\"FnConverging({0})\", ty.repr(tcx)),\n@@ -1020,17 +1021,17 @@ impl Repr for ty::FnOutput {\n     }\n }\n \n-impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodCallee<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodCallee {{origin: {}, ty: {}, {}}}\",\n                 self.origin.repr(tcx),\n                 self.ty.repr(tcx),\n                 self.substs.repr(tcx))\n     }\n }\n \n-impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodOrigin<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n@@ -1048,36 +1049,36 @@ impl Repr for typeck::MethodOrigin {\n     }\n }\n \n-impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodParam<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodParam({},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num)\n     }\n }\n \n-impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for typeck::MethodObject<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"MethodObject({},{},{})\",\n                 self.trait_ref.repr(tcx),\n                 self.method_num,\n                 self.real_index)\n     }\n }\n \n-impl Repr for ty::TraitStore {\n+impl<'tcx> Repr<'tcx> for ty::TraitStore {\n     fn repr(&self, tcx: &ctxt) -> String {\n         trait_store_to_string(tcx, *self)\n     }\n }\n \n-impl Repr for ty::BuiltinBound {\n+impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl UserString for ty::BuiltinBound {\n+impl<'tcx> UserString<'tcx> for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n             ty::BoundSend => \"Send\".to_string(),\n@@ -1088,21 +1089,21 @@ impl UserString for ty::BuiltinBound {\n     }\n }\n \n-impl Repr for Span {\n+impl<'tcx> Repr<'tcx> for Span {\n     fn repr(&self, tcx: &ctxt) -> String {\n         tcx.sess.codemap().span_to_string(*self).to_string()\n     }\n }\n \n-impl<A:UserString> UserString for Rc<A> {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx, A:UserString<'tcx>> UserString<'tcx> for Rc<A> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n-impl UserString for ty::ParamBounds {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::ParamBounds<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         let mut result = Vec::new();\n         let s = self.builtin_bounds.user_string(tcx);\n         if !s.is_empty() {\n@@ -1115,7 +1116,7 @@ impl UserString for ty::ParamBounds {\n     }\n }\n \n-impl UserString for ty::ExistentialBounds {\n+impl<'tcx> UserString<'tcx> for ty::ExistentialBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n@@ -1138,7 +1139,7 @@ impl UserString for ty::ExistentialBounds {\n     }\n }\n \n-impl UserString for ty::BuiltinBounds {\n+impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         self.iter()\n             .map(|bb| bb.user_string(tcx))\n@@ -1148,8 +1149,8 @@ impl UserString for ty::BuiltinBounds {\n     }\n }\n \n-impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         // Replace any anonymous late-bound regions with named\n         // variants, using gensym'd identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n@@ -1188,31 +1189,31 @@ impl UserString for ty::TraitRef {\n     }\n }\n \n-impl UserString for Ty {\n-    fn user_string(&self, tcx: &ctxt) -> String {\n+impl<'tcx> UserString<'tcx> for Ty<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         ty_to_string(tcx, *self)\n     }\n }\n \n-impl UserString for ast::Ident {\n+impl<'tcx> UserString<'tcx> for ast::Ident {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         token::get_name(self.name).get().to_string()\n     }\n }\n \n-impl Repr for abi::Abi {\n+impl<'tcx> Repr<'tcx> for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         self.to_string()\n     }\n }\n \n-impl UserString for abi::Abi {\n+impl<'tcx> UserString<'tcx> for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         self.to_string()\n     }\n }\n \n-impl Repr for ty::UpvarId {\n+impl<'tcx> Repr<'tcx> for ty::UpvarId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"UpvarId({};`{}`;{})\",\n                 self.var_id,\n@@ -1221,82 +1222,82 @@ impl Repr for ty::UpvarId {\n     }\n }\n \n-impl Repr for ast::Mutability {\n+impl<'tcx> Repr<'tcx> for ast::Mutability {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::BorrowKind {\n+impl<'tcx> Repr<'tcx> for ty::BorrowKind {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::UpvarBorrow {\n+impl<'tcx> Repr<'tcx> for ty::UpvarBorrow {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"UpvarBorrow({}, {})\",\n                 self.kind.repr(tcx),\n                 self.region.repr(tcx))\n     }\n }\n \n-impl Repr for ty::IntVid {\n+impl<'tcx> Repr<'tcx> for ty::IntVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::FloatVid {\n+impl<'tcx> Repr<'tcx> for ty::FloatVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::RegionVid {\n+impl<'tcx> Repr<'tcx> for ty::RegionVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::TyVid {\n+impl<'tcx> Repr<'tcx> for ty::TyVid {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", self)\n     }\n }\n \n-impl Repr for ty::IntVarValue {\n+impl<'tcx> Repr<'tcx> for ty::IntVarValue {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::IntTy {\n+impl<'tcx> Repr<'tcx> for ast::IntTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::UintTy {\n+impl<'tcx> Repr<'tcx> for ast::UintTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ast::FloatTy {\n+impl<'tcx> Repr<'tcx> for ast::FloatTy {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{}\", *self)\n     }\n }\n \n-impl Repr for ty::ExplicitSelfCategory {\n+impl<'tcx> Repr<'tcx> for ty::ExplicitSelfCategory {\n     fn repr(&self, _: &ctxt) -> String {\n         explicit_self_category_to_str(self).to_string()\n     }\n }\n \n \n-impl Repr for regionmanip::WfConstraint {\n+impl<'tcx> Repr<'tcx> for regionmanip::WfConstraint<'tcx> {\n     fn repr(&self, tcx: &ctxt) -> String {\n         match *self {\n             regionmanip::RegionSubRegionConstraint(_, r_a, r_b) => {\n@@ -1314,7 +1315,7 @@ impl Repr for regionmanip::WfConstraint {\n     }\n }\n \n-impl UserString for ParamTy {\n+impl<'tcx> UserString<'tcx> for ParamTy {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         let id = self.idx;\n         let did = self.def_id;\n@@ -1329,22 +1330,22 @@ impl UserString for ParamTy {\n     }\n }\n \n-impl Repr for ParamTy {\n+impl<'tcx> Repr<'tcx> for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let ident = self.user_string(tcx);\n         format!(\"{}/{}.{}\", ident, self.space, self.idx)\n     }\n }\n \n-impl<A:Repr,B:Repr> Repr for (A,B) {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         let &(ref a, ref b) = self;\n         format!(\"({},{})\", a.repr(tcx), b.repr(tcx))\n     }\n }\n \n-impl<T:Repr> Repr for ty::Binder<T> {\n-    fn repr(&self, tcx: &ctxt) -> String {\n+impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"Binder({})\", self.value.repr(tcx))\n     }\n }"}, {"sha": "d27a338b308c70babc25b0ea2ee238b073eed771", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -196,11 +196,11 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: &ty::ctxt,\n-               symbol_hasher: &mut Sha256,\n-               t: Ty,\n-               link_meta: &LinkMeta)\n-               -> String {\n+fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                     symbol_hasher: &mut Sha256,\n+                     t: Ty<'tcx>,\n+                     link_meta: &LinkMeta)\n+                     -> String {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -219,7 +219,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n     hash\n }\n \n-fn get_symbol_hash(ccx: &CrateContext, t: Ty) -> String {\n+fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> String {\n     match ccx.type_hashcodes().borrow().get(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n@@ -320,8 +320,8 @@ pub fn exported_name(path: PathElems, hash: &str) -> String {\n     mangle(path, Some(hash))\n }\n \n-pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n-                            t: Ty, id: ast::NodeId) -> String {\n+pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathElems,\n+                                      t: Ty<'tcx>, id: ast::NodeId) -> String {\n     let mut hash = get_symbol_hash(ccx, t);\n \n     // Paths can be completely identical for different nodes,\n@@ -345,9 +345,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     exported_name(path, hash.as_slice())\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n-                                            t: Ty,\n-                                            name: &str) -> String {\n+pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                      t: Ty<'tcx>,\n+                                                      name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n     let path = [PathName(token::intern(s.as_slice())),\n                 gensym_name(name)];"}, {"sha": "98cf779fcd2a28fc8dfa35b4bce70fc6f62f2d7d", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -358,7 +358,7 @@ pub struct CrateAnalysis<'tcx> {\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                          ast_map: ast_map::Map<'tcx>,\n-                                         type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                         type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n                                          name: String) -> CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();"}, {"sha": "aa6ac6564e205a4613a4e0a0f1cb44d8334160d4", "filename": "src/librustc_trans/driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fpretty.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -98,7 +98,7 @@ impl PpSourceMode {\n     fn call_with_pp_support<'tcx, A, B>(&self,\n                                         sess: Session,\n                                         ast_map: Option<ast_map::Map<'tcx>>,\n-                                        type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                        type_arena: &'tcx TypedArena<ty::TyS<'tcx>>,\n                                         id: String,\n                                         payload: B,\n                                         f: |&PrinterSupport, B| -> A) -> A {"}, {"sha": "984c1f99720eae65a5d82ab36d3f9b45544a75c9", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -215,59 +215,59 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n-    pub fn make_subtype(&self, a: Ty, b: Ty) -> bool {\n+    pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::mk_subty(self.infcx, true, infer::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n         }\n     }\n \n-    pub fn is_subtype(&self, a: Ty, b: Ty) -> bool {\n+    pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match infer::can_mk_subty(self.infcx, a, b) {\n             Ok(_) => true,\n             Err(_) => false\n         }\n     }\n \n-    pub fn assert_subtype(&self, a: Ty, b: Ty) {\n+    pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         if !self.is_subtype(a, b) {\n             panic!(\"{} is not a subtype of {}, but it should be\",\n                   self.ty_to_string(a),\n                   self.ty_to_string(b));\n         }\n     }\n \n-    pub fn assert_eq(&self, a: Ty, b: Ty) {\n+    pub fn assert_eq(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n     }\n \n-    pub fn ty_to_string(&self, a: Ty) -> String {\n+    pub fn ty_to_string(&self, a: Ty<'tcx>) -> String {\n         ty_to_string(self.infcx.tcx, a)\n     }\n \n     pub fn t_fn(&self,\n-                input_tys: &[Ty],\n-                output_ty: Ty)\n-                -> Ty\n+                input_tys: &[Ty<'tcx>],\n+                output_ty: Ty<'tcx>)\n+                -> Ty<'tcx>\n     {\n         ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n     }\n \n-    pub fn t_nil(&self) -> Ty {\n+    pub fn t_nil(&self) -> Ty<'tcx> {\n         ty::mk_nil(self.infcx.tcx)\n     }\n \n-    pub fn t_pair(&self, ty1: Ty, ty2: Ty) -> Ty {\n+    pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n         ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n     }\n \n     pub fn t_closure(&self,\n-                     input_tys: &[Ty],\n-                     output_ty: Ty,\n+                     input_tys: &[Ty<'tcx>],\n+                     output_ty: Ty<'tcx>,\n                      region_bound: ty::Region)\n-                     -> Ty\n+                     -> Ty<'tcx>\n     {\n         ty::mk_closure(self.infcx.tcx, ty::ClosureTy {\n             fn_style: ast::NormalFn,\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         })\n     }\n \n-    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> Ty {\n+    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> Ty<'tcx> {\n         ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n     }\n \n@@ -301,23 +301,26 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         ty::ReLateBound(debruijn, ty::BrAnon(id))\n     }\n \n-    pub fn t_rptr(&self, r: ty::Region) -> Ty {\n+    pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, id: uint) -> Ty {\n+    pub fn t_rptr_late_bound(&self, id: uint) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> Ty {\n+    pub fn t_rptr_late_bound_with_debruijn(&self,\n+                                           id: uint,\n+                                           debruijn: ty::DebruijnIndex)\n+                                           -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.re_late_bound_with_debruijn(id, debruijn),\n                         ty::mk_int())\n     }\n \n-    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty {\n+    pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n     }\n \n@@ -326,15 +329,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                                    bound_region: ty::BrAnon(id)})\n     }\n \n-    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty {\n+    pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n     }\n \n-    pub fn t_rptr_static(&self) -> Ty {\n+    pub fn t_rptr_static(&self) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n     }\n \n-    pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n+    pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n         infer::TypeTrace::dummy()\n     }\n \n@@ -348,7 +351,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn make_lub_ty(&self, t1: Ty, t2: Ty) -> Ty {\n+    pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n@@ -357,7 +360,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n-    pub fn check_lub(&self, t1: Ty, t2: Ty, t_lub: Ty) {\n+    pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n@@ -370,7 +373,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     /// Checks that `GLB(t1,t2) == t_glb`\n-    pub fn check_glb(&self, t1: Ty, t2: Ty, t_glb: Ty) {\n+    pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\",\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),"}, {"sha": "8d16e56d435aa221969b2aeb7835b0e30c620579", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -248,16 +248,16 @@ impl<'a> ConstantExpr<'a> {\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n #[deriving(Show)]\n-enum Opt<'a> {\n+enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n-    Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n+    Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'a> Opt<'a> {\n-    fn eq(&self, other: &Opt<'a>, tcx: &ty::ctxt) -> bool {\n+impl<'a, 'tcx> Opt<'a, 'tcx> {\n+    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: &ty::ctxt<'tcx>) -> bool {\n         match (self, other) {\n             (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n             (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n@@ -274,7 +274,7 @@ impl<'a> Opt<'a> {\n         }\n     }\n \n-    fn trans<'blk, 'tcx>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n+    fn trans<'blk>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n@@ -334,20 +334,20 @@ pub enum TransBindingMode {\n  * - `id` is the node id of the binding\n  * - `ty` is the Rust type of the binding */\n  #[deriving(Clone)]\n-pub struct BindingInfo {\n+pub struct BindingInfo<'tcx> {\n     pub llmatch: ValueRef,\n     pub trmode: TransBindingMode,\n     pub id: ast::NodeId,\n     pub span: Span,\n-    pub ty: Ty,\n+    pub ty: Ty<'tcx>,\n }\n \n-type BindingsMap = FnvHashMap<Ident, BindingInfo>;\n+type BindingsMap<'tcx> = FnvHashMap<Ident, BindingInfo<'tcx>>;\n \n struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n     arm: &'p ast::Arm,\n-    bindings_map: BindingsMap\n+    bindings_map: BindingsMap<'tcx>\n }\n \n /**\n@@ -362,7 +362,7 @@ struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     bound_ptrs: Vec<(Ident, ValueRef)>,\n }\n \n-impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n+impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -564,7 +564,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n-                                    -> Vec<Opt<'p>> {\n+                                    -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n     let mut found: Vec<Opt> = vec![];\n@@ -608,7 +608,7 @@ struct ExtractedBlock<'blk, 'tcx: 'blk> {\n }\n \n fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    repr: &adt::Repr,\n+                                    repr: &adt::Repr<'tcx>,\n                                     disr_val: ty::Disr,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n@@ -620,7 +620,7 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     ExtractedBlock { vals: args, bcx: bcx }\n }\n \n-fn match_datum(val: ValueRef, left_ty: Ty) -> Datum<Lvalue> {\n+fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n     /*!\n      * Helper for converting from the ValueRef that we pass around in\n      * the match code, which is always an lvalue, into a Datum. Eventually\n@@ -790,12 +790,12 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n-                              rhs_t: Ty)\n+                              rhs_t: Ty<'tcx>)\n                               -> Result<'blk, 'tcx> {\n     fn compare_str<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                lhs: ValueRef,\n                                rhs: ValueRef,\n-                               rhs_t: Ty)\n+                               rhs_t: Ty<'tcx>)\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n@@ -832,7 +832,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n }\n \n fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                               bindings_map: &BindingsMap,\n+                               bindings_map: &BindingsMap<'tcx>,\n                                cs: Option<cleanup::ScopeId>)\n                                -> Block<'blk, 'tcx> {\n     /*!\n@@ -889,7 +889,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      guard_expr: &ast::Expr,\n-                                     data: &ArmData,\n+                                     data: &ArmData<'p, 'blk, 'tcx>,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                      vals: &[ValueRef],\n                                      chk: &FailureHandler,\n@@ -1272,7 +1272,7 @@ struct ReassignmentChecker {\n     reassigned: bool\n }\n \n-impl euv::Delegate for ReassignmentChecker {\n+impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n@@ -1288,8 +1288,9 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: Block, pat: &ast::Pat,\n-                      discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n+fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n+                                   discr: &ast::Expr, body: &ast::Expr)\n+                                   -> BindingsMap<'tcx> {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n     // Note that we use the names because each binding will have many ids\n@@ -1482,7 +1483,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              pat: &ast::Pat,\n-                             arg: Datum<Rvalue>,\n+                             arg: Datum<'tcx, Rvalue>,\n                              arg_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx> {\n     /*!\n@@ -1560,7 +1561,7 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n                                     ident: &ast::Ident,\n                                     cleanup_scope: cleanup::ScopeId,\n                                     arg: A,\n-                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty|\n+                                    populate: |A, Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|\n                                               -> Block<'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {\n     let var_ty = node_id_type(bcx, p_id);"}, {"sha": "eaf3f904107b2c561ccfa0b055abd7824fd4df3c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -76,7 +76,7 @@ type Hint = attr::ReprAttr;\n \n /// Representations.\n #[deriving(Eq, PartialEq, Show)]\n-pub enum Repr {\n+pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /**\n@@ -86,7 +86,7 @@ pub enum Repr {\n      * avoid running the destructor too many times; this is included\n      * in the `Struct` if present.\n      */\n-    Univariant(Struct, bool),\n+    Univariant(Struct<'tcx>, bool),\n     /**\n      * General-case enums: for each case there is a struct, and they\n      * all start with a field for the discriminant.\n@@ -95,7 +95,7 @@ pub enum Repr {\n      * avoid running the destructor too many times; the last argument\n      * indicates whether such a flag is present.\n      */\n-    General(IntType, Vec<Struct>, bool),\n+    General(IntType, Vec<Struct<'tcx>>, bool),\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n      * `nndiscr` must have single field which is known to be nonnull due to its type.\n@@ -105,8 +105,8 @@ pub enum Repr {\n      */\n     RawNullablePointer {\n         nndiscr: Disr,\n-        nnty: Ty,\n-        nullfields: Vec<Ty>\n+        nnty: Ty<'tcx>,\n+        nullfields: Vec<Ty<'tcx>>\n     },\n     /**\n      * Two cases distinguished by a nullable pointer: the case with discriminant\n@@ -120,36 +120,38 @@ pub enum Repr {\n      * identity function.\n      */\n     StructWrappedNullablePointer {\n-        nonnull: Struct,\n+        nonnull: Struct<'tcx>,\n         nndiscr: Disr,\n         ptrfield: PointerField,\n-        nullfields: Vec<Ty>,\n+        nullfields: Vec<Ty<'tcx>>,\n     }\n }\n \n /// For structs, and struct-like parts of anything fancier.\n #[deriving(Eq, PartialEq, Show)]\n-pub struct Struct {\n+pub struct Struct<'tcx> {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n     pub size: u64,\n     pub align: u32,\n     pub sized: bool,\n     pub packed: bool,\n-    pub fields: Vec<Ty>\n+    pub fields: Vec<Ty<'tcx>>\n }\n \n /**\n  * Convenience for `represent_type`.  There should probably be more or\n  * these, for places in trans where the `Ty` isn't directly\n  * available.\n  */\n-pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n+pub fn represent_node<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  node: ast::NodeId) -> Rc<Repr<'tcx>> {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &CrateContext, t: Ty) -> Rc<Repr> {\n+pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                t: Ty<'tcx>) -> Rc<Repr<'tcx>> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n     match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n@@ -162,10 +164,11 @@ pub fn represent_type(cx: &CrateContext, t: Ty) -> Rc<Repr> {\n     repr\n }\n \n-fn represent_type_uncached(cx: &CrateContext, t: Ty) -> Repr {\n+fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     t: Ty<'tcx>) -> Repr<'tcx> {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n+            Univariant(mk_struct(cx, elems.as_slice(), false, t), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -176,13 +179,12 @@ fn represent_type_uncached(cx: &CrateContext, t: Ty) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys.as_slice(), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, ref substs) => {\n             let upvars = ty::unboxed_closure_upvars(cx.tcx(), def_id, substs);\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            return Univariant(mk_struct(cx, upvar_types.as_slice(), false, t),\n-                              false)\n+            Univariant(mk_struct(cx, upvar_types.as_slice(), false, t), false)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n@@ -285,9 +287,9 @@ fn represent_type_uncached(cx: &CrateContext, t: Ty) -> Repr {\n }\n \n // this should probably all be in ty\n-struct Case {\n+struct Case<'tcx> {\n     discr: Disr,\n-    tys: Vec<Ty>\n+    tys: Vec<Ty<'tcx>>\n }\n \n \n@@ -297,12 +299,12 @@ pub enum PointerField {\n     FatPointer(uint)\n }\n \n-impl Case {\n-    fn is_zerolen(&self, cx: &CrateContext, scapegoat: Ty) -> bool {\n+impl<'tcx> Case<'tcx> {\n+    fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n         mk_struct(cx, self.tys.as_slice(), false, scapegoat).size == 0\n     }\n \n-    fn find_ptr(&self, cx: &CrateContext) -> Option<PointerField> {\n+    fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<PointerField> {\n         for (i, &ty) in self.tys.iter().enumerate() {\n             match ty::get(ty).sty {\n                 // &T/&mut T/Box<T> could either be a thin or fat pointer depending on T\n@@ -336,7 +338,10 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<Case> {\n+fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   def_id: ast::DefId,\n+                   substs: &subst::Substs<'tcx>)\n+                   -> Vec<Case<'tcx>> {\n     ty::enum_variants(tcx, def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n             raw_ty.subst(tcx, substs)\n@@ -345,7 +350,10 @@ fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &subst::Substs) -> Vec<\n     }).collect()\n }\n \n-fn mk_struct(cx: &CrateContext, tys: &[Ty], packed: bool, scapegoat: Ty) -> Struct {\n+fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                       tys: &[Ty<'tcx>], packed: bool,\n+                       scapegoat: Ty<'tcx>)\n+                       -> Struct<'tcx> {\n     let sized = tys.iter().all(|&ty| ty::type_is_sized(cx.tcx(), ty));\n     let lltys : Vec<Type> = if sized {\n         tys.iter()\n@@ -375,7 +383,9 @@ struct IntBounds {\n     uhi: u64\n }\n \n-fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+fn mk_cenum<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                      hint: Hint, bounds: &IntBounds)\n+                      -> Repr<'tcx> {\n     let it = range_to_inttype(cx, hint, bounds);\n     match it {\n         attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n@@ -450,18 +460,19 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-pub fn ty_of_inttype(ity: IntType) -> Ty {\n+// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n+pub fn ty_of_inttype<'tcx>(ity: IntType) -> Ty<'tcx> {\n     match ity {\n         attr::SignedInt(t) => ty::mk_mach_int(t),\n         attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n     }\n }\n \n // LLVM doesn't like types that don't fit in the address space\n-fn ensure_struct_fits_in_address_space(ccx: &CrateContext,\n-                                       fields: &[Type],\n-                                       packed: bool,\n-                                       scapegoat: Ty) {\n+fn ensure_struct_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                 fields: &[Type],\n+                                                 packed: bool,\n+                                                 scapegoat: Ty<'tcx>) {\n     let mut offset = 0;\n     for &llty in fields.iter() {\n         // Invariant: offset < ccx.max_obj_size() <= 1<<61\n@@ -486,10 +497,10 @@ fn union_size_and_align(sts: &[Struct]) -> (machine::llsize, machine::llalign) {\n     (size, most_aligned.align)\n }\n \n-fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n-                                     discr: IntType,\n-                                     fields: &[Struct],\n-                                     scapegoat: Ty) {\n+fn ensure_enum_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               discr: IntType,\n+                                               fields: &[Struct],\n+                                               scapegoat: Ty<'tcx>) {\n     let discr_size = machine::llsize_of_alloc(ccx, ll_inttype(ccx, discr));\n     let (field_size, field_align) = union_size_and_align(fields);\n \n@@ -513,19 +524,22 @@ fn ensure_enum_fits_in_address_space(ccx: &CrateContext,\n  * and fill in the actual contents in a second pass to prevent\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n-pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>) -> Type {\n     generic_type_of(cx, r, None, false, false)\n }\n // Pass dst=true if the type you are passing is a DST. Yes, we could figure\n // this out, but if you call this on an unsized type without realising it, you\n // are going to get the wrong type (it will not include the unsized parts of it).\n-pub fn sizing_type_of(cx: &CrateContext, r: &Repr, dst: bool) -> Type {\n+pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                r: &Repr<'tcx>, dst: bool) -> Type {\n     generic_type_of(cx, r, None, true, dst)\n }\n-pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n+pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    r: &Repr<'tcx>, name: &str) -> Type {\n     generic_type_of(cx, r, Some(name), false, false)\n }\n-pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n+pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n@@ -534,11 +548,11 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     }\n }\n \n-fn generic_type_of(cx: &CrateContext,\n-                   r: &Repr,\n-                   name: Option<&str>,\n-                   sizing: bool,\n-                   dst: bool) -> Type {\n+fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                             r: &Repr<'tcx>,\n+                             name: Option<&str>,\n+                             sizing: bool,\n+                             dst: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         RawNullablePointer { nnty, .. } => type_of::sizing_type_of(cx, nnty),\n@@ -596,7 +610,8 @@ fn generic_type_of(cx: &CrateContext,\n     }\n }\n \n-fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> Vec<Type> {\n+fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, st: &Struct<'tcx>,\n+                             sizing: bool, dst: bool) -> Vec<Type> {\n     if sizing {\n         st.fields.iter().filter(|&ty| !dst || ty::type_is_sized(cx.tcx(), *ty))\n             .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n@@ -611,8 +626,9 @@ fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool, dst: bool) -> V\n  *\n  * This should ideally be less tightly tied to `_match`.\n  */\n-pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n-    -> (_match::BranchKind, Option<ValueRef>) {\n+pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                r: &Repr<'tcx>, scrutinee: ValueRef)\n+                                -> (_match::BranchKind, Option<ValueRef>) {\n     match *r {\n         CEnum(..) | General(..) |\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n@@ -627,7 +643,8 @@ pub fn trans_switch(bcx: Block, r: &Repr, scrutinee: ValueRef)\n \n \n /// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Option<Type>)\n+pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n     let signed;\n     let val;\n@@ -728,7 +745,8 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n  * Set the discriminant for a new value of the given case of the given\n  * representation.\n  */\n-pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n+pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   val: ValueRef, discr: Disr) {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n@@ -806,8 +824,8 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n }\n \n /// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n-                       ix: uint) -> ValueRef {\n+pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n+                                   val: ValueRef, discr: Disr, ix: uint) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -845,8 +863,8 @@ pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n     }\n }\n \n-pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n-                        ix: uint, needs_cast: bool) -> ValueRef {\n+pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: ValueRef,\n+                                    ix: uint, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n@@ -860,8 +878,8 @@ pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n }\n \n pub fn fold_variants<'blk, 'tcx>(\n-        bcx: Block<'blk, 'tcx>, r: &Repr, value: ValueRef,\n-        f: |Block<'blk, 'tcx>, &Struct, ValueRef| -> Block<'blk, 'tcx>)\n+        bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, value: ValueRef,\n+        f: |Block<'blk, 'tcx>, &Struct<'tcx>, ValueRef| -> Block<'blk, 'tcx>)\n         -> Block<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     match *r {\n@@ -900,7 +918,7 @@ pub fn fold_variants<'blk, 'tcx>(\n }\n \n /// Access the struct drop flag, if present.\n-pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val: ValueRef)\n+pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n                                        -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n     let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n@@ -949,8 +967,8 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n-                   vals: &[ValueRef]) -> ValueRef {\n+pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr: Disr,\n+                             vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(ity, min, max) => {\n             assert_eq!(vals.len(), 0);\n@@ -1004,7 +1022,8 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n /**\n  * Compute struct field offsets relative to struct begin.\n  */\n-fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n+fn compute_struct_field_offsets<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                          st: &Struct<'tcx>) -> Vec<u64> {\n     let mut offsets = vec!();\n \n     let mut offset = 0;\n@@ -1031,8 +1050,9 @@ fn compute_struct_field_offsets(ccx: &CrateContext, st: &Struct) -> Vec<u64> {\n  * a two-element struct will locate it at offset 4, and accesses to it\n  * will read the wrong memory.\n  */\n-fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n-    -> Vec<ValueRef> {\n+fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                st: &Struct<'tcx>, vals: &[ValueRef])\n+                                -> Vec<ValueRef> {\n     assert_eq!(vals.len(), st.fields.len());\n \n     let target_offsets = compute_struct_field_offsets(ccx, st);"}, {"sha": "979082737c531d8ad94647c2a21dd7237ec3e435", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 137, "deletions": 126, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -25,7 +25,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::IsUnboxedClosureFlag::*;\n pub use self::ValueOrigin::*;\n pub use self::scalar_type::*;\n \n@@ -49,8 +48,9 @@ use trans::adt;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n use trans::callee;\n-use trans::cleanup::{CleanupMethods, ScopeId};\n+use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n+use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n@@ -224,7 +224,8 @@ pub fn get_extern_fn(ccx: &CrateContext,\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str, did: ast::DefId) -> ValueRef {\n+fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n+                                name: &str, did: ast::DefId) -> ValueRef {\n     match ccx.externs().borrow().get(name) {\n         Some(n) => return *n,\n         None => ()\n@@ -240,10 +241,10 @@ fn get_extern_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str, did: ast::DefId\n     f\n }\n \n-pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n+pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      closure_id: ast::DefId,\n-                                     fn_ty: Ty)\n-                                     -> Ty {\n+                                     fn_ty: Ty<'tcx>)\n+                                     -> Ty<'tcx> {\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n@@ -263,7 +264,8 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n     (*unboxed_closures)[closure_id].kind\n }\n \n-pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str) -> ValueRef {\n+pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match ty::get(fn_ty).sty {\n         ty::ty_bare_fn(ref f) => {\n             (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n@@ -297,14 +299,15 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str) -> ValueRef {\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, fn_ty: Ty, name: &str) -> ValueRef {\n+pub fn decl_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, fn_ty, name);\n     llvm::SetLinkage(llfn, llvm::InternalLinkage);\n     llfn\n }\n \n-pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n-                        t: Ty) -> ValueRef {\n+pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n+                                  t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n     match ccx.externs().borrow_mut().get(&name) {\n@@ -335,15 +338,17 @@ pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n-pub fn at_box_body(bcx: Block, body_t: Ty, boxptr: ValueRef) -> ValueRef {\n+pub fn at_box_body<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                               body_t: Ty<'tcx>, boxptr: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"at_box_body\");\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, &[0u, abi::box_field_body])\n }\n \n-fn require_alloc_fn(bcx: Block, info_ty: Ty, it: LangItem) -> ast::DefId {\n+fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n@@ -359,7 +364,7 @@ fn require_alloc_fn(bcx: Block, info_ty: Ty, it: LangItem) -> ast::DefId {\n \n pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   llty_ptr: Type,\n-                                  info_ty: Ty,\n+                                  info_ty: Ty<'tcx>,\n                                   size: ValueRef,\n                                   align: ValueRef)\n                                   -> Result<'blk, 'tcx> {\n@@ -374,7 +379,8 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n }\n \n-pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty) -> Result<'blk, 'tcx> {\n+pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>)\n+                                       -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"malloc_raw_dyn_proc\");\n     let ccx = bcx.ccx();\n \n@@ -399,7 +405,8 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty) -> Result<\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc(ccx: &CrateContext, t: Ty) -> Rc<tydesc_info> {\n+pub fn get_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            t: Ty<'tcx>) -> Rc<tydesc_info<'tcx>> {\n     match ccx.tydescs().borrow().get(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n@@ -494,12 +501,12 @@ pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n }\n \n \n-pub fn get_res_dtor(ccx: &CrateContext,\n-                    did: ast::DefId,\n-                    t: Ty,\n-                    parent_id: ast::DefId,\n-                    substs: &subst::Substs)\n-                 -> ValueRef {\n+pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              did: ast::DefId,\n+                              t: Ty<'tcx>,\n+                              parent_id: ast::DefId,\n+                              substs: &subst::Substs<'tcx>)\n+                              -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = inline::maybe_instantiate_inline(ccx, did);\n \n@@ -549,7 +556,7 @@ pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n-                                        t: Ty,\n+                                        t: Ty<'tcx>,\n                                         op: ast::BinOp)\n                                         -> Result<'blk, 'tcx> {\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n@@ -627,11 +634,11 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn compare_simd_types(\n-                    cx: Block,\n+pub fn compare_simd_types<'blk, 'tcx>(\n+                    cx: Block<'blk, 'tcx>,\n                     lhs: ValueRef,\n                     rhs: ValueRef,\n-                    t: Ty,\n+                    t: Ty<'tcx>,\n                     size: uint,\n                     op: ast::BinOp)\n                     -> ValueRef {\n@@ -666,21 +673,21 @@ pub fn compare_simd_types(\n }\n \n pub type val_and_ty_fn<'a, 'blk, 'tcx> =\n-    |Block<'blk, 'tcx>, ValueRef, Ty|: 'a -> Block<'blk, 'tcx>;\n+    |Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|: 'a -> Block<'blk, 'tcx>;\n \n // Iterates through the elements of a structural type.\n pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                           av: ValueRef,\n-                                          t: Ty,\n+                                          t: Ty<'tcx>,\n                                           f: val_and_ty_fn<'a, 'blk, 'tcx>)\n                                           -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"iter_structural_ty\");\n \n     fn iter_variant<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                    repr: &adt::Repr,\n+                                    repr: &adt::Repr<'tcx>,\n                                     av: ValueRef,\n-                                    variant: &ty::VariantInfo,\n-                                    substs: &subst::Substs,\n+                                    variant: &ty::VariantInfo<'tcx>,\n+                                    substs: &subst::Substs<'tcx>,\n                                     f: val_and_ty_fn<'a, 'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");\n@@ -855,7 +862,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 divrem: ast::BinOp,\n                                 lhs: ValueRef,\n                                 rhs: ValueRef,\n-                                rhs_t: Ty)\n+                                rhs_t: Ty<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n     let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n         (\"attempted to divide by zero\",\n@@ -922,7 +929,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n     }\n }\n \n-pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: Ty) -> ValueRef {\n+pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     did: ast::DefId, t: Ty<'tcx>) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -951,7 +959,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: Ty) -> ValueR\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: Vec<ValueRef> ,\n-                          fn_ty: Ty,\n+                          fn_ty: Ty<'tcx>,\n                           call_info: Option<NodeInfo>,\n                           // FIXME(15064) is_lang_item is a horrible hack, please remove it\n                           // at the soonest opportunity.\n@@ -1028,13 +1036,15 @@ pub fn need_invoke(bcx: Block) -> bool {\n     bcx.fcx.needs_invoke()\n }\n \n-pub fn load_if_immediate(cx: Block, v: ValueRef, t: Ty) -> ValueRef {\n+pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                     v: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n     if type_is_immediate(cx.ccx(), t) { return load_ty(cx, v, t); }\n     return v;\n }\n \n-pub fn load_ty(cx: Block, ptr: ValueRef, t: Ty) -> ValueRef {\n+pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                           ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     /*!\n      * Helper for loading values from memory. Does the necessary conversion if\n      * the in-memory type differs from the type used for SSA values. Also\n@@ -1148,7 +1158,9 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: Ty) {\n+pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             dst: ValueRef, src: ValueRef,\n+                             t: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n@@ -1161,7 +1173,7 @@ pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: Ty) {\n     }\n }\n \n-pub fn zero_mem(cx: Block, llptr: ValueRef, t: Ty) {\n+pub fn zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n     if cx.unreachable.get() { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n@@ -1173,7 +1185,7 @@ pub fn zero_mem(cx: Block, llptr: ValueRef, t: Ty) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-fn memzero(b: &Builder, llptr: ValueRef, ty: Ty) {\n+fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n@@ -1194,7 +1206,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Ty) {\n     b.call(llintrinsicfn, &[llptr, llzeroval, size, align, volatile], None);\n }\n \n-pub fn alloc_ty(bcx: Block, t: Ty, name: &str) -> ValueRef {\n+pub fn alloc_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let ty = type_of::type_of(ccx, t);\n@@ -1220,7 +1232,8 @@ pub fn alloca_no_lifetime(cx: Block, ty: Type, name: &str) -> ValueRef {\n     Alloca(cx, ty, name)\n }\n \n-pub fn alloca_zeroed(cx: Block, ty: Ty, name: &str) -> ValueRef {\n+pub fn alloca_zeroed<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n+                                 name: &str) -> ValueRef {\n     let llty = type_of::type_of(cx.ccx(), ty);\n     if cx.unreachable.get() {\n         unsafe {\n@@ -1248,7 +1261,8 @@ pub fn arrayalloca(cx: Block, ty: Type, v: ValueRef) -> ValueRef {\n }\n \n // Creates the alloca slot which holds the pointer to the slot for the final return value\n-pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: Ty) -> ValueRef {\n+pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                          output_type: Ty<'tcx>) -> ValueRef {\n     let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n \n     // We create an alloca to hold a pointer of type `output_type`\n@@ -1407,8 +1421,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              llfndecl: ValueRef,\n                              id: ast::NodeId,\n                              has_env: bool,\n-                             output_type: ty::FnOutput,\n-                             param_substs: &'a param_substs,\n+                             output_type: ty::FnOutput<'tcx>,\n+                             param_substs: &'a param_substs<'tcx>,\n                              sp: Option<Span>,\n                              block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n                              -> FunctionContext<'a, 'tcx> {\n@@ -1463,7 +1477,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n /// and allocating space for the return pointer.\n pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n                                skip_retptr: bool,\n-                               output: ty::FnOutput) -> Block<'a, 'tcx> {\n+                               output: ty::FnOutput<'tcx>)\n+                               -> Block<'a, 'tcx> {\n     let entry_bcx = fcx.new_temp_block(\"entry-block\");\n \n     // Use a dummy instruction as the insertion point for all allocas.\n@@ -1499,7 +1514,8 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n //  - new_fn_ctxt\n //  - trans_args\n \n-pub fn arg_kind(cx: &FunctionContext, t: Ty) -> datum::Rvalue {\n+pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>)\n+                          -> datum::Rvalue {\n     use trans::datum::{ByRef, ByValue};\n \n     datum::Rvalue {\n@@ -1508,15 +1524,15 @@ pub fn arg_kind(cx: &FunctionContext, t: Ty) -> datum::Rvalue {\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum = datum::Datum<datum::Rvalue>;\n-pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n+pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // create_datums_for_fn_args: creates rvalue datums for each of the\n // incoming function arguments. These will later be stored into\n // appropriate lvalue datums.\n-pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n-                                 arg_tys: &[Ty])\n-                                 -> Vec<RvalueDatum> {\n+pub fn create_datums_for_fn_args<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+                                           arg_tys: &[Ty<'tcx>])\n+                                           -> Vec<RvalueDatum<'tcx>> {\n     let _icx = push_ctxt(\"create_datums_for_fn_args\");\n \n     // Return an array wrapping the ValueRefs that we get from `get_param` for\n@@ -1532,11 +1548,11 @@ pub fn create_datums_for_fn_args(fcx: &FunctionContext,\n /// datums.\n ///\n /// FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-fn create_datums_for_fn_args_under_call_abi(\n-        mut bcx: Block,\n+fn create_datums_for_fn_args_under_call_abi<'blk, 'tcx>(\n+        mut bcx: Block<'blk, 'tcx>,\n         arg_scope: cleanup::CustomScopeIndex,\n-        arg_tys: &[Ty])\n-        -> Vec<RvalueDatum> {\n+        arg_tys: &[Ty<'tcx>])\n+        -> Vec<RvalueDatum<'tcx>> {\n     let mut result = Vec::new();\n     for (i, &arg_ty) in arg_tys.iter().enumerate() {\n         if i < arg_tys.len() - 1 {\n@@ -1597,7 +1613,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                                     arg_scope: cleanup::CustomScopeIndex,\n                                     bcx: Block<'blk, 'tcx>,\n                                     args: &[ast::Arg],\n-                                    arg_datums: Vec<RvalueDatum> )\n+                                    arg_datums: Vec<RvalueDatum<'tcx>>)\n                                     -> Block<'blk, 'tcx> {\n     debug!(\"copy_args_to_allocas\");\n \n@@ -1629,8 +1645,8 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                         mut bcx: Block<'blk, 'tcx>,\n                                         arg_scope: cleanup::CustomScopeIndex,\n                                         args: &[ast::Arg],\n-                                        arg_datums: Vec<RvalueDatum>,\n-                                        monomorphized_arg_types: &[Ty])\n+                                        arg_datums: Vec<RvalueDatum<'tcx>>,\n+                                        monomorphized_arg_types: &[Ty<'tcx>])\n                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"copy_unboxed_closure_args_to_allocas\");\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n@@ -1681,7 +1697,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput) {\n+                             retty: ty::FnOutput<'tcx>) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n@@ -1704,7 +1720,9 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::FnOutput) {\n+pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n+                                      ret_cx: Block<'blk, 'tcx>,\n+                                      retty: ty::FnOutput<'tcx>) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n         return RetVoid(ret_cx);\n@@ -1763,28 +1781,19 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: Block, retty: ty::FnOut\n     }\n }\n \n-#[deriving(Clone, Eq, PartialEq)]\n-pub enum IsUnboxedClosureFlag {\n-    NotUnboxedClosure,\n-    IsUnboxedClosure,\n-}\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: &CrateContext,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     llfndecl: ValueRef,\n-                     param_substs: &param_substs,\n-                     fn_ast_id: ast::NodeId,\n-                     _attributes: &[ast::Attribute],\n-                     output_type: ty::FnOutput,\n-                     abi: Abi,\n-                     has_env: bool,\n-                     is_unboxed_closure: IsUnboxedClosureFlag,\n-                     maybe_load_env: for<'blk, 'tcx> |Block<'blk, 'tcx>, ScopeId|\n-                                                     -> Block<'blk, 'tcx>) {\n+pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                   decl: &ast::FnDecl,\n+                                   body: &ast::Block,\n+                                   llfndecl: ValueRef,\n+                                   param_substs: &param_substs<'tcx>,\n+                                   fn_ast_id: ast::NodeId,\n+                                   _attributes: &[ast::Attribute],\n+                                   output_type: ty::FnOutput<'tcx>,\n+                                   abi: Abi,\n+                                   closure_env: closure::ClosureEnv<'b, 'tcx>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n@@ -1797,7 +1806,7 @@ pub fn trans_closure(ccx: &CrateContext,\n     let fcx = new_fn_ctxt(ccx,\n                           llfndecl,\n                           fn_ast_id,\n-                          has_env,\n+                          closure_env.kind != closure::NotClosure,\n                           output_type,\n                           param_substs,\n                           Some(body.span),\n@@ -1816,11 +1825,15 @@ pub fn trans_closure(ccx: &CrateContext,\n         decl.inputs.iter()\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n-    let monomorphized_arg_types = match is_unboxed_closure {\n-        NotUnboxedClosure => monomorphized_arg_types,\n+    let monomorphized_arg_types = match closure_env.kind {\n+        closure::NotClosure | closure::BoxedClosure(..) => {\n+            monomorphized_arg_types\n+        }\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+        closure::UnboxedClosure(..) => {\n+            vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n+        }\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n@@ -1839,15 +1852,15 @@ pub fn trans_closure(ccx: &CrateContext,\n             monomorphized_arg_types.as_slice())\n     };\n \n-    bcx = match is_unboxed_closure {\n-        NotUnboxedClosure => {\n+    bcx = match closure_env.kind {\n+        closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n                                  decl.inputs.as_slice(),\n                                  arg_datums)\n         }\n-        IsUnboxedClosure => {\n+        closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n@@ -1857,7 +1870,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         }\n     };\n \n-    bcx = maybe_load_env(bcx, cleanup::CustomScope(arg_scope));\n+    bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n@@ -1912,13 +1925,13 @@ pub fn trans_closure(ccx: &CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: &CrateContext,\n-                decl: &ast::FnDecl,\n-                body: &ast::Block,\n-                llfndecl: ValueRef,\n-                param_substs: &param_substs,\n-                id: ast::NodeId,\n-                attrs: &[ast::Attribute]) {\n+pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          decl: &ast::FnDecl,\n+                          body: &ast::Block,\n+                          llfndecl: ValueRef,\n+                          param_substs: &param_substs<'tcx>,\n+                          id: ast::NodeId,\n+                          attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n     debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n@@ -1934,18 +1947,16 @@ pub fn trans_fn(ccx: &CrateContext,\n                   attrs,\n                   output_type,\n                   abi,\n-                  false,\n-                  NotUnboxedClosure,\n-                  |bcx, _| bcx);\n-}\n-\n-pub fn trans_enum_variant(ccx: &CrateContext,\n-                          _enum_id: ast::NodeId,\n-                          variant: &ast::Variant,\n-                          _args: &[ast::VariantArg],\n-                          disr: ty::Disr,\n-                          param_substs: &param_substs,\n-                          llfndecl: ValueRef) {\n+                  closure::ClosureEnv::new(&[], closure::NotClosure));\n+}\n+\n+pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    _enum_id: ast::NodeId,\n+                                    variant: &ast::Variant,\n+                                    _args: &[ast::VariantArg],\n+                                    disr: ty::Disr,\n+                                    param_substs: &param_substs<'tcx>,\n+                                    llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n     trans_enum_variant_or_tuple_like_struct(\n@@ -1957,7 +1968,7 @@ pub fn trans_enum_variant(ccx: &CrateContext,\n }\n \n pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                                 ctor_ty: Ty,\n+                                                 ctor_ty: Ty<'tcx>,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n@@ -2016,11 +2027,11 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub fn trans_tuple_struct(ccx: &CrateContext,\n-                          _fields: &[ast::StructField],\n-                          ctor_id: ast::NodeId,\n-                          param_substs: &param_substs,\n-                          llfndecl: ValueRef) {\n+pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    _fields: &[ast::StructField],\n+                                    ctor_id: ast::NodeId,\n+                                    param_substs: &param_substs<'tcx>,\n+                                    llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n     trans_enum_variant_or_tuple_like_struct(\n@@ -2031,11 +2042,11 @@ pub fn trans_tuple_struct(ccx: &CrateContext,\n         llfndecl);\n }\n \n-fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n-                                           ctor_id: ast::NodeId,\n-                                           disr: ty::Disr,\n-                                           param_substs: &param_substs,\n-                                           llfndecl: ValueRef) {\n+fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                     ctor_id: ast::NodeId,\n+                                                     disr: ty::Disr,\n+                                                     param_substs: &param_substs<'tcx>,\n+                                                     llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n     let ctor_ty = ctor_ty.substp(ccx.tcx(), param_substs);\n \n@@ -2370,12 +2381,12 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n     }\n }\n \n-fn register_fn(ccx: &CrateContext,\n-               sp: Span,\n-               sym: String,\n-               node_id: ast::NodeId,\n-               node_type: Ty)\n-               -> ValueRef {\n+fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                         sp: Span,\n+                         sym: String,\n+                         node_id: ast::NodeId,\n+                         node_type: Ty<'tcx>)\n+                         -> ValueRef {\n     match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abi == Rust || f.abi == RustCall);\n@@ -2388,8 +2399,8 @@ fn register_fn(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: Ty)\n-                              -> llvm::AttrBuilder {\n+pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>)\n+                                        -> llvm::AttrBuilder {\n     use middle::ty::{BrAnon, ReLateBound};\n \n     let (fn_sig, abi, has_env) = match ty::get(fn_ty).sty {\n@@ -2664,8 +2675,8 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     }\n }\n \n-fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n-                 ty: Ty, attrs: &[ast::Attribute]) -> String {\n+fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, id: ast::NodeId,\n+                           ty: Ty<'tcx>, attrs: &[ast::Attribute]) -> String {\n     match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);"}, {"sha": "f35671f81a4d91153451bdb133fb2fb251d3354e", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -66,26 +66,26 @@ pub struct MethodData {\n     pub llself: ValueRef,\n }\n \n-pub enum CalleeData {\n-    Closure(Datum<Lvalue>),\n+pub enum CalleeData<'tcx> {\n+    Closure(Datum<'tcx, Lvalue>),\n \n     // Constructor for enum variant/tuple-like-struct\n     // i.e. Some, Ok\n-    NamedTupleConstructor(subst::Substs, ty::Disr),\n+    NamedTupleConstructor(subst::Substs<'tcx>, ty::Disr),\n \n     // Represents a (possibly monomorphized) top-level fn item or method\n     // item. Note that this is just the fn-ptr and is not a Rust closure\n     // value (which is a pair).\n     Fn(/* llfn */ ValueRef),\n \n-    Intrinsic(ast::NodeId, subst::Substs),\n+    Intrinsic(ast::NodeId, subst::Substs<'tcx>),\n \n     TraitItem(MethodData)\n }\n \n pub struct Callee<'blk, 'tcx: 'blk> {\n     pub bcx: Block<'blk, 'tcx>,\n-    pub data: CalleeData,\n+    pub data: CalleeData<'tcx>,\n }\n \n fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n@@ -240,7 +240,7 @@ pub fn trans_fn_ref(bcx: Block, def_id: ast::DefId, node: ExprOrMethodCall) -> V\n fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                   def_id: ast::DefId,\n                                                   ref_id: ast::NodeId,\n-                                                  substs: subst::Substs)\n+                                                  substs: subst::Substs<'tcx>)\n                                                   -> Callee<'blk, 'tcx> {\n     Callee {\n         bcx: bcx,\n@@ -253,12 +253,12 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n /// Translates the adapter that deconstructs a `Box<Trait>` object into\n /// `Trait` so that a by-value self method can be called.\n-pub fn trans_unboxing_shim(bcx: Block,\n-                           llshimmedfn: ValueRef,\n-                           fty: &ty::BareFnTy,\n-                           method_id: ast::DefId,\n-                           substs: &subst::Substs)\n-                           -> ValueRef {\n+pub fn trans_unboxing_shim<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       llshimmedfn: ValueRef,\n+                                       fty: &ty::BareFnTy<'tcx>,\n+                                       method_id: ast::DefId,\n+                                       substs: &subst::Substs<'tcx>)\n+                                       -> ValueRef {\n     let _icx = push_ctxt(\"trans_unboxing_shim\");\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n@@ -399,11 +399,11 @@ pub fn trans_unboxing_shim(bcx: Block,\n     llfn\n }\n \n-pub fn trans_fn_ref_with_substs(\n-    bcx: Block,                  //\n+pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n+    bcx: Block<'blk, 'tcx>,      //\n     def_id: ast::DefId,          // def id of fn\n     node: ExprOrMethodCall,      // node id of use of fn; may be zero if N/A\n-    substs: subst::Substs)       // vtables for the call\n+    substs: subst::Substs<'tcx>) // vtables for the call\n     -> ValueRef\n {\n     /*!\n@@ -610,12 +610,12 @@ pub fn trans_fn_ref_with_substs(\n // ______________________________________________________________________\n // Translating calls\n \n-pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n-                              call_ex: &ast::Expr,\n-                              f: &ast::Expr,\n-                              args: CallArgs,\n-                              dest: expr::Dest)\n-                              -> Block<'blk, 'tcx> {\n+pub fn trans_call<'a, 'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n+                                  call_ex: &ast::Expr,\n+                                  f: &ast::Expr,\n+                                  args: CallArgs<'a, 'tcx>,\n+                                  dest: expr::Dest)\n+                                  -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n@@ -625,12 +625,12 @@ pub fn trans_call<'blk, 'tcx>(in_cx: Block<'blk, 'tcx>,\n                      Some(dest)).bcx\n }\n \n-pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     call_ex: &ast::Expr,\n-                                     rcvr: &ast::Expr,\n-                                     args: CallArgs,\n-                                     dest: expr::Dest)\n-                                     -> Block<'blk, 'tcx> {\n+pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                         call_ex: &ast::Expr,\n+                                         rcvr: &ast::Expr,\n+                                         args: CallArgs<'a, 'tcx>,\n+                                         dest: expr::Dest)\n+                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n@@ -669,15 +669,15 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest)\n }\n \n-pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    call_info: Option<NodeInfo>,\n-                                    callee_ty: Ty,\n-                                    get_callee: |bcx: Block<'blk, 'tcx>,\n-                                                arg_cleanup_scope: cleanup::ScopeId|\n-                                                -> Callee<'blk, 'tcx>,\n-                                    args: CallArgs,\n-                                    dest: Option<expr::Dest>)\n-                                    -> Result<'blk, 'tcx> {\n+pub fn trans_call_inner<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        call_info: Option<NodeInfo>,\n+                                        callee_ty: Ty<'tcx>,\n+                                        get_callee: |bcx: Block<'blk, 'tcx>,\n+                                                     arg_cleanup_scope: cleanup::ScopeId|\n+                                                     -> Callee<'blk, 'tcx>,\n+                                        args: CallArgs<'a, 'tcx>,\n+                                        dest: Option<expr::Dest>)\n+                                        -> Result<'blk, 'tcx> {\n     /*!\n      * This behemoth of a function translates function calls.\n      * Unfortunately, in order to generate more efficient LLVM\n@@ -890,7 +890,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub enum CallArgs<'a> {\n+pub enum CallArgs<'a, 'tcx> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n     ArgExprs(&'a [P<ast::Expr>]),\n@@ -903,7 +903,7 @@ pub enum CallArgs<'a> {\n     // For overloaded operators: `(lhs, Vec(rhs, rhs_id))`. `lhs`\n     // is the left-hand-side and `rhs/rhs_id` is the datum/expr-id of\n     // the right-hand-side arguments (if any).\n-    ArgOverloadedOp(Datum<Expr>, Vec<(Datum<Expr>, ast::NodeId)>),\n+    ArgOverloadedOp(Datum<'tcx, Expr>, Vec<(Datum<'tcx, Expr>, ast::NodeId)>),\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n@@ -913,7 +913,7 @@ pub enum CallArgs<'a> {\n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n                              arg_exprs: &[P<ast::Expr>],\n-                             fn_ty: Ty,\n+                             fn_ty: Ty<'tcx>,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n                              ignore_self: bool)\n@@ -973,7 +973,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n fn trans_overloaded_call_args<'blk, 'tcx>(\n                               mut bcx: Block<'blk, 'tcx>,\n                               arg_exprs: Vec<&ast::Expr>,\n-                              fn_ty: Ty,\n+                              fn_ty: Ty<'tcx>,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n                               ignore_self: bool)\n@@ -1016,14 +1016,14 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     bcx\n }\n \n-pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                              args: CallArgs,\n-                              fn_ty: Ty,\n-                              llargs: &mut Vec<ValueRef> ,\n-                              arg_cleanup_scope: cleanup::ScopeId,\n-                              ignore_self: bool,\n-                              abi: synabi::Abi)\n-                              -> Block<'blk, 'tcx> {\n+pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+                                  args: CallArgs<'a, 'tcx>,\n+                                  fn_ty: Ty<'tcx>,\n+                                  llargs: &mut Vec<ValueRef>,\n+                                  arg_cleanup_scope: cleanup::ScopeId,\n+                                  ignore_self: bool,\n+                                  abi: synabi::Abi)\n+                                  -> Block<'blk, 'tcx> {\n     debug!(\"trans_args(abi={})\", abi);\n \n     let _icx = push_ctxt(\"trans_args\");\n@@ -1108,8 +1108,8 @@ pub enum AutorefArg {\n }\n \n pub fn trans_arg_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   formal_arg_ty: Ty,\n-                                   arg_datum: Datum<Expr>,\n+                                   formal_arg_ty: Ty<'tcx>,\n+                                   arg_datum: Datum<'tcx, Expr>,\n                                    arg_cleanup_scope: cleanup::ScopeId,\n                                    autoref_arg: AutorefArg)\n                                    -> Result<'blk, 'tcx> {"}, {"sha": "0a26922e1846836b2d002032386f75506d8941e4", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -41,7 +41,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     kind: CleanupScopeKind<'blk, 'tcx>,\n \n     // Cleanups to run upon scope exit.\n-    cleanups: Vec<CleanupObj>,\n+    cleanups: Vec<CleanupObj<'tcx>>,\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n@@ -94,17 +94,17 @@ pub struct CachedEarlyExit {\n     cleanup_block: BasicBlockRef,\n }\n \n-pub trait Cleanup {\n+pub trait Cleanup<'tcx> {\n     fn must_unwind(&self) -> bool;\n     fn clean_on_unwind(&self) -> bool;\n     fn is_lifetime_end(&self) -> bool;\n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx>;\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx>;\n }\n \n-pub type CleanupObj = Box<Cleanup+'static>;\n+pub type CleanupObj<'tcx> = Box<Cleanup<'tcx>+'tcx>;\n \n #[deriving(Show)]\n pub enum ScopeId {\n@@ -307,7 +307,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty) {\n+                         ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is a pointer to an\n          * instance of `ty`\n@@ -333,7 +333,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty) {\n+                                  ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop and zero-ing of `val`, which is a pointer\n          * to an instance of `ty`\n@@ -360,7 +360,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: Ty) {\n+                               ty: Ty<'tcx>) {\n         /*!\n          * Schedules a (deep) drop of `val`, which is an instance of `ty`\n          */\n@@ -386,7 +386,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: Ty) {\n+                           content_ty: Ty<'tcx>) {\n         /*!\n          * Schedules a call to `free(val)`. Note that this is a shallow\n          * operation.\n@@ -425,7 +425,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj) {\n+                      cleanup: CleanupObj<'tcx>) {\n         match cleanup_scope {\n             AstScope(id) => self.schedule_clean_in_ast_scope(id, cleanup),\n             CustomScope(id) => self.schedule_clean_in_custom_scope(id, cleanup),\n@@ -434,7 +434,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj) {\n+                                   cleanup: CleanupObj<'tcx>) {\n         /*!\n          * Schedules a cleanup to occur upon exit from `cleanup_scope`.\n          * If `cleanup_scope` is not provided, then the cleanup is scheduled\n@@ -462,7 +462,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n     fn schedule_clean_in_custom_scope(&self,\n                                       custom_scope: CustomScopeIndex,\n-                                      cleanup: CleanupObj) {\n+                                      cleanup: CleanupObj<'tcx>) {\n         /*!\n          * Schedules a cleanup to occur in the top-most scope,\n          * which must be a temporary scope.\n@@ -559,7 +559,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse\n                             bcx: Block<'blk, 'tcx>,\n-                            scope: &CleanupScope) -> Block<'blk, 'tcx> {\n+                            scope: &CleanupScope<'blk, 'tcx>) -> Block<'blk, 'tcx> {\n         /*! Generates the cleanups for `scope` into `bcx` */\n \n         let mut bcx = bcx;\n@@ -955,15 +955,15 @@ impl EarlyExitLabel {\n ///////////////////////////////////////////////////////////////////////////\n // Cleanup types\n \n-pub struct DropValue {\n+pub struct DropValue<'tcx> {\n     is_immediate: bool,\n     must_unwind: bool,\n     val: ValueRef,\n-    ty: Ty,\n+    ty: Ty<'tcx>,\n     zero: bool\n }\n \n-impl Cleanup for DropValue {\n+impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n     fn must_unwind(&self) -> bool {\n         self.must_unwind\n     }\n@@ -976,10 +976,10 @@ impl Cleanup for DropValue {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                         -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n         } else {\n@@ -997,13 +997,13 @@ pub enum Heap {\n     HeapExchange\n }\n \n-pub struct FreeValue {\n+pub struct FreeValue<'tcx> {\n     ptr: ValueRef,\n     heap: Heap,\n-    content_ty: Ty\n+    content_ty: Ty<'tcx>\n }\n \n-impl Cleanup for FreeValue {\n+impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n     fn must_unwind(&self) -> bool {\n         true\n     }\n@@ -1016,10 +1016,10 @@ impl Cleanup for FreeValue {\n         false\n     }\n \n-    fn trans<'blk, 'tcx>(&self,\n-                         bcx: Block<'blk, 'tcx>,\n-                         debug_loc: Option<NodeInfo>)\n-                      -> Block<'blk, 'tcx> {\n+    fn trans<'blk>(&self,\n+                   bcx: Block<'blk, 'tcx>,\n+                   debug_loc: Option<NodeInfo>)\n+                   -> Block<'blk, 'tcx> {\n         apply_debug_loc(bcx.fcx, debug_loc);\n \n         match self.heap {\n@@ -1037,7 +1037,7 @@ pub struct FreeSlice {\n     heap: Heap,\n }\n \n-impl Cleanup for FreeSlice {\n+impl<'tcx> Cleanup<'tcx> for FreeSlice {\n     fn must_unwind(&self) -> bool {\n         true\n     }\n@@ -1068,7 +1068,7 @@ pub struct LifetimeEnd {\n     ptr: ValueRef,\n }\n \n-impl Cleanup for LifetimeEnd {\n+impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n     fn must_unwind(&self) -> bool {\n         false\n     }\n@@ -1166,20 +1166,20 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn schedule_drop_mem(&self,\n                          cleanup_scope: ScopeId,\n                          val: ValueRef,\n-                         ty: Ty);\n+                         ty: Ty<'tcx>);\n     fn schedule_drop_and_zero_mem(&self,\n                                   cleanup_scope: ScopeId,\n                                   val: ValueRef,\n-                                  ty: Ty);\n+                                  ty: Ty<'tcx>);\n     fn schedule_drop_immediate(&self,\n                                cleanup_scope: ScopeId,\n                                val: ValueRef,\n-                               ty: Ty);\n+                               ty: Ty<'tcx>);\n     fn schedule_free_value(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n                            heap: Heap,\n-                           content_ty: Ty);\n+                           content_ty: Ty<'tcx>);\n     fn schedule_free_slice(&self,\n                            cleanup_scope: ScopeId,\n                            val: ValueRef,\n@@ -1188,13 +1188,13 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                            heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n-                      cleanup: CleanupObj);\n+                      cleanup: CleanupObj<'tcx>);\n     fn schedule_clean_in_ast_scope(&self,\n                                    cleanup_scope: ast::NodeId,\n-                                   cleanup: CleanupObj);\n+                                   cleanup: CleanupObj<'tcx>);\n     fn schedule_clean_in_custom_scope(&self,\n                                     custom_scope: CustomScopeIndex,\n-                                    cleanup: CleanupObj);\n+                                    cleanup: CleanupObj<'tcx>);\n     fn needs_invoke(&self) -> bool;\n     fn get_landing_pad(&'blk self) -> BasicBlockRef;\n }"}, {"sha": "af4743511a6d8acfe29ef81c01da1c77fb327670", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use self::ClosureKind::*;\n \n use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n@@ -101,21 +102,21 @@ use syntax::ast_util;\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-pub struct EnvValue {\n+pub struct EnvValue<'tcx> {\n     action: ast::CaptureClause,\n-    datum: Datum<Lvalue>\n+    datum: Datum<'tcx, Lvalue>\n }\n \n-impl EnvValue {\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+impl<'tcx> EnvValue<'tcx> {\n+    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"{}({})\", self.action, self.datum.to_string(ccx))\n     }\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys(tcx: &ty::ctxt,\n-                      bound_values: &[EnvValue])\n-                   -> Ty {\n+pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                            bound_values: &[EnvValue<'tcx>])\n+                            -> Ty<'tcx> {\n     // determine the types of the values in the env.  Note that this\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n@@ -131,14 +132,14 @@ pub fn mk_closure_tys(tcx: &ty::ctxt,\n     return cdata_ty;\n }\n \n-fn tuplify_box_ty(tcx: &ty::ctxt, t: Ty) -> Ty {\n+fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              store: ty::TraitStore,\n-                             cdata_ty: Ty)\n+                             cdata_ty: Ty<'tcx>)\n                              -> Result<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n@@ -157,8 +158,8 @@ fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub struct ClosureResult<'blk, 'tcx: 'blk> {\n-    llbox: ValueRef,    // llvalue of ptr to closure\n-    cdata_ty: Ty,    // type of the closure data\n+    llbox: ValueRef,        // llvalue of ptr to closure\n+    cdata_ty: Ty<'tcx>,     // type of the closure data\n     bcx: Block<'blk, 'tcx>  // final bcx\n }\n \n@@ -167,7 +168,7 @@ pub struct ClosureResult<'blk, 'tcx: 'blk> {\n // heap allocated closure that copies the upvars into environment.\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue> ,\n+                                     bound_values: Vec<EnvValue<'tcx>> ,\n                                      store: ty::TraitStore)\n                                      -> ClosureResult<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n@@ -248,17 +249,12 @@ fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: Ty,\n-                                freevars: &Vec<ty::Freevar>,\n+                                cdata_ty: Ty<'tcx>,\n+                                freevars: &[ty::Freevar],\n                                 store: ty::TraitStore)\n                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n-    // Don't bother to create the block if there's nothing to load\n-    if freevars.len() == 0 {\n-        return bcx;\n-    }\n-\n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = at_box_body(bcx, cdata_ty, bcx.fcx.llenv.unwrap());\n \n@@ -304,16 +300,12 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevar_mode: ast::CaptureClause,\n-                                    freevars: &Vec<ty::Freevar>,\n-                                    closure_id: ast::DefId)\n+                                    freevars: &[ty::Freevar])\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n-    if freevars.len() == 0 {\n-        return bcx\n-    }\n-\n     // Special case for small by-value selfs.\n+    let closure_id = ast_util::local_def(bcx.fcx.id);\n     let self_type = self_type_for_unboxed_closure(bcx.ccx(), closure_id,\n                                                   node_id_type(bcx, closure_id.node));\n     let kind = kind_for_unboxed_closure(bcx.ccx(), closure_id);\n@@ -352,6 +344,48 @@ fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef)\n     Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::fn_field_box]));\n }\n \n+#[deriving(PartialEq)]\n+pub enum ClosureKind<'tcx> {\n+    NotClosure,\n+    // See load_environment.\n+    BoxedClosure(Ty<'tcx>, ty::TraitStore),\n+    // See load_unboxed_closure_environment.\n+    UnboxedClosure(ast::CaptureClause)\n+}\n+\n+pub struct ClosureEnv<'a, 'tcx> {\n+    freevars: &'a [ty::Freevar],\n+    pub kind: ClosureKind<'tcx>\n+}\n+\n+impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n+    pub fn new(freevars: &'a [ty::Freevar], kind: ClosureKind<'tcx>)\n+               -> ClosureEnv<'a, 'tcx> {\n+        ClosureEnv {\n+            freevars: freevars,\n+            kind: kind\n+        }\n+    }\n+\n+    pub fn load<'blk>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n+                      -> Block<'blk, 'tcx> {\n+        // Don't bother to create the block if there's nothing to load\n+        if self.freevars.is_empty() {\n+            return bcx;\n+        }\n+\n+        match self.kind {\n+            NotClosure => bcx,\n+            BoxedClosure(cdata_ty, store) => {\n+                load_environment(bcx, cdata_ty, self.freevars, store)\n+            }\n+            UnboxedClosure(freevar_mode) => {\n+                load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n+            }\n+        }\n+    }\n+}\n+\n pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  store: ty::TraitStore,\n                                  decl: &ast::FnDecl,\n@@ -401,6 +435,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         cdata_ty,\n         bcx\n     } = build_closure(bcx, freevar_mode, &freevars, store);\n+\n     trans_closure(ccx,\n                   decl,\n                   body,\n@@ -410,9 +445,8 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n-                  true,\n-                  NotUnboxedClosure,\n-                  |bcx, _| load_environment(bcx, cdata_ty, &freevars, store));\n+                  ClosureEnv::new(freevars.as_slice(),\n+                                  BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n }\n@@ -421,7 +455,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                 closure_id: ast::DefId,\n-                                                                substs: &Substs)\n+                                                                substs: &Substs<'tcx>)\n                                                                 -> Option<ValueRef> {\n     let ccx = bcx.ccx();\n     if !ccx.tcx().unboxed_closures.borrow().contains_key(&closure_id) {\n@@ -495,7 +529,6 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     let freevars: Vec<ty::Freevar> =\n         ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n-    let freevars_ptr = &freevars;\n     let freevar_mode = bcx.tcx().capture_mode(id);\n \n     trans_closure(bcx.ccx(),\n@@ -507,15 +540,8 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   ty::ty_fn_ret(function_type),\n                   ty::ty_fn_abi(function_type),\n-                  true,\n-                  IsUnboxedClosure,\n-                  |bcx, arg_scope| {\n-                      load_unboxed_closure_environment(bcx,\n-                                                       arg_scope,\n-                                                       freevar_mode,\n-                                                       freevars_ptr,\n-                                                       closure_id)\n-                  });\n+                  ClosureEnv::new(freevars.as_slice(),\n+                                  UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size unboxed closure (in which case dest will be\n@@ -531,7 +557,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n \n     // Create the closure.\n-    for (i, freevar) in freevars_ptr.iter().enumerate() {\n+    for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(bcx,\n                                                    &*repr,\n@@ -552,11 +578,11 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     bcx\n }\n \n-pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n-                               closure_ty: Ty,\n-                               def: def::Def,\n-                               fn_ptr: ValueRef,\n-                               is_local: bool) -> ValueRef {\n+pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                         closure_ty: Ty<'tcx>,\n+                                         def: def::Def,\n+                                         fn_ptr: ValueRef,\n+                                         is_local: bool) -> ValueRef {\n \n     let def_id = match def {\n         def::DefFn(did, _) | def::DefStaticMethod(did, _) |\n@@ -647,7 +673,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n }\n \n pub fn make_closure_from_bare_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                             closure_ty: Ty,\n+                                             closure_ty: Ty<'tcx>,\n                                              def: def::Def,\n                                              fn_ptr: ValueRef)\n                                              -> DatumBlock<'blk, 'tcx, Expr>  {"}, {"sha": "019ea9972053d6222d67dd1b5e65a7dc8994909b", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -55,7 +55,8 @@ use syntax::parse::token;\n \n pub use trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n+fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       ty: Ty<'tcx>) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n@@ -68,7 +69,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n+pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     use trans::machine::llsize_of_alloc;\n     use trans::type_of::sizing_type_of;\n \n@@ -93,7 +94,7 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_zero_size(ccx: &CrateContext, ty: Ty) -> bool {\n+pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     /*!\n      * Identify types which have size zero at runtime.\n      */\n@@ -125,8 +126,8 @@ pub fn gensym_name(name: &str) -> PathElem {\n     PathName(token::gensym(format!(\"{}:{}\", name, num).as_slice()))\n }\n \n-pub struct tydesc_info {\n-    pub ty: Ty,\n+pub struct tydesc_info<'tcx> {\n+    pub ty: Ty<'tcx>,\n     pub tydesc: ValueRef,\n     pub size: ValueRef,\n     pub align: ValueRef,\n@@ -190,23 +191,23 @@ pub type ExternMap = FnvHashMap<String, ValueRef>;\n \n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n-pub struct param_substs {\n-    substs: subst::Substs,\n+pub struct param_substs<'tcx> {\n+    substs: subst::Substs<'tcx>,\n }\n \n-impl param_substs {\n-    pub fn new(substs: subst::Substs) -> param_substs {\n+impl<'tcx> param_substs<'tcx> {\n+    pub fn new(substs: subst::Substs<'tcx>) -> param_substs<'tcx> {\n         assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n         assert!(substs.types.all(|t| !ty::type_has_params(*t)));\n         assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n         param_substs { substs: substs.erase_regions() }\n     }\n \n-    pub fn substs(&self) -> &subst::Substs {\n+    pub fn substs(&self) -> &subst::Substs<'tcx> {\n         &self.substs\n     }\n \n-    pub fn empty() -> param_substs {\n+    pub fn empty() -> param_substs<'tcx> {\n         param_substs {\n             substs: subst::Substs::trans_empty(),\n         }\n@@ -217,26 +218,26 @@ impl param_substs {\n     }\n }\n \n-impl Repr for param_substs {\n-    fn repr(&self, tcx: &ty::ctxt) -> String {\n+impl<'tcx> Repr<'tcx> for param_substs<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         self.substs.repr(tcx)\n     }\n }\n \n-pub trait SubstP {\n-    fn substp(&self, tcx: &ty::ctxt, param_substs: &param_substs)\n+pub trait SubstP<'tcx> {\n+    fn substp(&self, tcx: &ty::ctxt<'tcx>, param_substs: &param_substs<'tcx>)\n               -> Self;\n }\n \n-impl<T: Subst + Clone> SubstP for T {\n-    fn substp(&self, tcx: &ty::ctxt, substs: &param_substs) -> T {\n+impl<'tcx, T: Subst<'tcx> + Clone> SubstP<'tcx> for T {\n+    fn substp(&self, tcx: &ty::ctxt<'tcx>, substs: &param_substs<'tcx>) -> T {\n         self.subst(tcx, &substs.substs)\n     }\n }\n \n // work around bizarre resolve errors\n-pub type RvalueDatum = datum::Datum<datum::Rvalue>;\n-pub type LvalueDatum = datum::Datum<datum::Lvalue>;\n+pub type RvalueDatum<'tcx> = datum::Datum<'tcx, datum::Rvalue>;\n+pub type LvalueDatum<'tcx> = datum::Datum<'tcx, datum::Lvalue>;\n \n // Function context.  Every LLVM function we create will have one of\n // these.\n@@ -280,7 +281,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n-    pub lllocals: RefCell<NodeMap<LvalueDatum>>,\n+    pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n \n     // Same as above, but for closure upvars\n     pub llupvars: RefCell<NodeMap<ValueRef>>,\n@@ -291,7 +292,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: &'a param_substs,\n+    pub param_substs: &'a param_substs<'tcx>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -354,7 +355,9 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block, output: ty::FnOutput, name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n+                        output: ty::FnOutput<'tcx>,\n+                        name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n             base::alloca_no_lifetime(bcx, match output {\n                 ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n@@ -495,7 +498,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.ccx().tn().type_to_string(ty)\n     }\n \n-    pub fn ty_to_string(&self, t: Ty) -> String {\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         t.repr(self.tcx())\n     }\n \n@@ -509,19 +512,19 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<Ty<'tcx>> {\n         Ok(node_id_type(self, id))\n     }\n \n-    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<Ty<'tcx>> {\n         self.tcx()\n             .method_map\n             .borrow()\n             .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n \n-    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n+    fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment<'tcx>>> {\n         &self.tcx().adjustments\n     }\n \n@@ -534,7 +537,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure<'tcx>>> {\n         &self.tcx().unboxed_closures\n     }\n \n@@ -788,28 +791,28 @@ pub fn is_null(val: ValueRef) -> bool {\n     }\n }\n \n-pub fn monomorphize_type(bcx: &BlockS, t: Ty) -> Ty {\n+pub fn monomorphize_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n     t.subst(bcx.tcx(), &bcx.fcx.param_substs.substs)\n }\n \n-pub fn node_id_type(bcx: &BlockS, id: ast::NodeId) -> Ty {\n+pub fn node_id_type<'blk, 'tcx>(bcx: &BlockS<'blk, 'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     let tcx = bcx.tcx();\n     let t = ty::node_id_to_type(tcx, id);\n     monomorphize_type(bcx, t)\n }\n \n-pub fn expr_ty(bcx: Block, ex: &ast::Expr) -> Ty {\n+pub fn expr_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     node_id_type(bcx, ex.id)\n }\n \n-pub fn expr_ty_adjusted(bcx: Block, ex: &ast::Expr) -> Ty {\n+pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> Ty<'tcx> {\n     monomorphize_type(bcx, ty::expr_ty_adjusted(bcx.tcx(), ex))\n }\n \n-pub fn fulfill_obligation(ccx: &CrateContext,\n-                          span: Span,\n-                          trait_ref: Rc<ty::TraitRef>)\n-                          -> traits::Vtable<()>\n+pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    span: Span,\n+                                    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                    -> traits::Vtable<'tcx, ()>\n {\n     /*!\n      * Attempts to resolve an obligation. The result is a shallow\n@@ -923,9 +926,9 @@ pub enum ExprOrMethodCall {\n     MethodCall(typeck::MethodCall)\n }\n \n-pub fn node_id_substs(bcx: Block,\n-                      node: ExprOrMethodCall)\n-                      -> subst::Substs\n+pub fn node_id_substs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  node: ExprOrMethodCall)\n+                                  -> subst::Substs<'tcx>\n {\n     let tcx = bcx.tcx();\n "}, {"sha": "fb08b76e3d233db8cbb8ca08b044892c99e72ec9", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -133,14 +133,15 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: Ty)\n+fn const_deref_newtype<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, &*repr, v, 0, 0)\n }\n \n-fn const_deref(cx: &CrateContext, v: ValueRef, t: Ty, explicit: bool)\n-    -> (ValueRef, Ty) {\n+fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n+                         t: Ty<'tcx>, explicit: bool)\n+                         -> (ValueRef, Ty<'tcx>) {\n     match ty::deref(t, explicit) {\n         Some(ref mt) => {\n             match ty::get(t).sty {\n@@ -187,7 +188,8 @@ pub fn get_const_val(cx: &CrateContext,\n     cx.const_values().borrow()[def_id.node].clone()\n }\n \n-pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, Ty) {\n+pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n+                            -> (ValueRef, Ty<'tcx>) {\n     let llconst = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let ety = ty::expr_ty(cx.tcx(), e);\n@@ -725,7 +727,8 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     }\n }\n \n-fn get_static_val(ccx: &CrateContext, did: ast::DefId, ty: Ty) -> ValueRef {\n+fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n+                            ty: Ty<'tcx>) -> ValueRef {\n     if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }\n     base::trans_external_path(ccx, did, ty)\n }"}, {"sha": "4822299d1488614336f4b54eb77cacb52a31d522", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -56,7 +56,7 @@ pub struct Stats {\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'tcx> {\n-    local_ccxs: Vec<LocalCrateContext>,\n+    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n \n     metadata_llmod: ModuleRef,\n     metadata_llcx: ContextRef,\n@@ -70,22 +70,22 @@ pub struct SharedCrateContext<'tcx> {\n     stats: Stats,\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n-    available_drop_glues: RefCell<FnvHashMap<Ty, String>>,\n+    available_drop_glues: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n /// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n /// several compilation units may be optimized in parallel.  All other LLVM\n /// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext {\n+pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     td: TargetData,\n     tn: TypeNames,\n     externs: RefCell<ExternMap>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n-    drop_glues: RefCell<FnvHashMap<Ty, ValueRef>>,\n-    tydescs: RefCell<FnvHashMap<Ty, Rc<tydesc_info>>>,\n+    drop_glues: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n+    tydescs: RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>>,\n     /// Set when running emit_tydescs to enforce that no more tydescs are\n     /// created.\n     finished_tydescs: Cell<bool>,\n@@ -95,10 +95,10 @@ pub struct LocalCrateContext {\n     /// came from)\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n-    monomorphized: RefCell<FnvHashMap<MonoId, ValueRef>>,\n+    monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty, Rc<ty::TraitRef>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -126,19 +126,19 @@ pub struct LocalCrateContext {\n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n-    lltypes: RefCell<FnvHashMap<Ty, Type>>,\n-    llsizingtypes: RefCell<FnvHashMap<Ty, Type>>,\n-    adt_reprs: RefCell<FnvHashMap<Ty, Rc<adt::Repr>>>,\n-    type_hashcodes: RefCell<FnvHashMap<Ty, String>>,\n+    lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n+    llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n+    adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n+    type_hashcodes: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     all_llvm_symbols: RefCell<FnvHashSet<String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n \n     /// Holds the LLVM values for closure IDs.\n-    unboxed_closure_vals: RefCell<FnvHashMap<MonoId, ValueRef>>,\n+    unboxed_closure_vals: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n \n-    dbg_cx: Option<debuginfo::CrateDebugContext>,\n+    dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: RefCell<Option<ValueRef>>,\n \n@@ -149,13 +149,13 @@ pub struct LocalCrateContext {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef>,\n-                                    traits::Vtable<()>>>,\n+    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                    traits::Vtable<'tcx, ()>>>,\n }\n \n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    local: &'a LocalCrateContext,\n+    local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n     index: uint,\n@@ -367,10 +367,10 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     }\n }\n \n-impl LocalCrateContext {\n-    fn new(shared: &SharedCrateContext,\n+impl<'tcx> LocalCrateContext<'tcx> {\n+    fn new(shared: &SharedCrateContext<'tcx>,\n            name: &str)\n-           -> LocalCrateContext {\n+           -> LocalCrateContext<'tcx> {\n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n \n@@ -456,8 +456,8 @@ impl LocalCrateContext {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a, 'tcx>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n-                           -> CrateContext<'a, 'tcx> {\n+    fn dummy_ccx<'a>(&'a self, shared: &'a SharedCrateContext<'tcx>)\n+                     -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n@@ -471,7 +471,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    pub fn local(&self) -> &'b LocalCrateContext {\n+    pub fn local(&self) -> &'b LocalCrateContext<'tcx> {\n         self.local\n     }\n \n@@ -574,11 +574,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.link_meta\n     }\n \n-    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, ValueRef>> {\n+    pub fn drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, ValueRef>> {\n         &self.local.drop_glues\n     }\n \n-    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Rc<tydesc_info>>> {\n+    pub fn tydescs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<tydesc_info<'tcx>>>> {\n         &self.local.tydescs\n     }\n \n@@ -594,15 +594,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.external_srcs\n     }\n \n-    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId, ValueRef>> {\n+    pub fn monomorphized<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>> {\n         &self.local.monomorphized\n     }\n \n     pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty, Rc<ty::TraitRef>), ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>),\n+                                                            ValueRef>> {\n         &self.local.vtables\n     }\n \n@@ -635,23 +636,23 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n-    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Type>> {\n+    pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.lltypes\n     }\n \n-    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Type>> {\n+    pub fn llsizingtypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.llsizingtypes\n     }\n \n-    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, Rc<adt::Repr>>> {\n+    pub fn adt_reprs<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>> {\n         &self.local.adt_reprs\n     }\n \n     pub fn symbol_hasher<'a>(&'a self) -> &'a RefCell<Sha256> {\n         &self.shared.symbol_hasher\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, String>> {\n+    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.local.type_hashcodes\n     }\n \n@@ -667,7 +668,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.shared.available_monomorphizations\n     }\n \n-    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty, String>> {\n+    pub fn available_drop_glues<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, String>> {\n         &self.shared.available_drop_glues\n     }\n \n@@ -679,11 +680,11 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.opaque_vec_type\n     }\n \n-    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId,ValueRef>> {\n+    pub fn unboxed_closure_vals<'a>(&'a self) -> &'a RefCell<FnvHashMap<MonoId<'tcx>,ValueRef>> {\n         &self.local.unboxed_closure_vals\n     }\n \n-    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext> {\n+    pub fn dbg_cx<'a>(&'a self) -> &'a Option<debuginfo::CrateDebugContext<'tcx>> {\n         &self.local.dbg_cx\n     }\n \n@@ -699,15 +700,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef>, traits::Vtable<()>>> {\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                                     traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }\n \n     pub fn max_obj_size(&self) -> u64 {\n         1<<31 /* FIXME #18069: select based on architecture */\n     }\n \n-    pub fn report_overbig_object(&self, obj: Ty) -> ! {\n+    pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n                     obj.repr(self.tcx())).as_slice())"}, {"sha": "b0be310becd1cac00db4aa54efd7387b64bab840", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -38,21 +38,21 @@ use syntax::ast;\n  * the section on datums in `doc.rs` for more details.\n  */\n #[deriving(Clone)]\n-pub struct Datum<K> {\n+pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `kind` below.\n     pub val: ValueRef,\n \n     /// The rust type of the value.\n-    pub ty: Ty,\n+    pub ty: Ty<'tcx>,\n \n     /// Indicates whether this is by-ref or by-value.\n     pub kind: K,\n }\n \n pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub bcx: Block<'blk, 'tcx>,\n-    pub datum: Datum<K>,\n+    pub datum: Datum<'tcx, K>,\n }\n \n #[deriving(Show)]\n@@ -95,20 +95,20 @@ pub enum RvalueMode {\n     ByValue,\n }\n \n-pub fn immediate_rvalue(val: ValueRef, ty: Ty) -> Datum<Rvalue> {\n+pub fn immediate_rvalue<'tcx>(val: ValueRef, ty: Ty<'tcx>) -> Datum<'tcx, Rvalue> {\n     return Datum::new(val, ty, Rvalue::new(ByValue));\n }\n \n pub fn immediate_rvalue_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         val: ValueRef,\n-                                        ty: Ty)\n+                                        ty: Ty<'tcx>)\n                                         -> DatumBlock<'blk, 'tcx, Rvalue> {\n     return DatumBlock::new(bcx, immediate_rvalue(val, ty))\n }\n \n \n pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n-                                           ty: Ty,\n+                                           ty: Ty<'tcx>,\n                                            name: &str,\n                                            zero: bool,\n                                            scope: cleanup::ScopeId,\n@@ -140,10 +140,10 @@ pub fn lvalue_scratch_datum<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n     DatumBlock::new(bcx, Datum::new(scratch, ty, Lvalue))\n }\n \n-pub fn rvalue_scratch_datum(bcx: Block,\n-                            ty: Ty,\n-                            name: &str)\n-                            -> Datum<Rvalue> {\n+pub fn rvalue_scratch_datum<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        name: &str)\n+                                        -> Datum<'tcx, Rvalue> {\n     /*!\n      * Allocates temporary space on the stack using alloca() and\n      * returns a by-ref Datum pointing to it.  If `zero` is true, the\n@@ -159,7 +159,8 @@ pub fn rvalue_scratch_datum(bcx: Block,\n     Datum::new(scratch, ty, Rvalue::new(ByRef))\n }\n \n-pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: Ty) -> RvalueMode {\n+pub fn appropriate_rvalue_mode<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                         ty: Ty<'tcx>) -> RvalueMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -173,11 +174,11 @@ pub fn appropriate_rvalue_mode(ccx: &CrateContext, ty: Ty) -> RvalueMode {\n     }\n }\n \n-fn add_rvalue_clean(mode: RvalueMode,\n-                    fcx: &FunctionContext,\n-                    scope: cleanup::ScopeId,\n-                    val: ValueRef,\n-                    ty: Ty) {\n+fn add_rvalue_clean<'a, 'tcx>(mode: RvalueMode,\n+                              fcx: &FunctionContext<'a, 'tcx>,\n+                              scope: cleanup::ScopeId,\n+                              val: ValueRef,\n+                              ty: Ty<'tcx>) {\n     match mode {\n         ByValue => { fcx.schedule_drop_immediate(scope, val, ty); }\n         ByRef => {\n@@ -196,7 +197,7 @@ pub trait KindOps {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: Ty)\n+                              ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx>;\n \n     /**\n@@ -216,7 +217,7 @@ impl KindOps for Rvalue {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               _val: ValueRef,\n-                              _ty: Ty)\n+                              _ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n         // No cleanup is scheduled for an rvalue, so we don't have\n         // to do anything after a move to cancel or duplicate it.\n@@ -236,7 +237,7 @@ impl KindOps for Lvalue {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: Ty)\n+                              ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n         /*!\n          * If an lvalue is moved, we must zero out the memory in which\n@@ -266,7 +267,7 @@ impl KindOps for Expr {\n     fn post_store<'blk, 'tcx>(&self,\n                               bcx: Block<'blk, 'tcx>,\n                               val: ValueRef,\n-                              ty: Ty)\n+                              ty: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n         match *self {\n             LvalueExpr => Lvalue.post_store(bcx, val, ty),\n@@ -286,11 +287,11 @@ impl KindOps for Expr {\n     }\n }\n \n-impl Datum<Rvalue> {\n-    pub fn add_clean(self,\n-                     fcx: &FunctionContext,\n-                     scope: cleanup::ScopeId)\n-                     -> ValueRef {\n+impl<'tcx> Datum<'tcx, Rvalue> {\n+    pub fn add_clean<'a>(self,\n+                         fcx: &FunctionContext<'a, 'tcx>,\n+                         scope: cleanup::ScopeId)\n+                         -> ValueRef {\n         /*!\n          * Schedules a cleanup for this datum in the given scope.\n          * That means that this datum is no longer an rvalue datum;\n@@ -302,11 +303,11 @@ impl Datum<Rvalue> {\n         self.val\n     }\n \n-    pub fn to_lvalue_datum_in_scope<'blk, 'tcx>(self,\n-                                                bcx: Block<'blk, 'tcx>,\n-                                                name: &str,\n-                                                scope: cleanup::ScopeId)\n-                                                -> DatumBlock<'blk, 'tcx, Lvalue> {\n+    pub fn to_lvalue_datum_in_scope<'blk>(self,\n+                                          bcx: Block<'blk, 'tcx>,\n+                                          name: &str,\n+                                          scope: cleanup::ScopeId)\n+                                          -> DatumBlock<'blk, 'tcx, Lvalue> {\n         /*!\n          * Returns an lvalue datum (that is, a by ref datum with\n          * cleanup scheduled). If `self` is not already an lvalue,\n@@ -328,8 +329,8 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_ref_datum<'blk, 'tcx>(self, bcx: Block<'blk, 'tcx>)\n-                                    -> DatumBlock<'blk, 'tcx, Rvalue> {\n+    pub fn to_ref_datum<'blk>(self, bcx: Block<'blk, 'tcx>)\n+                              -> DatumBlock<'blk, 'tcx, Rvalue> {\n         let mut bcx = bcx;\n         match self.kind.mode {\n             ByRef => DatumBlock::new(bcx, self),\n@@ -341,9 +342,8 @@ impl Datum<Rvalue> {\n         }\n     }\n \n-    pub fn to_appropriate_datum<'blk, 'tcx>(self,\n-                                            bcx: Block<'blk, 'tcx>)\n-                                            -> DatumBlock<'blk, 'tcx, Rvalue> {\n+    pub fn to_appropriate_datum<'blk>(self, bcx: Block<'blk, 'tcx>)\n+                                      -> DatumBlock<'blk, 'tcx, Rvalue> {\n         match self.appropriate_rvalue_mode(bcx.ccx()) {\n             ByRef => {\n                 self.to_ref_datum(bcx)\n@@ -369,10 +369,10 @@ impl Datum<Rvalue> {\n  * here since we can `match self.kind` rather than having to implement\n  * generic methods in `KindOps`.)\n  */\n-impl Datum<Expr> {\n+impl<'tcx> Datum<'tcx, Expr> {\n     fn match_kind<R>(self,\n-                     if_lvalue: |Datum<Lvalue>| -> R,\n-                     if_rvalue: |Datum<Rvalue>| -> R)\n+                     if_lvalue: |Datum<'tcx, Lvalue>| -> R,\n+                     if_rvalue: |Datum<'tcx, Rvalue>| -> R)\n                      -> R {\n         let Datum { val, ty, kind } = self;\n         match kind {\n@@ -382,7 +382,7 @@ impl Datum<Expr> {\n     }\n \n     #[allow(dead_code)] // potentially useful\n-    pub fn assert_lvalue(self, bcx: Block) -> Datum<Lvalue> {\n+    pub fn assert_lvalue(self, bcx: Block) -> Datum<'tcx, Lvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -392,7 +392,7 @@ impl Datum<Expr> {\n             |_| bcx.sess().bug(\"assert_lvalue given rvalue\"))\n     }\n \n-    pub fn assert_rvalue(self, bcx: Block) -> Datum<Rvalue> {\n+    pub fn assert_rvalue(self, bcx: Block) -> Datum<'tcx, Rvalue> {\n         /*!\n          * Asserts that this datum *is* an lvalue and returns it.\n          */\n@@ -402,11 +402,11 @@ impl Datum<Expr> {\n             |r| r)\n     }\n \n-    pub fn store_to_dest<'blk, 'tcx>(self,\n-                                     bcx: Block<'blk, 'tcx>,\n-                                     dest: expr::Dest,\n-                                     expr_id: ast::NodeId)\n-                                     -> Block<'blk, 'tcx> {\n+    pub fn store_to_dest<'blk>(self,\n+                               bcx: Block<'blk, 'tcx>,\n+                               dest: expr::Dest,\n+                               expr_id: ast::NodeId)\n+                               -> Block<'blk, 'tcx> {\n         match dest {\n             expr::Ignore => {\n                 self.add_clean_if_rvalue(bcx, expr_id);\n@@ -418,9 +418,9 @@ impl Datum<Expr> {\n         }\n     }\n \n-    pub fn add_clean_if_rvalue<'blk, 'tcx>(self,\n-                                           bcx: Block<'blk, 'tcx>,\n-                                           expr_id: ast::NodeId) {\n+    pub fn add_clean_if_rvalue<'blk>(self,\n+                                     bcx: Block<'blk, 'tcx>,\n+                                     expr_id: ast::NodeId) {\n         /*!\n          * Arranges cleanup for `self` if it is an rvalue. Use when\n          * you are done working with a value that may need drop.\n@@ -434,11 +434,11 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn clean<'blk, 'tcx>(self,\n-                             bcx: Block<'blk, 'tcx>,\n-                             name: &'static str,\n-                             expr_id: ast::NodeId)\n-                             -> Block<'blk, 'tcx> {\n+    pub fn clean<'blk>(self,\n+                       bcx: Block<'blk, 'tcx>,\n+                       name: &'static str,\n+                       expr_id: ast::NodeId)\n+                       -> Block<'blk, 'tcx> {\n         /*!\n          * Ensures that `self` will get cleaned up, if it is not an lvalue\n          * already.\n@@ -447,11 +447,11 @@ impl Datum<Expr> {\n         self.to_lvalue_datum(bcx, name, expr_id).bcx\n     }\n \n-    pub fn to_lvalue_datum<'blk, 'tcx>(self,\n-                                       bcx: Block<'blk, 'tcx>,\n-                                       name: &str,\n-                                       expr_id: ast::NodeId)\n-                                       -> DatumBlock<'blk, 'tcx, Lvalue> {\n+    pub fn to_lvalue_datum<'blk>(self,\n+                                 bcx: Block<'blk, 'tcx>,\n+                                 name: &str,\n+                                 expr_id: ast::NodeId)\n+                                 -> DatumBlock<'blk, 'tcx, Lvalue> {\n         debug!(\"to_lvalue_datum self: {}\", self.to_string(bcx.ccx()));\n \n         assert!(ty::lltype_is_sized(bcx.tcx(), self.ty),\n@@ -464,10 +464,10 @@ impl Datum<Expr> {\n             })\n     }\n \n-    pub fn to_rvalue_datum<'blk, 'tcx>(self,\n-                                       bcx: Block<'blk, 'tcx>,\n-                                       name: &'static str)\n-                                       -> DatumBlock<'blk, 'tcx, Rvalue> {\n+    pub fn to_rvalue_datum<'blk>(self,\n+                                 bcx: Block<'blk, 'tcx>,\n+                                 name: &'static str)\n+                                 -> DatumBlock<'blk, 'tcx, Rvalue> {\n         /*!\n          * Ensures that we have an rvalue datum (that is, a datum with\n          * no cleanup scheduled).\n@@ -500,7 +500,7 @@ impl Datum<Expr> {\n  * such as extracting the field from a struct or a particular element\n  * from an array.\n  */\n-impl Datum<Lvalue> {\n+impl<'tcx> Datum<'tcx, Lvalue> {\n     pub fn to_llref(self) -> ValueRef {\n         /*!\n          * Converts a datum into a by-ref value. The datum type must\n@@ -515,9 +515,9 @@ impl Datum<Lvalue> {\n     // datum may also be unsized _without the size information_. It is the\n     // callers responsibility to package the result in some way to make a valid\n     // datum in that case (e.g., by making a fat pointer or opened pair).\n-    pub fn get_element(&self, bcx: Block, ty: Ty,\n-                       gep: |ValueRef| -> ValueRef)\n-                       -> Datum<Lvalue> {\n+    pub fn get_element<'blk>(&self, bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>,\n+                             gep: |ValueRef| -> ValueRef)\n+                             -> Datum<'tcx, Lvalue> {\n         let val = match ty::get(self.ty).sty {\n             _ if ty::type_is_sized(bcx.tcx(), self.ty) => gep(self.val),\n             ty::ty_open(_) => {\n@@ -545,20 +545,20 @@ impl Datum<Lvalue> {\n /**\n  * Generic methods applicable to any sort of datum.\n  */\n-impl<K: KindOps + fmt::Show> Datum<K> {\n-    pub fn new(val: ValueRef, ty: Ty, kind: K) -> Datum<K> {\n+impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n+    pub fn new(val: ValueRef, ty: Ty<'tcx>, kind: K) -> Datum<'tcx, K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n \n-    pub fn to_expr_datum(self) -> Datum<Expr> {\n+    pub fn to_expr_datum(self) -> Datum<'tcx, Expr> {\n         let Datum { val, ty, kind } = self;\n         Datum { val: val, ty: ty, kind: kind.to_expr_kind() }\n     }\n \n-    pub fn store_to<'blk, 'tcx>(self,\n-                                bcx: Block<'blk, 'tcx>,\n-                                dst: ValueRef)\n-                                -> Block<'blk, 'tcx> {\n+    pub fn store_to<'blk>(self,\n+                          bcx: Block<'blk, 'tcx>,\n+                          dst: ValueRef)\n+                          -> Block<'blk, 'tcx> {\n         /*!\n          * Moves or copies this value into a new home, as appropriate\n          * depending on the type of the datum. This method consumes\n@@ -572,10 +572,10 @@ impl<K: KindOps + fmt::Show> Datum<K> {\n         self.kind.post_store(bcx, self.val, self.ty)\n     }\n \n-    fn shallow_copy_raw<'blk, 'tcx>(&self,\n-                                    bcx: Block<'blk, 'tcx>,\n-                                    dst: ValueRef)\n-                                    -> Block<'blk, 'tcx> {\n+    fn shallow_copy_raw<'blk>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              dst: ValueRef)\n+                              -> Block<'blk, 'tcx> {\n         /*!\n          * Helper function that performs a shallow copy of this value\n          * into `dst`, which should be a pointer to a memory location\n@@ -604,10 +604,10 @@ impl<K: KindOps + fmt::Show> Datum<K> {\n         return bcx;\n     }\n \n-    pub fn shallow_copy<'blk, 'tcx>(&self,\n-                                    bcx: Block<'blk, 'tcx>,\n-                                    dst: ValueRef)\n-                                    -> Block<'blk, 'tcx> {\n+    pub fn shallow_copy<'blk>(&self,\n+                              bcx: Block<'blk, 'tcx>,\n+                              dst: ValueRef)\n+                              -> Block<'blk, 'tcx> {\n         /*!\n          * Copies the value into a new location. This function always\n          * preserves the existing datum as a valid value. Therefore,\n@@ -620,20 +620,21 @@ impl<K: KindOps + fmt::Show> Datum<K> {\n     }\n \n     #[allow(dead_code)] // useful for debugging\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"Datum({}, {}, {})\",\n                 ccx.tn().val_to_string(self.val),\n                 ty_to_string(ccx.tcx(), self.ty),\n                 self.kind)\n     }\n \n-    pub fn appropriate_rvalue_mode(&self, ccx: &CrateContext) -> RvalueMode {\n+    pub fn appropriate_rvalue_mode<'a>(&self, ccx: &CrateContext<'a, 'tcx>)\n+                                       -> RvalueMode {\n         /*! See the `appropriate_rvalue_mode()` function */\n \n         appropriate_rvalue_mode(ccx, self.ty)\n     }\n \n-    pub fn to_llscalarish(self, bcx: Block) -> ValueRef {\n+    pub fn to_llscalarish<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n         /*!\n          * Converts `self` into a by-value `ValueRef`. Consumes this\n          * datum (i.e., absolves you of responsibility to cleanup the\n@@ -652,14 +653,15 @@ impl<K: KindOps + fmt::Show> Datum<K> {\n         }\n     }\n \n-    pub fn to_llbool(self, bcx: Block) -> ValueRef {\n+    pub fn to_llbool<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n         assert!(ty::type_is_bool(self.ty))\n         self.to_llscalarish(bcx)\n     }\n }\n \n impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n-    pub fn new(bcx: Block<'blk, 'tcx>, datum: Datum<K>) -> DatumBlock<'blk, 'tcx, K> {\n+    pub fn new(bcx: Block<'blk, 'tcx>, datum: Datum<'tcx, K>)\n+               -> DatumBlock<'blk, 'tcx, K> {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n }"}, {"sha": "480ac0b339f6993fe73f4ead6bf1f800cdbc0d35", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 179, "deletions": 172, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -260,20 +260,20 @@ struct UniqueTypeId(ast::Name);\n // created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n // faster lookup, also by Ty. The TypeMap is responsible for creating\n // UniqueTypeIds.\n-struct TypeMap {\n+struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner<Rc<String>>,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n-    type_to_metadata: FnvHashMap<Ty, DIType>,\n+    type_to_metadata: FnvHashMap<Ty<'tcx>, DIType>,\n     // A map from types to UniqueTypeId. This is a N:1 mapping.\n-    type_to_unique_id: FnvHashMap<Ty, UniqueTypeId>\n+    type_to_unique_id: FnvHashMap<Ty<'tcx>, UniqueTypeId>\n }\n \n-impl TypeMap {\n+impl<'tcx> TypeMap<'tcx> {\n \n-    fn new() -> TypeMap {\n+    fn new() -> TypeMap<'tcx> {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n             type_to_metadata: FnvHashMap::new(),\n@@ -284,10 +284,10 @@ impl TypeMap {\n \n     // Adds a Ty to metadata mapping to the TypeMap. The method will fail if\n     // the mapping already exists.\n-    fn register_type_with_metadata(&mut self,\n-                                   cx: &CrateContext,\n-                                   type_: Ty,\n-                                   metadata: DIType) {\n+    fn register_type_with_metadata<'a>(&mut self,\n+                                       cx: &CrateContext<'a, 'tcx>,\n+                                       type_: Ty<'tcx>,\n+                                       metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n                                    ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n@@ -307,7 +307,7 @@ impl TypeMap {\n         }\n     }\n \n-    fn find_metadata_for_type(&self, type_: Ty) -> Option<DIType> {\n+    fn find_metadata_for_type(&self, type_: Ty<'tcx>) -> Option<DIType> {\n         self.type_to_metadata.get(&type_).cloned()\n     }\n \n@@ -325,7 +325,8 @@ impl TypeMap {\n     // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n     // type has been requested before, this is just a table lookup. Otherwise an\n     // ID will be generated and stored for later lookup.\n-    fn get_unique_type_id_of_type(&mut self, cx: &CrateContext, type_: Ty) -> UniqueTypeId {\n+    fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n+                                      type_: Ty<'tcx>) -> UniqueTypeId {\n \n         // basic type           -> {:name of the type:}\n         // tuple                -> {tuple_(:param-uid:)*}\n@@ -498,11 +499,11 @@ impl TypeMap {\n \n         return UniqueTypeId(key);\n \n-        fn from_def_id_and_substs(type_map: &mut TypeMap,\n-                                  cx: &CrateContext,\n-                                  def_id: ast::DefId,\n-                                  substs: &subst::Substs,\n-                                  output: &mut String) {\n+        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n+                                            cx: &CrateContext<'a, 'tcx>,\n+                                            def_id: ast::DefId,\n+                                            substs: &subst::Substs<'tcx>,\n+                                            output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n@@ -549,10 +550,10 @@ impl TypeMap {\n         }\n     }\n \n-    fn get_unique_type_id_of_closure_type(&mut self,\n-                                          cx: &CrateContext,\n-                                          closure_ty: ty::ClosureTy,\n-                                          unique_type_id: &mut String) {\n+    fn get_unique_type_id_of_closure_type<'a>(&mut self,\n+                                              cx: &CrateContext<'a, 'tcx>,\n+                                              closure_ty: ty::ClosureTy<'tcx>,\n+                                              unique_type_id: &mut String) {\n         let ty::ClosureTy { fn_style,\n                             onceness,\n                             store,\n@@ -619,11 +620,11 @@ impl TypeMap {\n     // Get the UniqueTypeId for an enum variant. Enum variants are not really\n     // types of their own, so they need special handling. We still need a\n     // UniqueTypeId for them, since to debuginfo they *are* real types.\n-    fn get_unique_type_id_of_enum_variant(&mut self,\n-                                          cx: &CrateContext,\n-                                          enum_type: Ty,\n-                                          variant_name: &str)\n-                                       -> UniqueTypeId {\n+    fn get_unique_type_id_of_enum_variant<'a>(&mut self,\n+                                              cx: &CrateContext<'a, 'tcx>,\n+                                              enum_type: Ty<'tcx>,\n+                                              variant_name: &str)\n+                                              -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            self.get_unique_type_id_as_string(enum_type_id)\n@@ -649,23 +650,23 @@ macro_rules! return_if_metadata_created_in_meantime(\n \n \n /// A context object for maintaining all state needed by the debuginfo module.\n-pub struct CrateDebugContext {\n+pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n     current_debug_location: Cell<DebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n     created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n \n-    type_map: RefCell<TypeMap>,\n+    type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<FnvHashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n \n     // This collection is used to assert that composite types (structs, enums,\n     // ...) have their members only set once:\n     composite_types_completed: RefCell<FnvHashSet<DIType>>,\n }\n \n-impl CrateDebugContext {\n-    pub fn new(llmod: ModuleRef) -> CrateDebugContext {\n+impl<'tcx> CrateDebugContext<'tcx> {\n+    pub fn new(llmod: ModuleRef) -> CrateDebugContext<'tcx> {\n         debug!(\"CrateDebugContext::new\");\n         let builder = unsafe { llvm::LLVMDIBuilderCreate(llmod) };\n         // DIBuilder inherits context from the module, so we'd better use the same one\n@@ -884,13 +885,13 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n /// Creates debug information for a variable captured in a closure.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_captured_var_metadata(bcx: Block,\n-                                    node_id: ast::NodeId,\n-                                    env_data_type: Ty,\n-                                    env_pointer: ValueRef,\n-                                    env_index: uint,\n-                                    closure_store: ty::TraitStore,\n-                                    span: Span) {\n+pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                node_id: ast::NodeId,\n+                                                env_data_type: Ty<'tcx>,\n+                                                env_pointer: ValueRef,\n+                                                env_index: uint,\n+                                                closure_store: ty::TraitStore,\n+                                                span: Span) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -971,9 +972,9 @@ pub fn create_captured_var_metadata(bcx: Block,\n /// match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_match_binding_metadata(bcx: Block,\n-                                     variable_ident: ast::Ident,\n-                                     binding: BindingInfo) {\n+pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                                 variable_ident: ast::Ident,\n+                                                 binding: BindingInfo<'tcx>) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -1168,10 +1169,10 @@ pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n /// for debug info creation. The function may also return another variant of the\n /// FunctionDebugContext enum which indicates why no debuginfo should be created\n /// for the function.\n-pub fn create_function_debug_context(cx: &CrateContext,\n-                                     fn_ast_id: ast::NodeId,\n-                                     param_substs: &param_substs,\n-                                     llfn: ValueRef) -> FunctionDebugContext {\n+pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                               fn_ast_id: ast::NodeId,\n+                                               param_substs: &param_substs<'tcx>,\n+                                               llfn: ValueRef) -> FunctionDebugContext {\n     if cx.sess().opts.debuginfo == NoDebugInfo {\n         return FunctionDebugContext { repr: DebugInfoDisabled };\n     }\n@@ -1369,11 +1370,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n \n-    fn get_function_signature(cx: &CrateContext,\n-                              fn_ast_id: ast::NodeId,\n-                              fn_decl: &ast::FnDecl,\n-                              param_substs: &param_substs,\n-                              error_reporting_span: Span) -> DIArray {\n+    fn get_function_signature<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                        fn_ast_id: ast::NodeId,\n+                                        fn_decl: &ast::FnDecl,\n+                                        param_substs: &param_substs<'tcx>,\n+                                        error_reporting_span: Span) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), &[]);\n         }\n@@ -1404,12 +1405,12 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return create_DIArray(DIB(cx), signature.as_slice());\n     }\n \n-    fn get_template_parameters(cx: &CrateContext,\n-                               generics: &ast::Generics,\n-                               param_substs: &param_substs,\n-                               file_metadata: DIFile,\n-                               name_to_append_suffix_to: &mut String)\n-                               -> DIArray {\n+    fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         generics: &ast::Generics,\n+                                         param_substs: &param_substs<'tcx>,\n+                                         file_metadata: DIFile,\n+                                         name_to_append_suffix_to: &mut String)\n+                                         -> DIArray {\n         let self_type = param_substs.substs().self_ty();\n \n         // Only true for static default methods:\n@@ -1590,13 +1591,13 @@ fn compile_unit_metadata(cx: &CrateContext) {\n     }\n }\n \n-fn declare_local(bcx: Block,\n-                 variable_ident: ast::Ident,\n-                 variable_type: Ty,\n-                 scope_metadata: DIScope,\n-                 variable_access: VariableAccess,\n-                 variable_kind: VariableKind,\n-                 span: Span) {\n+fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             variable_ident: ast::Ident,\n+                             variable_type: Ty<'tcx>,\n+                             scope_metadata: DIScope,\n+                             variable_access: VariableAccess,\n+                             variable_kind: VariableKind,\n+                             span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n@@ -1739,7 +1740,8 @@ fn diverging_type_metadata(cx: &CrateContext) -> DIType {\n     })\n }\n \n-fn basic_type_metadata(cx: &CrateContext, t: Ty) -> DIType {\n+fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                 t: Ty<'tcx>) -> DIType {\n \n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n@@ -1785,10 +1787,10 @@ fn basic_type_metadata(cx: &CrateContext, t: Ty) -> DIType {\n     return ty_metadata;\n }\n \n-fn pointer_type_metadata(cx: &CrateContext,\n-                         pointer_type: Ty,\n-                         pointee_type_metadata: DIType)\n-                      -> DIType {\n+fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   pointer_type: Ty<'tcx>,\n+                                   pointee_type_metadata: DIType)\n+                                   -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n@@ -1829,15 +1831,16 @@ struct MemberDescription {\n // for some record-like type. MemberDescriptionFactories are used to defer the\n // creation of type member descriptions in order to break cycles arising from\n // recursive type definitions.\n-enum MemberDescriptionFactory {\n-    StructMDF(StructMemberDescriptionFactory),\n-    TupleMDF(TupleMemberDescriptionFactory),\n-    EnumMDF(EnumMemberDescriptionFactory),\n-    VariantMDF(VariantMemberDescriptionFactory)\n+enum MemberDescriptionFactory<'tcx> {\n+    StructMDF(StructMemberDescriptionFactory<'tcx>),\n+    TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n+    EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n }\n \n-impl MemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n+impl<'tcx> MemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n         match *self {\n             StructMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n@@ -1859,25 +1862,25 @@ impl MemberDescriptionFactory {\n // with FinalMetadata) or it is not yet finished, but contains all information\n // needed to generate the missing parts of the description. See the documentation\n // section on Recursive Types at the top of this file for more information.\n-enum RecursiveTypeDescription {\n+enum RecursiveTypeDescription<'tcx> {\n     UnfinishedMetadata {\n-        unfinished_type: Ty,\n+        unfinished_type: Ty<'tcx>,\n         unique_type_id: UniqueTypeId,\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n-        member_description_factory: MemberDescriptionFactory,\n+        member_description_factory: MemberDescriptionFactory<'tcx>,\n     },\n     FinalMetadata(DICompositeType)\n }\n \n-fn create_and_register_recursive_type_forward_declaration(\n-    cx: &CrateContext,\n-    unfinished_type: Ty,\n+fn create_and_register_recursive_type_forward_declaration<'a, 'tcx>(\n+    cx: &CrateContext<'a, 'tcx>,\n+    unfinished_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n     metadata_stub: DICompositeType,\n     llvm_type: Type,\n-    member_description_factory: MemberDescriptionFactory)\n- -> RecursiveTypeDescription {\n+    member_description_factory: MemberDescriptionFactory<'tcx>)\n+ -> RecursiveTypeDescription<'tcx> {\n \n     // Insert the stub into the TypeMap in order to allow for recursive references\n     let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -1893,10 +1896,10 @@ fn create_and_register_recursive_type_forward_declaration(\n     }\n }\n \n-impl RecursiveTypeDescription {\n+impl<'tcx> RecursiveTypeDescription<'tcx> {\n     // Finishes up the description of the type in question (mostly by providing\n     // descriptions of the fields of the given type) and returns the final type metadata.\n-    fn finalize(&self, cx: &CrateContext) -> MetadataCreationResult {\n+    fn finalize<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> MetadataCreationResult {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n             UnfinishedMetadata {\n@@ -1944,14 +1947,15 @@ impl RecursiveTypeDescription {\n //=-----------------------------------------------------------------------------\n \n // Creates MemberDescriptions for the fields of a struct\n-struct StructMemberDescriptionFactory {\n-    fields: Vec<ty::field>,\n+struct StructMemberDescriptionFactory<'tcx> {\n+    fields: Vec<ty::field<'tcx>>,\n     is_simd: bool,\n     span: Span,\n }\n \n-impl StructMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n+impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n         if self.fields.len() == 0 {\n             return Vec::new();\n         }\n@@ -1988,13 +1992,13 @@ impl StructMemberDescriptionFactory {\n }\n \n \n-fn prepare_struct_metadata(cx: &CrateContext,\n-                           struct_type: Ty,\n-                           def_id: ast::DefId,\n-                           substs: &subst::Substs,\n-                           unique_type_id: UniqueTypeId,\n-                           span: Span)\n-                        -> RecursiveTypeDescription {\n+fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                     struct_type: Ty<'tcx>,\n+                                     def_id: ast::DefId,\n+                                     substs: &subst::Substs<'tcx>,\n+                                     unique_type_id: UniqueTypeId,\n+                                     span: Span)\n+                                     -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n@@ -2028,14 +2032,14 @@ fn prepare_struct_metadata(cx: &CrateContext,\n //=-----------------------------------------------------------------------------\n \n // Creates MemberDescriptions for the fields of a tuple\n-struct TupleMemberDescriptionFactory {\n-    component_types: Vec<Ty> ,\n+struct TupleMemberDescriptionFactory<'tcx> {\n+    component_types: Vec<Ty<'tcx>>,\n     span: Span,\n }\n \n-impl TupleMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> Vec<MemberDescription> {\n+impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n         self.component_types.iter().map(|&component_type| {\n             MemberDescription {\n                 name: \"\".to_string(),\n@@ -2048,12 +2052,12 @@ impl TupleMemberDescriptionFactory {\n     }\n }\n \n-fn prepare_tuple_metadata(cx: &CrateContext,\n-                          tuple_type: Ty,\n-                          component_types: &[Ty],\n-                          unique_type_id: UniqueTypeId,\n-                          span: Span)\n-                       -> RecursiveTypeDescription {\n+fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    tuple_type: Ty<'tcx>,\n+                                    component_types: &[Ty<'tcx>],\n+                                    unique_type_id: UniqueTypeId,\n+                                    span: Span)\n+                                    -> RecursiveTypeDescription<'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx, tuple_type, false);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n@@ -2084,18 +2088,19 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n // the members of this union; so for every variant of the given enum, this factory\n // will produce one MemberDescription (all with no name and a fixed offset of\n // zero bytes).\n-struct EnumMemberDescriptionFactory {\n-    enum_type: Ty,\n-    type_rep: Rc<adt::Repr>,\n-    variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n+struct EnumMemberDescriptionFactory<'tcx> {\n+    enum_type: Ty<'tcx>,\n+    type_rep: Rc<adt::Repr<'tcx>>,\n+    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n     span: Span,\n }\n \n-impl EnumMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n+impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n         match *self.type_rep {\n             adt::General(_, ref struct_defs, _) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n@@ -2286,14 +2291,15 @@ impl EnumMemberDescriptionFactory {\n }\n \n // Creates MemberDescriptions for the fields of a single enum variant.\n-struct VariantMemberDescriptionFactory {\n-    args: Vec<(String, Ty)> ,\n+struct VariantMemberDescriptionFactory<'tcx> {\n+    args: Vec<(String, Ty<'tcx>)>,\n     discriminant_type_metadata: Option<DIType>,\n     span: Span,\n }\n \n-impl VariantMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &CrateContext) -> Vec<MemberDescription> {\n+impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n             MemberDescription {\n                 name: name.to_string(),\n@@ -2319,14 +2325,14 @@ enum EnumDiscriminantInfo {\n // of the variant, and (3) a MemberDescriptionFactory for producing the\n // descriptions of the fields of the variant. This is a rudimentary version of a\n // full RecursiveTypeDescription.\n-fn describe_enum_variant(cx: &CrateContext,\n-                         enum_type: Ty,\n-                         struct_def: &adt::Struct,\n-                         variant_info: &ty::VariantInfo,\n-                         discriminant_info: EnumDiscriminantInfo,\n-                         containing_scope: DIScope,\n-                         span: Span)\n-                      -> (DICompositeType, Type, MemberDescriptionFactory) {\n+fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   enum_type: Ty<'tcx>,\n+                                   struct_def: &adt::Struct<'tcx>,\n+                                   variant_info: &ty::VariantInfo<'tcx>,\n+                                   discriminant_info: EnumDiscriminantInfo,\n+                                   containing_scope: DIScope,\n+                                   span: Span)\n+                                   -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n     let variant_llvm_type =\n         Type::struct_(cx, struct_def.fields\n                                     .iter()\n@@ -2389,12 +2395,12 @@ fn describe_enum_variant(cx: &CrateContext,\n     (metadata_stub, variant_llvm_type, member_description_factory)\n }\n \n-fn prepare_enum_metadata(cx: &CrateContext,\n-                         enum_type: Ty,\n-                         enum_def_id: ast::DefId,\n-                         unique_type_id: UniqueTypeId,\n-                         span: Span)\n-                      -> RecursiveTypeDescription {\n+fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   enum_type: Ty<'tcx>,\n+                                   enum_def_id: ast::DefId,\n+                                   unique_type_id: UniqueTypeId,\n+                                   span: Span)\n+                                   -> RecursiveTypeDescription<'tcx> {\n     let enum_name = compute_debuginfo_type_name(cx, enum_type, false);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n@@ -2675,12 +2681,12 @@ fn create_struct_stub(cx: &CrateContext,\n     return metadata_stub;\n }\n \n-fn fixed_vec_metadata(cx: &CrateContext,\n-                      unique_type_id: UniqueTypeId,\n-                      element_type: Ty,\n-                      len: uint,\n-                      span: Span)\n-                   -> MetadataCreationResult {\n+fn fixed_vec_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                unique_type_id: UniqueTypeId,\n+                                element_type: Ty<'tcx>,\n+                                len: uint,\n+                                span: Span)\n+                                -> MetadataCreationResult {\n     let element_type_metadata = type_metadata(cx, element_type, span);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n@@ -2708,12 +2714,12 @@ fn fixed_vec_metadata(cx: &CrateContext,\n     return MetadataCreationResult::new(metadata, false);\n }\n \n-fn vec_slice_metadata(cx: &CrateContext,\n-                      vec_type: Ty,\n-                      element_type: Ty,\n-                      unique_type_id: UniqueTypeId,\n-                      span: Span)\n-                   -> MetadataCreationResult {\n+fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                vec_type: Ty<'tcx>,\n+                                element_type: Ty<'tcx>,\n+                                unique_type_id: UniqueTypeId,\n+                                span: Span)\n+                                -> MetadataCreationResult {\n     let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n         ty: element_type,\n         mutbl: ast::MutImmutable\n@@ -2762,21 +2768,21 @@ fn vec_slice_metadata(cx: &CrateContext,\n                                            span);\n     return MetadataCreationResult::new(metadata, false);\n \n-    fn slice_layout_is_correct(cx: &CrateContext,\n-                               member_llvm_types: &[Type],\n-                               element_type: Ty)\n-                            -> bool {\n+    fn slice_layout_is_correct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         member_llvm_types: &[Type],\n+                                         element_type: Ty<'tcx>)\n+                                         -> bool {\n         member_llvm_types.len() == 2 &&\n         member_llvm_types[0] == type_of::type_of(cx, element_type).ptr_to() &&\n         member_llvm_types[1] == cx.int_type()\n     }\n }\n \n-fn subroutine_type_metadata(cx: &CrateContext,\n-                            unique_type_id: UniqueTypeId,\n-                            signature: &ty::FnSig,\n-                            span: Span)\n-                         -> MetadataCreationResult {\n+fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                      unique_type_id: UniqueTypeId,\n+                                      signature: &ty::FnSig<'tcx>,\n+                                      span: Span)\n+                                      -> MetadataCreationResult {\n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n@@ -2811,11 +2817,11 @@ fn subroutine_type_metadata(cx: &CrateContext,\n // trait_type should be the actual trait (e.g., Trait). Where the trait is part\n // of a DST struct, there is no trait_object_type and the results of this\n // function will be a little bit weird.\n-fn trait_pointer_metadata(cx: &CrateContext,\n-                          trait_type: Ty,\n-                          trait_object_type: Option<Ty>,\n-                          unique_type_id: UniqueTypeId)\n-                       -> DIType {\n+fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    trait_type: Ty<'tcx>,\n+                                    trait_object_type: Option<Ty<'tcx>>,\n+                                    unique_type_id: UniqueTypeId)\n+                                    -> DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n     // But it does not describe the trait's methods.\n@@ -2848,10 +2854,10 @@ fn trait_pointer_metadata(cx: &CrateContext,\n                             codemap::DUMMY_SP)\n }\n \n-fn type_metadata(cx: &CrateContext,\n-                 t: Ty,\n-                 usage_site_span: Span)\n-              -> DIType {\n+fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                           t: Ty<'tcx>,\n+                           usage_site_span: Span)\n+                           -> DIType {\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -3111,8 +3117,9 @@ fn bytes_to_bits(bytes: u64) -> u64 {\n }\n \n #[inline]\n-fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx().as_ref().unwrap();\n+fn debug_context<'a, 'tcx>(cx: &'a CrateContext<'a, 'tcx>)\n+                           -> &'a CrateDebugContext<'tcx> {\n+    let debug_context: &'a CrateDebugContext<'tcx> = cx.dbg_cx().as_ref().unwrap();\n     debug_context\n }\n \n@@ -3666,21 +3673,21 @@ fn populate_scope_map(cx: &CrateContext,\n // any caching, i.e. calling the function twice with the same type will also do\n // the work twice. The `qualified` parameter only affects the first level of the\n // type name, further levels (i.e. type parameters) are always fully qualified.\n-fn compute_debuginfo_type_name(cx: &CrateContext,\n-                               t: Ty,\n-                               qualified: bool)\n-                            -> String {\n+fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                         t: Ty<'tcx>,\n+                                         qualified: bool)\n+                                         -> String {\n     let mut result = String::with_capacity(64);\n     push_debuginfo_type_name(cx, t, qualified, &mut result);\n     result\n }\n \n // Pushes the name of the type as it should be stored in debuginfo on the\n // `output` String. See also compute_debuginfo_type_name().\n-fn push_debuginfo_type_name(cx: &CrateContext,\n-                            t: Ty,\n-                            qualified: bool,\n-                            output: &mut String) {\n+fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                      t: Ty<'tcx>,\n+                                      qualified: bool,\n+                                      output: &mut String) {\n     match ty::get(t).sty {\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n@@ -3907,9 +3914,9 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n     // reconstructed for items from non-local crates. For local crates, this\n     // would be possible but with inlining and LTO we have to use the least\n     // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params(cx: &CrateContext,\n-                        substs: &subst::Substs,\n-                        output: &mut String) {\n+    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                  substs: &subst::Substs<'tcx>,\n+                                  output: &mut String) {\n         if substs.types.is_empty() {\n             return;\n         }"}, {"sha": "214acaf48b67a126eaf9651d615186ed970f88bb", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -179,7 +179,7 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n \n fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  expr: &ast::Expr,\n-                                 datum: Datum<Expr>)\n+                                 datum: Datum<'tcx, Expr>)\n                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     /*!\n      * Helper for trans that apply adjustments from `expr` to `datum`,\n@@ -253,10 +253,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"after adjustments, datum={}\", datum.to_string(bcx.ccx()));\n     return DatumBlock::new(bcx, datum);\n \n-    fn apply_autoref<'blk, 'tcx>(autoref: &ty::AutoRef,\n+    fn apply_autoref<'blk, 'tcx>(autoref: &ty::AutoRef<'tcx>,\n                                  bcx: Block<'blk, 'tcx>,\n                                  expr: &ast::Expr,\n-                                 datum: Datum<Expr>)\n+                                 datum: Datum<'tcx, Expr>)\n                                  -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let mut datum = datum;\n@@ -291,7 +291,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn ref_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            expr: &ast::Expr,\n-                           datum: Datum<Expr>)\n+                           datum: Datum<'tcx, Expr>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n         if !ty::type_is_sized(bcx.tcx(), datum.ty) {\n             debug!(\"Taking address of unsized type {}\",\n@@ -312,10 +312,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n     fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                kind: &ty::UnsizeKind,\n+                                kind: &ty::UnsizeKind<'tcx>,\n                                 id: ast::NodeId,\n-                                unsized_ty: Ty,\n-                                mk_ty: |Ty| -> Ty) -> ValueRef {\n+                                unsized_ty: Ty<'tcx>,\n+                                mk_ty: |Ty<'tcx>| -> Ty<'tcx>) -> ValueRef {\n         match kind {\n             &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n             &ty::UnsizeStruct(box ref k, tp_index) => match ty::get(unsized_ty).sty {\n@@ -345,8 +345,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n-                               datum: Datum<Expr>,\n-                               k: &ty::UnsizeKind)\n+                               datum: Datum<'tcx, Expr>,\n+                               k: &ty::UnsizeKind<'tcx>)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let datum_ty = datum.ty;\n@@ -379,7 +379,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n-                               datum: Datum<Expr>)\n+                               datum: Datum<'tcx, Expr>)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n         let tcx = bcx.tcx();\n         let dest_ty = ty::close_type(tcx, datum.ty);\n@@ -390,8 +390,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn into_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 expr: &ast::Expr,\n-                                datum: Datum<Expr>,\n-                                dest_ty: Ty,\n+                                datum: Datum<'tcx, Expr>,\n+                                dest_ty: Ty<'tcx>,\n                                 base: |Block<'blk, 'tcx>, ValueRef| -> ValueRef,\n                                 info: |Block<'blk, 'tcx>, ValueRef| -> ValueRef)\n                                 -> DatumBlock<'blk, 'tcx, Expr> {\n@@ -412,7 +412,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      expr: &ast::Expr,\n-                                     datum: Datum<Expr>,\n+                                     datum: Datum<'tcx, Expr>,\n                                      len: uint)\n                                      -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n@@ -440,8 +440,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn unsize_unique_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       expr: &ast::Expr,\n-                                      datum: Datum<Expr>,\n-                                      k: &ty::UnsizeKind)\n+                                      datum: Datum<'tcx, Expr>,\n+                                      k: &ty::UnsizeKind<'tcx>)\n                                       -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n@@ -475,7 +475,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn add_env<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            expr: &ast::Expr,\n-                           datum: Datum<Expr>)\n+                           datum: Datum<'tcx, Expr>)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n         // This is not the most efficient thing possible; since closures\n         // are two words it'd be better if this were compiled in\n@@ -566,7 +566,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: Ty)\n+    fn nil<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ty: Ty<'tcx>)\n                        -> DatumBlock<'blk, 'tcx, Expr> {\n         let llval = C_undef(type_of::type_of(bcx.ccx(), ty));\n         let datum = immediate_rvalue(llval, ty);\n@@ -678,7 +678,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn trans_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            base: &ast::Expr,\n-                           get_idx: |&'blk ty::ctxt<'tcx>, &[ty::field]| -> uint)\n+                           get_idx: |&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]| -> uint)\n                            -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -858,7 +858,7 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n-                                   const_ty: Ty) -> ValueRef {\n+                                   const_ty: Ty<'tcx>) -> ValueRef {\n                 // For external constants, we don't inline.\n                 if did.krate == ast::LOCAL_CRATE {\n                     // Case 1.\n@@ -1224,7 +1224,7 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    def: def::Def)\n-                                   -> Datum<Lvalue> {\n+                                   -> Datum<'tcx, Lvalue> {\n     /*!\n      * Translates a reference to a local variable or argument.\n      * This always results in an lvalue datum.\n@@ -1266,11 +1266,11 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn with_field_tys<R>(tcx: &ty::ctxt,\n-                         ty: Ty,\n-                         node_id_opt: Option<ast::NodeId>,\n-                         op: |ty::Disr, (&[ty::field])| -> R)\n-                         -> R {\n+pub fn with_field_tys<'tcx, R>(tcx: &ty::ctxt<'tcx>,\n+                               ty: Ty<'tcx>,\n+                               node_id_opt: Option<ast::NodeId>,\n+                               op: |ty::Disr, (&[ty::field<'tcx>])| -> R)\n+                               -> R {\n     /*!\n      * Helper for enumerating the field types of structs, enums, or records.\n      * The optional node ID here is the node ID of the path identifying the enum\n@@ -1389,11 +1389,11 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n  * Note that `fields` may be empty; the base expression must always be\n  * evaluated for side-effects.\n  */\n-pub struct StructBaseInfo<'a> {\n+pub struct StructBaseInfo<'a, 'tcx> {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, Ty)>\n+    fields: Vec<(uint, Ty<'tcx>)>\n }\n \n /**\n@@ -1406,14 +1406,14 @@ pub struct StructBaseInfo<'a> {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             ty: Ty,\n-                             discr: ty::Disr,\n-                             fields: &[(uint, &ast::Expr)],\n-                             optbase: Option<StructBaseInfo>,\n-                             dest: Dest,\n-                             source_location: Option<NodeInfo>)\n-                          -> Block<'blk, 'tcx> {\n+pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 discr: ty::Disr,\n+                                 fields: &[(uint, &ast::Expr)],\n+                                 optbase: Option<StructBaseInfo<'a, 'tcx>>,\n+                                 dest: Dest,\n+                                 source_location: Option<NodeInfo>)\n+                                 -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n@@ -1572,9 +1572,9 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               box_ty: Ty,\n+                               box_ty: Ty<'tcx>,\n                                contents: &ast::Expr,\n-                               contents_ty: Ty)\n+                               contents_ty: Ty<'tcx>)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_uniq_expr\");\n     let fcx = bcx.fcx;\n@@ -1635,11 +1635,11 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // and the other not.\n fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  binop_expr: &ast::Expr,\n-                                 binop_ty: Ty,\n+                                 binop_ty: Ty<'tcx>,\n                                  op: ast::BinOp,\n-                                 lhs_t: Ty,\n+                                 lhs_t: Ty<'tcx>,\n                                  lhs: ValueRef,\n-                                 rhs_t: Ty,\n+                                 rhs_t: Ty<'tcx>,\n                                  rhs: ValueRef)\n                                  -> DatumBlock<'blk, 'tcx, Expr> {\n     let _icx = push_ctxt(\"trans_eager_binop\");\n@@ -1813,8 +1813,8 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n                                    method_call: MethodCall,\n-                                   lhs: Datum<Expr>,\n-                                   rhs: Vec<(Datum<Expr>, ast::NodeId)>,\n+                                   lhs: Datum<'tcx, Expr>,\n+                                   rhs: Vec<(Datum<'tcx, Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>)\n                                    -> Result<'blk, 'tcx> {\n     let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n@@ -1907,7 +1907,7 @@ pub enum cast_kind {\n     cast_other,\n }\n \n-pub fn cast_type_kind(tcx: &ty::ctxt, t: Ty) -> cast_kind {\n+pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n@@ -1927,7 +1927,7 @@ pub fn cast_type_kind(tcx: &ty::ctxt, t: Ty) -> cast_kind {\n     }\n }\n \n-fn cast_is_noop(t_in: Ty, t_out: Ty) -> bool {\n+fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n@@ -2061,7 +2061,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                        datum: Datum<Expr>,\n+                        datum: Datum<'tcx, Expr>,\n                         expr: &ast::Expr)\n                         -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n@@ -2086,7 +2086,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n-                              datum: Datum<Expr>,\n+                              datum: Datum<'tcx, Expr>,\n                               times: uint)\n                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n@@ -2100,7 +2100,7 @@ fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           expr: &ast::Expr,\n-                          datum: Datum<Expr>,\n+                          datum: Datum<'tcx, Expr>,\n                           method_call: MethodCall)\n                           -> DatumBlock<'blk, 'tcx, Expr> {\n     let ccx = bcx.ccx();\n@@ -2195,8 +2195,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     fn deref_owned_pointer<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        expr: &ast::Expr,\n-                                       datum: Datum<Expr>,\n-                                       content_ty: Ty)\n+                                       datum: Datum<'tcx, Expr>,\n+                                       content_ty: Ty<'tcx>)\n                                        -> DatumBlock<'blk, 'tcx, Expr> {\n         /*!\n          * We microoptimize derefs of owned pointers a bit here."}, {"sha": "c743f61cba5f76d66c67613ac305007854d9027c", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -39,9 +39,9 @@ use util::ppaux::Repr;\n ///////////////////////////////////////////////////////////////////////////\n // Type definitions\n \n-struct ForeignTypes {\n+struct ForeignTypes<'tcx> {\n     /// Rust signature of the function\n-    fn_sig: ty::FnSig,\n+    fn_sig: ty::FnSig<'tcx>,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know)\n@@ -161,8 +161,9 @@ pub fn register_static(ccx: &CrateContext,\n     }\n }\n \n-pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: Ty,\n-                                name: &str) -> ValueRef {\n+pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                          abi: Abi, fty: Ty<'tcx>,\n+                                          name: &str) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n@@ -201,11 +202,11 @@ pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi, fty: Ty,\n }\n \n pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     callee_ty: Ty,\n+                                     callee_ty: Ty<'tcx>,\n                                      llfn: ValueRef,\n                                      llretptr: ValueRef,\n                                      llargs_rust: &[ValueRef],\n-                                     passed_arg_tys: Vec<Ty> )\n+                                     passed_arg_tys: Vec<Ty<'tcx>>)\n                                      -> Block<'blk, 'tcx> {\n     /*!\n      * Prepares a call to a native function. This requires adapting\n@@ -483,10 +484,10 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n // inline the one into the other. Of course we could just generate the\n // correct code in the first place, but this is much simpler.\n \n-pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n-                                     t: Ty,\n-                                     name: &str)\n-                                     -> ValueRef {\n+pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               t: Ty<'tcx>,\n+                                               name: &str)\n+                                               -> ValueRef {\n     let tys = foreign_types_for_fn_ty(ccx, t);\n     let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n     let cconv = match ty::get(t).sty {\n@@ -525,14 +526,14 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     llfn\n }\n \n-pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n-                                      decl: &ast::FnDecl,\n-                                      body: &ast::Block,\n-                                      attrs: &[ast::Attribute],\n-                                      llwrapfn: ValueRef,\n-                                      param_substs: &param_substs,\n-                                      id: ast::NodeId,\n-                                      hash: Option<&str>) {\n+pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                decl: &ast::FnDecl,\n+                                                body: &ast::Block,\n+                                                attrs: &[ast::Attribute],\n+                                                llwrapfn: ValueRef,\n+                                                param_substs: &param_substs<'tcx>,\n+                                                id: ast::NodeId,\n+                                                hash: Option<&str>) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     let fnty = ty::node_id_to_type(ccx.tcx(), id);\n@@ -547,14 +548,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys, mty);\n     }\n \n-    fn build_rust_fn(ccx: &CrateContext,\n-                     decl: &ast::FnDecl,\n-                     body: &ast::Block,\n-                     param_substs: &param_substs,\n-                     attrs: &[ast::Attribute],\n-                     id: ast::NodeId,\n-                     hash: Option<&str>)\n-                     -> ValueRef {\n+    fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               decl: &ast::FnDecl,\n+                               body: &ast::Block,\n+                               param_substs: &param_substs<'tcx>,\n+                               attrs: &[ast::Attribute],\n+                               id: ast::NodeId,\n+                               hash: Option<&str>)\n+                               -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n         let t = ty::node_id_to_type(tcx, id).subst(\n@@ -589,11 +590,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         llfn\n     }\n \n-    unsafe fn build_wrap_fn(ccx: &CrateContext,\n-                            llrustfn: ValueRef,\n-                            llwrapfn: ValueRef,\n-                            tys: &ForeignTypes,\n-                            t: Ty) {\n+    unsafe fn build_wrap_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      llrustfn: ValueRef,\n+                                      llwrapfn: ValueRef,\n+                                      tys: &ForeignTypes<'tcx>,\n+                                      t: Ty<'tcx>) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n         let tcx = ccx.tcx();\n@@ -832,8 +833,9 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n     }\n }\n \n-fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[Ty])\n-                     -> LlvmSignature {\n+fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               fn_sig: &ty::FnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n+                               -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n      * of a function.  Note that these LLVM types are not quite the same\n@@ -856,13 +858,13 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[Ty])\n     }\n }\n \n-fn foreign_types_for_id(ccx: &CrateContext,\n-                        id: ast::NodeId) -> ForeignTypes {\n+fn foreign_types_for_id<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  id: ast::NodeId) -> ForeignTypes<'tcx> {\n     foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx(), id))\n }\n \n-fn foreign_types_for_fn_ty(ccx: &CrateContext,\n-                           ty: Ty) -> ForeignTypes {\n+fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     ty: Ty<'tcx>) -> ForeignTypes<'tcx> {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n@@ -934,7 +936,8 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     }\n }\n \n-pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: Ty) -> Type {\n+pub fn lltype_for_foreign_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                       ty: Ty<'tcx>) -> Type {\n     lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n }\n "}, {"sha": "ae389663ace23cdfac5d28c15c65ebd82143e007", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -62,7 +62,7 @@ pub fn trans_exchange_free<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n }\n \n pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n-                                          content_ty: Ty) -> Block<'blk, 'tcx> {\n+                                          content_ty: Ty<'tcx>) -> Block<'blk, 'tcx> {\n     assert!(ty::type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -76,7 +76,8 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef,\n     }\n }\n \n-pub fn get_drop_glue_type(ccx: &CrateContext, t: Ty) -> Ty {\n+pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    t: Ty<'tcx>) -> Ty<'tcx> {\n     let tcx = ccx.tcx();\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n@@ -103,7 +104,7 @@ pub fn get_drop_glue_type(ccx: &CrateContext, t: Ty) -> Ty {\n \n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n-                           t: Ty,\n+                           t: Ty<'tcx>,\n                            source_location: Option<NodeInfo>)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n@@ -131,7 +132,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n-                                     t: Ty,\n+                                     t: Ty<'tcx>,\n                                      source_location: Option<NodeInfo>)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n@@ -140,7 +141,7 @@ pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     drop_ty(bcx, vp, t, source_location)\n }\n \n-pub fn get_drop_glue(ccx: &CrateContext, t: Ty) -> ValueRef {\n+pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -185,11 +186,11 @@ pub fn get_drop_glue(ccx: &CrateContext, t: Ty) -> ValueRef {\n }\n \n fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                      t: Ty,\n+                                      t: Ty<'tcx>,\n                                       v0: ValueRef,\n                                       dtor_did: ast::DefId,\n                                       class_did: ast::DefId,\n-                                      substs: &subst::Substs)\n+                                      substs: &subst::Substs<'tcx>)\n                                       -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n     let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n@@ -205,11 +206,11 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 t: Ty,\n+                                 t: Ty<'tcx>,\n                                  v0: ValueRef,\n                                  dtor_did: ast::DefId,\n                                  class_did: ast::DefId,\n-                                 substs: &subst::Substs)\n+                                 substs: &subst::Substs<'tcx>)\n                                  -> Block<'blk, 'tcx> {\n     let repr = adt::represent_type(bcx.ccx(), t);\n \n@@ -297,7 +298,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-fn size_and_align_of_dst(bcx: Block, t :Ty, info: ValueRef) -> (ValueRef, ValueRef) {\n+fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n+                                     -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {}\",\n            bcx.ty_to_string(t), bcx.val_to_string(info));\n     if ty::type_is_sized(bcx.tcx(), t) {\n@@ -352,7 +354,7 @@ fn size_and_align_of_dst(bcx: Block, t :Ty, info: ValueRef) -> (ValueRef, ValueR\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n@@ -477,7 +479,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty)\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: &CrateContext, t: Ty) -> tydesc_info {\n+pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n+                                -> tydesc_info<'tcx> {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n     assert!(!ccx.finished_tydescs().get());\n@@ -514,8 +517,8 @@ pub fn declare_tydesc(ccx: &CrateContext, t: Ty) -> tydesc_info {\n     }\n }\n \n-fn declare_generic_glue(ccx: &CrateContext, t: Ty, llfnty: Type,\n-                        name: &str) -> (String, ValueRef) {\n+fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                                  llfnty: Type, name: &str) -> (String, ValueRef) {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n@@ -526,13 +529,13 @@ fn declare_generic_glue(ccx: &CrateContext, t: Ty, llfnty: Type,\n     return (fn_nm, llfn);\n }\n \n-fn make_generic_glue(ccx: &CrateContext,\n-                     t: Ty,\n-                     llfn: ValueRef,\n-                     helper: for<'blk, 'tcx> |Block<'blk, 'tcx>, ValueRef, Ty|\n-                                              -> Block<'blk, 'tcx>,\n-                     name: &str)\n-                     -> ValueRef {\n+fn make_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               t: Ty<'tcx>,\n+                               llfn: ValueRef,\n+                               helper: for<'blk> |Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|\n+                                                  -> Block<'blk, 'tcx>,\n+                               name: &str)\n+                               -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);"}, {"sha": "d8c9b3ac9b2e83831b5416d1c5298148eaaf024b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -135,11 +135,15 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n     ccx.sess().abort_if_errors();\n }\n \n-pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::NodeId,\n-                                        callee_ty: Ty, cleanup_scope: cleanup::CustomScopeIndex,\n-                                        args: callee::CallArgs, dest: expr::Dest,\n-                                        substs: subst::Substs, call_info: NodeInfo)\n-                                        -> Result<'blk, 'tcx> {\n+pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                            node: ast::NodeId,\n+                                            callee_ty: Ty<'tcx>,\n+                                            cleanup_scope: cleanup::CustomScopeIndex,\n+                                            args: callee::CallArgs<'a, 'tcx>,\n+                                            dest: expr::Dest,\n+                                            substs: subst::Substs<'tcx>,\n+                                            call_info: NodeInfo)\n+                                            -> Result<'blk, 'tcx> {\n \n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n@@ -553,8 +557,9 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n     Result::new(bcx, llresult)\n }\n \n-fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n-                  tp_ty: Ty, dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n+fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              allow_overlap: bool, volatile: bool, tp_ty: Ty<'tcx>,\n+                              dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -582,8 +587,8 @@ fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n                       C_bool(ccx, volatile)], None)\n }\n \n-fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: Ty,\n-                    dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n+fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: Ty<'tcx>,\n+                                dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -607,8 +612,8 @@ fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> Value\n     Call(bcx, llfn, &[val, y], None)\n }\n \n-fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: Ty,\n-                           a: ValueRef, b: ValueRef) -> ValueRef {\n+fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static str,\n+                                       t: Ty<'tcx>, a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter"}, {"sha": "73f893cd07dfb0639aa1dc6a60854fd6797cb779", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -328,7 +328,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n                                           n_method: uint,\n-                                          vtable: traits::Vtable<()>)\n+                                          vtable: traits::Vtable<'tcx, ()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n     match vtable {\n@@ -378,10 +378,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn combine_impl_and_methods_tps(bcx: Block,\n-                                node: ExprOrMethodCall,\n-                                rcvr_substs: subst::Substs)\n-                                -> subst::Substs\n+fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                            node: ExprOrMethodCall,\n+                                            rcvr_substs: subst::Substs<'tcx>)\n+                                            -> subst::Substs<'tcx>\n {\n     /*!\n      * Creates a concatenated set of substitutions which includes\n@@ -424,7 +424,7 @@ fn combine_impl_and_methods_tps(bcx: Block,\n }\n \n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                  method_ty: Ty,\n+                                  method_ty: Ty<'tcx>,\n                                   n_method: uint,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n@@ -468,7 +468,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 callee_ty: Ty,\n+                                                 callee_ty: Ty<'tcx>,\n                                                  n_method: uint,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n@@ -526,10 +526,10 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// `trait_ref` would map `T:Trait`, but `box_ty` would be\n /// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n /// This will hopefully change now that DST is underway.\n-pub fn get_vtable(bcx: Block,\n-                  box_ty: Ty,\n-                  trait_ref: Rc<ty::TraitRef>)\n-                  -> ValueRef\n+pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              box_ty: Ty<'tcx>,\n+                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              -> ValueRef\n {\n     debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n            box_ty.repr(bcx.tcx()),\n@@ -677,10 +677,10 @@ pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n     }\n }\n \n-fn emit_vtable_methods(bcx: Block,\n-                       impl_id: ast::DefId,\n-                       substs: subst::Substs)\n-                       -> Vec<ValueRef> {\n+fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   impl_id: ast::DefId,\n+                                   substs: subst::Substs<'tcx>)\n+                                   -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n     let tcx = ccx.tcx();\n \n@@ -735,9 +735,9 @@ fn emit_vtable_methods(bcx: Block,\n }\n \n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    datum: Datum<Expr>,\n+                                    datum: Datum<'tcx, Expr>,\n                                     id: ast::NodeId,\n-                                    trait_ref: Rc<ty::TraitRef>,\n+                                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     /*!"}, {"sha": "218faa73e6c168302beae6174d1a4b53db47d7d1", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -30,10 +30,10 @@ use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use std::hash::{sip, Hash};\n \n-pub fn monomorphic_fn(ccx: &CrateContext,\n-                      fn_id: ast::DefId,\n-                      real_substs: &subst::Substs,\n-                      ref_id: Option<ast::NodeId>)\n+pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                fn_id: ast::DefId,\n+                                real_substs: &subst::Substs<'tcx>,\n+                                ref_id: Option<ast::NodeId>)\n     -> (ValueRef, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\\n@@ -284,7 +284,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n }\n \n #[deriving(PartialEq, Eq, Hash, Show)]\n-pub struct MonoId {\n+pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n-    pub params: subst::VecPerParamSpace<Ty>\n+    pub params: subst::VecPerParamSpace<Ty<'tcx>>\n }"}, {"sha": "baab9b7b9a75b0b9127ca8b3d04757d9267a2ea9", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -52,7 +52,7 @@ pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef\n \n pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           vptr: ValueRef,\n-                                          unit_ty: Ty,\n+                                          unit_ty: Ty<'tcx>,\n                                           should_deallocate: bool)\n                                           -> Block<'blk, 'tcx> {\n     let not_null = IsNotNull(bcx, vptr);\n@@ -89,15 +89,15 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-pub struct VecTypes {\n-    pub unit_ty: Ty,\n+pub struct VecTypes<'tcx> {\n+    pub unit_ty: Ty<'tcx>,\n     pub llunit_ty: Type,\n     pub llunit_size: ValueRef,\n     pub llunit_alloc_size: u64\n }\n \n-impl VecTypes {\n-    pub fn to_string(&self, ccx: &CrateContext) -> String {\n+impl<'tcx> VecTypes<'tcx> {\n+    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         format!(\"VecTypes {{unit_ty={}, llunit_ty={}, \\\n                  llunit_size={}, llunit_alloc_size={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n@@ -240,7 +240,7 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 vt: &VecTypes,\n+                                 vt: &VecTypes<'tcx>,\n                                  vstore_expr: &ast::Expr,\n                                  content_expr: &ast::Expr,\n                                  dest: Dest)\n@@ -337,12 +337,16 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn vec_types_from_expr(bcx: Block, vec_expr: &ast::Expr) -> VecTypes {\n+pub fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       vec_expr: &ast::Expr)\n+                                       -> VecTypes<'tcx> {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types(bcx: Block, unit_ty: Ty) -> VecTypes {\n+pub fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             unit_ty: Ty<'tcx>)\n+                             -> VecTypes<'tcx> {\n     let ccx = bcx.ccx();\n     let llunit_ty = type_of::type_of(ccx, unit_ty);\n     let llunit_size = nonzero_llsize_of(ccx, llunit_ty);\n@@ -437,11 +441,11 @@ pub fn get_base_and_len(bcx: Block,\n }\n \n pub type iter_vec_block<'a, 'blk, 'tcx> =\n-    |Block<'blk, 'tcx>, ValueRef, Ty|: 'a -> Block<'blk, 'tcx>;\n+    |Block<'blk, 'tcx>, ValueRef, Ty<'tcx>|: 'a -> Block<'blk, 'tcx>;\n \n pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      data_ptr: ValueRef,\n-                                     vt: &VecTypes,\n+                                     vt: &VecTypes<'tcx>,\n                                      count: ValueRef,\n                                      f: iter_vec_block<'a, 'blk, 'tcx>)\n                                      -> Block<'blk, 'tcx> {\n@@ -497,7 +501,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     data_ptr: ValueRef,\n-                                    unit_ty: Ty,\n+                                    unit_ty: Ty<'tcx>,\n                                     len: ValueRef,\n                                     f: iter_vec_block<'a, 'blk, 'tcx>)\n                                     -> Block<'blk, 'tcx> {"}, {"sha": "431768a94de58d3738960af042756cbaf698eefb", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc98954d559385bae9d85cd5f160b9efd69a110/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=5bc98954d559385bae9d85cd5f160b9efd69a110", "patch": "@@ -28,26 +28,29 @@ use syntax::abi;\n use syntax::ast;\n \n // LLVM doesn't like objects that are too big. Issue #17913\n-fn ensure_array_fits_in_address_space(ccx: &CrateContext,\n-                                      llet: Type,\n-                                      size: machine::llsize,\n-                                      scapegoat: Ty) {\n+fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                llet: Type,\n+                                                size: machine::llsize,\n+                                                scapegoat: Ty<'tcx>) {\n     let esz = machine::llsize_of_alloc(ccx, llet);\n     match esz.checked_mul(size) {\n         Some(n) if n < ccx.max_obj_size() => {}\n         _ => { ccx.report_overbig_object(scapegoat) }\n     }\n }\n \n-pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: Ty) -> bool {\n+pub fn arg_is_indirect<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 arg_ty: Ty<'tcx>) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n \n-pub fn return_uses_outptr(ccx: &CrateContext, ty: Ty) -> bool {\n+pub fn return_uses_outptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                    ty: Ty<'tcx>) -> bool {\n     !type_is_immediate(ccx, ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: Ty) -> Type {\n+pub fn type_of_explicit_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                      arg_ty: Ty<'tcx>) -> Type {\n     let llty = arg_type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n@@ -59,10 +62,10 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: Ty) -> Type {\n /// Yields the types of the \"real\" arguments for this function. For most\n /// functions, these are simply the types of the arguments. For functions with\n /// the `RustCall` ABI, however, this untuples the arguments of the function.\n-pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n-                                      inputs: &[Ty],\n-                                      abi: abi::Abi)\n-                                      -> Vec<Ty> {\n+pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                inputs: &[Ty<'tcx>],\n+                                                abi: abi::Abi)\n+                                                -> Vec<Ty<'tcx>> {\n     if abi != abi::RustCall {\n         return inputs.iter().map(|x| (*x).clone()).collect()\n     }\n@@ -94,12 +97,12 @@ pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n     result\n }\n \n-pub fn type_of_rust_fn(cx: &CrateContext,\n-                       llenvironment_type: Option<Type>,\n-                       inputs: &[Ty],\n-                       output: ty::FnOutput,\n-                       abi: abi::Abi)\n-                       -> Type {\n+pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                 llenvironment_type: Option<Type>,\n+                                 inputs: &[Ty<'tcx>],\n+                                 output: ty::FnOutput<'tcx>,\n+                                 abi: abi::Abi)\n+                                 -> Type {\n     let mut atys: Vec<Type> = Vec::new();\n \n     // First, munge the inputs, if this has the `rust-call` ABI.\n@@ -138,7 +141,7 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &CrateContext, fty: Ty) -> Type {\n+pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx,\n@@ -175,7 +178,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: Ty) -> Type {\n //     type behind pointers. This can help prevent infinite loops for\n //     recursive types. For example, enum types rely on this behavior.\n \n-pub fn sizing_type_of(cx: &CrateContext, t: Ty) -> Type {\n+pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     match cx.llsizingtypes().borrow().get(&t).cloned() {\n         Some(t) => return t,\n         None => ()\n@@ -247,7 +250,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: Ty) -> Type {\n     llsizingty\n }\n \n-pub fn arg_type_of(cx: &CrateContext, t: Ty) -> Type {\n+pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if ty::type_is_bool(t) {\n         Type::i1(cx)\n     } else {\n@@ -256,8 +259,8 @@ pub fn arg_type_of(cx: &CrateContext, t: Ty) -> Type {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &CrateContext, t: Ty) -> Type {\n-    fn type_of_unsize_info(cx: &CrateContext, t: Ty) -> Type {\n+pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+    fn type_of_unsize_info<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n         // It is possible to end up here with a sized type. This happens with a\n         // struct which might be unsized, but is monomorphised to a sized type.\n         // In this case we'll fake a fat pointer with no unsize info (we use 0).\n@@ -433,7 +436,8 @@ pub fn type_of(cx: &CrateContext, t: Ty) -> Type {\n     return llty;\n }\n \n-pub fn align_of(cx: &CrateContext, t: Ty) -> machine::llalign {\n+pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n+                          -> machine::llalign {\n     let llty = sizing_type_of(cx, t);\n     machine::llalign_of_min(cx, llty)\n }\n@@ -445,11 +449,11 @@ pub enum named_ty {\n     an_unboxed_closure,\n }\n \n-pub fn llvm_type_name(cx: &CrateContext,\n-                      what: named_ty,\n-                      did: ast::DefId,\n-                      tps: &[Ty])\n-                      -> String\n+pub fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                what: named_ty,\n+                                did: ast::DefId,\n+                                tps: &[Ty<'tcx>])\n+                                -> String\n {\n     let name = match what {\n         a_struct => \"struct\",\n@@ -472,7 +476,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     }\n }\n \n-pub fn type_of_dtor(ccx: &CrateContext, self_ty: Ty) -> Type {\n+pub fn type_of_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, self_ty: Ty<'tcx>) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n     Type::func(&[self_ty], &Type::void(ccx))\n }"}]}