{"sha": "4d90635adc953f56d946925e56d189aabd4d3199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOTA2MzVhZGM5NTNmNTZkOTQ2OTI1ZTU2ZDE4OWFhYmQ0ZDMxOTk=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-28T22:30:26Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-28T23:04:43Z"}, "message": "Fix tidy platform-specific code check", "tree": {"sha": "1dfc945f65171b70e4b1cdcedbc058b002e287e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dfc945f65171b70e4b1cdcedbc058b002e287e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d90635adc953f56d946925e56d189aabd4d3199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d90635adc953f56d946925e56d189aabd4d3199", "html_url": "https://github.com/rust-lang/rust/commit/4d90635adc953f56d946925e56d189aabd4d3199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d90635adc953f56d946925e56d189aabd4d3199/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76a04dd3f8b2500d9e524dca122814fd5a3e25e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/76a04dd3f8b2500d9e524dca122814fd5a3e25e4", "html_url": "https://github.com/rust-lang/rust/commit/76a04dd3f8b2500d9e524dca122814fd5a3e25e4"}], "stats": {"total": 76, "additions": 28, "deletions": 48}, "files": [{"sha": "db177f75ceae9e906899bbe6a4b03da899cb3cba", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 28, "deletions": 48, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4d90635adc953f56d946925e56d189aabd4d3199/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d90635adc953f56d946925e56d189aabd4d3199/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=4d90635adc953f56d946925e56d189aabd4d3199", "patch": "@@ -21,8 +21,7 @@\n //! - libunwind may have platform-specific code.\n //! - other crates in the std facade may not.\n //! - std may have platform-specific code in the following places:\n-//!   - `sys/unix/`\n-//!   - `sys/windows/`\n+//!   - `sys/`\n //!   - `os/`\n //!\n //! `std/sys_common` should _not_ contain platform-specific code.\n@@ -36,34 +35,30 @@ use std::path::Path;\n \n // Paths that may contain platform-specific code.\n const EXCEPTION_PATHS: &[&str] = &[\n-    // std crates\n     \"library/panic_abort\",\n     \"library/panic_unwind\",\n     \"library/unwind\",\n-    \"library/std/src/sys/\", // Platform-specific code for std lives here.\n-    // This has the trailing slash so that sys_common is not excepted.\n-    \"library/std/src/os\", // Platform-specific public interfaces\n-    \"library/rtstartup\",  // Not sure what to do about this. magic stuff for mingw\n-    // Integration test for platform-specific run-time feature detection:\n-    \"library/std/tests/run-time-detect.rs\",\n-    \"library/std/src/net/test.rs\",\n-    \"library/std/src/net/addr\",\n-    \"library/std/src/net/udp\",\n-    \"library/std/src/sys_common/remutex.rs\",\n-    \"library/std/src/sync/mutex.rs\",\n-    \"library/std/src/sync/rwlock.rs\",\n-    \"library/term\", // Not sure how to make this crate portable, but test crate needs it.\n-    \"library/test\", // Probably should defer to unstable `std::sys` APIs.\n-    // std testing crates, okay for now at least\n-    \"library/core/tests\",\n-    \"library/alloc/tests/lib.rs\",\n-    \"library/alloc/benches/lib.rs\",\n+    \"library/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n+    \"library/term\",      // Not sure how to make this crate portable, but test crate needs it.\n+    \"library/test\",      // Probably should defer to unstable `std::sys` APIs.\n     // The `VaList` implementation must have platform specific code.\n     // The Windows implementation of a `va_list` is always a character\n     // pointer regardless of the target architecture. As a result,\n     // we must use `#[cfg(windows)]` to conditionally compile the\n     // correct `VaList` structure for windows.\n     \"library/core/src/ffi.rs\",\n+    \"library/std/src/sys/\", // Platform-specific code for std lives here.\n+    \"library/std/src/os\",   // Platform-specific public interfaces\n+    // Temporary `std` exceptions\n+    // FIXME: platform-specific code should be moved to `sys`\n+    \"library/std/src/io/copy.rs\",\n+    \"library/std/src/io/stdio.rs\",\n+    \"library/std/src/f32.rs\",\n+    \"library/std/src/f64.rs\",\n+    \"library/std/src/path.rs\",\n+    \"library/std/src/thread/available_concurrency.rs\",\n+    \"library/std/src/sys_common\", // Should only contain abstractions over platforms\n+    \"library/std/src/net/test.rs\", // Utility helpers for tests\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {\n@@ -82,6 +77,11 @@ pub fn check(path: &Path, bad: &mut bool) {\n             return;\n         }\n \n+        // exclude tests and benchmarks as some platforms do not support all tests\n+        if filestr.contains(\"tests\") || filestr.contains(\"benches\") {\n+            return;\n+        }\n+\n         check_cfgs(contents, &file, bad, &mut saw_target_arch, &mut saw_cfg_bang);\n     });\n \n@@ -96,9 +96,6 @@ fn check_cfgs(\n     saw_target_arch: &mut bool,\n     saw_cfg_bang: &mut bool,\n ) {\n-    // For now it's ok to have platform-specific code after 'mod tests'.\n-    let mod_tests_idx = find_test_mod(contents);\n-    let contents = &contents[..mod_tests_idx];\n     // Pull out all `cfg(...)` and `cfg!(...)` strings.\n     let cfgs = parse_cfgs(contents);\n \n@@ -149,39 +146,22 @@ fn check_cfgs(\n             continue;\n         }\n \n-        err(idx, cfg);\n-    }\n-}\n-\n-fn find_test_mod(contents: &str) -> usize {\n-    if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n-        // Also capture a previous line indicating that \"mod tests\" is cfg'd out.\n-        let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n-        let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n-        if let Some(nl) = prev_newline_idx {\n-            let prev_line = &contents[nl + 1..mod_tests_idx];\n-            if prev_line.contains(\"cfg(all(test, not(target_os\")\n-                || prev_line.contains(\"cfg(all(test, not(any(target_os\")\n-            {\n-                nl\n-            } else {\n-                mod_tests_idx\n-            }\n-        } else {\n-            mod_tests_idx\n+        // exclude tests as some platforms do not support all tests\n+        if cfg.contains(\"test\") {\n+            continue;\n         }\n-    } else {\n-        contents.len()\n+\n+        err(idx, cfg);\n     }\n }\n \n-fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n+fn parse_cfgs(contents: &str) -> Vec<(usize, &str)> {\n     let candidate_cfgs = contents.match_indices(\"cfg\");\n     let candidate_cfg_idxs = candidate_cfgs.map(|(i, _)| i);\n     // This is puling out the indexes of all \"cfg\" strings\n     // that appear to be tokens followed by a parenthesis.\n     let cfgs = candidate_cfg_idxs.filter(|i| {\n-        let pre_idx = i.saturating_sub(*i);\n+        let pre_idx = i.saturating_sub(1);\n         let succeeds_non_ident = !contents\n             .as_bytes()\n             .get(pre_idx)"}]}