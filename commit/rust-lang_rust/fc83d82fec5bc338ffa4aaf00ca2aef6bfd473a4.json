{"sha": "fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjODNkODJmZWM1YmMzMzhmZmE0YWFmMDBjYTJhZWY2YmZkNDczYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T00:13:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-23T00:13:51Z"}, "message": "auto merge of #7204 : alexcrichton/rust/deriving-to-string, r=pcwalton\n\nCloses #7180 and #7179.\r\n\r\nBefore, the `deriving(ToStr)` attribute was essentially `fmt!(\"%?\")`. This changes it to recursively invoke `to_str()` on fields instead of relying on `fmt!`-style things. This seems more natural to me and what should actually be expected.", "tree": {"sha": "efbdac2a1b9c2f2f29551d33f8cc5dc61f4e565b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efbdac2a1b9c2f2f29551d33f8cc5dc61f4e565b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "html_url": "https://github.com/rust-lang/rust/commit/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0739c6b5a00372e6c7ed2f9bdafea8a8c0e383a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0739c6b5a00372e6c7ed2f9bdafea8a8c0e383a6", "html_url": "https://github.com/rust-lang/rust/commit/0739c6b5a00372e6c7ed2f9bdafea8a8c0e383a6"}, {"sha": "30d755957a0f2cc3be3b355671da79cdf34fd50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/30d755957a0f2cc3be3b355671da79cdf34fd50a", "html_url": "https://github.com/rust-lang/rust/commit/30d755957a0f2cc3be3b355671da79cdf34fd50a"}], "stats": {"total": 147, "additions": 102, "deletions": 45}, "files": [{"sha": "3dc70ed10c770b854c9eb9f3162bc8acc94800c6", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "patch": "@@ -1563,7 +1563,9 @@ Supported traits for `deriving` are:\n * `Rand`, to create a random instance of a data type.\n * `Zero`, to create an zero (or empty) instance of a data type.\n * `ToStr`, to convert to a string. For a type with this instance,\n-  `obj.to_str()` has the same output as `fmt!(\"%?\", obj)`.\n+  `obj.to_str()` has similar output as `fmt!(\"%?\", obj)`, but it differs in that\n+  each constituent field of the type must also implement `ToStr` and will have\n+  `field.to_str()` invoked to build up the result.\n \n # Statements and expressions\n "}, {"sha": "4cd168b12c0cc64b7fed149d503687e5b097e975", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 64, "deletions": 11, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use ast;\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n@@ -40,16 +41,68 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n-    match substr.self_args {\n-        [self_obj] => {\n-            let self_addr = cx.expr_addr_of(span, self_obj);\n-            cx.expr_call_global(span,\n-                                ~[cx.ident_of(\"std\"),\n-                                  cx.ident_of(\"sys\"),\n-                                  cx.ident_of(\"log_str\")],\n-                                ~[self_addr])\n+// It used to be the case that this deriving implementation invoked\n+// std::sys::log_str, but this isn't sufficient because it doesn't invoke the\n+// to_str() method on each field. Hence we mirror the logic of the log_str()\n+// method, but with tweaks to call to_str() on sub-fields.\n+fn to_str_substructure(cx: @ExtCtxt, span: span,\n+                       substr: &Substructure) -> @expr {\n+    let to_str = cx.ident_of(\"to_str\");\n+\n+    let doit = |start: &str, end: @str, name: ast::ident,\n+                fields: &[(Option<ast::ident>, @expr, ~[@expr])]| {\n+        if fields.len() == 0 {\n+            cx.expr_str_uniq(span, cx.str_of(name))\n+        } else {\n+            let buf = cx.ident_of(\"buf\");\n+            let start = cx.str_of(name) + start;\n+            let init = cx.expr_str_uniq(span, start.to_managed());\n+            let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n+            let push_str = cx.ident_of(\"push_str\");\n+\n+            let push = |s: @expr| {\n+                let ebuf = cx.expr_ident(span, buf);\n+                let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n+                stmts.push(cx.stmt_expr(call));\n+            };\n+\n+            for fields.iter().enumerate().advance |(i, &(name, e, _))| {\n+                if i > 0 {\n+                    push(cx.expr_str(span, @\", \"));\n+                }\n+                match name {\n+                    None => {}\n+                    Some(id) => {\n+                        let name = cx.str_of(id) + \": \";\n+                        push(cx.expr_str(span, name.to_managed()));\n+                    }\n+                }\n+                push(cx.expr_method_call(span, e, to_str, ~[]));\n+            }\n+            push(cx.expr_str(span, end));\n+\n+            cx.expr_blk(cx.blk(span, stmts, Some(cx.expr_ident(span, buf))))\n+        }\n+    };\n+\n+    return match *substr.fields {\n+        Struct(ref fields) => {\n+            if fields.len() == 0 || fields[0].n0_ref().is_none() {\n+                doit(\"(\", @\")\", substr.type_ident, *fields)\n+            } else {\n+                doit(\"{\", @\"}\", substr.type_ident, *fields)\n+            }\n         }\n-        _ => cx.span_bug(span, \"Invalid number of arguments in `deriving(ToStr)`\")\n-    }\n+\n+        EnumMatching(_, variant, ref fields) => {\n+            match variant.node.kind {\n+                ast::tuple_variant_kind(*) =>\n+                    doit(\"(\", @\")\", variant.node.name, *fields),\n+                ast::struct_variant_kind(*) =>\n+                    doit(\"{\", @\"}\", variant.node.name, *fields),\n+            }\n+        }\n+\n+        _ => cx.bug(\"expected Struct or EnumMatching in deriving(ToStr)\")\n+    };\n }"}, {"sha": "1fc1d6815f5f4612b3e34a304826cb29b6c4a956", "filename": "src/test/run-pass/deriving-to-str.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-to-str.rs?ref=fc83d82fec5bc338ffa4aaf00ca2aef6bfd473a4", "patch": "@@ -1,5 +1,4 @@\n-// xfail-fast #6330\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,39 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rand;\n+#[deriving(ToStr)]\n+enum A {}\n+#[deriving(ToStr)]\n+enum B { B1, B2, B3 }\n+#[deriving(ToStr)]\n+enum C { C1(int), C2(B), C3(~str) }\n+#[deriving(ToStr)]\n+enum D { D1{ a: int } }\n+#[deriving(ToStr)]\n+struct E;\n+#[deriving(ToStr)]\n+struct F(int);\n+#[deriving(ToStr)]\n+struct G(int, int);\n+#[deriving(ToStr)]\n+struct H { a: int }\n+#[deriving(ToStr)]\n+struct I { a: int, b: int }\n+#[deriving(ToStr)]\n+struct J(Custom);\n \n-#[deriving(Rand,ToStr)]\n-struct A;\n-\n-#[deriving(Rand,ToStr)]\n-struct B(int, int);\n-\n-#[deriving(Rand,ToStr)]\n-struct C {\n-    x: f64,\n-    y: (u8, u8)\n-}\n-\n-#[deriving(Rand,ToStr)]\n-enum D {\n-    D0,\n-    D1(uint),\n-    D2 { x: (), y: () }\n+struct Custom;\n+impl ToStr for Custom {\n+    fn to_str(&self) -> ~str { ~\"yay\" }\n }\n \n fn main() {\n-    macro_rules! t(\n-        ($ty:ty) => {{\n-            let x =rand::random::<$ty>();\n-            assert_eq!(x.to_str(), fmt!(\"%?\", x));\n-        }}\n-    );\n-\n-    for 20.times {\n-        t!(A);\n-        t!(B);\n-        t!(C);\n-        t!(D);\n-    }\n+    assert_eq!(B1.to_str(), ~\"B1\");\n+    assert_eq!(B2.to_str(), ~\"B2\");\n+    assert_eq!(C1(3).to_str(), ~\"C1(3)\");\n+    assert_eq!(C2(B2).to_str(), ~\"C2(B2)\");\n+    assert_eq!(D1{ a: 2 }.to_str(), ~\"D1{a: 2}\");\n+    assert_eq!(E.to_str(), ~\"E\");\n+    assert_eq!(F(3).to_str(), ~\"F(3)\");\n+    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n+    assert_eq!(G(3, 4).to_str(), ~\"G(3, 4)\");\n+    assert_eq!(I{ a: 2, b: 4 }.to_str(), ~\"I{a: 2, b: 4}\");\n+    assert_eq!(J(Custom).to_str(), ~\"J(yay)\");\n }"}]}