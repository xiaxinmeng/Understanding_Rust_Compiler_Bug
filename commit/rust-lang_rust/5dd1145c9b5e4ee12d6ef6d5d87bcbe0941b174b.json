{"sha": "5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDExNDVjOWI1ZTRlZTEyZDZlZjZkNWQ4N2JjYmUwOTQxYjE3NGI=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-09-29T12:23:58Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-10-05T10:09:30Z"}, "message": "Use &'self str instead of raw char pointer in ModEntry", "tree": {"sha": "212e620c633a8fb089cb0193e5d2938a6e814727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/212e620c633a8fb089cb0193e5d2938a6e814727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "html_url": "https://github.com/rust-lang/rust/commit/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ef4463b2a7d2c41fbc1072779951b445c80f95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef4463b2a7d2c41fbc1072779951b445c80f95b", "html_url": "https://github.com/rust-lang/rust/commit/9ef4463b2a7d2c41fbc1072779951b445c80f95b"}], "stats": {"total": 256, "additions": 116, "deletions": 140}, "files": [{"sha": "c7ae68ec446ec093f9556a0be1f59a7fece059e6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "patch": "@@ -54,7 +54,7 @@ use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n-use middle::trans::machine::{llalign_of_min, llsize_of};\n+use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n@@ -2911,8 +2911,9 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n-    let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n+pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint, uint) {\n+    let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n+    let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = Type::array(&elttype, ccx.module_data.len() as u64);\n     let map = do \"_rust_mod_map\".with_c_str |buf| {\n         unsafe {\n@@ -2931,17 +2932,18 @@ pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n     }\n \n     for key in keys.iter() {\n-        let val = *ccx.module_data.find_equiv(key).unwrap();\n-        let s_const = C_cstr(ccx, *key);\n-        let s_ptr = p2i(ccx, s_const);\n-        let v_ptr = p2i(ccx, val);\n-        let elt = C_struct([s_ptr, v_ptr]);\n-        elts.push(elt);\n+            let val = *ccx.module_data.find_equiv(key).unwrap();\n+            let v_ptr = p2i(ccx, val);\n+            let elt = C_struct([\n+                C_estr_slice(ccx, *key),\n+                v_ptr\n+            ]);\n+            elts.push(elt);\n     }\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     }\n-    return (map, keys.len());\n+    return (map, keys.len(), llsize_of_alloc(ccx, elttype));\n }\n \n \n@@ -3003,17 +3005,19 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n         llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n-        let (mod_map, mod_count) = create_module_map(ccx);\n+        let (mod_map, mod_count, mod_struct_size) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n              C_struct([\n                 p2i(ccx, mod_map),\n-                C_int(ccx, (mod_count * 16) as int)\n+                // byte size of the module map array, an entry consists of two integers\n+                C_int(ccx, ((mod_count * mod_struct_size) as int))\n              ]),\n              C_struct([\n                 p2i(ccx, vec_elements),\n-                C_int(ccx, (subcrates.len() * 8) as int)\n+                // byte size of the subcrates array, an entry consists of an integer\n+                C_int(ccx, (subcrates.len() * llsize_of_alloc(ccx, ccx.int_type)) as int)\n              ])\n         ]));\n     }"}, {"sha": "3120d69d5dfdd24dbde9bbddcd057de87e3706c5", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "patch": "@@ -11,7 +11,6 @@\n #[cfg(not(stage0))] use cast::transmute;\n use container::MutableSet;\n use hashmap::HashSet;\n-use libc::c_char;\n use option::{Some, None};\n use vec::ImmutableVector;\n \n@@ -29,19 +28,19 @@ extern {\n     static CRATE_MAP: CrateMap<'static>;\n }\n \n-pub struct ModEntry {\n-    name: *c_char,\n+pub struct ModEntry<'self> {\n+    name: &'self str,\n     log_level: *mut u32\n }\n \n pub struct CrateMapV0<'self> {\n-    entries: &'self [ModEntry],\n+    entries: &'self [ModEntry<'self>],\n     children: &'self [&'self CrateMap<'self>]\n }\n \n pub struct CrateMap<'self> {\n     version: i32,\n-    entries: &'self [ModEntry],\n+    entries: &'self [ModEntry<'self>],\n     /// a dynamically sized struct, where all pointers to children are listed adjacent\n     /// to the struct, terminated with NULL\n     children: &'self [&'self CrateMap<'self>]\n@@ -79,7 +78,7 @@ fn version(crate_map: &CrateMap) -> i32 {\n \n #[cfg(not(stage0))]\n fn get_entries_and_children<'a>(crate_map: &'a CrateMap<'a>) ->\n-                    (&'a [ModEntry], &'a [&'a CrateMap<'a>]) {\n+                    (&'a [ModEntry<'a>], &'a [&'a CrateMap<'a>]) {\n     match version(crate_map) {\n         0 => {\n             unsafe {\n@@ -127,34 +126,31 @@ pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n \n #[cfg(test)]\n mod tests {\n-    use c_str::ToCStr;\n-    use cast::transmute;\n     use rt::crate_map::{CrateMap, ModEntry, iter_crate_map};\n \n     #[test]\n     fn iter_crate_map_duplicates() {\n+        let mut level3: u32 = 3;\n+\n+        let entries = [\n+            ModEntry { name: \"c::m1\", log_level: &mut level3},\n+        ];\n+\n+        let child_crate = CrateMap {\n+            version: 1,\n+            entries: entries,\n+            children: []\n+        };\n+\n+        let root_crate = CrateMap {\n+            version: 1,\n+            entries: [],\n+            children: [&child_crate, &child_crate]\n+        };\n+\n+        let mut cnt = 0;\n         unsafe {\n-            let mod_name1 = \"c::m1\".to_c_str();\n-            let mut level3: u32 = 3;\n-\n-            let entries = [\n-                ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n-            ];\n-\n-            let child_crate = CrateMap {\n-                version: 1,\n-                entries: entries,\n-                children: []\n-            };\n-\n-            let root_crate = CrateMap {\n-                version: 1,\n-                entries: [],\n-                children: [&child_crate, &child_crate]\n-            };\n-\n-            let mut cnt = 0;\n-            do iter_crate_map(transmute(&root_crate)) |entry| {\n+            do iter_crate_map(&root_crate) |entry| {\n                 assert!(*entry.log_level == 3);\n                 cnt += 1;\n             }\n@@ -164,38 +160,36 @@ mod tests {\n \n     #[test]\n     fn iter_crate_map_follow_children() {\n+        let mut level2: u32 = 2;\n+        let mut level3: u32 = 3;\n+        let child_crate2 = CrateMap {\n+            version: 1,\n+            entries: [\n+                ModEntry { name: \"c::m1\", log_level: &mut level2},\n+                ModEntry { name: \"c::m2\", log_level: &mut level3},\n+            ],\n+            children: []\n+        };\n+\n+        let child_crate1 = CrateMap {\n+            version: 1,\n+            entries: [\n+                ModEntry { name: \"t::f1\", log_level: &mut 1},\n+            ],\n+            children: [&child_crate2]\n+        };\n+\n+        let root_crate = CrateMap {\n+            version: 1,\n+            entries: [\n+                ModEntry { name: \"t::f2\", log_level: &mut 0},\n+            ],\n+            children: [&child_crate1]\n+        };\n+\n+        let mut cnt = 0;\n         unsafe {\n-            let mod_name1 = \"c::m1\".to_c_str();\n-            let mod_name2 = \"c::m2\".to_c_str();\n-            let mut level2: u32 = 2;\n-            let mut level3: u32 = 3;\n-            let child_crate2 = CrateMap {\n-                version: 1,\n-                entries: [\n-                    ModEntry { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n-                    ModEntry { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n-                ],\n-                children: []\n-            };\n-\n-            let child_crate1 = CrateMap {\n-                version: 1,\n-                entries: [\n-                    ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 1},\n-                ],\n-                children: [&child_crate2]\n-            };\n-\n-            let root_crate = CrateMap {\n-                version: 1,\n-                entries: [\n-                    ModEntry { name: \"t::f1\".to_c_str().with_ref(|buf| buf), log_level: &mut 0},\n-                ],\n-                children: [&child_crate1]\n-            };\n-\n-            let mut cnt = 0;\n-            do iter_crate_map(transmute(&root_crate)) |entry| {\n+            do iter_crate_map(&root_crate) |entry| {\n                 assert!(*entry.log_level == cnt);\n                 cnt += 1;\n             }"}, {"sha": "cf917d1c412c515191d7d048a688294a47bb3e59", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 45, "deletions": 67, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "patch": "@@ -16,7 +16,6 @@ use rt;\n use rt::util::dumb_println;\n use rt::crate_map::{ModEntry, CrateMap, iter_crate_map, get_crate_map};\n use str::StrSlice;\n-use str::raw::from_c_str;\n use u32;\n use vec::ImmutableVector;\n #[cfg(test)] use cast::transmute;\n@@ -112,28 +111,26 @@ fn parse_logging_spec(spec: ~str) -> ~[LogDirective]{\n fn update_entry(dirs: &[LogDirective], entry: &ModEntry) -> u32 {\n     let mut new_lvl: u32 = DEFAULT_LOG_LEVEL;\n     let mut longest_match = -1i;\n-    unsafe {\n-        for dir in dirs.iter() {\n-            match dir.name {\n-                None => {\n-                    if longest_match == -1 {\n-                        longest_match = 0;\n-                        new_lvl = dir.level;\n-                    }\n+    for dir in dirs.iter() {\n+        match dir.name {\n+            None => {\n+                if longest_match == -1 {\n+                    longest_match = 0;\n+                    new_lvl = dir.level;\n                 }\n-                Some(ref dir_name) => {\n-                    let name = from_c_str(entry.name);\n-                    let len = dir_name.len() as int;\n-                    if name.starts_with(*dir_name) &&\n-                        len >= longest_match {\n-                        longest_match = len;\n-                        new_lvl = dir.level;\n-                    }\n+            }\n+            Some(ref dir_name) => {\n+                let name = entry.name;\n+                let len = dir_name.len() as int;\n+                if name.starts_with(*dir_name) &&\n+                    len >= longest_match {\n+                    longest_match = len;\n+                    new_lvl = dir.level;\n                 }\n-            };\n-        }\n-        *entry.log_level = new_lvl;\n+            }\n+        };\n     }\n+    unsafe { *entry.log_level = new_lvl; }\n     if longest_match >= 0 { return 1; } else { return 0; }\n }\n \n@@ -144,13 +141,11 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     let mut dirs = ~[];\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n-            dumb_println(\"\\nCrate log map:\\n\");\n-            unsafe {\n-                do iter_crate_map(crate_map) |entry| {\n-                    dumb_println(\" \"+from_c_str(entry.name));\n-                }\n-                exit(1);\n+        dumb_println(\"\\nCrate log map:\\n\");\n+            do iter_crate_map(crate_map) |entry| {\n+                dumb_println(\" \"+entry.name);\n             }\n+            unsafe { exit(1); }\n         }\n         dirs = parse_logging_spec(settings);\n     }\n@@ -288,88 +283,71 @@ fn parse_logging_spec_global() {\n // Tests for update_entry\n #[test]\n fn update_entry_match_full_path() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate1::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 2);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name:\"crate1::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 2);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_no_match() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate3::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n-            assert!(m == 0);\n-        }\n+        let entry= &ModEntry {name: \"crate3::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == DEFAULT_LOG_LEVEL);\n+        assert!(m == 0);\n     }\n }\n \n #[test]\n fn update_entry_match_beginning() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate2::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 3);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name: \"crate2::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 3);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_match_beginning_longest_match() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: Some(~\"crate2\"), level: 3},\n                  LogDirective {name: Some(~\"crate2::mod\"), level: 4}];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate2::mod1\".with_c_str |ptr| {\n-            let entry = &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 4);\n-            assert!(m == 1);\n-        }\n+        let entry = &ModEntry {name: \"crate2::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 4);\n+        assert!(m == 1);\n     }\n }\n \n #[test]\n fn update_entry_match_default() {\n-    use c_str::ToCStr;\n     let dirs = ~[LogDirective {name: Some(~\"crate1::mod1\"), level: 2 },\n                  LogDirective {name: None, level: 3}\n                 ];\n     let level = &mut 0;\n     unsafe {\n-        do \"crate1::mod1\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 2);\n-            assert!(m == 1);\n-        }\n-        do \"crate2::mod2\".with_c_str |ptr| {\n-            let entry= &ModEntry {name: ptr, log_level: level};\n-            let m = update_entry(dirs, transmute(entry));\n-            assert!(*entry.log_level == 3);\n-            assert!(m == 1);\n-        }\n+        let entry= &ModEntry {name: \"crate1::mod1\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 2);\n+        assert!(m == 1);\n+        let entry= &ModEntry {name: \"crate2::mod2\", log_level: level};\n+        let m = update_entry(dirs, transmute(entry));\n+        assert!(*entry.log_level == 3);\n+        assert!(m == 1);\n     }\n }"}]}