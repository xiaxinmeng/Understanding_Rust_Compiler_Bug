{"sha": "50f67de35ed0aadc351e55dad47d49bc7c89c399", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjY3ZGUzNWVkMGFhZGMzNTFlNTVkYWQ0N2Q0OWJjN2M4OWMzOTk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-02T10:45:01Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-16T09:54:38Z"}, "message": "Remove rustc_driver tests", "tree": {"sha": "47f016d18b38b91fe9bee2c522f9cae824c84ff2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47f016d18b38b91fe9bee2c522f9cae824c84ff2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f67de35ed0aadc351e55dad47d49bc7c89c399", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f67de35ed0aadc351e55dad47d49bc7c89c399", "html_url": "https://github.com/rust-lang/rust/commit/50f67de35ed0aadc351e55dad47d49bc7c89c399", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f67de35ed0aadc351e55dad47d49bc7c89c399/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c7d368ebeeb9a10be216a93302633915d02c627", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c7d368ebeeb9a10be216a93302633915d02c627", "html_url": "https://github.com/rust-lang/rust/commit/1c7d368ebeeb9a10be216a93302633915d02c627"}], "stats": {"total": 617, "additions": 0, "deletions": 617}, "files": [{"sha": "908ddd0ab418eba0a3d006fddf9d40701d3ca9ac", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50f67de35ed0aadc351e55dad47d49bc7c89c399/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f67de35ed0aadc351e55dad47d49bc7c89c399/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=50f67de35ed0aadc351e55dad47d49bc7c89c399", "patch": "@@ -91,9 +91,6 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n-#[cfg(test)]\n-mod test;\n-\n pub mod pretty;\n \n /// Exit status code used for successful compilation and help output."}, {"sha": "f98939eb40a8e45147178677ce410dd7e1ccfac2", "filename": "src/librustc_driver/test.rs", "status": "removed", "additions": 0, "deletions": 614, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/1c7d368ebeeb9a10be216a93302633915d02c627/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c7d368ebeeb9a10be216a93302633915d02c627/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1c7d368ebeeb9a10be216a93302633915d02c627", "patch": "@@ -1,614 +0,0 @@\n-//! Standalone tests for the inference module.\n-\n-use errors::emitter::Emitter;\n-use errors::{DiagnosticBuilder, Level};\n-use rustc::hir;\n-use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n-use rustc::middle::region;\n-use rustc::session::{DiagnosticOutput, config};\n-use rustc::traits::ObligationCause;\n-use rustc::ty::subst::Subst;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_data_structures::sync;\n-use rustc_target::spec::abi::Abi;\n-use rustc_interface::interface;\n-use syntax::ast;\n-use syntax::feature_gate::UnstableFeatures;\n-use syntax::source_map::FileName;\n-use syntax::symbol::Symbol;\n-\n-struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n-    region_scope_tree: &'a mut region::ScopeTree,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-struct RH<'a> {\n-    id: hir::ItemLocalId,\n-    sub: &'a [RH<'a>],\n-}\n-\n-const EMPTY_SOURCE_STR: &'static str = \"#![feature(no_core)] #![no_core]\";\n-\n-struct ExpectErrorEmitter {\n-    messages: Vec<String>,\n-}\n-\n-fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n-    match lvl {\n-        Level::Bug | Level::Fatal | Level::Error => {}\n-        _ => {\n-            return;\n-        }\n-    }\n-\n-    debug!(\"Error: {}\", msg);\n-    match e.messages.iter().position(|m| msg.contains(m)) {\n-        Some(i) => {\n-            e.messages.remove(i);\n-        }\n-        None => {\n-            debug!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n-            panic!(\"Unexpected error: {} Expected: {:?}\", msg, e.messages);\n-        }\n-    }\n-}\n-\n-impl Emitter for ExpectErrorEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        remove_message(self, &db.message(), db.level);\n-        for child in &db.children {\n-            remove_message(self, &child.message(), child.level);\n-        }\n-    }\n-}\n-\n-fn errors(msgs: &[&str]) -> (Box<dyn Emitter + Send + sync::Send>, usize) {\n-    let mut v: Vec<_> = msgs.iter().map(|m| m.to_string()).collect();\n-    if !v.is_empty() {\n-        v.push(\"aborting due to previous error\".to_owned());\n-    }\n-    (\n-        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + Send + sync::Send>,\n-        msgs.len(),\n-    )\n-}\n-\n-fn test_env<F>(\n-    source_string: &str,\n-    (emitter, expected_err_count): (Box<dyn Emitter + Send + sync::Send>, usize),\n-    body: F,\n-)\n-where\n-    F: FnOnce(Env) + Send,\n-{\n-    let mut opts = config::Options::default();\n-    opts.debugging_opts.verbose = true;\n-    opts.unstable_features = UnstableFeatures::Allow;\n-\n-    // When we're compiling this library with `--test` it'll run as a binary but\n-    // not actually exercise much functionality.\n-    // As a result most of the logic loading the codegen backend is defunkt\n-    // (it assumes we're a dynamic library in a sysroot)\n-    // so let's just use the metadata only backend which doesn't need to load any libraries.\n-    opts.debugging_opts.codegen_backend = Some(\"metadata_only\".to_owned());\n-\n-    let input = config::Input::Str {\n-        name: FileName::anon_source_code(&source_string),\n-        input: source_string.to_string(),\n-    };\n-\n-    let config = interface::Config {\n-        opts,\n-        crate_cfg: Default::default(),\n-        input,\n-        input_path: None,\n-        output_file: None,\n-        output_dir: None,\n-        file_loader: None,\n-        diagnostic_output: DiagnosticOutput::Emitter(emitter),\n-        stderr: None,\n-        crate_name: Some(\"test\".to_owned()),\n-        lint_caps: Default::default(),\n-    };\n-\n-    interface::run_compiler(config, |compiler| {\n-        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n-            tcx.infer_ctxt().enter(|infcx| {\n-                let mut region_scope_tree = region::ScopeTree::default();\n-                let param_env = ty::ParamEnv::empty();\n-                body(Env {\n-                    infcx: &infcx,\n-                    region_scope_tree: &mut region_scope_tree,\n-                    param_env: param_env,\n-                });\n-                let outlives_env = OutlivesEnvironment::new(param_env);\n-                let def_id = tcx.hir().local_def_id(ast::CRATE_NODE_ID);\n-                infcx.resolve_regions_and_report_errors(\n-                    def_id,\n-                    &region_scope_tree,\n-                    &outlives_env,\n-                    SuppressRegionErrors::default(),\n-                );\n-                assert_eq!(tcx.sess.err_count(), expected_err_count);\n-            });\n-        })\n-    });\n-}\n-\n-fn d1() -> ty::DebruijnIndex {\n-    ty::INNERMOST\n-}\n-\n-fn d2() -> ty::DebruijnIndex {\n-    d1().shifted_in(1)\n-}\n-\n-impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    pub fn create_region_hierarchy(\n-        &mut self,\n-        rh: &RH,\n-        parent: (region::Scope, region::ScopeDepth),\n-    ) {\n-        let me = region::Scope {\n-            id: rh.id,\n-            data: region::ScopeData::Node,\n-        };\n-        self.region_scope_tree.record_scope_parent(me, Some(parent));\n-        for child_rh in rh.sub {\n-            self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n-        }\n-    }\n-\n-    pub fn create_simple_region_hierarchy(&mut self) {\n-        // Creates a region hierarchy where 1 is root, 10 and 11 are\n-        // children of 1, etc.\n-\n-        let dscope = region::Scope {\n-            id: hir::ItemLocalId::from_u32(1),\n-            data: region::ScopeData::Destruction,\n-        };\n-        self.region_scope_tree.record_scope_parent(dscope, None);\n-        self.create_region_hierarchy(\n-            &RH {\n-                id: hir::ItemLocalId::from_u32(1),\n-                sub: &[\n-                    RH {\n-                        id: hir::ItemLocalId::from_u32(10),\n-                        sub: &[],\n-                    },\n-                    RH {\n-                        id: hir::ItemLocalId::from_u32(11),\n-                        sub: &[],\n-                    },\n-                ],\n-            },\n-            (dscope, 1),\n-        );\n-    }\n-\n-    #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n-    pub fn lookup_item(&self, names: &[String]) -> hir::HirId {\n-        return match search_mod(self, &self.infcx.tcx.hir().krate().module, 0, names) {\n-            Some(id) => id,\n-            None => {\n-                panic!(\"no item found: `{}`\", names.join(\"::\"));\n-            }\n-        };\n-\n-        fn search_mod(\n-            this: &Env,\n-            m: &hir::Mod,\n-            idx: usize,\n-            names: &[String],\n-        ) -> Option<hir::HirId> {\n-            assert!(idx < names.len());\n-            for item in &m.item_ids {\n-                let item = this.infcx.tcx.hir().expect_item(item.id);\n-                if item.ident.to_string() == names[idx] {\n-                    return search(this, item, idx + 1, names);\n-                }\n-            }\n-            return None;\n-        }\n-\n-        fn search(this: &Env, it: &hir::Item, idx: usize, names: &[String]) -> Option<hir::HirId> {\n-            if idx == names.len() {\n-                return Some(it.hir_id);\n-            }\n-\n-            return match it.node {\n-                hir::ItemKind::Use(..)\n-                | hir::ItemKind::ExternCrate(..)\n-                | hir::ItemKind::Const(..)\n-                | hir::ItemKind::Static(..)\n-                | hir::ItemKind::Fn(..)\n-                | hir::ItemKind::ForeignMod(..)\n-                | hir::ItemKind::GlobalAsm(..)\n-                | hir::ItemKind::Existential(..)\n-                | hir::ItemKind::Ty(..) => None,\n-\n-                hir::ItemKind::Enum(..)\n-                | hir::ItemKind::Struct(..)\n-                | hir::ItemKind::Union(..)\n-                | hir::ItemKind::Trait(..)\n-                | hir::ItemKind::TraitAlias(..)\n-                | hir::ItemKind::Impl(..) => None,\n-\n-                hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n-            };\n-        }\n-    }\n-\n-    pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .sub(a, b)\n-        {\n-            Ok(_) => true,\n-            Err(ref e) => panic!(\"Encountered error: {}\", e),\n-        }\n-    }\n-\n-    pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        self.infcx.can_sub(self.param_env, a, b).is_ok()\n-    }\n-\n-    pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        if !self.is_subtype(a, b) {\n-            panic!(\"{} is not a subtype of {}, but it should be\", a, b);\n-        }\n-    }\n-\n-    pub fn assert_eq(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        self.assert_subtype(a, b);\n-        self.assert_subtype(b, a);\n-    }\n-\n-    pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx\n-            .tcx\n-            .mk_fn_ptr(ty::Binder::bind(self.infcx.tcx.mk_fn_sig(\n-                input_tys.iter().cloned(),\n-                output_ty,\n-                false,\n-                hir::Unsafety::Normal,\n-                Abi::Rust,\n-            )))\n-    }\n-\n-    pub fn t_nil(&self) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_unit()\n-    }\n-\n-    pub fn t_pair(&self, ty1: Ty<'tcx>, ty2: Ty<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.intern_tup(&[ty1, ty2])\n-    }\n-\n-    pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n-        let name = format!(\"T{}\", index);\n-        self.infcx\n-            .tcx\n-            .mk_ty_param(index, Symbol::intern(&name).as_interned_str())\n-    }\n-\n-    pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n-        let name = Symbol::intern(name).as_interned_str();\n-        self.infcx\n-            .tcx\n-            .mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                def_id: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n-                index,\n-                name,\n-            }))\n-    }\n-\n-    pub fn re_late_bound_with_debruijn(\n-        &self,\n-        id: u32,\n-        debruijn: ty::DebruijnIndex,\n-    ) -> ty::Region<'tcx> {\n-        self.infcx\n-            .tcx\n-            .mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n-    }\n-\n-    pub fn t_rptr(&self, r: ty::Region<'tcx>) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n-        let r = self.re_late_bound_with_debruijn(id, d1());\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_late_bound_with_debruijn(\n-        &self,\n-        id: u32,\n-        debruijn: ty::DebruijnIndex,\n-    ) -> Ty<'tcx> {\n-        let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(region::Scope {\n-            id: hir::ItemLocalId::from_u32(id),\n-            data: region::ScopeData::Node,\n-        });\n-        self.infcx\n-            .tcx\n-            .mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n-    }\n-\n-    pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n-        self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: self.infcx.tcx.hir().local_def_id(ast::CRATE_NODE_ID),\n-            bound_region: ty::BrAnon(id),\n-        }))\n-    }\n-\n-    pub fn t_rptr_free(&self, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(id);\n-        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n-    }\n-\n-    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, ()> {\n-        self.infcx\n-            .at(&ObligationCause::dummy(), self.param_env)\n-            .sub(t1, t2)\n-    }\n-\n-    /// Checks that `t1 <: t2` is true (this may register additional\n-    /// region checks).\n-    pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(t1, t2) {\n-            Ok(InferOk {\n-                obligations,\n-                value: (),\n-            }) => {\n-                // None of these tests should require nested obligations.\n-                assert!(obligations.is_empty());\n-            }\n-            Err(ref e) => {\n-                panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn contravariant_region_ptr_ok() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr1 = env.t_rptr_scope(1);\n-        let t_rptr10 = env.t_rptr_scope(10);\n-        env.assert_eq(t_rptr1, t_rptr1);\n-        env.assert_eq(t_rptr10, t_rptr10);\n-        env.make_subtype(t_rptr1, t_rptr10);\n-    })\n-}\n-\n-#[test]\n-fn contravariant_region_ptr_err() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[\"mismatched types\"]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr1 = env.t_rptr_scope(1);\n-        let t_rptr10 = env.t_rptr_scope(10);\n-        env.assert_eq(t_rptr1, t_rptr1);\n-        env.assert_eq(t_rptr10, t_rptr10);\n-\n-        // This will cause an error when regions are resolved.\n-        env.make_subtype(t_rptr10, t_rptr1);\n-    })\n-}\n-\n-#[test]\n-fn sub_bound_free_true() {\n-    //! Test that:\n-    //!\n-    //!     for<'a> fn(&'a isize) <: fn(&'b isize)\n-    //!\n-    //! *does* hold.\n-\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        env.create_simple_region_hierarchy();\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        env.check_sub(\n-            env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n-            env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n-        );\n-    })\n-}\n-\n-/// Test substituting a bound region into a function, which introduces another level of binding.\n-/// This requires adjusting the Debruijn index.\n-#[test]\n-fn subst_ty_renumber_bound() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        // Situation:\n-        // Theta = [A -> &'a foo]\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-\n-        // t_source = fn(A)\n-        let t_source = {\n-            let t_param = env.t_param(0);\n-            env.t_fn(&[t_param], env.t_nil())\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // t_expected = fn(&'a isize)\n-        let t_expected = {\n-            let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_fn(&[t_ptr_bound2], env.t_nil())\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-/// Tests substituting a bound region into a function, which introduces another level of binding.\n-/// This requires adjusting the De Bruijn index.\n-#[test]\n-fn subst_ty_renumber_some_bounds() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        // Situation:\n-        // `Theta = [A -> &'a foo]`\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-\n-        // `t_source = (A, fn(A))`\n-        let t_source = {\n-            let t_param = env.t_param(0);\n-            env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[t_rptr_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // `t_expected = (&'a isize, fn(&'a isize))`\n-        //\n-        // However, note that the Debruijn index is different in the different cases.\n-        let t_expected = {\n-            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-/// Tests that we correctly compute whether a type has escaping regions or not.\n-#[test]\n-fn escaping() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n-        // Situation:\n-        // `Theta = [A -> &'a foo]`\n-        env.create_simple_region_hierarchy();\n-\n-        assert!(!env.t_nil().has_escaping_bound_vars());\n-\n-        let t_rptr_free1 = env.t_rptr_free(1);\n-        assert!(!t_rptr_free1.has_escaping_bound_vars());\n-\n-        let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, d1());\n-        assert!(t_rptr_bound1.has_escaping_bound_vars());\n-\n-        let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-        assert!(t_rptr_bound2.has_escaping_bound_vars());\n-\n-        // `t_fn = fn(A)`\n-        let t_param = env.t_param(0);\n-        assert!(!t_param.has_escaping_bound_vars());\n-        let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!t_fn.has_escaping_bound_vars());\n-    })\n-}\n-\n-/// Tests applying a substitution where the value being substituted for an early-bound region is a\n-/// late-bound region.\n-#[test]\n-fn subst_region_renumber_region() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let re_bound1 = env.re_late_bound_with_debruijn(1, d1());\n-\n-        // `type t_source<'a> = fn(&'a isize)`\n-        let t_source = {\n-            let re_early = env.re_early_bound(0, \"'a\");\n-            env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n-        };\n-\n-        let substs = env.infcx.tcx.intern_substs(&[re_bound1.into()]);\n-        let t_substituted = t_source.subst(env.infcx.tcx, substs);\n-\n-        // `t_expected = fn(&'a isize)`\n-        //\n-        // but not that the Debruijn index is different in the different cases.\n-        let t_expected = {\n-            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-            env.t_fn(&[t_rptr_bound2], env.t_nil())\n-        };\n-\n-        debug!(\n-            \"subst_bound: t_source={:?} substs={:?} t_substituted={:?} t_expected={:?}\",\n-            t_source, substs, t_substituted, t_expected\n-        );\n-\n-        assert_eq!(t_substituted, t_expected);\n-    })\n-}\n-\n-#[test]\n-fn walk_ty() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.isize;\n-        let usize_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n-        let walked: Vec<_> = tup2_ty.walk().collect();\n-        assert_eq!(\n-            walked,\n-            [\n-                tup2_ty, tup1_ty, int_ty, usize_ty, int_ty, usize_ty, tup1_ty, int_ty, usize_ty,\n-                int_ty, usize_ty, usize_ty\n-            ]\n-        );\n-    })\n-}\n-\n-#[test]\n-fn walk_ty_skip_subtree() {\n-    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.isize;\n-        let usize_ty = tcx.types.usize;\n-        let tup1_ty = tcx.intern_tup(&[int_ty, usize_ty, int_ty, usize_ty]);\n-        let tup2_ty = tcx.intern_tup(&[tup1_ty, tup1_ty, usize_ty]);\n-\n-        // types we expect to see (in order), plus a boolean saying\n-        // whether to skip the subtree.\n-        let mut expected = vec![\n-            (tup2_ty, false),\n-            (tup1_ty, false),\n-            (int_ty, false),\n-            (usize_ty, false),\n-            (int_ty, false),\n-            (usize_ty, false),\n-            (tup1_ty, true), // skip the isize/usize/isize/usize\n-            (usize_ty, false),\n-        ];\n-        expected.reverse();\n-\n-        let mut walker = tup2_ty.walk();\n-        while let Some(t) = walker.next() {\n-            debug!(\"walked to {:?}\", t);\n-            let (expected_ty, skip) = expected.pop().unwrap();\n-            assert_eq!(t, expected_ty);\n-            if skip {\n-                walker.skip_current_subtree();\n-            }\n-        }\n-\n-        assert!(expected.is_empty());\n-    })\n-}"}]}