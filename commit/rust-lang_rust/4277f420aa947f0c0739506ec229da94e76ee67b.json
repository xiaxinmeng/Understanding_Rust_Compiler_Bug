{"sha": "4277f420aa947f0c0739506ec229da94e76ee67b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNzdmNDIwYWE5NDdmMGMwNzM5NTA2ZWMyMjlkYTk0ZTc2ZWU2N2I=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2019-01-18T14:17:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-19T12:37:26Z"}, "message": "Replace Expectation by &Ty in `infer_pat` method", "tree": {"sha": "b70a618670b95bf89a1c77fbe57e43c9d925cd79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b70a618670b95bf89a1c77fbe57e43c9d925cd79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4277f420aa947f0c0739506ec229da94e76ee67b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4277f420aa947f0c0739506ec229da94e76ee67b", "html_url": "https://github.com/rust-lang/rust/commit/4277f420aa947f0c0739506ec229da94e76ee67b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4277f420aa947f0c0739506ec229da94e76ee67b/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9a6050034b2ab4358d8a46dd8432de41cebdf0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a6050034b2ab4358d8a46dd8432de41cebdf0c", "html_url": "https://github.com/rust-lang/rust/commit/f9a6050034b2ab4358d8a46dd8432de41cebdf0c"}], "stats": {"total": 47, "additions": 23, "deletions": 24}, "files": [{"sha": "b880fb3d88c97591e25b055fca9628320d740ffa", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4277f420aa947f0c0739506ec229da94e76ee67b/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4277f420aa947f0c0739506ec229da94e76ee67b/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4277f420aa947f0c0739506ec229da94e76ee67b", "patch": "@@ -902,7 +902,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .get(i)\n                 .and_then(|field| field.ty(self.db))\n                 .unwrap_or(Ty::Unknown);\n-            self.infer_pat(subpat, &Expectation::has_type(expected_ty));\n+            self.infer_pat(subpat, &expected_ty);\n         }\n \n         ty\n@@ -918,45 +918,45 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let expected_ty = matching_field\n                 .and_then(|field| field.ty(self.db))\n                 .unwrap_or(Ty::Unknown);\n-            self.infer_pat(subpat.pat, &Expectation::has_type(expected_ty));\n+            self.infer_pat(subpat.pat, &expected_ty);\n         }\n \n         ty\n     }\n \n-    fn infer_pat(&mut self, pat: PatId, expected: &Expectation) -> Ty {\n+    fn infer_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n         let ty = match &body[pat] {\n             Pat::Tuple(ref args) => {\n-                // this can probably be done without cloning/ collecting\n-                let expectations = match expected.ty {\n-                    Ty::Tuple(ref tuple_args) if args.len() == tuple_args.len() => {\n-                        tuple_args.iter().cloned().collect()\n-                    }\n-                    _ => vec![Ty::Unknown; args.len()],\n+                let expectations = match *expected {\n+                    Ty::Tuple(ref tuple_args) => &**tuple_args,\n+                    _ => &[],\n                 };\n+                let expectations_iter = expectations\n+                    .into_iter()\n+                    .chain(std::iter::repeat(&Ty::Unknown));\n \n                 let inner_tys = args\n                     .iter()\n-                    .zip(expectations.into_iter())\n-                    .map(|(&pat, ty)| self.infer_pat(pat, &Expectation::has_type(ty)))\n+                    .zip(expectations_iter)\n+                    .map(|(&pat, ty)| self.infer_pat(pat, ty))\n                     .collect::<Vec<_>>()\n                     .into();\n \n                 Ty::Tuple(inner_tys)\n             }\n             Pat::Ref { pat, mutability } => {\n-                let expectation = match expected.ty {\n+                let expectation = match *expected {\n                     Ty::Ref(ref sub_ty, exp_mut) => {\n                         if *mutability != exp_mut {\n                             // TODO: emit type error?\n                         }\n-                        Expectation::has_type((&**sub_ty).clone())\n+                        &**sub_ty\n                     }\n-                    _ => Expectation::none(),\n+                    _ => &Ty::Unknown,\n                 };\n-                let subty = self.infer_pat(*pat, &expectation);\n+                let subty = self.infer_pat(*pat, expectation);\n                 Ty::Ref(subty.into(), *mutability)\n             }\n             Pat::TupleStruct {\n@@ -980,7 +980,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let subty = if let Some(subpat) = subpat {\n                     self.infer_pat(*subpat, expected)\n                 } else {\n-                    expected.ty.clone()\n+                    expected.clone()\n                 };\n \n                 match mode {\n@@ -993,7 +993,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, &expected.ty);\n+        self.unify(&ty, expected);\n         let ty = self.resolve_ty_as_possible(ty);\n         self.write_pat_ty(pat, ty.clone());\n         ty\n@@ -1040,7 +1040,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 pat,\n             } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                self.infer_pat(*pat, &Expectation::none());\n+                self.infer_pat(*pat, &Ty::Unknown);\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -1054,9 +1054,9 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n                     let expected = if let Some(type_ref) = arg_type {\n                         let ty = self.make_ty(type_ref);\n-                        Expectation::has_type(ty)\n+                        ty\n                     } else {\n-                        Expectation::none()\n+                        Ty::Unknown\n                     };\n                     self.infer_pat(*arg_pat, &expected);\n                 }\n@@ -1126,11 +1126,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     expected.clone()\n                 };\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n-                let pat_expectation = Expectation::has_type(input_ty);\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &pat_expectation);\n+                        let _pat_ty = self.infer_pat(pat, &input_ty);\n                     }\n                     // TODO type the guard\n                     self.infer_expr(arm.expr, &expected);\n@@ -1323,7 +1322,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         decl_ty\n                     };\n \n-                    self.infer_pat(*pat, &Expectation::has_type(ty));\n+                    self.infer_pat(*pat, &ty);\n                 }\n                 Statement::Expr(expr) => {\n                     self.infer_expr(*expr, &Expectation::none());\n@@ -1344,7 +1343,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let ty = self.make_ty(type_ref);\n             let ty = self.insert_type_vars(ty);\n \n-            self.infer_pat(*pat, &Expectation::has_type(ty));\n+            self.infer_pat(*pat, &ty);\n         }\n         self.return_ty = {\n             let ty = self.make_ty(signature.ret_type());"}]}