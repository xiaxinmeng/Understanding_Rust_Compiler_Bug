{"sha": "ef4becdce4198107507734246f6ffd053d0b8c67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNGJlY2RjZTQxOTgxMDc1MDc3MzQyNDZmNmZmZDA1M2QwYjhjNjc=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-11T18:24:34Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-08-22T18:23:31Z"}, "message": "Split try_execute_query.", "tree": {"sha": "b87aeef8d53819f8774daea3abfebac8f97342f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b87aeef8d53819f8774daea3abfebac8f97342f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4becdce4198107507734246f6ffd053d0b8c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4becdce4198107507734246f6ffd053d0b8c67", "html_url": "https://github.com/rust-lang/rust/commit/ef4becdce4198107507734246f6ffd053d0b8c67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4becdce4198107507734246f6ffd053d0b8c67/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "307aacaf05419fbd45c9c5c428cb1004801f455b", "url": "https://api.github.com/repos/rust-lang/rust/commits/307aacaf05419fbd45c9c5c428cb1004801f455b", "html_url": "https://github.com/rust-lang/rust/commit/307aacaf05419fbd45c9c5c428cb1004801f455b"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "79fbde9585045d6c31e748d934e14fc23a478710", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ef4becdce4198107507734246f6ffd053d0b8c67/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4becdce4198107507734246f6ffd053d0b8c67/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=ef4becdce4198107507734246f6ffd053d0b8c67", "patch": "@@ -411,18 +411,22 @@ where\n     C::Key: Clone + DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::<'_, CTX::DepKind, C::Key>::try_start(\n+    match JobOwner::<'_, CTX::DepKind, C::Key>::try_start(\n         &tcx,\n         state,\n         span,\n         key.clone(),\n         lookup,\n         query.dep_kind,\n     ) {\n-        TryGetJob::NotYetStarted(job) => job,\n+        TryGetJob::NotYetStarted(job) => {\n+            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id, compute);\n+            let result = job.complete(cache, result, dep_node_index);\n+            (result, Some(dep_node_index))\n+        }\n         TryGetJob::Cycle(error) => {\n             let result = mk_cycle(tcx, error, query.handle_cycle_error, &cache.cache);\n-            return (result, None);\n+            (result, None)\n         }\n         #[cfg(parallel_compiler)]\n         TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n@@ -440,27 +444,40 @@ where\n             }\n             query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n \n-            return (v, Some(index));\n+            (v, Some(index))\n         }\n-    };\n+    }\n+}\n \n+fn execute_job<CTX, K, V>(\n+    tcx: CTX,\n+    key: K,\n+    dep_node: Option<DepNode<CTX::DepKind>>,\n+    query: &QueryVtable<CTX, K, V>,\n+    job_id: QueryJobId<CTX::DepKind>,\n+    compute: fn(CTX::DepContext, K) -> V,\n+) -> (V, DepNodeIndex)\n+where\n+    K: Clone + DepNodeParams<CTX::DepContext>,\n+    V: Debug,\n+    CTX: QueryContext,\n+{\n     let dep_graph = tcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job.id, None, || compute(*tcx.dep_context(), key));\n+        let result = tcx.start_query(job_id, None, || compute(*tcx.dep_context(), key));\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-        let result = job.complete(cache, result, dep_node_index);\n-        return (result, None);\n+        return (result, dep_node_index);\n     }\n \n-    let (result, dep_node_index) = if query.anon {\n+    if query.anon {\n         let prof_timer = tcx.dep_context().profiler().query_provider();\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n-            tcx.start_query(job.id, diagnostics, || {\n+            tcx.start_query(job_id, diagnostics, || {\n                 dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n                     compute(*tcx.dep_context(), key)\n                 })\n@@ -479,24 +496,22 @@ where\n     } else if query.eval_always {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n-        force_query_with_job(tcx, key, job.id, dep_node, query, compute)\n+        force_query_with_job(tcx, key, job_id, dep_node, query, compute)\n     } else {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node = dep_node.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n         // The diagnostics for this query will be\n         // promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        let loaded = tcx.start_query(job.id, None, || {\n+        let loaded = tcx.start_query(job_id, None, || {\n             try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query, compute)\n         });\n         if let Some((result, dep_node_index)) = loaded {\n             (result, dep_node_index)\n         } else {\n-            force_query_with_job(tcx, key, job.id, dep_node, query, compute)\n+            force_query_with_job(tcx, key, job_id, dep_node, query, compute)\n         }\n-    };\n-    let result = job.complete(cache, result, dep_node_index);\n-    (result, Some(dep_node_index))\n+    }\n }\n \n fn try_load_from_disk_and_cache_in_memory<CTX, K, V>("}]}