{"sha": "c5db290bf6df986a6acd5ce993f278c18e55ca37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZGIyOTBiZjZkZjk4NmE2YWNkNWNlOTkzZjI3OGMxOGU1NWNhMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T00:46:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-16T00:46:43Z"}, "message": "Auto merge of #22367 - Manishearth:rollup, r=steveklabnik\n\n(still testing locally)", "tree": {"sha": "5a67ed2bb3601bc1d5f477057324421fbd2291c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a67ed2bb3601bc1d5f477057324421fbd2291c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5db290bf6df986a6acd5ce993f278c18e55ca37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5db290bf6df986a6acd5ce993f278c18e55ca37", "html_url": "https://github.com/rust-lang/rust/commit/c5db290bf6df986a6acd5ce993f278c18e55ca37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5db290bf6df986a6acd5ce993f278c18e55ca37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "342ab53bf858a89e418973ba3bfff55161c0b174", "url": "https://api.github.com/repos/rust-lang/rust/commits/342ab53bf858a89e418973ba3bfff55161c0b174", "html_url": "https://github.com/rust-lang/rust/commit/342ab53bf858a89e418973ba3bfff55161c0b174"}, {"sha": "cea2bbfe27707becaacad1ce64b835b408c0ccf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/cea2bbfe27707becaacad1ce64b835b408c0ccf8", "html_url": "https://github.com/rust-lang/rust/commit/cea2bbfe27707becaacad1ce64b835b408c0ccf8"}], "stats": {"total": 1529, "additions": 1012, "deletions": 517}, "files": [{"sha": "9d7c939ff9de8a28aa48a28b4516c21da80b5dc5", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -5,16 +5,10 @@ documentation.\n \n ## Quick Start\n \n-1. Download a [binary installer][installer] for your platform.\n-2. Read [The Rust Programming Language][trpl].\n-3. Enjoy!\n+Read [\"Installing Rust\"][install] from [The Book][trpl].\n \n-> ***Note:*** Windows users can read the detailed\n-> [using Rust on Windows][win-wiki] notes on the wiki.\n-\n-[installer]: http://www.rust-lang.org/install.html\n+[install]: http://doc.rust-lang.org/book/installing-rust.html\n [trpl]: http://doc.rust-lang.org/book/index.html\n-[win-wiki]: https://github.com/rust-lang/rust/wiki/Using-Rust-on-Windows\n \n ## Building from Source\n \n@@ -52,8 +46,6 @@ documentation.\n     When complete, `make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool.\n-3. Read [The Rust Programming Language][trpl].\n-4. Enjoy!\n \n ### Building on Windows\n \n@@ -81,7 +73,6 @@ $ pacman -S base-devel\n \n [repo]: https://github.com/rust-lang/rust\n [tarball]: https://static.rust-lang.org/dist/rustc-nightly-src.tar.gz\n-[trpl]: http://doc.rust-lang.org/book/index.html\n \n ## Notes\n "}, {"sha": "831225556f3fc8d4beade567fe09f69afff9e6a7", "filename": "mk/dist.mk", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -109,8 +109,6 @@ distcheck-tar-src: dist-tar-src\n # Unix binary installer tarballs\n ######################################################################\n \n-NON_INSTALLED_PREFIXES=COPYRIGHT,LICENSE-APACHE,LICENSE-MIT,README.md,version\n-\n define DEF_INSTALLER\n \n $$(eval $$(call DEF_PREPARE,dir-$(1)))\n@@ -124,19 +122,23 @@ dist-install-dir-$(1): PREPARE_LIB_CMD=$(DEFAULT_PREPARE_LIB_CMD)\n dist-install-dir-$(1): PREPARE_MAN_CMD=$(DEFAULT_PREPARE_MAN_CMD)\n dist-install-dir-$(1): PREPARE_CLEAN=true\n dist-install-dir-$(1): prepare-base-dir-$(1) docs compiler-docs\n-\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)COPYRIGHT $$(PREPARE_DEST_DIR)\n-\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)\n-\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)\n-\t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)\n \t$$(Q)mkdir -p $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)COPYRIGHT $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-APACHE $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)LICENSE-MIT $$(PREPARE_DEST_DIR)/share/doc/rust\n \t$$(Q)$$(PREPARE_MAN_CMD) $$(S)README.md $$(PREPARE_DEST_DIR)/share/doc/rust\n+\n+prepare-overlay-$(1):\n+\t$$(Q)rm -Rf tmp/dist/$$(PKG_NAME)-$(1)-overlay\n+\t$$(Q)mkdir -p tmp/dist/$$(PKG_NAME)-$(1)-overlay\n+\t$$(Q)cp $$(S)COPYRIGHT tmp/dist/$$(PKG_NAME)-$(1)-overlay/\n+\t$$(Q)cp $$(S)LICENSE-APACHE tmp/dist/$$(PKG_NAME)-$(1)-overlay/\n+\t$$(Q)cp $$(S)LICENSE-MIT tmp/dist/$$(PKG_NAME)-$(1)-overlay/\n+\t$$(Q)cp $$(S)README.md tmp/dist/$$(PKG_NAME)-$(1)-overlay/\n # This tiny morsel of metadata is used by rust-packaging\n-\t$$(Q)echo \"$(CFG_VERSION)\" > $$(PREPARE_DEST_DIR)/version\n+\t$$(Q)echo \"$(CFG_VERSION)\" > tmp/dist/$$(PKG_NAME)-$(1)-overlay/version\n \n-dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1)\n+dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1) prepare-overlay-$(1)\n \t@$(call E, build: $$@)\n # Copy essential gcc components into installer\n ifdef CFG_WINDOWSY_$(1)\n@@ -146,13 +148,12 @@ ifdef CFG_WINDOWSY_$(1)\n endif\n \t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n \t\t--product-name=Rust \\\n-\t\t--verify-bin=rustc \\\n \t\t--rel-manifest-dir=rustlib \\\n \t\t--success-message=Rust-is-ready-to-roll. \\\n \t\t--image-dir=tmp/dist/$$(PKG_NAME)-$(1)-image \\\n \t\t--work-dir=tmp/dist \\\n \t\t--output-dir=dist \\\n-\t\t--non-installed-prefixes=$$(NON_INSTALLED_PREFIXES) \\\n+\t\t--non-installed-overlay=tmp/dist/$$(PKG_NAME)-$(1)-overlay \\\n \t\t--package-name=$$(PKG_NAME)-$(1) \\\n \t\t--component-name=rustc \\\n \t\t--legacy-manifest-dirs=rustlib,cargo"}, {"sha": "4c2c1243c65a4c03757bc062f6e5fc5c9bcd85b3", "filename": "mk/docs.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -27,7 +27,7 @@\n ######################################################################\n DOCS := index intro tutorial complement-bugreport \\\n     complement-lang-faq complement-design-faq complement-project-faq \\\n-    rustdoc reference\n+    rustdoc reference grammar\n \n # Legacy guides, preserved for a while to reduce the number of 404s\n DOCS += guide-crates guide-error-handling guide-ffi guide-macros guide \\"}, {"sha": "9752ee233b6e3ab0035f30af74c0cf047362046f", "filename": "mk/main.mk", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -18,7 +18,7 @@ CFG_RELEASE_NUM=1.0.0\n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n # versions (section 9)\n-CFG_PRERELEASE_VERSION=.1\n+CFG_PRERELEASE_VERSION=.2\n \n CFG_FILENAME_EXTRA=4e7c5e5c\n \n@@ -30,8 +30,8 @@ CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n-CFG_RELEASE=$(CFG_RELEASE_NUM)-beta$(CFG_PRERELEASE_VERSION)\n-CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-beta$(CFG_PRERELEASE_VERSION)\n+CFG_RELEASE=$(CFG_RELEASE_NUM)-alpha$(CFG_PRERELEASE_VERSION)\n+CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-alpha$(CFG_PRERELEASE_VERSION)\n CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)\n@@ -61,13 +61,16 @@ SPACE :=\n SPACE +=\n ifneq ($(CFG_GIT),)\n ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n-    CFG_VER_DATE = $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 --pretty=format:'%ci')\n+    CFG_VER_DATE = $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 --date=short --pretty=format:'%cd')\n     CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n     CFG_SHORT_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse --short=9 HEAD)\n     CFG_VERSION += ($(CFG_SHORT_VER_HASH) $(CFG_VER_DATE))\n endif\n endif\n \n+CFG_BUILD_DATE = $(shell date +%F)\n+CFG_VERSION += (built $(CFG_BUILD_DATE))\n+\n # Windows exe's need numeric versions - don't use anything but\n # numbers and dots here\n CFG_VERSION_WIN = $(CFG_RELEASE_NUM)\n@@ -317,6 +320,7 @@ endif\n ifdef CFG_VER_HASH\n export CFG_VER_HASH\n endif\n+export CFG_BUILD_DATE\n export CFG_VERSION\n export CFG_VERSION_WIN\n export CFG_RELEASE"}, {"sha": "6b6251a96c944731ad1f3afd3ba8481a074e604e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -16,7 +16,7 @@\n #![feature(io)]\n #![feature(path)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(unboxed_closures)]\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(unicode)]"}, {"sha": "1a28cd682e70c626c3dba7feda3ff4b33acdf8f9", "filename": "src/doc/complement-bugreport.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fcomplement-bugreport.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fcomplement-bugreport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-bugreport.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -56,8 +56,6 @@ $ RUST_BACKTRACE=1 rustc ...\n \n # I submitted a bug, but nobody has commented on it!\n \n-This is sad, but does happen sometimes, since we're short-staffed. If you\n-submit a bug and you haven't received a comment on it within 3 business days,\n-it's entirely reasonable to either ask on the #rust IRC channel,\n-or post on the [rust-dev mailing list](https://mail.mozilla.org/listinfo/rust-dev)\n-to ask what the status of the bug is.\n+This is sad, but does happen sometimes, since we're short-staffed. If you submit a\n+bug and you haven't received a comment on it within 3 business days, it's entirely\n+reasonable to ask about the status of the bug in #rust on irc.mozilla.org."}, {"sha": "d7a29ea530952a4f28a934c0834fce2558f7e845", "filename": "src/doc/grammar.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1,6 +1,4 @@\n-# **This is a work in progress**\n-\n-% The Rust Grammar\n+% Grammar\n \n # Introduction\n \n@@ -570,7 +568,7 @@ binop_expr : expr binop expr ;\n The precedence of Rust binary operators is ordered as follows, going from\n strong to weak:\n \n-```\n+```text\n * / %\n as\n + -"}, {"sha": "90a018c2dddb857f347e03df7c32da29c3a11d10", "filename": "src/doc/intro.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -224,7 +224,7 @@ segfault when we allocate more memory?\n \n The answer is that in the C++ version, `x` is a *reference* to the memory\n location where the first element of the array is stored. But in Ruby, `x` is a\n-standalone value, not connected to the underyling array at all. Let's dig into\n+standalone value, not connected to the underlying array at all. Let's dig into\n the details for a moment. Your program has access to memory, provided to it by\n the operating system. Each location in memory has an address.  So when we make\n our vector, `v`, it's stored in a memory location somewhere:"}, {"sha": "3223e2f2626530ff8f11c0c1d8d6ff366fab2ae1", "filename": "src/doc/reference.md", "status": "modified", "additions": 71, "deletions": 22, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -5,9 +5,7 @@\n This document is the primary reference for the Rust programming language. It\n provides three kinds of material:\n \n-  - Chapters that formally define the language grammar and, for each\n-    construct, informally describe its semantics and give examples of its\n-    use.\n+  - Chapters that informally describe each language construct and their use.\n   - Chapters that informally describe the memory model, concurrency model,\n     runtime services, linkage model and debugging facilities.\n   - Appendix chapters providing rationale and references to languages that\n@@ -23,8 +21,11 @@ separately by extracting documentation attributes from their source code. Many\n of the features that one might expect to be language features are library\n features in Rust, so what you're looking for may be there, not here.\n \n+You may also be interested in the [grammar].\n+\n [book]: book/index.html\n [standard]: std/index.html\n+[grammar]: grammar.html\n \n # Notation\n \n@@ -2377,21 +2378,33 @@ considered off, and using the features will result in a compiler error.\n \n The currently implemented features of the reference compiler are:\n \n+* `advanced_slice_patterns` - see the [match expressions](#match-expressions)\n+                              section for discussion; the exact semantics of\n+                              slice patterns are subject to change.\n+\n * `asm` - The `asm!` macro provides a means for inline assembly. This is often\n           useful, but the exact syntax for this feature along with its\n           semantics are likely to change, so this macro usage must be opted\n           into.\n \n+* `associated_types` - Allows type aliases in traits. Experimental.\n+\n+* `box_patterns` - Allows `box` patterns, the exact semantics of which\n+                   is subject to change.\n+\n+* `box_syntax` - Allows use of `box` expressions, the exact semantics of which\n+                 is subject to change.\n+\n * `concat_idents` - Allows use of the `concat_idents` macro, which is in many\n                     ways insufficient for concatenating identifiers, and may be\n                     removed entirely for something more wholesome.\n \n-* `default_type_params` - Allows use of default type parameters. The future of\n-                          this feature is uncertain.\n-\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n+* `int_uint` - Allows the use of the `int` and `uint` types, which are deprecated.\n+               Use `isize` and `usize` instead.\n+\n * `lang_items` - Allows use of the `#[lang]` attribute. Like `intrinsics`,\n                  lang items are inherently unstable and no promise about them\n                  is made.\n@@ -2410,12 +2423,33 @@ The currently implemented features of the reference compiler are:\n * `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n                  nasty hack that will certainly be removed.\n \n+* `main` - Allows use of the `#[main]` attribute, which changes the entry point\n+           into a Rust program. This capabiilty is subject to change.\n+\n+* `macro_reexport` - Allows macros to be re-exported from one crate after being imported\n+                     from another. This feature was originally designed with the sole\n+                     use case of the Rust standard library in mind, and is subject to\n+                     change.\n+\n * `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n                        but the implementation is a little rough around the\n                        edges, so this can be seen as an experimental feature\n                        for now until the specification of identifiers is fully\n                        fleshed out.\n \n+* `no_std` - Allows the `#![no_std]` crate attribute, which disables the implicit\n+             `extern crate std`. This typically requires use of the unstable APIs\n+             behind the libstd \"facade\", such as libcore and libcollections. It\n+             may also cause problems when using syntax extensions, including\n+             `#[derive]`.\n+\n+* `on_unimplemented` - Allows the `#[rustc_on_unimplemented]` attribute, which allows\n+                       trait definitions to add specialized notes to error messages\n+                       when an implementation was expected but not found.\n+\n+* `optin_builtin_traits` - Allows the definition of default and negative trait\n+                           implementations. Experimental.\n+\n * `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n              These depend on compiler internals and are subject to change.\n \n@@ -2431,8 +2465,15 @@ The currently implemented features of the reference compiler are:\n * `simd` - Allows use of the `#[simd]` attribute, which is overly simple and\n            not the SIMD interface we want to expose in the long term.\n \n+* `simd_ffi` - Allows use of SIMD vectors in signatures for foreign functions.\n+               The SIMD interface is subject to change.\n+\n * `staged_api` - Allows usage of stability markers and `#![staged_api]` in a crate\n \n+* `start` - Allows use of the `#[start]` attribute, which changes the entry point\n+            into a Rust program. This capabiilty, especially the signature for the\n+            annotated function, is subject to change.\n+\n * `struct_inherit` - Allows using struct inheritance, which is barely\n                      implemented and will probably be removed. Don't use this.\n \n@@ -2460,18 +2501,20 @@ The currently implemented features of the reference compiler are:\n                         which is considered wildly unsafe and will be\n                         obsoleted by language improvements.\n \n+* `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n+                          which removes hidden flag added to a type that\n+                          implements the `Drop` trait. The design for the\n+                          `Drop` flag is subject to change, and this feature\n+                          may be removed in the future.\n+\n * `unmarked_api` - Allows use of items within a `#![staged_api]` crate\n                    which have not been marked with a stability marker.\n                    Such items should not be allowed by the compiler to exist,\n                    so if you need this there probably is a compiler bug.\n \n-* `associated_types` - Allows type aliases in traits. Experimental.\n-\n-* `no_std` - Allows the `#![no_std]` crate attribute, which disables the implicit\n-             `extern crate std`. This typically requires use of the unstable APIs\n-             behind the libstd \"facade\", such as libcore and libcollections. It\n-             may also cause problems when using syntax extensions, including\n-             `#[derive]`.\n+* `visible_private_types` - Allows public APIs to expose otherwise private\n+                            types, e.g. as the return type of a public function.\n+                            This capability may be removed in the future.\n \n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about #[feature] directives which enabled\n@@ -2591,9 +2634,8 @@ of any reference that points to it.\n \n When a [local variable](#memory-slots) is used as an\n [rvalue](#lvalues,-rvalues-and-temporaries) the variable will either be moved\n-or copied, depending on its type. For types that contain [owning\n-pointers](#pointer-types) or values that implement the special trait `Drop`,\n-the variable is moved. All other types are copied.\n+or copied, depending on its type. All values whose type implements `Copy` are\n+copied, all others are moved.\n \n ### Literal expressions\n \n@@ -2701,9 +2743,19 @@ items can bring new names into scopes and declared items are in scope for only\n the block itself.\n \n A block will execute each statement sequentially, and then execute the\n-expression (if given). If the final expression is omitted, the type and return\n-value of the block are `()`, but if it is provided, the type and return value\n-of the block are that of the expression itself.\n+expression (if given). If the block ends in a statement, its value is `()`:\n+\n+```\n+let x: () = { println!(\"Hello.\"); };\n+```\n+\n+If it ends in an expression, its value and type are that of the expression:\n+\n+```\n+let x: i32 = { println!(\"Hello.\"); 5 };\n+\n+assert_eq!(5, x);\n+```\n \n ### Method-call expressions\n \n@@ -3502,9 +3554,6 @@ elements, respectively, in a parenthesized, comma-separated list.\n Because tuple elements don't have a name, they can only be accessed by\n pattern-matching.\n \n-The members of a tuple are laid out in memory contiguously, in order specified\n-by the tuple type.\n-\n An example of a tuple type and its use:\n \n ```"}, {"sha": "d4e2ad5cd5f66fa7973a0214b130afa660a411aa", "filename": "src/doc/trpl/arrays-vectors-and-slices.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Farrays-vectors-and-slices.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -49,8 +49,8 @@ languages.\n \n A *vector* is a dynamic or \"growable\" array, implemented as the standard\n library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n-later). Vectors are to arrays what `String` is to `&str`. You can create them\n-with the `vec!` macro:\n+later). Vectors always allocate their data on the heap. Vectors are to slices \n+what `String` is to `&str`. You can create them with the `vec!` macro:\n \n ```{rust}\n let v = vec![1, 2, 3]; // v: Vec<i32>"}, {"sha": "dea19fa73fb49f39d39012197dada67734a629b9", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -263,15 +263,12 @@ let four_is_smaller = four <= ten;\n let four_equals_ten = four == ten;\n ```\n \n-This may seem rather limiting, particularly equality being invalid; in\n-many cases however, it's unnecessary. Rust provides the [`match`][match]\n-keyword, which will be examined in more detail in the next section, which\n-often allows better and easier branch control than a series of `if`/`else`\n-statements would. However, for our [game][game] we need the comparisons\n-to work so we will utilize the `Ordering` `enum` provided by the standard\n-library which supports such comparisons. It has this form:\n+This may seem rather limiting, but it's a limitation which we can overcome.\n+There are two ways: by implementing equality ourselves, or by using the\n+[`match`][match] keyword. We don't know enough about Rust to implement equality\n+yet, but we can use the `Ordering` enum from the standard library, which does:\n \n-```{rust}\n+```\n enum Ordering {\n     Less,\n     Equal,"}, {"sha": "3c933c1c5af5856484dd4fdb992c4b4423d414ff", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -171,7 +171,7 @@ use std::time::Duration;\n fn main() {\n     let mut data = vec![1u32, 2, 3];\n \n-    for i in 0 .. 2 {\n+    for i in 0..2 {\n         Thread::spawn(move || {\n             data[i] += 1;\n         });\n@@ -211,7 +211,7 @@ use std::sync::Mutex;\n fn main() {\n     let mut data = Mutex::new(vec![1u32, 2, 3]);\n \n-    for i in 0 .. 2 {\n+    for i in 0..2 {\n         let data = data.lock().unwrap();\n         Thread::spawn(move || {\n             data[i] += 1;\n@@ -262,7 +262,7 @@ use std::time::Duration;\n fn main() {\n     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n \n-    for i in (0us..2) {\n+    for i in 0us..2 {\n         let data = data.clone();\n         Thread::spawn(move || {\n             let mut data = data.lock().unwrap();\n@@ -285,7 +285,7 @@ thread more closely:\n # use std::time::Duration;\n # fn main() {\n #     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n-#     for i in (0us..2) {\n+#     for i in 0us..2 {\n #         let data = data.clone();\n Thread::spawn(move || {\n     let mut data = data.lock().unwrap();\n@@ -323,7 +323,7 @@ fn main() {\n \n     let (tx, rx) = mpsc::channel();\n \n-    for _ in (0..10) {\n+    for _ in 0..10 {\n         let (data, tx) = (data.clone(), tx.clone());\n \n         Thread::spawn(move || {\n@@ -334,7 +334,7 @@ fn main() {\n         });\n     }\n \n-    for _ in 0 .. 10 {\n+    for _ in 0..10 {\n         rx.recv();\n     }\n }"}, {"sha": "1f5d3eadae3b9204b7836a838d5f2ce91563cb42", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -20,7 +20,7 @@ you to partition your code within the crate itself.\n \n As an example, let's make a *phrases* crate, which will give us various phrases\n in different languages. To keep things simple, we'll stick to \"greetings\" and\n-\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e\uff09 as\n+\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e) as\n two languages for those phrases to be in. We'll use this module layout:\n \n ```text"}, {"sha": "2651949747952748af855976566024ea941d1e1f", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1,4 +1,4 @@\n-% Rust Documentation\n+% Documentation\n \n `rustdoc` is the built-in tool for generating documentation. It integrates\n with the compiler to provide accurate hyperlinking between usage of types and\n@@ -294,3 +294,26 @@ Documentation` on the first line).\n Like with a Rust crate, the `--test` argument will run the code\n examples to check they compile, and obeys any `--test-args` flags. The\n tests are named after the last `#` heading.\n+\n+# Re-exports\n+\n+Rustdoc will show the documentation for a publc re-export in both places:\n+\n+```{rust,ignore}\n+extern crate foo;\n+\n+pub use foo::bar;\n+```\n+\n+This will create documentation for `bar` both inside the documentation for\n+the crate `foo`, as well as the documentation for your crate. It will use\n+the same documentation in both places.\n+\n+This behavior can be supressed with `no_inline`:\n+\n+```{rust,ignore}\n+extern crate foo;\n+\n+#[doc(no_inline)]\n+pub use foo::bar;\n+```"}, {"sha": "f2b95f19edce21336c808454969cc3ff27f50ac5", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -420,7 +420,7 @@ fn main() {\n ```\n \n Alternatively, you may need to alter global state provided by a foreign\n-interface. To do this, statics can be declared with `mut` so rust can mutate\n+interface. To do this, statics can be declared with `mut` so we can mutate\n them.\n \n ```no_run\n@@ -436,12 +436,19 @@ extern {\n \n fn main() {\n     let prompt = CString::from_slice(b\"[my-awesome-shell] $\");\n-    unsafe { rl_prompt = prompt.as_ptr(); }\n-    // get a line, process it\n-    unsafe { rl_prompt = ptr::null(); }\n+    unsafe { \n+        rl_prompt = prompt.as_ptr();\n+\n+        println!(\"{:?}\", rl_prompt);\n+\n+        rl_prompt = ptr::null();\n+    }\n }\n ```\n \n+Note that all interaction with a `static mut` is unsafe, both reading and\n+writing. Dealing with global mutable state requires a great deal of care.\n+\n # Foreign calling conventions\n \n Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when"}, {"sha": "ca1385fde9c74950d8992e3e33646ba540a7a40c", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -2,7 +2,7 @@\n \n You've already seen one function so far, the `main` function:\n \n-```{rust}\n+```rust\n fn main() {\n }\n ```\n@@ -12,22 +12,22 @@ This is the simplest possible function declaration. As we mentioned before,\n this function takes no arguments, and then some curly braces to indicate the\n body. Here's a function named `foo`:\n \n-```{rust}\n+```rust\n fn foo() {\n }\n ```\n \n So, what about taking arguments? Here's a function that prints a number:\n \n-```{rust}\n+```rust\n fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n \n Here's a complete program that uses `print_number`:\n \n-```{rust}\n+```rust\n fn main() {\n     print_number(5);\n }\n@@ -42,7 +42,7 @@ you add a type to the argument name, after a colon.\n \n Here's a complete program that adds two numbers together and prints them:\n \n-```{rust}\n+```rust\n fn main() {\n     print_sum(5, 6);\n }\n@@ -58,9 +58,9 @@ as when you declare it.\n Unlike `let`, you _must_ declare the types of function arguments. This does\n not work:\n \n-```{ignore}\n+```{rust,ignore}\n fn print_sum(x, y) {\n-    println!(\"x is: {}\", x + y);\n+    println!(\"sum is: {}\", x + y);\n }\n ```\n \n@@ -79,7 +79,7 @@ sweet spot between full inference and no inference.\n \n What about returning a value? Here's a function that adds one to an integer:\n \n-```{rust}\n+```rust\n fn add_one(x: i32) -> i32 {\n     x + 1\n }\n@@ -90,7 +90,7 @@ Rust functions return exactly one value, and you declare the type after an\n \n You'll note the lack of a semicolon here. If we added it in:\n \n-```{ignore}\n+```{rust,ignore}\n fn add_one(x: i32) -> i32 {\n     x + 1;\n }\n@@ -123,7 +123,7 @@ semicolon in a return position would cause a bug.\n \n But what about early returns? Rust does have a keyword for that, `return`:\n \n-```{rust}\n+```rust\n fn foo(x: i32) -> i32 {\n     if x < 5 { return x; }\n \n@@ -134,7 +134,7 @@ fn foo(x: i32) -> i32 {\n Using a `return` as the last line of a function works, but is considered poor\n style:\n \n-```{rust}\n+```rust\n fn foo(x: i32) -> i32 {\n     if x < 5 { return x; }\n \n@@ -160,5 +160,34 @@ fn foo(x: i32) -> i32 {\n Because `if` is an expression, and it's the only expression in this function,\n the value will be the result of the `if`.\n \n-There are some additional ways to define functions, but they involve features\n-that we haven't learned about yet, so let's just leave it at that for now.\n+## Diverging functions\n+\n+Rust has some special syntax for 'diverging functions', which are functions that\n+do not return:\n+\n+```\n+fn diverges() -> ! {\n+    panic!(\"This function never returns!\");\n+}\n+```\n+\n+`panic!` is a macro, similar to `println!()` that we've already seen. Unlike\n+`println!()`, `panic!()` causes the current thread of execution to crash with\n+the given message.\n+\n+Because this function will cause a crash, it will never return, and so it has\n+the type '`!`', which is read \"diverges.\" A diverging function can be used\n+as any type:\n+\n+```should_fail\n+# fn diverges() -> ! {\n+#    panic!(\"This function never returns!\");\n+# }\n+\n+let x: i32 = diverges();\n+let x: String = diverges();\n+```\n+\n+We don't have a good use for diverging functions yet, because they're used in\n+conjunction with other Rust features. But when you see `-> !` later, you'll\n+know what it's called."}, {"sha": "5bc33d0a232eab1d41ecee093f5ce6cb4d75a834", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -24,11 +24,11 @@ installer](https://static.rust-lang.org/dist/rust-nightly-x86_64-pc-windows-gnu.\n and run it.\n \n If you decide you don't want Rust anymore, we'll be a bit sad, but that's okay.\n-Not every programming language is great for everyone. Just pass an argument to\n-the script:\n+Not every programming language is great for everyone. Just run the uninstall\n+script:\n \n ```bash\n-$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh -s -- --uninstall\n+$ sudo /usr/local/lib/rustlib/uninstall.sh\n ```\n \n If you used the Windows installer, just re-run the `.exe` and it will give you"}, {"sha": "ce0283480c60cb3df49da87f1a3decfa83929f54", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -132,7 +132,16 @@ let one_to_one_hundred = (1..101i32).collect::<Vec<i32>>();\n ```\n \n If you remember, the `::<>` syntax allows us to give a type hint,\n-and so we tell it that we want a vector of integers.\n+and so we tell it that we want a vector of integers. You don't always\n+need to use the whole type, though. Using a `_` will let you provide\n+a partial hint:\n+\n+```rust\n+let one_to_one_hundred = range(1, 101).collect::<Vec<_>>();\n+```\n+\n+This says \"Collect into a `Vec<T>`, please, but infer what the `T` is for me.\"\n+`_` is sometimes called a \"type placeholder\" for this reason.\n \n `collect()` is the most common consumer, but there are others too. `find()`\n is one:"}, {"sha": "20f1406aebbabae512dc67639a7b8cfbaab5dfe5", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -91,7 +91,7 @@ and only moving to this:\n fn foo(s: String) {\n ```\n \n-If you have good reason. It's not polite to hold on to ownership you don't\n+if you have good reason. It's not polite to hold on to ownership you don't\n need, and it can make your lifetimes more complex.\n \n ## Generic functions\n@@ -169,8 +169,8 @@ e\u0301\n Note that `l` has the type `&str` here, since a single grapheme can consist of\n multiple codepoints, so a `char` wouldn't be appropriate.\n \n-This will print out each visible character in turn, as you'd expect: first \"u\u0354\", then\n-\"n\u030e\u0348\u0330\", etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n+This will print out each visible character in turn, as you'd expect: first `u\u0354`, then\n+`n\u030e\u0348\u0330`, etc. If you wanted each individual codepoint of each grapheme, you can use `.chars()`:\n \n ```\n let s = \"u\u0354n\u030e\u0348\u0330i\u0319\u032e\u035a\u0326c\u0309\u035ao\u0357\u033c\u0329\u0330d\u0306\u0343\u0365\u0354e\u0301\";"}, {"sha": "dc8716d1378df6ce3296716f204ad70a444f0c88", "filename": "src/etc/unicode.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -366,7 +366,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -449,13 +449,13 @@ def emit_charwidth_module(f, width_table):\n \"\"\")\n \n     f.write(\"\"\"\n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n \n@@ -610,7 +610,7 @@ def optimize_width_table(wtable):\n         rf.write(\"\"\"\n /// The version of [Unicode](http://www.unicode.org/)\n /// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (%s, %s, %s);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (%s, %s, %s);\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")"}, {"sha": "423646e5acd0473f0af2bcd8fcfb12ffdc54c0ba", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -560,7 +560,12 @@ impl<T> DList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if `at > len`.\n+    ///\n     /// This operation should compute in O(n) time.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -580,9 +585,11 @@ impl<T> DList<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn split_off(&mut self, at: usize) -> DList<T> {\n         let len = self.len();\n-        assert!(at < len, \"Cannot split off at a nonexistent index\");\n+        assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n             return mem::replace(self, DList::new());\n+        } else if at == len {\n+            return DList::new();\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n@@ -1116,6 +1123,18 @@ mod tests {\n             }\n         }\n \n+        // no-op on the last index\n+        {\n+            let mut m = DList::new();\n+            m.push_back(1);\n+\n+            let p = m.split_off(1);\n+            assert_eq!(m.len(), 1);\n+            assert_eq!(p.len(), 0);\n+            assert_eq!(m.back(), Some(&1));\n+            assert_eq!(m.front(), Some(&1));\n+        }\n+\n     }\n \n     #[test]"}, {"sha": "8325e7247d5fcd4e90047b3e7c022649fcfad762", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -27,7 +27,6 @@\n #![feature(box_patterns)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "06ae8127c00fbf3cf1c8dfb74d1a5043267df350", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -52,7 +52,6 @@\n //! interval `[a, b)`:\n //!\n //! ```rust\n-//! #![feature(slicing_syntax)]\n //! fn main() {\n //!     let numbers = [0, 1, 2];\n //!     let last_numbers = &numbers[1..3];"}, {"sha": "32e8cffcae4f91e9156d35a804d82edd5c53f108", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -21,9 +21,9 @@\n //!\n //! Each method takes an `Ordering` which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n-//! same as [C++11 atomic orderings][1].\n+//! same as [LLVM atomic orderings][1].\n //!\n-//! [1]: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+//! [1]: http://llvm.org/docs/LangRef.html#memory-model-for-concurrent-operations\n //!\n //! Atomic variables are safe to share between threads (they implement `Sync`)\n //! but they do not themselves provide the mechanism for sharing. The most"}, {"sha": "cf293ded13f00b9dc5f99e55797d257915ba2ffc", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -649,7 +649,8 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n ///\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n-#[lang=\"unsafe\"]\n+#[cfg_attr(stage0, lang=\"unsafe\")]  // NOTE: remove after next snapshot\n+#[cfg_attr(not(stage0), lang=\"unsafe_cell\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n     /// Wrapped value"}, {"sha": "683e450acb230ba84df9e8ce11548c7a647fc6aa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -119,16 +119,16 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// ```\n #[inline]\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n+pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {\n             if num < 10 {\n-                Some(transmute(('0' as uint + num) as u32))\n+                Some(transmute('0' as u32 + num))\n             } else {\n-                Some(transmute(('a' as uint + num - 10) as u32))\n+                Some(transmute('a' as u32 + num - 10))\n             }\n         }\n     } else {\n@@ -164,7 +164,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -189,7 +189,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n     ///\n@@ -275,7 +275,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the number of bytes this character would need if encoded in UTF-16.\n     ///\n@@ -287,7 +287,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n     /// of bytes written.\n@@ -317,7 +317,7 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n     /// number of `u16`s written.\n@@ -347,27 +347,27 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool {\n+    fn is_digit(self, radix: u32) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> {\n+    fn to_digit(self, radix: u32) -> Option<u32> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n         }\n         let val = match self {\n-          '0' ... '9' => self as uint - ('0' as uint),\n-          'a' ... 'z' => self as uint + 10 - ('a' as uint),\n-          'A' ... 'Z' => self as uint + 10 - ('A' as uint),\n+          '0' ... '9' => self as u32 - '0' as u32,\n+          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n+          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n           _ => return None,\n         };\n         if val < radix { Some(val) }\n@@ -396,7 +396,7 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint {\n+    fn len_utf8(self) -> usize {\n         let code = self as u32;\n         match () {\n             _ if code < MAX_ONE_B   => 1,\n@@ -408,22 +408,22 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint {\n+    fn len_utf16(self) -> usize {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n         encode_utf16_raw(self as u32, dst)\n     }\n }\n@@ -435,7 +435,7 @@ impl CharExt for char {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n         dst[0] = code as u8;\n@@ -467,7 +467,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n+pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n         // The BMP falls through (assuming non-surrogate, as it should)\n@@ -499,7 +499,7 @@ enum EscapeUnicodeState {\n     Backslash,\n     Type,\n     LeftBrace,\n-    Value(uint),\n+    Value(usize),\n     RightBrace,\n     Done,\n }"}, {"sha": "058eff121e63300daef084435917f9b6131fb130", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -61,13 +61,13 @@ macro_rules! clone_impl {\n     }\n }\n \n-clone_impl! { int }\n+clone_impl! { isize }\n clone_impl! { i8 }\n clone_impl! { i16 }\n clone_impl! { i32 }\n clone_impl! { i64 }\n \n-clone_impl! { uint }\n+clone_impl! { usize }\n clone_impl! { u8 }\n clone_impl! { u16 }\n clone_impl! { u32 }"}, {"sha": "8e09e52daee198cff18f31a26433f173e4ad5d14", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -53,7 +53,7 @@ pub enum SignFormat {\n     SignNeg\n }\n \n-static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11;\n+static DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n \n /// Converts a number to its string representation as a byte vector.\n /// This is meant to be a common base implementation for all numeric string\n@@ -87,7 +87,7 @@ static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11;\n ///   between digit and exponent sign `'p'`.\n pub fn float_to_str_bytes_common<T: Float, U, F>(\n     num: T,\n-    radix: uint,\n+    radix: u32,\n     negative_zero: bool,\n     sign: SignFormat,\n     digits: SignificantDigits,\n@@ -156,7 +156,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        let c = char::from_digit(current_digit.to_int().unwrap() as uint, radix);\n+        let c = char::from_digit(current_digit.to_int().unwrap() as u32, radix);\n         buf[end] = c.unwrap() as u8;\n         end += 1;\n \n@@ -211,7 +211,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             // See note in first loop.\n             let current_digit = deccum.trunc().abs();\n \n-            let c = char::from_digit(current_digit.to_int().unwrap() as uint,\n+            let c = char::from_digit(current_digit.to_int().unwrap() as u32,\n                                      radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n@@ -228,7 +228,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             let ascii2value = |chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |val: u32| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n "}, {"sha": "06aba2cb08ef34df8039c868ab5309d8251a644f", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -2676,9 +2676,9 @@ impl<A: Int> Iterator for ::ops::Range<A> {\n     }\n }\n \n+// Ranges of u64 and i64 are excluded because they cannot guarantee having\n+// a length <= usize::MAX, which is required by ExactSizeIterator.\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-#[cfg(target_pointer_width = \"64\")]\n-range_exact_iter_impl!(u64 i64);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Int> DoubleEndedIterator for ::ops::Range<A> {"}, {"sha": "7243bd4f0cb258d59af2316da88217999e105bc9", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -64,7 +64,7 @@\n #![feature(int_uint)]\n #![feature(intrinsics, lang_items)]\n #![feature(on_unimplemented)]\n-#![feature(simd, unsafe_destructor, slicing_syntax)]\n+#![feature(simd, unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n "}, {"sha": "b542c9d47f7d4a386d9ac5148b7275ae245d008b", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -35,14 +35,27 @@ pub const EPSILON: f32 = 1.19209290e-07_f32;\n \n /// Smallest finite f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN`\")]\n pub const MIN_VALUE: f32 = -3.40282347e+38_f32;\n /// Smallest positive, normalized f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MIN_POSITIVE`\")]\n pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n /// Largest finite f32 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f32::MAX`\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n+/// Smallest finite f32 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MIN: f32 = -3.40282347e+38_f32;\n+/// Smallest positive, normalized f32 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MIN_POSITIVE: f32 = 1.17549435e-38_f32;\n+/// Largest finite f32 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MAX: f32 = 3.40282347e+38_f32;\n+\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -125;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n@@ -215,17 +228,17 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f32 { MIN_VALUE }\n+    fn min_value() -> f32 { MIN }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n+    fn min_pos_value(_: Option<f32>) -> f32 { MIN_POSITIVE }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f32 { MAX_VALUE }\n+    fn max_value() -> f32 { MAX }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {"}, {"sha": "2aae7107548c6f3ecab3fa7d632635b7c277933e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -38,14 +38,27 @@ pub const EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n /// Smallest finite f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN`\")]\n pub const MIN_VALUE: f64 = -1.7976931348623157e+308_f64;\n /// Smallest positive, normalized f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MIN_POSITIVE`\")]\n pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n /// Largest finite f64 value\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `std::f64::MAX`\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n+/// Smallest finite f64 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MIN: f64 = -1.7976931348623157e+308_f64;\n+/// Smallest positive, normalized f64 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64;\n+/// Largest finite f64 value\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub const MAX: f64 = 1.7976931348623157e+308_f64;\n+\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -1021;\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n@@ -222,17 +235,17 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_value() -> f64 { MIN_VALUE }\n+    fn min_value() -> f64 { MIN }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n+    fn min_pos_value(_: Option<f64>) -> f64 { MIN_POSITIVE }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_value() -> f64 { MAX_VALUE }\n+    fn max_value() -> f64 { MAX }\n \n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {"}, {"sha": "7612469c8088bbfe3c30579d02e28f48aa4482fd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -956,7 +956,7 @@ macro_rules! impl_to_primitive_float_to_float {\n             Some($slf as $DstT)\n         } else {\n             let n = $slf as f64;\n-            let max_value: $SrcT = ::$SrcT::MAX_VALUE;\n+            let max_value: $SrcT = ::$SrcT::MAX;\n             if -max_value as f64 <= n && n <= max_value as f64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -1331,18 +1331,18 @@ pub trait Float\n     /// Returns the smallest finite value that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\")]\n+                 reason = \"use `std::f32::MIN` or `std::f64::MIN` as appropriate\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MIN_POS_VALUE` or \\\n-                           `std::f64::MIN_POS_VALUE` as appropriate\")]\n+                 reason = \"use `std::f32::MIN_POSITIVE` or \\\n+                           `std::f64::MIN_POSITIVE` as appropriate\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n-                 reason = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\")]\n+                 reason = \"use `std::f32::MAX` or `std::f64::MAX` as appropriate\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n@@ -1432,12 +1432,12 @@ pub trait Float\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n pub trait FromStrRadix {\n     type Err;\n-    fn from_str_radix(str: &str, radix: uint) -> Result<Self, Self::Err>;\n+    fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::Err>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n #[unstable(feature = \"core\", reason = \"needs reevaluation\")]\n-pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint)\n+pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: u32)\n                                        -> Result<T, T::Err> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n@@ -1501,7 +1501,7 @@ macro_rules! from_str_radix_float_impl {\n             /// `None` if the string did not represent a valid number.\n             /// Otherwise, `Some(n)` where `n` is the floating-point number\n             /// represented by `src`.\n-            fn from_str_radix(src: &str, radix: uint)\n+            fn from_str_radix(src: &str, radix: u32)\n                               -> Result<$T, ParseFloatError> {\n                 use self::FloatErrorKind::*;\n                 use self::ParseFloatError as PFE;\n@@ -1661,7 +1661,7 @@ macro_rules! from_str_radix_int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl FromStrRadix for $T {\n             type Err = ParseIntError;\n-            fn from_str_radix(src: &str, radix: uint)\n+            fn from_str_radix(src: &str, radix: u32)\n                               -> Result<$T, ParseIntError> {\n                 use self::IntErrorKind::*;\n                 use self::ParseIntError as PIE;"}, {"sha": "081c895c3175c25da7bfb88c3c1198a433ab40df", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -162,7 +162,7 @@ use slice;\n // `Iterator` is an enumeration with one type parameter and two variants,\n // which basically means it must be `Option`.\n \n-/// The `Option` type.\n+/// The `Option` type. See [the module level documentation](../index.html) for more.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {"}, {"sha": "5cc210df5b464e5d6581614df4d17a2012a6f323", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 112, "deletions": 9, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -21,27 +21,130 @@\n use marker::Copy;\n use mem;\n \n-/// The representation of a Rust slice\n+/// The representation of a slice like `&[T]`.\n+///\n+/// This struct is guaranteed to have the layout of types like `&[T]`,\n+/// `&str`, and `Box<[T]>`, but is not the type of such slices\n+/// (e.g. the fields are not directly accessible on a `&[T]`) nor does\n+/// it control that layout (changing the definition will not change\n+/// the layout of a `&[T]`). It is only designed to be used by unsafe\n+/// code that needs to manipulate the low-level details.\n+///\n+/// However, it is not recommended to use this type for such code,\n+/// since there are alternatives which may be safer:\n+///\n+/// - Creating a slice from a data pointer and length can be done with\n+///   `std::slice::from_raw_parts` or `std::slice::from_raw_parts_mut`\n+///   instead of `std::mem::transmute`ing a value of type `Slice`.\n+/// - Extracting the data pointer and length from a slice can be\n+///   performed with the `as_ptr` (or `as_mut_ptr`) and `len`\n+///   methods.\n+///\n+/// If one does decide to convert a slice value to a `Slice`, the\n+/// `Repr` trait in this module provides a method for a safe\n+/// conversion from `&[T]` (and `&str`) to a `Slice`, more type-safe\n+/// than a call to `transmute`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::raw::{self, Repr};\n+///\n+/// let slice: &[u16] = &[1, 2, 3, 4];\n+///\n+/// let repr: raw::Slice<u16> = slice.repr();\n+/// println!(\"data pointer = {:?}, length = {}\", repr.data, repr.len);\n+/// ```\n #[repr(C)]\n pub struct Slice<T> {\n     pub data: *const T,\n-    pub len: uint,\n+    pub len: usize,\n }\n \n impl<T> Copy for Slice<T> {}\n \n-/// The representation of a Rust closure\n+/// The representation of an old closure.\n #[repr(C)]\n #[derive(Copy)]\n+#[unstable(feature = \"core\")]\n+#[deprecated(reason = \"unboxed new closures do not have a universal representation; \\\n+                       `&Fn` (etc) trait objects should use `TraitObject` instead\",\n+             since= \"1.0.0\")]\n pub struct Closure {\n     pub code: *mut (),\n     pub env: *mut (),\n }\n \n-/// The representation of a Rust trait object.\n+/// The representation of a trait object like `&SomeTrait`.\n+///\n+/// This struct has the same layout as types like `&SomeTrait` and\n+/// `Box<AnotherTrait>`. The [Static and Dynamic Dispatch chapter of the\n+/// Book][moreinfo] contains more details about the precise nature of\n+/// these internals.\n+///\n+/// [moreinfo]: ../../book/static-and-dynamic-dispatch.html#representation\n+///\n+/// `TraitObject` is guaranteed to match layouts, but it is not the\n+/// type of trait objects (e.g. the fields are not directly accessible\n+/// on a `&SomeTrait`) nor does it control that layout (changing the\n+/// definition will not change the layout of a `&SometTrait`). It is\n+/// only designed to be used by unsafe code that needs to manipulate\n+/// the low-level details.\n+///\n+/// There is no `Repr` implementation for `TraitObject` because there\n+/// is no way to refer to all trait objects generically, so the only\n+/// way to create values of this type is with functions like\n+/// `std::mem::transmute`. Similarly, the only way to create a true\n+/// trait object from a `TraitObject` value is with `transmute`.\n+///\n+/// Synthesizing a trait object with mismatched types\u2014one where the\n+/// vtable does not correspond to the type of the value to which the\n+/// data pointer points\u2014is highly likely to lead to undefined\n+/// behaviour.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::raw;\n+///\n+/// // an example trait\n+/// trait Foo {\n+///     fn bar(&self) -> i32;\n+/// }\n+/// impl Foo for i32 {\n+///     fn bar(&self) -> i32 {\n+///          *self + 1\n+///     }\n+/// }\n+///\n+/// let value: i32 = 123;\n+///\n+/// // let the compiler make a trait object\n+/// let object: &Foo = &value;\n+///\n+/// // look at the raw representation\n+/// let raw_object: raw::TraitObject = unsafe { mem::transmute(object) };\n+///\n+/// // the data pointer is the address of `value`\n+/// assert_eq!(raw_object.data as *const i32, &value as *const _);\n+///\n+///\n+/// let other_value: i32 = 456;\n+///\n+/// // construct a new object, pointing to a different `i32`, being\n+/// // careful to use the `i32` vtable from `object`\n+/// let synthesized: &Foo = unsafe {\n+///      mem::transmute(raw::TraitObject {\n+///          data: &other_value as *const _ as *mut (),\n+///          vtable: raw_object.vtable\n+///      })\n+/// };\n ///\n-/// This struct does not have a `Repr` implementation\n-/// because there is no way to refer to all trait objects generically.\n+/// // it should work just like we constructed a trait object out of\n+/// // `other_value` directly\n+/// assert_eq!(synthesized.bar(), 457);\n+/// ```\n #[repr(C)]\n #[derive(Copy)]\n pub struct TraitObject {\n@@ -51,7 +154,7 @@ pub struct TraitObject {\n \n /// This trait is meant to map equivalences between raw structs and their\n /// corresponding rust values.\n-pub trait Repr<T> {\n+pub unsafe trait Repr<T> {\n     /// This function \"unwraps\" a rust value (without consuming it) into its raw\n     /// struct representation. This can be used to read/write different values\n     /// for the struct. This is a safe method because by default it does not\n@@ -60,5 +163,5 @@ pub trait Repr<T> {\n     fn repr(&self) -> T { unsafe { mem::transmute_copy(&self) } }\n }\n \n-impl<T> Repr<Slice<T>> for [T] {}\n-impl Repr<Slice<u8>> for str {}\n+unsafe impl<T> Repr<Slice<T>> for [T] {}\n+unsafe impl Repr<Slice<u8>> for str {}"}, {"sha": "097633b706312a1762cef1394e8f4233e333a994", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 117, "deletions": 117, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -66,28 +66,28 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n+    fn split_at<'a>(&'a self, mid: usize) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n                     where P: FnMut(&Self::Item) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>\n+    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>\n+    fn rsplitn<'a, P>(&'a self,  n: usize, pred: P) -> RSplitN<'a, Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;\n+    fn windows<'a>(&'a self, size: usize) -> Windows<'a, Self::Item>;\n+    fn chunks<'a>(&'a self, size: usize) -> Chunks<'a, Self::Item>;\n+    fn get<'a>(&'a self, index: usize) -> Option<&'a Self::Item>;\n     fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n     fn tail<'a>(&'a self) -> &'a [Self::Item];\n     fn init<'a>(&'a self) -> &'a [Self::Item];\n     fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;\n+    unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a Self::Item;\n     fn as_ptr(&self) -> *const Self::Item;\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n         F: FnMut(&Self::Item) -> Ordering;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n+    fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n@@ -96,40 +96,40 @@ pub trait SliceExt {\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n                         where P: FnMut(&Self::Item) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>\n+    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>\n+    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;\n-    fn swap(&mut self, a: uint, b: uint);\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: usize) -> ChunksMut<'a, Self::Item>;\n+    fn swap(&mut self, a: usize, b: usize);\n+    fn split_at_mut<'a>(&'a mut self, mid: usize) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: usize) -> &'a mut Self::Item;\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n-    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n-    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n-    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n-    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n }\n \n #[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n     #[inline]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n+    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n     }\n \n@@ -139,11 +139,11 @@ impl<T> SliceExt for [T] {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n-                      end: (p as uint + self.len()) as *const T,\n+                      end: (p as usize + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 Iter {ptr: p,\n-                      end: p.offset(self.len() as int),\n+                      end: p.offset(self.len() as isize),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where\n+    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         SplitN {\n@@ -172,7 +172,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where\n+    fn rsplitn<'a, P>(&'a self, n: usize, pred: P) -> RSplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitN {\n@@ -185,19 +185,19 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn windows(&self, size: uint) -> Windows<T> {\n+    fn windows(&self, size: usize) -> Windows<T> {\n         assert!(size != 0);\n         Windows { v: self, size: size }\n     }\n \n     #[inline]\n-    fn chunks(&self, size: uint) -> Chunks<T> {\n+    fn chunks(&self, size: usize) -> Chunks<T> {\n         assert!(size != 0);\n         Chunks { v: self, size: size }\n     }\n \n     #[inline]\n-    fn get(&self, index: uint) -> Option<&T> {\n+    fn get(&self, index: usize) -> Option<&T> {\n         if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n@@ -220,8 +220,8 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(&self, index: uint) -> &T {\n-        transmute(self.repr().data.offset(index as int))\n+    unsafe fn get_unchecked(&self, index: usize) -> &T {\n+        transmute(self.repr().data.offset(index as isize))\n     }\n \n     #[inline]\n@@ -230,11 +230,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[unstable(feature = \"core\")]\n-    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where\n         F: FnMut(&T) -> Ordering\n     {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n+        let mut base : usize = 0;\n+        let mut lim : usize = self.len();\n \n         while lim != 0 {\n             let ix = base + (lim >> 1);\n@@ -252,18 +252,18 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T> {\n+    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n     #[inline]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let self2: &mut [T] = mem::transmute_copy(&self);\n \n@@ -278,11 +278,11 @@ impl<T> SliceExt for [T] {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n+                         end: (p as usize + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 IterMut {ptr: p,\n-                         end: p.offset(self.len() as int),\n+                         end: p.offset(self.len() as isize),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n@@ -317,7 +317,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where\n+    fn splitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> SplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n@@ -330,7 +330,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> RSplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitNMut {\n@@ -343,12 +343,12 @@ impl<T> SliceExt for [T] {\n    }\n \n     #[inline]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> {\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         assert!(chunk_size > 0);\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n-    fn swap(&mut self, a: uint, b: uint) {\n+    fn swap(&mut self, a: usize, b: usize) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n             // them to their raw pointers to do the swap\n@@ -359,7 +359,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     fn reverse(&mut self) {\n-        let mut i: uint = 0;\n+        let mut i: usize = 0;\n         let ln = self.len();\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n@@ -373,8 +373,8 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+        transmute((self.repr().data as *mut T).offset(index as isize))\n     }\n \n     #[inline]\n@@ -383,12 +383,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq {\n+    fn position_elem(&self, x: &T) -> Option<usize> where T: PartialEq {\n         self.iter().position(|y| *x == *y)\n     }\n \n     #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         self.iter().rposition(|x| *x == *t)\n     }\n \n@@ -410,7 +410,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[unstable(feature = \"core\")]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n@@ -477,7 +477,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n         let dst = &mut self[.. min];\n         let src = &src[.. min];\n@@ -489,53 +489,53 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<uint> for [T] {\n+impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n-    fn index(&self, &index: &uint) -> &T {\n+    fn index(&self, &index: &usize) -> &T {\n         assert!(index < self.len());\n \n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<uint> for [T] {\n-    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+impl<T> ops::IndexMut<usize> for [T] {\n+    fn index_mut(&mut self, &index: &usize) -> &mut T {\n         assert!(index < self.len());\n \n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::Range<uint>> for [T] {\n+impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(index.start as int),\n+                    data: self.as_ptr().offset(index.start as isize),\n                     len: index.end - index.start\n                 })\n         }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n+impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n+impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n@@ -549,30 +549,30 @@ impl<T> ops::Index<RangeFull> for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(index.start as int),\n+                    data: self.as_ptr().offset(index.start as isize),\n                     len: index.end - index.start\n                 })\n         }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n@@ -660,7 +660,7 @@ macro_rules! iterator {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n-                            self.ptr = transmute(self.ptr as uint + 1);\n+                            self.ptr = transmute(self.ptr as usize + 1);\n \n                             // Use a non-null pointer value\n                             Some(&mut *(1 as *mut _))\n@@ -675,8 +675,8 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                let diff = (self.end as usize) - (self.ptr as usize);\n                 let size = mem::size_of::<T>();\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n@@ -694,7 +694,7 @@ macro_rules! iterator {\n                     } else {\n                         if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n-                            self.end = transmute(self.end as uint - 1);\n+                            self.end = transmute(self.end as usize - 1);\n \n                             // Use a non-null pointer value\n                             Some(&mut *(1 as *mut _))\n@@ -712,7 +712,7 @@ macro_rules! iterator {\n \n macro_rules! make_slice {\n     ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as uint - $start as uint;\n+        let diff = $end as usize - $start as usize;\n         let len = if mem::size_of::<T>() == 0 {\n             diff\n         } else {\n@@ -733,28 +733,28 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n@@ -792,20 +792,20 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (exact, _) = self.size_hint();\n         exact\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n+    fn idx(&mut self, index: usize) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n                 if mem::size_of::<T>() == 0 {\n                     // Use a non-null pointer value\n                     Some(&mut *(1 as *mut _))\n                 } else {\n-                    Some(transmute(self.ptr.offset(index as int)))\n+                    Some(transmute(self.ptr.offset(index as isize)))\n                 }\n             } else {\n                 None\n@@ -824,26 +824,26 @@ pub struct IterMut<'a, T: 'a> {\n \n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n@@ -857,23 +857,23 @@ impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n@@ -952,7 +952,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.finished {\n             (0, Some(0))\n         } else {\n@@ -1030,7 +1030,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.finished {\n             (0, Some(0))\n         } else {\n@@ -1070,7 +1070,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n /// times.\n struct GenericSplitN<I> {\n     iter: I,\n-    count: uint,\n+    count: usize,\n     invert: bool\n }\n \n@@ -1088,7 +1088,7 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper_opt) = self.iter.size_hint();\n         (lower, upper_opt.map(|upper| cmp::min(self.count + 1, upper)))\n     }\n@@ -1138,7 +1138,7 @@ macro_rules! forward_iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.inner.size_hint()\n             }\n         }\n@@ -1155,7 +1155,7 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n-    size: uint\n+    size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1174,7 +1174,7 @@ impl<'a, T> Iterator for Windows<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.size > self.v.len() {\n             (0, Some(0))\n         } else {\n@@ -1204,12 +1204,12 @@ impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.size_hint().0\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n         if index + self.size > self.v.len() {\n             None\n         } else {\n@@ -1227,7 +1227,7 @@ impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n-    size: uint\n+    size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1247,7 +1247,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n@@ -1281,12 +1281,12 @@ impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n         if index < self.indexable() {\n             let lo = index * self.size;\n             let mut hi = lo + self.size;\n@@ -1305,7 +1305,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n-    chunk_size: uint\n+    chunk_size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1326,7 +1326,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n@@ -1402,15 +1402,15 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const uint;\n+/// let ptr = 0x1234 as *const usize;\n /// let amt = 10;\n /// unsafe {\n ///     let slice = slice::from_raw_parts(ptr, amt);\n /// }\n /// ```\n #[inline]\n #[unstable(feature = \"core\")]\n-pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: uint) -> &'a [T] {\n+pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n@@ -1422,7 +1422,7 @@ pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: uint) -> &'a [T] {\n /// mutable slice.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n+pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n@@ -1445,7 +1445,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const uint;\n+/// let ptr = 0x1234 as *const usize;\n /// let amt = 10;\n /// unsafe {\n ///     let slice = slice::from_raw_buf(&ptr, amt);\n@@ -1455,7 +1455,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n #[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\",\n              reason = \"use from_raw_parts\")]\n-pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n+pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: usize) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n \n@@ -1469,7 +1469,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n #[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\",\n              reason = \"use from_raw_parts_mut\")]\n-pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n+pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n \n@@ -1606,4 +1606,4 @@ impl_int_slices! { u8,   i8  }\n impl_int_slices! { u16,  i16 }\n impl_int_slices! { u32,  i32 }\n impl_int_slices! { u64,  i64 }\n-impl_int_slices! { uint, int }\n+impl_int_slices! { usize, isize }"}, {"sha": "ce26abe606dd4b432e7f85101e41e1de83e507d9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate_iter {\n         delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n-            fn len(&self) -> uint {\n+            fn len(&self) -> usize {\n                 self.0.len()\n             }\n         }\n@@ -56,7 +56,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -78,7 +78,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -100,7 +100,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -178,7 +178,7 @@ pub enum Utf8Error {\n     /// The offset is guaranteed to be in bounds of the slice in question, and\n     /// the byte at the specified offset was the first invalid byte in the\n     /// sequence detected.\n-    InvalidByte(uint),\n+    InvalidByte(usize),\n \n     /// The byte slice was invalid because more bytes were needed but no more\n     /// bytes were available.\n@@ -227,7 +227,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n-    while *s.offset(len as int) != 0 {\n+    while *s.offset(len as isize) != 0 {\n         len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n@@ -250,7 +250,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -383,7 +383,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (len, _) = self.iter.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -428,16 +428,16 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n-    front_offset: uint,\n+    front_offset: usize,\n     iter: Chars<'a>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (uint, char);\n+    type Item = (usize, char);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n+    fn next(&mut self) -> Option<(usize, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n         match self.iter.next() {\n             None => None,\n@@ -451,15 +451,15 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n         match self.iter.next_back() {\n             None => None,\n             Some(ch) => {\n@@ -512,7 +512,7 @@ struct CharSplits<'a, Sep> {\n struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n-    count: uint,\n+    count: usize,\n     invert: bool,\n }\n \n@@ -636,15 +636,15 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n /// within a larger string using naive search\n #[derive(Clone)]\n struct NaiveSearcher {\n-    position: uint\n+    position: usize\n }\n \n impl NaiveSearcher {\n     fn new() -> NaiveSearcher {\n         NaiveSearcher { position: 0 }\n     }\n \n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n         while self.position + needle.len() <= haystack.len() {\n             if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n@@ -663,13 +663,13 @@ impl NaiveSearcher {\n #[derive(Clone)]\n struct TwoWaySearcher {\n     // constants\n-    crit_pos: uint,\n-    period: uint,\n+    crit_pos: usize,\n+    period: usize,\n     byteset: u64,\n \n     // variables\n-    position: uint,\n-    memory: uint\n+    position: usize,\n+    memory: usize\n }\n \n /*\n@@ -756,7 +756,7 @@ impl TwoWaySearcher {\n \n         // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n \n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n@@ -794,7 +794,8 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+            -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -804,7 +805,7 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if (self.byteset >>\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as uint)) & 1 == 0 {\n+                     as usize)) & 1 == 0 {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -851,7 +852,7 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -937,16 +938,16 @@ pub struct MatchIndices<'a> {\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n-    last_end: uint,\n+    last_end: usize,\n     finished: bool\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n+    fn next(&mut self) -> Option<(usize, usize)> {\n         match self.searcher {\n             Naive(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n@@ -991,8 +992,9 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n+    // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n                b.as_ptr() as *const i8,\n@@ -1049,7 +1051,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1124,7 +1126,7 @@ pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n-    pub next: uint,\n+    pub next: usize,\n }\n \n /// Mask of the value bits of a continuation byte\n@@ -1209,10 +1211,10 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<uint>> for str {\n+    impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::Range<uint>) -> &str {\n+        fn index(&self, index: &ops::Range<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if index.start <= index.end &&\n                self.is_char_boundary(index.start) &&\n@@ -1232,10 +1234,10 @@ mod traits {\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<uint>> for str {\n+    impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.end) {\n                 unsafe { self.slice_unchecked(0, index.end) }\n@@ -1252,10 +1254,10 @@ mod traits {\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<uint>> for str {\n+    impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.start) {\n                 unsafe { self.slice_unchecked(index.start, self.len()) }\n@@ -1332,40 +1334,40 @@ pub trait StrExt {\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n+    fn splitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n+    fn rsplitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n-    fn char_len(&self) -> uint;\n-    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n+    fn char_len(&self) -> usize;\n+    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n     fn ends_with(&self, pat: &str) -> bool;\n     fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-    fn char_at(&self, i: uint) -> char;\n-    fn char_at_reverse(&self, i: uint) -> char;\n+    fn is_char_boundary(&self, index: usize) -> bool;\n+    fn char_range_at(&self, start: usize) -> CharRange;\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n+    fn char_at(&self, i: usize) -> char;\n+    fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn find_str(&self, pat: &str) -> Option<uint>;\n+    fn find<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn find_str(&self, pat: &str) -> Option<usize>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-    fn subslice_offset(&self, inner: &str) -> uint;\n+    fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool;\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n-fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n@@ -1409,7 +1411,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1426,7 +1428,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1470,9 +1472,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_len(&self) -> uint { self.chars().count() }\n+    fn char_len(&self) -> usize { self.chars().count() }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1496,9 +1498,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as int),\n+            data: self.as_ptr().offset(begin as isize),\n             len: end - begin,\n         })\n     }\n@@ -1550,7 +1552,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         if index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n@@ -1559,13 +1561,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n+    fn char_range_at(&self, i: usize) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n         CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n@@ -1574,14 +1576,14 @@ impl StrExt for str {\n         }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -1596,12 +1598,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n@@ -1610,7 +1612,7 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn find<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().position(|b| pat.matches(b as char))\n         } else {\n@@ -1621,7 +1623,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().rposition(|b| pat.matches(b as char))\n         } else {\n@@ -1632,7 +1634,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<uint> {\n+    fn find_str(&self, needle: &str) -> Option<usize> {\n         if needle.is_empty() {\n             Some(0)\n         } else {\n@@ -1653,10 +1655,10 @@ impl StrExt for str {\n         }\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n+    fn subslice_offset(&self, inner: &str) -> usize {\n+        let a_start = self.as_ptr() as usize;\n         let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n+        let b_start = inner.as_ptr() as usize;\n         let b_end = b_start + inner.len();\n \n         assert!(a_start <= b_start);\n@@ -1670,7 +1672,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1683,15 +1685,15 @@ impl StrExt for str {\n /// index of the next code point.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n     }\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n         let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n         assert!((w != 0));\n \n         val = utf8_first_byte!(val, w);\n@@ -1718,7 +1720,7 @@ impl<'a> Iterator for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1734,7 +1736,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "2dfd81f32c2703869f43d32657089860b80ca7db", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n #![feature(int_uint)]\n #![feature(unboxed_closures)]\n-#![feature(unsafe_destructor, slicing_syntax)]\n+#![feature(unsafe_destructor)]\n #![allow(deprecated)] // rand\n \n extern crate core;"}, {"sha": "1c7e97d784c685b91472669c1502d19ce404a709", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -25,7 +25,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(int_uint)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(unicode)]\n \n@@ -422,7 +421,7 @@ impl<'a> Parser<'a> {\n                 Some((_, c)) => {\n                     match c.to_digit(10) {\n                         Some(i) => {\n-                            cur = cur * 10 + i;\n+                            cur = cur * 10 + i as usize;\n                             found = true;\n                             self.cur.next();\n                         }"}, {"sha": "ca184fb8736cdd78d0f335fc08857a2faad39b24", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -91,7 +91,6 @@\n #![deny(missing_docs)]\n #![feature(collections)]\n #![feature(int_uint)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(rustc_private))]\n "}, {"sha": "a1a271bc5abb557799763a8eb92d1ebb9faf8bbc", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -273,7 +273,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(slicing_syntax)]\n #![feature(int_uint)]\n #![feature(collections)]\n #![feature(core)]"}, {"sha": "5edb4a96a7df66ad9e952da74ead57001794c11a", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -168,7 +168,6 @@\n #![deny(missing_docs)]\n \n #![feature(staged_api)]\n-#![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n #![feature(core)]"}, {"sha": "154dbbdb750344d556dc32480fca970666e64132", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -30,7 +30,6 @@\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n \n extern crate serialize;"}, {"sha": "f060d464e410fb229979827472a4e4d901a78515", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -36,7 +36,7 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]"}, {"sha": "fe1d695ab7b3e6c889ecd20bbd3bfaf3d999f5af", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -318,8 +318,8 @@ impl LintPass for TypeLimits {\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                ast::TyF32  => (f32::MIN_VALUE as f64, f32::MAX_VALUE as f64),\n-                ast::TyF64  => (f64::MIN_VALUE,        f64::MAX_VALUE)\n+                ast::TyF32  => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64  => (f64::MIN,        f64::MAX)\n             }\n         }\n \n@@ -674,6 +674,7 @@ impl LintPass for UnusedAttributes {\n             \"stable\",\n             \"unstable\",\n             \"rustc_on_unimplemented\",\n+            \"rustc_error\",\n \n             // FIXME: #19470 this shouldn't be needed forever\n             \"old_orphan_check\","}, {"sha": "e13a5672778e24da1a4a88980b21fc01eacff0ce", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -271,7 +271,7 @@ lets_do_this! {\n     RangeToStructLangItem,           \"range_to\",                range_to_struct;\n     RangeFullStructLangItem,         \"range_full\",              range_full_struct;\n \n-    UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;\n+    UnsafeCellTypeLangItem,          \"unsafe_cell\",             unsafe_cell_type;\n \n     DerefTraitLangItem,              \"deref\",                   deref_trait;\n     DerefMutTraitLangItem,           \"deref_mut\",               deref_mut_trait;"}, {"sha": "6f58f4655fed1ed944805e58485c9525a98b1e8d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1654,7 +1654,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::BoundSync => {\n                     if\n                         Some(def_id) == tcx.lang_items.managed_bound() ||\n-                        Some(def_id) == tcx.lang_items.unsafe_type()\n+                        Some(def_id) == tcx.lang_items.unsafe_cell_type()\n                     {\n                         return Err(Unimplemented)\n                     }"}, {"sha": "e276683236f866a67efc7a75488d7641c25c233f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -3577,7 +3577,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                         -> TypeContents {\n         if Some(did) == cx.lang_items.managed_bound() {\n             tc | TC::Managed\n-        } else if Some(did) == cx.lang_items.unsafe_type() {\n+        } else if Some(did) == cx.lang_items.unsafe_cell_type() {\n             tc | TC::InteriorUnsafe\n         } else {\n             tc"}, {"sha": "904b337c03f46e63e664126f01cc470d457c013a", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -73,8 +73,11 @@ fn pre_link_args(arch: Arch) -> Vec<String> {\n \n fn target_cpu(arch: Arch) -> String {\n     match arch {\n+        Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n+        Armv7s => \"cortex-a9\",\n+        Arm64 => \"cyclone\",\n+        I386 => \"generic\",\n         X86_64 => \"x86-64\",\n-        _ => \"generic\",\n     }.to_string()\n }\n "}, {"sha": "b80a486b191d20ede43a37b50bb558ca8a330d36", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -384,8 +384,7 @@ impl Target {\n             Path::new(target)\n         };\n \n-        let target_path = env::var_os(\"RUST_TARGET_PATH\")\n-                              .unwrap_or(OsString::from_str(\"\"));\n+        let target_path = env::var_os(\"RUST_TARGET_PATH\").unwrap_or(OsString::from_str(\"\"));\n \n         // FIXME 16351: add a sane default search path?\n "}, {"sha": "9b8ca398b12b887445e0ff0ff2726248523e419d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -35,7 +35,7 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n@@ -477,6 +477,10 @@ pub fn commit_date_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_DATE\")\n }\n \n+pub fn build_date_str() -> Option<&'static str> {\n+    option_env!(\"CFG_BUILD_DATE\")\n+}\n+\n /// Prints version information and returns None on success or an error\n /// message on panic.\n pub fn version(binary: &str, matches: &getopts::Matches) {\n@@ -488,6 +492,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"binary: {}\", binary);\n         println!(\"commit-hash: {}\", unw(commit_hash_str()));\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n+        println!(\"build-date: {}\", unw(build_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n     }"}, {"sha": "874c8f2a9402df38653c04fcf0d7389fdb48ca46", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -24,7 +24,6 @@\n #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n "}, {"sha": "21557379e3ae2a2ad01a48c717d4f51e94f5ba91", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -37,7 +37,7 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]"}, {"sha": "54c50b7a62b5dcae915656bce45b37395f4919e9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -2425,6 +2425,14 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: String, node_id: ast::N\n \n \n     if is_entry_fn(ccx.sess(), node_id) {\n+        // check for the #[rustc_error] annotation, which forces an\n+        // error in trans. This is used to write compile-fail tests\n+        // that actually test that compilation succeeds without\n+        // reporting an error.\n+        if ty::has_attr(ccx.tcx(), local_def(node_id), \"rustc_error\") {\n+            ccx.tcx().sess.span_fatal(sp, \"compilation successful\");\n+        }\n+\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n }"}, {"sha": "7498dc8179d751915c6f21f84877d72bb3e23643", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -83,7 +83,7 @@ This API is completely unstable and subject to change.\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(unsafe_destructor)]\n #![feature(staged_api)]\n \n #[macro_use] extern crate log;"}, {"sha": "d5883d8bf864bc3f386b3dfa4f3c763d11939a52", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -412,7 +412,7 @@ struct ConstraintContext<'a, 'tcx: 'a> {\n     invariant_lang_items: [Option<ast::DefId>; 2],\n     covariant_lang_items: [Option<ast::DefId>; 2],\n     contravariant_lang_items: [Option<ast::DefId>; 2],\n-    unsafe_lang_item: Option<ast::DefId>,\n+    unsafe_cell_lang_item: Option<ast::DefId>,\n \n     // These are pointers to common `ConstantTerm` instances\n     covariant: VarianceTermPtr<'a>,\n@@ -453,7 +453,7 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n     invariant_lang_items[RegionParam as uint] =\n         terms_cx.tcx.lang_items.invariant_lifetime();\n \n-    let unsafe_lang_item = terms_cx.tcx.lang_items.unsafe_type();\n+    let unsafe_cell_lang_item = terms_cx.tcx.lang_items.unsafe_cell_type();\n \n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n@@ -465,7 +465,7 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n         invariant_lang_items: invariant_lang_items,\n         covariant_lang_items: covariant_lang_items,\n         contravariant_lang_items: contravariant_lang_items,\n-        unsafe_lang_item: unsafe_lang_item,\n+        unsafe_cell_lang_item: unsafe_cell_lang_item,\n \n         covariant: covariant,\n         contravariant: contravariant,\n@@ -654,7 +654,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             self.covariant\n         } else if self.contravariant_lang_items[kind as uint] == Some(item_def_id) {\n             self.contravariant\n-        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_lang_item {\n+        } else if kind == TypeParam && Some(item_def_id) == self.unsafe_cell_lang_item {\n             self.invariant\n         } else if param_def_id.krate == ast::LOCAL_CRATE {\n             // Parameter on an item defined within current crate:"}, {"sha": "95994af7dc8deecd325711d0d617eee65d6acebc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1849,6 +1849,7 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                s: &clean::Struct) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust struct'>\"));\n+    try!(render_attributes(w, it));\n     try!(render_struct(w,\n                        it,\n                        Some(&s.generics),\n@@ -1885,7 +1886,9 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust enum'>{}enum {}{}{}\",\n+    try!(write!(w, \"<pre class='rust enum'>\"));\n+    try!(render_attributes(w, it));\n+    try!(write!(w, \"{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n                   it.name.as_ref().unwrap(),\n                   e.generics,\n@@ -1982,6 +1985,21 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+fn render_attributes(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n+    for attr in &it.attrs {\n+        match *attr {\n+            clean::Word(ref s) if *s == \"must_use\" => {\n+                try!(write!(w, \"#[{}]\\n\", s));\n+            }\n+            clean::NameValue(ref k, ref v) if *k == \"must_use\" => {\n+                try!(write!(w, \"#[{} = \\\"{}\\\"]\\n\", k, v));\n+            }\n+            _ => ()\n+        }\n+    }\n+    Ok(())\n+}\n+\n fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,"}, {"sha": "b09c3f730fc6476782f4d06a351813bfa3c6973c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -30,7 +30,6 @@\n #![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(test)]"}, {"sha": "6cada2e5614ba0abe9b32472484661bd5e8df336", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -33,7 +33,6 @@ Core encoding and decoding interfaces.\n #![feature(path)]\n #![feature(hash)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]"}, {"sha": "0a3abd5d1acc3cbe3787d7478d06d77e0dadc598", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -159,12 +159,12 @@ impl AsciiExt for u8 {\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as uint]\n+        ASCII_UPPERCASE_MAP[*self as usize]\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as uint]\n+        ASCII_LOWERCASE_MAP[*self as usize]\n     }\n \n     #[inline]"}, {"sha": "1d14b141778f052bf7dcbbd0db326df151f9c400", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -189,7 +189,7 @@ impl OsStr {\n         self.inner.to_string_lossy()\n     }\n \n-    /// Copy the slice into an onwed `OsString`.\n+    /// Copy the slice into an owned `OsString`.\n     pub fn to_os_string(&self) -> OsString {\n         OsString { inner: self.inner.to_owned() }\n     }"}, {"sha": "139693ccdbcb9c3c0d022c48b694d4234f100b29", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -279,7 +279,7 @@ pub mod sync;\n #[path = \"sys/common/mod.rs\"] mod sys_common;\n \n pub mod rt;\n-mod failure;\n+mod panicking;\n \n // Documentation for primitive types\n "}, {"sha": "7d15a16309e5b3f481a52440fa1df25b44d614da", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -30,6 +30,7 @@ use core::num;\n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f32::{MIN, MIN_POSITIVE, MAX};\n pub use core::f32::consts;\n \n #[allow(dead_code)]\n@@ -369,7 +370,7 @@ impl Float for f32 {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 10, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -382,7 +383,7 @@ pub fn to_string(num: f32) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 16, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -395,7 +396,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n+pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n@@ -410,7 +411,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -425,7 +426,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -441,7 +442,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -457,7 +458,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "0ce56371c77e544733a9dfc3a72a4ca2809b1e79", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -29,6 +29,7 @@ use core::num;\n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n+pub use core::f64::{MIN, MIN_POSITIVE, MAX};\n pub use core::f64::consts;\n \n #[allow(dead_code)]\n@@ -378,7 +379,7 @@ impl Float for f64 {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 10, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -391,7 +392,7 @@ pub fn to_string(num: f64) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 16u, true, SignNeg, DigAll, ExpNone, false);\n+        num, 16, true, SignNeg, DigAll, ExpNone, false);\n     r\n }\n \n@@ -404,7 +405,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * radix - The base to use\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n+pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n \n@@ -419,7 +420,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n }\n \n@@ -434,7 +435,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n+        num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n }\n \n@@ -450,7 +451,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n }\n \n@@ -466,7 +467,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n-        num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);\n+        num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r\n }\n "}, {"sha": "cf5e1eb0eb7ca4095ef85c2df69faa54a28f7398", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -182,7 +182,7 @@ fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F\n /// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n ///   between digit and exponent sign `'p'`.\n pub fn float_to_str_bytes_common<T: Float>(\n-        num: T, radix: uint, negative_zero: bool,\n+        num: T, radix: u32, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n         ) -> (Vec<u8>, bool) {\n     assert!(2 <= radix && radix <= 36);\n@@ -253,7 +253,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n         deccum = deccum / radix_gen;\n         deccum = deccum.trunc();\n \n-        buf.push(char::from_digit(current_digit.to_int().unwrap() as uint, radix)\n+        buf.push(char::from_digit(current_digit.to_int().unwrap() as u32, radix)\n              .unwrap() as u8);\n \n         // No more digits to calculate for the non-fractional part -> break\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n             let current_digit = deccum.trunc().abs();\n \n             buf.push(char::from_digit(\n-                current_digit.to_int().unwrap() as uint, radix).unwrap() as u8);\n+                current_digit.to_int().unwrap() as u32, radix).unwrap() as u8);\n \n             // Decrease the deccumulator one fractional digit at a time\n             deccum = deccum.fract();\n@@ -324,7 +324,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n             let ascii2value = |chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |val: u32| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n@@ -412,7 +412,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n /// `to_str_bytes_common()`, for details see there.\n #[inline]\n pub fn float_to_str_common<T: Float>(\n-        num: T, radix: uint, negative_zero: bool,\n+        num: T, radix: u32, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool\n         ) -> (String, bool) {\n     let (bytes, special) = float_to_str_bytes_common(num, radix,\n@@ -422,8 +422,8 @@ pub fn float_to_str_common<T: Float>(\n \n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n-static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n+static DIGIT_P_RADIX: u32 = ('p' as u32) - ('a' as u32) + 11;\n+static DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n \n #[cfg(test)]\n mod tests {"}, {"sha": "8dc19047de08e0f7b1f585d837b1c919d8a42352", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -32,7 +32,6 @@ use sys_common;\n ///\n /// ```rust,no_run\n /// # #![allow(unused_must_use)]\n-/// #![feature(slicing_syntax)]\n ///\n /// use std::old_io::net::udp::UdpSocket;\n /// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};"}, {"sha": "70cce1f7e769eab05f3619db65acf1fad2077ff4", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -30,7 +30,7 @@ use self::StdSource::*;\n use boxed::Box;\n use cell::RefCell;\n use clone::Clone;\n-use failure::LOCAL_STDERR;\n+use panicking::LOCAL_STDERR;\n use fmt;\n use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};"}, {"sha": "e485c6a63c6f12afff71491b993eaad02bb3107a", "filename": "src/libstd/panicking.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -33,7 +33,7 @@ impl Writer for Stdio {\n     }\n }\n \n-pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n+pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {", "previous_filename": "src/libstd/failure.rs"}, {"sha": "1f6d39fb1b3f4d3394f56b2db848209c2d017fa5", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1033,6 +1033,7 @@ impl AsOsStr for PathBuf {\n /// let parent_dir = path.parent();\n /// ```\n ///\n+#[derive(Hash)]\n pub struct Path {\n     inner: OsStr\n }"}, {"sha": "464adadde621507628df47794fc6766f379bbe02", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -62,7 +62,7 @@ use prelude::v1::*;\n use any::Any;\n use cell::Cell;\n use cmp;\n-use failure;\n+use panicking;\n use fmt;\n use intrinsics;\n use libc::c_void;\n@@ -534,10 +534,10 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) -> ! {\n-    // Make sure the default failure handler is registered before we look at the\n+    // Make sure the default panic handler is registered before we look at the\n     // callbacks.\n     static INIT: Once = ONCE_INIT;\n-    INIT.call_once(|| unsafe { register(failure::on_fail); });\n+    INIT.call_once(|| unsafe { register(panicking::on_panic); });\n \n     // First, invoke call the user-defined callbacks triggered on thread panic.\n     //"}, {"sha": "d783acd57ac04356fe6e6f06fa1e722f1cfbd1fd", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1024,14 +1024,14 @@ impl fmt::Display for TryRecvError {\n mod test {\n     use prelude::v1::*;\n \n-    use os;\n+    use std::env;\n     use super::*;\n     use thread::Thread;\n \n     pub fn stress_factor() -> uint {\n-        match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => val.parse().unwrap(),\n-            None => 1,\n+        match env::var(\"RUST_TEST_STRESS\") {\n+            Ok(val) => val.parse().unwrap(),\n+            Err(..) => 1,\n         }\n     }\n \n@@ -1546,14 +1546,14 @@ mod test {\n mod sync_tests {\n     use prelude::v1::*;\n \n-    use os;\n+    use std::env;\n     use thread::Thread;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n-        match os::getenv(\"RUST_TEST_STRESS\") {\n-            Some(val) => val.parse().unwrap(),\n-            None => 1,\n+        match env::var(\"RUST_TEST_STRESS\") {\n+            Ok(val) => val.parse().unwrap(),\n+            Err(..) => 1,\n         }\n     }\n "}, {"sha": "87b2fe8f100c36a8a22c5b9e209e4c039285a811", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -111,11 +111,18 @@ pub trait Packet {\n }\n \n impl Select {\n-    /// Creates a new selection structure. This set is initially empty and\n-    /// `wait` will panic!() if called.\n+    /// Creates a new selection structure. This set is initially empty.\n     ///\n-    /// Usage of this struct directly can sometimes be burdensome, and usage is\n-    /// rather much easier through the `select!` macro.\n+    /// Usage of this struct directly can sometimes be burdensome, and usage is much easier through\n+    /// the `select!` macro.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::mpsc::Select;\n+    ///\n+    /// let select = Select::new();\n+    /// ```\n     pub fn new() -> Select {\n         Select {\n             head: ptr::null_mut(),"}, {"sha": "f322cf8bad09cc103cdf627353b297be0dddd0d6", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -89,8 +89,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             match parser.token {\n                 token::Eof => break,\n                 _ => {\n-                    let attrs = parser.parse_outer_attributes();\n-                    ret.push(parser.parse_method(attrs, ast::Inherited))\n+                    ret.push(parser.parse_method_with_outer_attributes());\n                 }\n             }\n         }"}, {"sha": "fd1ca11818c9832575aefb9a57cc3463e4c20cb6", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -79,7 +79,7 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"tuple_indexing\", \"1.0.0\", Accepted),\n     (\"associated_types\", \"1.0.0\", Accepted),\n     (\"visible_private_types\", \"1.0.0\", Active),\n-    (\"slicing_syntax\", \"1.0.0\", Active),\n+    (\"slicing_syntax\", \"1.0.0\", Accepted),\n     (\"box_syntax\", \"1.0.0\", Active),\n     (\"on_unimplemented\", \"1.0.0\", Active),\n     (\"simd_ffi\", \"1.0.0\", Active),\n@@ -134,6 +134,7 @@ static KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // switch to Accepted; see RFC 320)\n     (\"unsafe_no_drop_flag\", \"1.0.0\", Active),\n ];\n+// (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n enum Status {\n     /// Represents an active feature that is currently being implemented or"}, {"sha": "f4b0c867f42c61ede7e931b0297b4709303d62a0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -35,7 +35,6 @@\n #![feature(path)]\n #![feature(quote, unsafe_destructor)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]"}, {"sha": "38ba0b38df5a7a6f8c51a8aa3859b6a7da56ccfa", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n \n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n-    fn scan_digits(&mut self, radix: usize) -> usize {\n+    fn scan_digits(&mut self, radix: u32) -> usize {\n         let mut len = 0;\n         loop {\n             let c = self.curr;"}, {"sha": "407740e580d2e30eff0e5d720d78dfc7490ee62a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -4650,6 +4650,17 @@ impl<'a> Parser<'a> {\n         self.parse_method(attrs, visa)\n     }\n \n+    fn complain_if_pub_macro(&mut self, visa: Visibility, span: Span) {\n+        match visa {\n+            Public => {\n+                self.span_err(span, \"can't qualify macro invocation with `pub`\");\n+                self.span_help(span, \"try adjusting the macro to put `pub` inside \\\n+                                      the invocation\");\n+            }\n+            Inherited => (),\n+        }\n+    }\n+\n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n                         attrs: Vec<Attribute>,\n@@ -4664,6 +4675,10 @@ impl<'a> Parser<'a> {\n                 && (self.look_ahead(2, |t| *t == token::OpenDelim(token::Paren))\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n                 // method macro.\n+\n+                let last_span = self.last_span;\n+                self.complain_if_pub_macro(visa, last_span);\n+\n                 let pth = self.parse_path(NoTypesAllowed);\n                 self.expect(&token::Not);\n \n@@ -5867,6 +5882,9 @@ impl<'a> Parser<'a> {\n                     || self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))) {\n             // MACRO INVOCATION ITEM\n \n+            let last_span = self.last_span;\n+            self.complain_if_pub_macro(visibility, last_span);\n+\n             // item macro.\n             let pth = self.parse_path(NoTypesAllowed);\n             self.expect(&token::Not);"}, {"sha": "c4b3d2813afe4e254838f13f9abf04e44df85872", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -57,7 +57,6 @@\n #![feature(io)]\n #![feature(path)]\n #![feature(rustc_private)]\n-#![feature(slicing_syntax)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]"}, {"sha": "82b5ec11d95d1dd8aef5c9f990ade25c9a950d27", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -297,7 +297,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                    Some(d) => d - 1,\n+                    Some(d) => d as usize - 1,\n                     None => return Err(\"bad param number\".to_string())\n                 }].clone());\n             },"}, {"sha": "860ce209d451f11199632fef2ea9288c908a8a29", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -32,7 +32,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(asm, slicing_syntax)]\n+#![feature(asm)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]"}, {"sha": "89b310d494971a60260e6b2587adc85cdaeac34c", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -31,8 +31,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(no_std)]\n #![no_std]\n-#![feature(slicing_syntax)]\n-#![feature(int_uint)]\n #![feature(core)]\n \n extern crate core;"}, {"sha": "61f447a3dd3b687a836c4f17f308aabd76ab41ca", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -14,7 +14,7 @@\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (7, 0, 0);\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n@@ -6977,7 +6977,7 @@ pub mod conversions {\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -7613,13 +7613,13 @@ pub mod charwidth {\n         }\n     }\n \n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n "}, {"sha": "c0f45ca4d7247e948143cc06a86595df4a3a5e09", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -36,7 +36,7 @@ pub trait CharExt {\n     /// Panics if given a radix > 36.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -51,7 +51,7 @@ pub trait CharExt {\n     /// Panics if given a radix outside the range [0..36].\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n@@ -80,12 +80,12 @@ pub trait CharExt {\n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n@@ -94,7 +94,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n@@ -103,7 +103,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -216,31 +216,31 @@ pub trait CharExt {\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint>;\n+    fn width(self, is_cjk: bool) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n+    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n+    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint { C::len_utf8(self) }\n+    fn len_utf8(self) -> usize { C::len_utf8(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint { C::len_utf16(self) }\n+    fn len_utf16(self) -> usize { C::len_utf16(self) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> { C::encode_utf8(self, dst) }\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n@@ -313,5 +313,5 @@ impl CharExt for char {\n \n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n+    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "9bd8c5525a056828966e0838637722518d0370f6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -43,7 +43,7 @@ pub trait UnicodeStr {\n     fn words<'a>(&'a self) -> Words<'a>;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn width(&self, is_cjk: bool) -> uint;\n+    fn width(&self, is_cjk: bool) -> usize;\n     fn trim<'a>(&'a self) -> &'a str;\n     fn trim_left<'a>(&'a self) -> &'a str;\n     fn trim_right<'a>(&'a self) -> &'a str;\n@@ -57,7 +57,7 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        GraphemeIndices { start_offset: self.as_ptr() as uint, iter: self.graphemes(is_extended) }\n+        GraphemeIndices { start_offset: self.as_ptr() as usize, iter: self.graphemes(is_extended) }\n     }\n \n     #[inline]\n@@ -78,7 +78,7 @@ impl UnicodeStr for str {\n     fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n-    fn width(&self, is_cjk: bool) -> uint {\n+    fn width(&self, is_cjk: bool) -> usize {\n         self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum()\n     }\n \n@@ -101,28 +101,28 @@ impl UnicodeStr for str {\n /// External iterator for grapheme clusters and byte offsets.\n #[derive(Clone)]\n pub struct GraphemeIndices<'a> {\n-    start_offset: uint,\n+    start_offset: usize,\n     iter: Graphemes<'a>,\n }\n \n impl<'a> Iterator for GraphemeIndices<'a> {\n-    type Item = (uint, &'a str);\n+    type Item = (usize, &'a str);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next_back().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next_back(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next_back().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n }\n \n@@ -151,7 +151,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     type Item = &'a str;\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let slen = self.string.len();\n         (cmp::min(slen, 1), Some(slen))\n     }\n@@ -378,8 +378,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+pub fn utf8_char_width(b: u8) -> usize {\n+    return UTF8_CHAR_WIDTH[b as usize] as usize;\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -468,7 +468,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.iter.size_hint();\n         // we could be entirely valid surrogates (2 elements per\n         // char), or entirely non-surrogates (1 element per char)\n@@ -534,7 +534,7 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.chars.size_hint();\n         // every char gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as"}, {"sha": "4891e6382e3e8aa89d530aa18427836428c47157", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1 +1 @@\n-Subproject commit 32c27dda3ae2318b6897f00795009cd6f42ac4b3\n+Subproject commit 4891e6382e3e8aa89d530aa18427836428c47157"}, {"sha": "60fd8abfcae50629a3fc664bd809238fed039617", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1 +1 @@\n-Subproject commit e577c97b494be2815b215e3042207d6d4b7c5516\n+Subproject commit 60fd8abfcae50629a3fc664bd809238fed039617"}, {"sha": "b29538ad62078639e9b4ca1522efca0555be3bd3", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slicing_syntax, box_syntax)]\n+#![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(io)]"}, {"sha": "6bb6f1ad2c7e8ef84e0512badbcd8ed62e11824e", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2015-02-09\n+2015-02-12"}, {"sha": "00f8feacff8cab0710b16b85f3864a92a2e1da8c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -17,6 +17,7 @@ use std::old_io::File;\n use std::iter::repeat;\n use std::mem::swap;\n use std::os;\n+use std::env;\n use std::rand::Rng;\n use std::rand;\n use std::str;\n@@ -46,7 +47,7 @@ fn main() {\n fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n     let mut run_test = false;\n \n-    if os::getenv(\"RUST_BENCH\").is_some() {\n+    if env::var_os(\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n         run_test = argv.iter().any(|x| x == &\"all\".to_string()) || argv.iter().any(|x| x == &name)"}, {"sha": "90cc222c3deba06188dc9788ad9b35817f64367f", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n use std::os;\n+use std::env;\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"10000000\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"100000\".to_string())"}, {"sha": "4e9c2fe99bd4a342fdecef0033ca366a2d7019fb", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -20,6 +20,7 @@\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::os;\n+use std::env;\n use std::thread::Thread;\n use std::time::Duration;\n \n@@ -94,7 +95,7 @@ fn run(args: &[String]) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"1000000\".to_string(), \"10000\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())"}, {"sha": "2530e8bd90707f31b2e9aa01d6693411516f64cb", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -16,6 +16,7 @@\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::os;\n+use std::env;\n use std::thread::Thread;\n use std::time::Duration;\n \n@@ -101,7 +102,7 @@ fn run(args: &[String]) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"1000000\".to_string(), \"8\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"4\".to_string())"}, {"sha": "a935a6b30864612eef5b356bf700f74c11de2274", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -19,6 +19,7 @@\n // ignore-lexer-test FIXME #15679\n \n use std::os;\n+use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};\n use std::time::Duration;\n \n@@ -64,7 +65,7 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100\".to_string(), \"10000\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10\".to_string(), \"100\".to_string())"}, {"sha": "933c1c218c376441004a08eb34a9405025299e4b", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::env;\n \n fn ack(m: int, n: int) -> int {\n     if m == 0 {\n@@ -24,7 +25,7 @@ fn ack(m: int, n: int) -> int {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"12\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"8\".to_string())"}, {"sha": "0311a1ac7c4e1e6ca4e79f69c1d660d8436730c0", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -86,7 +86,7 @@ fn inner(depth: i32, iterations: i32) -> String {\n fn main() {\n     let args = std::os::args();\n     let args = args;\n-    let n = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         17\n     } else if args.len() <= 1u {\n         8"}, {"sha": "628206986c51829a7a6d31c29dd2acd619f887f6", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -227,7 +227,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n }\n \n fn main() {\n-    let nn = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let nn = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         200000\n     } else {\n         std::os::args()"}, {"sha": "5bf0862e0a1d6b8d809ca254bee45dd3c56d8a9d", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -43,6 +43,7 @@ use std::old_io::{BufferedWriter, File};\n use std::old_io;\n use std::num::Float;\n use std::os;\n+use std::env;\n \n const LINE_LENGTH: uint = 60;\n const IM: u32 = 139968;\n@@ -105,7 +106,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n     let args = os::args();\n     let args = args;\n-    let n = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let n = if env::var_os(\"RUST_BENCH\").is_some() {\n         25000000\n     } else if args.len() <= 1u {\n         1000\n@@ -143,7 +144,7 @@ fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n }\n \n fn main() {\n-    let res = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let res = if env::var_os(\"RUST_BENCH\").is_some() {\n         let mut file = BufferedWriter::new(File::create(&Path::new(\"./shootout-fasta.data\")));\n         run(&mut file)\n     } else {"}, {"sha": "6a062ba3980d65606eb670b96ad1da7dd46416dc", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::env;\n \n fn fib(n: int) -> int {\n     if n < 2 {\n@@ -20,7 +21,7 @@ fn fib(n: int) -> int {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"40\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"30\".to_string())"}, {"sha": "3c96878179f3ab473e05ec3e1a2396f899c84a8b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -22,6 +22,7 @@ use std::mem::replace;\n use std::num::Float;\n use std::option;\n use std::os;\n+use std::env;\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::thread::Thread;\n \n@@ -148,7 +149,7 @@ fn make_sequence_processor(sz: uint,\n fn main() {\n     use std::old_io::{stdio, MemReader, BufferedReader};\n \n-    let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let rdr = if env::var_os(\"RUST_BENCH\").is_some() {\n         let foo = include_bytes!(\"shootout-k-nucleotide.data\");\n         box MemReader::new(foo.to_vec()) as Box<Reader>\n     } else {"}, {"sha": "ca920b2fa821c9470b1072db83da7b22ff4b07cc", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -291,7 +291,7 @@ fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n }\n \n fn main() {\n-    let input = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let input = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         let fd = std::old_io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n         get_sequence(&mut std::old_io::BufferedReader::new(fd), \">THREE\")\n     } else {"}, {"sha": "7904657bece2855dee67265f8f001d3a9c87cdf2", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -170,7 +170,7 @@ fn offset_momentum(bodies: &mut [Planet;N_BODIES]) {\n }\n \n fn main() {\n-    let n = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let n = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         5000000\n     } else {\n         std::os::args().get(1)"}, {"sha": "9abc808f88770f2a58269e427b523376bdd7b936", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -22,6 +22,7 @@ extern crate getopts;\n \n use std::sync::mpsc::{channel, Sender};\n use std::os;\n+use std::env;\n use std::result::Result::{Ok, Err};\n use std::thread::Thread;\n use std::time::Duration;\n@@ -89,7 +90,7 @@ fn stress(num_tasks: int) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"20\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"8\".to_string())"}, {"sha": "8356df8d8a184264390bdf7b342eda454a5d5e88", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -48,12 +48,13 @@ use std::thread::Thread;\n use std::mem;\n use std::num::Float;\n use std::os;\n+use std::env;\n use std::raw::Repr;\n use std::simd::f64x2;\n \n fn main() {\n     let args = os::args();\n-    let answer = spectralnorm(if os::getenv(\"RUST_BENCH\").is_some() {\n+    let answer = spectralnorm(if env::var_os(\"RUST_BENCH\").is_some() {\n         5500\n     } else if args.len() < 2 {\n         2000"}, {"sha": "8614f94da89ea87d03fdb2a70bc733876b112065", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -65,7 +65,7 @@ fn roundtrip(id: i32, tx: Sender<i32>, rx: Receiver<i32>) {\n \n fn main() {\n     let args = std::os::args();\n-    let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n+    let token = if std::env::var_os(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n         args.get(1).and_then(|arg| arg.parse().ok()).unwrap_or(1000)"}, {"sha": "e6948a1371c9ed401b3de108cbaf0c2554a4b5c3", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -12,6 +12,7 @@\n \n use std::collections::VecMap;\n use std::os;\n+use std::env;\n use std::time::Duration;\n \n fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n@@ -28,7 +29,7 @@ fn check_sequential(min: uint, max: uint, map: &VecMap<uint>) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100000\".to_string(), \"100\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10000\".to_string(), \"50\".to_string())"}, {"sha": "f09e64cb9c5eac8456a38c3cffb5226339ee1434", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unsafe_destructor, box_syntax)]\n \n-use std::os;\n+use std::env;\n use std::thread::Thread;\n use std::time::Duration;\n \n@@ -20,7 +20,7 @@ enum List<T> {\n }\n \n fn main() {\n-    let (repeat, depth) = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let (repeat, depth) = if env::var_os(\"RUST_BENCH\").is_some() {\n         (50, 1000)\n     } else {\n         (10, 10)"}, {"sha": "9edb4201098d6c4a472786205995832a416c051c", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -19,6 +19,7 @@\n \n use std::sync::mpsc::{channel, Sender};\n use std::os;\n+use std::env;\n use std::thread::Thread;\n \n fn child_generation(gens_left: uint, tx: Sender<()>) {\n@@ -39,7 +40,7 @@ fn child_generation(gens_left: uint, tx: Sender<()>) {\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"100000\".to_string())\n     } else if args.len() <= 1 {\n         vec!(\"\".to_string(), \"100\".to_string())"}, {"sha": "279b3fa432a3cb208eefc98c64d476e61209ec01", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::os;\n+use std::env;\n use std::thread::Thread;\n \n fn f(n: uint) {\n@@ -23,7 +24,7 @@ fn g() { }\n \n fn main() {\n     let args = os::args();\n-    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+    let args = if env::var_os(\"RUST_BENCH\").is_some() {\n         vec!(\"\".to_string(), \"400\".to_string())\n     } else if args.len() <= 1u {\n         vec!(\"\".to_string(), \"10\".to_string())"}, {"sha": "8809e9a257ddb0bd46cdb9abb22249102c508c8f", "filename": "src/test/compile-fail/pub-item-macro.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fpub-item-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fpub-item-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpub-item-macro.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #14660\n+\n+macro_rules! priv_x { () => {\n+    static x: u32 = 0;\n+}}\n+\n+macro_rules! pub_x { () => {\n+    pub priv_x!(); //~ ERROR can't qualify macro invocation with `pub`\n+    //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+}}\n+\n+mod foo {\n+    pub_x!();\n+}\n+\n+fn main() {\n+    let y: u32 = foo::x;\n+}"}, {"sha": "aa890550f1c4868aa6ac3a4734bb98dc02fe19c6", "filename": "src/test/compile-fail/pub-method-macro.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fpub-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Fpub-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpub-method-macro.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #18317\n+\n+mod bleh {\n+    macro_rules! defn {\n+        ($n:ident) => (\n+            fn $n (&self) -> i32 {\n+                println!(\"{}\", stringify!($n));\n+                1\n+            }\n+        )\n+    }\n+\n+    #[derive(Copy)]\n+    pub struct S;\n+\n+    impl S {\n+        pub defn!(f); //~ ERROR can't qualify macro invocation with `pub`\n+        //~^ HELP try adjusting the macro to put `pub` inside the invocation\n+    }\n+}\n+\n+fn main() {\n+    bleh::S.f();\n+}"}, {"sha": "6497439c3dc5756d07fa94b410f99d850d8886fb", "filename": "src/test/compile-fail/rustc-error.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Frustc-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Fcompile-fail%2Frustc-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frustc-error.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[rustc_error]\n+fn main() {\n+    //~^ ERROR compilation successful\n+}"}, {"sha": "74fca83f5f9157adb269616c7a19c4cfed6107e7", "filename": "src/test/run-make/rustdoc-must-use/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-make%2Frustdoc-must-use%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-make%2Frustdoc-must-use%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-must-use%2FMakefile?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all: lib.rs\n+\t$(HOST_RPATH_ENV) $(RUSTDOC) -w html -o $(TMPDIR)/doc lib.rs\n+\t$(HTMLDOCCK) $(TMPDIR)/doc lib.rs"}, {"sha": "cef79d4536bef0e88d5a46d14b7d2c251c701a63", "filename": "src/test/run-make/rustdoc-must-use/lib.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-make%2Frustdoc-must-use%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-make%2Frustdoc-must-use%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-must-use%2Flib.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"lib\"]\n+\n+// @has lib/struct.Struct.html //pre '#[must_use]'\n+#[must_use]\n+pub struct Struct {\n+    field: i32,\n+}\n+\n+// @has lib/enum.Enum.html //pre '#[must_use = \"message\"]'\n+#[must_use = \"message\"]\n+pub enum Enum {\n+    Variant(i32),\n+}"}, {"sha": "b1cb4d6e42c23f46c1c7a320526cf82fcc143ae6", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -15,14 +15,15 @@\n #![feature(unsafe_destructor)]\n \n use std::os;\n+use std::env;\n use std::old_io::process::Command;\n use std::str;\n use std::ops::{Drop, FnMut, FnOnce};\n \n #[inline(never)]\n fn foo() {\n     let _v = vec![1, 2, 3];\n-    if os::getenv(\"IS_TEST\").is_some() {\n+    if env::var_os(\"IS_TEST\").is_some() {\n         panic!()\n     }\n }"}, {"sha": "a71016fd88baaf6676c06df88de4340b424d1c1a", "filename": "src/test/run-pass/exec-env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fexec-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fexec-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexec-env.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -10,8 +10,8 @@\n \n // exec-env:TEST_EXEC_ENV=22\n \n-use std::os;\n+use std::env;\n \n pub fn main() {\n-    assert_eq!(os::getenv(\"TEST_EXEC_ENV\"), Some(\"22\".to_string()));\n+    assert_eq!(env::var(\"TEST_EXEC_ENV\"), Ok(\"22\".to_string()));\n }"}, {"sha": "bfe22712de8c3b2e0b4e5b2092fd6854b8a8b1da", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -19,18 +19,18 @@ macro_rules! t {\n \n pub fn main() {\n     // Basic usage\n-    t!(to_string(1.2345678e-5f64, 10u, true, SignNeg, DigMax(6), ExpDec, false),\n+    t!(to_string(1.2345678e-5f64, 10, true, SignNeg, DigMax(6), ExpDec, false),\n              \"1.234568e-5\");\n \n     // Hexadecimal output\n-    t!(to_string(7.281738281250e+01f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n+    t!(to_string(7.281738281250e+01f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n               \"+1.2345p+6\");\n-    t!(to_string(-1.777768135071e-02f64, 16u, true, SignAll, DigMax(6), ExpBin, false),\n+    t!(to_string(-1.777768135071e-02f64, 16, true, SignAll, DigMax(6), ExpBin, false),\n              \"-1.2345p-6\");\n \n     // Some denormals\n-    t!(to_string(4.9406564584124654e-324f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n+    t!(to_string(4.9406564584124654e-324f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1074\");\n-    t!(to_string(2.2250738585072009e-308f64, 10u, true, SignNeg, DigMax(6), ExpBin, false),\n+    t!(to_string(2.2250738585072009e-308f64, 10, true, SignNeg, DigMax(6), ExpBin, false),\n              \"1p-1022\");\n }"}, {"sha": "aa45a8c5d5f7f538576fdbcb177f9cfbd84fa902", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -13,6 +13,7 @@\n use std::slice::SliceExt;\n use std::old_io::{Command, fs, USER_RWX};\n use std::os;\n+use std::env;\n use std::old_path::BytesContainer;\n use std::rand::random;\n \n@@ -45,7 +46,7 @@ fn test() {\n     fs::copy(&my_path, &child_path).unwrap();\n \n     // Append the new directory to our own PATH.\n-    let mut path = os::split_paths(os::getenv(\"PATH\").unwrap_or(String::new()));\n+    let mut path = os::split_paths(env::var(\"PATH\").ok().unwrap_or(String::new()));\n     path.push(child_dir.clone());\n     let path = os::join_paths(&path).unwrap();\n "}, {"sha": "5bbc90b260639e0405b2ff91dd73a9ed510e1a40", "filename": "src/test/run-pass/issue-21909.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fissue-21909.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fissue-21909.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21909.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait A<X> {}\n+\n+trait B {\n+    type X;\n+    type Y: A<Self::X>;\n+}\n+\n+fn main () { }"}, {"sha": "9eb7d624c9921bf602fbc7ab34ddebcd994d73d9", "filename": "src/test/run-pass/process-remove-from-env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::old_io::Command;\n-use std::os;\n+use std::env;\n \n #[cfg(all(unix, not(target_os=\"android\")))]\n pub fn env_cmd() -> Command {\n@@ -31,17 +31,17 @@ pub fn env_cmd() -> Command {\n \n fn main() {\n     // save original environment\n-    let old_env = os::getenv(\"RUN_TEST_NEW_ENV\");\n+    let old_env = env::var_os(\"RUN_TEST_NEW_ENV\");\n \n-    os::setenv(\"RUN_TEST_NEW_ENV\", \"123\");\n+    env::set_var(\"RUN_TEST_NEW_ENV\", \"123\");\n \n     let mut cmd = env_cmd();\n     cmd.env_remove(\"RUN_TEST_NEW_ENV\");\n \n     // restore original environment\n     match old_env {\n-        None => os::unsetenv(\"RUN_TEST_NEW_ENV\"),\n-        Some(val) => os::setenv(\"RUN_TEST_NEW_ENV\", val)\n+        None => env::remove_var(\"RUN_TEST_NEW_ENV\"),\n+        Some(val) => env::set_var(\"RUN_TEST_NEW_ENV\", &val)\n     }\n \n     let prog = cmd.spawn().unwrap();"}, {"sha": "442eea13d6bacb6c8cf69c767be40d3c8d6d68ba", "filename": "src/test/run-pass/pub-item-inside-macro.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fpub-item-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fpub-item-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-item-inside-macro.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #14660\n+\n+mod bleh {\n+    macro_rules! foo {\n+        () => {\n+            pub fn bar() { }\n+        }\n+    }\n+\n+    foo!();\n+}\n+\n+fn main() {\n+    bleh::bar();\n+}"}, {"sha": "af2f217c1fbb2ca31d6a03f7e74fe74d554222d0", "filename": "src/test/run-pass/pub-method-inside-macro.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fpub-method-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Fpub-method-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpub-method-inside-macro.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #17436\n+\n+mod bleh {\n+    macro_rules! foo {\n+        () => {\n+            pub fn bar(&self) { }\n+        }\n+    }\n+\n+    pub struct S;\n+\n+    impl S {\n+        foo!();\n+    }\n+}\n+\n+fn main() {\n+    bleh::S.bar();\n+}"}, {"sha": "db414abb7ffc87478820738a37b5fdaa43b6148c", "filename": "src/test/run-pass/ranges-precedence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Franges-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5db290bf6df986a6acd5ce993f278c18e55ca37/src%2Ftest%2Frun-pass%2Franges-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Franges-precedence.rs?ref=c5db290bf6df986a6acd5ce993f278c18e55ca37", "patch": "@@ -10,7 +10,6 @@\n \n // Test that the precedence of ranges is correct\n \n-#![feature(slicing_syntax)]\n \n struct Foo {\n     foo: uint,"}]}