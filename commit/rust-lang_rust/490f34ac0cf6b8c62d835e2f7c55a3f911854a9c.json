{"sha": "490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MGYzNGFjMGNmNmI4YzYyZDgzNWUyZjdjNTVhM2Y5MTE4NTRhOWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-31T19:08:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-05T14:37:58Z"}, "message": "rustc: Remove `CrateStore::used_crate*`\n\nThis commit removes the `use_crates` and `used_crate_source` methods in favor of\na mix of queries and helper methods being used now instead.", "tree": {"sha": "fa1433ca2ed1e891d0ee4ff049aefb87eb584976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1433ca2ed1e891d0ee4ff049aefb87eb584976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "html_url": "https://github.com/rust-lang/rust/commit/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7e0aaba5c140a4d7db0023e5f8a685bcaec9bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7e0aaba5c140a4d7db0023e5f8a685bcaec9bd", "html_url": "https://github.com/rust-lang/rust/commit/0b7e0aaba5c140a4d7db0023e5f8a685bcaec9bd"}], "stats": {"total": 212, "additions": 120, "deletions": 92}, "files": [{"sha": "c684440296f4cb6ce3bf397910f27f70cea8653d", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -567,6 +567,8 @@ define_dep_nodes!( <'tcx>\n     [] VisibleParentMap,\n     [] IsDirectExternCrate(CrateNum),\n     [] MissingExternCrateItem(CrateNum),\n+    [] UsedCrateSource(CrateNum),\n+    [] PostorderCnums,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "68d871c4b30ec8e06607ecd39f788909e0c9b3c2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -23,7 +23,7 @@\n //! probably get a better home if someone can find one.\n \n use hir::def;\n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n@@ -251,14 +251,13 @@ pub trait CrateStore {\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics;\n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem;\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n@@ -340,9 +339,6 @@ impl CrateStore for DummyCrateStore {\n     fn crates(&self) -> Vec<CrateNum> { vec![] }\n \n     // utility functions\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n-        { vec![] }\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -352,6 +348,7 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> { bug!(\"postorder_cnums_untracked\") }\n \n     // access to the metadata loader\n     fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n@@ -361,3 +358,46 @@ pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions);\n     fn postprocess(&mut self, krate: &ast::Crate);\n }\n+\n+// This method is used when generating the command line to pass through to\n+// system linker. The linker expects undefined symbols on the left of the\n+// command line to be defined in libraries on the right, not the other way\n+// around. For more info, see some comments in the add_used_library function\n+// below.\n+//\n+// In order to get this left-to-right dependency ordering, we perform a\n+// topological sort of all crates putting the leaves at the right-most\n+// positions.\n+pub fn used_crates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)> {\n+    let mut libs = tcx.sess.cstore.crates()\n+        .into_iter()\n+        .filter_map(|cnum| {\n+            if tcx.dep_kind(cnum).macros_only() {\n+                return None\n+            }\n+            let source = tcx.used_crate_source(cnum);\n+            let path = match prefer {\n+                LinkagePreference::RequireDynamic => source.dylib.clone().map(|p| p.0),\n+                LinkagePreference::RequireStatic => source.rlib.clone().map(|p| p.0),\n+            };\n+            let path = match path {\n+                Some(p) => LibSource::Some(p),\n+                None => {\n+                    if source.rmeta.is_some() {\n+                        LibSource::MetadataOnly\n+                    } else {\n+                        LibSource::None\n+                    }\n+                }\n+            };\n+            Some((cnum, path))\n+        })\n+        .collect::<Vec<_>>();\n+    let mut ordering = tcx.postorder_cnums(LOCAL_CRATE);\n+    Rc::make_mut(&mut ordering).reverse();\n+    libs.sort_by_key(|&(a, _)| {\n+        ordering.iter().position(|x| *x == a)\n+    });\n+    libs\n+}"}, {"sha": "81c406f3cb1834224b1848a81d95baf22aaebb05", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -66,7 +66,7 @@ use hir::def_id::CrateNum;\n use session;\n use session::config;\n use ty::TyCtxt;\n-use middle::cstore::DepKind;\n+use middle::cstore::{self, DepKind};\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FxHashMap;\n use rustc_back::PanicStrategy;\n@@ -134,7 +134,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             for cnum in sess.cstore.crates() {\n                 if tcx.dep_kind(cnum).macros_only() { continue }\n-                let src = sess.cstore.used_crate_source(cnum);\n+                let src = tcx.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n                                   tcx.crate_name(cnum)));\n@@ -168,7 +168,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for cnum in sess.cstore.crates() {\n         if tcx.dep_kind(cnum).macros_only() { continue }\n         let name = tcx.crate_name(cnum);\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n             add_library(tcx, cnum, RequireDynamic, &mut formats);\n@@ -196,7 +196,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If the crate hasn't been included yet and it's not actually required\n     // (e.g. it's an allocator) then we skip it here as well.\n     for cnum in sess.cstore.crates() {\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n            tcx.dep_kind(cnum) == DepKind::Explicit {\n@@ -225,7 +225,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n         let cnum = CrateNum::new(cnum + 1);\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = tcx.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n             Linkage::IncludedFromDylib => {}\n@@ -274,7 +274,7 @@ fn add_library(tcx: TyCtxt,\n \n fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyList> {\n     let sess = &tcx.sess;\n-    let crates = sess.cstore.used_crates(RequireStatic);\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n     if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n         return None\n     }"}, {"sha": "78f85fd58ac881a3de637ac79f97b8352b0db14c", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -17,7 +17,7 @@ use hir::svh::Svh;\n use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n-use middle::cstore::{NativeLibraryKind, DepKind};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use middle::privacy::AccessLevels;\n use middle::region;\n use middle::region::RegionMaps;\n@@ -718,6 +718,18 @@ impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking at the source for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"generating a postorder list of CrateNums\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1331,6 +1343,8 @@ define_maps! { <'tcx>\n     [] visible_parent_map: visible_parent_map_node(CrateNum)\n         -> Rc<DefIdMap<DefId>>,\n     [] missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+    [] used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n+    [] postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1428,3 +1442,7 @@ fn get_lang_items_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn visible_parent_map_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::VisibleParentMap\n }\n+\n+fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::PostorderCnums\n+}"}, {"sha": "7f018a7f5a6d54dbfeec2f1c2427a482cc5f77a2", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -24,7 +24,7 @@ use rustc::session::config::{Sanitizer, self};\n use rustc_back::PanicStrategy;\n use rustc::session::search_paths::PathKind;\n use rustc::middle;\n-use rustc::middle::cstore::{CrateStore, validate_crate_name, ExternCrate};\n+use rustc::middle::cstore::{validate_crate_name, ExternCrate};\n use rustc::util::common::record_time;\n use rustc::util::nodemap::FxHashSet;\n use rustc::hir::map::Definitions;\n@@ -166,7 +166,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.cstore.used_crate_source(cnum);\n+            let source = &self.cstore.get_crate_data(cnum).source;\n             if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();"}, {"sha": "2d10dadaf64150563147e47231ef733600e265c6", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -150,52 +150,12 @@ impl CStore {\n         ordering.push(krate);\n     }\n \n-    // This method is used when generating the command line to pass through to\n-    // system linker. The linker expects undefined symbols on the left of the\n-    // command line to be defined in libraries on the right, not the other way\n-    // around. For more info, see some comments in the add_used_library function\n-    // below.\n-    //\n-    // In order to get this left-to-right dependency ordering, we perform a\n-    // topological sort of all crates putting the leaves at the right-most\n-    // positions.\n-    pub fn do_get_used_crates(&self,\n-                              prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, LibSource)> {\n+    pub fn do_postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n-        info!(\"topological ordering: {:?}\", ordering);\n-        ordering.reverse();\n-        let mut libs = self.metas\n-            .borrow()\n-            .iter()\n-            .filter_map(|(&cnum, data)| {\n-                if data.dep_kind.get().macros_only() { return None; }\n-                let path = match prefer {\n-                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n-                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n-                };\n-                let path = match path {\n-                    Some(p) => LibSource::Some(p),\n-                    None => {\n-                        if data.source.rmeta.is_some() {\n-                            LibSource::MetadataOnly\n-                        } else {\n-                            LibSource::None\n-                        }\n-                    }\n-                };\n-                Some((cnum, path))\n-            })\n-            .collect::<Vec<_>>();\n-        libs.sort_by(|&(a, _), &(b, _)| {\n-            let a = ordering.iter().position(|x| *x == a);\n-            let b = ordering.iter().position(|x| *x == b);\n-            a.cmp(&b)\n-        });\n-        libs\n+        return ordering\n     }\n \n     pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {"}, {"sha": "445ac601cb9737dc744c0fb644096a90167fbd88", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -15,9 +15,9 @@ use native_libs;\n use schema;\n \n use rustc::ty::maps::QueryConfig;\n-use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n+use rustc::middle::cstore::{CrateStore, DepKind,\n                             MetadataLoader, LinkMeta,\n-                            LinkagePreference, LoadedMacro, EncodedMetadata,\n+                            LoadedMacro, EncodedMetadata,\n                             EncodedMetadataHashes, NativeLibraryKind};\n use rustc::hir::def;\n use rustc::session::Session;\n@@ -229,6 +229,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n             _ => false,\n         }\n     }\n+\n+    used_crate_source => { Rc::new(cdata.source.clone()) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -332,6 +334,11 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n             Rc::new(visible_parent_map)\n         },\n \n+        postorder_cnums: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Rc::new(tcx.sess.cstore.postorder_cnums_untracked())\n+        },\n+\n         ..*providers\n     };\n }\n@@ -477,21 +484,15 @@ impl CrateStore for cstore::CStore {\n         result\n     }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n-    {\n-        self.do_get_used_crates(prefer)\n-    }\n-\n-    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource\n-    {\n-        self.get_crate_data(cnum).source.clone()\n-    }\n-\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n     {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n+    fn postorder_cnums_untracked(&self) -> Vec<CrateNum> {\n+        self.do_postorder_cnums_untracked()\n+    }\n+\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,"}, {"sha": "9bc6b737a6d2691bf561991c59ca7f675bf1d48d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -19,8 +19,7 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n-                            NativeLibraryKind};\n+use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n@@ -218,7 +217,7 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n pub fn each_linked_rlib(sess: &Session,\n                         info: &CrateInfo,\n                         f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic).into_iter();\n+    let crates = info.used_crates_static.iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n                    .or_else(|| fmts.get(&config::CrateTypeStaticlib))\n@@ -228,16 +227,16 @@ pub fn each_linked_rlib(sess: &Session,\n         Some(f) => f,\n         None => return Err(format!(\"could not find formats for rlibs\"))\n     };\n-    for (cnum, path) in crates {\n+    for &(cnum, ref path) in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked) |\n             Some(&Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n             None => return Err(format!(\"could not find formats for rlibs\"))\n         }\n         let name = &info.crate_name[&cnum];\n-        let path = match path {\n-            LibSource::Some(p) => p,\n+        let path = match *path {\n+            LibSource::Some(ref p) => p,\n             LibSource::MetadataOnly => {\n                 return Err(format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n                                    name))\n@@ -1028,7 +1027,7 @@ fn link_args(cmd: &mut Linker,\n             path\n         };\n         let mut rpath_config = RPathConfig {\n-            used_crates: sess.cstore.used_crates(LinkagePreference::RequireDynamic),\n+            used_crates: &trans.crate_info.used_crates_dynamic,\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.target.options.has_rpath,\n             is_like_osx: sess.target.target.options.is_like_osx,\n@@ -1107,21 +1106,21 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n-    let deps = sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n+    let deps = &trans.crate_info.used_crates_dynamic;\n \n     let mut compiler_builtins = None;\n \n-    for &(cnum, _) in &deps {\n+    for &(cnum, _) in deps.iter() {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = sess.cstore.used_crate_source(cnum);\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             _ if trans.crate_info.profiler_runtime == Some(cnum) => {\n                 add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n             _ if trans.crate_info.sanitizer_runtime == Some(cnum) => {\n-                link_sanitizer_runtime(cmd, sess, tmpdir, cnum);\n+                link_sanitizer_runtime(cmd, sess, trans, tmpdir, cnum);\n             }\n             // compiler-builtins are always placed last to ensure that they're\n             // linked correctly.\n@@ -1135,7 +1134,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 add_static_crate(cmd, sess, trans, tmpdir, crate_type, cnum);\n             }\n             Linkage::Dynamic => {\n-                add_dynamic_crate(cmd, sess, &src.dylib.unwrap().0)\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0)\n             }\n         }\n     }\n@@ -1164,10 +1163,11 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // linking it.\n     fn link_sanitizer_runtime(cmd: &mut Linker,\n                               sess: &Session,\n+                              trans: &CrateTranslation,\n                               tmpdir: &Path,\n                               cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         if sess.target.target.options.is_like_osx {\n             // On Apple platforms, the sanitizer is always built as a dylib, and\n@@ -1236,8 +1236,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                         tmpdir: &Path,\n                         crate_type: config::CrateType,\n                         cnum: CrateNum) {\n-        let src = sess.cstore.used_crate_source(cnum);\n-        let cratepath = &src.rlib.unwrap().0;\n+        let src = &trans.crate_info.used_crate_source[&cnum];\n+        let cratepath = &src.rlib.as_ref().unwrap().0;\n \n         // See the comment above in `link_staticlib` and `link_rlib` for why if\n         // there's a static library that's not relevant we skip all object\n@@ -1371,8 +1371,8 @@ fn add_upstream_native_libraries(cmd: &mut Linker,\n     let formats = sess.dependency_formats.borrow();\n     let data = formats.get(&crate_type).unwrap();\n \n-    let crates = sess.cstore.used_crates(LinkagePreference::RequireStatic);\n-    for (cnum, _) in crates {\n+    let crates = &trans.crate_info.used_crates_static;\n+    for &(cnum, _) in crates {\n         for lib in trans.crate_info.native_libraries[&cnum].iter() {\n             if !relevant_lib(sess, &lib) {\n                 continue"}, {"sha": "8e5e7d376488b7df5b69af8b100b736f6fe15a8d", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::CrateNum;\n use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, LibSource)>,\n+    pub used_crates: &'a [(CrateNum, LibSource)],\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -36,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n+    let libs = libs.iter().filter_map(|&(_, ref l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths));\n "}, {"sha": "b3db5a8730a0aa2f78f7135c58ede003a80b85fb", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -41,7 +41,7 @@ use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n-use rustc::middle::cstore::LinkMeta;\n+use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n@@ -1508,7 +1508,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n }\n \n impl CrateInfo {\n-    pub fn new(tcx: TyCtxt) -> CrateInfo {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,\n@@ -1519,11 +1519,15 @@ impl CrateInfo {\n             used_libraries: tcx.native_libraries(LOCAL_CRATE),\n             link_args: tcx.link_args(LOCAL_CRATE),\n             crate_name: FxHashMap(),\n+            used_crates_dynamic: cstore::used_crates(tcx, LinkagePreference::RequireDynamic),\n+            used_crates_static: cstore::used_crates(tcx, LinkagePreference::RequireStatic),\n+            used_crate_source: FxHashMap(),\n         };\n \n         for cnum in tcx.sess.cstore.crates() {\n             info.native_libraries.insert(cnum, tcx.native_libraries(cnum));\n             info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n             if tcx.is_panic_runtime(cnum) {\n                 info.panic_runtime = Some(cnum);\n             }"}, {"sha": "ab0c646ccd040b6d630853e25e02d1150b6e9346", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/490f34ac0cf6b8c62d835e2f7c55a3f911854a9c/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=490f34ac0cf6b8c62d835e2f7c55a3f911854a9c", "patch": "@@ -70,7 +70,7 @@ use std::rc::Rc;\n \n use rustc::hir::def_id::CrateNum;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n-use rustc::middle::cstore::NativeLibrary;\n+use rustc::middle::cstore::{NativeLibrary, CrateSource, LibSource};\n \n pub mod back {\n     mod archive;\n@@ -237,6 +237,9 @@ pub struct CrateInfo {\n     crate_name: FxHashMap<CrateNum, String>,\n     used_libraries: Rc<Vec<NativeLibrary>>,\n     link_args: Rc<Vec<String>>,\n+    used_crate_source: FxHashMap<CrateNum, Rc<CrateSource>>,\n+    used_crates_static: Vec<(CrateNum, LibSource)>,\n+    used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}]}