{"sha": "4f105e4025729047f60d2adef01d31e905aec222", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTA1ZTQwMjU3MjkwNDdmNjBkMmFkZWYwMWQzMWU5MDVhZWMyMjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-03T16:17:58Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-05-07T21:43:31Z"}, "message": "In resolve, visit the path in an iface ref\n\nNecessary to resolve any type arguments in a ref to a parameterized\niface. This meant that, for example:\n\nclass A implements B<int> { ...\n\ndidn't work before, because the \"int\" in B's argument wasn't getting\nvisited, and thus wasn't getting resolved. Now it works.\n\nPartially addresses Issue #2288, but I also want to check that class\nty params can appear as the type arguments to ifaces (for example,\n\nclass A<T> implements B<T> {...\n\nshould work.)", "tree": {"sha": "3f3a7648e056caaf23b5b9f8af22e3f5dd28c302", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f3a7648e056caaf23b5b9f8af22e3f5dd28c302"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f105e4025729047f60d2adef01d31e905aec222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f105e4025729047f60d2adef01d31e905aec222", "html_url": "https://github.com/rust-lang/rust/commit/4f105e4025729047f60d2adef01d31e905aec222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f105e4025729047f60d2adef01d31e905aec222/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1226669172ee257fc010af5b4cadc4b72965823e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1226669172ee257fc010af5b4cadc4b72965823e", "html_url": "https://github.com/rust-lang/rust/commit/1226669172ee257fc010af5b4cadc4b72965823e"}], "stats": {"total": 121, "additions": 109, "deletions": 12}, "files": [{"sha": "f17a2836ee5ebbacad96bcf9b426d512006ec328", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -242,6 +242,9 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                         ty::ty_class(parent_id, ts) {\n                             /* ...and if it has a class type, prepend the\n                                class bounds onto the method bounds */\n+                            /* n.b. this code is very likely sketchy --\n+                             currently, class-impl-very-parameterized-iface\n+                             fails here and is thus xfailed */\n                             bounds =\n                              @(*ty::lookup_item_type(cx.tcx, parent_id).bounds\n                                + *bounds);\n@@ -260,6 +263,13 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                 }\n               }\n             };\n+            if vec::len(ts) != vec::len(*bounds) {\n+              // Fail earlier to make debugging easier\n+              fail #fmt(\"Internal error: in kind::check_expr, length \\\n+                  mismatch between actual and declared bounds: actual = \\\n+                  %s (%u tys), declared = %s (%u tys)\", ts, ts.len(),\n+                        *bounds, bounds.len());\n+            }\n             vec::iter2(ts, *bounds) {|ty, bound|\n                 check_bounds(cx, e.span, ty, bound)\n             }"}, {"sha": "a25b84ea89b5ddcbf350ebdf6138b5d0679f590c", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -430,17 +430,17 @@ fn resolve_names(e: @env, c: @ast::crate) {\n \n     fn walk_item(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(e, i, sc, v);\n-        /*\n-          Resolve the ifaces that a class implements; do nothing for\n-          non-class items\n-         */\n         alt i.node {\n-          ast::item_class(_, ifaces, _, _, _) {\n-            /* visit the iface paths... */\n-            for ifaces.each {|p| resolve_iface_ref(p, sc, e) ;}\n-          }\n+          /* At this point, the code knows what ifaces the iface refs\n+             refer to, so it's possible to resolve them.\n+           */\n           ast::item_impl(_, _, ifce, _, _) {\n-            ifce.iter { |p| resolve_iface_ref(p, sc, e); }\n+            ifce.iter {|p| resolve_iface_ref(p, sc, e);}\n+          }\n+          ast::item_class(_, ifaces, _, _, _) {\n+            for ifaces.each {|p|\n+               resolve_iface_ref(p, sc, e);\n+            }\n           }\n           _ {}\n         }\n@@ -529,6 +529,10 @@ fn resolve_names(e: @env, c: @ast::crate) {\n \n \n // Visit helper functions\n+/*\n+  This is used in more than one context, thus should only call generic\n+  visit methods. Called both from map_crate and resolve_names.\n+ */\n fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n     // Some magic here. Items with the !resolve_unexported attribute\n     // cause us to consider every name to be exported when resolving their\n@@ -567,6 +571,12 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         /* visit the constructor... */\n         let ctor_scope = cons(scope_method(ctor.node.self_id, tps),\n                               @class_scope);\n+        /*\n+          but, I should visit the ifaces refs in the class scope, no?\n+         */\n+        for ifaces.each {|p|\n+            visit::visit_path(p.path, class_scope, v);\n+        }\n         visit_fn_with_scope(e, visit::fk_item_fn(i.ident, tps), ctor.node.dec,\n                             ctor.node.body, ctor.span, ctor.node.id,\n                             ctor_scope, v);"}, {"sha": "dd2c3071b3b895d8b9120b5bddc78afe1ca20027", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -12,8 +12,7 @@ import metadata::csearch;\n import util::common::*;\n import util::ppaux::region_to_str;\n import util::ppaux::vstore_to_str;\n-import util::ppaux::ty_to_str;\n-import util::ppaux::ty_constr_to_str;\n+import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n import syntax::print::pprust::*;\n \n export ty_vid, region_vid, vid;"}, {"sha": "5d63d8c4e68024f2c93d156e28e3eb2603cafe3a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -1,6 +1,7 @@\n import result::{result, extensions};\n import syntax::{ast, ast_util};\n import ast::spanned;\n+import ast_map::node_id_to_str;\n import syntax::ast_util::{local_def, respan, split_class_items};\n import syntax::visit;\n import metadata::csearch;\n@@ -12,7 +13,7 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::ty::{ty_vid, region_vid, vid};\n-import util::ppaux::{ty_to_str, region_to_str,\n+import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                      bound_region_to_str, vstore_to_str};\n import std::smallintmap;\n import std::smallintmap::map;\n@@ -1639,6 +1640,8 @@ mod collect {\n             let fty = ty::mk_fn(tcx, mty.fty);\n             tcx.tcache.insert(\n                 local_def(m.id),\n+                // n.b. This code is kind of sketchy (concat'ing i_bounds\n+                // with bounds), but removing *i_bounds breaks other stuff\n                 {bounds: @(*i_bounds + *bounds), rp: rp, ty: fty});\n             write_ty_to_tcx(tcx, m.id, fty);\n             {mty: mty, id: m.id, span: m.span}"}, {"sha": "d5758605d63ffd9fbba82c54008862e0a1a04940", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -84,6 +84,12 @@ fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> str {\n     }\n }\n \n+fn tys_to_str(cx: ctxt, ts: [t]) -> str {\n+    let mut rs = \"\";\n+    for ts.each {|t| rs += ty_to_str(cx, t); }\n+    rs\n+}\n+\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        str {"}, {"sha": "1acce7da7d6df402fd2e4bdbd998b42153401d71", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4f105e4025729047f60d2adef01d31e905aec222/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f105e4025729047f60d2adef01d31e905aec222/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=4f105e4025729047f60d2adef01d31e905aec222", "patch": "@@ -0,0 +1,69 @@\n+// xfail-fast\n+use std;\n+import std::map::*;\n+\n+class cat implements map<int, bool> {\n+  priv {\n+    // Yes, you can have negative meows\n+    let mut meows : int;\n+    fn meow() {\n+      self.meows += 1;\n+      #error(\"Meow %d\", self.meows);\n+      if self.meows % 5 == 0 {\n+          self.how_hungry += 1;\n+      }\n+    }\n+  }\n+\n+  let mut how_hungry : int;\n+  let name : str;\n+\n+  new(in_x : int, in_y : int, in_name: str)\n+    { self.meows = in_x; self.how_hungry = in_y; self.name = in_name; }\n+\n+  fn speak() { self.meow(); }\n+\n+  fn eat() -> bool {\n+    if self.how_hungry > 0 {\n+        #error(\"OM NOM NOM\");\n+        self.how_hungry -= 2;\n+        ret true;\n+    }\n+    else {\n+        #error(\"Not hungry!\");\n+        ret false;\n+    }\n+  }\n+\n+  fn size() -> uint { self.meows as uint }\n+  fn insert(&&k: int, &&v: bool) -> bool { \n+    if v { self.meows += k; } else { self.meows -= k; };\n+    true\n+  }\n+  fn contains_key(&&k: int) -> bool { k <= self.meows }\n+  fn get(&&k:int) -> bool { k <= self.meows }\n+  fn find(&&k:int) -> option<bool> { some(self.get(k)) }\n+  fn remove(&&k:int) -> option<bool> { self.meows -= k; some(true) }\n+  fn each(f: fn(&&int, &&bool) -> bool) {\n+    let mut n = int::abs(self.meows);\n+    while n > 0 {\n+        if !f(n, true) { break; }\n+        n -= 1;\n+    }\n+  }\n+  fn each_key(&&f: fn(&&int) -> bool) {\n+    for self.each {|k, _v| if !f(k) { break; } cont;};\n+  }\n+  fn each_value(&&f: fn(&&bool) -> bool) {\n+    for self.each {|_k, v| if !f(v) { break; } cont;};\n+  }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(0, 2, \"nyan\");\n+  uint::range(1u, 5u) {|_i| nyan.speak(); }\n+  // cat returns true if uint input is greater than\n+  // the number of meows so far\n+  assert(nyan.get(1));\n+  assert(!nyan.get(10));\n+}"}]}