{"sha": "ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "node_id": "C_kwDOAAsO6NoAKGFiMmJkNDFjZTBkYTc5ZjgyZTdiZmQyODFiYjc0NmE2ZWVlMjEzNDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T17:13:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-05T17:13:03Z"}, "message": "Auto merge of #92123 - m-ou-se:thread-local-cell-methods, r=joshtriplett\n\nImplement RFC 3184 - thread local cell methods\n\nThis implements [RFC 3184](https://github.com/rust-lang/rfcs/pull/3184), with `@danielhenrymantilla's` [suggestion](https://github.com/rust-lang/rfcs/pull/3184#issuecomment-965773616) for the `with_` method names.\n\nTracking issue: https://github.com/rust-lang/rust/issues/92122", "tree": {"sha": "eb5d60d6000cb4de4893853ddc87a6cc8e88ea98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb5d60d6000cb4de4893853ddc87a6cc8e88ea98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "html_url": "https://github.com/rust-lang/rust/commit/ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379e94f5a4aebe7dc2d8742653ca244d92b06f3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/379e94f5a4aebe7dc2d8742653ca244d92b06f3d", "html_url": "https://github.com/rust-lang/rust/commit/379e94f5a4aebe7dc2d8742653ca244d92b06f3d"}, {"sha": "a6e7f26f5ae323b1b7180913fb54f7c7510b7f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e7f26f5ae323b1b7180913fb54f7c7510b7f29", "html_url": "https://github.com/rust-lang/rust/commit/a6e7f26f5ae323b1b7180913fb54f7c7510b7f29"}], "stats": {"total": 565, "additions": 492, "deletions": 73}, "files": [{"sha": "36e6032b5e4e5204c4d51a4aa822cabe45ba7066", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -249,6 +249,7 @@\n #![feature(const_ip)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_mut_refs)]\n #![feature(const_option)]\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]"}, {"sha": "a100444f04968b9ff653991d03556445451a218d", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 371, "deletions": 10, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -8,6 +8,7 @@ mod tests;\n #[cfg(test)]\n mod dynamic_tests;\n \n+use crate::cell::{Cell, RefCell};\n use crate::error::Error;\n use crate::fmt;\n \n@@ -108,7 +109,7 @@ pub struct LocalKey<T: 'static> {\n     // trivially devirtualizable by LLVM because the value of `inner` never\n     // changes and the constant should be readonly within a crate. This mainly\n     // only runs into problems when TLS statics are exported across crates.\n-    inner: unsafe fn() -> Option<&'static T>,\n+    inner: unsafe fn(Option<&mut Option<T>>) -> Option<&'static T>,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -178,7 +179,9 @@ macro_rules! __thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[cfg_attr(not(windows), inline(always))] // see comments below\n-        unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n             const INIT_EXPR: $t = $init;\n \n             // wasm without atomics maps directly to `static mut`, and dtors\n@@ -260,7 +263,18 @@ macro_rules! __thread_local_inner {\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n                 #[allow(unused_unsafe)]\n-                unsafe { __KEY.get(__init) }\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = _init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                unreachable!(\"missing initial value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n             }\n         }\n \n@@ -298,7 +312,9 @@ macro_rules! __thread_local_inner {\n             //\n             // The issue of \"should enable on Windows sometimes\" is #84933\n             #[cfg_attr(not(windows), inline(always))]\n-            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n                 #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n@@ -322,7 +338,18 @@ macro_rules! __thread_local_inner {\n                 // raise warning for missing/extraneous unsafe blocks anymore.\n                 // See https://github.com/rust-lang/rust/issues/74838.\n                 #[allow(unused_unsafe)]\n-                unsafe { __KEY.get(__init) }\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n             }\n \n             unsafe {\n@@ -367,7 +394,9 @@ impl<T: 'static> LocalKey<T> {\n         issue = \"none\"\n     )]\n     #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n+    pub const unsafe fn new(\n+        inner: unsafe fn(Option<&mut Option<T>>) -> Option<&'static T>,\n+    ) -> LocalKey<T> {\n         LocalKey { inner }\n     }\n \n@@ -409,10 +438,342 @@ impl<T: 'static> LocalKey<T> {\n         F: FnOnce(&T) -> R,\n     {\n         unsafe {\n-            let thread_local = (self.inner)().ok_or(AccessError)?;\n+            let thread_local = (self.inner)(None).ok_or(AccessError)?;\n             Ok(f(thread_local))\n         }\n     }\n+\n+    /// Acquires a reference to the value in this TLS key, initializing it with\n+    /// `init` if it wasn't already initialized on this thread.\n+    ///\n+    /// If `init` was used to initialize the thread local variable, `None` is\n+    /// passed as the first argument to `f`. If it was already initialized,\n+    /// `Some(init)` is passed to `f`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the key currently has its destructor\n+    /// running, and it **may** panic if the destructor has previously been run\n+    /// for this thread.\n+    fn initialize_with<F, R>(&'static self, init: T, f: F) -> R\n+    where\n+        F: FnOnce(Option<T>, &T) -> R,\n+    {\n+        unsafe {\n+            let mut init = Some(init);\n+            let reference = (self.inner)(Some(&mut init)).expect(\n+                \"cannot access a Thread Local Storage value \\\n+                 during or after destruction\",\n+            );\n+            f(init, reference)\n+        }\n+    }\n+}\n+\n+impl<T: 'static> LocalKey<Cell<T>> {\n+    /// Sets or initializes the contained value.\n+    ///\n+    /// Unlike the other methods, this will *not* run the lazy initializer of\n+    /// the thread local. Instead, it will be directly initialized with the\n+    /// given value if it wasn't initialized yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = panic!(\"!\");\n+    /// }\n+    ///\n+    /// // Calling X.get() here would result in a panic.\n+    ///\n+    /// X.set(123); // But X.set() is fine, as it skips the initializer above.\n+    ///\n+    /// assert_eq!(X.get(), 123);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn set(&'static self, value: T) {\n+        self.initialize_with(Cell::new(value), |value, cell| {\n+            if let Some(value) = value {\n+                // The cell was already initialized, so `value` wasn't used to\n+                // initialize it. So we overwrite the current value with the\n+                // new one instead.\n+                cell.set(value.into_inner());\n+            }\n+        });\n+    }\n+\n+    /// Returns a copy of the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = Cell::new(1);\n+    /// }\n+    ///\n+    /// assert_eq!(X.get(), 1);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn get(&'static self) -> T\n+    where\n+        T: Copy,\n+    {\n+        self.with(|cell| cell.get())\n+    }\n+\n+    /// Takes the contained value, leaving `Default::default()` in its place.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<Option<i32>> = Cell::new(Some(1));\n+    /// }\n+    ///\n+    /// assert_eq!(X.take(), Some(1));\n+    /// assert_eq!(X.take(), None);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn take(&'static self) -> T\n+    where\n+        T: Default,\n+    {\n+        self.with(|cell| cell.take())\n+    }\n+\n+    /// Replaces the contained value, returning the old value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = Cell::new(1);\n+    /// }\n+    ///\n+    /// assert_eq!(X.replace(2), 1);\n+    /// assert_eq!(X.replace(3), 2);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn replace(&'static self, value: T) -> T {\n+        self.with(|cell| cell.replace(value))\n+    }\n+}\n+\n+impl<T: 'static> LocalKey<RefCell<T>> {\n+    /// Acquires a reference to the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently mutably borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_borrow(|v| assert!(v.is_empty()));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn with_borrow<F, R>(&'static self, f: F) -> R\n+    where\n+        F: FnOnce(&T) -> R,\n+    {\n+        self.with(|cell| f(&cell.borrow()))\n+    }\n+\n+    /// Acquires a mutable reference to the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_borrow_mut(|v| v.push(1));\n+    ///\n+    /// X.with_borrow(|v| assert_eq!(*v, vec![1]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn with_borrow_mut<F, R>(&'static self, f: F) -> R\n+    where\n+        F: FnOnce(&mut T) -> R,\n+    {\n+        self.with(|cell| f(&mut cell.borrow_mut()))\n+    }\n+\n+    /// Sets or initializes the contained value.\n+    ///\n+    /// Unlike the other methods, this will *not* run the lazy initializer of\n+    /// the thread local. Instead, it will be directly initialized with the\n+    /// given value if it wasn't initialized yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = panic!(\"!\");\n+    /// }\n+    ///\n+    /// // Calling X.with() here would result in a panic.\n+    ///\n+    /// X.set(vec![1, 2, 3]); // But X.set() is fine, as it skips the initializer above.\n+    ///\n+    /// X.with_borrow(|v| assert_eq!(*v, vec![1, 2, 3]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn set(&'static self, value: T) {\n+        self.initialize_with(RefCell::new(value), |value, cell| {\n+            if let Some(value) = value {\n+                // The cell was already initialized, so `value` wasn't used to\n+                // initialize it. So we overwrite the current value with the\n+                // new one instead.\n+                *cell.borrow_mut() = value.into_inner();\n+            }\n+        });\n+    }\n+\n+    /// Takes the contained value, leaving `Default::default()` in its place.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_borrow_mut(|v| v.push(1));\n+    ///\n+    /// let a = X.take();\n+    ///\n+    /// assert_eq!(a, vec![1]);\n+    ///\n+    /// X.with_borrow(|v| assert!(v.is_empty()));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn take(&'static self) -> T\n+    where\n+        T: Default,\n+    {\n+        self.with(|cell| cell.take())\n+    }\n+\n+    /// Replaces the contained value, returning the old value.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// let prev = X.replace(vec![1, 2, 3]);\n+    /// assert!(prev.is_empty());\n+    ///\n+    /// X.with_borrow(|v| assert_eq!(*v, vec![1, 2, 3]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"92122\")]\n+    pub fn replace(&'static self, value: T) -> T {\n+        self.with(|cell| cell.replace(value))\n+    }\n }\n \n mod lazy {\n@@ -518,7 +879,7 @@ pub mod statik {\n             Key { inner: LazyKeyInner::new() }\n         }\n \n-        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n+        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: The caller must ensure no reference is ever handed out to\n             // the inner cell nor mutable reference to the Option<T> inside said\n             // cell. This make it safe to hand a reference, though the lifetime\n@@ -707,7 +1068,7 @@ pub mod os {\n \n         /// It is a requirement for the caller to ensure that no mutable\n         /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n+        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: See the documentation for this method.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n             if ptr as usize > 1 {\n@@ -725,7 +1086,7 @@ pub mod os {\n         // `try_initialize` is only called once per os thread local variable,\n         // except in corner cases where thread_local dtors reference other\n         // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n+        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: No mutable references are ever handed out meaning getting\n             // the value is ok.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };"}, {"sha": "ce847c86bedde078bf1190e1127ba9f86d8fa6d8", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.rs?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -45,13 +45,15 @@ thread_local! {\n     //~| ERROR this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n+    //~| ERROR this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n }\n thread_local! {\n     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n     //~^ ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n+    //~| ERROR this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n     //~| ERROR missing lifetime\n     //~| ERROR missing lifetime\n }"}, {"sha": "b04ea1c9158df41d7692e79859099fb46c3dca15", "filename": "src/test/ui/suggestions/missing-lifetime-specifier.stderr", "status": "modified", "additions": 111, "deletions": 58, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lifetime-specifier.stderr?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -13,14 +13,15 @@ LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo<'static, 'static>>>>> = RefC\n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:18:44\n    |\n-LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::new());\n-   |                                            ^^^ expected 2 lifetime parameters\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static a: RefCell<HashMap<i32, Vec<Vec<Foo<'static, 'static>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~~~~~~~~~~~~~~\n+LL | / thread_local! {\n+LL | |     static a: RefCell<HashMap<i32, Vec<Vec<Foo>>>> = RefCell::new(HashMap::new());\n+   | |                                            ^^^ expected 2 lifetime parameters\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:23:44\n@@ -49,26 +50,32 @@ LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = Ref\n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:23:44\n    |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&'static Bar>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n+LL | / thread_local! {\n+LL | |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   | |                                            ^ expected named lifetime parameter\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:23:45\n    |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n-   |                                             ^^^ expected 2 lifetime parameters\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar<'static, 'static>>>>> = RefCell::new(HashMap::new());\n-   |                                             ~~~~~~~~~~~~~~~~~~~~~\n+LL | / thread_local! {\n+LL | |     static b: RefCell<HashMap<i32, Vec<Vec<&Bar>>>> = RefCell::new(HashMap::new());\n+   | |                                             ^^^ expected 2 lifetime parameters\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:30:48\n@@ -85,14 +92,15 @@ LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> =\n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:30:48\n    |\n-LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                ^ expected 2 lifetime parameters\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n+LL | / thread_local! {\n+LL | |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<i32>>>>> = RefCell::new(HashMap::new());\n+   | |                                                ^ expected 2 lifetime parameters\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n    |\n-LL |     static c: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                +++++++++++++++++\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:35:44\n@@ -121,26 +129,50 @@ LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>>\n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lifetime-specifier.rs:35:44\n    |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n-   |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n-   |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&'static Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n+LL | / thread_local! {\n+LL | |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   | |                                            ^ expected named lifetime parameter\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n \n error[E0106]: missing lifetime specifiers\n   --> $DIR/missing-lifetime-specifier.rs:35:49\n    |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                 ^ expected 2 lifetime parameters\n+LL | / thread_local! {\n+LL | |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<i32>>>>> = RefCell::new(HashMap::new());\n+   | |                                                 ^ expected 2 lifetime parameters\n+LL | |\n+LL | |\n+LL | |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 4 lifetimes it is borrowed from\n+\n+error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n+  --> $DIR/missing-lifetime-specifier.rs:43:44\n    |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                            ^^^ ------- supplied 1 lifetime argument\n+   |                                            |\n+   |                                            expected 2 lifetime arguments\n    |\n-LL |     static d: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                                 +++++++++++++++++\n+note: union defined here, with 2 lifetime parameters: `'t`, `'k`\n+  --> $DIR/missing-lifetime-specifier.rs:11:11\n+   |\n+LL | pub union Qux<'t, 'k, I> {\n+   |           ^^^ --  --\n+help: add missing lifetime argument\n+   |\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                       ++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n   --> $DIR/missing-lifetime-specifier.rs:43:44\n@@ -157,7 +189,7 @@ LL | pub union Qux<'t, 'k, I> {\n    |           ^^^ --  --\n help: add missing lifetime argument\n    |\n-LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n+LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, 'k, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                       ++++\n \n error[E0107]: this union takes 2 lifetime arguments but 1 lifetime argument was supplied\n@@ -215,7 +247,7 @@ LL |     static e: RefCell<HashMap<i32, Vec<Vec<Qux<'static, '_, i32>>>>> = RefC\n    |                                                       ++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:50:45\n+  --> $DIR/missing-lifetime-specifier.rs:51:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -233,7 +265,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = Ref\n    |                                                        ++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:50:44\n+  --> $DIR/missing-lifetime-specifier.rs:51:44\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                            ^ expected named lifetime parameter\n@@ -245,7 +277,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> =\n    |                                            ~~~~~~~~\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:50:45\n+  --> $DIR/missing-lifetime-specifier.rs:51:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -263,19 +295,40 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = Ref\n    |                                                        ++++\n \n error[E0106]: missing lifetime specifier\n-  --> $DIR/missing-lifetime-specifier.rs:50:44\n+  --> $DIR/missing-lifetime-specifier.rs:51:44\n+   |\n+LL | / thread_local! {\n+LL | |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n+   | |                                            ^ expected named lifetime parameter\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_-\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `init`'s 3 lifetimes it is borrowed from\n+\n+error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n+  --> $DIR/missing-lifetime-specifier.rs:51:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ^ expected named lifetime parameter\n+   |                                             ^^^ ------- supplied 1 lifetime argument\n+   |                                             |\n+   |                                             expected 2 lifetime arguments\n    |\n-   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n-help: consider using the `'static` lifetime\n+note: trait defined here, with 2 lifetime parameters: `'t`, `'k`\n+  --> $DIR/missing-lifetime-specifier.rs:15:7\n    |\n-LL |     static f: RefCell<HashMap<i32, Vec<Vec<&'static Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n-   |                                            ~~~~~~~~\n+LL | trait Tar<'t, 'k, I> {}\n+   |       ^^^ --  --\n+help: add missing lifetime argument\n+   |\n+LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = RefCell::new(HashMap::new());\n+   |                                                        ++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:50:45\n+  --> $DIR/missing-lifetime-specifier.rs:51:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -293,7 +346,7 @@ LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, 'k, i32>>>>> = Ref\n    |                                                        ++++\n \n error[E0107]: this trait takes 2 lifetime arguments but 1 lifetime argument was supplied\n-  --> $DIR/missing-lifetime-specifier.rs:50:45\n+  --> $DIR/missing-lifetime-specifier.rs:51:45\n    |\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, i32>>>>> = RefCell::new(HashMap::new());\n    |                                             ^^^ ------- supplied 1 lifetime argument\n@@ -310,7 +363,7 @@ help: add missing lifetime argument\n LL |     static f: RefCell<HashMap<i32, Vec<Vec<&Tar<'static, '_, i32>>>>> = RefCell::new(HashMap::new());\n    |                                                        ++++\n \n-error: aborting due to 22 previous errors\n+error: aborting due to 24 previous errors\n \n Some errors have detailed explanations: E0106, E0107.\n For more information about an error, try `rustc --explain E0106`."}, {"sha": "8dc0e75f1af22467dc3f416b3f48439d5b07f228", "filename": "src/test/ui/threads-sendsync/issue-43733.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.mir.stderr?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -1,13 +1,13 @@\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:17:5\n+  --> $DIR/issue-43733.rs:19:5\n    |\n LL |     __KEY.get(Default::default)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:20:42\n+  --> $DIR/issue-43733.rs:22:42\n    |\n LL | static FOO: std::thread::LocalKey<Foo> = std::thread::LocalKey::new(__getit);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function"}, {"sha": "9926ed09bb4a84088a35e520f0bcd0124fef0a4b", "filename": "src/test/ui/threads-sendsync/issue-43733.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.rs?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -4,6 +4,8 @@\n #![feature(thread_local)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n+use std::cell::RefCell;\n+\n type Foo = std::cell::RefCell<String>;\n \n #[cfg(target_thread_local)]\n@@ -13,7 +15,7 @@ static __KEY: std::thread::__FastLocalKeyInner<Foo> = std::thread::__FastLocalKe\n #[cfg(not(target_thread_local))]\n static __KEY: std::thread::__OsLocalKeyInner<Foo> = std::thread::__OsLocalKeyInner::new();\n \n-fn __getit() -> std::option::Option<&'static Foo> {\n+fn __getit(_: Option<&mut Option<RefCell<String>>>) -> std::option::Option<&'static Foo> {\n     __KEY.get(Default::default) //~ ERROR call to unsafe function is unsafe\n }\n "}, {"sha": "8dc0e75f1af22467dc3f416b3f48439d5b07f228", "filename": "src/test/ui/threads-sendsync/issue-43733.thir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ab2bd41ce0da79f82e7bfd281bb746a6eee21346/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-43733.thir.stderr?ref=ab2bd41ce0da79f82e7bfd281bb746a6eee21346", "patch": "@@ -1,13 +1,13 @@\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:17:5\n+  --> $DIR/issue-43733.rs:19:5\n    |\n LL |     __KEY.get(Default::default)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/issue-43733.rs:20:42\n+  --> $DIR/issue-43733.rs:22:42\n    |\n LL | static FOO: std::thread::LocalKey<Foo> = std::thread::LocalKey::new(__getit);\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function"}]}