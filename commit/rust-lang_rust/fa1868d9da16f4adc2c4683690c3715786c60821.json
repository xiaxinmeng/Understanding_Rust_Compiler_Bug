{"sha": "fa1868d9da16f4adc2c4683690c3715786c60821", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMTg2OGQ5ZGExNmY0YWRjMmM0NjgzNjkwYzM3MTU3ODZjNjA4MjE=", "commit": {"author": {"name": "Marshall Bowers", "email": "elliott.codes@gmail.com", "date": "2018-09-15T17:10:29Z"}, "committer": {"name": "Marshall Bowers", "email": "elliott.codes@gmail.com", "date": "2018-09-15T17:10:29Z"}, "message": "Make rustc::middle::region::Scope's fields public", "tree": {"sha": "118121859614c5aa180270e50e6b3bf56b54aca0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/118121859614c5aa180270e50e6b3bf56b54aca0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa1868d9da16f4adc2c4683690c3715786c60821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa1868d9da16f4adc2c4683690c3715786c60821", "html_url": "https://github.com/rust-lang/rust/commit/fa1868d9da16f4adc2c4683690c3715786c60821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa1868d9da16f4adc2c4683690c3715786c60821/comments", "author": {"login": "maxdeviant", "id": 1486634, "node_id": "MDQ6VXNlcjE0ODY2MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1486634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxdeviant", "html_url": "https://github.com/maxdeviant", "followers_url": "https://api.github.com/users/maxdeviant/followers", "following_url": "https://api.github.com/users/maxdeviant/following{/other_user}", "gists_url": "https://api.github.com/users/maxdeviant/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxdeviant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxdeviant/subscriptions", "organizations_url": "https://api.github.com/users/maxdeviant/orgs", "repos_url": "https://api.github.com/users/maxdeviant/repos", "events_url": "https://api.github.com/users/maxdeviant/events{/privacy}", "received_events_url": "https://api.github.com/users/maxdeviant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "maxdeviant", "id": 1486634, "node_id": "MDQ6VXNlcjE0ODY2MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1486634?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxdeviant", "html_url": "https://github.com/maxdeviant", "followers_url": "https://api.github.com/users/maxdeviant/followers", "following_url": "https://api.github.com/users/maxdeviant/following{/other_user}", "gists_url": "https://api.github.com/users/maxdeviant/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxdeviant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxdeviant/subscriptions", "organizations_url": "https://api.github.com/users/maxdeviant/orgs", "repos_url": "https://api.github.com/users/maxdeviant/repos", "events_url": "https://api.github.com/users/maxdeviant/events{/privacy}", "received_events_url": "https://api.github.com/users/maxdeviant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba0fdf43c22795822e1d7c751a69e6c85007221", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba0fdf43c22795822e1d7c751a69e6c85007221", "html_url": "https://github.com/rust-lang/rust/commit/cba0fdf43c22795822e1d7c751a69e6c85007221"}], "stats": {"total": 258, "additions": 157, "deletions": 101}, "files": [{"sha": "6b9c0aac52e79b370af16a0af500f90e56020828", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -556,7 +556,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         target_scope: region::Scope,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = region::Scope::Node(from_expr.hir_id.local_id);\n+        let mut scope = region::Scope {\n+            id: from_expr.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        };\n         let region_scope_tree = self.tcx.region_scope_tree(self.owner_def_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.item_local_id());\n@@ -586,17 +589,23 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             Ok(loop_id) => {\n                 for b in &self.breakable_block_scopes {\n                     if b.block_expr_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n-                        let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n-                        return (region::Scope::Node(scope_id), match scope_cf_kind {\n+                        let scope = region::Scope {\n+                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            data: region::ScopeData::Node\n+                        };\n+                        return (scope, match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n                     }\n                 }\n                 for l in &self.loop_scopes {\n                     if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n-                        let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n-                        return (region::Scope::Node(scope_id), match scope_cf_kind {\n+                        let scope = region::Scope {\n+                            id: self.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                            data: region::ScopeData::Node\n+                        };\n+                        return (scope, match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "cf76c3b7e02dfbb94185bdd6ff561e07c0b400ee", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match scope.data() {\n+                let scope_decorated_tag = match scope.data {\n                     region::ScopeData::Node => tag,\n                     region::ScopeData::CallSite => \"scope of call-site for function\",\n                     region::ScopeData::Arguments => \"scope of function body\","}, {"sha": "469ae04c0fdc10bb70dc74c349f461d33ffb37f7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -317,7 +317,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             debug!(\"consume_body: arg_ty = {:?}\", arg_ty);\n \n             let fn_body_scope_r =\n-                self.tcx().mk_region(ty::ReScope(region::Scope::Node(body.value.hir_id.local_id)));\n+                self.tcx().mk_region(ty::ReScope(\n+                    region::Scope {\n+                        id: body.value.hir_id.local_id,\n+                        data: region::ScopeData::Node\n+                    }));\n             let arg_cmt = Rc::new(self.mc.cat_rvalue(\n                 arg.hir_id,\n                 arg.pat.span,\n@@ -558,7 +562,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             _ => {\n                 if let Some(def) = self.mc.tables.type_dependent_defs().get(call.hir_id) {\n                     let def_id = def.def_id();\n-                    let call_scope = region::Scope::Node(call.hir_id.local_id);\n+                    let call_scope = region::Scope {\n+                        id: call.hir_id.local_id,\n+                        data: region::ScopeData::Node\n+                    };\n                     match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                         FnMutOverloadedCall => {\n                             let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n@@ -766,7 +773,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n                 let r = self.tcx().mk_region(ty::ReScope(\n-                    region::Scope::Node(expr.hir_id.local_id)));\n+                    region::Scope {\n+                        id: expr.hir_id.local_id,\n+                        data: region::ScopeData::Node\n+                    }));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,"}, {"sha": "788fbcef17163581c6e5709b10cdb90ed2da018b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 59, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -102,8 +102,8 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n-    pub(crate) id: hir::ItemLocalId,\n-    pub(crate) data: ScopeData,\n+    pub id: hir::ItemLocalId,\n+    pub data: ScopeData,\n }\n \n impl fmt::Debug for Scope {\n@@ -172,48 +172,6 @@ impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { private });\n #[cfg(not(stage0))]\n static ASSERT: () = [()][!(mem::size_of::<ScopeData>() == 4) as usize];\n \n-#[allow(non_snake_case)]\n-impl Scope {\n-    #[inline]\n-    pub fn data(self) -> ScopeData {\n-        self.data\n-    }\n-\n-    #[inline]\n-    pub fn new(id: hir::ItemLocalId, data: ScopeData) -> Self {\n-        Scope { id, data }\n-    }\n-\n-    #[inline]\n-    pub fn Node(id: hir::ItemLocalId) -> Self {\n-        Self::new(id, ScopeData::Node)\n-    }\n-\n-    #[inline]\n-    pub fn CallSite(id: hir::ItemLocalId) -> Self {\n-        Self::new(id, ScopeData::CallSite)\n-    }\n-\n-    #[inline]\n-    pub fn Arguments(id: hir::ItemLocalId) -> Self {\n-        Self::new(id, ScopeData::Arguments)\n-    }\n-\n-    #[inline]\n-    pub fn Destruction(id: hir::ItemLocalId) -> Self {\n-        Self::new(id, ScopeData::Destruction)\n-    }\n-\n-    #[inline]\n-    pub fn Remainder(\n-        id: hir::ItemLocalId,\n-        first: FirstStatementIndex,\n-    ) -> Self {\n-        Self::new(id, ScopeData::Remainder(first))\n-    }\n-}\n-\n-\n impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n@@ -244,7 +202,7 @@ impl Scope {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let ScopeData::Remainder(first_statement_index) = self.data() {\n+        if let ScopeData::Remainder(first_statement_index) = self.data {\n             if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n@@ -498,7 +456,7 @@ impl<'tcx> ScopeTree {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let ScopeData::Destruction = child.data() {\n+        if let ScopeData::Destruction = child.data {\n             self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n     }\n@@ -578,10 +536,10 @@ impl<'tcx> ScopeTree {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = Scope::Node(expr_id);\n+        let mut id = Scope { id: expr_id, data: ScopeData::Node };\n \n         while let Some(&(p, _)) = self.parent_map.get(&id) {\n-            match p.data() {\n+            match p.data {\n                 ScopeData::Destruction => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n@@ -637,7 +595,7 @@ impl<'tcx> ScopeTree {\n     /// Returns the id of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope)-> Option<hir::ItemLocalId> {\n         loop {\n-            if let ScopeData::CallSite = scope.data() {\n+            if let ScopeData::CallSite = scope.data {\n                 return Some(scope.item_local_id());\n             }\n \n@@ -730,7 +688,7 @@ impl<'tcx> ScopeTree {\n             self.root_body.unwrap().local_id\n         });\n \n-        Scope::CallSite(scope)\n+        Scope { id: scope, data: ScopeData::CallSite }\n     }\n \n     /// Assuming that the provided region was defined within this `ScopeTree`,\n@@ -750,7 +708,7 @@ impl<'tcx> ScopeTree {\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n         let body_id = tcx.hir.body_owned_by(param_owner_id);\n-        Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n+        Scope { id: tcx.hir.body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }\n \n     /// Checks whether the given scope contains a `yield`. If so,\n@@ -854,7 +812,10 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n                 visitor.enter_scope(\n-                    Scope::Remainder(blk.hir_id.local_id, FirstStatementIndex::new(i))\n+                    Scope {\n+                        id: blk.hir_id.local_id,\n+                        data: ScopeData::Remainder(FirstStatementIndex::new(i))\n+                    }\n                 );\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n@@ -879,7 +840,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.record_child_scope(Scope::Node(pat.hir_id.local_id));\n+    visitor.record_child_scope(Scope { id: pat.hir_id.local_id, data: ScopeData::Node });\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n@@ -1008,15 +969,15 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n \n     if let hir::ExprKind::Yield(..) = expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n-        let mut scope = Scope::Node(expr.hir_id.local_id);\n+        let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n             visitor.scope_tree.yield_in_scope.insert(scope,\n                 (expr.span, visitor.expr_and_pat_count));\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n-                Some(&(superscope, _)) => match superscope.data() {\n+                Some(&(superscope, _)) => match superscope.data {\n                     ScopeData::CallSite => break,\n                     _ => scope = superscope\n                 },\n@@ -1280,9 +1241,9 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n         // account for the destruction scope representing the scope of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n-            self.enter_scope(Scope::Destruction(id));\n+            self.enter_scope(Scope { id, data: ScopeData::Destruction });\n         }\n-        self.enter_scope(Scope::Node(id));\n+        self.enter_scope(Scope { id, data: ScopeData::Node });\n     }\n }\n \n@@ -1315,8 +1276,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         }\n         self.cx.root_id = Some(body.value.hir_id.local_id);\n \n-        self.enter_scope(Scope::CallSite(body.value.hir_id.local_id));\n-        self.enter_scope(Scope::Arguments(body.value.hir_id.local_id));\n+        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::CallSite });\n+        self.enter_scope(Scope { id: body.value.hir_id.local_id, data: ScopeData::Arguments });\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();"}, {"sha": "9a1add26bb0b4bf24b80816145343ef97aba9e41", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -769,7 +769,7 @@ define_print! {\n                     write!(f, \"{}\", br)\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n-                    match scope.data() {\n+                    match scope.data {\n                         region::ScopeData::Node =>\n                             write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n                         region::ScopeData::CallSite =>"}, {"sha": "40bfbf1596a478f5ce9b2593e49efa8dd80e34d9", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -767,8 +767,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         let mut ret = UseOk;\n \n+        let scope = region::Scope {\n+            id: expr_id,\n+            data: region::ScopeData::Node\n+        };\n         self.each_in_scope_loan_affecting_path(\n-            region::Scope::Node(expr_id), use_path, |loan| {\n+            scope, use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -886,7 +890,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(assignee_cmt) {\n-            let scope = region::Scope::Node(assignment_id);\n+            let scope = region::Scope {\n+                id: assignment_id,\n+                data: region::ScopeData::Node\n+            };\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "dc400c6ef3eadec1aca7a3306ca1c9e72383b890", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -43,7 +43,10 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::Scope::Node(bccx.tcx.hir.body(body).value.hir_id.local_id),\n+        item_ub: region::Scope {\n+            id: bccx.tcx.hir.body(body).value.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        },\n         move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -375,7 +378,10 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = region::Scope::Node(borrow_id);\n+                let borrow_scope = region::Scope {\n+                    id: borrow_id,\n+                    data: region::ScopeData::Node\n+                };\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n "}, {"sha": "6c0a8c23de93e792148741a527981385f4261c3d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -441,7 +441,7 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n                 let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n-                region::Scope::Node(hir_id.local_id)\n+                region::Scope { id: hir_id.local_id, data: region::ScopeData::Node }\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),"}, {"sha": "a781f286a7b730677f4ea2b9d3030cf648e15edd", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn create_region_hierarchy(&mut self, rh: &RH,\n                                    parent: (region::Scope, region::ScopeDepth)) {\n-        let me = region::Scope::Node(rh.id);\n+        let me = region { id: rh.id, data: region::ScopeData::Node };\n         self.region_scope_tree.record_scope_parent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, (me, parent.1 + 1));\n@@ -209,7 +209,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n-        let dscope = region::Scope::Destruction(hir::ItemLocalId(1));\n+        let dscope = region::Scope {\n+            id: hir::ItemLocalId(1),\n+            data: region::ScopeData::Destruction\n+        };\n         self.region_scope_tree.record_scope_parent(dscope, None);\n         self.create_region_hierarchy(&RH {\n             id: hir::ItemLocalId(1),\n@@ -355,7 +358,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(region::Scope::Node(hir::ItemLocalId(id)));\n+        let r = ty::ReScope(region::Scope {\n+            id: hir::ItemLocalId(id),\n+            data: region::ScopeData::Node\n+        });\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "8e40fd19941b3dc01fc94e5e56dbb936bb013c3a", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> CFG<'tcx> {\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n         if tcx.emit_end_regions() {\n-            if let region::ScopeData::CallSite = region_scope.data() {\n+            if let region::ScopeData::CallSite = region_scope.data {\n                 // The CallSite scope (aka the root scope) is sort of weird, in that it is\n                 // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n                 // that, it is not really a part of the region hierarchy, but for some"}, {"sha": "d2061d8eecf5f3d79667430fea1c4d0d0167b400", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -550,8 +550,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         upvar_decls);\n \n     let fn_def_id = tcx.hir.local_def_id(fn_id);\n-    let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n-    let arg_scope = region::Scope::Arguments(body.value.hir_id.local_id);\n+    let call_site_scope = region::Scope {\n+        id: body.value.hir_id.local_id,\n+        data: region::ScopeData::CallSite\n+    };\n+    let arg_scope = region::Scope {\n+        id: body.value.hir_id.local_id,\n+        data: region::ScopeData::Arguments\n+    };\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);"}, {"sha": "cc5b08f2a90474776ee07ef381c9b0f06d8fdb0e", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -565,7 +565,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].region_scope.data() {\n+        assert!(match self.scopes[1].region_scope.data {\n             region::ScopeData::Arguments => true,\n             _ => false,\n         });"}, {"sha": "93136a0fb83e3e53bd687d472aba177380e84b5f", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -157,7 +157,10 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     ) -> Self {\n         let scope_tree = tcx.region_scope_tree(def_id);\n         let root_scope = body_id.map(|body_id| {\n-            region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n+            region::Scope {\n+                id: tcx.hir.body(body_id).value.hir_id.local_id,\n+                data: region::ScopeData::CallSite\n+            }\n         });\n \n         let mut borrows_out_of_scope_at_location = FxHashMap();"}, {"sha": "2ab0a57a855419f23dae98a2d220ebaed70c32ba", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -27,7 +27,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            region_scope: region::Scope::Node(self.hir_id.local_id),\n+            region_scope: region::Scope {\n+                id: self.hir_id.local_id,\n+                data: region::ScopeData::Node\n+            },\n             opt_destruction_scope,\n             span: self.span,\n             stmts,\n@@ -59,7 +62,10 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             hir::StmtKind::Semi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n-                        scope: region::Scope::Node(hir_id.local_id),\n+                        scope: region::Scope {\n+                            id: hir_id.local_id,\n+                            data: region::ScopeData::Node\n+                        },\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n@@ -71,10 +77,11 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclKind::Local(ref local) => {\n-                        let remainder_scope = region::Scope::Remainder(\n-                            block_id,\n-                            region::FirstStatementIndex::new(index),\n-                        );\n+                        let remainder_scope = region::Scope {\n+                            id: block_id,\n+                            data: region::ScopeData::Remainder(\n+                                region::FirstStatementIndex::new(index)),\n+                        };\n \n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n \n@@ -94,7 +101,10 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,\n-                                init_scope: region::Scope::Node(hir_id.local_id),\n+                                init_scope: region::Scope {\n+                                    id: hir_id.local_id,\n+                                    data: region::ScopeData::Node\n+                                },\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n                                 lint_level: cx.lint_level_of(local.id),"}, {"sha": "3183f0f47eace5f51ce1f235b1db86c2c3dec8f2", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -27,7 +27,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         let temp_lifetime = cx.region_scope_tree.temporary_scope(self.hir_id.local_id);\n-        let expr_scope = region::Scope::Node(self.hir_id.local_id);\n+        let expr_scope = region::Scope {\n+            id: self.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        };\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -148,7 +151,10 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // Convert this to a suitable `&foo` and\n             // then an unsafe coercion. Limit the region to be just this\n             // expression.\n-            let region = ty::ReScope(region::Scope::Node(hir_expr.hir_id.local_id));\n+            let region = ty::ReScope(region::Scope {\n+                id: hir_expr.hir_id.local_id,\n+                data: region::ScopeData::Node\n+            });\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n@@ -581,7 +587,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Break(dest, ref value) => {\n             match dest.target_id {\n                 Ok(target_id) => ExprKind::Break {\n-                    label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n+                    label: region::Scope {\n+                        id: cx.tcx.hir.node_to_hir_id(target_id).local_id,\n+                        data: region::ScopeData::Node\n+                    },\n                     value: value.to_ref(),\n                 },\n                 Err(err) => bug!(\"invalid loop id for break: {}\", err)\n@@ -590,7 +599,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Continue(dest) => {\n             match dest.target_id {\n                 Ok(loop_id) => ExprKind::Continue {\n-                    label: region::Scope::Node(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n+                    label: region::Scope {\n+                        id: cx.tcx.hir.node_to_hir_id(loop_id).local_id,\n+                        data: region::ScopeData::Node\n+                    },\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err)\n             }"}, {"sha": "db0c4fdb03ae61e20829b3f1695184496106cbe2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -622,7 +622,10 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir.body(body_id);\n-            tcx.mk_region(ty::ReScope(region::Scope::CallSite(body.value.hir_id.local_id)))\n+            tcx.mk_region(ty::ReScope(region::Scope {\n+                id: body.value.hir_id.local_id,\n+                data: region::ScopeData::CallSite\n+            }))\n         });\n \n         Inherited {"}, {"sha": "fbf8afc3be234b5364a6b479ca21d4ae92e64731", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa1868d9da16f4adc2c4683690c3715786c60821/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fa1868d9da16f4adc2c4683690c3715786c60821", "patch": "@@ -307,7 +307,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let body_id = body.id();\n         self.body_id = body_id.node_id;\n \n-        let call_site = region::Scope::CallSite(body.value.hir_id.local_id);\n+        let call_site = region::Scope {\n+            id: body.value.hir_id.local_id,\n+            data: region::ScopeData::CallSite\n+        };\n         self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n@@ -333,7 +336,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             &fn_sig_tys[..],\n             body_id.node_id,\n             span);\n-        self.link_fn_args(region::Scope::Node(body.value.hir_id.local_id), &body.arguments);\n+        self.link_fn_args(\n+            region::Scope {\n+                id: body.value.hir_id.local_id,\n+                data: region::ScopeData::Node\n+            },\n+            &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -483,7 +491,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n         let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope::Node(expr.hir_id.local_id)));\n+            region::Scope {\n+                id: expr.hir_id.local_id,\n+                data: region::ScopeData::Node\n+            }));\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -766,7 +777,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = region::Scope::Node(call_expr.hir_id.local_id);\n+        let callee_scope = region::Scope {\n+            id: call_expr.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        };\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -819,7 +833,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.check_safety_of_rvalue_destructor_if_necessary(&cmt, expr.span);\n \n         let expr_region = self.tcx.mk_region(ty::ReScope(\n-            region::Scope::Node(expr.hir_id.local_id)));\n+            region::Scope {\n+                id: expr.hir_id.local_id,\n+                data: region::ScopeData::Node\n+            }));\n         for adjustment in adjustments {\n             debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n                    adjustment, cmt);\n@@ -913,7 +930,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(region::Scope::Node(index_expr.hir_id.local_id));\n+        let r_index_expr = ty::ReScope(region::Scope {\n+            id: index_expr.hir_id.local_id,\n+            data: region::ScopeData::Node\n+        });\n         if let ty::Ref(r_ptr, r_ty, _) = indexed_ty.sty {\n             match r_ty.sty {\n                 ty::Slice(_) | ty::Str => {\n@@ -1072,7 +1092,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.mk_region(ty::ReScope(region::Scope::Node(expr.hir_id.local_id)));\n+                let r = self.tcx.mk_region(ty::ReScope(region::Scope {\n+                    id: expr.hir_id.local_id,\n+                    data: region::ScopeData::Node\n+                }));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }"}]}