{"sha": "61c8aae0a9222b7d2481704094f85a0d8f6b333e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYzhhYWUwYTkyMjJiN2QyNDgxNzA0MDk0Zjg1YTBkOGY2YjMzM2U=", "commit": {"author": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2020-12-29T07:58:32Z"}, "committer": {"name": "J. Ryan Stinnett", "email": "jryans@gmail.com", "date": "2021-01-04T13:27:13Z"}, "message": "Extract `sidebar_deref_methods` function", "tree": {"sha": "24f69ce95bed0d9575a52c0dbf6d80199fd15924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24f69ce95bed0d9575a52c0dbf6d80199fd15924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61c8aae0a9222b7d2481704094f85a0d8f6b333e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61c8aae0a9222b7d2481704094f85a0d8f6b333e", "html_url": "https://github.com/rust-lang/rust/commit/61c8aae0a9222b7d2481704094f85a0d8f6b333e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61c8aae0a9222b7d2481704094f85a0d8f6b333e/comments", "author": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jryans", "id": 279572, "node_id": "MDQ6VXNlcjI3OTU3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/279572?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jryans", "html_url": "https://github.com/jryans", "followers_url": "https://api.github.com/users/jryans/followers", "following_url": "https://api.github.com/users/jryans/following{/other_user}", "gists_url": "https://api.github.com/users/jryans/gists{/gist_id}", "starred_url": "https://api.github.com/users/jryans/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jryans/subscriptions", "organizations_url": "https://api.github.com/users/jryans/orgs", "repos_url": "https://api.github.com/users/jryans/repos", "events_url": "https://api.github.com/users/jryans/events{/privacy}", "received_events_url": "https://api.github.com/users/jryans/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6163bfdcce6404c5d61d6ab441bf49a831082194", "url": "https://api.github.com/repos/rust-lang/rust/commits/6163bfdcce6404c5d61d6ab441bf49a831082194", "html_url": "https://github.com/rust-lang/rust/commit/6163bfdcce6404c5d61d6ab441bf49a831082194"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "8d304b45590cfdf24390af4aa907185edfd8b482", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/61c8aae0a9222b7d2481704094f85a0d8f6b333e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c8aae0a9222b7d2481704094f85a0d8f6b333e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=61c8aae0a9222b7d2481704094f85a0d8f6b333e", "patch": "@@ -4303,58 +4303,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                debug!(\"found Deref: {:?}\", impl_);\n-                if let Some((target, real_target)) =\n-                    impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-                        clean::TypedefItem(ref t, true) => Some(match *t {\n-                            clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n-                            _ => (&t.type_, &t.type_),\n-                        }),\n-                        _ => None,\n-                    })\n-                {\n-                    debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-                    let deref_mut = v\n-                        .iter()\n-                        .filter(|i| i.inner_impl().trait_.is_some())\n-                        .any(|i| i.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n-                    let inner_impl = target\n-                        .def_id()\n-                        .or_else(|| {\n-                            target\n-                                .primitive_type()\n-                                .and_then(|prim| c.primitive_locations.get(&prim).cloned())\n-                        })\n-                        .and_then(|did| c.impls.get(&did));\n-                    if let Some(impls) = inner_impl {\n-                        debug!(\"found inner_impl: {:?}\", impls);\n-                        out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n-                        out.push_str(&format!(\n-                            \"Methods from {}&lt;Target={}&gt;\",\n-                            Escape(&format!(\n-                                \"{:#}\",\n-                                impl_.inner_impl().trait_.as_ref().unwrap().print()\n-                            )),\n-                            Escape(&format!(\"{:#}\", real_target.print()))\n-                        ));\n-                        out.push_str(\"</a>\");\n-                        let mut ret = impls\n-                            .iter()\n-                            .filter(|i| i.inner_impl().trait_.is_none())\n-                            .flat_map(|i| {\n-                                get_methods(i.inner_impl(), true, &mut used_links, deref_mut)\n-                            })\n-                            .collect::<Vec<_>>();\n-                        // We want links' order to be reproducible so we don't use unstable sort.\n-                        ret.sort();\n-                        if !ret.is_empty() {\n-                            out.push_str(&format!(\n-                                \"<div class=\\\"sidebar-links\\\">{}</div>\",\n-                                ret.join(\"\")\n-                            ));\n-                        }\n-                    }\n-                }\n+                out.push_str(&sidebar_deref_methods(impl_, v));\n             }\n             let format_impls = |impls: Vec<&Impl>| {\n                 let mut links = FxHashSet::default();\n@@ -4422,6 +4371,57 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n     out\n }\n \n+fn sidebar_deref_methods(impl_: &Impl, v: &Vec<Impl>) -> String {\n+    let mut out = String::new();\n+    let c = cache();\n+\n+    debug!(\"found Deref: {:?}\", impl_);\n+    if let Some((target, real_target)) =\n+        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n+            clean::TypedefItem(ref t, true) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n+            _ => None,\n+        })\n+    {\n+        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n+        let deref_mut = v\n+            .iter()\n+            .filter(|i| i.inner_impl().trait_.is_some())\n+            .any(|i| i.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n+        let inner_impl = target\n+            .def_id()\n+            .or_else(|| {\n+                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n+            })\n+            .and_then(|did| c.impls.get(&did));\n+        if let Some(impls) = inner_impl {\n+            debug!(\"found inner_impl: {:?}\", impls);\n+            out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n+            out.push_str(&format!(\n+                \"Methods from {}&lt;Target={}&gt;\",\n+                Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print())),\n+                Escape(&format!(\"{:#}\", real_target.print()))\n+            ));\n+            out.push_str(\"</a>\");\n+            let mut used_links = FxHashSet::default();\n+            let mut ret = impls\n+                .iter()\n+                .filter(|i| i.inner_impl().trait_.is_none())\n+                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut))\n+                .collect::<Vec<_>>();\n+            // We want links' order to be reproducible so we don't use unstable sort.\n+            ret.sort();\n+            if !ret.is_empty() {\n+                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret.join(\"\")));\n+            }\n+        }\n+    }\n+\n+    out\n+}\n+\n fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&s.fields);"}]}