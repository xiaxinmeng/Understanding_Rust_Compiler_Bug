{"sha": "4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYWY1MzVkMmI0ZjhjNTkzN2YyYzI0YWM4ZTk5YjAyZjg5MzQ2MGI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-04-15T21:29:29Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-04-20T19:18:18Z"}, "message": "Treat RETURN_PLACE as a normal Local\n\nCopy its value to the `return_place` upon leaving a call frame", "tree": {"sha": "405d9f2b00449caeb19653e7d3b24aca209246a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/405d9f2b00449caeb19653e7d3b24aca209246a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "html_url": "https://github.com/rust-lang/rust/commit/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ce3f840ae9b735a66531996c32330f24b877cb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ce3f840ae9b735a66531996c32330f24b877cb0", "html_url": "https://github.com/rust-lang/rust/commit/8ce3f840ae9b735a66531996c32330f24b877cb0"}], "stats": {"total": 112, "additions": 42, "deletions": 70}, "files": [{"sha": "2510dbcea0bdc1f40570f5221d1860d3d3e81073", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -361,8 +361,6 @@ pub enum UndefinedBehaviorInfo {\n     InvalidUndefBytes(Option<Pointer>),\n     /// Working with a local that is not currently live.\n     DeadLocal,\n-    /// Trying to read from the return place of a function.\n-    ReadFromReturnPlace,\n }\n \n impl fmt::Debug for UndefinedBehaviorInfo {\n@@ -424,7 +422,6 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n                 \"using uninitialized data, but this operation requires initialized memory\"\n             ),\n             DeadLocal => write!(f, \"accessing a dead local variable\"),\n-            ReadFromReturnPlace => write!(f, \"reading from return place\"),\n         }\n     }\n }"}, {"sha": "283f9e14251788a69b0a562f405a9cd6b6996985", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -623,35 +623,30 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame = M::init_frame_extra(self, pre_frame)?;\n         self.stack_mut().push(frame);\n \n-        // don't allocate at all for trivial constants\n-        if body.local_decls.len() > 1 {\n-            // Locals are initially uninitialized.\n-            let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n-            let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n-            // Return place is handled specially by the `eval_place` functions, and the\n-            // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n-            // Now mark those locals as dead that we do not want to initialize\n-            match self.tcx.def_kind(instance.def_id()) {\n-                // statics and constants don't have `Storage*` statements, no need to look for them\n-                //\n-                // FIXME: The above is likely untrue. See\n-                // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n-                // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n-                Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {}\n-                _ => {\n-                    // Mark locals that use `Storage*` annotations as dead on function entry.\n-                    let always_live = AlwaysLiveLocals::new(self.body());\n-                    for local in locals.indices() {\n-                        if !always_live.contains(local) {\n-                            locals[local].value = LocalValue::Dead;\n-                        }\n+        // Locals are initially uninitialized.\n+        let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n+        let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n+\n+        // Now mark those locals as dead that we do not want to initialize\n+        match self.tcx.def_kind(instance.def_id()) {\n+            // statics and constants don't have `Storage*` statements, no need to look for them\n+            //\n+            // FIXME: The above is likely untrue. See\n+            // <https://github.com/rust-lang/rust/pull/70004#issuecomment-602022110>. Is it\n+            // okay to ignore `StorageDead`/`StorageLive` annotations during CTFE?\n+            Some(DefKind::Static | DefKind::Const | DefKind::AssocConst) => {}\n+            _ => {\n+                // Mark locals that use `Storage*` annotations as dead on function entry.\n+                let always_live = AlwaysLiveLocals::new(self.body());\n+                for local in locals.indices() {\n+                    if !always_live.contains(local) {\n+                        locals[local].value = LocalValue::Dead;\n                     }\n                 }\n             }\n-            // done\n-            self.frame_mut().locals = locals;\n         }\n+        // done\n+        self.frame_mut().locals = locals;\n \n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n@@ -729,6 +724,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame =\n             self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n \n+        if let Some(return_place) = frame.return_place {\n+            // Copy the return value to the caller's stack frame.\n+            let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n+            self.copy_op(op, return_place)?;\n+        }\n+\n         // Now where do we jump next?\n \n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't."}, {"sha": "d5864d1d4db079d60af932d5ec142b1fd38f5ea7", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -419,7 +419,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        assert_ne!(local, mir::RETURN_PLACE);\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Do not read from ZST, they might not be initialized\n@@ -454,15 +453,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         place: mir::Place<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let base_op = match place.local {\n-            mir::RETURN_PLACE => throw_ub!(ReadFromReturnPlace),\n-            local => {\n-                // Do not use the layout passed in as argument if the base we are looking at\n-                // here is not the entire place.\n-                let layout = if place.projection.is_empty() { layout } else { None };\n-\n-                self.access_local(self.frame(), local, layout)?\n-            }\n+        let base_op = {\n+            // Do not use the layout passed in as argument if the base we are looking at\n+            // here is not the entire place.\n+            let layout = if place.projection.is_empty() { layout } else { None };\n+\n+            self.access_local(self.frame(), place.local, layout)?\n         };\n \n         let op = place"}, {"sha": "ca7148714ac3a5087fbe94291793dafa270551e1", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -276,6 +276,10 @@ impl<Tag: ::std::fmt::Debug> Place<Tag> {\n }\n \n impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n+    pub fn null(cx: &impl HasDataLayout, layout: TyAndLayout<'tcx>) -> Self {\n+        Self { place: Place::null(cx), layout }\n+    }\n+\n     #[inline]\n     pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n         MPlaceTy { mplace: self.place.assert_mem_place(), layout: self.layout }\n@@ -636,35 +640,10 @@ where\n         &mut self,\n         place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        let mut place_ty = match place.local {\n-            mir::RETURN_PLACE => {\n-                // `return_place` has the *caller* layout, but we want to use our\n-                // `layout to verify our assumption. The caller will validate\n-                // their layout on return.\n-                PlaceTy {\n-                    place: match self.frame().return_place {\n-                        Some(p) => *p,\n-                        // Even if we don't have a return place, we sometimes need to\n-                        // create this place, but any attempt to read from / write to it\n-                        // (even a ZST read/write) needs to error, so let us make this\n-                        // a NULL place.\n-                        //\n-                        // FIXME: Ideally we'd make sure that the place projections also\n-                        // bail out.\n-                        None => Place::null(&*self),\n-                    },\n-                    layout: self.layout_of(\n-                        self.subst_from_current_frame_and_normalize_erasing_regions(\n-                            self.frame().body.return_ty(),\n-                        ),\n-                    )?,\n-                }\n-            }\n-            local => PlaceTy {\n-                // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local { frame: self.frame_idx(), local },\n-                layout: self.layout_of_local(self.frame(), local, None)?,\n-            },\n+        let mut place_ty = PlaceTy {\n+            // This works even for dead/uninitialized locals; we check further when writing\n+            place: Place::Local { frame: self.frame_idx(), local: place.local },\n+            layout: self.layout_of_local(self.frame(), place.local, None)?,\n         };\n \n         for elem in place.projection.iter() {"}, {"sha": "777a4381cda720d125635af6f9137891cad8c6a2", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -19,7 +19,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.frame().return_place.map(|r| self.dump_place(*r));\n                 self.pop_stack_frame(/* unwinding */ false)?\n             }\n "}, {"sha": "b6c2572cb8dc3108db1c08e629b94f72802870ac", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -13,7 +13,7 @@ LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n LL | |     let out_of_bounds_ptr = &ptr[255];\n-   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc8 which has size 1\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of alloc11 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n    | |____-"}, {"sha": "54a9eda21466088c75433b179020984d54f9955e", "filename": "src/test/ui/consts/miri_unleashed/mutable_const.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4eaf535d2b4f8c5937f2c24ac8e99b02f893460b/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const.stderr?ref=4eaf535d2b4f8c5937f2c24ac8e99b02f893460b", "patch": "@@ -11,7 +11,7 @@ LL | / const MUTATING_BEHIND_RAW: () = {\n LL | |     // Test that `MUTABLE_BEHIND_RAW` is actually immutable, by doing this at const time.\n LL | |     unsafe {\n LL | |         *MUTABLE_BEHIND_RAW = 99\n-   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc1 which is read-only\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc2 which is read-only\n LL | |     }\n LL | | };\n    | |__-"}]}