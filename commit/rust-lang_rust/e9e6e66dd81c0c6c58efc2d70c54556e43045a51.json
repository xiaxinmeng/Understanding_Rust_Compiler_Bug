{"sha": "e9e6e66dd81c0c6c58efc2d70c54556e43045a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZTZlNjZkZDgxYzBjNmM1OGVmYzJkNzBjNTQ1NTZlNDMwNDVhNTE=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2021-05-24T23:24:27Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2021-05-24T23:24:27Z"}, "message": "Optimize linkchecker by caching all filesystem access.\n\nThis should improve performance 2-3x depending on the system.", "tree": {"sha": "ef4234eb0934362389741e4018aca6d1391f543a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef4234eb0934362389741e4018aca6d1391f543a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9e6e66dd81c0c6c58efc2d70c54556e43045a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e6e66dd81c0c6c58efc2d70c54556e43045a51", "html_url": "https://github.com/rust-lang/rust/commit/e9e6e66dd81c0c6c58efc2d70c54556e43045a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9e6e66dd81c0c6c58efc2d70c54556e43045a51/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e11b61e8de1ffb6a1ea8fb1f8c42cfe30b6b3e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e11b61e8de1ffb6a1ea8fb1f8c42cfe30b6b3e4", "html_url": "https://github.com/rust-lang/rust/commit/9e11b61e8de1ffb6a1ea8fb1f8c42cfe30b6b3e4"}], "stats": {"total": 386, "additions": 214, "deletions": 172}, "files": [{"sha": "076b3653583b79c8bab6919219f09ade2099d090", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 214, "deletions": 172, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/e9e6e66dd81c0c6c58efc2d70c54556e43045a51/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e6e66dd81c0c6c58efc2d70c54556e43045a51/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=e9e6e66dd81c0c6c58efc2d70c54556e43045a51", "patch": "@@ -14,19 +14,18 @@\n //! A few exceptions are allowed as there's known bugs in rustdoc, but this\n //! should catch the majority of \"broken link\" cases.\n \n-use std::collections::hash_map::Entry;\n+use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs;\n+use std::io::ErrorKind;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n use std::time::Instant;\n \n use once_cell::sync::Lazy;\n use regex::Regex;\n \n-use crate::Redirect::*;\n-\n // Add linkcheck exceptions here\n // If at all possible you should use intra-doc links to avoid linkcheck issues. These\n // are cases where that does not work\n@@ -88,11 +87,10 @@ macro_rules! t {\n }\n \n fn main() {\n-    let docs = env::args_os().nth(1).unwrap();\n+    let docs = env::args_os().nth(1).expect(\"doc path should be first argument\");\n     let docs = env::current_dir().unwrap().join(docs);\n-    let mut checker = Checker {\n-        root: docs.clone(),\n-        cache: HashMap::new(),\n+    let mut checker = Checker { root: docs.clone(), cache: HashMap::new() };\n+    let mut report = Report {\n         errors: 0,\n         start: Instant::now(),\n         html_files: 0,\n@@ -102,9 +100,9 @@ fn main() {\n         links_ignored_exception: 0,\n         intra_doc_exceptions: 0,\n     };\n-    checker.walk(&docs);\n-    checker.report();\n-    if checker.errors != 0 {\n+    checker.walk(&docs, &mut report);\n+    report.report();\n+    if report.errors != 0 {\n         println!(\"found some broken links\");\n         std::process::exit(1);\n     }\n@@ -113,6 +111,9 @@ fn main() {\n struct Checker {\n     root: PathBuf,\n     cache: Cache,\n+}\n+\n+struct Report {\n     errors: u32,\n     start: Instant,\n     html_files: u32,\n@@ -123,23 +124,27 @@ struct Checker {\n     intra_doc_exceptions: u32,\n }\n \n-#[derive(Debug)]\n-pub enum LoadError {\n-    BrokenRedirect(PathBuf, std::io::Error),\n-    IsRedirect,\n+/// A cache entry.\n+enum FileEntry {\n+    /// An HTML file.\n+    ///\n+    /// This includes the contents of the HTML file, and an optional set of\n+    /// HTML IDs. The IDs are used for checking fragments. The are computed\n+    /// as-needed. The source is discarded (replaced with an empty string)\n+    /// after the file has been checked, to conserve on memory.\n+    HtmlFile { source: Rc<String>, ids: RefCell<HashSet<String>> },\n+    /// This file is an HTML redirect to the given local path.\n+    Redirect { target: PathBuf },\n+    /// This is not an HTML file.\n+    OtherFile,\n+    /// This is a directory.\n+    Dir,\n+    /// The file doesn't exist.\n+    Missing,\n }\n \n-enum Redirect {\n-    SkipRedirect,\n-    FromRedirect(bool),\n-}\n-\n-struct FileEntry {\n-    source: Rc<String>,\n-    ids: HashSet<String>,\n-}\n-\n-type Cache = HashMap<PathBuf, FileEntry>;\n+/// A cache to speed up file access.\n+type Cache = HashMap<String, FileEntry>;\n \n fn small_url_encode(s: &str) -> String {\n     s.replace(\"<\", \"%3C\")\n@@ -156,62 +161,36 @@ fn small_url_encode(s: &str) -> String {\n         .replace(\"\\\"\", \"%22\")\n }\n \n-impl FileEntry {\n-    fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut u32) {\n-        if self.ids.is_empty() {\n-            with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n-                let frag = fragment.trim_start_matches(\"#\").to_owned();\n-                let encoded = small_url_encode(&frag);\n-                if !self.ids.insert(frag) {\n-                    *errors += 1;\n-                    println!(\"{}:{}: id is not unique: `{}`\", file.display(), i, fragment);\n-                }\n-                // Just in case, we also add the encoded id.\n-                self.ids.insert(encoded);\n-            });\n-        }\n-    }\n-}\n-\n impl Checker {\n-    fn walk(&mut self, dir: &Path) {\n+    /// Primary entry point for walking the filesystem to find HTML files to check.\n+    fn walk(&mut self, dir: &Path, report: &mut Report) {\n         for entry in t!(dir.read_dir()).map(|e| t!(e)) {\n             let path = entry.path();\n             let kind = t!(entry.file_type());\n             if kind.is_dir() {\n-                self.walk(&path);\n+                self.walk(&path, report);\n             } else {\n-                let pretty_path = self.check(&path);\n-                if let Some(pretty_path) = pretty_path {\n-                    let entry = self.cache.get_mut(&pretty_path).unwrap();\n-                    // we don't need the source anymore,\n-                    // so drop to reduce memory-usage\n-                    entry.source = Rc::new(String::new());\n-                }\n+                self.check(&path, report);\n             }\n         }\n     }\n \n-    fn check(&mut self, file: &Path) -> Option<PathBuf> {\n-        // Ignore non-HTML files.\n-        if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n-            return None;\n-        }\n-        self.html_files += 1;\n-\n-        let res = self.load_file(file, SkipRedirect);\n-        let (pretty_file, contents) = match res {\n-            Ok(res) => res,\n-            Err(_) => return None,\n+    /// Checks a single file.\n+    fn check(&mut self, file: &Path, report: &mut Report) {\n+        let (pretty_path, entry) = self.load_file(file, report);\n+        let source = match entry {\n+            FileEntry::Missing => panic!(\"missing file {:?} while walking\", file),\n+            FileEntry::Dir => unreachable!(\"never with `check` path\"),\n+            FileEntry::OtherFile => return,\n+            FileEntry::Redirect { .. } => return,\n+            FileEntry::HtmlFile { source, ids } => {\n+                parse_ids(&mut ids.borrow_mut(), &pretty_path, source, report);\n+                source.clone()\n+            }\n         };\n-        self.cache.get_mut(&pretty_file).unwrap().parse_ids(\n-            &pretty_file,\n-            &contents,\n-            &mut self.errors,\n-        );\n \n         // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-        with_attrs_in_source(&contents, \" href\", |url, i, base| {\n+        with_attrs_in_source(&source, \" href\", |url, i, base| {\n             // Ignore external URLs\n             if url.starts_with(\"http:\")\n                 || url.starts_with(\"https:\")\n@@ -220,10 +199,10 @@ impl Checker {\n                 || url.starts_with(\"irc:\")\n                 || url.starts_with(\"data:\")\n             {\n-                self.links_ignored_external += 1;\n+                report.links_ignored_external += 1;\n                 return;\n             }\n-            self.links_checked += 1;\n+            report.links_checked += 1;\n             let (url, fragment) = match url.split_once('#') {\n                 None => (url, None),\n                 Some((url, fragment)) => (url, Some(fragment)),\n@@ -242,10 +221,10 @@ impl Checker {\n                             // Avoid absolute paths as they make the docs not\n                             // relocatable by making assumptions on where the docs\n                             // are hosted relative to the site root.\n-                            self.errors += 1;\n+                            report.errors += 1;\n                             println!(\n                                 \"{}:{}: absolute path - {}\",\n-                                pretty_file.display(),\n+                                pretty_path,\n                                 i + 1,\n                                 Path::new(base).join(url).display()\n                             );\n@@ -262,138 +241,165 @@ impl Checker {\n                 }\n             }\n \n-            // Alright, if we've found a file name then this file had better\n-            // exist! If it doesn't then we register and print an error.\n-            if path.exists() {\n-                if path.is_dir() {\n+            let (target_pretty_path, target_entry) = self.load_file(&path, report);\n+            let (target_source, target_ids) = match target_entry {\n+                FileEntry::Missing => {\n+                    if is_exception(file, &target_pretty_path) {\n+                        report.links_ignored_exception += 1;\n+                    } else {\n+                        report.errors += 1;\n+                        println!(\n+                            \"{}:{}: broken link - `{}`\",\n+                            pretty_path,\n+                            i + 1,\n+                            target_pretty_path\n+                        );\n+                    }\n+                    return;\n+                }\n+                FileEntry::Dir => {\n                     // Links to directories show as directory listings when viewing\n                     // the docs offline so it's best to avoid them.\n-                    self.errors += 1;\n-                    let pretty_path = path.strip_prefix(&self.root).unwrap_or(&path);\n+                    report.errors += 1;\n                     println!(\n-                        \"{}:{}: directory link - {}\",\n-                        pretty_file.display(),\n+                        \"{}:{}: directory link to `{}` \\\n+                         (directory links should use index.html instead)\",\n+                        pretty_path,\n                         i + 1,\n-                        pretty_path.display()\n+                        target_pretty_path\n                     );\n                     return;\n                 }\n-                if let Some(extension) = path.extension() {\n-                    // Ignore none HTML files.\n-                    if extension != \"html\" {\n-                        return;\n+                FileEntry::OtherFile => return,\n+                FileEntry::Redirect { target } => {\n+                    let t = target.clone();\n+                    drop(target);\n+                    let (target, redir_entry) = self.load_file(&t, report);\n+                    match redir_entry {\n+                        FileEntry::Missing => {\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: broken redirect from `{}` to `{}`\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::Redirect { target } => {\n+                            // Redirect to a redirect, this link checker\n+                            // currently doesn't support this, since it would\n+                            // require cycle checking, etc.\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: redirect from `{}` to `{}` \\\n+                                 which is also a redirect (not supported)\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target.display()\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::Dir => {\n+                            report.errors += 1;\n+                            println!(\n+                                \"{}:{}: redirect from `{}` to `{}` \\\n+                                 which is a directory \\\n+                                 (directory links should use index.html instead)\",\n+                                pretty_path,\n+                                i + 1,\n+                                target_pretty_path,\n+                                target\n+                            );\n+                            return;\n+                        }\n+                        FileEntry::OtherFile => return,\n+                        FileEntry::HtmlFile { source, ids } => (source, ids),\n                     }\n                 }\n-                let res = self.load_file(&path, FromRedirect(false));\n-                let (pretty_path, contents) = match res {\n-                    Ok(res) => res,\n-                    Err(LoadError::BrokenRedirect(target, _)) => {\n-                        self.errors += 1;\n-                        println!(\n-                            \"{}:{}: broken redirect to {}\",\n-                            pretty_file.display(),\n-                            i + 1,\n-                            target.display()\n-                        );\n-                        return;\n-                    }\n-                    Err(LoadError::IsRedirect) => unreachable!(),\n-                };\n+                FileEntry::HtmlFile { source, ids } => (source, ids),\n+            };\n \n-                if let Some(ref fragment) = fragment {\n-                    // Fragments like `#1-6` are most likely line numbers to be\n-                    // interpreted by javascript, so we're ignoring these\n-                    if fragment.splitn(2, '-').all(|f| f.chars().all(|c| c.is_numeric())) {\n-                        return;\n-                    }\n+            // Alright, if we've found an HTML file for the target link. If\n+            // this is a fragment link, also check that the `id` exists.\n+            if let Some(ref fragment) = fragment {\n+                // Fragments like `#1-6` are most likely line numbers to be\n+                // interpreted by javascript, so we're ignoring these\n+                if fragment.splitn(2, '-').all(|f| f.chars().all(|c| c.is_numeric())) {\n+                    return;\n+                }\n \n-                    // These appear to be broken in mdbook right now?\n-                    if fragment.starts_with('-') {\n-                        return;\n-                    }\n+                // These appear to be broken in mdbook right now?\n+                if fragment.starts_with('-') {\n+                    return;\n+                }\n \n-                    let entry = self.cache.get_mut(&pretty_path).unwrap();\n-                    entry.parse_ids(&pretty_path, &contents, &mut self.errors);\n+                parse_ids(&mut target_ids.borrow_mut(), &pretty_path, target_source, report);\n \n-                    if entry.ids.contains(*fragment) {\n-                        return;\n-                    }\n-\n-                    if is_exception(file, &format!(\"#{}\", fragment)) {\n-                        self.links_ignored_exception += 1;\n-                    } else {\n-                        self.errors += 1;\n-                        print!(\"{}:{}: broken link fragment \", pretty_file.display(), i + 1);\n-                        println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n-                    };\n+                if target_ids.borrow().contains(*fragment) {\n+                    return;\n                 }\n-            } else {\n-                let pretty_path = path.strip_prefix(&self.root).unwrap_or(&path);\n-                if is_exception(file, pretty_path.to_str().unwrap()) {\n+\n+                if is_exception(file, &format!(\"#{}\", fragment)) {\n+                    report.links_ignored_exception += 1;\n                 } else {\n-                    self.errors += 1;\n-                    print!(\"{}:{}: broken link - \", pretty_file.display(), i + 1);\n-                    println!(\"{}\", pretty_path.display());\n-                }\n+                    report.errors += 1;\n+                    print!(\"{}:{}: broken link fragment \", pretty_path, i + 1);\n+                    println!(\"`#{}` pointing to `{}`\", fragment, pretty_path);\n+                };\n             }\n         });\n \n         // Search for intra-doc links that rustdoc didn't warn about\n         // FIXME(#77199, 77200) Rustdoc should just warn about these directly.\n         // NOTE: only looks at one line at a time; in practice this should find most links\n-        for (i, line) in contents.lines().enumerate() {\n+        for (i, line) in source.lines().enumerate() {\n             for broken_link in BROKEN_INTRA_DOC_LINK.captures_iter(line) {\n                 if is_intra_doc_exception(file, &broken_link[1]) {\n-                    self.intra_doc_exceptions += 1;\n+                    report.intra_doc_exceptions += 1;\n                 } else {\n-                    self.errors += 1;\n-                    print!(\"{}:{}: broken intra-doc link - \", pretty_file.display(), i + 1);\n+                    report.errors += 1;\n+                    print!(\"{}:{}: broken intra-doc link - \", pretty_path, i + 1);\n                     println!(\"{}\", &broken_link[0]);\n                 }\n             }\n         }\n-        Some(pretty_file)\n+        // we don't need the source anymore,\n+        // so drop to reduce memory-usage\n+        match self.cache.get_mut(&pretty_path).unwrap() {\n+            FileEntry::HtmlFile { source, .. } => *source = Rc::new(String::new()),\n+            _ => unreachable!(\"must be html file\"),\n+        }\n     }\n \n-    fn load_file(\n-        &mut self,\n-        file: &Path,\n-        redirect: Redirect,\n-    ) -> Result<(PathBuf, Rc<String>), LoadError> {\n-        let pretty_file = PathBuf::from(file.strip_prefix(&self.root).unwrap_or(&file));\n-\n-        let (maybe_redirect, contents) = match self.cache.entry(pretty_file.clone()) {\n-            Entry::Occupied(entry) => (None, entry.get().source.clone()),\n-            Entry::Vacant(entry) => {\n-                let contents = match fs::read_to_string(file) {\n-                    Ok(s) => Rc::new(s),\n-                    Err(err) => {\n-                        return Err(if let FromRedirect(true) = redirect {\n-                            LoadError::BrokenRedirect(file.to_path_buf(), err)\n-                        } else {\n-                            panic!(\"error loading {}: {}\", file.display(), err);\n-                        });\n-                    }\n-                };\n-\n-                let maybe = maybe_redirect(&contents);\n-                if maybe.is_some() {\n-                    self.html_redirects += 1;\n-                    if let SkipRedirect = redirect {\n-                        return Err(LoadError::IsRedirect);\n+    /// Load a file from disk, or from the cache if available.\n+    fn load_file(&mut self, file: &Path, report: &mut Report) -> (String, &FileEntry) {\n+        let pretty_path =\n+            file.strip_prefix(&self.root).unwrap_or(&file).to_str().unwrap().to_string();\n+\n+        let entry =\n+            self.cache.entry(pretty_path.clone()).or_insert_with(|| match fs::metadata(file) {\n+                Ok(metadata) if metadata.is_dir() => FileEntry::Dir,\n+                Ok(_) => {\n+                    if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n+                        FileEntry::OtherFile\n+                    } else {\n+                        report.html_files += 1;\n+                        load_html_file(file, report)\n                     }\n-                } else {\n-                    entry.insert(FileEntry { source: contents.clone(), ids: HashSet::new() });\n                 }\n-                (maybe, contents)\n-            }\n-        };\n-        match maybe_redirect.map(|url| file.parent().unwrap().join(url)) {\n-            Some(redirect_file) => self.load_file(&redirect_file, FromRedirect(true)),\n-            None => Ok((pretty_file, contents)),\n-        }\n+                Err(e) if e.kind() == ErrorKind::NotFound => FileEntry::Missing,\n+                Err(e) => {\n+                    panic!(\"unexpected read error for {}: {}\", file.display(), e);\n+                }\n+            });\n+        (pretty_path, entry)\n     }\n+}\n \n+impl Report {\n     fn report(&self) {\n         println!(\"checked links in: {:.1}s\", self.start.elapsed().as_secs_f64());\n         println!(\"number of HTML files scanned: {}\", self.html_files);\n@@ -406,6 +412,25 @@ impl Checker {\n     }\n }\n \n+fn load_html_file(file: &Path, report: &mut Report) -> FileEntry {\n+    let source = match fs::read_to_string(file) {\n+        Ok(s) => Rc::new(s),\n+        Err(err) => {\n+            // This usually should not fail since `metadata` was already\n+            // called successfully on this file.\n+            panic!(\"unexpected read error for {}: {}\", file.display(), err);\n+        }\n+    };\n+    match maybe_redirect(&source) {\n+        Some(target) => {\n+            report.html_redirects += 1;\n+            let target = file.parent().unwrap().join(target);\n+            FileEntry::Redirect { target }\n+        }\n+        None => FileEntry::HtmlFile { source: source.clone(), ids: RefCell::new(HashSet::new()) },\n+    }\n+}\n+\n fn is_intra_doc_exception(file: &Path, link: &str) -> bool {\n     if let Some(entry) = INTRA_DOC_LINK_EXCEPTIONS.iter().find(|&(f, _)| file.ends_with(f)) {\n         entry.1.is_empty() || entry.1.contains(&link)\n@@ -432,6 +457,8 @@ fn is_exception(file: &Path, link: &str) -> bool {\n     }\n }\n \n+/// If the given HTML file contents is an HTML redirect, this returns the\n+/// destination path given in the redirect.\n fn maybe_redirect(source: &str) -> Option<String> {\n     const REDIRECT: &str = \"<p>Redirecting to <a href=\";\n \n@@ -445,9 +472,9 @@ fn maybe_redirect(source: &str) -> Option<String> {\n     })\n }\n \n-fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str, mut f: F) {\n+fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(source: &str, attr: &str, mut f: F) {\n     let mut base = \"\";\n-    for (i, mut line) in contents.lines().enumerate() {\n+    for (i, mut line) in source.lines().enumerate() {\n         while let Some(j) = line.find(attr) {\n             let rest = &line[j + attr.len()..];\n             // The base tag should always be the first link in the document so\n@@ -486,3 +513,18 @@ fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str,\n         }\n     }\n }\n+\n+fn parse_ids(ids: &mut HashSet<String>, file: &str, source: &str, report: &mut Report) {\n+    if ids.is_empty() {\n+        with_attrs_in_source(source, \" id\", |fragment, i, _| {\n+            let frag = fragment.trim_start_matches(\"#\").to_owned();\n+            let encoded = small_url_encode(&frag);\n+            if !ids.insert(frag) {\n+                report.errors += 1;\n+                println!(\"{}:{}: id is not unique: `{}`\", file, i, fragment);\n+            }\n+            // Just in case, we also add the encoded id.\n+            ids.insert(encoded);\n+        });\n+    }\n+}"}]}