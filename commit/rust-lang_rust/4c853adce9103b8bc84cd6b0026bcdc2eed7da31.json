{"sha": "4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjODUzYWRjZTkxMDNiOGJjODRjZDZiMDAyNmJjZGMyZWVkN2RhMzE=", "commit": {"author": {"name": "Nikolai Vazquez", "email": "nvazquez1297@gmail.com", "date": "2017-09-30T14:08:33Z"}, "committer": {"name": "Nikolai Vazquez", "email": "nvazquez1297@gmail.com", "date": "2017-09-30T14:08:33Z"}, "message": "Merge remote-tracking branch 'upstream/master'", "tree": {"sha": "f71af0eb9d7139af598684355e690596721eac1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f71af0eb9d7139af598684355e690596721eac1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "html_url": "https://github.com/rust-lang/rust/commit/4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/comments", "author": {"login": "nvzqz", "id": 10367662, "node_id": "MDQ6VXNlcjEwMzY3NjYy", "avatar_url": "https://avatars.githubusercontent.com/u/10367662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nvzqz", "html_url": "https://github.com/nvzqz", "followers_url": "https://api.github.com/users/nvzqz/followers", "following_url": "https://api.github.com/users/nvzqz/following{/other_user}", "gists_url": "https://api.github.com/users/nvzqz/gists{/gist_id}", "starred_url": "https://api.github.com/users/nvzqz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nvzqz/subscriptions", "organizations_url": "https://api.github.com/users/nvzqz/orgs", "repos_url": "https://api.github.com/users/nvzqz/repos", "events_url": "https://api.github.com/users/nvzqz/events{/privacy}", "received_events_url": "https://api.github.com/users/nvzqz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nvzqz", "id": 10367662, "node_id": "MDQ6VXNlcjEwMzY3NjYy", "avatar_url": "https://avatars.githubusercontent.com/u/10367662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nvzqz", "html_url": "https://github.com/nvzqz", "followers_url": "https://api.github.com/users/nvzqz/followers", "following_url": "https://api.github.com/users/nvzqz/following{/other_user}", "gists_url": "https://api.github.com/users/nvzqz/gists{/gist_id}", "starred_url": "https://api.github.com/users/nvzqz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nvzqz/subscriptions", "organizations_url": "https://api.github.com/users/nvzqz/orgs", "repos_url": "https://api.github.com/users/nvzqz/repos", "events_url": "https://api.github.com/users/nvzqz/events{/privacy}", "received_events_url": "https://api.github.com/users/nvzqz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9d877221f65b26e52f49bfc639ef705ff396deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d877221f65b26e52f49bfc639ef705ff396deb", "html_url": "https://github.com/rust-lang/rust/commit/d9d877221f65b26e52f49bfc639ef705ff396deb"}, {"sha": "c4cca3a72df87def5cb18ff500c643fbff8ad08e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4cca3a72df87def5cb18ff500c643fbff8ad08e", "html_url": "https://github.com/rust-lang/rust/commit/c4cca3a72df87def5cb18ff500c643fbff8ad08e"}], "stats": {"total": 12102, "additions": 7947, "deletions": 4155}, "files": [{"sha": "309fbd95345a451fd9bcf6e04d65180ecf8229f4", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -103,3 +103,6 @@ version.texi\n .cargo\n !src/vendor/**\n /src/target/\n+\n+no_llvm_build\n+"}, {"sha": "3834c54d6c4f72b203463d02dc7fc676ccfc613f", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -461,6 +461,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n * The [generated documentation for rust's compiler][gdfrustc]\n@@ -476,6 +477,7 @@ are:\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org\n [rr]: https://doc.rust-lang.org/book/README.html\n+[rustforge]: https://forge.rust-lang.org/\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./src/test/COMPILER_TESTS.md"}, {"sha": "c77be5154d3dbad794948d7589455e9fa990062a", "filename": "src/Cargo.lock", "status": "modified", "additions": 238, "deletions": 211, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,10 +1,6 @@\n [root]\n-name = \"unwind\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core 0.0.0\",\n- \"libc 0.0.0\",\n-]\n+name = \"workspace_symbol\"\n+version = \"0.1.0\"\n \n [[package]]\n name = \"advapi32-sys\"\n@@ -46,8 +42,8 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n ]\n \n@@ -80,31 +76,31 @@ version = \"0.2.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace-sys 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.12\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -140,16 +136,16 @@ name = \"bootstrap\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -166,16 +162,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"build_helper\"\n version = \"0.1.0\"\n dependencies = [\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -193,8 +189,8 @@ dependencies = [\n  \"docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -205,20 +201,20 @@ dependencies = [\n  \"ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"scoped-tls 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -233,13 +229,13 @@ name = \"cargotest\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo 0.23.0\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -248,34 +244,38 @@ dependencies = [\n name = \"cargotest2\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"cc\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"cfg-if\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"clap\"\n-version = \"2.26.0\"\n+version = \"2.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"textwrap 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"textwrap 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"yaml-rust 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.25\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -300,9 +300,9 @@ version = \"0.0.0\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -332,15 +332,15 @@ version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"core-foundation-sys\"\n version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -349,9 +349,9 @@ version = \"0.12.0\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -394,23 +394,23 @@ name = \"curl\"\n version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"socket2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"socket2 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.3.14\"\n+version = \"0.3.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -459,8 +459,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -500,15 +500,15 @@ name = \"error-chain\"\n version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"error-chain\"\n version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -520,10 +520,11 @@ dependencies = [\n \n [[package]]\n name = \"filetime\"\n-version = \"0.1.10\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -540,11 +541,11 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"flate2\"\n-version = \"0.2.19\"\n+version = \"0.2.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miniz-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -567,7 +568,7 @@ version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -582,7 +583,7 @@ dependencies = [\n \n [[package]]\n name = \"futures\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -592,7 +593,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"getopts\"\n-version = \"0.2.14\"\n+version = \"0.2.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -601,10 +602,10 @@ version = \"0.6.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -661,10 +662,10 @@ dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quick-error 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -753,9 +754,9 @@ version = \"0.1.0\"\n name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n- \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -766,28 +767,28 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"jobserver\"\n version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"jsonrpc-core\"\n-version = \"7.1.0\"\n+version = \"7.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"futures 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"futures 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -816,9 +817,9 @@ version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -837,21 +838,21 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.30\"\n+version = \"0.2.31\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.6.14\"\n+version = \"0.6.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -860,20 +861,20 @@ name = \"libssh2-sys\"\n version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"libz-sys\"\n-version = \"1.0.16\"\n+version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -889,12 +890,13 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"lzma-sys\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -942,18 +944,18 @@ name = \"mdbook\"\n version = \"0.0.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"handlebars 0.27.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -963,24 +965,24 @@ name = \"memchr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"miniz-sys\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1005,7 +1007,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1081,7 +1083,7 @@ name = \"num_cpus\"\n version = \"1.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1090,19 +1092,19 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"open\"\n-version = \"1.2.0\"\n+version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl\"\n-version = \"0.9.17\"\n+version = \"0.9.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1112,11 +1114,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.17\"\n+version = \"0.9.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1219,8 +1221,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1238,12 +1240,12 @@ version = \"0.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"quick-error\"\n-version = \"1.2.0\"\n+version = \"1.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -1261,7 +1263,7 @@ name = \"racer\"\n version = \"2.0.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1282,10 +1284,15 @@ name = \"rand\"\n version = \"0.3.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.1.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"reformat\"\n version = \"0.1.0\"\n@@ -1346,26 +1353,26 @@ version = \"0.122.0\"\n dependencies = [\n  \"cargo 0.23.0\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"jsonrpc-core 7.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-rustc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.2.5\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.2.7\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.6.7\"\n+version = \"0.6.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1382,8 +1389,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1397,8 +1404,8 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1414,7 +1421,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1424,7 +1431,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1482,7 +1489,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1621,7 +1628,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n ]\n \n@@ -1632,15 +1639,15 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n [[package]]\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n@@ -1677,7 +1684,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1715,6 +1722,7 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -1751,8 +1759,8 @@ name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1777,7 +1785,12 @@ dependencies = [\n name = \"rustc_trans_utils\"\n version = \"0.0.0\"\n dependencies = [\n+ \"ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -1789,7 +1802,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n ]\n \n@@ -1815,8 +1828,8 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"html-diff 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1831,18 +1844,18 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.2.5\"\n+version = \"0.2.7\"\n dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1890,7 +1903,7 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1900,22 +1913,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.11\"\n+version = \"1.0.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.11\"\n+version = \"1.0.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive_internals\"\n-version = \"0.15.1\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1927,18 +1940,18 @@ name = \"serde_ignored\"\n version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"itoa 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1962,12 +1975,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1985,10 +1998,10 @@ dependencies = [\n  \"alloc_jemalloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n+ \"cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"collections 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n- \"gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.0.0\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -2018,7 +2031,7 @@ dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"phf_shared 0.7.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"precomputed-hash 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_codegen 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2116,7 +2129,7 @@ name = \"syntex_errors\"\n version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2138,7 +2151,7 @@ version = \"0.52.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2152,8 +2165,8 @@ name = \"tar\"\n version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2194,7 +2207,7 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2210,13 +2223,13 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.0.0\",\n ]\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2229,7 +2242,7 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2266,7 +2279,7 @@ name = \"toml\"\n version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2307,6 +2320,10 @@ name = \"unicode-xid\"\n version = \"0.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"unic\u00f8d\u00eb\"\n+version = \"0.1.0\"\n+\n [[package]]\n name = \"unreachable\"\n version = \"0.1.1\"\n@@ -2330,6 +2347,14 @@ dependencies = [\n  \"tidy 0.1.0\",\n ]\n \n+[[package]]\n+name = \"unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n [[package]]\n name = \"url\"\n version = \"1.5.1\"\n@@ -2345,7 +2370,7 @@ name = \"url_serde\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2434,15 +2459,15 @@ name = \"xattr\"\n version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"xz2\"\n version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lzma-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lzma-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2457,16 +2482,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n \"checksum ar 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b24e4eef8e3fa7e2ca75b157e6039cdf8d9d3a68213ddc19d0fd9d576b9717c9\"\n \"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n-\"checksum backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"72f9b4182546f4b04ebc4ab7f84948953a118bd6021a1b6a6c909e3e94f6be76\"\n-\"checksum backtrace-sys 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"afccc5772ba333abccdf60d55200fa3406f8c59dcf54d5f7998c9107d3799c7c\"\n+\"checksum backtrace 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99f2ce94e22b8e664d95c57fff45b98a966c2252b60691d0b7aeeccd88d70983\"\n+\"checksum backtrace-sys 0.1.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c63ea141ef8fdb10409d0f5daf30ac51f84ef43bff66f16627773d2a292cd189\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n \"checksum bitflags 0.9.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n \"checksum bitflags 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5cde24d1b2e2216a726368b2363a273739c91f4e3eb4e0dd12d672d396ad989\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n+\"checksum cc 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7db2f146208d7e0fbee761b09cd65a7f51ccc38705d4e7262dad4d73b12a76b1\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n-\"checksum clap 2.26.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2267a8fdd4dce6956ba6649e130f62fb279026e5e84b92aa939ac8f85ce3f9f0\"\n-\"checksum cmake 0.1.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c8a6541a55bcd72d3de4faee2d101a5a66df29790282c7f797082a7228a9b3d\"\n+\"checksum clap 2.26.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3451e409013178663435d6f15fdb212f14ee4424a3d74f979d081d0a66b6f1f2\"\n+\"checksum cmake 0.1.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"357c07e7a1fc95732793c1edb5901e1a1f305cfcf63a90eb12dbd22bdb6b789d\"\n \"checksum conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299\"\n \"checksum core-foundation 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5909502e547762013619f4c4e01cc7393c20fe2d52d7fa471c1210adb2320dc7\"\n \"checksum core-foundation-sys 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc9fb3d6cb663e6fd7cf1c63f9b144ee2b1e4a78595a0451dd34bff85b9a3387\"\n@@ -2475,7 +2501,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cssparser 0.13.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef6124306e5ebc5ab11891d063aeafdd0cdc308079b708c8b566125f3680292b\"\n \"checksum cssparser-macros 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"079adec4af52bb5275eadd004292028c79eb3c5f5b4ee8086a36d4197032f6df\"\n \"checksum curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7034c534a1d7d22f7971d6088aa9d281d219ef724026c3428092500f41ae9c2c\"\n-\"checksum curl-sys 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d5481162dc4f424d088581db2f979fa7d4c238fe9794595de61d8d7522e277de\"\n+\"checksum curl-sys 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4bee31aa3a079d5f3ff9579ea4dcfb1b1a17a40886f5f467436d383e78134b55\"\n \"checksum custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef8ae57c4978a2acd8b869ce6b9ca1dfe817bff704c220209fdef2c0b75a01b9\"\n \"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n \"checksum debug_unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a032eac705ca39214d169f83e3d3da290af06d8d1d344d1baad2fd002dca4b3\"\n@@ -2488,15 +2514,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n-\"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n+\"checksum filetime 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ab199bf38537c6f38792669e081e0bb278b9b7405bba2642e4e5d15bf732c0e\"\n+\"checksum flate2 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e6234dd4468ae5d1e2dbb06fe2b058696fdc50a339c68a393aefbf00bc81e423\"\n \"checksum fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6cc484842f1e2884faf56f529f960cc12ad8c71ce96cc7abba0a067c98fee344\"\n \"checksum foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e4056b9bd47f8ac5ba12be771f77a0dae796d1bbaaf5fd0b9c2d38b69b8a29d\"\n \"checksum fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ab76cfd2aaa59b7bf6688ad9ba15bbae64bff97f04ea02144cfd3443e5c2866\"\n \"checksum futf 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51f93f3de6ba1794dcd5810b3546d004600a59a98266487c8407bc4b24e398f3\"\n-\"checksum futures 0.1.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a82bdc62350ca9d7974c760e9665102fc9d740992a528c2254aa930e53b783c4\"\n+\"checksum futures 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"05a23db7bd162d4e8265968602930c476f688f0c180b44bdaf55e0cb2c687558\"\n \"checksum gcc 0.3.54 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e33ec290da0d127825013597dbdfc28bee4964690c7ce1166cbc2a7bd08b1bb\"\n-\"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n+\"checksum getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"65922871abd2f101a2eb0eaebadc66668e54a87ad9c3dd82520b5f86ede5eff9\"\n \"checksum git2 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c1c0203d653f4140241da0c1375a404f0a397249ec818cd2076c6280c50f6fa\"\n \"checksum git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"68676bc784bf0bef83278898929bf64a251e87c0340723d0b93fa096c9c5bf8e\"\n \"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n@@ -2509,19 +2535,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum html5ever 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a49d5001dd1bddf042ea41ed4e0a671d50b1bf187e66b349d7ec613bdce4ad90\"\n \"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d\"\n \"checksum ignore 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3fcaf2365eb14b28ec7603c98c06cc531f19de9eb283d89a3dff8417c8c99f5\"\n-\"checksum itoa 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac17257442c2ed77dbc9fd555cf83c58b0c7f7d0e8f2ae08c0ac05c72842e1f6\"\n+\"checksum itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8324a32baf01e2ae060e9de58ed0bc2320c9a2833491ee36cd3b4c414de4db8c\"\n \"checksum jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"443ae8bc0af6c106e6e8b77e04684faecc1a5ce94e058f4c2b0a037b0ea1b133\"\n-\"checksum jsonrpc-core 7.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"903e5eee845f3d83c1436d12848d97b1247cf850ff06a8e1db2f1ce3543af2cf\"\n+\"checksum jsonrpc-core 7.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1acd0f9934da94466d2370f36832b9b19271b4abdfdb5e69f0bcd991ebcd515\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n \"checksum kuchiki 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef2ea4f2f7883cd7c6772b06c14abca01a2cc1f75c426cebffcf6b3b925ef9fc\"\n \"checksum languageserver-types 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d52e477b23bf52cd3ca0f9fc6c5d14be954eec97e3b9cdfbd962d911bd533caf\"\n \"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n-\"checksum libc 0.2.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2370ca07ec338939e356443dac2296f581453c35fe1e3a3ed06023c49435f915\"\n-\"checksum libgit2-sys 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c00f6e5bc3fb2b5f87e75e8d0fd4ae6720d55f3ee23d389b7c6cae30f8db8db1\"\n+\"checksum libc 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d1419b2939a0bc44b77feb34661583c7546b532b192feab36249ab584b86856c\"\n+\"checksum libgit2-sys 0.6.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"205fc37e829c5b36de63d14c8dc8b62c5a6a2519b16318ed0977079ca97256a9\"\n \"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n-\"checksum libz-sys 1.0.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3fdd64ef8ee652185674455c1d450b83cbc8ad895625d543b5324d923f82e4d8\"\n+\"checksum libz-sys 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44ebbc760fd2d2f4d93de09a0e13d97e057612052e871da9985cedcb451e6bd5\"\n \"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n-\"checksum lzma-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66b2e318eb97ab84f05725471f90c52a09c964053a5899a13fd0165acc26d00b\"\n+\"checksum lzma-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1b93b78f89e8737dac81837fc8f5521ac162abcba902e1a3db949d55346d1da\"\n \"checksum mac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c41e0c4fef86961ac6d6f8a82609f55f31b05e4fce149ac5710e439df7619ba4\"\n \"checksum magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4bf0336886480e671965f794bc9b6fce88503563013d1bfb7a502c81fe3ac527\"\n \"checksum magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40d014c7011ac470ae28e2f76a02bfea4a8480f73e701353b49ad7a8d75f4699\"\n@@ -2530,7 +2556,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum mdbook 0.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"146eadfc6d141452a364c351f07bb19208d1401e931f40b8532f87bba3ecc40f\"\n \"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n-\"checksum miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28eaee17666671fa872e567547e8428e83308ebe5808cdf6a0e28397dbe2c726\"\n+\"checksum miniz-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"609ce024854aeb19a0ef7567d348aaa5a746b32fb72e336df7fcc16869d7e2b4\"\n \"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n \"checksum net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a80f842784ef6c9a958b68b7516bc7e35883c614004dd94959a4dca1b716c09\"\n \"checksum num 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a311b77ebdc5dd4cf6449d81e4135d9f0e3b153839ac90e648a8ef538f923525\"\n@@ -2541,10 +2567,10 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum num-rational 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"288629c76fac4b33556f4b7ab57ba21ae202da65ba8b77466e6d598e31990790\"\n \"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n \"checksum num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aec53c34f2d0247c5ca5d32cca1478762f301740468ee9ee6dcb7a0dd7a0c584\"\n-\"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n-\"checksum openssl 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"085aaedcc89a2fac1eb2bc19cd66f29d4ea99fec60f82a5f3a88a6be7dbd90b5\"\n+\"checksum open 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c281318d992e4432cfa799969467003d05921582a7489a8325e37f8a450d5113\"\n+\"checksum openssl 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"816914b22eb15671d62c73442a51978f311e911d6a6f6cbdafa6abce1b5038fc\"\n \"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n-\"checksum openssl-sys 0.9.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e3a9845a4c9fdb321931868aae5549e96bb7b979bf9af7de03603d74691b5f3\"\n+\"checksum openssl-sys 0.9.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e4c63a7d559c1e5afa6d6a9e6fa34bbc5f800ffc9ae08b72c605420b0c4f5e8\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum percent-encoding 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de154f638187706bde41d9b4738748933d64e6b37bdbffc0b47a97d16a6ae356\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n@@ -2557,16 +2583,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum procedural-masquerade 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c93cdc1fb30af9ddf3debc4afbdb0f35126cbd99daa229dd76cdd5349b41d989\"\n \"checksum psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abcd5d1a07d360e29727f757a9decb3ce8bc6e0efa8969cfaad669a8317a2478\"\n \"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n-\"checksum quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c36987d4978eb1be2e422b1e0423a557923a5c3e7e6f31d5699e9aafaefa469\"\n+\"checksum quick-error 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eda5fe9b71976e62bc81b781206aaa076401769b2143379d3eb2118388babac4\"\n \"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum racer 2.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f120c7510ef7aff254aeb06067fb6fac573ec96a1660e194787cf9dced412bf0\"\n \"checksum rand 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb250fd207a4729c976794d03db689c9be1d634ab5a1c9da9492a13d8fecbcdf\"\n+\"checksum redox_syscall 0.1.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dde11f18c108289bef24469638a04dce49da56084f2d50618b226e47eb04509\"\n \"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rls-analysis 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4302cc8291570d7f817945845d8c01756e833dbc93c0a87d4f6c9a0b0b7992f1\"\n+\"checksum rls-analysis 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa390bdc70b0a90d07d9cd5c6989ba5fca2d59728903919ebda1a1b2037b18d7\"\n \"checksum rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d339f1888e33e74d8032de0f83c40b2bdaaaf04a8cfc03b32186c3481fb534\"\n \"checksum rls-rustc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b21ea952e9bf1569929abf1bb920262cde04b7b1b26d8e0260286302807299d2\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n@@ -2579,15 +2606,15 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum selectors 0.18.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3c89b1c6a3c029c82263f7dd2d44d0005ee7374eb09e254ab59dede4353a8c0\"\n \"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7726f29ddf9731b17ff113c461e362c381d9d69433f79de4f3dd572488823e9\"\n-\"checksum serde_derive 1.0.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cf823e706be268e73e7747b147aa31c8f633ab4ba31f115efb57e5047c3a76dd\"\n-\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n+\"checksum serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a7046c9d4c6c522d10b2d098f9bebe2bef227e0e74044d8c1bfcf6b476af799\"\n+\"checksum serde_derive 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1afcaae083fd1c46952a315062326bc9957f182358eb7da03b57ef1c688f7aa9\"\n+\"checksum serde_derive_internals 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd381f6d01a6616cdba8530492d453b7761b456ba974e98768a18cad2cd76f58\"\n \"checksum serde_ignored 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n-\"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n+\"checksum serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d243424e06f9f9c39e3cd36147470fd340db785825e367625f79298a6ac6b7ac\"\n \"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n \"checksum siphasher 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \"checksum smallvec 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f8266519bc1d17d0b5b16f6c21295625d562841c708f6376f49028a43e9c11e\"\n-\"checksum socket2 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4daf80fcf54186fac4fe049e0b39d36a5cfde69a11a06413e61e77f553cccf9a\"\n+\"checksum socket2 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e76b159741052c7deaa9fd0b5ca6b5f79cecf525ed665abfe5002086c6b2791\"\n \"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n \"checksum string_cache 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"413fc7852aeeb5472f1986ef755f561ddf0c789d3d796e65f0b6fe293ecd4ef8\"\n \"checksum string_cache_codegen 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"479cde50c3539481f33906a387f2bd17c8e87cb848c35b6021d41fb81ff9b4d7\"\n@@ -2606,7 +2633,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n \"checksum term_size 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2b6b55df3198cc93372e85dd2ed817f0e38ce8cc0f22eb32391bfad9c4bf209\"\n \"checksum termcolor 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9065bced9c3e43453aa3d56f1e98590b8455b341d2fa191a1090c0dd0b242c75\"\n-\"checksum textwrap 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f728584ea33b0ad19318e20557cb0a39097751dbb07171419673502f848c7af6\"\n+\"checksum textwrap 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"df8e08afc40ae3459e4838f303e465aa50d823df8d7f83ca88108f6d3afe7edd\"\n \"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n \"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n \"checksum thread_local 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1697c4b57aeeb7a536b647165a2825faddffb1d3bad386d507709bd51a90bb14\""}, {"sha": "f4b4189e01f06a17d489b580ecae03064f91bf7d", "filename": "src/Cargo.toml", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -38,6 +38,8 @@ members = [\n   \"tools/rls/test_data/infer_custom_bin\",\n   \"tools/rls/test_data/infer_lib\",\n   \"tools/rls/test_data/omit_init_build\",\n+  \"tools/rls/test_data/unic\u00f8d\u00eb\",\n+  \"tools/rls/test_data/workspace_symbol\",\n ]\n \n # Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit\n@@ -60,10 +62,5 @@ debug-assertions = false\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"tools/cargo\" }\n \n-# Override rustfmt dependencies both on the repo and the crate (the RLS\n-# sometimes uses either).\n-# FIXME should only need the crates.io patch, long term.\n-[patch.\"https://github.com/rust-lang-nursery/rustfmt\"]\n-rustfmt-nightly = { path = \"tools/rustfmt\" }\n [patch.crates-io]\n rustfmt-nightly = { path = \"tools/rustfmt\" }"}, {"sha": "3f1d03b187203d220a7fc26bc312460b121ceee9", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -34,7 +34,7 @@ cmake = \"0.1.23\"\n filetime = \"0.1\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n-gcc = \"0.3.54\"\n+cc = \"1.0\"\n libc = \"0.2\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\""}, {"sha": "8584014d48d5f5ff62161514bfab9bddf772ebad", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate gcc;\n+extern crate cc;\n \n use std::env;\n use std::process::{self, Command};\n@@ -18,7 +18,7 @@ fn main() {\n     // Locate the actual compiler that we're invoking\n     env::remove_var(\"CC\");\n     env::remove_var(\"CXX\");\n-    let mut cfg = gcc::Build::new();\n+    let mut cfg = cc::Build::new();\n     cfg.cargo_metadata(false)\n        .out_dir(\"/\")\n        .target(&target)"}, {"sha": "4a8c3dcebcb498619186894cd0d92ccdea4d56b1", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -682,7 +682,7 @@ def bootstrap():\n     try:\n         with open(args.config or 'config.toml') as config:\n             build.config_toml = config.read()\n-    except OSError:\n+    except (OSError, IOError):\n         pass\n \n     if '\\nverbose = 2' in build.config_toml:"}, {"sha": "e7a5196178c3f0758244c01487da0f53fecfb225", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -306,7 +306,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n-            Subcommand::Clean => panic!(),\n+            Subcommand::Clean { .. } => panic!(),\n         };\n \n         let builder = Builder {\n@@ -531,7 +531,10 @@ impl<'a> Builder<'a> {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        if mode == Mode::Libstd {\n+        //\n+        // If LLVM support is disabled we need to use the snapshot compiler to compile\n+        // build scripts, as the new compiler doesnt support executables.\n+        if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n             cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {"}, {"sha": "08df65c7611821bce454586aa9f72a6244df3b39", "filename": "src/bootstrap/cc_detect.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -23,7 +23,7 @@\n //! 6. \"cc\"\n //!\n //! Some of this logic is implemented here, but much of it is farmed out to the\n-//! `gcc` crate itself, so we end up having the same fallbacks as there.\n+//! `cc` crate itself, so we end up having the same fallbacks as there.\n //! Similar logic is then used to find a C++ compiler, just some s/cc/c++/ is\n //! used.\n //!\n@@ -35,7 +35,7 @@ use std::process::Command;\n use std::iter;\n \n use build_helper::{cc2ar, output};\n-use gcc;\n+use cc;\n \n use Build;\n use config::Target;\n@@ -45,7 +45,7 @@ pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n     for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n-        let mut cfg = gcc::Build::new();\n+        let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n \n@@ -67,7 +67,7 @@ pub fn find(build: &mut Build) {\n \n     // For all host triples we need to find a C++ compiler as well\n     for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n-        let mut cfg = gcc::Build::new();\n+        let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n@@ -82,7 +82,7 @@ pub fn find(build: &mut Build) {\n     }\n }\n \n-fn set_compiler(cfg: &mut gcc::Build,\n+fn set_compiler(cfg: &mut cc::Build,\n                 gnu_compiler: &str,\n                 target: Interned<String>,\n                 config: Option<&Target>,", "previous_filename": "src/bootstrap/cc.rs"}, {"sha": "6e276f44668f76070085effaf189d5c064904c3e", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -254,7 +254,11 @@ impl Step for Rls {\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run(build, &mut cargo);\n+        try_run_expecting(\n+            build,\n+            &mut cargo,\n+            builder.build.config.toolstate.rls.passes(ToolState::Testing),\n+        );\n     }\n }\n \n@@ -295,7 +299,11 @@ impl Step for Rustfmt {\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-        try_run(build, &mut cargo);\n+        try_run_expecting(\n+            build,\n+            &mut cargo,\n+            builder.build.config.toolstate.rustfmt.passes(ToolState::Testing),\n+        );\n     }\n }\n "}, {"sha": "87f194fb7d2f85d4ae3eed1e32efd0390331975b", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,32 +13,37 @@\n //! Responsible for cleaning out a build directory of all old and stale\n //! artifacts to prepare for a fresh build. Currently doesn't remove the\n //! `build/cache` directory (download cache) or the `build/$target/llvm`\n-//! directory as we want that cached between builds.\n+//! directory unless the --all flag is present.\n \n use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n use Build;\n \n-pub fn clean(build: &Build) {\n+pub fn clean(build: &Build, all: bool) {\n     rm_rf(\"tmp\".as_ref());\n-    rm_rf(&build.out.join(\"tmp\"));\n-    rm_rf(&build.out.join(\"dist\"));\n \n-    for host in &build.hosts {\n-        let entries = match build.out.join(host).read_dir() {\n-            Ok(iter) => iter,\n-            Err(_) => continue,\n-        };\n+    if all {\n+        rm_rf(&build.out);\n+    } else {\n+        rm_rf(&build.out.join(\"tmp\"));\n+        rm_rf(&build.out.join(\"dist\"));\n \n-        for entry in entries {\n-            let entry = t!(entry);\n-            if entry.file_name().to_str() == Some(\"llvm\") {\n-                continue\n+        for host in &build.hosts {\n+            let entries = match build.out.join(host).read_dir() {\n+                Ok(iter) => iter,\n+                Err(_) => continue,\n+            };\n+\n+            for entry in entries {\n+                let entry = t!(entry);\n+                if entry.file_name().to_str() == Some(\"llvm\") {\n+                    continue\n+                }\n+                let path = t!(entry.path().canonicalize());\n+                rm_rf(&path);\n             }\n-            let path = t!(entry.path().canonicalize());\n-            rm_rf(&path);\n         }\n     }\n }"}, {"sha": "67337bf44214e982269b50c8de286cf1d2453f92", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -109,6 +109,8 @@ def v(*args):\n   \"arm-unknown-linux-musleabihf install directory\")\n v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n+v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\",\n+  \"aarch64-unknown-linux-musl install directory\")\n v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\","}, {"sha": "3d4aa0413db6188278cbede24b6c8eb444229550", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1098,13 +1098,8 @@ impl Step for Rls {\n            .arg(\"--output-dir\").arg(&distdir(build))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n-           .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-\n-        if build.config.channel == \"nightly\" {\n-            cmd.arg(\"--component-name=rls\");\n-        } else {\n-            cmd.arg(\"--component-name=rls-preview\");\n-        }\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--component-name=rls-preview\");\n \n         build.run(&mut cmd);\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n@@ -1333,12 +1328,8 @@ impl Step for Extended {\n             cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-std\"), target))\n                         .join(format!(\"rust-std-{}\", target)),\n                     &exe.join(\"rust-std\"));\n-            let rls_path = if build.config.channel == \"nightly\" {\n-                work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls\")\n-            } else {\n-                work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls-preview\")\n-            };\n-            cp_r(&rls_path, &exe.join(\"rls\"));\n+            cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rls\"), target)).join(\"rls-preview\"),\n+                 &exe.join(\"rls\"));\n             cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, \"rust-analysis\"), target))\n                         .join(format!(\"rust-analysis-{}\", target)),\n                     &exe.join(\"rust-analysis\"));"}, {"sha": "df378188b4ad05c0fe044c2be4a3bcad820af1d8", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -60,7 +60,9 @@ pub enum Subcommand {\n         paths: Vec<PathBuf>,\n         test_args: Vec<String>,\n     },\n-    Clean,\n+    Clean {\n+        all: bool,\n+    },\n     Dist {\n         paths: Vec<PathBuf>,\n     },\n@@ -147,6 +149,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n             },\n             \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n             _ => { },\n         };\n \n@@ -250,17 +253,18 @@ Arguments:\n             }\n         });\n \n-        // All subcommands can have an optional \"Available paths\" section\n+        // All subcommands except `clean` can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n             let config = Config::parse(&[\"build\".to_string()]);\n             let mut build = Build::new(config);\n             metadata::build(&mut build);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-        } else {\n-            extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                     subcommand).as_str());\n+        } else if subcommand.as_str() != \"clean\" {\n+            extra_help.push_str(format!(\n+                \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                subcommand).as_str());\n         }\n \n         // User passed in -h/--help?\n@@ -290,10 +294,13 @@ Arguments:\n             }\n             \"clean\" => {\n                 if paths.len() > 0 {\n-                    println!(\"\\nclean takes no arguments\\n\");\n+                    println!(\"\\nclean does not take a path argument\\n\");\n                     usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n-                Subcommand::Clean\n+\n+                Subcommand::Clean {\n+                    all: matches.opt_present(\"all\"),\n+                }\n             }\n             \"dist\" => {\n                 Subcommand::Dist {"}, {"sha": "2d721f455785a0fa8152365b26411173917e7c3e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -126,7 +126,7 @@ extern crate lazy_static;\n extern crate serde_json;\n extern crate cmake;\n extern crate filetime;\n-extern crate gcc;\n+extern crate cc;\n extern crate getopts;\n extern crate num_cpus;\n extern crate toml;\n@@ -148,7 +148,7 @@ use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppresse\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n-mod cc;\n+mod cc_detect;\n mod channel;\n mod check;\n mod clean;\n@@ -241,9 +241,9 @@ pub struct Build {\n \n     // Runtime state filled in later on\n     // target -> (cc, ar)\n-    cc: HashMap<Interned<String>, (gcc::Tool, Option<PathBuf>)>,\n+    cc: HashMap<Interned<String>, (cc::Tool, Option<PathBuf>)>,\n     // host -> (cc, ar)\n-    cxx: HashMap<Interned<String>, gcc::Tool>,\n+    cxx: HashMap<Interned<String>, cc::Tool>,\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -345,12 +345,12 @@ impl Build {\n             job::setup(self);\n         }\n \n-        if let Subcommand::Clean = self.config.cmd {\n-            return clean::clean(self);\n+        if let Subcommand::Clean { all } = self.config.cmd {\n+            return clean::clean(self, all);\n         }\n \n         self.verbose(\"finding compilers\");\n-        cc::find(self);\n+        cc_detect::find(self);\n         self.verbose(\"running sanity check\");\n         sanity::check(self);\n         // If local-rust is the same major.minor as the current version, then force a local-rebuild\n@@ -619,7 +619,7 @@ impl Build {\n     /// specified.\n     fn cflags(&self, target: Interned<String>) -> Vec<String> {\n         // Filter out -O and /O (the optimization flags) that we picked up from\n-        // gcc-rs because the build scripts will determine that for themselves.\n+        // cc-rs because the build scripts will determine that for themselves.\n         let mut base = self.cc[&target].0.args().iter()\n                            .map(|s| s.to_string_lossy().into_owned())\n                            .filter(|s| !s.starts_with(\"-O\") && !s.starts_with(\"/O\"))"}, {"sha": "c4e80630315200e651e77ba1d72a019e75026e49", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -27,7 +27,7 @@ use std::process::Command;\n \n use build_helper::output;\n use cmake;\n-use gcc;\n+use cc;\n \n use Build;\n use util;\n@@ -289,7 +289,7 @@ impl Step for TestHelpers {\n         let _folder = build.fold_output(|| \"build_test_helpers\");\n         println!(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n-        let mut cfg = gcc::Build::new();\n+        let mut cfg = cc::Build::new();\n \n         // We may have found various cross-compilers a little differently due to our\n         // extra configuration, so inform gcc of these compilers. Note, though, that\n@@ -367,7 +367,7 @@ impl Step for Openssl {\n             if !ok {\n                 panic!(\"failed to download openssl source\")\n             }\n-            let mut shasum = if target.contains(\"apple\") {\n+            let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n                 let mut cmd = Command::new(\"shasum\");\n                 cmd.arg(\"-a\").arg(\"256\");\n                 cmd\n@@ -387,7 +387,7 @@ impl Step for Openssl {\n         let dst = build.openssl_install_dir(target).unwrap();\n         drop(fs::remove_dir_all(&obj));\n         drop(fs::remove_dir_all(&dst));\n-        build.run(Command::new(\"tar\").arg(\"xf\").arg(&tarball).current_dir(&out));\n+        build.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n \n         let mut configure = Command::new(\"perl\");\n         configure.arg(obj.join(\"Configure\"));\n@@ -399,6 +399,7 @@ impl Step for Openssl {\n         let os = match &*target {\n             \"aarch64-linux-android\" => \"linux-aarch64\",\n             \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n+            \"aarch64-unknown-linux-musl\" => \"linux-aarch64\",\n             \"arm-linux-androideabi\" => \"android\",\n             \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n             \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\","}, {"sha": "8b23be69a85cf4d6ad41b89a0ee13ad4c47cce60", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -221,8 +221,9 @@ $ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n     let run = |cmd: &mut Command| {\n         cmd.output().map(|output| {\n             String::from_utf8_lossy(&output.stdout)\n-                   .lines().next().unwrap()\n-                   .to_string()\n+                   .lines().next().unwrap_or_else(|| {\n+                       panic!(\"{:?} failed {:?}\", cmd, output)\n+                   }).to_string()\n         })\n     };\n     build.lldb_version = run(Command::new(\"lldb\").arg(\"--version\")).ok();"}, {"sha": "a05e58e6a22706a0ba355df8d3f716ffeb1ac9f6", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -126,6 +126,10 @@ pub fn prepare_tool_cargo(\n         cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n     }\n \n+    // if tools are using lzma we want to force the build script to build its\n+    // own copy\n+    cargo.env(\"LZMA_API_STATIC\", \"1\");\n+\n     cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n     cargo.env(\"CFG_VERSION\", build.rust_version());\n \n@@ -304,6 +308,11 @@ impl Step for Rustdoc {\n                                            target,\n                                            \"build\",\n                                            \"src/tools/rustdoc\");\n+\n+        // Most tools don't get debuginfo, but rustdoc should.\n+        cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n+             .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n+\n         build.run(&mut cargo);\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n@@ -449,7 +458,7 @@ impl Step for Rls {\n             tool: \"rls\",\n             mode: Mode::Librustc,\n             path: \"src/tools/rls\",\n-            expectation: BuildExpectation::None,\n+            expectation: builder.build.config.toolstate.rls.passes(ToolState::Compiling),\n         })\n     }\n }\n@@ -484,7 +493,7 @@ impl Step for Rustfmt {\n             tool: \"rustfmt\",\n             mode: Mode::Librustc,\n             path: \"src/tools/rustfmt\",\n-            expectation: BuildExpectation::None,\n+            expectation: builder.build.config.toolstate.rustfmt.passes(ToolState::Compiling),\n         })\n     }\n }"}, {"sha": "8a113f6b4d2dffe9f3a457ac6c978719be829d4e", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -46,4 +46,6 @@ impl Default for ToolState {\n pub struct ToolStates {\n     pub miri: ToolState,\n     pub clippy: ToolState,\n+    pub rls: ToolState,\n+    pub rustfmt: ToolState,\n }"}, {"sha": "05745709a07cbc3e2cd885079f7a49782c842ad7", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -14,6 +14,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   g++-arm-linux-gnueabi \\\n   g++-arm-linux-gnueabihf \\\n+  g++-aarch64-linux-gnu \\\n   gcc-sparc64-linux-gnu \\\n   libc6-dev-sparc64-cross \\\n   bzip2 \\\n@@ -46,6 +47,7 @@ ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n+ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n \n@@ -62,7 +64,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n       --musl-root-arm=/usr/local/arm-linux-musleabi \\\n       --musl-root-armhf=/usr/local/arm-linux-musleabihf \\\n-      --musl-root-armv7=/usr/local/armv7-linux-musleabihf\n+      --musl-root-armv7=/usr/local/armv7-linux-musleabihf \\\n+      --musl-root-aarch64=/usr/local/aarch64-linux-musl\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n \n # sccache"}, {"sha": "780099e2ec176212d84a24f0a829ea5d95e3a159", "filename": "src/ci/docker/cross/build-arm-musl.sh", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2Fbuild-arm-musl.sh?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -65,11 +65,24 @@ CFLAGS=\"-march=armv7-a\" \\\n hide_output make -j$(nproc)\n hide_output make install\n cd ..\n+rm -rf musl-$MUSL\n+\n+tar xf musl-$MUSL.tar.gz\n+cd musl-$MUSL\n+CC=aarch64-linux-gnu-gcc \\\n+CFLAGS=\"\" \\\n+    hide_output ./configure \\\n+        --prefix=/usr/local/aarch64-linux-musl \\\n+        --enable-wrapper=gcc\n+hide_output make -j$(nproc)\n+hide_output make install\n+cd ..\n rm -rf musl-$MUSL*\n \n ln -nsf ../arm-linux-musleabi/bin/musl-gcc /usr/local/bin/arm-linux-musleabi-gcc\n ln -nsf ../arm-linux-musleabihf/bin/musl-gcc /usr/local/bin/arm-linux-musleabihf-gcc\n ln -nsf ../armv7-linux-musleabihf/bin/musl-gcc /usr/local/bin/armv7-linux-musleabihf-gcc\n+ln -nsf ../aarch64-linux-musl/bin/musl-gcc /usr/local/bin/aarch64-unknown-linux-musl-gcc\n \n curl -L https://github.com/llvm-mirror/llvm/archive/release_39.tar.gz | tar xzf -\n curl -L https://github.com/llvm-mirror/libunwind/archive/release_39.tar.gz | tar xzf -\n@@ -116,5 +129,19 @@ cp lib/libunwind.a /usr/local/armv7-linux-musleabihf/lib\n cd ..\n rm -rf libunwind-build\n \n+mkdir libunwind-build\n+cd libunwind-build\n+cmake ../libunwind-release_39 \\\n+          -DLLVM_PATH=/tmp/llvm-release_39 \\\n+          -DLIBUNWIND_ENABLE_SHARED=0 \\\n+          -DCMAKE_C_COMPILER=aarch64-linux-gnu-gcc \\\n+          -DCMAKE_CXX_COMPILER=aarch64-linux-gnu-g++ \\\n+          -DCMAKE_C_FLAGS=\"\" \\\n+          -DCMAKE_CXX_FLAGS=\"\"\n+make -j$(nproc)\n+cp lib/libunwind.a /usr/local/aarch64-linux-musl/lib\n+cd ..\n+rm -rf libunwind-build\n+\n rm -rf libunwind-release_39\n rm -rf llvm-release_39"}, {"sha": "fedb4094c8aaafd25732e8b163517fd057def3d2", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -31,7 +31,7 @@ WORKDIR /build\n # The `config` config file was a previously generated config file for\n # the kernel. This file was generated by running `make defconfig`\n # followed by `make menuconfig` and then enabling the IPv6 protocol page.\n-COPY disabled/aarch64-gnu/config /build/.config\n+COPY aarch64-gnu/config /build/.config\n RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n       tar xJf - && \\\n       cd /build/linux-4.4.42 && \\"}, {"sha": "8653b0e8b465ec5dda9a20a1b6bf3d9d592e322d", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n # emscripten\n COPY scripts/emscripten-wasm.sh /scripts/\n-COPY disabled/wasm32-exp/node.sh /usr/local/bin/node\n+COPY wasm32-exp/node.sh /usr/local/bin/node\n RUN bash /scripts/emscripten-wasm.sh\n \n # cache"}, {"sha": "bcd95924b427f80600bff1d2acfa20488d7a6d91", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,27 +1,26 @@\n FROM ubuntu:16.04\n \n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n+RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y \\\n+  build-essential \\\n+  bzip2 \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  gdb \\\n+  git \\\n+  libedit-dev \\\n   make \\\n   ninja-build \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  nodejs \\\n   python2.7-dev \\\n-  git \\\n   sudo \\\n-  bzip2 \\\n   xz-utils \\\n-  swig \\\n-  libedit-dev \\\n-  libncurses5-dev \\\n-  patch\n-\n-RUN curl -L https://cmake.org/files/v3.8/cmake-3.8.0-rc1-Linux-x86_64.tar.gz | \\\n-      tar xzf - -C /usr/local --strip-components=1\n+  unzip\n \n WORKDIR /tmp\n-COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh dist-fuchsia/compiler-rt-dso-handle.patch /tmp/\n+COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh /tmp/\n RUN /tmp/build-toolchain.sh\n \n COPY scripts/sccache.sh /scripts/\n@@ -39,4 +38,4 @@ ENV TARGETS=x86_64-unknown-fuchsia\n ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n \n ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n\\ No newline at end of file"}, {"sha": "756013a235cc15ce3d9a4d6d9fbfe2e283209b58", "filename": "src/ci/docker/dist-fuchsia/build-toolchain.sh", "status": "modified", "additions": 24, "deletions": 85, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fbuild-toolchain.sh?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -14,105 +14,44 @@\n set -ex\n source shared.sh\n \n-# Download sources\n-SRCS=(\n-  \"https://fuchsia.googlesource.com/magenta magenta d17073dc8de344ead3b65e8cc6a12280dec38c84\"\n-  \"https://llvm.googlesource.com/llvm llvm 3f58a16d8eec385e2b3ebdfbb84ff9d3bf27e025\"\n-  \"https://llvm.googlesource.com/clang llvm/tools/clang 727ea63e6e82677f6e10e05e08bc7d6bdbae3111\"\n-  \"https://llvm.googlesource.com/lld llvm/tools/lld a31286c1366e5e89b8872803fded13805a1a084b\"\n-  \"https://llvm.googlesource.com/lldb llvm/tools/lldb 0b2384abec4cb99ad66687712e07dee4dd9d187e\"\n-  \"https://llvm.googlesource.com/compiler-rt llvm/runtimes/compiler-rt 9093a35c599fe41278606a20b51095ea8bd5a081\"\n-  \"https://llvm.googlesource.com/libcxx llvm/runtimes/libcxx 607e0c71ec4f7fd377ad3f6c47b08dbe89f66eaa\"\n-  \"https://llvm.googlesource.com/libcxxabi llvm/runtimes/libcxxabi 0a3a1a8a5ca5ef69e0f6b7d5b9d13e63e6fd2c19\"\n-  \"https://llvm.googlesource.com/libunwind llvm/runtimes/libunwind e128003563d99d9ee62247c4cee40f07d21c03e3\"\n-)\n-\n-fetch() {\n-  mkdir -p $2\n-  pushd $2 > /dev/null\n-  git init\n-  git remote add origin $1\n-  git fetch --depth=1 origin $3\n-  git reset --hard FETCH_HEAD\n-  popd > /dev/null\n-}\n+ZIRCON=e9a26dbc70d631029f8ee9763103910b7e3a2fe1\n \n-for i in \"${SRCS[@]}\"; do\n-  fetch $i\n-done\n+mkdir -p zircon\n+pushd zircon > /dev/null\n \n-# Remove this once https://reviews.llvm.org/D28791 is resolved\n-cd llvm/runtimes/compiler-rt\n-patch -Np1 < /tmp/compiler-rt-dso-handle.patch\n-cd ../../..\n+# Download sources\n+git init\n+git remote add origin https://fuchsia.googlesource.com/zircon\n+git fetch --depth=1 origin $ZIRCON\n+git reset --hard FETCH_HEAD\n \n-# Build toolchain\n-cd llvm\n-mkdir build\n-cd build\n-hide_output cmake -GNinja \\\n-  -DFUCHSIA_SYSROOT=${PWD}/../../magenta/third_party/ulib/musl \\\n-  -DLLVM_ENABLE_LTO=OFF \\\n-  -DCLANG_BOOTSTRAP_PASSTHROUGH=LLVM_ENABLE_LTO \\\n-  -C ../tools/clang/cmake/caches/Fuchsia.cmake \\\n-  ..\n-hide_output ninja stage2-distribution\n-hide_output ninja stage2-install-distribution\n-cd ../..\n+# Download toolchain\n+./scripts/download-toolchain\n+chmod -R a+rx prebuilt/downloads/clang+llvm-x86_64-linux\n+cp -a prebuilt/downloads/clang+llvm-x86_64-linux/. /usr/local\n \n-# Build sysroot\n-rm -rf llvm/runtimes/compiler-rt\n-./magenta/scripts/download-toolchain\n-\n-build_sysroot() {\n+build() {\n   local arch=\"$1\"\n \n   case \"${arch}\" in\n-    x86_64) tgt=\"magenta-pc-x86-64\" ;;\n-    aarch64) tgt=\"magenta-qemu-arm64\" ;;\n+    x86_64) tgt=\"zircon-pc-x86-64\" ;;\n+    aarch64) tgt=\"zircon-qemu-arm64\" ;;\n   esac\n \n-  hide_output make -C magenta -j$(getconf _NPROCESSORS_ONLN) $tgt\n+  hide_output make -j$(getconf _NPROCESSORS_ONLN) $tgt\n   dst=/usr/local/${arch}-unknown-fuchsia\n   mkdir -p $dst\n-  cp -r magenta/build-${tgt}/sysroot/include $dst/\n-  cp -r magenta/build-${tgt}/sysroot/lib $dst/\n-\n-  cd llvm\n-  mkdir build-runtimes-${arch}\n-  cd build-runtimes-${arch}\n-  hide_output cmake -GNinja \\\n-    -DCMAKE_C_COMPILER=clang \\\n-    -DCMAKE_CXX_COMPILER=clang++ \\\n-    -DCMAKE_AR=/usr/local/bin/llvm-ar \\\n-    -DCMAKE_RANLIB=/usr/local/bin/llvm-ranlib \\\n-    -DCMAKE_INSTALL_PREFIX= \\\n-    -DLLVM_MAIN_SRC_DIR=${PWD}/.. \\\n-    -DLLVM_BINARY_DIR=${PWD}/../build \\\n-    -DLLVM_ENABLE_WERROR=OFF \\\n-    -DCMAKE_BUILD_TYPE=Release \\\n-    -DLLVM_INCLUDE_TESTS=ON \\\n-    -DCMAKE_SYSTEM_NAME=Fuchsia \\\n-    -DCMAKE_C_COMPILER_TARGET=${arch}-fuchsia \\\n-    -DCMAKE_CXX_COMPILER_TARGET=${arch}-fuchsia \\\n-    -DUNIX=1 \\\n-    -DLIBCXX_HAS_MUSL_LIBC=ON \\\n-    -DLIBCXXABI_USE_LLVM_UNWINDER=ON \\\n-    -DCMAKE_SYSROOT=${dst} \\\n-    -DCMAKE_C_COMPILER_FORCED=TRUE \\\n-    -DCMAKE_CXX_COMPILER_FORCED=TRUE \\\n-    -DLLVM_ENABLE_LIBCXX=ON \\\n-    -DCMAKE_EXE_LINKER_FLAGS=\"-nodefaultlibs -lc\" \\\n-    -DCMAKE_SHARED_LINKER_FLAGS=\"$(clang --target=${arch}-fuchsia -print-libgcc-file-name)\" \\\n-    ../runtimes\n-  hide_output env DESTDIR=\"${dst}\" ninja install\n-  cd ../..\n+  cp -a build-${tgt}/sysroot/include $dst/\n+  cp -a build-${tgt}/sysroot/lib $dst/\n }\n \n-build_sysroot \"x86_64\"\n-build_sysroot \"aarch64\"\n+# Build sysroot\n+for arch in x86_64 aarch64; do\n+  build ${arch}\n+done\n \n-rm -rf magenta llvm\n+popd > /dev/null\n+rm -rf zircon\n \n for arch in x86_64 aarch64; do\n   for tool in clang clang++; do"}, {"sha": "0b702894bb216481125219d51de73ce4fb69cf4d", "filename": "src/ci/docker/dist-fuchsia/compiler-rt-dso-handle.patch", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fcompiler-rt-dso-handle.patch", "raw_url": "https://github.com/rust-lang/rust/raw/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fcompiler-rt-dso-handle.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2Fcompiler-rt-dso-handle.patch?ref=d9d877221f65b26e52f49bfc639ef705ff396deb", "patch": "@@ -1,41 +0,0 @@\n-diff --git a/lib/builtins/CMakeLists.txt b/lib/builtins/CMakeLists.txt\n-index fc4384af2..b442264c0 100644\n---- a/lib/builtins/CMakeLists.txt\n-+++ b/lib/builtins/CMakeLists.txt\n-@@ -194,6 +194,12 @@ if(APPLE)\n-     atomic_thread_fence.c)\n- endif()\n- \n-+if(FUCHSIA)\n-+  set(GENERIC_SOURCES\n-+    ${GENERIC_SOURCES}\n-+    dso_handle.c)\n-+endif()\n-+\n- if(NOT WIN32 OR MINGW)\n-   set(GENERIC_SOURCES\n-       ${GENERIC_SOURCES}\n-diff --git a/lib/builtins/dso_handle.c b/lib/builtins/dso_handle.c\n-new file mode 100644\n-index 000000000..7766cd0aa\n---- /dev/null\n-+++ b/lib/builtins/dso_handle.c\n-@@ -0,0 +1,18 @@\n-+/* ===-- dso_handle.c - Provide __dso_handle -------------------------------===\n-+ *\n-+ *               The LLVM Compiler Infrastructure\n-+ *\n-+ * This file is dual licensed under the MIT and the University of Illinois Open\n-+ * Source Licenses. See LICENSE.TXT for details.\n-+ *\n-+ * ===----------------------------------------------------------------------===\n-+ */\n-+\n-+/* __dso_handle symbol is mandated by C++ ABI with a value which is an address\n-+ * in one of the object's segments, and as such this symbol has to be included\n-+ * statically and cannot be a part of a shared library. Traditionally, it has\n-+ * been defined in crtbegin.o but there's no principled reason for it to be\n-+ * there. We defined this symbol in the builtin library which is built as a\n-+ * static library and always included in the final link.\n-+ */\n-+__attribute__((visibility(\"hidden\"))) void *const __dso_handle;"}, {"sha": "b2560c6b95b4ccf68f7766c61cded75c91dece55", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -36,12 +36,14 @@ elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n         echo Cannot run disabled images on travis!\n         exit 1\n     fi\n-    retry docker \\\n+    # retry messes with the pipe from tar to docker. Not needed on non-travis\n+    # Transform changes the context of disabled Dockerfiles to match the enabled ones\n+    tar --transform 's#^./disabled/#./#' -C $docker_dir -c . | docker \\\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      -f \"$docker_dir/disabled/$image/Dockerfile\" \\\n-      \"$docker_dir\"\n+      -f \"$image/Dockerfile\" \\\n+      -\n else\n     echo Invalid image: $image\n     exit 1"}, {"sha": "56f58803150ca6ca274b5b9046f771f92e1c0627", "filename": "src/doc/unstable-book/src/language-features/inclusive-range-syntax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -7,13 +7,13 @@ The tracking issue for this feature is: [#28237]\n ------------------------\n \n To get a range that goes from 0 to 10 and includes the value 10, you\n-can write `0...10`:\n+can write `0..=10`:\n \n ```rust\n #![feature(inclusive_range_syntax)]\n \n fn main() {\n-    for i in 0...10 {\n+    for i in 0..=10 {\n         println!(\"{}\", i);\n     }\n }"}, {"sha": "3b7dbd813cf05ddfd022861cb1fdeb52977f71de", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -72,13 +72,13 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n /// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n /// data, but it  doesn't add thread safety to its data. Consider\n-/// `Arc<RefCell<T>>`. `RefCell<T>` isn't [`Sync`], and if `Arc<T>` was always\n-/// [`Send`], `Arc<RefCell<T>>` would be as well. But then we'd have a problem:\n-/// `RefCell<T>` is not thread safe; it keeps track of the borrowing count using\n+/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n+/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n+/// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n /// non-atomic operations.\n ///\n /// In the end, this means that you may need to pair `Arc<T>` with some sort of\n-/// `std::sync` type, usually `Mutex<T>`.\n+/// [`std::sync`] type, usually [`Mutex<T>`][mutex].\n ///\n /// ## Breaking cycles with `Weak`\n ///\n@@ -106,7 +106,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// // a and b both point to the same memory location as foo.\n /// ```\n ///\n-/// The `Arc::clone(&from)` syntax is the most idiomatic because it conveys more explicitly\n+/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n /// the meaning of the code. In the example above, this syntax makes it easier to see that\n /// this code is creating a new reference rather than copying the whole content of foo.\n ///\n@@ -141,6 +141,9 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [upgrade]: struct.Weak.html#method.upgrade\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n+/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+/// [`std::sync`]: ../../std/sync/index.html\n+/// [`Arc::clone(&from)`]: #method.clone\n ///\n /// # Examples\n ///"}, {"sha": "d51aaa23c6a53dccf31e15464b6ef09a36842ef8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -98,6 +98,7 @@\n #![feature(generic_param_attrs)]\n #![feature(i128_type)]\n #![feature(inclusive_range)]\n+#![feature(iter_rfold)]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n #![feature(nonzero)]"}, {"sha": "2393101040d9f9d3781df9a0f396026775be4d23", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -182,7 +182,7 @@ fn test_range_small() {\n fn test_range_inclusive() {\n     let size = 500;\n \n-    let map: BTreeMap<_, _> = (0...size).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (0..=size).map(|i| (i, i)).collect();\n \n     fn check<'a, L, R>(lhs: L, rhs: R)\n         where L: IntoIterator<Item=(&'a i32, &'a i32)>,\n@@ -193,26 +193,26 @@ fn test_range_inclusive() {\n         assert_eq!(lhs, rhs);\n     }\n \n-    check(map.range(size + 1...size + 1), vec![]);\n-    check(map.range(size...size), vec![(&size, &size)]);\n-    check(map.range(size...size + 1), vec![(&size, &size)]);\n-    check(map.range(0...0), vec![(&0, &0)]);\n-    check(map.range(0...size - 1), map.range(..size));\n-    check(map.range(-1...-1), vec![]);\n-    check(map.range(-1...size), map.range(..));\n-    check(map.range(...size), map.range(..));\n-    check(map.range(...200), map.range(..201));\n-    check(map.range(5...8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n-    check(map.range(-1...0), vec![(&0, &0)]);\n-    check(map.range(-1...2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n+    check(map.range(size + 1..=size + 1), vec![]);\n+    check(map.range(size..=size), vec![(&size, &size)]);\n+    check(map.range(size..=size + 1), vec![(&size, &size)]);\n+    check(map.range(0..=0), vec![(&0, &0)]);\n+    check(map.range(0..=size - 1), map.range(..size));\n+    check(map.range(-1..=-1), vec![]);\n+    check(map.range(-1..=size), map.range(..));\n+    check(map.range(..=size), map.range(..));\n+    check(map.range(..=200), map.range(..201));\n+    check(map.range(5..=8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n+    check(map.range(-1..=0), vec![(&0, &0)]);\n+    check(map.range(-1..=2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n }\n \n #[test]\n fn test_range_inclusive_max_value() {\n     let max = ::std::usize::MAX;\n     let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n \n-    assert_eq!(map.range(max...max).collect::<Vec<_>>(), &[(&max, &0)]);\n+    assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);\n }\n \n #[test]"}, {"sha": "b3178064505e8683f0bbeacd77b01b3c36ccca89", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -361,43 +361,43 @@ fn test_slice_fail() {\n #[test]\n #[should_panic]\n fn test_str_slice_rangetoinclusive_max_panics() {\n-    &\"hello\"[...usize::max_value()];\n+    &\"hello\"[..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slice_rangeinclusive_max_panics() {\n-    &\"hello\"[1...usize::max_value()];\n+    &\"hello\"[1..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slicemut_rangetoinclusive_max_panics() {\n     let mut s = \"hello\".to_owned();\n     let s: &mut str = &mut s;\n-    &mut s[...usize::max_value()];\n+    &mut s[..=usize::max_value()];\n }\n \n #[test]\n #[should_panic]\n fn test_str_slicemut_rangeinclusive_max_panics() {\n     let mut s = \"hello\".to_owned();\n     let s: &mut str = &mut s;\n-    &mut s[1...usize::max_value()];\n+    &mut s[1..=usize::max_value()];\n }\n \n #[test]\n fn test_str_get_maxinclusive() {\n     let mut s = \"hello\".to_owned();\n     {\n         let s: &str = &s;\n-        assert_eq!(s.get(...usize::max_value()), None);\n-        assert_eq!(s.get(1...usize::max_value()), None);\n+        assert_eq!(s.get(..=usize::max_value()), None);\n+        assert_eq!(s.get(1..=usize::max_value()), None);\n     }\n     {\n         let s: &mut str = &mut s;\n-        assert_eq!(s.get(...usize::max_value()), None);\n-        assert_eq!(s.get(1...usize::max_value()), None);\n+        assert_eq!(s.get(..=usize::max_value()), None);\n+        assert_eq!(s.get(1..=usize::max_value()), None);\n     }\n }\n "}, {"sha": "ef6f5e10a72de9094dbf6cf4c31a8fcaebba8546", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -456,9 +456,9 @@ fn test_splice_char_boundary() {\n #[test]\n fn test_splice_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    v.splice(2...3, \"789\");\n+    v.splice(2..=3, \"789\");\n     assert_eq!(v, \"127895\");\n-    v.splice(1...2, \"A\");\n+    v.splice(1..=2, \"A\");\n     assert_eq!(v, \"1A895\");\n }\n \n@@ -473,7 +473,7 @@ fn test_splice_out_of_bounds() {\n #[should_panic]\n fn test_splice_inclusive_out_of_bounds() {\n     let mut s = String::from(\"12345\");\n-    s.splice(5...5, \"789\");\n+    s.splice(5..=5, \"789\");\n }\n \n #[test]"}, {"sha": "0e25da5bd3077f099034e6deaaabdba5e7adf5ac", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -537,27 +537,27 @@ fn test_drain_range() {\n #[test]\n fn test_drain_inclusive_range() {\n     let mut v = vec!['a', 'b', 'c', 'd', 'e'];\n-    for _ in v.drain(1...3) {\n+    for _ in v.drain(1..=3) {\n     }\n     assert_eq!(v, &['a', 'e']);\n \n-    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(1...5) {\n+    let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(1..=5) {\n     }\n     assert_eq!(v, &[\"0\".to_string()]);\n \n-    let mut v: Vec<String> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0...5) {\n+    let mut v: Vec<String> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0..=5) {\n     }\n     assert_eq!(v, Vec::<String>::new());\n \n-    let mut v: Vec<_> = (0...5).map(|x| x.to_string()).collect();\n-    for _ in v.drain(0...3) {\n+    let mut v: Vec<_> = (0..=5).map(|x| x.to_string()).collect();\n+    for _ in v.drain(0..=3) {\n     }\n     assert_eq!(v, &[\"4\".to_string(), \"5\".to_string()]);\n \n-    let mut v: Vec<_> = (0...1).map(|x| x.to_string()).collect();\n-    for _ in v.drain(...0) {\n+    let mut v: Vec<_> = (0..=1).map(|x| x.to_string()).collect();\n+    for _ in v.drain(..=0) {\n     }\n     assert_eq!(v, &[\"1\".to_string()]);\n }\n@@ -572,7 +572,7 @@ fn test_drain_max_vec_size() {\n \n     let mut v = Vec::<()>::with_capacity(usize::max_value());\n     unsafe { v.set_len(usize::max_value()); }\n-    for _ in v.drain(usize::max_value() - 1...usize::max_value() - 1) {\n+    for _ in v.drain(usize::max_value() - 1..=usize::max_value() - 1) {\n     }\n     assert_eq!(v.len(), usize::max_value() - 1);\n }\n@@ -581,7 +581,7 @@ fn test_drain_max_vec_size() {\n #[should_panic]\n fn test_drain_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n-    v.drain(5...5);\n+    v.drain(5..=5);\n }\n \n #[test]\n@@ -598,10 +598,10 @@ fn test_splice() {\n fn test_splice_inclusive_range() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    let t1: Vec<_> = v.splice(2...3, a.iter().cloned()).collect();\n+    let t1: Vec<_> = v.splice(2..=3, a.iter().cloned()).collect();\n     assert_eq!(v, &[1, 2, 10, 11, 12, 5]);\n     assert_eq!(t1, &[3, 4]);\n-    let t2: Vec<_> = v.splice(1...2, Some(20)).collect();\n+    let t2: Vec<_> = v.splice(1..=2, Some(20)).collect();\n     assert_eq!(v, &[1, 20, 11, 12, 5]);\n     assert_eq!(t2, &[2, 10]);\n }\n@@ -619,7 +619,7 @@ fn test_splice_out_of_bounds() {\n fn test_splice_inclusive_out_of_bounds() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    v.splice(5...5, a.iter().cloned());\n+    v.splice(5..=5, a.iter().cloned());\n }\n \n #[test]"}, {"sha": "725d3e15f4a614c52250f20a0cd06cb6e8bdf4af", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1950,7 +1950,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(u, &[1, 2]);\n     /// ```\n     #[inline]\n-    #[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+    #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n         where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n     {\n@@ -2553,13 +2553,13 @@ impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n /// [`splice()`]: struct.Vec.html#method.splice\n /// [`Vec`]: struct.Vec.html\n #[derive(Debug)]\n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {\n     drain: Drain<'a, I::Item>,\n     replace_with: I,\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     type Item = I::Item;\n \n@@ -2572,18 +2572,18 @@ impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     }\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n \n \n-#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n+#[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n impl<'a, I: Iterator> Drop for Splice<'a, I> {\n     fn drop(&mut self) {\n         // exhaust drain first"}, {"sha": "6d64e9e303f76ca74b1bd9417398b7f33446f7f0", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -558,7 +558,7 @@ impl<T> VecDeque<T> {\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n             .expect(\"capacity overflow\");\n \n-        if new_cap > self.capacity() {\n+        if new_cap > old_cap {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n             unsafe {\n                 self.handle_cap_increase(old_cap);\n@@ -1973,6 +1973,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n         self.head = wrap_index(self.head.wrapping_sub(1), self.ring.len());\n         unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = back.iter().rfold(accum, &mut f);\n+        front.iter().rfold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2058,6 +2066,14 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n             Some(&mut *(elem as *mut _))\n         }\n     }\n+\n+    fn rfold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = back.iter_mut().rfold(accum, &mut f);\n+        front.iter_mut().rfold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4042c4d2d4e02de3d31687758246ea9c7c26fea7", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -19,7 +19,7 @@ libc = { path = \"../rustc/libc_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\"\n+cc = \"1.0\"\n \n [features]\n debug = []"}, {"sha": "7dd85ddcc796595c521fd145439bb1d0afa158f6", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,7 +11,7 @@\n #![deny(warnings)]\n \n extern crate build_helper;\n-extern crate gcc;\n+extern crate cc;\n \n use std::env;\n use std::path::PathBuf;\n@@ -63,7 +63,7 @@ fn main() {\n         _ => return,\n     };\n \n-    let compiler = gcc::Build::new().get_compiler();\n+    let compiler = cc::Build::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n     let cflags = compiler.args()\n@@ -150,7 +150,7 @@ fn main() {\n     // sure the symbols are available.\n     if target.contains(\"androideabi\") {\n         println!(\"cargo:rerun-if-changed=pthread_atfork_dummy.c\");\n-        gcc::Build::new()\n+        cc::Build::new()\n             .flag(\"-fvisibility=hidden\")\n             .file(\"pthread_atfork_dummy.c\")\n             .compile(\"libpthread_atfork_dummy.a\");"}, {"sha": "1f16f5b1df3f309a62b1864708fec8ccba968746", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 121, "deletions": 30, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -147,40 +147,131 @@ fn bench_for_each_chain_ref_fold(b: &mut Bencher) {\n     });\n }\n \n-#[bench]\n-fn bench_flat_map_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .sum()\n-    });\n+\n+/// Helper to benchmark `sum` for iterators taken by value which\n+/// can optimize `fold`, and by reference which cannot.\n+macro_rules! bench_sums {\n+    ($bench_sum:ident, $bench_ref_sum:ident, $iter:expr) => {\n+        #[bench]\n+        fn $bench_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).sum()\n+            });\n+        }\n+\n+        #[bench]\n+        fn $bench_ref_sum(b: &mut Bencher) {\n+            b.iter(|| -> i64 {\n+                $iter.map(black_box).by_ref().sum()\n+            });\n+        }\n+    }\n }\n \n-#[bench]\n-fn bench_flat_map_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000).flat_map(|x| x..x+1000)\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_sum,\n+    bench_flat_map_ref_sum,\n+    (0i64..1000).flat_map(|x| x..x+1000)\n }\n \n-#[bench]\n-fn bench_flat_map_chain_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_flat_map_chain_sum,\n+    bench_flat_map_chain_ref_sum,\n+    (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n }\n \n-#[bench]\n-fn bench_flat_map_chain_ref_sum(b: &mut Bencher) {\n-    b.iter(|| -> i64 {\n-        (0i64..1000000).flat_map(|x| once(x).chain(once(x)))\n-            .map(black_box)\n-            .by_ref()\n-            .sum()\n-    });\n+bench_sums! {\n+    bench_enumerate_sum,\n+    bench_enumerate_ref_sum,\n+    (0i64..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_enumerate_chain_sum,\n+    bench_enumerate_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).enumerate().map(|(i, x)| x * i as i64)\n+}\n+\n+bench_sums! {\n+    bench_filter_sum,\n+    bench_filter_ref_sum,\n+    (0i64..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_chain_sum,\n+    bench_filter_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter(|x| x % 2 == 0)\n+}\n+\n+bench_sums! {\n+    bench_filter_map_sum,\n+    bench_filter_map_ref_sum,\n+    (0i64..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_filter_map_chain_sum,\n+    bench_filter_map_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).filter_map(|x| x.checked_mul(x))\n+}\n+\n+bench_sums! {\n+    bench_fuse_sum,\n+    bench_fuse_ref_sum,\n+    (0i64..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_fuse_chain_sum,\n+    bench_fuse_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).fuse()\n+}\n+\n+bench_sums! {\n+    bench_inspect_sum,\n+    bench_inspect_ref_sum,\n+    (0i64..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_inspect_chain_sum,\n+    bench_inspect_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).inspect(|_| {})\n+}\n+\n+bench_sums! {\n+    bench_peekable_sum,\n+    bench_peekable_ref_sum,\n+    (0i64..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_peekable_chain_sum,\n+    bench_peekable_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).peekable()\n+}\n+\n+bench_sums! {\n+    bench_skip_sum,\n+    bench_skip_ref_sum,\n+    (0i64..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_chain_sum,\n+    bench_skip_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip(1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_sum,\n+    bench_skip_while_ref_sum,\n+    (0i64..1000000).skip_while(|&x| x < 1000)\n+}\n+\n+bench_sums! {\n+    bench_skip_while_chain_sum,\n+    bench_skip_while_chain_ref_sum,\n+    (0i64..1000000).chain(0..1000000).skip_while(|&x| x < 1000)\n }"}, {"sha": "e012cbd76ff91009a9602f8bdb74f6db614a759f", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -456,7 +456,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(2, 1.max(2));\n     /// assert_eq!(2, 2.max(2));\n     /// ```\n-    #[stable(feature = \"ord_max_min\", since = \"1.22.0\")]\n+    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     fn max(self, other: Self) -> Self\n     where Self: Sized {\n         if other >= self { other } else { self }\n@@ -472,7 +472,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     /// assert_eq!(1, 1.min(2));\n     /// assert_eq!(2, 2.min(2));\n     /// ```\n-    #[stable(feature = \"ord_max_min\", since = \"1.22.0\")]\n+    #[stable(feature = \"ord_max_min\", since = \"1.21.0\")]\n     fn min(self, other: Self) -> Self\n     where Self: Sized {\n         if self <= other { self } else { other }"}, {"sha": "e815d72d366466e79d3b3507c36585afeca5cb28", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -48,8 +48,25 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use str::FromStr;\n+use fmt;\n \n+/// A type used as the error type for implementations of fallible conversion\n+/// traits in cases where conversions cannot actually fail.\n+///\n+/// Because `Infallible` has no variants, a value of this type can never exist.\n+/// It is used only to satisfy trait signatures that expect an error type, and\n+/// signals to both the compiler and the user that the error case is impossible.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub enum Infallible {}\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl fmt::Display for Infallible {\n+    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+        }\n+    }\n+}\n /// A cheap reference-to-reference conversion. Used to convert a value to a\n /// reference value within generic code.\n ///\n@@ -417,6 +434,17 @@ impl<T, U> TryInto<U> for T where U: TryFrom<T>\n     }\n }\n \n+// Infallible conversions are semantically equivalent to fallible conversions\n+// with an uninhabited error type.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl<T, U> TryFrom<U> for T where T: From<U> {\n+    type Error = Infallible;\n+\n+    fn try_from(value: U) -> Result<Self, Self::Error> {\n+        Ok(T::from(value))\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n@@ -442,14 +470,3 @@ impl AsRef<str> for str {\n         self\n     }\n }\n-\n-// FromStr implies TryFrom<&str>\n-#[unstable(feature = \"try_from\", issue = \"33417\")]\n-impl<'a, T> TryFrom<&'a str> for T where T: FromStr\n-{\n-    type Error = <T as FromStr>::Err;\n-\n-    fn try_from(s: &'a str) -> Result<T, Self::Error> {\n-        FromStr::from_str(s)\n-    }\n-}"}, {"sha": "6c251b9eb09249e662752f3017ec039d23ca3f2f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -488,13 +488,14 @@ impl<'a> Display for Arguments<'a> {\n /// The origin is: Point { x: 0, y: 0 }\n /// ```\n ///\n-/// There are a number of `debug_*` methods on `Formatter` to help you with manual\n+/// There are a number of `debug_*` methods on [`Formatter`] to help you with manual\n /// implementations, such as [`debug_struct`][debug_struct].\n ///\n /// `Debug` implementations using either `derive` or the debug builder API\n-/// on `Formatter` support pretty printing using the alternate flag: `{:#?}`.\n+/// on [`Formatter`] support pretty printing using the alternate flag: `{:#?}`.\n ///\n /// [debug_struct]: ../../std/fmt/struct.Formatter.html#method.debug_struct\n+/// [`Formatter`]: ../../std/fmt/struct.Formatter.html\n ///\n /// Pretty printing with `#?`:\n ///\n@@ -1321,8 +1322,11 @@ impl<'a> Formatter<'a> {\n         self.flags & (1 << FlagV1::SignAwareZeroPad as u32) != 0\n     }\n \n-    /// Creates a `DebugStruct` builder designed to assist with creation of\n-    /// `fmt::Debug` implementations for structs.\n+    /// Creates a [`DebugStruct`] builder designed to assist with creation of\n+    /// [`fmt::Debug`] implementations for structs.\n+    ///\n+    /// [`DebugStruct`]: ../../std/fmt/struct.DebugStruct.html\n+    /// [`fmt::Debug`]: ../../std/fmt/trait.Debug.html\n     ///\n     /// # Examples\n     ///\n@@ -1700,8 +1704,18 @@ impl<T: ?Sized + Debug> Debug for RefCell<T> {\n                     .finish()\n             }\n             Err(_) => {\n+                // The RefCell is mutably borrowed so we can't look at its value\n+                // here. Show a placeholder instead.\n+                struct BorrowedPlaceholder;\n+\n+                impl Debug for BorrowedPlaceholder {\n+                    fn fmt(&self, f: &mut Formatter) -> Result {\n+                        f.write_str(\"<borrowed>\")\n+                    }\n+                }\n+\n                 f.debug_struct(\"RefCell\")\n-                    .field(\"value\", &\"<borrowed>\")\n+                    .field(\"value\", &BorrowedPlaceholder)\n                     .finish()\n             }\n         }"}, {"sha": "cb215a38e5356247808236b1286732338a53ebc9", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -68,3 +68,22 @@ macro_rules! forward_ref_binop {\n         }\n     }\n }\n+\n+// implements \"T op= &U\", based on \"T op= U\"\n+// where U is expected to be `Copy`able\n+macro_rules! forward_ref_op_assign {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_op_assign!(impl $imp, $method for $t, $u,\n+                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n+    };\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n+        #[$attr]\n+        impl<'a> $imp<&'a $u> for $t {\n+            #[inline]\n+            fn $method(&mut self, other: &'a $u) {\n+                $imp::$method(self, *other);\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "e9e31065cf876f14d52dbef947467e687ae36143", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -518,7 +518,7 @@ pub trait Iterator {\n     ///       .for_each(|(i, x)| println!(\"{}:{}\", i, x));\n     /// ```\n     #[inline]\n-    #[stable(feature = \"iterator_for_each\", since = \"1.22.0\")]\n+    #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n     fn for_each<F>(self, mut f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n@@ -1337,7 +1337,7 @@ pub trait Iterator {\n         (left, right)\n     }\n \n-    /// An iterator adaptor that applies a function, producing a single, final value.\n+    /// An iterator method that applies a function, producing a single, final value.\n     ///\n     /// `fold()` takes two arguments: an initial value, and a closure with two\n     /// arguments: an 'accumulator', and an element. The closure returns the value that"}, {"sha": "8d2521b053eb5c5e129f2b019f37797bfe0bc934", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 231, "deletions": 2, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -359,6 +359,12 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n \n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n     #[inline]\n     fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n         where P: FnMut(&Self::Item) -> bool\n@@ -379,6 +385,12 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n \n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n         where P: FnMut(&Self::Item) -> bool\n     {\n@@ -449,6 +461,12 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n     fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n     }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n }\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n@@ -470,7 +488,7 @@ impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n {}\n \n #[doc(hidden)]\n-unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+default unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n     where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n@@ -481,6 +499,18 @@ unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n     fn may_have_side_effect() -> bool { true }\n }\n \n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Copy\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        *self.it.get_unchecked(i)\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n     where I: TrustedLen<Item=&'a T>,\n@@ -528,7 +558,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n \n-/// An adapter for stepping iterators by a custom amount.\n+/// An iterator for stepping iterators by a custom amount.\n ///\n /// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n /// its documentation for more.\n@@ -761,6 +791,26 @@ impl<A, B> DoubleEndedIterator for Chain<A, B> where\n             ChainState::Back => self.b.next_back(),\n         }\n     }\n+\n+    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.rfold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n@@ -1094,6 +1144,13 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n     fn next_back(&mut self) -> Option<B> {\n         self.iter.next_back().map(&mut self.f)\n     }\n+\n+    fn rfold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1193,6 +1250,18 @@ impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool\n         }\n         count\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.fold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1208,6 +1277,18 @@ impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut predicate = self.predicate;\n+        self.iter.rfold(init, move |acc, item| if predicate(&item) {\n+            fold(acc, item)\n+        } else {\n+            acc\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1259,6 +1340,17 @@ impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1274,6 +1366,17 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| match f(item) {\n+            Some(x) => fold(acc, x),\n+            None => acc,\n+        })\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1338,6 +1441,19 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     fn count(self) -> usize {\n         self.iter.count()\n     }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut count = self.count;\n+        self.iter.fold(init, move |acc, item| {\n+            let acc = fold(acc, (count, item));\n+            count += 1;\n+            acc\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1353,6 +1469,19 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n             (self.count + len, a)\n         })\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        let mut count = self.count + self.iter.len();\n+        self.iter.rfold(init, move |acc, item| {\n+            count -= 1;\n+            fold(acc, (count, item))\n+        })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1464,6 +1593,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         let hi = hi.and_then(|x| x.checked_add(peek_len));\n         (lo, hi)\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1572,6 +1713,19 @@ impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n         let (_, upper) = self.iter.size_hint();\n         (0, upper) // can't know a lower bound, due to the predicate\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1712,6 +1866,19 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n \n         (lower, upper)\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1934,6 +2101,16 @@ impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F> wher\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(self.f).map(U::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -2011,6 +2188,17 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n             self.iter.size_hint()\n         }\n     }\n+\n+    #[inline]\n+    default fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.fold(init, fold)\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2025,6 +2213,17 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n             next\n         }\n     }\n+\n+    #[inline]\n+    default fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.done {\n+            init\n+        } else {\n+            self.iter.rfold(init, fold)\n+        }\n+    }\n }\n \n unsafe impl<I> TrustedRandomAccess for Fuse<I>\n@@ -2065,6 +2264,13 @@ impl<I> Iterator for Fuse<I> where I: FusedIterator {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, fold)\n+    }\n }\n \n #[unstable(feature = \"fused\", reason = \"recently added\", issue = \"35602\")]\n@@ -2075,6 +2281,13 @@ impl<I> DoubleEndedIterator for Fuse<I>\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n         self.iter.next_back()\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, fold)\n+    }\n }\n \n \n@@ -2139,6 +2352,14 @@ impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2150,6 +2371,14 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.rfold(init, move |acc, item| { f(&item); fold(acc, item) })\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e9aee4a4676de47fda7282106908e79d3d80b430", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -89,6 +89,7 @@ macro_rules! step_impl_unsigned {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$t>::try_from(n) {\n                     Ok(n_as_t) => self.checked_add(n_as_t),\n@@ -120,6 +121,7 @@ macro_rules! step_impl_signed {\n             }\n \n             #[inline]\n+            #[allow(unreachable_patterns)]\n             fn add_usize(&self, n: usize) -> Option<Self> {\n                 match <$unsigned>::try_from(n) {\n                     Ok(n_as_unsigned) => {"}, {"sha": "28236d193c324df5571bc696ff3625656eec2819", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -415,6 +415,70 @@ pub trait DoubleEndedIterator: Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n \n+    /// An iterator method that reduces the iterator's elements to a single,\n+    /// final value, starting from the back.\n+    ///\n+    /// This is the reverse version of [`fold()`]: it takes elements starting from\n+    /// the back of the iterator.\n+    ///\n+    /// `rfold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. The closure returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `rfold()`\n+    /// returns the accumulator.\n+    ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// [`fold()`]: trait.Iterator.html#method.fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_rfold)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .rfold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// This example builds a string, starting with an initial value\n+    /// and continuing with each element from the back until the front:\n+    ///\n+    /// ```\n+    /// #![feature(iter_rfold)]\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let zero = \"0\".to_string();\n+    ///\n+    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n+    ///     format!(\"({} + {})\", x, acc)\n+    /// });\n+    ///\n+    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_rfold\", issue = \"44705\")]\n+    fn rfold<B, F>(mut self, mut accum: B, mut f: F) -> B where\n+        Self: Sized, F: FnMut(B, Self::Item) -> B,\n+    {\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x);\n+        }\n+        accum\n+    }\n+\n     /// Searches for an element of an iterator from the right that satisfies a predicate.\n     ///\n     /// `rfind()` takes a closure that returns `true` or `false`. It applies"}, {"sha": "f56a9a40332987c804e829fa35d362416c241a53", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -122,7 +122,7 @@ pub trait Sized {\n /// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n-#[lang=\"unsize\"]\n+#[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }"}, {"sha": "c869054cee81abdfb31db0c70fbea540e57645e9", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -177,15 +177,59 @@ pub fn forget<T>(t: T) {\n \n /// Returns the size of a type in bytes.\n ///\n-/// More specifically, this is the offset in bytes between successive\n-/// items of the same type, including alignment padding.\n+/// More specifically, this is the offset in bytes between successive elements\n+/// in an array with that item type including alignment padding. Thus, for any\n+/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n+///\n+/// In general, the size of a type is not stable across compilations, but\n+/// specific types such as primitives are.\n+///\n+/// The following table gives the size for primitives.\n+///\n+/// Type | size_of::\\<Type>()\n+/// ---- | ---------------\n+/// () | 0\n+/// u8 | 1\n+/// u16 | 2\n+/// u32 | 4\n+/// u64 | 8\n+/// i8 | 1\n+/// i16 | 2\n+/// i32 | 4\n+/// i64 | 8\n+/// f32 | 4\n+/// f64 | 8\n+/// char | 4\n+///\n+/// Furthermore, `usize` and `isize` have the same size.\n+///\n+/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n+/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n+///\n+/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n+/// have the same size. Likewise for `*const T` and `*mut T`.\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n+/// // Some primitives\n /// assert_eq!(4, mem::size_of::<i32>());\n+/// assert_eq!(8, mem::size_of::<f64>());\n+/// assert_eq!(0, mem::size_of::<()>());\n+///\n+/// // Some arrays\n+/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n+/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n+/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n+///\n+///\n+/// // Pointer size equality\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n+/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -358,7 +402,7 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n /// }\n /// ```\n #[inline]\n-#[stable(feature = \"needs_drop\", since = \"1.22.0\")]\n+#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n pub fn needs_drop<T>() -> bool {\n     unsafe { intrinsics::needs_drop::<T>() }\n }"}, {"sha": "85be8a08728e519fca43789b6eb7fb94986087aa", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -12,7 +12,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use convert::TryFrom;\n+use convert::{Infallible, TryFrom};\n use fmt;\n use intrinsics;\n use str::FromStr;\n@@ -2507,16 +2507,24 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl From<Infallible> for TryFromIntError {\n+    fn from(infallible: Infallible) -> TryFromIntError {\n+        match infallible {\n+        }\n+    }\n+}\n+\n // no possible bounds violation\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n-            type Error = TryFromIntError;\n+            type Error = Infallible;\n \n             #[inline]\n-            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n-                Ok(u as $target)\n+            fn try_from(value: $source) -> Result<Self, Self::Error> {\n+                Ok(value as $target)\n             }\n         }\n     )*}\n@@ -2588,31 +2596,17 @@ macro_rules! rev {\n }\n \n /// intra-sign conversions\n-try_from_unbounded!(u8, u8, u16, u32, u64, u128);\n-try_from_unbounded!(u16, u16, u32, u64, u128);\n-try_from_unbounded!(u32, u32, u64, u128);\n-try_from_unbounded!(u64, u64, u128);\n-try_from_unbounded!(u128, u128);\n try_from_upper_bounded!(u16, u8);\n try_from_upper_bounded!(u32, u16, u8);\n try_from_upper_bounded!(u64, u32, u16, u8);\n try_from_upper_bounded!(u128, u64, u32, u16, u8);\n \n-try_from_unbounded!(i8, i8, i16, i32, i64, i128);\n-try_from_unbounded!(i16, i16, i32, i64, i128);\n-try_from_unbounded!(i32, i32, i64, i128);\n-try_from_unbounded!(i64, i64, i128);\n-try_from_unbounded!(i128, i128);\n try_from_both_bounded!(i16, i8);\n try_from_both_bounded!(i32, i16, i8);\n try_from_both_bounded!(i64, i32, i16, i8);\n try_from_both_bounded!(i128, i64, i32, i16, i8);\n \n // unsigned-to-signed\n-try_from_unbounded!(u8, i16, i32, i64, i128);\n-try_from_unbounded!(u16, i32, i64, i128);\n-try_from_unbounded!(u32, i64, i128);\n-try_from_unbounded!(u64, i128);\n try_from_upper_bounded!(u8, i8);\n try_from_upper_bounded!(u16, i8, i16);\n try_from_upper_bounded!(u32, i8, i16, i32);\n@@ -2631,15 +2625,13 @@ try_from_both_bounded!(i64, u32, u16, u8);\n try_from_both_bounded!(i128, u64, u32, u16, u8);\n \n // usize/isize\n-try_from_unbounded!(usize, usize);\n try_from_upper_bounded!(usize, isize);\n try_from_lower_bounded!(isize, usize);\n-try_from_unbounded!(isize, isize);\n \n #[cfg(target_pointer_width = \"16\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8);\n     try_from_unbounded!(usize, u16, u32, u64, u128);\n@@ -2651,21 +2643,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8);\n     try_from_unbounded!(isize, i16, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16);\n+    rev!(try_from_unbounded, usize, u16);\n     rev!(try_from_upper_bounded, usize, u32, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16);\n     rev!(try_from_both_bounded, usize, i32, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8);\n     rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16);\n+    rev!(try_from_unbounded, isize, i16);\n     rev!(try_from_both_bounded, isize, i32, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"32\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16);\n     try_from_unbounded!(usize, u32, u64, u128);\n@@ -2677,21 +2669,21 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16);\n     try_from_unbounded!(isize, i32, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32);\n+    rev!(try_from_unbounded, usize, u16, u32);\n     rev!(try_from_upper_bounded, usize, u64, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n     rev!(try_from_both_bounded, usize, i64, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16);\n     rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32);\n+    rev!(try_from_unbounded, isize, i16, i32);\n     rev!(try_from_both_bounded, isize, i64, i128);\n }\n \n #[cfg(target_pointer_width = \"64\")]\n mod ptr_try_from_impls {\n     use super::TryFromIntError;\n-    use convert::TryFrom;\n+    use convert::{Infallible, TryFrom};\n \n     try_from_upper_bounded!(usize, u8, u16, u32);\n     try_from_unbounded!(usize, u64, u128);\n@@ -2703,14 +2695,14 @@ mod ptr_try_from_impls {\n     try_from_both_bounded!(isize, i8, i16, i32);\n     try_from_unbounded!(isize, i64, i128);\n \n-    rev!(try_from_unbounded, usize, u8, u16, u32, u64);\n+    rev!(try_from_unbounded, usize, u16, u32, u64);\n     rev!(try_from_upper_bounded, usize, u128);\n     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n     rev!(try_from_both_bounded, usize, i128);\n \n     rev!(try_from_unbounded, isize, u8, u16, u32);\n     rev!(try_from_upper_bounded, isize, u64, u128);\n-    rev!(try_from_unbounded, isize, i8, i16, i32, i64);\n+    rev!(try_from_unbounded, isize, i16, i32, i64);\n     rev!(try_from_both_bounded, isize, i128);\n }\n "}, {"sha": "ae1b0b3ce11b209cfff581408724b3a05a4c864f", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -36,6 +36,7 @@ macro_rules! sh_impl_signed {\n                 *self = *self << other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for Wrapping<$t> {\n@@ -58,6 +59,7 @@ macro_rules! sh_impl_signed {\n                 *self = *self >> other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     )\n }\n \n@@ -80,6 +82,7 @@ macro_rules! sh_impl_unsigned {\n                 *self = *self << other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Shr<$f> for Wrapping<$t> {\n@@ -98,6 +101,7 @@ macro_rules! sh_impl_unsigned {\n                 *self = *self >> other;\n             }\n         }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     )\n }\n \n@@ -142,6 +146,7 @@ macro_rules! wrapping_impl {\n                 *self = *self + other;\n             }\n         }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Sub for Wrapping<$t> {\n@@ -162,6 +167,7 @@ macro_rules! wrapping_impl {\n                 *self = *self - other;\n             }\n         }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Mul for Wrapping<$t> {\n@@ -182,6 +188,7 @@ macro_rules! wrapping_impl {\n                 *self = *self * other;\n             }\n         }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n         impl Div for Wrapping<$t> {\n@@ -202,6 +209,7 @@ macro_rules! wrapping_impl {\n                 *self = *self / other;\n             }\n         }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n         impl Rem for Wrapping<$t> {\n@@ -222,6 +230,7 @@ macro_rules! wrapping_impl {\n                 *self = *self % other;\n             }\n         }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Not for Wrapping<$t> {\n@@ -254,6 +263,7 @@ macro_rules! wrapping_impl {\n                 *self = *self ^ other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitOr for Wrapping<$t> {\n@@ -274,6 +284,7 @@ macro_rules! wrapping_impl {\n                 *self = *self | other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl BitAnd for Wrapping<$t> {\n@@ -294,6 +305,7 @@ macro_rules! wrapping_impl {\n                 *self = *self & other;\n             }\n         }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n         impl Neg for Wrapping<$t> {"}, {"sha": "8b3d662a6db774382bd9b14e7591ed55bffca87e", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -662,6 +662,8 @@ macro_rules! add_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn add_assign(&mut self, other: $t) { *self += other }\n         }\n+\n+        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n     )+)\n }\n \n@@ -713,6 +715,8 @@ macro_rules! sub_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn sub_assign(&mut self, other: $t) { *self -= other }\n         }\n+\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n     )+)\n }\n \n@@ -755,6 +759,8 @@ macro_rules! mul_assign_impl {\n             #[rustc_inherit_overflow_checks]\n             fn mul_assign(&mut self, other: $t) { *self *= other }\n         }\n+\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n     )+)\n }\n \n@@ -796,6 +802,8 @@ macro_rules! div_assign_impl {\n             #[inline]\n             fn div_assign(&mut self, other: $t) { *self /= other }\n         }\n+\n+        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n     )+)\n }\n \n@@ -841,6 +849,8 @@ macro_rules! rem_assign_impl {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) { *self %= other }\n         }\n+\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n     )+)\n }\n "}, {"sha": "7ac5fc4debf1489150e9f1d4e151e1c60231edc0", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -593,6 +593,8 @@ macro_rules! bitand_assign_impl {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) { *self &= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n     )+)\n }\n \n@@ -638,6 +640,8 @@ macro_rules! bitor_assign_impl {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) { *self |= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n     )+)\n }\n \n@@ -683,6 +687,8 @@ macro_rules! bitxor_assign_impl {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n         }\n+\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n     )+)\n }\n \n@@ -729,6 +735,8 @@ macro_rules! shl_assign_impl {\n                 *self <<= other\n             }\n         }\n+\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n     )\n }\n \n@@ -793,6 +801,8 @@ macro_rules! shr_assign_impl {\n                 *self >>= other\n             }\n         }\n+\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n     )\n }\n "}, {"sha": "3f573f7c7eb69b73ef38eb69c31e463d3988682d", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -241,22 +241,22 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     }\n }\n \n-/// An range bounded inclusively below and above (`start...end`).\n+/// An range bounded inclusively below and above (`start..=end`).\n ///\n-/// The `RangeInclusive` `start...end` contains all values with `x >= start`\n+/// The `RangeInclusive` `start..=end` contains all values with `x >= start`\n /// and `x <= end`.\n ///\n /// # Examples\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n ///\n-/// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n-/// assert_eq!(3 + 4 + 5, (3...5).sum());\n+/// assert_eq!((3..=5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3..=5).sum());\n ///\n /// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ...2], [0,1,2  ]);\n-/// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// assert_eq!(arr[ ..=2], [0,1,2  ]);\n+/// assert_eq!(arr[1..=2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -276,7 +276,7 @@ pub struct RangeInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n+        write!(fmt, \"{:?}..={:?}\", self.start, self.end)\n     }\n }\n \n@@ -289,32 +289,32 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// assert!(!(3...5).contains(2));\n-    /// assert!( (3...5).contains(3));\n-    /// assert!( (3...5).contains(4));\n-    /// assert!( (3...5).contains(5));\n-    /// assert!(!(3...5).contains(6));\n+    /// assert!(!(3..=5).contains(2));\n+    /// assert!( (3..=5).contains(3));\n+    /// assert!( (3..=5).contains(4));\n+    /// assert!( (3..=5).contains(5));\n+    /// assert!(!(3..=5).contains(6));\n     ///\n-    /// assert!( (3...3).contains(3));\n-    /// assert!(!(3...2).contains(3));\n+    /// assert!( (3..=3).contains(3));\n+    /// assert!(!(3..=2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n }\n \n-/// A range only bounded inclusively above (`...end`).\n+/// A range only bounded inclusively above (`..=end`).\n ///\n-/// The `RangeToInclusive` `...end` contains all values with `x <= end`.\n+/// The `RangeToInclusive` `..=end` contains all values with `x <= end`.\n /// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `...end` syntax is a `RangeToInclusive`:\n+/// The `..=end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// assert_eq!((..=5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n /// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n@@ -325,7 +325,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n ///\n /// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n /// // std::iter::Iterator` is not satisfied\n-/// for i in ...5 {\n+/// for i in ..=5 {\n ///     // ...\n /// }\n /// ```\n@@ -337,8 +337,8 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// #![feature(inclusive_range_syntax)]\n ///\n /// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// assert_eq!(arr[ ..=2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1..=2], [  1,2  ]);\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -357,7 +357,7 @@ pub struct RangeToInclusive<Idx> {\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"...{:?}\", self.end)\n+        write!(fmt, \"..={:?}\", self.end)\n     }\n }\n \n@@ -370,9 +370,9 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// assert!( (...5).contains(-1_000_000_000));\n-    /// assert!( (...5).contains(5));\n-    /// assert!(!(...5).contains(6));\n+    /// assert!( (..=5).contains(-1_000_000_000));\n+    /// assert!( (..=5).contains(5));\n+    /// assert!(!(..=5).contains(6));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}, {"sha": "cd896859b16bc7eb703de393279305f37d8529b5", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -42,7 +42,7 @@ use marker::Unsize;\n /// [unsize]: ../marker/trait.Unsize.html\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-#[lang=\"coerce_unsized\"]\n+#[lang = \"coerce_unsized\"]\n pub trait CoerceUnsized<T> {\n     // Empty.\n }"}, {"sha": "980ea551f0806a888ce834bcbfbf3b196fffffd6", "filename": "src/libcore/option.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -146,7 +146,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use iter::{FromIterator, FusedIterator, TrustedLen};\n-use mem;\n+use {mem, ops};\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -1123,3 +1123,29 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n         }\n     }\n }\n+\n+/// The error type that results from applying the try operator (`?`) to a `None` value. If you wish\n+/// to allow `x?` (where `x` is an `Option<T>`) to be converted into your error type, you can\n+/// implement `impl From<NoneError>` for `YourErrorType`. In that case, `x?` within a function that\n+/// returns `Result<_, YourErrorType>` will translate a `None` value into an `Err` result.\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+pub struct NoneError;\n+\n+#[unstable(feature = \"try_trait\", issue = \"42327\")]\n+impl<T> ops::Try for Option<T> {\n+    type Ok = T;\n+    type Error = NoneError;\n+\n+    fn into_result(self) -> Result<T, NoneError> {\n+        self.ok_or(NoneError)\n+    }\n+\n+    fn from_ok(v: T) -> Self {\n+        Some(v)\n+    }\n+\n+    fn from_error(_: NoneError) -> Self {\n+        None\n+    }\n+}"}, {"sha": "34d310446536d19c41317681feebfa99d87be15b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -56,7 +56,7 @@ pub use intrinsics::write_bytes;\n /// This has all the same safety problems as `ptr::read` with respect to\n /// invalid pointers, types, and double drops.\n #[stable(feature = \"drop_in_place\", since = \"1.8.0\")]\n-#[lang=\"drop_in_place\"]\n+#[lang = \"drop_in_place\"]\n #[allow(unconditional_recursion)]\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     // Code here does not matter - this is replaced by the"}, {"sha": "ae243f3f246a5833c3a2c65c0ef84233d88b0bbf", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -16,6 +16,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+// FIXME: after next stage0, change RangeInclusive { ... } back to ..=\n+use ops::RangeInclusive;\n+\n // How this module is organized.\n //\n // The library infrastructure for slices is fairly messy. There's\n@@ -1044,32 +1047,32 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        (0...self.end).get(slice)\n+        (RangeInclusive { start: 0, end: self.end }).get(slice)\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        (0...self.end).get_mut(slice)\n+        (RangeInclusive { start: 0, end: self.end }).get_mut(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0...self.end).get_unchecked(slice)\n+        (RangeInclusive { start: 0, end: self.end }).get_unchecked(slice)\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).get_unchecked_mut(slice)\n+        (RangeInclusive { start: 0, end: self.end }).get_unchecked_mut(slice)\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n-        (0...self.end).index(slice)\n+        (RangeInclusive { start: 0, end: self.end }).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0...self.end).index_mut(slice)\n+        (RangeInclusive { start: 0, end: self.end }).index_mut(slice)\n     }\n }\n "}, {"sha": "0af9fcf0a3d3bcaecff2efa11661721fb77a75c3", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,9 +18,9 @@ use self::pattern::Pattern;\n use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n-use convert::TryFrom;\n use fmt;\n-use iter::{Map, Cloned, FusedIterator};\n+use iter::{Map, Cloned, FusedIterator, TrustedLen};\n+use iter_private::TrustedRandomAccess;\n use slice::{self, SliceIndex};\n use mem;\n \n@@ -818,6 +818,17 @@ impl<'a> ExactSizeIterator for Bytes<'a> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Bytes<'a> {}\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a> TrustedLen for Bytes<'a> {}\n+\n+#[doc(hidden)]\n+unsafe impl<'a> TrustedRandomAccess for Bytes<'a> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> u8 {\n+        self.0.get_unchecked(i)\n+    }\n+    fn may_have_side_effect() -> bool { false }\n+}\n+\n /// This macro generates a Clone impl for string pattern API\n /// wrapper types of the form X<'a, P>\n macro_rules! derive_pattern_clone {\n@@ -1399,9 +1410,6 @@ Section: Comparing strings\n */\n \n /// Bytewise slice equality\n-/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n-/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n     a.as_bytes() == b.as_bytes()\n@@ -2189,7 +2197,7 @@ pub trait StrExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_empty(&self) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn parse<'a, T: TryFrom<&'a str>>(&'a self) -> Result<T, T::Error>;\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n // truncate `&str` to length at most equal to `max`\n@@ -2509,9 +2517,7 @@ impl StrExt for str {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n \n     #[inline]\n-    fn parse<'a, T>(&'a self) -> Result<T, T::Error> where T: TryFrom<&'a str> {\n-        T::try_from(self)\n-    }\n+    fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "465d31b5f493da413c793293f68a15d35a234664", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -926,10 +926,24 @@ macro_rules! atomic_int {\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n+     $s_int_type:expr, $int_ref:expr,\n      $int_type:ident $atomic_type:ident $atomic_init:ident) => {\n         /// An integer type which can be safely shared between threads.\n         ///\n-        /// This type has the same in-memory representation as the underlying integer type.\n+        /// This type has the same in-memory representation as the underlying\n+        /// integer type, [`\n+        #[doc = $s_int_type]\n+        /// `](\n+        #[doc = $int_ref]\n+        /// ). For more about the differences between atomic types and\n+        /// non-atomic types, please see the [module-level documentation].\n+        ///\n+        /// Please note that examples are shared between atomic variants of\n+        /// primitive integer types, so it's normal that they are all\n+        /// demonstrating [`AtomicIsize`].\n+        ///\n+        /// [module-level documentation]: index.html\n+        /// [`AtomicIsize`]: struct.AtomicIsize.html\n         #[$stable]\n         pub struct $atomic_type {\n             v: UnsafeCell<$int_type>,\n@@ -1339,6 +1353,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i8\", \"../../../std/primitive.i8.html\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n #[cfg(target_has_atomic = \"8\")]\n@@ -1348,6 +1363,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u8\", \"../../../std/primitive.u8.html\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1357,6 +1373,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i16\", \"../../../std/primitive.i16.html\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n #[cfg(target_has_atomic = \"16\")]\n@@ -1366,6 +1383,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u16\", \"../../../std/primitive.u16.html\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1375,6 +1393,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i32\", \"../../../std/primitive.i32.html\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n #[cfg(target_has_atomic = \"32\")]\n@@ -1384,6 +1403,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u32\", \"../../../std/primitive.u32.html\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1393,6 +1413,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"i64\", \"../../../std/primitive.i64.html\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n #[cfg(target_has_atomic = \"64\")]\n@@ -1402,6 +1423,7 @@ atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+    \"u64\", \"../../../std/primitive.u64.html\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1411,6 +1433,7 @@ atomic_int!{\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+    \"isize\", \"../../../std/primitive.isize.html\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n #[cfg(target_has_atomic = \"ptr\")]\n@@ -1420,6 +1443,7 @@ atomic_int!{\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n+    \"usize\", \"../../../std/primitive.usize.html\",\n     usize AtomicUsize ATOMIC_USIZE_INIT\n }\n \n@@ -1752,7 +1776,7 @@ pub fn fence(order: Ordering) {\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n /// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n #[inline]\n-#[stable(feature = \"compiler_fences\", since = \"1.22.0\")]\n+#[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n     unsafe {\n         match order {"}, {"sha": "4e10ceac878b6a4c5669d49a2b7fd9838efb4ca8", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -32,7 +32,6 @@ fn test_convert() {\n #[test]\n fn test_from_str() {\n     assert_eq!(char::from_str(\"a\").unwrap(), 'a');\n-    assert_eq!(char::try_from(\"a\").unwrap(), 'a');\n     assert_eq!(char::from_str(\"\\0\").unwrap(), '\\0');\n     assert_eq!(char::from_str(\"\\u{D7FF}\").unwrap(), '\\u{d7FF}');\n     assert!(char::from_str(\"\").is_err());"}, {"sha": "f8c6fc5c8fa4205b6c6fd5a3c1838b45b1d1fbfb", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 193, "deletions": 19, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -248,6 +248,25 @@ fn test_filter_map() {\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n+#[test]\n+fn test_filter_map_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0*0, 2*2, 4*4, 6*6, 8*8];\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter_map(|&x| if x % 2 == 0 { Some(x*x) } else { None });\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_enumerate() {\n     let xs = [0, 1, 2, 3, 4, 5];\n@@ -282,7 +301,31 @@ fn test_iterator_enumerate_nth() {\n #[test]\n fn test_iterator_enumerate_count() {\n     let xs = [0, 1, 2, 3, 4, 5];\n-    assert_eq!(xs.iter().count(), 6);\n+    assert_eq!(xs.iter().enumerate().count(), 6);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    // steal a couple to get an interesting offset\n+    assert_eq!(it.next(), Some((0, &0)));\n+    assert_eq!(it.next(), Some((1, &1)));\n+    let i = it.fold(2, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let mut it = xs.iter().enumerate();\n+    assert_eq!(it.next(), Some((0, &0)));\n+    let i = it.rfold(xs.len() - 1, |i, (j, &x)| {\n+        assert_eq!(i, j);\n+        assert_eq!(x, xs[j]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -291,6 +334,25 @@ fn test_iterator_filter_count() {\n     assert_eq!(xs.iter().filter(|&&x| x % 2 == 0).count(), 5);\n }\n \n+#[test]\n+fn test_iterator_filter_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let ys = [0, 2, 4, 6, 8];\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let it = xs.iter().filter(|&&x| x % 2 == 0);\n+    let i = it.rfold(ys.len(), |i, &x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n@@ -381,6 +443,18 @@ fn test_iterator_peekable_last() {\n     assert_eq!(it.last(), None);\n }\n \n+#[test]\n+fn test_iterator_peekable_fold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -470,6 +544,26 @@ fn test_iterator_skip_while() {\n     assert_eq!(i, ys.len());\n }\n \n+#[test]\n+fn test_iterator_skip_while_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let it = xs.iter().skip_while(|&x| *x < 15);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip_while(|&x| *x < 15);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+\n #[test]\n fn test_iterator_skip() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n@@ -566,6 +660,26 @@ fn test_iterator_skip_last() {\n     assert_eq!(it.last(), Some(&30));\n }\n \n+#[test]\n+fn test_iterator_skip_fold() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+    let it = xs.iter().skip(5);\n+    let i = it.fold(0, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&ys[0])); // process skips before folding\n+    let i = it.fold(1, |i, &x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+}\n+\n #[test]\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -661,13 +775,22 @@ fn test_iterator_flat_map_fold() {\n     let xs = [0, 3, 6];\n     let ys = [1, 2, 3, 4, 5, 6, 7];\n     let mut it = xs.iter().flat_map(|&x| x..x+3);\n-    it.next();\n-    it.next_back();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n     let i = it.fold(0, |i, x| {\n         assert_eq!(x, ys[i]);\n         i + 1\n     });\n     assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().flat_map(|&x| x..x+3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n }\n \n #[test]\n@@ -684,6 +807,32 @@ fn test_inspect() {\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n+#[test]\n+fn test_inspect_fold() {\n+    let xs = [1, 2, 3, 4];\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.fold(0, |i, &x| {\n+            assert_eq!(x, xs[i]);\n+            i + 1\n+        });\n+        assert_eq!(i, xs.len());\n+    }\n+    assert_eq!(n, xs.len());\n+\n+    let mut n = 0;\n+    {\n+        let it = xs.iter().inspect(|_| n += 1);\n+        let i = it.rfold(xs.len(), |i, &x| {\n+            assert_eq!(x, xs[i - 1]);\n+            i - 1\n+        });\n+        assert_eq!(i, 0);\n+    }\n+    assert_eq!(n, xs.len());\n+}\n+\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n@@ -1094,21 +1243,21 @@ fn test_range() {\n \n #[test]\n fn test_range_inclusive_exhaustion() {\n-    let mut r = 10...10;\n+    let mut r = 10..=10;\n     assert_eq!(r.next(), Some(10));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...10;\n+    let mut r = 10..=10;\n     assert_eq!(r.next_back(), Some(10));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...12;\n+    let mut r = 10..=12;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n-    let mut r = 10...12;\n+    let mut r = 10..=12;\n     assert_eq!(r.nth(5), None);\n-    assert_eq!(r, 1...0);\n+    assert_eq!(r, 1..=0);\n \n }\n \n@@ -1145,20 +1294,20 @@ fn test_range_from_nth() {\n \n #[test]\n fn test_range_inclusive_nth() {\n-    assert_eq!((10...15).nth(0), Some(10));\n-    assert_eq!((10...15).nth(1), Some(11));\n-    assert_eq!((10...15).nth(5), Some(15));\n-    assert_eq!((10...15).nth(6), None);\n+    assert_eq!((10..=15).nth(0), Some(10));\n+    assert_eq!((10..=15).nth(1), Some(11));\n+    assert_eq!((10..=15).nth(5), Some(15));\n+    assert_eq!((10..=15).nth(6), None);\n \n-    let mut r = 10_u8...20;\n+    let mut r = 10_u8..=20;\n     assert_eq!(r.nth(2), Some(12));\n-    assert_eq!(r, 13...20);\n+    assert_eq!(r, 13..=20);\n     assert_eq!(r.nth(2), Some(15));\n-    assert_eq!(r, 16...20);\n+    assert_eq!(r, 16..=20);\n     assert_eq!(r.is_empty(), false);\n     assert_eq!(r.nth(10), None);\n     assert_eq!(r.is_empty(), true);\n-    assert_eq!(r, 1...0);  // We may not want to document/promise this detail\n+    assert_eq!(r, 1..=0);  // We may not want to document/promise this detail\n }\n \n #[test]\n@@ -1241,6 +1390,31 @@ fn test_fuse_count() {\n     // Can't check len now because count consumes.\n }\n \n+#[test]\n+fn test_fuse_fold() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().fold(0, |i, &x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+\n+    let it = xs.iter(); // `FusedIterator`\n+    let i = it.fuse().rfold(xs.len(), |i, &x| {\n+        assert_eq!(x, xs[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+\n+    let it = xs.iter().scan((), |_, &x| Some(x)); // `!FusedIterator`\n+    let i = it.fuse().fold(0, |i, x| {\n+        assert_eq!(x, xs[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n #[test]\n fn test_once() {\n     let mut it = once(42);"}, {"sha": "afc5de7b0ee358068c6d789c7de885304e710f01", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -25,6 +25,7 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iter_rfind)]\n+#![feature(iter_rfold)]\n #![feature(nonzero)]\n #![feature(rand)]\n #![feature(raw)]\n@@ -38,6 +39,7 @@\n #![feature(test)]\n #![feature(trusted_len)]\n #![feature(try_from)]\n+#![feature(try_trait)]\n #![feature(unique)]\n \n #![feature(const_atomic_bool_new)]"}, {"sha": "7eb5ff988577766058c656e5d681f40319792448", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::convert::TryFrom;\n+use core::convert::{TryFrom, TryInto};\n use core::cmp::PartialEq;\n use core::fmt::Debug;\n use core::marker::Copy;\n+use core::num::TryFromIntError;\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::option::Option;\n use core::option::Option::{Some, None};\n@@ -134,6 +135,13 @@ fn test_empty() {\n     assert_eq!(\"\".parse::<u8>().ok(), None);\n }\n \n+#[test]\n+fn test_infallible_try_from_int_error() {\n+    let func = |x: i8| -> Result<i32, TryFromIntError> { Ok(x.try_into()?) };\n+\n+    assert!(func(0).is_ok());\n+}\n+\n macro_rules! test_impl_from {\n     ($fn_name: ident, $Small: ty, $Large: ty) => {\n         #[test]"}, {"sha": "22109e28edd9b810534dffb3cbf371b77945b5f6", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -270,3 +270,30 @@ fn test_cloned() {\n     assert_eq!(opt_ref_ref.clone().cloned(), Some(&val));\n     assert_eq!(opt_ref_ref.cloned().cloned(), Some(1));\n }\n+\n+#[test]\n+fn test_try() {\n+    fn try_option_some() -> Option<u8> {\n+        let val = Some(1)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_option_some(), Some(1));\n+\n+    fn try_option_none() -> Option<u8> {\n+        let val = None?;\n+        Some(val)\n+    }\n+    assert_eq!(try_option_none(), None);\n+\n+    fn try_option_ok() -> Result<u8, NoneError> {\n+        let val = Some(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_option_ok(), Ok(1));\n+\n+    fn try_option_err() -> Result<u8, NoneError> {\n+        let val = None?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_option_err(), Err(NoneError));\n+}"}, {"sha": "ce41bde8342edbbe2784cc4dc6a695d77a0a6d6f", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::option::*;\n+\n fn op1() -> Result<isize, &'static str> { Ok(666) }\n fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n@@ -202,3 +204,30 @@ pub fn test_unwrap_or_default() {\n     assert_eq!(op1().unwrap_or_default(), 666);\n     assert_eq!(op2().unwrap_or_default(), 0);\n }\n+\n+#[test]\n+fn test_try() {\n+    fn try_result_some() -> Option<u8> {\n+        let val = Ok(1)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_result_some(), Some(1));\n+\n+    fn try_result_none() -> Option<u8> {\n+        let val = Err(NoneError)?;\n+        Some(val)\n+    }\n+    assert_eq!(try_result_none(), None);\n+\n+    fn try_result_ok() -> Result<u8, u8> {\n+        let val = Ok(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_result_ok(), Ok(1));\n+\n+    fn try_result_err() -> Result<u8, u8> {\n+        let val = Err(1)?;\n+        Ok(val)\n+    }\n+    assert_eq!(try_result_err(), Err(1));\n+}"}, {"sha": "44e4018e1a37716286ec98cb5b7dd7d33ecaf940", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1 +1 @@\n-Subproject commit 95848f9622deccc9cbadcd5d3a4faef01a90ead4\n+Subproject commit 44e4018e1a37716286ec98cb5b7dd7d33ecaf940"}, {"sha": "2c540c8de8fc8bc8d749cb870d371fcc7915cfe0", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -509,6 +509,7 @@ impl TokenTree {\n             Dot => op!('.'),\n             DotDot => joint!('.', Dot),\n             DotDotDot => joint!('.', DotDot),\n+            DotDotEq => joint!('.', DotEq),\n             Comma => op!(','),\n             Semi => op!(';'),\n             Colon => op!(':'),\n@@ -531,6 +532,7 @@ impl TokenTree {\n                 })\n             }\n \n+            DotEq => unreachable!(),\n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n         };"}, {"sha": "8c1f6bfc11a5fcff35deb04e966c2b80e9ac5d78", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -202,8 +202,8 @@ impl Quote for Token {\n \n         gen_match! {\n             Eq, Lt, Le, EqEq, Ne, Ge, Gt, AndAnd, OrOr, Not, Tilde, At, Dot, DotDot, DotDotDot,\n-            Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar, Question,\n-            Underscore;\n+            DotDotEq, Comma, Semi, Colon, ModSep, RArrow, LArrow, FatArrow, Pound, Dollar,\n+            Question, Underscore;\n \n             Token::OpenDelim(delim) => quote!(rt::token::OpenDelim((quote delim))),\n             Token::CloseDelim(delim) => quote!(rt::token::CloseDelim((quote delim))),"}, {"sha": "eb31f5730d191f5c8b2d7ff0aaa710fae3aced89", "filename": "src/libprofiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibprofiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibprofiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,4 +15,4 @@ doc = false\n core = { path = \"../libcore\" }\n \n [build-dependencies]\n-gcc = \"0.3.50\"\n+cc = \"1.0\""}, {"sha": "8508b2dae2c56db23189b501b74058f661484c9a", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -12,14 +12,14 @@\n //!\n //! See the build.rs for libcompiler_builtins crate for details.\n \n-extern crate gcc;\n+extern crate cc;\n \n use std::env;\n use std::path::Path;\n \n fn main() {\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-    let cfg = &mut gcc::Build::new();\n+    let cfg = &mut cc::Build::new();\n \n     let mut profile_sources = vec![\"GCDAProfiling.c\",\n                                    \"InstrProfiling.c\","}, {"sha": "87de284d011b3a0db99a96efbb3528f851856206", "filename": "src/librustc/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -37,7 +37,7 @@ incremental improves that may change.)\n \n The dependency structure of these crates is roughly a diamond:\n \n-````\n+```\n                   rustc_driver\n                 /      |       \\\n               /        |         \\"}, {"sha": "7a78765365db047e86492d36d152343cc0083bf5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 68, "deletions": 20, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -60,7 +60,7 @@\n //! user of the `DepNode` API of having to know how to compute the expected\n //! fingerprint for a given set of node parameters.\n \n-use hir::def_id::{CrateNum, DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n \n@@ -80,14 +80,28 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n-macro_rules! anon_attr_to_bool {\n-    (anon) => (true)\n+macro_rules! is_anon_attr {\n+    (anon) => (true);\n+    ($attr:ident) => (false);\n+}\n+\n+macro_rules! is_input_attr {\n+    (input) => (true);\n+    ($attr:ident) => (false);\n+}\n+\n+macro_rules! contains_anon_attr {\n+    ($($attr:ident),*) => ({$(is_anon_attr!($attr) | )* false});\n+}\n+\n+macro_rules! contains_input_attr {\n+    ($($attr:ident),*) => ({$(is_input_attr!($attr) | )* false});\n }\n \n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n-        [$($anon:ident)*]\n+        [$($attr:ident),* ]\n         $variant:ident $(( $($tuple_arg:tt),* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n@@ -105,7 +119,9 @@ macro_rules! define_dep_nodes {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n-                            $(return !anon_attr_to_bool!($anon);)*\n+                            if contains_anon_attr!($($attr),*) {\n+                                return false;\n+                            }\n \n                             // tuple args\n                             $({\n@@ -126,15 +142,20 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[allow(unreachable_code)]\n             #[inline]\n-            pub fn is_anon<$tcx>(&self) -> bool {\n+            pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n-                        DepKind :: $variant => {\n-                            $(return anon_attr_to_bool!($anon);)*\n-                            false\n-                        }\n+                        DepKind :: $variant => { contains_anon_attr!($($attr),*) }\n+                    )*\n+                }\n+            }\n+\n+            #[inline]\n+            pub fn is_input(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => { contains_input_attr!($($attr),*) }\n                     )*\n                 }\n             }\n@@ -366,6 +387,17 @@ impl DefId {\n     }\n }\n \n+impl DepKind {\n+    #[inline]\n+    pub fn fingerprint_needed_for_crate_hash(self) -> bool {\n+        match self {\n+            DepKind::HirBody |\n+            DepKind::Krate => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n@@ -378,18 +410,17 @@ define_dep_nodes!( <'tcx>\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n     // edges yourself for the individual items that you read.\n-    [] Krate,\n-\n-    // Represents the HIR node with the given node-id\n-    [] Hir(DefId),\n+    [input] Krate,\n \n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n-    [] HirBody(DefId),\n+    [input] HirBody(DefId),\n+\n+    // Represents the HIR node with the given node-id\n+    [input] Hir(DefId),\n \n-    // Represents the metadata for a given HIR node, typically found\n-    // in an extern crate.\n-    [] MetaData(DefId),\n+    // Represents metadata from an extern crate.\n+    [input] CrateMetadata(CrateNum),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n@@ -414,6 +445,7 @@ define_dep_nodes!( <'tcx>\n     [] BorrowCheckKrate,\n     [] BorrowCheck(DefId),\n     [] MirBorrowCheck(DefId),\n+    [] UnsafetyViolations(DefId),\n \n     [] RvalueCheck(DefId),\n     [] Reachability,\n@@ -529,7 +561,7 @@ define_dep_nodes!( <'tcx>\n     [] ExternCrate(DefId),\n     [] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n-    [] InScopeTraits(DefIndex),\n+    [input] InScopeTraits(DefIndex),\n     [] ModuleExports(DefId),\n     [] IsSanitizerRuntime(CrateNum),\n     [] IsProfilerRuntime(CrateNum),\n@@ -647,6 +679,22 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (CrateNum,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        let def_id = DefId {\n+            krate: self.0,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        tcx.def_path_hash(def_id).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.crate_name(self.0).as_str().to_string()\n+    }\n+}\n+\n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "b12db11cb6af692f83ba54042ffd179cfa9bc9d0", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -17,7 +17,7 @@ use std::mem;\n use super::{DepGraphQuery, DepKind, DepNode};\n use super::debug::EdgeFilter;\n \n-pub struct DepGraphEdges {\n+pub(super) struct DepGraphEdges {\n     nodes: Vec<DepNode>,\n     indices: FxHashMap<DepNode, DepNodeIndex>,\n     edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n@@ -31,8 +31,8 @@ pub struct DepGraphEdges {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DepNodeIndex {\n-    index: u32\n+pub(super) struct DepNodeIndex {\n+    index: u32,\n }\n \n impl DepNodeIndex {\n@@ -123,6 +123,7 @@ impl DepGraphEdges {\n             reads\n         } = popped_node {\n             debug_assert_eq!(node, key);\n+            debug_assert!(!node.kind.is_input() || reads.is_empty());\n \n             let target_id = self.get_or_create_node(node);\n "}, {"sha": "d9770db9d69a2826b886fdce8d525c366fd677b6", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 322, "deletions": 29, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHashingContextProvider};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n+use std::hash::Hash;\n use std::rc::Rc;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n@@ -22,17 +24,56 @@ use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::edges::{DepGraphEdges, DepNodeIndex};\n+use super::edges::{self, DepGraphEdges};\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::prev::PreviousDepGraph;\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Option<Rc<DepGraphData>>\n+    data: Option<Rc<DepGraphData>>,\n+\n+    // At the moment we are using DepNode as key here. In the future it might\n+    // be possible to use an IndexVec<DepNodeIndex, _> here. At the moment there\n+    // are a few problems with that:\n+    // - Some fingerprints are needed even if incr. comp. is disabled -- yet\n+    //   we need to have a dep-graph to generate DepNodeIndices.\n+    // - The architecture is still in flux and it's not clear what how to best\n+    //   implement things.\n+    fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n+}\n+\n+/// As a temporary measure, while transitioning to the new DepGraph\n+/// implementation, we maintain the old and the new dep-graph encoding in\n+/// parallel, so a DepNodeIndex actually contains two indices, one for each\n+/// version.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DepNodeIndex {\n+    legacy: edges::DepNodeIndex,\n+    new: DepNodeIndexNew,\n+}\n+\n+impl DepNodeIndex {\n+    pub const INVALID: DepNodeIndex = DepNodeIndex {\n+        legacy: edges::DepNodeIndex::INVALID,\n+        new: DepNodeIndexNew::INVALID,\n+    };\n }\n \n struct DepGraphData {\n-    /// The actual graph data.\n+    /// The old, initial encoding of the dependency graph. This will soon go\n+    /// away.\n     edges: RefCell<DepGraphEdges>,\n \n+    /// The new encoding of the dependency graph, optimized for red/green\n+    /// tracking. The `current` field is the dependency graph of only the\n+    /// current compilation session: We don't merge the previous dep-graph into\n+    /// current one anymore.\n+    current: RefCell<CurrentDepGraph>,\n+\n+    /// The dep-graph from the previous compilation session. It contains all\n+    /// nodes and edges as well as all fingerprints of nodes that have them.\n+    previous: PreviousDepGraph,\n+\n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n@@ -46,18 +87,25 @@ struct DepGraphData {\n }\n \n impl DepGraph {\n-    pub fn new(enabled: bool) -> DepGraph {\n+\n+    pub fn new(prev_graph: PreviousDepGraph) -> DepGraph {\n         DepGraph {\n-            data: if enabled {\n-                Some(Rc::new(DepGraphData {\n-                    previous_work_products: RefCell::new(FxHashMap()),\n-                    work_products: RefCell::new(FxHashMap()),\n-                    edges: RefCell::new(DepGraphEdges::new()),\n-                    dep_node_debug: RefCell::new(FxHashMap()),\n-                }))\n-            } else {\n-                None\n-            }\n+            data: Some(Rc::new(DepGraphData {\n+                previous_work_products: RefCell::new(FxHashMap()),\n+                work_products: RefCell::new(FxHashMap()),\n+                edges: RefCell::new(DepGraphEdges::new()),\n+                dep_node_debug: RefCell::new(FxHashMap()),\n+                current: RefCell::new(CurrentDepGraph::new()),\n+                previous: prev_graph,\n+            })),\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n+        }\n+    }\n+\n+    pub fn new_disabled() -> DepGraph {\n+        DepGraph {\n+            data: None,\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n     }\n \n@@ -72,7 +120,8 @@ impl DepGraph {\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges,\n+                                                            &data.current))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -120,6 +169,7 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            data.current.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n             };\n@@ -135,15 +185,36 @@ impl DepGraph {\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskEnd)\n             };\n-            let dep_node_index = data.edges.borrow_mut().pop_task(key);\n+\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_task(key);\n+            let dep_node_index_new = data.current.borrow_mut().pop_task(key);\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n-            let _: Fingerprint = stable_hasher.finish();\n \n-            (result, dep_node_index)\n+            assert!(self.fingerprints\n+                        .borrow_mut()\n+                        .insert(key, stable_hasher.finish())\n+                        .is_none());\n+\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n-            (task(cx, arg), DepNodeIndex::INVALID)\n+            if key.kind.fingerprint_needed_for_crate_hash() {\n+                let mut hcx = cx.create_stable_hashing_context();\n+                let result = task(cx, arg);\n+                let mut stable_hasher = StableHasher::new();\n+                result.hash_stable(&mut hcx, &mut stable_hasher);\n+                assert!(self.fingerprints\n+                            .borrow_mut()\n+                            .insert(key, stable_hasher.finish())\n+                            .is_none());\n+                (result, DepNodeIndex::INVALID)\n+            } else {\n+                (task(cx, arg), DepNodeIndex::INVALID)\n+            }\n         }\n     }\n \n@@ -154,9 +225,14 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_anon_task();\n+            data.current.borrow_mut().push_anon_task();\n             let result = op();\n-            let dep_node = data.edges.borrow_mut().pop_anon_task(dep_kind);\n-            (result, dep_node)\n+            let dep_node_index_legacy = data.edges.borrow_mut().pop_anon_task(dep_kind);\n+            let dep_node_index_new = data.current.borrow_mut().pop_anon_task(dep_kind);\n+            (result, DepNodeIndex {\n+                legacy: dep_node_index_legacy,\n+                new: dep_node_index_new,\n+            })\n         } else {\n             (op(), DepNodeIndex::INVALID)\n         }\n@@ -166,13 +242,21 @@ impl DepGraph {\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().read(v);\n+\n+            let mut current = data.current.borrow_mut();\n+            if let Some(&dep_node_index_new) = current.node_to_node_index.get(&v) {\n+                current.read_index(dep_node_index_new);\n+            } else {\n+                bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n+            }\n         }\n     }\n \n     #[inline]\n     pub fn read_index(&self, v: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().read_index(v);\n+            data.edges.borrow_mut().read_index(v.legacy);\n+            data.current.borrow_mut().read_index(v.new);\n         }\n     }\n \n@@ -187,12 +271,12 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n-    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n-        if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().add_node(node)\n-        } else {\n-            DepNodeIndex::INVALID\n-        }\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.fingerprints.borrow()[dep_node]\n+    }\n+\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     /// Indicates that a previous work product exists for `v`. This is\n@@ -261,6 +345,44 @@ impl DepGraph {\n     pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n         self.data.as_ref().and_then(|t| t.dep_node_debug.borrow().get(&dep_node).cloned())\n     }\n+\n+    pub fn serialize(&self) -> SerializedDepGraph {\n+        let fingerprints = self.fingerprints.borrow();\n+        let current_dep_graph = self.data.as_ref().unwrap().current.borrow();\n+\n+        let nodes: IndexVec<_, _> = current_dep_graph.nodes.iter().map(|dep_node| {\n+            let fingerprint = fingerprints.get(dep_node)\n+                                          .cloned()\n+                                          .unwrap_or(Fingerprint::zero());\n+            (*dep_node, fingerprint)\n+        }).collect();\n+\n+        let total_edge_count: usize = current_dep_graph.edges.iter()\n+                                                             .map(|v| v.len())\n+                                                             .sum();\n+\n+        let mut edge_list_indices = IndexVec::with_capacity(nodes.len());\n+        let mut edge_list_data = Vec::with_capacity(total_edge_count);\n+\n+        for (current_dep_node_index, edges) in current_dep_graph.edges.iter_enumerated() {\n+            let start = edge_list_data.len() as u32;\n+            // This should really just be a memcpy :/\n+            edge_list_data.extend(edges.iter().map(|i| SerializedDepNodeIndex(i.index)));\n+            let end = edge_list_data.len() as u32;\n+\n+            debug_assert_eq!(current_dep_node_index.index(), edge_list_indices.len());\n+            edge_list_indices.push((start, end));\n+        }\n+\n+        debug_assert!(edge_list_data.len() <= ::std::u32::MAX as usize);\n+        debug_assert_eq!(edge_list_data.len(), total_edge_count);\n+\n+        SerializedDepGraph {\n+            nodes,\n+            edge_list_indices,\n+            edge_list_data,\n+        }\n+    }\n }\n \n /// A \"work product\" is an intermediate result that we save into the\n@@ -305,3 +427,174 @@ pub struct WorkProduct {\n     /// Saved files associated with this CGU\n     pub saved_files: Vec<(OutputType, String)>,\n }\n+\n+pub(super) struct CurrentDepGraph {\n+    nodes: IndexVec<DepNodeIndexNew, DepNode>,\n+    edges: IndexVec<DepNodeIndexNew, Vec<DepNodeIndexNew>>,\n+    node_to_node_index: FxHashMap<DepNode, DepNodeIndexNew>,\n+\n+    task_stack: Vec<OpenTask>,\n+}\n+\n+impl CurrentDepGraph {\n+    fn new() -> CurrentDepGraph {\n+        CurrentDepGraph {\n+            nodes: IndexVec::new(),\n+            edges: IndexVec::new(),\n+            node_to_node_index: FxHashMap(),\n+            task_stack: Vec::new(),\n+        }\n+    }\n+\n+    pub(super) fn push_ignore(&mut self) {\n+        self.task_stack.push(OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn pop_ignore(&mut self) {\n+        let popped_node = self.task_stack.pop().unwrap();\n+        debug_assert_eq!(popped_node, OpenTask::Ignore);\n+    }\n+\n+    pub(super) fn push_task(&mut self, key: DepNode) {\n+        self.task_stack.push(OpenTask::Regular {\n+            node: key,\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Regular {\n+            node,\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            debug_assert_eq!(node, key);\n+            self.alloc_node(node, reads)\n+        } else {\n+            bug!(\"pop_task() - Expected regular task to be popped\")\n+        }\n+    }\n+\n+    fn push_anon_task(&mut self) {\n+        self.task_stack.push(OpenTask::Anon {\n+            reads: Vec::new(),\n+            read_set: FxHashSet(),\n+        });\n+    }\n+\n+    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndexNew {\n+        let popped_node = self.task_stack.pop().unwrap();\n+\n+        if let OpenTask::Anon {\n+            read_set: _,\n+            reads\n+        } = popped_node {\n+            let mut fingerprint = Fingerprint::zero();\n+            let mut hasher = StableHasher::new();\n+\n+            for &read in reads.iter() {\n+                let read_dep_node = self.nodes[read];\n+\n+                ::std::mem::discriminant(&read_dep_node.kind).hash(&mut hasher);\n+\n+                // Fingerprint::combine() is faster than sending Fingerprint\n+                // through the StableHasher (at least as long as StableHasher\n+                // is so slow).\n+                fingerprint = fingerprint.combine(read_dep_node.hash);\n+            }\n+\n+            fingerprint = fingerprint.combine(hasher.finish());\n+\n+            let target_dep_node = DepNode {\n+                kind,\n+                hash: fingerprint,\n+            };\n+\n+            if let Some(&index) = self.node_to_node_index.get(&target_dep_node) {\n+                return index;\n+            }\n+\n+            self.alloc_node(target_dep_node, reads)\n+        } else {\n+            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n+        }\n+    }\n+\n+    fn read_index(&mut self, source: DepNodeIndexNew) {\n+        match self.task_stack.last_mut() {\n+            Some(&mut OpenTask::Regular {\n+                ref mut reads,\n+                ref mut read_set,\n+                node: _,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Anon {\n+                ref mut reads,\n+                ref mut read_set,\n+            }) => {\n+                if read_set.insert(source) {\n+                    reads.push(source);\n+                }\n+            }\n+            Some(&mut OpenTask::Ignore) | None => {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    fn alloc_node(&mut self,\n+                  dep_node: DepNode,\n+                  edges: Vec<DepNodeIndexNew>)\n+                  -> DepNodeIndexNew {\n+        debug_assert_eq!(self.edges.len(), self.nodes.len());\n+        debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n+        debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n+        let dep_node_index = DepNodeIndexNew::new(self.nodes.len());\n+        self.nodes.push(dep_node);\n+        self.node_to_node_index.insert(dep_node, dep_node_index);\n+        self.edges.push(edges);\n+        dep_node_index\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(super) struct DepNodeIndexNew {\n+    index: u32,\n+}\n+\n+impl Idx for DepNodeIndexNew {\n+    fn new(v: usize) -> DepNodeIndexNew {\n+        assert!((v & 0xFFFF_FFFF) == v);\n+        DepNodeIndexNew { index: v as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n+impl DepNodeIndexNew {\n+    const INVALID: DepNodeIndexNew = DepNodeIndexNew {\n+        index: ::std::u32::MAX,\n+    };\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum OpenTask {\n+    Regular {\n+        node: DepNode,\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Anon {\n+        reads: Vec<DepNodeIndexNew>,\n+        read_set: FxHashSet<DepNodeIndexNew>,\n+    },\n+    Ignore,\n+}"}, {"sha": "cd77e06bdd6b03c6ace7f0e802ad2d279a0ca4a7", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,19 +13,17 @@ mod dep_node;\n mod dep_tracking_map;\n mod edges;\n mod graph;\n+mod prev;\n mod query;\n mod raii;\n mod safe;\n+mod serialized;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n-pub use self::dep_node::DepNode;\n-pub use self::dep_node::WorkProductId;\n-pub use self::graph::DepGraph;\n-pub use self::graph::WorkProduct;\n-pub use self::edges::DepNodeIndex;\n+pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex};\n+pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;\n pub use self::safe::AssertDepGraphSafe;\n pub use self::safe::DepGraphSafe;\n-pub use self::raii::DepTask;\n-\n-pub use self::dep_node::{DepKind, DepConstructor};\n+pub use self::serialized::SerializedDepGraph;"}, {"sha": "882ca0414ccc9cdaec44161f6a960d81bbcba45b", "filename": "src/librustc/dep_graph/prev.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ich::Fingerprint;\n+use rustc_data_structures::fx::FxHashMap;\n+use super::dep_node::DepNode;\n+use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph {\n+    data: SerializedDepGraph,\n+    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+}\n+\n+impl PreviousDepGraph {\n+    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+        let index: FxHashMap<_, _> = data.nodes\n+            .iter_enumerated()\n+            .map(|(idx, &(dep_node, _))| (dep_node, idx))\n+            .collect();\n+        PreviousDepGraph { data, index }\n+    }\n+\n+    pub fn with_edges_from<F>(&self, dep_node: &DepNode, mut f: F)\n+    where\n+        F: FnMut(&(DepNode, Fingerprint)),\n+    {\n+        let node_index = self.index[dep_node];\n+        self.data\n+            .edge_targets_from(node_index)\n+            .into_iter()\n+            .for_each(|&index| f(&self.data.nodes[index]));\n+    }\n+\n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n+        let node_index = self.index[dep_node];\n+        self.data.nodes[node_index].1\n+    }\n+}"}, {"sha": "6e9e4f4a18b15ca8e9b6185e0ae5d8cc60357eee", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,50 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::DepNode;\n use super::edges::DepGraphEdges;\n+use super::graph::CurrentDepGraph;\n \n use std::cell::RefCell;\n \n-pub struct DepTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n-    key: DepNode,\n-}\n-\n-impl<'graph> DepTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>,\n-               key: DepNode)\n-               -> DepTask<'graph> {\n-        graph.borrow_mut().push_task(key);\n-        DepTask {\n-            graph,\n-            key,\n-        }\n-    }\n-}\n-\n-impl<'graph> Drop for DepTask<'graph> {\n-    fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_task(self.key);\n-    }\n-}\n-\n pub struct IgnoreTask<'graph> {\n-    graph: &'graph RefCell<DepGraphEdges>,\n+    legacy_graph: &'graph RefCell<DepGraphEdges>,\n+    new_graph: &'graph RefCell<CurrentDepGraph>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(graph: &'graph RefCell<DepGraphEdges>) -> IgnoreTask<'graph> {\n-        graph.borrow_mut().push_ignore();\n+    pub(super) fn new(legacy_graph: &'graph RefCell<DepGraphEdges>,\n+                      new_graph: &'graph RefCell<CurrentDepGraph>)\n+                      -> IgnoreTask<'graph> {\n+        legacy_graph.borrow_mut().push_ignore();\n+        new_graph.borrow_mut().push_ignore();\n         IgnoreTask {\n-            graph\n+            legacy_graph,\n+            new_graph,\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        self.graph.borrow_mut().pop_ignore();\n+        self.legacy_graph.borrow_mut().pop_ignore();\n+        self.new_graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "6110c270086fe0b1d11ee75a1cecf64325b570c6", "filename": "src/librustc/dep_graph/serialized.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The data that we will serialize and deserialize.\n+\n+use dep_graph::DepNode;\n+use ich::Fingerprint;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+\n+/// The index of a DepNode in the SerializedDepGraph::nodes array.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepNodeIndex(pub u32);\n+\n+impl Idx for SerializedDepNodeIndex {\n+    #[inline]\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= ::std::u32::MAX as usize);\n+        SerializedDepNodeIndex(idx as u32)\n+    }\n+\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Data for use when recompiling the **current crate**.\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph {\n+    /// The set of all DepNodes in the graph\n+    pub nodes: IndexVec<SerializedDepNodeIndex, (DepNode, Fingerprint)>,\n+    /// For each DepNode, stores the list of edges originating from that\n+    /// DepNode. Encoded as a [start, end) pair indexing into edge_list_data,\n+    /// which holds the actual DepNodeIndices of the target nodes.\n+    pub edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)>,\n+    /// A flattened list of all edge targets in the graph. Edge sources are\n+    /// implicit in edge_list_indices.\n+    pub edge_list_data: Vec<SerializedDepNodeIndex>,\n+}\n+\n+impl SerializedDepGraph {\n+\n+    pub fn new() -> SerializedDepGraph {\n+        SerializedDepGraph {\n+            nodes: IndexVec::new(),\n+            edge_list_indices: IndexVec::new(),\n+            edge_list_data: Vec::new(),\n+        }\n+    }\n+\n+    pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n+        let targets = self.edge_list_indices[source];\n+        &self.edge_list_data[targets.0 as usize..targets.1 as usize]\n+    }\n+}"}, {"sha": "26f56ffacae7fd5c7a53968045d39991678488bc", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 103, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -479,40 +479,6 @@ fn main() {\n ```\n \"##,\n \n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n-\"##,\n-\n // This shouldn't really ever trigger since the repeated value error comes first\n E0136: r##\"\n A binary can only have one entry point, and by default that entry point is the\n@@ -1139,11 +1105,13 @@ already specify all requirements that will be used for every type parameter.\n \"##,\n \n E0281: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n You tried to supply a type which doesn't implement some trait in a location\n which expected that trait. This error typically occurs when working with\n `Fn`-based types. Erroneous code example:\n \n-```compile_fail,E0281\n+```compile-fail\n fn foo<F: Fn(usize)>(x: F) { }\n \n fn main() {\n@@ -1383,74 +1351,6 @@ struct Foo<T: 'static> {\n ```\n \"##,\n \n-E0312: r##\"\n-A lifetime of reference outlives lifetime of borrowed content.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0312\n-fn make_child<'tree, 'human>(\n-  x: &'human i32,\n-  y: &'tree i32\n-) -> &'human i32 {\n-    if x > y\n-       { x }\n-    else\n-       { y }\n-       // error: lifetime of reference outlives lifetime of borrowed content\n-}\n-```\n-\n-The function declares that it returns a reference with the `'human`\n-lifetime, but it may return data with the `'tree` lifetime. As neither\n-lifetime is declared longer than the other, this results in an\n-error. Sometimes, this error is because the function *body* is\n-incorrect -- that is, maybe you did not *mean* to return data from\n-`y`. In that case, you should fix the function body.\n-\n-Often, however, the body is correct. In that case, the function\n-signature needs to be altered to match the body, so that the caller\n-understands that data from either `x` or `y` may be returned. The\n-simplest way to do this is to give both function parameters the *same*\n-named lifetime:\n-\n-```\n-fn make_child<'human>(\n-  x: &'human i32,\n-  y: &'human i32\n-) -> &'human i32 {\n-    if x > y\n-       { x }\n-    else\n-       { y } // ok!\n-}\n-```\n-\n-However, in some cases, you may prefer to explicitly declare that one lifetime\n-outlives another using a `where` clause:\n-\n-```\n-fn make_child<'tree, 'human>(\n-  x: &'human i32,\n-  y: &'tree i32\n-) -> &'human i32\n-where\n-  'tree: 'human\n-{\n-    if x > y\n-       { x }\n-    else\n-       { y } // ok!\n-}\n-```\n-\n-Here, the where clause `'tree: 'human` can be read as \"the lifetime\n-'tree outlives the lifetime 'human\" -- meaning, references with the\n-`'tree` lifetime live *at least as long as* references with the\n-`'human` lifetime. Therefore, it is safe to return data with lifetime\n-`'tree` when data with the lifetime `'human` is needed.\n-\"##,\n-\n E0317: r##\"\n This error occurs when an `if` expression without an `else` block is used in a\n context where a type other than `()` is expected, for example a `let`\n@@ -2060,6 +1960,7 @@ register_diagnostics! {\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n     E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n@@ -2086,4 +1987,6 @@ register_diagnostics! {\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n     E0628, // generators cannot have explicit arguments\n+    E0631, // type mismatch in closure arguments\n+    E0637, // \"'_\" is not a valid lifetime bound\n }"}, {"sha": "8e48352007b374d9942028a19e40fce1965c5635", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -97,6 +97,17 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n+impl Idx for DefIndex {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        DefIndex(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n impl fmt::Debug for DefIndex {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,"}, {"sha": "1755b3bca0572198806b82422b46a0a73fdf508b", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -422,7 +422,12 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n-    visitor.visit_name(lifetime.span, lifetime.name);\n+    match lifetime.name {\n+        LifetimeName::Name(name) => {\n+            visitor.visit_name(lifetime.span, name);\n+        }\n+        LifetimeName::Static | LifetimeName::Implicit | LifetimeName::Underscore => {}\n+    }\n }\n \n pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v LifetimeDef) {\n@@ -622,7 +627,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n     visitor.visit_name(path_span, segment.name);\n-    visitor.visit_path_parameters(path_span, &segment.parameters);\n+    if let Some(ref parameters) = segment.parameters {\n+        visitor.visit_path_parameters(path_span, parameters);\n+    }\n }\n \n pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,"}, {"sha": "1fdfbe20328a41a3063c888ab3956c66c608ad81", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -65,7 +65,7 @@ use syntax::codemap::{self, respan, Spanned, CompilerDesugaringKind};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n-use syntax::parse::token::{Token, DelimToken};\n+use syntax::parse::token::Token;\n use syntax::util::small_vector::SmallVector;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -606,10 +606,12 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n-        tokens.into_trees().map(|tree| self.lower_token_tree(tree)).collect()\n+        tokens.into_trees()\n+            .flat_map(|tree| self.lower_token_tree(tree).into_trees())\n+            .collect()\n     }\n \n-    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenTree {\n+    fn lower_token_tree(&mut self, tree: TokenTree) -> TokenStream {\n         match tree {\n             TokenTree::Token(span, token) => {\n                 self.lower_token(token, span)\n@@ -618,23 +620,19 @@ impl<'a> LoweringContext<'a> {\n                 TokenTree::Delimited(span, Delimited {\n                     delim: delimited.delim,\n                     tts: self.lower_token_stream(delimited.tts.into()).into(),\n-                })\n+                }).into()\n             }\n         }\n     }\n \n-    fn lower_token(&mut self, token: Token, span: Span) -> TokenTree {\n+    fn lower_token(&mut self, token: Token, span: Span) -> TokenStream {\n         match token {\n             Token::Interpolated(_) => {}\n-            other => return TokenTree::Token(span, other),\n+            other => return TokenTree::Token(span, other).into(),\n         }\n \n         let tts = token.interpolated_to_tokenstream(&self.sess.parse_sess, span);\n-        let tts = self.lower_token_stream(tts);\n-        TokenTree::Delimited(span, Delimited {\n-            delim: DelimToken::NoDelim,\n-            tts: tts.into(),\n-        })\n+        self.lower_token_stream(tts)\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -685,17 +683,16 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_ty(ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n-                let id = self.lower_node_id(t.id).node_id;\n+                let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n                 return self.ty_path(id, t.span, qpath);\n             }\n             TyKind::ImplicitSelf => {\n                 hir::TyPath(hir::QPath::Resolved(None, P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment {\n-                        name: keywords::SelfType.name(),\n-                        parameters: hir::PathParameters::none()\n-                    }],\n+                    segments: hir_vec![\n+                        hir::PathSegment::from_name(keywords::SelfType.name())\n+                    ],\n                     span: t.span,\n                 })))\n             }\n@@ -734,10 +731,12 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(t.id);\n         P(hir::Ty {\n-            id: self.lower_node_id(t.id).node_id,\n+            id: node_id,\n             node: kind,\n             span: t.span,\n+            hir_id,\n         })\n     }\n \n@@ -863,7 +862,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id().node_id;\n+            let new_id = self.next_id();\n             self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n@@ -888,7 +887,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            let new_id = self.next_id().node_id;\n+            let new_id = self.next_id();\n             ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n@@ -914,12 +913,8 @@ impl<'a> LoweringContext<'a> {\n             segments: segments.map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n                                         ParenthesizedGenericArgs::Err)\n-            }).chain(name.map(|name| {\n-                hir::PathSegment {\n-                    name,\n-                    parameters: hir::PathParameters::none()\n-                }\n-            })).collect(),\n+            }).chain(name.map(|name| hir::PathSegment::from_name(name)))\n+              .collect(),\n             span: p.span,\n         }\n     }\n@@ -940,7 +935,7 @@ impl<'a> LoweringContext<'a> {\n                           expected_lifetimes: usize,\n                           parenthesized_generic_args: ParenthesizedGenericArgs)\n                           -> hir::PathSegment {\n-        let mut parameters = if let Some(ref parameters) = segment.parameters {\n+        let (mut parameters, infer_types) = if let Some(ref parameters) = segment.parameters {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n@@ -951,12 +946,12 @@ impl<'a> LoweringContext<'a> {\n                     ParenthesizedGenericArgs::Warn => {\n                         self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                                               CRATE_NODE_ID, data.span, msg.into());\n-                        hir::PathParameters::none()\n+                        (hir::PathParameters::none(), true)\n                     }\n                     ParenthesizedGenericArgs::Err => {\n                         struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n                             .span_label(data.span, \"only traits may use parentheses\").emit();\n-                        hir::PathParameters::none()\n+                        (hir::PathParameters::none(), true)\n                     }\n                 }\n             }\n@@ -970,39 +965,39 @@ impl<'a> LoweringContext<'a> {\n             }).collect();\n         }\n \n-        hir::PathSegment {\n-            name: self.lower_ident(segment.identifier),\n+        hir::PathSegment::new(\n+            self.lower_ident(segment.identifier),\n             parameters,\n-        }\n+            infer_types\n+        )\n     }\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n-                                            -> hir::PathParameters {\n+                                            -> (hir::PathParameters, bool) {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n-        hir::PathParameters {\n+        (hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n             parenthesized: false,\n-        }\n+        }, types.is_empty() && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n-                                          -> hir::PathParameters {\n+                                          -> (hir::PathParameters, bool) {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n         let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n         let mk_tup = |this: &mut Self, tys, span| {\n-            P(hir::Ty { node: hir::TyTup(tys), id: this.next_id().node_id, span })\n+            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n         };\n \n-        hir::PathParameters {\n+        (hir::PathParameters {\n             lifetimes: hir::HirVec::new(),\n             types: hir_vec![mk_tup(self, inputs, span)],\n-            infer_types: false,\n             bindings: hir_vec![hir::TypeBinding {\n                 id: self.next_id().node_id,\n                 name: Symbol::intern(FN_OUTPUT_NAME),\n@@ -1011,7 +1006,7 @@ impl<'a> LoweringContext<'a> {\n                 span: output.as_ref().map_or(span, |ty| ty.span),\n             }],\n             parenthesized: true,\n-        }\n+        }, false)\n     }\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n@@ -1108,6 +1103,10 @@ impl<'a> LoweringContext<'a> {\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n+            synthetic: tp.attrs.iter()\n+                               .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                               .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                               .nth(0),\n         }\n     }\n \n@@ -1121,7 +1120,11 @@ impl<'a> LoweringContext<'a> {\n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         hir::Lifetime {\n             id: self.lower_node_id(l.id).node_id,\n-            name: self.lower_ident(l.ident),\n+            name: match self.lower_ident(l.ident) {\n+                x if x == \"'_\" => hir::LifetimeName::Underscore,\n+                x if x == \"'static\" => hir::LifetimeName::Static,\n+                name => hir::LifetimeName::Name(name),\n+            },\n             span: l.span,\n         }\n     }\n@@ -1865,7 +1868,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_range_end(&mut self, e: &RangeEnd) -> hir::RangeEnd {\n         match *e {\n-            RangeEnd::Included => hir::RangeEnd::Included,\n+            RangeEnd::Included(_) => hir::RangeEnd::Included,\n             RangeEnd::Excluded => hir::RangeEnd::Excluded,\n         }\n     }\n@@ -2972,7 +2975,7 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn ty_path(&mut self, id: NodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n+    fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n         let mut id = id;\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n@@ -2982,14 +2985,14 @@ impl<'a> LoweringContext<'a> {\n                         bound_lifetimes: hir_vec![],\n                         trait_ref: hir::TraitRef {\n                             path: path.and_then(|path| path),\n-                            ref_id: id,\n+                            ref_id: id.node_id,\n                         },\n                         span,\n                     };\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n-                    id = self.next_id().node_id;\n+                    id = self.next_id();\n \n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n@@ -2998,14 +3001,14 @@ impl<'a> LoweringContext<'a> {\n             }\n             _ => hir::TyPath(qpath)\n         };\n-        P(hir::Ty { id, node, span })\n+        P(hir::Ty { id: id.node_id, hir_id: id.hir_id, node, span })\n     }\n \n     fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n             id: self.next_id().node_id,\n             span,\n-            name: keywords::Invalid.name()\n+            name: hir::LifetimeName::Implicit,\n         }\n     }\n }"}, {"sha": "80fadcda2775d426501f90b5ceb66811834d00a9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 158, "deletions": 33, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -16,6 +16,9 @@ use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+\n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n@@ -25,37 +28,113 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: NodeId,\n \n+    // These fields keep track of the currently relevant DepNodes during\n+    // the visitor's traversal.\n     current_dep_node_owner: DefIndex,\n-    current_dep_node_index: DepNodeIndex,\n+    current_signature_dep_index: DepNodeIndex,\n+    current_full_dep_index: DepNodeIndex,\n+    currently_in_body: bool,\n \n     dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n+\n+    hcx: StableHashingContext<'a>,\n+\n+    // We are collecting DepNode::HirBody hashes here so we can compute the\n+    // crate hash from then later on.\n+    hir_body_nodes: Vec<DefPathHash>,\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n-                dep_graph: &'a DepGraph,\n-                definitions: &'a definitions::Definitions)\n+                       dep_graph: &'a DepGraph,\n+                       definitions: &'a definitions::Definitions,\n+                       hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n-        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n-        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n+        // Allocate DepNodes for the root module\n+        let (root_mod_sig_dep_index, root_mod_full_dep_index);\n+        {\n+            let Crate {\n+                ref module,\n+                // Crate attributes are not copied over to the root `Mod`, so hash\n+                // them explicitly here.\n+                ref attrs,\n+                span,\n+\n+                // These fields are handled separately:\n+                exported_macros: _,\n+                items: _,\n+                trait_items: _,\n+                impl_items: _,\n+                bodies: _,\n+                trait_impls: _,\n+                trait_default_impl: _,\n+                body_ids: _,\n+            } = *krate;\n+\n+            root_mod_sig_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::Hir),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: false },\n+                identity_fn\n+            ).1;\n+            root_mod_full_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::HirBody),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: true },\n+                identity_fn\n+            ).1;\n+        }\n+\n+        {\n+            dep_graph.with_task(\n+                DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n+                &hcx,\n+                &krate.trait_impls,\n+                identity_fn\n+            );\n+        }\n+\n+        let hir_body_nodes = vec![root_mod_def_path_hash];\n \n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            current_dep_node_index: root_mod_dep_node_index,\n+            current_signature_dep_index: root_mod_sig_dep_index,\n+            current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n+            currently_in_body: false,\n             dep_graph,\n             definitions,\n+            hcx,\n+            hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_sig_dep_index));\n \n         collector\n     }\n \n-    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+    pub(super) fn finalize_and_compute_crate_hash(self,\n+                                                  crate_disambiguator: &str)\n+                                                  -> Vec<MapEntry<'hir>> {\n+        let mut node_hashes: Vec<_> = self\n+            .hir_body_nodes\n+            .iter()\n+            .map(|&def_path_hash| {\n+                let dep_node = def_path_hash.to_dep_node(DepKind::HirBody);\n+                (def_path_hash, self.dep_graph.fingerprint_of(&dep_node))\n+            })\n+            .collect();\n+\n+        node_hashes.sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+\n+        self.dep_graph.with_task(DepNode::new_no_params(DepKind::Krate),\n+                                 &self.hcx,\n+                                 (node_hashes, crate_disambiguator),\n+                                 identity_fn);\n         self.map\n     }\n \n@@ -70,7 +149,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n         let parent = self.parent_node;\n-        let dep_node_index = self.current_dep_node_index;\n+        let dep_node_index = if self.currently_in_body {\n+            self.current_full_dep_index\n+        } else {\n+            self.current_signature_dep_index\n+        };\n \n         let entry = match node {\n             NodeItem(n) => EntryItem(parent, dep_node_index, n),\n@@ -91,6 +174,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n             NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n             NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+            NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -127,22 +211,41 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+                           F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n+                                                 item_like: &T,\n                                                  f: F) {\n         let prev_owner = self.current_dep_node_owner;\n-        let prev_index = self.current_dep_node_index;\n-\n-        // When we enter a new owner (item, impl item, or trait item), we always\n-        // start out again with DepKind::Hir.\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(dep_node_owner)\n-                               .to_dep_node(DepKind::Hir);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_signature_dep_index = self.current_signature_dep_index;\n+        let prev_full_dep_index = self.current_signature_dep_index;\n+        let prev_in_body = self.currently_in_body;\n+\n+        let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n+\n+        self.current_signature_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::Hir),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: false },\n+            identity_fn\n+        ).1;\n+\n+        self.current_full_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::HirBody),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: true },\n+            identity_fn\n+        ).1;\n+\n+        self.hir_body_nodes.push(def_path_hash);\n+\n         self.current_dep_node_owner = dep_node_owner;\n+        self.currently_in_body = false;\n         f(self);\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n         self.current_dep_node_owner = prev_owner;\n+        self.current_full_dep_index = prev_full_dep_index;\n+        self.current_signature_dep_index = prev_signature_dep_index;\n     }\n }\n \n@@ -169,24 +272,17 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        // When we enter a body, we switch to DepKind::HirBody.\n-        // Note that current_dep_node_index might already be DepKind::HirBody,\n-        // e.g. when entering the body of a closure that is already part of a\n-        // surrounding body. That's expected and not a problem.\n-        let prev_index = self.current_dep_node_index;\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(self.current_dep_node_owner)\n-                               .to_dep_node(DepKind::HirBody);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_in_body = self.currently_in_body;\n+        self.currently_in_body = true;\n         self.visit_body(self.krate.body(id));\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n-        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+        self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.id, NodeItem(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n@@ -222,7 +318,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n-        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.id, NodeTraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n@@ -234,7 +330,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n-        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n             this.insert(ii.id, NodeImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n@@ -328,7 +424,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n-        self.insert_entry(macro_def.id, NotPresent);\n+        let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n+\n+        self.with_dep_node_owner(def_index, macro_def, |this| {\n+            this.insert(macro_def.id, NodeMacroDef(macro_def));\n+        });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n@@ -375,3 +475,28 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_impl_item(id);\n     }\n }\n+\n+// We use this with DepGraph::with_task(). Since we are handling only input\n+// values here, the \"task\" computing them just passes them through.\n+fn identity_fn<T>(_: &StableHashingContext, item_like: T) -> T {\n+    item_like\n+}\n+\n+// This is a wrapper structure that allows determining if span values within\n+// the wrapped item should be hashed or not.\n+struct HirItemLike<T> {\n+    item_like: T,\n+    hash_bodies: bool,\n+}\n+\n+impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+    where T: HashStable<StableHashingContext<'hir>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n+            self.item_like.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "8ce2feab06cef06ee6ba75b3b55922e3f7c763cd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -57,6 +57,7 @@ pub enum Node<'hir> {\n     NodePat(&'hir Pat),\n     NodeBlock(&'hir Block),\n     NodeLocal(&'hir Local),\n+    NodeMacroDef(&'hir MacroDef),\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(&'hir VariantData),\n@@ -93,6 +94,8 @@ enum MapEntry<'hir> {\n     EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n     EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n \n+    EntryMacroDef(DepNodeIndex, &'hir MacroDef),\n+\n     /// Roots for node trees. The DepNodeIndex is the dependency node of the\n     /// crate's root module.\n     RootCrate(DepNodeIndex),\n@@ -127,6 +130,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryLocal(id, _, _) => id,\n \n             NotPresent |\n+            EntryMacroDef(..) |\n             RootCrate(_) => return None,\n         })\n     }\n@@ -151,6 +155,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryTyParam(_, _, n) => NodeTyParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n+            EntryMacroDef(_, n) => NodeMacroDef(n),\n \n             NotPresent |\n             RootCrate(_) => return None\n@@ -285,20 +290,12 @@ impl<'hir> Map<'hir> {\n             EntryVisibility(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n             EntryLocal(_, dep_node_index, _) |\n+            EntryMacroDef(dep_node_index, _) |\n             RootCrate(dep_node_index) => {\n                 self.dep_graph.read_index(dep_node_index);\n             }\n             NotPresent => {\n-                // Some nodes, notably macro definitions, are not\n-                // present in the map for whatever reason, but\n-                // they *do* have def-ids. So if we encounter an\n-                // empty hole, check for that case.\n-                if let Some(def_index) = self.definitions.opt_def_index(id) {\n-                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-                } else {\n-                    bug!(\"called HirMap::read() with invalid NodeId\")\n-                }\n+                bug!(\"called HirMap::read() with invalid NodeId\")\n             }\n         }\n     }\n@@ -805,7 +802,7 @@ impl<'hir> Map<'hir> {\n             NodeTraitItem(ti) => ti.name,\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.name,\n-            NodeLifetime(lt) => lt.name,\n+            NodeLifetime(lt) => lt.name.name(),\n             NodeTyParam(tp) => tp.name,\n             NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n@@ -875,20 +872,11 @@ impl<'hir> Map<'hir> {\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n+            Some(EntryMacroDef(_, macro_def)) => macro_def.span,\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n-                // Some nodes, notably macro definitions, are not\n-                // present in the map for whatever reason, but\n-                // they *do* have def-ids. So if we encounter an\n-                // empty hole, check for that case.\n-                if let Some(def_index) = self.definitions.opt_def_index(id) {\n-                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-                    DUMMY_SP\n-                } else {\n-                    bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n-                }\n+                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n         }\n     }\n@@ -1012,15 +1000,22 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub fn map_crate<'hir>(forest: &'hir mut Forest,\n+pub fn map_crate<'hir>(sess: &::session::Session,\n+                       cstore: &::middle::cstore::CrateStore,\n+                       forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let map = {\n+        let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+\n         let mut collector = NodeCollector::root(&forest.krate,\n                                                 &forest.dep_graph,\n-                                                &definitions);\n+                                                &definitions,\n+                                                hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n-        collector.into_map()\n+\n+        let crate_disambiguator = sess.local_crate_disambiguator().as_str();\n+        collector.finalize_and_compute_crate_hash(&crate_disambiguator)\n     };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n@@ -1103,6 +1098,7 @@ impl<'a> print::State<'a> {\n             // printing.\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n             NodeLocal(a)       => self.print_local_decl(&a),\n+            NodeMacroDef(_)    => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1219,6 +1215,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n+        Some(NodeMacroDef(_)) => {\n+            format!(\"macro {}{}\",  path_str(), id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "9bfedd7a381cb72d16bfbfaab95e9c0077ff9004", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 75, "deletions": 11, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -145,7 +145,27 @@ pub struct Lifetime {\n     /// HIR lowering inserts these placeholders in type paths that\n     /// refer to type definitions needing lifetime parameters,\n     /// `&T` and `&mut T`, and trait objects without `... + 'a`.\n-    pub name: Name,\n+    pub name: LifetimeName,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum LifetimeName {\n+    Implicit,\n+    Underscore,\n+    Static,\n+    Name(Name),\n+}\n+\n+impl LifetimeName {\n+    pub fn name(&self) -> Name {\n+        use self::LifetimeName::*;\n+        match *self {\n+            Implicit => keywords::Invalid.name(),\n+            Underscore => Symbol::intern(\"'_\"),\n+            Static => keywords::StaticLifetime.name(),\n+            Name(name) => name,\n+        }\n+    }\n }\n \n impl fmt::Debug for Lifetime {\n@@ -159,11 +179,15 @@ impl fmt::Debug for Lifetime {\n \n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n-        self.name == keywords::Invalid.name()\n+        use self::LifetimeName::*;\n+        match self.name {\n+            Implicit | Underscore => true,\n+            Static | Name(_) => false,\n+        }\n     }\n \n     pub fn is_static(&self) -> bool {\n-        self.name == \"'static\"\n+        self.name == LifetimeName::Static\n     }\n }\n \n@@ -212,17 +236,49 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: PathParameters,\n+    pub parameters: Option<P<PathParameters>>,\n+\n+    /// Whether to infer remaining type parameters, if any.\n+    /// This only applies to expression and pattern paths, and\n+    /// out of those only the segments with no type parameters\n+    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    pub infer_types: bool,\n }\n \n impl PathSegment {\n     /// Convert an identifier to the corresponding segment.\n     pub fn from_name(name: Name) -> PathSegment {\n         PathSegment {\n             name,\n-            parameters: PathParameters::none()\n+            infer_types: true,\n+            parameters: None\n+        }\n+    }\n+\n+    pub fn new(name: Name, parameters: PathParameters, infer_types: bool) -> Self {\n+        PathSegment {\n+            name,\n+            infer_types,\n+            parameters: if parameters.is_empty() {\n+                None\n+            } else {\n+                Some(P(parameters))\n+            }\n         }\n     }\n+\n+    // FIXME: hack required because you can't create a static\n+    // PathParameters, so you can't just return a &PathParameters.\n+    pub fn with_parameters<F, R>(&self, f: F) -> R\n+        where F: FnOnce(&PathParameters) -> R\n+    {\n+        let dummy = PathParameters::none();\n+        f(if let Some(ref params) = self.parameters {\n+            &params\n+        } else {\n+            &dummy\n+        })\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -231,11 +287,6 @@ pub struct PathParameters {\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: HirVec<P<Ty>>,\n-    /// Whether to infer remaining type parameters, if any.\n-    /// This only applies to expression and pattern paths, and\n-    /// out of those only the segments with no type parameters\n-    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n-    pub infer_types: bool,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n@@ -250,12 +301,16 @@ impl PathParameters {\n         Self {\n             lifetimes: HirVec::new(),\n             types: HirVec::new(),\n-            infer_types: true,\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty() &&\n+            self.bindings.is_empty() && !self.parenthesized\n+    }\n+\n     pub fn inputs(&self) -> &[P<Ty>] {\n         if self.parenthesized {\n             if let Some(ref ty) = self.types.get(0) {\n@@ -296,6 +351,7 @@ pub struct TyParam {\n     pub default: Option<P<Ty>>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n+    pub synthetic: Option<SyntheticTyParamKind>,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -364,6 +420,13 @@ impl Generics {\n     }\n }\n \n+/// Synthetic Type Parameters are converted to an other form during lowering, this allows\n+/// to track the original form they had. Usefull for error messages.\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum SyntheticTyParamKind {\n+    ImplTrait\n+}\n+\n /// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n@@ -1330,6 +1393,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n+    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Ty {"}, {"sha": "5daffe667fde5c51cae388b2a6afbd164f060b46", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1213,11 +1213,17 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n-        if !segment.parameters.lifetimes.is_empty() ||\n-                !segment.parameters.types.is_empty() ||\n-                !segment.parameters.bindings.is_empty() {\n-            self.print_path_parameters(&segment.parameters, true)?;\n-        }\n+\n+        segment.with_parameters(|parameters| {\n+            if !parameters.lifetimes.is_empty() ||\n+                !parameters.types.is_empty() ||\n+                !parameters.bindings.is_empty()\n+            {\n+                self.print_path_parameters(&parameters, segment.infer_types, true)\n+            } else {\n+                Ok(())\n+            }\n+        })?;\n         self.print_call_post(base_args)\n     }\n \n@@ -1564,8 +1570,12 @@ impl<'a> State<'a> {\n             }\n             if segment.name != keywords::CrateRoot.name() &&\n                segment.name != keywords::DollarCrate.name() {\n-                self.print_name(segment.name)?;\n-                self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+               self.print_name(segment.name)?;\n+               segment.with_parameters(|parameters| {\n+                   self.print_path_parameters(parameters,\n+                                              segment.infer_types,\n+                                              colons_before_params)\n+               })?;\n             }\n         }\n \n@@ -1593,29 +1603,42 @@ impl<'a> State<'a> {\n                     if segment.name != keywords::CrateRoot.name() &&\n                        segment.name != keywords::DollarCrate.name() {\n                         self.print_name(segment.name)?;\n-                        self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                        segment.with_parameters(|parameters| {\n+                            self.print_path_parameters(parameters,\n+                                                       segment.infer_types,\n+                                                       colons_before_params)\n+                        })?;\n                     }\n                 }\n \n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n                 self.print_name(item_segment.name)?;\n-                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+                item_segment.with_parameters(|parameters| {\n+                    self.print_path_parameters(parameters,\n+                                               item_segment.infer_types,\n+                                               colons_before_params)\n+                })\n             }\n             hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n                 self.s.word(\"<\")?;\n                 self.print_type(qself)?;\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 self.print_name(item_segment.name)?;\n-                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+                item_segment.with_parameters(|parameters| {\n+                    self.print_path_parameters(parameters,\n+                                               item_segment.infer_types,\n+                                               colons_before_params)\n+                })\n             }\n         }\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n+                             infer_types: bool,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if parameters.parenthesized {\n@@ -1652,7 +1675,7 @@ impl<'a> State<'a> {\n \n             // FIXME(eddyb) This would leak into error messages, e.g.:\n             // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n-            if parameters.infer_types && false {\n+            if infer_types && false {\n                 start_or_comma(self)?;\n                 self.s.word(\"..\")?;\n             }\n@@ -1975,7 +1998,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n-        self.print_name(lifetime.name)\n+        self.print_name(lifetime.name.name())\n     }\n \n     pub fn print_lifetime_def(&mut self, lifetime: &hir::LifetimeDef) -> io::Result<()> {"}, {"sha": "e393459027859a741d86de7ff4ec63dd2bcad3a4", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -22,6 +22,7 @@ struct CacheEntry {\n     file_index: usize,\n }\n \n+#[derive(Clone)]\n pub struct CachingCodemapView<'cm> {\n     codemap: &'cm CodeMap,\n     line_cache: [CacheEntry; 3],"}, {"sha": "e7a26e14db5bbb6349a8b3c53295c266390f0987", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -43,6 +43,7 @@ thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n+#[derive(Clone)]\n pub struct StableHashingContext<'gcx> {\n     sess: &'gcx Session,\n     definitions: &'gcx Definitions,\n@@ -168,6 +169,11 @@ impl<'gcx> StableHashingContext<'gcx> {\n         self.definitions.def_path_hash(def_index)\n     }\n \n+    #[inline]\n+    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.definitions.node_to_hir_id(node_id)\n+    }\n+\n     #[inline]\n     pub fn hash_spans(&self) -> bool {\n         self.hash_spans\n@@ -259,6 +265,18 @@ impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n     }\n }\n \n+\n+impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n+    type ContextType = StableHashingContext<'gcx>;\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        self.clone()\n+    }\n+}\n+\n+impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+}\n+\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "776f85cf5da96accb66543bb23c75e7b580f5d9c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -123,6 +123,13 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n     }\n }\n \n+impl_stable_hash_for!(enum hir::LifetimeName {\n+    Implicit,\n+    Underscore,\n+    Static,\n+    Name(name)\n+});\n+\n impl_stable_hash_for!(struct hir::Lifetime {\n     id,\n     span,\n@@ -143,13 +150,13 @@ impl_stable_hash_for!(struct hir::Path {\n \n impl_stable_hash_for!(struct hir::PathSegment {\n     name,\n+    infer_types,\n     parameters\n });\n \n impl_stable_hash_for!(struct hir::PathParameters {\n     lifetimes,\n     types,\n-    infer_types,\n     bindings,\n     parenthesized\n });\n@@ -170,7 +177,8 @@ impl_stable_hash_for!(struct hir::TyParam {\n     bounds,\n     default,\n     span,\n-    pure_wrt_drop\n+    pure_wrt_drop,\n+    synthetic\n });\n \n impl_stable_hash_for!(struct hir::Generics {\n@@ -180,6 +188,10 @@ impl_stable_hash_for!(struct hir::Generics {\n     span\n });\n \n+impl_stable_hash_for!(enum hir::SyntheticTyParamKind {\n+    ImplTrait\n+});\n+\n impl_stable_hash_for!(struct hir::WhereClause {\n     id,\n     predicates\n@@ -238,6 +250,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 id: _,\n+                hir_id: _,\n                 ref node,\n                 ref span,\n             } = *self;\n@@ -691,7 +704,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref attrs,\n@@ -700,7 +713,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n@@ -725,7 +737,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref vis,\n@@ -736,7 +748,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n@@ -1160,6 +1171,25 @@ for hir::TraitCandidate {\n     }\n }\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n+    type KeyType = (DefPathHash, Option<(DefPathHash, hir::ItemLocalId)>);\n+\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'gcx>)\n+                          -> Self::KeyType {\n+        let hir::TraitCandidate {\n+            def_id,\n+            import_id,\n+        } = *self;\n+\n+        let import_id = import_id.map(|node_id| hcx.node_to_hir_id(node_id))\n+                                 .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner),\n+                                                hir_id.local_id));\n+        (hcx.def_path_hash(def_id), import_id)\n+    }\n+}\n+\n+\n impl_stable_hash_for!(struct hir::Freevar {\n     def,\n     span"}, {"sha": "4bda89690b7a9b8a1c64498e4a6420295babb95c", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -28,10 +28,12 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     name,\n     source_info,\n     internal,\n+    lexical_scope,\n     is_user_variable\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, lint_node_id });\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::Terminator<'gcx> {\n@@ -75,6 +77,22 @@ for mir::Terminator<'gcx> {\n     }\n }\n \n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearOnDecode<T>\n+    where T: HashStable<StableHashingContext<'gcx>>\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            mir::ClearOnDecode::Clear => {}\n+            mir::ClearOnDecode::Set(ref value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n     #[inline]\n@@ -347,6 +365,26 @@ for mir::ProjectionElem<'gcx, V, T>\n }\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n+impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n+    lint_root, safety\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Safety::Safe |\n+            mir::Safety::BuiltinUnsafe |\n+            mir::Safety::FnUnsafe => {}\n+            mir::Safety::ExplicitUnsafe(node_id) => {\n+                node_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "669e1ba773e2384de512b9f0edd379e231af5834", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -272,6 +272,8 @@ fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n         token::Token::Dot |\n         token::Token::DotDot |\n         token::Token::DotDotDot |\n+        token::Token::DotDotEq |\n+        token::Token::DotEq |\n         token::Token::Comma |\n         token::Token::Semi |\n         token::Token::Colon |"}, {"sha": "fe060aaf4269e5ce6f55525d2bc16a3b8c866866", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -463,7 +463,8 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     index,\n     has_default,\n     object_lifetime_default,\n-    pure_wrt_drop\n+    pure_wrt_drop,\n+    synthetic\n });\n \n impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n@@ -514,13 +515,8 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(enum ::middle::region::Scope {\n-    Node(local_id),\n-    Destruction(local_id),\n-    CallSite(local_id),\n-    Arguments(local_id),\n-    Remainder(block_remainder)\n-});\n+impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { idx });\n+impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n     type KeyType = region::Scope;"}, {"sha": "ee30db26255198ad1b3b361b17b06fd1ad5aa587", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,6 +18,7 @@ use infer::region_inference::RegionResolutionError;\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use infer::error_reporting::util::AnonymousArgInfo;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method prints the error message for lifetime errors when both the concerned regions\n@@ -57,6 +58,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+\n         debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n                ty_sub,\n                sup,\n@@ -66,56 +68,70 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                sub,\n                bregion_sub);\n \n-        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_region(sup, sup), self.find_arg_with_region(sub, sub)) {\n+        let (ty_sup, ty_fndecl_sup) = ty_sup;\n+        let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-            let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n-                (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n-            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n-               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n-                return false;\n-            }\n+        let AnonymousArgInfo { arg: anon_arg_sup, .. } =\n+            or_false!(self.find_arg_with_region(sup, sup));\n+        let AnonymousArgInfo { arg: anon_arg_sub, .. } =\n+            or_false!(self.find_arg_with_region(sub, sub));\n \n-            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n-               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n-                return false;\n-            }\n+        let sup_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n+        let sub_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-            if anon_arg_sup == anon_arg_sub {\n-                (format!(\"this type was declared with multiple lifetimes...\"),\n-                 format!(\" with one lifetime\"),\n-                 format!(\" into the other\"))\n-            } else {\n-                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n-                    format!(\" from `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n+        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+            format!(\" from `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+            format!(\" into `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+\n+        let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n+            (None, None) => {\n+                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n \n-                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n-                    format!(\" into `{}`\", simple_name)\n+                    (format!(\"this type is declared with multiple lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             format!(\" with one lifetime\"),\n+                             format!(\" into the other\")))\n                 } else {\n-                    format!(\"\")\n+                    (format!(\"these two types are declared with different lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             span_label_var1,\n+                             span_label_var2))\n                 };\n+                (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n+            }\n \n-                let span_label =\n-                    format!(\"these two types are declared with different lifetimes...\",);\n-\n-                (span_label, span_label_var1, span_label_var2)\n+            (Some(ret_span), _) => {\n+                (ty_sub.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared \\\n+                          with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n+            }\n+            (_, Some(ret_span)) => {\n+                (ty_sup.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared \\\n+                          with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n             }\n-        } else {\n-            debug!(\"no arg with anon region found\");\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sub) = {:?}\",\n-                   self.is_suitable_region(sub));\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sup) = {:?}\",\n-                   self.is_suitable_region(sup));\n-            return false;\n         };\n \n+\n         struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(ty_sup.span, main_label)\n-            .span_label(ty_sub.span, format!(\"\"))\n-            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .span_label(span_1, main_label)\n+            .span_label(span_2, format!(\"\"))\n+            .span_label(span, span_label)\n             .emit();\n         return true;\n     }\n@@ -135,28 +151,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+    pub fn find_anon_type(&self,\n+                          region: Region<'tcx>,\n+                          br: &ty::BoundRegion)\n+                          -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let inputs: &[_] = match self.tcx.hir.get(node_id) {\n+                let fndecl = match self.tcx.hir.get(node_id) {\n                     hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n-                        &fndecl.inputs\n+                        &fndecl\n                     }\n                     hir_map::NodeTraitItem(&hir::TraitItem {\n-                                               node: hir::TraitItemKind::Method(ref fndecl, ..), ..\n-                                           }) => &fndecl.decl.inputs,\n+                                               node: hir::TraitItemKind::Method(ref m, ..), ..\n+                                           }) |\n                     hir_map::NodeImplItem(&hir::ImplItem {\n-                                              node: hir::ImplItemKind::Method(ref fndecl, ..), ..\n-                                          }) => &fndecl.decl.inputs,\n-\n-                    _ => &[],\n+                                              node: hir::ImplItemKind::Method(ref m, ..), ..\n+                                          }) => &m.decl,\n+                    _ => return None,\n                 };\n \n-                return inputs\n+                return fndecl\n+                           .inputs\n                            .iter()\n-                           .filter_map(|arg| self.find_component_for_bound_region(&**arg, br))\n-                           .next();\n+                           .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n+                           .next()\n+                           .map(|ty| (ty, &**fndecl));\n             }\n         }\n         None"}, {"sha": "3f22950fc773f3d07fdd0ae0a3f6190146100330", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 80, "deletions": 19, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -72,6 +72,8 @@ use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n mod note;\n \n mod need_type_info;\n@@ -152,21 +154,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match scope {\n-                    region::Scope::Node(_) => tag,\n-                    region::Scope::CallSite(_) => {\n+                let scope_decorated_tag = match scope.data() {\n+                    region::ScopeData::Node(_) => tag,\n+                    region::ScopeData::CallSite(_) => {\n                         \"scope of call-site for function\"\n                     }\n-                    region::Scope::Arguments(_) => {\n+                    region::ScopeData::Arguments(_) => {\n                         \"scope of function body\"\n                     }\n-                    region::Scope::Destruction(_) => {\n+                    region::ScopeData::Destruction(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::Scope::Remainder(r) => {\n+                    region::ScopeData::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n-                                             r.first_statement_index);\n+                                             r.first_statement_index.index());\n                         &new_string[..]\n                     }\n                 };\n@@ -333,11 +335,20 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             GenericBoundFailure(..) => true,\n         };\n \n-        if errors.iter().all(|e| is_bound_failure(e)) {\n+\n+        let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n             errors.clone()\n         } else {\n             errors.iter().filter(|&e| !is_bound_failure(e)).cloned().collect()\n-        }\n+        };\n+\n+        // sort the errors by span, for better error message stability.\n+        errors.sort_by_key(|u| match *u {\n+            ConcreteFailure(ref sro, _, _) => sro.span(),\n+            GenericBoundFailure(ref sro, _, _) => sro.span(),\n+            SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n+        });\n+        errors\n     }\n \n     /// Adds a note if the types come from similarly named crates\n@@ -774,10 +785,44 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     bound_kind: GenericKind<'tcx>,\n                                     sub: Region<'tcx>)\n     {\n-        // FIXME: it would be better to report the first error message\n-        // with the span of the parameter itself, rather than the span\n-        // where the error was detected. But that span is not readily\n-        // accessible.\n+        // Attempt to obtain the span of the parameter so we can\n+        // suggest adding an explicit lifetime bound to it.\n+        let type_param_span = match (self.in_progress_tables, bound_kind) {\n+            (Some(ref table), GenericKind::Param(ref param)) => {\n+                let table = table.borrow();\n+                table.local_id_root.and_then(|did| {\n+                    let generics = self.tcx.generics_of(did);\n+                    // Account for the case where `did` corresponds to `Self`, which doesn't have\n+                    // the expected type argument.\n+                    if generics.types.len() > 0 {\n+                        let type_param = generics.type_param(param);\n+                        let hir = &self.tcx.hir;\n+                        hir.as_local_node_id(type_param.def_id).map(|id| {\n+                            // Get the `hir::TyParam` to verify wether it already has any bounds.\n+                            // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n+                            // instead we suggest `T: 'a + 'b` in that case.\n+                            let has_lifetimes = if let hir_map::NodeTyParam(ref p) = hir.get(id) {\n+                                p.bounds.len() > 0\n+                            } else {\n+                                false\n+                            };\n+                            let sp = hir.span(id);\n+                            // `sp` only covers `T`, change it so that it covers\n+                            // `T:` when appropriate\n+                            let sp = if has_lifetimes {\n+                                sp.to(sp.next_point().next_point())\n+                            } else {\n+                                sp\n+                            };\n+                            (sp, has_lifetimes)\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None,\n+        };\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) =>\n@@ -799,6 +844,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n+        fn binding_suggestion<'tcx, S: fmt::Display>(err: &mut DiagnosticBuilder<'tcx>,\n+                                                     type_param_span: Option<(Span, bool)>,\n+                                                     bound_kind: GenericKind<'tcx>,\n+                                                     sub: S) {\n+            let consider = &format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n+                                    bound_kind,\n+                                    sub);\n+            if let Some((sp, has_lifetimes)) = type_param_span {\n+                let tail = if has_lifetimes {\n+                    \" + \"\n+                } else {\n+                    \"\"\n+                };\n+                let suggestion = format!(\"{}: {}{}\", bound_kind, sub, tail);\n+                err.span_suggestion_short(sp, consider, suggestion);\n+            } else {\n+                err.help(consider);\n+            }\n+        }\n+\n         let mut err = match *sub {\n             ty::ReEarlyBound(_) |\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n@@ -808,9 +873,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0309,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.help(&format!(\"consider adding an explicit lifetime bound `{}: {}`...\",\n-                         bound_kind,\n-                         sub));\n+                binding_suggestion(&mut err, type_param_span, bound_kind, sub);\n                 err\n             }\n \n@@ -821,9 +884,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0310,\n                                                \"{} may not live long enough\",\n                                                labeled_user_string);\n-                err.help(&format!(\"consider adding an explicit lifetime \\\n-                                   bound `{}: 'static`...\",\n-                                  bound_kind));\n+                binding_suggestion(&mut err, type_param_span, bound_kind, \"'static\");\n                 err\n             }\n "}, {"sha": "80fb4ce8e039260fc7933e0b4bfd37bcc94d2193", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -35,15 +35,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon_arg_info, region_info) =\n+        let (named, anon, anon_arg_info, region_info) =\n             if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n                self.find_arg_with_region(sup, sub).is_some() {\n                 (sub,\n+                 sup,\n                  self.find_arg_with_region(sup, sub).unwrap(),\n                  self.is_suitable_region(sup).unwrap())\n             } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n                       self.find_arg_with_region(sub, sup).is_some() {\n                 (sup,\n+                 sub,\n                  self.find_arg_with_region(sub, sup).unwrap(),\n                  self.is_suitable_region(sub).unwrap())\n             } else {\n@@ -76,33 +78,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return false;\n         }\n \n-        if self.is_return_type_anon(scope_def_id, br) {\n-            debug!(\"try_report_named_anon_conflict: is_return_type_anon({:?}, {:?}) = true\",\n-                   scope_def_id,\n-                   br);\n-            return false;\n-        } else if self.is_self_anon(is_first, scope_def_id) {\n-            debug!(\"try_report_named_anon_conflict: is_self_anon({:?}, {:?}) = true\",\n-                   is_first,\n-                   scope_def_id);\n-            return false;\n+        if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n+            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some() ||\n+               self.is_self_anon(is_first, scope_def_id) {\n+                return false;\n+            }\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n         } else {\n-            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n-            } else {\n-                (\"parameter type\".to_owned(), \"type\".to_owned())\n-            };\n+            (\"parameter type\".to_owned(), \"type\".to_owned())\n+        };\n+\n+        struct_span_err!(self.tcx.sess,\n+                         span,\n+                         E0621,\n+                         \"explicit lifetime required in {}\",\n+                         error_var)\n+                .span_label(arg.pat.span,\n+                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                .span_label(span, format!(\"lifetime `{}` required\", named))\n+                .emit();\n+        return true;\n \n-            struct_span_err!(self.tcx.sess,\n-                             span,\n-                             E0621,\n-                             \"explicit lifetime required in {}\",\n-                             error_var)\n-                    .span_label(arg.pat.span,\n-                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                    .span_label(span, format!(\"lifetime `{}` required\", named))\n-                    .emit();\n-            return true;\n-        }\n     }\n }"}, {"sha": "47db3f1b7926af1aa38c3b0991edb795cfe6f987", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,6 +15,7 @@ use infer::InferCtxt;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n+use syntax_pos::Span;\n \n macro_rules! or_false {\n      ($v:expr) => {\n@@ -163,20 +164,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n-    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+    pub fn is_return_type_anon(&self,\n+                               scope_def_id: DefId,\n+                               br: ty::BoundRegion,\n+                               decl: &hir::FnDecl)\n+                               -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::TyFnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let late_bound_regions = self.tcx\n                     .collect_referenced_late_bound_regions(&sig.output());\n                 if late_bound_regions.iter().any(|r| *r == br) {\n-                    return true;\n+                    return Some(decl.output.span());\n                 }\n             }\n             _ => {}\n         }\n-        false\n+        None\n     }\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312."}, {"sha": "1e90aa47267ff18b5388dd9182bccc5ca07f0536", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -111,7 +111,6 @@ pub mod middle {\n     pub mod dataflow;\n     pub mod dead;\n     pub mod dependency_format;\n-    pub mod effect;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;"}, {"sha": "5fe75d8ca71e38df9b8a2cd1c54665679d5775b6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -30,7 +30,7 @@ declare_lint! {\n \n declare_lint! {\n     pub UNUSED_EXTERN_CRATES,\n-    Warn,\n+    Allow,\n     \"extern crates that are never used\"\n }\n "}, {"sha": "4bc37747f2a76b1dc01c4c3ad23fedf0727b0f04", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -384,6 +384,11 @@ impl LintLevelMap {\n             self.sets.get_lint_level(lint, *idx, None)\n         })\n     }\n+\n+    /// Returns if this `id` has lint level information.\n+    pub fn lint_level_set(&self, id: HirId) -> Option<u32> {\n+        self.id_to_set.get(&id).cloned()\n+    }\n }\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {"}, {"sha": "a97bfa0536987398acae30741c2738ccb3ccbb3d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -267,6 +267,8 @@ pub trait CrateStore {\n     fn export_macros_untracked(&self, cnum: CrateNum);\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind;\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol;\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh;\n     fn struct_field_names_untracked(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n     fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -336,6 +338,10 @@ impl CrateStore for DummyCrateStore {\n     fn dep_kind_untracked(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n     fn export_macros_untracked(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n     fn crate_name_untracked(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol {\n+        bug!(\"crate_disambiguator\")\n+    }\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey { bug!(\"def_key\") }"}, {"sha": "a9d9f6f28ec0d3cb8f8a36caf214b4c45c38b469", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -553,9 +553,22 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         if self.should_warn_about_item(item) {\n+            // For items that have a definition with a signature followed by a\n+            // block, point only at the signature.\n+            let span = match item.node {\n+                hir::ItemFn(..) |\n+                hir::ItemMod(..) |\n+                hir::ItemEnum(..) |\n+                hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n+                hir::ItemTrait(..) |\n+                hir::ItemDefaultImpl(..) |\n+                hir::ItemImpl(..) => self.tcx.sess.codemap().def_span(item.span),\n+                _ => item.span,\n+            };\n             self.warn_dead_code(\n                 item.id,\n-                item.span,\n+                span,\n                 item.name,\n                 item.node.descriptive_variant()\n             );\n@@ -570,8 +583,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      id: ast::NodeId) {\n         if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.data.id(), variant.span,\n-                                variant.node.name, \"variant\");\n+            self.warn_dead_code(variant.node.data.id(), variant.span, variant.node.name, \"variant\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);\n         }\n@@ -596,15 +608,17 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n-                    self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.name, \"associated const\");\n+                    self.warn_dead_code(impl_item.id,\n+                                        impl_item.span,\n+                                        impl_item.name,\n+                                        \"associated const\");\n                 }\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n-                    self.warn_dead_code(impl_item.id, impl_item.span,\n-                                        impl_item.name, \"method\");\n+                    let span = self.tcx.sess.codemap().def_span(impl_item.span);\n+                    self.warn_dead_code(impl_item.id, span, impl_item.name, \"method\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "db0ecb6aa5eb1d624315e9f478530666b6d50c12", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -112,52 +112,61 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Vec::new();\n     }\n \n-    match ty {\n-        // If the global prefer_dynamic switch is turned off, first attempt\n-        // static linkage (this can fail).\n-        config::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic => {\n-            if let Some(v) = attempt_static(tcx) {\n-                return v;\n-            }\n-        }\n+    let preferred_linkage = match ty {\n+        // cdylibs must have all static dependencies.\n+        config::CrateTypeCdylib => Linkage::Static,\n+\n+        // Generating a dylib without `-C prefer-dynamic` means that we're going\n+        // to try to eagerly statically link all dependencies. This is normally\n+        // done for end-product dylibs, not intermediate products.\n+        config::CrateTypeDylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        config::CrateTypeDylib => Linkage::Dynamic,\n+\n+        // If the global prefer_dynamic switch is turned off, or the final\n+        // executable will be statically linked, prefer static crate linkage.\n+        config::CrateTypeExecutable if !sess.opts.cg.prefer_dynamic ||\n+            sess.crt_static() => Linkage::Static,\n+        config::CrateTypeExecutable => Linkage::Dynamic,\n+\n+        // proc-macro crates are required to be dylibs, and they're currently\n+        // required to link to libsyntax as well.\n+        config::CrateTypeProcMacro => Linkage::Dynamic,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        config::CrateTypeRlib => return Vec::new(),\n-\n-        // Staticlibs and cdylibs must have all static dependencies. If any fail\n-        // to be found, we generate some nice pretty errors.\n-        config::CrateTypeStaticlib |\n-        config::CrateTypeCdylib => {\n-            if let Some(v) = attempt_static(tcx) {\n-                return v;\n-            }\n+        config::CrateTypeRlib => Linkage::NotLinked,\n+\n+        // staticlibs must have all static dependencies.\n+        config::CrateTypeStaticlib => Linkage::Static,\n+    };\n+\n+    if preferred_linkage == Linkage::NotLinked {\n+        // If the crate is not linked, there are no link-time dependencies.\n+        return Vec::new();\n+    }\n+\n+    if preferred_linkage == Linkage::Static {\n+        // Attempt static linkage first. For dylibs and executables, we may be\n+        // able to retry below with dynamic linkage.\n+        if let Some(v) = attempt_static(tcx) {\n+            return v;\n+        }\n+\n+        // Staticlibs, cdylibs, and static executables must have all static\n+        // dependencies. If any are not found, generate some nice pretty errors.\n+        if ty == config::CrateTypeCdylib || ty == config::CrateTypeStaticlib ||\n+                (ty == config::CrateTypeExecutable && sess.crt_static() &&\n+                !sess.target.target.options.crt_static_allows_dylibs) {\n             for &cnum in tcx.crates().iter() {\n                 if tcx.dep_kind(cnum).macros_only() { continue }\n                 let src = tcx.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n-                sess.err(&format!(\"dependency `{}` not found in rlib format\",\n+                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n+                                  but was not found in this form\",\n                                   tcx.crate_name(cnum)));\n             }\n             return Vec::new();\n         }\n-\n-        // Generating a dylib without `-C prefer-dynamic` means that we're going\n-        // to try to eagerly statically link all dependencies. This is normally\n-        // done for end-product dylibs, not intermediate products.\n-        config::CrateTypeDylib if !sess.opts.cg.prefer_dynamic => {\n-            if let Some(v) = attempt_static(tcx) {\n-                return v;\n-            }\n-        }\n-\n-        // Everything else falls through below. This will happen either with the\n-        // `-C prefer-dynamic` or because we're a proc-macro crate. Note that\n-        // proc-macro crates are required to be dylibs, and they're currently\n-        // required to link to libsyntax as well.\n-        config::CrateTypeExecutable |\n-        config::CrateTypeDylib |\n-        config::CrateTypeProcMacro => {},\n     }\n \n     let mut formats = FxHashMap();\n@@ -236,10 +245,9 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     Linkage::Static => \"rlib\",\n                     _ => \"dylib\",\n                 };\n-                let name = tcx.crate_name(cnum);\n-                sess.err(&format!(\"crate `{}` required to be available in {}, \\\n-                                  but it was not available in this form\",\n-                                  name, kind));\n+                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n+                                  but was not found in this form\",\n+                                  tcx.crate_name(cnum), kind));\n             }\n         }\n     }"}, {"sha": "7290353e48b0c379b04756512b6e84bfc80f7e12", "filename": "src/librustc/middle/effect.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=d9d877221f65b26e52f49bfc639ef705ff396deb", "patch": "@@ -1,316 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Enforces the Rust effect system. Currently there is just one effect,\n-//! `unsafe`.\n-use self::RootUnsafeContext::*;\n-\n-use ty::{self, TyCtxt};\n-use lint;\n-use lint::builtin::UNUSED_UNSAFE;\n-\n-use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n-use hir::{self, PatKind};\n-use syntax::ast;\n-use syntax_pos::Span;\n-use util::nodemap::FxHashSet;\n-\n-#[derive(Copy, Clone)]\n-struct UnsafeContext {\n-    push_unsafe_count: usize,\n-    root: RootUnsafeContext,\n-}\n-\n-impl UnsafeContext {\n-    fn new(root: RootUnsafeContext) -> UnsafeContext {\n-        UnsafeContext { root: root, push_unsafe_count: 0 }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RootUnsafeContext {\n-    SafeContext,\n-    UnsafeFn,\n-    UnsafeBlock(ast::NodeId),\n-}\n-\n-struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    body_id: hir::BodyId,\n-\n-    /// Whether we're in an unsafe context.\n-    unsafe_context: UnsafeContext,\n-    used_unsafe: FxHashSet<ast::NodeId>,\n-}\n-\n-impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n-    fn require_unsafe_ext(&mut self, node_id: ast::NodeId, span: Span,\n-                          description: &str, is_lint: bool) {\n-        if self.unsafe_context.push_unsafe_count > 0 { return; }\n-        match self.unsafe_context.root {\n-            SafeContext => {\n-                if is_lint {\n-                    self.tcx.lint_node(lint::builtin::SAFE_EXTERN_STATICS,\n-                                       node_id,\n-                                       span,\n-                                       &format!(\"{} requires unsafe function or \\\n-                                                 block (error E0133)\", description));\n-                } else {\n-                    // Report an error.\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0133,\n-                        \"{} requires unsafe function or block\", description)\n-                        .span_label(span, description)\n-                        .emit();\n-                }\n-            }\n-            UnsafeBlock(block_id) => {\n-                // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: {}\", block_id);\n-                self.used_unsafe.insert(block_id);\n-            }\n-            UnsafeFn => {}\n-        }\n-    }\n-\n-    fn require_unsafe(&mut self, span: Span, description: &str) {\n-        self.require_unsafe_ext(ast::DUMMY_NODE_ID, span, description, false)\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        let old_body_id = self.body_id;\n-        self.tables = self.tcx.body_tables(body);\n-        self.body_id = body;\n-        let body = self.tcx.hir.body(body);\n-        self.visit_body(body);\n-        self.tables = old_tables;\n-        self.body_id = old_body_id;\n-    }\n-\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n-\n-        let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            FnKind::ItemFn(_, _, unsafety, ..) =>\n-                (true, unsafety == hir::Unsafety::Unsafe),\n-            FnKind::Method(_, sig, ..) =>\n-                (true, sig.unsafety == hir::Unsafety::Unsafe),\n-            _ => (false, false),\n-        };\n-\n-        let old_unsafe_context = self.unsafe_context;\n-        if is_unsafe_fn {\n-            self.unsafe_context = UnsafeContext::new(UnsafeFn)\n-        } else if is_item_fn {\n-            self.unsafe_context = UnsafeContext::new(SafeContext)\n-        }\n-\n-        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n-\n-        self.unsafe_context = old_unsafe_context\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        let old_unsafe_context = self.unsafe_context;\n-        match block.rules {\n-            hir::UnsafeBlock(source) => {\n-                // By default only the outermost `unsafe` block is\n-                // \"used\" and so nested unsafe blocks are pointless\n-                // (the inner ones are unnecessary and we actually\n-                // warn about them). As such, there are two cases when\n-                // we need to create a new context, when we're\n-                // - outside `unsafe` and found a `unsafe` block\n-                //   (normal case)\n-                // - inside `unsafe`, found an `unsafe` block\n-                //   created internally to the compiler\n-                //\n-                // The second case is necessary to ensure that the\n-                // compiler `unsafe` blocks don't accidentally \"use\"\n-                // external blocks (e.g. `unsafe { println(\"\") }`,\n-                // expands to `unsafe { ... unsafe { ... } }` where\n-                // the inner one is compiler generated).\n-                if self.unsafe_context.root == SafeContext || source == hir::CompilerGenerated {\n-                    self.unsafe_context.root = UnsafeBlock(block.id)\n-                }\n-            }\n-            hir::PushUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n-            }\n-            hir::PopUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n-            }\n-            hir::DefaultBlock => {}\n-        }\n-\n-        intravisit::walk_block(self, block);\n-\n-        self.unsafe_context = old_unsafe_context;\n-\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        match block.rules {\n-            hir::UnsafeBlock(hir::UserProvided) => {}\n-            _ => return,\n-        }\n-        if self.used_unsafe.contains(&block.id) {\n-            return\n-        }\n-\n-        /// Return the NodeId for an enclosing scope that is also `unsafe`\n-        fn is_enclosed(tcx: TyCtxt,\n-                       used_unsafe: &FxHashSet<ast::NodeId>,\n-                       id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-            let parent_id = tcx.hir.get_parent_node(id);\n-            if parent_id != id {\n-                if used_unsafe.contains(&parent_id) {\n-                    Some((\"block\".to_string(), parent_id))\n-                } else if let Some(hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n-                    ..\n-                })) = tcx.hir.find(parent_id) {\n-                    Some((\"fn\".to_string(), parent_id))\n-                } else {\n-                    is_enclosed(tcx, used_unsafe, parent_id)\n-                }\n-            } else {\n-                None\n-            }\n-        }\n-\n-        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n-                                                    block.id,\n-                                                    block.span,\n-                                                    \"unnecessary `unsafe` block\");\n-        db.span_label(block.span, \"unnecessary `unsafe` block\");\n-        if let Some((kind, id)) = is_enclosed(self.tcx, &self.used_unsafe, block.id) {\n-            db.span_note(self.tcx.hir.span(id),\n-                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n-        }\n-        db.emit();\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n-                let sig = self.tcx.fn_sig(def_id);\n-                debug!(\"effect: method call case, signature is {:?}\",\n-                        sig);\n-\n-                if sig.0.unsafety == hir::Unsafety::Unsafe {\n-                    self.require_unsafe(expr.span,\n-                                        \"invocation of unsafe method\")\n-                }\n-            }\n-            hir::ExprCall(ref base, _) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: call case, base type is {:?}\",\n-                        base_type);\n-                match base_type.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n-                            self.require_unsafe(expr.span, \"call to unsafe function\")\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: unary case, base type is {:?}\",\n-                        base_type);\n-                if let ty::TyRawPtr(_) = base_type.sty {\n-                    self.require_unsafe(expr.span, \"dereference of raw pointer\")\n-                }\n-            }\n-            hir::ExprInlineAsm(..) => {\n-                self.require_unsafe(expr.span, \"use of inline assembly\");\n-            }\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::Static(def_id, mutbl) = path.def {\n-                    if mutbl {\n-                        self.require_unsafe(expr.span, \"use of mutable static\");\n-                    } else if match self.tcx.hir.get_if_local(def_id) {\n-                        Some(hir::map::NodeForeignItem(..)) => true,\n-                        Some(..) => false,\n-                        None => self.tcx.is_foreign_item(def_id),\n-                    } {\n-                        self.require_unsafe_ext(expr.id, expr.span, \"use of extern static\", true);\n-                    }\n-                }\n-            }\n-            hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                    if adt.is_union() {\n-                        self.require_unsafe(field.span, \"access to union field\");\n-                    }\n-                }\n-            }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n-                if let hir::ExprField(ref base_expr, field) = lhs.node {\n-                    if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                        if adt.is_union() {\n-                            let field_ty = self.tables.expr_ty_adjusted(lhs);\n-                            let owner_def_id = self.tcx.hir.body_owner_def_id(self.body_id);\n-                            let param_env = self.tcx.param_env(owner_def_id);\n-                            if field_ty.moves_by_default(self.tcx, param_env, field.span) {\n-                                self.require_unsafe(field.span,\n-                                                    \"assignment to non-`Copy` union field\");\n-                            }\n-                            // Do not walk the field expr again.\n-                            intravisit::walk_expr(self, base_expr);\n-                            intravisit::walk_expr(self, rhs);\n-                            return\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tables.pat_ty(pat).sty {\n-                if adt.is_union() {\n-                    for field in fields {\n-                        self.require_unsafe(field.span, \"matching on union field\");\n-                    }\n-                }\n-            }\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-    }\n-}\n-\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut visitor = EffectCheckVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n-        unsafe_context: UnsafeContext::new(SafeContext),\n-        used_unsafe: FxHashSet(),\n-    };\n-\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-}"}, {"sha": "49a241b86e015046eb318be88fdca0226d101f0d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -117,7 +117,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //"}, {"sha": "679c4f17a6c03f55cc589b0f90604042a0697014", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -280,8 +280,6 @@ language_item_table! {\n     EqTraitLangItem,                 \"eq\",                      eq_trait;\n     OrdTraitLangItem,                \"ord\",                     ord_trait;\n \n-    StrEqFnLangItem,                 \"str_eq\",                  str_eq_fn;\n-\n     // A number of panic-related lang items. The `panic` item corresponds to\n     // divide-by-zero and various panic cases with `match`. The\n     // `panic_bounds_check` item is for indexing arrays."}, {"sha": "55d0c6b4c66a34338337b14eee16eb5da9cd5164", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -310,7 +310,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeVariant(_) |\n             hir_map::NodeStructCtor(_) |\n             hir_map::NodeField(_) |\n-            hir_map::NodeTy(_) => {}\n+            hir_map::NodeTy(_) |\n+            hir_map::NodeMacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "59c9e8b4c432caaf1d17e78bc5e96b7fcd0b45d6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 118, "deletions": 24, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,6 +18,7 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n+use std::fmt;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n@@ -31,6 +32,7 @@ use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n \n@@ -95,8 +97,24 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n+///\n+/// Scope is a bit-packed to save space - if `code` is SCOPE_DATA_REMAINDER_MAX\n+/// or less, it is a `ScopeData::Remainder`, otherwise it is a type specified\n+/// by the bitpacking.\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+pub struct Scope {\n+    pub(crate) id: hir::ItemLocalId,\n+    pub(crate) code: u32\n+}\n+\n+const SCOPE_DATA_NODE: u32 = !0;\n+const SCOPE_DATA_CALLSITE: u32 = !1;\n+const SCOPE_DATA_ARGUMENTS: u32 = !2;\n+const SCOPE_DATA_DESTRUCTION: u32 = !3;\n+const SCOPE_DATA_REMAINDER_MAX: u32 = !4;\n+\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n-pub enum Scope {\n+pub enum ScopeData {\n     Node(hir::ItemLocalId),\n \n     // Scope of the call-site for a function or closure\n@@ -135,7 +153,90 @@ pub enum Scope {\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: hir::ItemLocalId,\n-    pub first_statement_index: u32,\n+    pub first_statement_index: FirstStatementIndex,\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+         RustcDecodable, Copy)]\n+pub struct FirstStatementIndex { pub idx: u32 }\n+\n+impl Idx for FirstStatementIndex {\n+    fn new(idx: usize) -> Self {\n+        assert!(idx <= SCOPE_DATA_REMAINDER_MAX as usize);\n+        FirstStatementIndex { idx: idx as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.idx as usize\n+    }\n+}\n+\n+impl fmt::Debug for FirstStatementIndex {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.index(), formatter)\n+    }\n+}\n+\n+impl From<ScopeData> for Scope {\n+    #[inline]\n+    fn from(scope_data: ScopeData) -> Self {\n+        let (id, code) = match scope_data {\n+            ScopeData::Node(id) => (id, SCOPE_DATA_NODE),\n+            ScopeData::CallSite(id) => (id, SCOPE_DATA_CALLSITE),\n+            ScopeData::Arguments(id) => (id, SCOPE_DATA_ARGUMENTS),\n+            ScopeData::Destruction(id) => (id, SCOPE_DATA_DESTRUCTION),\n+            ScopeData::Remainder(r) => (r.block, r.first_statement_index.index() as u32)\n+        };\n+        Self { id, code }\n+    }\n+}\n+\n+impl fmt::Debug for Scope {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.data(), formatter)\n+    }\n+}\n+\n+#[allow(non_snake_case)]\n+impl Scope {\n+    #[inline]\n+    pub fn data(self) -> ScopeData {\n+        match self.code {\n+            SCOPE_DATA_NODE => ScopeData::Node(self.id),\n+            SCOPE_DATA_CALLSITE => ScopeData::CallSite(self.id),\n+            SCOPE_DATA_ARGUMENTS => ScopeData::Arguments(self.id),\n+            SCOPE_DATA_DESTRUCTION => ScopeData::Destruction(self.id),\n+            idx => ScopeData::Remainder(BlockRemainder {\n+                block: self.id,\n+                first_statement_index: FirstStatementIndex { idx }\n+            })\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn Node(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Node(id))\n+    }\n+\n+    #[inline]\n+    pub fn CallSite(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::CallSite(id))\n+    }\n+\n+    #[inline]\n+    pub fn Arguments(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Arguments(id))\n+    }\n+\n+    #[inline]\n+    pub fn Destruction(id: hir::ItemLocalId) -> Self {\n+        Self::from(ScopeData::Destruction(id))\n+    }\n+\n+    #[inline]\n+    pub fn Remainder(r: BlockRemainder) -> Self {\n+        Self::from(ScopeData::Remainder(r))\n+    }\n }\n \n impl Scope {\n@@ -144,16 +245,7 @@ impl Scope {\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn item_local_id(&self) -> hir::ItemLocalId {\n-        match *self {\n-            Scope::Node(id) => id,\n-\n-            // These cases all return rough approximations to the\n-            // precise scope denoted by `self`.\n-            Scope::Remainder(br) => br.block,\n-            Scope::Destruction(id) |\n-            Scope::CallSite(id) |\n-            Scope::Arguments(id) => id,\n-        }\n+        self.id\n     }\n \n     pub fn node_id(&self, tcx: TyCtxt, scope_tree: &ScopeTree) -> ast::NodeId {\n@@ -177,7 +269,7 @@ impl Scope {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let Scope::Remainder(r) = *self {\n+        if let ScopeData::Remainder(r) = self.data() {\n             if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n@@ -187,7 +279,7 @@ impl Scope {\n                 // (This is the special case aluded to in the\n                 // doc-comment for this method)\n \n-                let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n+                let stmt_span = blk.stmts[r.first_statement_index.index()].span;\n \n                 // To avoid issues with macro-generated spans, the span\n                 // of the statement must be nested in that of the block.\n@@ -201,7 +293,7 @@ impl Scope {\n }\n \n /// The region scope tree encodes information about region relationships.\n-#[derive(Default)]\n+#[derive(Default, Debug)]\n pub struct ScopeTree {\n     /// If not empty, this body is the root of this region hierarchy.\n     root_body: Option<hir::HirId>,\n@@ -387,7 +479,7 @@ impl<'tcx> ScopeTree {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let Scope::Destruction(n) = child {\n+        if let ScopeData::Destruction(n) = child.data() {\n             self.destruction_scopes.insert(n, child);\n         }\n     }\n@@ -482,8 +574,8 @@ impl<'tcx> ScopeTree {\n         let mut id = Scope::Node(expr_id);\n \n         while let Some(&p) = self.parent_map.get(&id) {\n-            match p {\n-                Scope::Destruction(..) => {\n+            match p.data() {\n+                ScopeData::Destruction(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -573,9 +665,9 @@ impl<'tcx> ScopeTree {\n             // infer::region_inference for more details.\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n-            return match (a_root_scope, b_root_scope) {\n-                (Scope::Destruction(a_root_id),\n-                 Scope::Destruction(b_root_id)) => {\n+            return match (a_root_scope.data(), b_root_scope.data()) {\n+                (ScopeData::Destruction(a_root_id),\n+                 ScopeData::Destruction(b_root_id)) => {\n                     if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -764,7 +856,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 visitor.enter_scope(\n                     Scope::Remainder(BlockRemainder {\n                         block: blk.hir_id.local_id,\n-                        first_statement_index: i as u32\n+                        first_statement_index: FirstStatementIndex::new(i)\n                     })\n                 );\n                 visitor.cx.var_parent = visitor.cx.parent;\n@@ -915,8 +1007,10 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n-                Some(&Scope::CallSite(_)) => break,\n-                Some(&superscope) => scope = superscope,\n+                Some(&superscope) => match superscope.data() {\n+                    ScopeData::CallSite(_) => break,\n+                    _ => scope = superscope\n+                },\n                 None => break\n             }\n         }"}, {"sha": "d0c5460fa9714e3c446c1ac378fc00c8630209d1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -46,14 +46,16 @@ pub enum Region {\n }\n \n impl Region {\n-    fn early(hir_map: &Map, index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+    fn early(hir_map: &Map, index: &mut u32, def: &hir::LifetimeDef)\n+        -> (hir::LifetimeName, Region)\n+    {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n         (def.lifetime.name, Region::EarlyBound(i, def_id))\n     }\n \n-    fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+    fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (hir::LifetimeName, Region) {\n         let depth = ty::DebruijnIndex::new(1);\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n         (def.lifetime.name, Region::LateBound(depth, def_id))\n@@ -198,7 +200,7 @@ enum Scope<'a> {\n     /// it should be shifted by the number of `Binder`s in between the\n     /// declaration `Binder` and the location it's referenced from.\n     Binder {\n-        lifetimes: FxHashMap<ast::Name, Region>,\n+        lifetimes: FxHashMap<hir::LifetimeName, Region>,\n         s: ScopeRef<'a>\n     },\n \n@@ -443,7 +445,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n         for (i, segment) in path.segments.iter().enumerate() {\n             let depth = path.segments.len() - i - 1;\n-            self.visit_segment_parameters(path.def, depth, &segment.parameters);\n+            if let Some(ref parameters) = segment.parameters {\n+                self.visit_segment_parameters(path.def, depth, parameters);\n+            }\n         }\n     }\n \n@@ -654,7 +658,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n \n                 Scope::Binder { ref lifetimes, s } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&label) {\n+                    if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n                         let node_id = hir_map.as_local_node_id(def.id().unwrap())\n                                              .unwrap();\n \n@@ -692,7 +696,7 @@ fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n                                 Set1::Empty => \"BaseDefault\".to_string(),\n                                 Set1::One(Region::Static) => \"'static\".to_string(),\n                                 Set1::One(Region::EarlyBound(i, _)) => {\n-                                    generics.lifetimes[i as usize].lifetime.name.to_string()\n+                                    generics.lifetimes[i as usize].lifetime.name.name().to_string()\n                                 }\n                                 Set1::One(_) => bug!(),\n                                 Set1::Many => \"Ambiguous\".to_string(),\n@@ -714,7 +718,7 @@ fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n /// for each type parameter.\n fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n                                      -> Vec<ObjectLifetimeDefault> {\n-    fn add_bounds(set: &mut Set1<ast::Name>, bounds: &[hir::TyParamBound]) {\n+    fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::TyParamBound]) {\n         for bound in bounds {\n             if let hir::RegionTyParamBound(ref lifetime) = *bound {\n                 set.insert(lifetime.name);\n@@ -754,7 +758,7 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n         match set {\n             Set1::Empty => Set1::Empty,\n             Set1::One(name) => {\n-                if name == \"'static\" {\n+                if name == hir::LifetimeName::Static {\n                     Set1::One(Region::Static)\n                 } else {\n                     generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n@@ -922,7 +926,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n             struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-                \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n+                \"use of undeclared lifetime name `{}`\", lifetime_ref.name.name())\n                 .span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n@@ -1422,13 +1426,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let lifetime_i = &lifetimes[i];\n \n             for lifetime in lifetimes {\n-                if lifetime.lifetime.is_static() {\n-                    let lifetime = lifetime.lifetime;\n-                    let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n-                                  \"invalid lifetime parameter name: `{}`\", lifetime.name);\n-                    err.span_label(lifetime.span,\n-                                   format!(\"{} is a reserved lifetime name\", lifetime.name));\n-                    err.emit();\n+                match lifetime.lifetime.name {\n+                    hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n+                        let lifetime = lifetime.lifetime;\n+                        let name = lifetime.name.name();\n+                        let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n+                                      \"invalid lifetime parameter name: `{}`\", name);\n+                        err.span_label(lifetime.span,\n+                                       format!(\"{} is a reserved lifetime name\", name));\n+                        err.emit();\n+                    }\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {}\n                 }\n             }\n \n@@ -1439,7 +1447,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     struct_span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n                                      \"lifetime name `{}` declared twice in the same scope\",\n-                                     lifetime_j.lifetime.name)\n+                                     lifetime_j.lifetime.name.name())\n                         .span_label(lifetime_j.lifetime.span,\n                                     \"declared twice\")\n                         .span_label(lifetime_i.lifetime.span,\n@@ -1452,15 +1460,27 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             self.check_lifetime_def_for_shadowing(old_scope, &lifetime_i.lifetime);\n \n             for bound in &lifetime_i.bounds {\n-                if !bound.is_static() {\n-                    self.resolve_lifetime_ref(bound);\n-                } else {\n-                    self.insert_lifetime(bound, Region::Static);\n-                    self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n-                        &format!(\"unnecessary lifetime parameter `{}`\", lifetime_i.lifetime.name))\n-                        .help(&format!(\"you can use the `'static` lifetime directly, in place \\\n-                                        of `{}`\", lifetime_i.lifetime.name))\n-                        .emit();\n+                match bound.name {\n+                    hir::LifetimeName::Underscore => {\n+                        let mut err = struct_span_err!(self.sess, bound.span, E0637,\n+                            \"invalid lifetime bound name: `'_`\");\n+                        err.span_label(bound.span, \"`'_` is a reserved lifetime name\");\n+                        err.emit();\n+                    }\n+                    hir::LifetimeName::Static => {\n+                        self.insert_lifetime(bound, Region::Static);\n+                        self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n+                            &format!(\"unnecessary lifetime parameter `{}`\",\n+                                    lifetime_i.lifetime.name.name()))\n+                            .help(&format!(\n+                                \"you can use the `'static` lifetime directly, in place \\\n+                                of `{}`\", lifetime_i.lifetime.name.name()))\n+                            .emit();\n+                    }\n+                    hir::LifetimeName::Implicit |\n+                    hir::LifetimeName::Name(_) => {\n+                        self.resolve_lifetime_ref(bound);\n+                    }\n                 }\n             }\n         }\n@@ -1472,9 +1492,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if lifetime.name == label {\n+            if lifetime.name.name() == label {\n                 signal_shadowing_problem(self.sess,\n-                                         lifetime.name,\n+                                         label,\n                                          original_label(label_span),\n                                          shadower_lifetime(&lifetime));\n                 return;\n@@ -1501,7 +1521,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         signal_shadowing_problem(\n                             self.sess,\n-                            lifetime.name,\n+                            lifetime.name.name(),\n                             original_lifetime(self.hir_map.span(node_id)),\n                             shadower_lifetime(&lifetime));\n                         return;\n@@ -1617,7 +1637,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     return;\n \n     struct ConstrainedCollector {\n-        regions: FxHashSet<ast::Name>,\n+        regions: FxHashSet<hir::LifetimeName>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -1657,7 +1677,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     struct AllCollector {\n-        regions: FxHashSet<ast::Name>,\n+        regions: FxHashSet<hir::LifetimeName>,\n         impl_trait: bool\n     }\n "}, {"sha": "ba221ef6ae10b03f9e487d6bdfb599ec0becc62b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,6 +18,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n@@ -33,7 +34,7 @@ use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};\n use std::vec::IntoIter;\n-use syntax::ast::Name;\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n mod cache;\n@@ -96,6 +97,10 @@ pub struct Mir<'tcx> {\n     /// and used (eventually) for debuginfo. Indexed by a `VisibilityScope`.\n     pub visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n \n+    /// Crate-local information for each visibility scope, that can't (and\n+    /// needn't) be tracked across crates.\n+    pub visibility_scope_info: ClearOnDecode<IndexVec<VisibilityScope, VisibilityScopeInfo>>,\n+\n     /// Rvalues promoted from this function, such as borrows of constants.\n     /// Each of them is the Mir of a constant with the fn's type parameters\n     /// in scope, but a separate set of locals.\n@@ -151,6 +156,8 @@ pub const START_BLOCK: BasicBlock = BasicBlock(0);\n impl<'tcx> Mir<'tcx> {\n     pub fn new(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n                visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+               visibility_scope_info: ClearOnDecode<IndexVec<VisibilityScope,\n+                                                             VisibilityScopeInfo>>,\n                promoted: IndexVec<Promoted, Mir<'tcx>>,\n                return_ty: Ty<'tcx>,\n                yield_ty: Option<Ty<'tcx>>,\n@@ -167,6 +174,7 @@ impl<'tcx> Mir<'tcx> {\n         Mir {\n             basic_blocks,\n             visibility_scopes,\n+            visibility_scope_info,\n             promoted,\n             return_ty,\n             yield_ty,\n@@ -278,9 +286,29 @@ impl<'tcx> Mir<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct VisibilityScopeInfo {\n+    /// A NodeId with lint levels equivalent to this scope's lint levels.\n+    pub lint_root: ast::NodeId,\n+    /// The unsafe block that contains this node.\n+    pub safety: Safety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Safety {\n+    Safe,\n+    /// Unsafe because of a PushUnsafeBlock\n+    BuiltinUnsafe,\n+    /// Unsafe because of an unsafe fn\n+    FnUnsafe,\n+    /// Unsafe because of an `unsafe` block\n+    ExplicitUnsafe(ast::NodeId)\n+}\n+\n impl_stable_hash_for!(struct Mir<'tcx> {\n     basic_blocks,\n     visibility_scopes,\n+    visibility_scope_info,\n     promoted,\n     return_ty,\n     yield_ty,\n@@ -310,10 +338,28 @@ impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ClearOnDecode<T> {\n+    Clear,\n+    Set(T)\n+}\n+\n+impl<T> serialize::Encodable for ClearOnDecode<T> {\n+    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        serialize::Encodable::encode(&(), s)\n+    }\n+}\n+\n+impl<T> serialize::Decodable for ClearOnDecode<T> {\n+    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        serialize::Decodable::decode(d).map(|()| ClearOnDecode::Clear)\n+    }\n+}\n+\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -414,14 +460,17 @@ pub struct LocalDecl<'tcx> {\n     /// True if this is an internal local\n     ///\n     /// These locals are not based on types in the source code and are only used\n-    /// for drop flags at the moment.\n+    /// for a few desugarings at the moment.\n     ///\n     /// The generator transformation will sanity check the locals which are live\n     /// across a suspension point against the type components of the generator\n     /// which type checking knows are live across a suspension point. We need to\n     /// flag drop flags to avoid triggering this check as they are introduced\n     /// after typeck.\n     ///\n+    /// Unsafety checking will also ignore dereferences of these locals,\n+    /// so they can be used for raw pointers only used in a desugaring.\n+    ///\n     /// This should be sound because the drop flags are fully algebraic, and\n     /// therefore don't affect the OIBIT or outlives properties of the\n     /// generator.\n@@ -438,6 +487,12 @@ pub struct LocalDecl<'tcx> {\n \n     /// Source info of the local.\n     pub source_info: SourceInfo,\n+\n+    /// The *lexical* visibility scope the local is defined\n+    /// in. If the local was defined in a let-statement, this\n+    /// is *within* the let-statement, rather than outside\n+    /// of it.\n+    pub lexical_scope: VisibilityScope,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n@@ -452,6 +507,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: false,\n             is_user_variable: false\n         }\n@@ -468,6 +524,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: true,\n             is_user_variable: false\n         }\n@@ -485,6 +542,7 @@ impl<'tcx> LocalDecl<'tcx> {\n                 span,\n                 scope: ARGUMENT_VISIBILITY_SCOPE\n             },\n+            lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n             internal: false,\n             name: None,     // FIXME maybe we do want some name here?\n             is_user_variable: false\n@@ -1592,6 +1650,13 @@ impl Location {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct UnsafetyViolation {\n+    pub source_info: SourceInfo,\n+    pub description: &'static str,\n+    pub lint_node_id: Option<ast::NodeId>,\n+}\n+\n /// The layout of generator state\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct GeneratorLayout<'tcx> {\n@@ -1607,6 +1672,7 @@ impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n         Mir {\n             basic_blocks: self.basic_blocks.fold_with(folder),\n             visibility_scopes: self.visibility_scopes.clone(),\n+            visibility_scope_info: self.visibility_scope_info.clone(),\n             promoted: self.promoted.fold_with(folder),\n             return_ty: self.return_ty.fold_with(folder),\n             yield_ty: self.yield_ty.fold_with(folder),"}, {"sha": "63652980f9b4b68372e2a179978c10eea58634f7", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -690,11 +690,13 @@ macro_rules! make_mir_visitor {\n                     name: _,\n                     ref $($mutability)* source_info,\n                     internal: _,\n+                    ref $($mutability)* lexical_scope,\n                     is_user_variable: _,\n                 } = *local_decl;\n \n                 self.visit_ty(ty, Lookup::Src(*source_info));\n                 self.visit_source_info(source_info);\n+                self.visit_visibility_scope(lexical_scope);\n             }\n \n             fn super_visibility_scope(&mut self,"}, {"sha": "153d8c3a152ab10f3519677ff6301972aa828bfe", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 84, "deletions": 43, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -350,6 +350,9 @@ top_level_options!(\n         // is currently just a hack and will be removed eventually, so please\n         // try to not rely on this too much.\n         actually_rustdoc: bool [TRACKED],\n+\n+        // Number of object files/codegen units to produce on the backend\n+        codegen_units: usize [UNTRACKED],\n     }\n );\n \n@@ -512,6 +515,7 @@ pub fn basic_options() -> Options {\n         unstable_features: UnstableFeatures::Disallow,\n         debug_assertions: true,\n         actually_rustdoc: false,\n+        codegen_units: 1,\n     }\n }\n \n@@ -529,11 +533,6 @@ impl Options {\n             (self.debugging_opts.query_dep_graph || self.debugging_opts.incremental_info)\n     }\n \n-    pub fn single_codegen_unit(&self) -> bool {\n-        self.incremental.is_none() ||\n-        self.cg.codegen_units == 1\n-    }\n-\n     pub fn file_path_mapping(&self) -> FilePathMapping {\n         FilePathMapping::new(\n             self.debugging_opts.remap_path_prefix_from.iter().zip(\n@@ -791,7 +790,7 @@ macro_rules! options {\n         fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n-                None => { *slot = None; true }\n+                None => { *slot = None; false }\n             }\n         }\n \n@@ -924,7 +923,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          \"metadata to mangle symbol names with\"),\n     extra_filename: String = (\"\".to_string(), parse_string, [UNTRACKED],\n          \"extra data to put in each output filename\"),\n-    codegen_units: usize = (1, parse_uint, [UNTRACKED],\n+    codegen_units: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n         \"divide crate into N units to optimize in parallel\"),\n     remark: Passes = (SomePasses(Vec::new()), parse_passes, [UNTRACKED],\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n@@ -1021,7 +1020,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_cc: bool = (true, parse_bool, [UNTRACKED],\n+    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n           \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n@@ -1373,20 +1372,20 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                                  always = always colorize output;\n                                  never  = never colorize output\", \"auto|always|never\"),\n \n-        opt::flagopt(\"\", \"pretty\",\n-                     \"Pretty-print the input instead of compiling;\n-                      valid types are: `normal` (un-annotated source),\n-                      `expanded` (crates expanded), or\n-                      `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n-                     \"TYPE\"),\n-        opt::flagopt(\"\", \"unpretty\",\n-                     \"Present the input source, unstable (and less-pretty) variants;\n-                      valid types are any of the types for `--pretty`, as well as:\n-                      `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n-                      `everybody_loops` (all function bodies replaced with `loop {}`),\n-                      `hir` (the HIR), `hir,identified`, or\n-                      `hir,typed` (HIR with types for each node).\",\n-                     \"TYPE\"),\n+        opt::opt(\"\", \"pretty\",\n+                 \"Pretty-print the input instead of compiling;\n+                  valid types are: `normal` (un-annotated source),\n+                  `expanded` (crates expanded), or\n+                  `expanded,identified` (fully parenthesized, AST nodes with IDs).\",\n+                 \"TYPE\"),\n+        opt::opt(\"\", \"unpretty\",\n+                 \"Present the input source, unstable (and less-pretty) variants;\n+                  valid types are any of the types for `--pretty`, as well as:\n+                  `flowgraph=<nodeid>` (graphviz formatted flowgraph for node),\n+                  `everybody_loops` (all function bodies replaced with `loop {}`),\n+                  `hir` (the HIR), `hir,identified`, or\n+                  `hir,typed` (HIR with types for each node).\",\n+                 \"TYPE\"),\n     ]);\n     opts\n }\n@@ -1521,27 +1520,35 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     let mut cg = build_codegen_options(matches, error_format);\n+    let mut codegen_units = cg.codegen_units;\n \n     // Issue #30063: if user requests llvm-related output to one\n     // particular path, disable codegen-units.\n-    if matches.opt_present(\"o\") && cg.codegen_units != 1 {\n-        let incompatible: Vec<_> = output_types.iter()\n-            .map(|ot_path| ot_path.0)\n-            .filter(|ot| {\n-                !ot.is_compatible_with_codegen_units_and_single_output_file()\n-            }).collect();\n-        if !incompatible.is_empty() {\n-            for ot in &incompatible {\n-                early_warn(error_format, &format!(\"--emit={} with -o incompatible with \\\n-                                                 -C codegen-units=N for N > 1\",\n-                                                ot.shorthand()));\n+    let incompatible: Vec<_> = output_types.iter()\n+        .map(|ot_path| ot_path.0)\n+        .filter(|ot| {\n+            !ot.is_compatible_with_codegen_units_and_single_output_file()\n+        })\n+        .map(|ot| ot.shorthand())\n+        .collect();\n+    if !incompatible.is_empty() {\n+        match codegen_units {\n+            Some(n) if n > 1 => {\n+                if matches.opt_present(\"o\") {\n+                    for ot in &incompatible {\n+                        early_warn(error_format, &format!(\"--emit={} with -o incompatible with \\\n+                                                         -C codegen-units=N for N > 1\",\n+                                                        ot));\n+                    }\n+                    early_warn(error_format, \"resetting to default -C codegen-units=1\");\n+                    codegen_units = Some(1);\n+                }\n             }\n-            early_warn(error_format, \"resetting to default -C codegen-units=1\");\n-            cg.codegen_units = 1;\n+            _ => codegen_units = Some(1),\n         }\n     }\n \n-    if cg.codegen_units < 1 {\n+    if codegen_units == Some(0) {\n         early_error(error_format, \"Value for codegen units must be a positive nonzero integer\");\n     }\n \n@@ -1550,12 +1557,17 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     // case, but it would be confusing to have the validity of\n     // `-Z lto -C codegen-units=2` depend on details of the crate being\n     // compiled, so we complain regardless.\n-    if cg.lto && cg.codegen_units > 1 {\n-        // This case is impossible to handle because LTO expects to be able\n-        // to combine the entire crate and all its dependencies into a\n-        // single compilation unit, but each codegen unit is in a separate\n-        // LLVM context, so they can't easily be combined.\n-        early_error(error_format, \"can't perform LTO when using multiple codegen units\");\n+    if cg.lto {\n+        if let Some(n) = codegen_units {\n+            if n > 1 {\n+                // This case is impossible to handle because LTO expects to be able\n+                // to combine the entire crate and all its dependencies into a\n+                // single compilation unit, but each codegen unit is in a separate\n+                // LLVM context, so they can't easily be combined.\n+                early_error(error_format, \"can't perform LTO when using multiple codegen units\");\n+            }\n+        }\n+        codegen_units = Some(1);\n     }\n \n     if cg.lto && debugging_opts.incremental.is_some() {\n@@ -1720,6 +1732,34 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let incremental = debugging_opts.incremental.as_ref().map(|m| PathBuf::from(m));\n \n+    let codegen_units = codegen_units.unwrap_or_else(|| {\n+        match opt_level {\n+            // If we're compiling at `-O0` then default to 32 codegen units.\n+            // The number here shouldn't matter too too much as debug mode\n+            // builds don't rely on performance at all, meaning that lost\n+            // opportunities for inlining through multiple codegen units is\n+            // a non-issue.\n+            //\n+            // Note that the high number here doesn't mean that we'll be\n+            // spawning a large number of threads in parallel. The backend\n+            // of rustc contains global rate limiting through the\n+            // `jobserver` crate so we'll never overload the system with too\n+            // much work, but rather we'll only be optimizing when we're\n+            // otherwise cooperating with other instances of rustc.\n+            //\n+            // Rather the high number here means that we should be able to\n+            // keep a lot of idle cpus busy. By ensuring that no codegen\n+            // unit takes *too* long to build we'll be guaranteed that all\n+            // cpus will finish pretty closely to one another and we should\n+            // make relatively optimal use of system resources\n+            OptLevel::No => 32,\n+\n+            // All other optimization levels default use one codegen unit,\n+            // the historical default in Rust for a Long Time.\n+            _ => 1,\n+        }\n+    });\n+\n     (Options {\n         crate_types,\n         optimize: opt_level,\n@@ -1744,6 +1784,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         unstable_features: UnstableFeatures::from_environment(),\n         debug_assertions,\n         actually_rustdoc: false,\n+        codegen_units,\n     },\n     cfg)\n }\n@@ -2447,7 +2488,7 @@ mod tests {\n         opts.cg.extra_filename = String::from(\"extra-filename\");\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n-        opts.cg.codegen_units = 42;\n+        opts.cg.codegen_units = Some(42);\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         opts.cg.remark = super::SomePasses(vec![String::from(\"pass1\"),"}, {"sha": "e87443619ece796245ab423a05074ec5668b3e6b", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -411,7 +411,8 @@ impl Session {\n     }\n     pub fn emit_end_regions(&self) -> bool {\n         self.opts.debugging_opts.emit_end_regions ||\n-            (self.opts.debugging_opts.mir_emit_validate > 0)\n+            (self.opts.debugging_opts.mir_emit_validate > 0) ||\n+            self.opts.debugging_opts.borrowck_mir\n     }\n     pub fn lto(&self) -> bool {\n         self.opts.cg.lto"}, {"sha": "c7c8141f4f768d06e28ec8e048c11ed98c1b75e8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 75, "deletions": 66, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -37,7 +37,7 @@ use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n use syntax::ast;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use ty::error::{ExpectedFound, TypeError};\n+use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n@@ -711,7 +711,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n+            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, _) => {\n                 let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n                 let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n                 if actual_trait_ref.self_ty().references_error() {\n@@ -722,48 +722,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     self.tcx.hir.span_if_local(did)\n                 });\n \n-                if let &TypeError::TupleSize(ref expected_found) = e {\n-                    // Expected `|x| { }`, found `|x, y| { }`\n-                    self.report_arg_count_mismatch(span,\n-                                                   found_span,\n-                                                   expected_found.expected,\n-                                                   expected_found.found,\n-                                                   expected_trait_ty.is_closure())\n-                } else if let &TypeError::Sorts(ref expected_found) = e {\n-                    let expected = if let ty::TyTuple(tys, _) = expected_found.expected.sty {\n-                        tys.len()\n-                    } else {\n-                        1\n+                let self_ty_count =\n+                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                        ty::TyTuple(ref tys, _) => tys.len(),\n+                        _ => 1,\n                     };\n-                    let found = if let ty::TyTuple(tys, _) = expected_found.found.sty {\n-                        tys.len()\n-                    } else {\n-                        1\n+                let arg_ty_count =\n+                    match actual_trait_ref.skip_binder().substs.type_at(1).sty {\n+                        ty::TyTuple(ref tys, _) => tys.len(),\n+                        _ => 1,\n                     };\n-\n-                    if expected != found {\n-                        // Expected `|| { }`, found `|x, y| { }`\n-                        // Expected `fn(x) -> ()`, found `|| { }`\n-                        self.report_arg_count_mismatch(span,\n-                                                       found_span,\n-                                                       expected,\n-                                                       found,\n-                                                       expected_trait_ty.is_closure())\n-                    } else {\n-                        self.report_type_argument_mismatch(span,\n-                                                            found_span,\n-                                                            expected_trait_ty,\n-                                                            expected_trait_ref,\n-                                                            actual_trait_ref,\n-                                                            e)\n-                    }\n+                if self_ty_count == arg_ty_count {\n+                    self.report_closure_arg_mismatch(span,\n+                                                     found_span,\n+                                                     expected_trait_ref,\n+                                                     actual_trait_ref)\n                 } else {\n-                    self.report_type_argument_mismatch(span,\n-                                                        found_span,\n-                                                        expected_trait_ty,\n-                                                        expected_trait_ref,\n-                                                        actual_trait_ref,\n-                                                        e)\n+                    // Expected `|| { }`, found `|x, y| { }`\n+                    // Expected `fn(x) -> ()`, found `|| { }`\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        found_span,\n+                        arg_ty_count,\n+                        self_ty_count,\n+                        expected_trait_ty.is_closure()\n+                    )\n                 }\n             }\n \n@@ -784,31 +767,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_type_argument_mismatch(&self,\n-                                      span: Span,\n-                                      found_span: Option<Span>,\n-                                      expected_ty: Ty<'tcx>,\n-                                      expected_ref: ty::PolyTraitRef<'tcx>,\n-                                      found_ref: ty::PolyTraitRef<'tcx>,\n-                                      type_error: &TypeError<'tcx>)\n-        -> DiagnosticBuilder<'tcx>\n-    {\n-        let mut err = struct_span_err!(self.tcx.sess, span, E0281,\n-            \"type mismatch: `{}` implements the trait `{}`, but the trait `{}` is required\",\n-            expected_ty,\n-            expected_ref,\n-            found_ref);\n-\n-        err.span_label(span, format!(\"{}\", type_error));\n-\n-        if let Some(sp) = found_span {\n-            err.span_label(span, format!(\"requires `{}`\", found_ref));\n-            err.span_label(sp, format!(\"implements `{}`\", expected_ref));\n-        }\n-\n-        err\n-    }\n-\n     fn report_arg_count_mismatch(&self,\n                                  span: Span,\n                                  found_span: Option<Span>,\n@@ -837,6 +795,57 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n         err\n     }\n+\n+    fn report_closure_arg_mismatch(&self,\n+                           span: Span,\n+                           found_span: Option<Span>,\n+                           expected_ref: ty::PolyTraitRef<'tcx>,\n+                           found: ty::PolyTraitRef<'tcx>)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        fn build_fn_sig_string<'a, 'gcx, 'tcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+                                               trait_ref: &ty::TraitRef<'tcx>) -> String {\n+            let inputs = trait_ref.substs.type_at(1);\n+            let sig = if let ty::TyTuple(inputs, _) = inputs.sty {\n+                tcx.mk_fn_sig(\n+                    inputs.iter().map(|&x| x),\n+                    tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::syntax::abi::Abi::Rust\n+                )\n+            } else {\n+                tcx.mk_fn_sig(\n+                    ::std::iter::once(inputs),\n+                    tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::syntax::abi::Abi::Rust\n+                )\n+            };\n+            format!(\"{}\", ty::Binder(sig))\n+        }\n+\n+        let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n+        let mut err = struct_span_err!(self.tcx.sess, span, E0631,\n+                                       \"type mismatch in {} arguments\",\n+                                       if argument_is_closure { \"closure\" } else { \"function\" });\n+\n+        let found_str = format!(\n+            \"expected signature of `{}`\",\n+            build_fn_sig_string(self.tcx, found.skip_binder())\n+        );\n+        err.span_label(span, found_str);\n+\n+        let found_span = found_span.unwrap_or(span);\n+        let expected_str = format!(\n+            \"found signature of `{}`\",\n+            build_fn_sig_string(self.tcx, expected_ref.skip_binder())\n+        );\n+        err.span_label(found_span, expected_str);\n+\n+        err\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "947e7117c4ea2d42842b528f76b4d7e593c3d540", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -19,7 +19,7 @@ use std::cell::RefCell;\n use std::marker::PhantomData;\n use syntax::ast;\n use syntax_pos::Span;\n-use traits::{FulfillmentContext, Obligation, ObligationCause, Reveal, SelectionContext, Vtable};\n+use traits::{FulfillmentContext, Obligation, ObligationCause, SelectionContext, Vtable};\n use ty::{self, Ty, TyCtxt};\n use ty::subst::{Subst, Substs};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -31,24 +31,25 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// (necessarily) resolve all nested obligations on the impl. Note\n     /// that type check should guarantee to us that all nested\n     /// obligations *could be* resolved if we wanted to.\n+    /// Assumes that this is run after the entire crate has been successfully type-checked.\n     pub fn trans_fulfill_obligation(self,\n                                     span: Span,\n+                                    param_env: ty::ParamEnv<'tcx>,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Vtable<'tcx, ()>\n     {\n         // Remove any references to regions; this helps improve caching.\n         let trait_ref = self.erase_regions(&trait_ref);\n \n-        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n+        self.trans_trait_caches.trait_cache.memoize((param_env, trait_ref), || {\n             debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-                   trait_ref, trait_ref.def_id());\n+                   (param_env, trait_ref), trait_ref.def_id());\n \n             // Do the initial selection for the obligation. This yields the\n             // shallow result we are looking for -- that is, what specific impl.\n             self.infer_ctxt().enter(|infcx| {\n                 let mut selcx = SelectionContext::new(&infcx);\n \n-                let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let obligation_cause = ObligationCause::misc(span,\n                                                              ast::DUMMY_NODE_ID);\n                 let obligation = Obligation::new(obligation_cause,\n@@ -167,7 +168,7 @@ pub struct TraitSelectionCache<'tcx> {\n }\n \n impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = ty::PolyTraitRef<'tcx>;\n+    type Key = (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>);\n     type Value = Vtable<'tcx, ()>;\n     fn to_dep_kind() -> DepKind {\n         DepKind::TraitSelect"}, {"sha": "315ba622ccf6d22c00ed2d3896f5da49388561f1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,6 +11,7 @@\n //! type context book-keeping\n \n use dep_graph::DepGraph;\n+use dep_graph::{DepNode, DepConstructor};\n use errors::DiagnosticBuilder;\n use session::Session;\n use session::config::OutputFilenames;\n@@ -50,8 +51,8 @@ use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n-                                           StableHasher, StableHasherResult};\n-\n+                                           StableHasher, StableHasherResult,\n+                                           StableVec};\n use arena::{TypedArena, DroplessArena};\n use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -314,7 +315,7 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct TypeckTables<'tcx> {\n     /// The HirId::owner all ItemLocalIds in this table are relative to.\n     pub local_id_root: Option<DefId>,\n@@ -828,7 +829,9 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+    trait_map: FxHashMap<DefIndex,\n+                         Rc<FxHashMap<ItemLocalId,\n+                                      Rc<StableVec<TraitCandidate>>>>>,\n \n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n@@ -1081,15 +1084,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        // FIXME(mw): Each of the Vecs in the trait_map should be brought into\n-        // a deterministic order here. Otherwise we might end up with\n-        // unnecessarily unstable incr. comp. hashes.\n         let mut trait_map = FxHashMap();\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner)\n                 .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n+            Rc::get_mut(map).unwrap()\n+                            .insert(hir_id.local_id,\n+                                    Rc::new(StableVec::new(v)));\n         }\n         let mut defs = FxHashMap();\n         for (k, v) in named_region_map.defs {\n@@ -1235,6 +1237,35 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   self.hir.definitions(),\n                                   self.cstore)\n     }\n+\n+    // This method makes sure that we have a DepNode and a Fingerprint for\n+    // every upstream crate. It needs to be called once right after the tcx is\n+    // created.\n+    // With full-fledged red/green, the method will probably become unnecessary\n+    // as this will be done on-demand.\n+    pub fn allocate_metadata_dep_nodes(self) {\n+        // We cannot use the query versions of crates() and crate_hash(), since\n+        // those would need the DepNodes that we are allocating here.\n+        for cnum in self.cstore.crates_untracked() {\n+            let dep_node = DepNode::new(self, DepConstructor::CrateMetadata(cnum));\n+            let crate_hash = self.cstore.crate_hash_untracked(cnum);\n+            self.dep_graph.with_task(dep_node,\n+                                     self,\n+                                     crate_hash,\n+                                     |_, x| x // No transformation needed\n+            );\n+        }\n+    }\n+\n+    // This method exercises the `in_scope_traits_map` query for all possible\n+    // values so that we have their fingerprints available in the DepGraph.\n+    // This is only required as long as we still use the old dependency tracking\n+    // which needs to have the fingerprints of all input nodes beforehand.\n+    pub fn precompute_in_scope_traits_hashes(self) {\n+        for &def_index in self.trait_map.keys() {\n+            self.in_scope_traits_map(def_index);\n+        }\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -2103,7 +2134,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<Vec<TraitCandidate>>> {\n+    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<StableVec<TraitCandidate>>> {\n         self.in_scope_traits_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).cloned())\n     }"}, {"sha": "4bd2d5be6d716f09a66d51cd6134190f8b9af034", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -42,6 +42,7 @@ use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::StableVec;\n use std::cell::{RefCell, Cell};\n \n use std::ops::Deref;\n@@ -158,6 +159,10 @@ define_maps! { <'tcx>\n     /// expression defining the closure.\n     [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n+    /// Unsafety violations for this def ID.\n+    [] fn unsafety_violations: UnsafetyViolations(DefId)\n+        -> Rc<[mir::UnsafetyViolation]>,\n+\n     /// The signature of functions and closures.\n     [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n \n@@ -259,7 +264,7 @@ define_maps! { <'tcx>\n \n     [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n     [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<StableVec<TraitCandidate>>>>>,\n     [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n "}, {"sha": "581f47dc13cdf466415b57b6e34ff54beb2a3e79", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -221,7 +221,7 @@ macro_rules! define_maps {\n \n                 profq_msg!(tcx,\n                     ProfileQueriesMsg::QueryBegin(\n-                        span.clone(),\n+                        span.data(),\n                         QueryMsg::$name(profq_key!(tcx, key))\n                     )\n                 );"}, {"sha": "da635ec80fc91081d5405b4a2fa919ce0fc94f28", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -675,6 +675,8 @@ pub struct TypeParameterDef {\n     /// on generic parameter `T`, asserts data behind the parameter\n     /// `T` won't be accessed during the parent type's `Drop` impl.\n     pub pure_wrt_drop: bool,\n+\n+    pub synthetic: Option<hir::SyntheticTyParamKind>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "9e566d2b9071f46d1dccb28c259707dc14cb9a3c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -20,7 +20,7 @@ use std::path::Path;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n-use syntax_pos::{Span};\n+use syntax_pos::{SpanData};\n use ty::maps::{QueryMsg};\n use dep_graph::{DepNode};\n \n@@ -61,7 +61,8 @@ pub enum ProfileQueriesMsg {\n     /// end a task\n     TaskEnd,\n     /// begin a new query\n-    QueryBegin(Span, QueryMsg),\n+    /// can't use `Span` because queries are sent to other thread\n+    QueryBegin(SpanData, QueryMsg),\n     /// query is satisfied by using an already-known value for the given key\n     CacheHit,\n     /// query requires running a provider; providers may nest, permitting queries to nest."}, {"sha": "214973e3085865bad8412e8f1be483d4aec7d87f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -26,6 +26,7 @@ use std::fmt;\n use std::usize;\n \n use rustc_const_math::ConstInt;\n+use rustc_data_structures::indexed_vec::Idx;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n@@ -530,17 +531,17 @@ impl fmt::Display for ty::RegionKind {\n                 write!(f, \"{}\", br)\n             }\n             ty::ReScope(scope) if identify_regions() => {\n-                match scope {\n-                    region::Scope::Node(id) =>\n+                match scope.data() {\n+                    region::ScopeData::Node(id) =>\n                         write!(f, \"'{}s\", id.as_usize()),\n-                    region::Scope::CallSite(id) =>\n+                    region::ScopeData::CallSite(id) =>\n                         write!(f, \"'{}cs\", id.as_usize()),\n-                    region::Scope::Arguments(id) =>\n+                    region::ScopeData::Arguments(id) =>\n                         write!(f, \"'{}as\", id.as_usize()),\n-                    region::Scope::Destruction(id) =>\n+                    region::ScopeData::Destruction(id) =>\n                         write!(f, \"'{}ds\", id.as_usize()),\n-                    region::Scope::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index),\n+                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n+                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {\n@@ -676,6 +677,12 @@ impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n     }\n }\n \n+impl<'tcx> fmt::Display for ty::Binder<ty::FnSig<'tcx>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))"}, {"sha": "1edac616366dd76e6d87b26094cebf6cf2a62b79", "filename": "src/librustc_back/target/aarch64_unknown_linux_musl.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_musl.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::linux_musl_base::opts();\n+    base.max_atomic_width = Some(128);\n+\n+    // see #36994\n+    base.exe_allocation_crate = None;\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-linux-musl\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_env: \"musl\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"linux\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: TargetOptions {\n+            abi_blacklist: super::arm_base::abi_blacklist(),\n+            .. base\n+        },\n+    })\n+}"}, {"sha": "27a0855dc29fe81d195877b95133d40e26c06aa0", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -153,6 +153,7 @@ supported_targets! {\n     (\"armv7-unknown-linux-gnueabihf\", armv7_unknown_linux_gnueabihf),\n     (\"armv7-unknown-linux-musleabihf\", armv7_unknown_linux_musleabihf),\n     (\"aarch64-unknown-linux-gnu\", aarch64_unknown_linux_gnu),\n+    (\"aarch64-unknown-linux-musl\", aarch64_unknown_linux_musl),\n     (\"x86_64-unknown-linux-musl\", x86_64_unknown_linux_musl),\n     (\"i686-unknown-linux-musl\", i686_unknown_linux_musl),\n     (\"mips-unknown-linux-musl\", mips_unknown_linux_musl),"}, {"sha": "e8f9a6720872d5ec21374e0b8fbba97865400ee4", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -138,7 +138,7 @@ impl FromIterator<bool> for BitVector {\n /// A \"bit matrix\" is basically a matrix of booleans represented as\n /// one gigantic bitvector. In other words, it is as if you have\n /// `rows` bitvectors, each of length `columns`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct BitMatrix {\n     columns: usize,\n     vector: Vec<u64>,"}, {"sha": "9aba48c5bef07b60b5f065f15125977056415f9b", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -558,3 +558,37 @@ pub fn hash_stable_hashmap<HCX, K, V, R, SK, F, W>(\n     entries.hash_stable(hcx, hasher);\n }\n \n+\n+/// A vector container that makes sure that its items are hashed in a stable\n+/// order.\n+pub struct StableVec<T>(Vec<T>);\n+\n+impl<T> StableVec<T> {\n+    pub fn new(v: Vec<T>) -> Self {\n+        StableVec(v)\n+    }\n+}\n+\n+impl<T> ::std::ops::Deref for StableVec<T> {\n+    type Target = Vec<T>;\n+\n+    fn deref(&self) -> &Vec<T> {\n+        &self.0\n+    }\n+}\n+\n+impl<T, HCX> HashStable<HCX> for StableVec<T>\n+    where T: HashStable<HCX> + ToStableHashKey<HCX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let StableVec(ref v) = *self;\n+\n+        let mut sorted: Vec<_> = v.iter()\n+                                  .map(|x| x.to_stable_hash_key(hcx))\n+                                  .collect();\n+        sorted.sort_unstable();\n+        sorted.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "7cb386b019798d3ecce2a1f015d4a867d3fb1d79", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,7 +18,7 @@ use std::hash::Hash;\n use std::mem;\n \n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: Vec<T>,\n@@ -42,10 +42,10 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash + Clone> {\n     closure: RefCell<Option<BitMatrix>>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n struct Edge {\n     source: Index,\n     target: Index,"}, {"sha": "57989f75cbaec3b5a5a19436b5db52c6a5603785", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 80, "deletions": 103, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![cfg_attr(not(feature=\"llvm\"), allow(dead_code))]\n-\n use rustc::dep_graph::DepGraph;\n use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n@@ -30,19 +28,20 @@ use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n-use rustc_trans::back::write;\n use rustc_trans as trans;\n+use rustc_trans_utils::trans_crate::TransCrate;\n use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{ast_validation, no_asm, loops, consts, static_recursion, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n+use ::DefaultTransCrate;\n \n use serialize::json;\n \n@@ -76,7 +75,8 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n-    use rustc_trans::back::write::OngoingCrateTranslation;\n+    use rustc::session::config::CrateType;\n+\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -94,17 +94,16 @@ pub fn compile_input(sess: &Session,\n     }\n \n     if cfg!(not(feature=\"llvm\")) {\n-        use rustc::session::config::CrateType;\n-        if !sess.opts.debugging_opts.no_trans && sess.opts.output_types.should_trans() {\n-            sess.err(\"LLVM is not supported by this rustc. Please use -Z no-trans to compile\")\n-        }\n-\n-        if sess.opts.crate_types.iter().all(|&t|{\n-            t != CrateType::CrateTypeRlib && t != CrateType::CrateTypeExecutable\n-        }) && !sess.opts.crate_types.is_empty() {\n-            sess.err(\n-                \"LLVM is not supported by this rustc, so non rlib libraries are not supported\"\n-            );\n+        for cty in sess.opts.crate_types.iter() {\n+            match *cty {\n+                CrateType::CrateTypeRlib | CrateType::CrateTypeDylib |\n+                CrateType::CrateTypeExecutable => {},\n+                _ => {\n+                    sess.parse_sess.span_diagnostic.warn(\n+                        &format!(\"LLVM unsupported, so output type {} is not supported\", cty)\n+                    );\n+                },\n+            }\n         }\n \n         sess.abort_if_errors();\n@@ -117,7 +116,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans, dep_graph): (OutputFilenames, OngoingCrateTranslation, DepGraph) = {\n+    let (outputs, trans, dep_graph) = {\n         let krate = match phase_1_parse_input(control, sess, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -175,7 +174,7 @@ pub fn compile_input(sess: &Session,\n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           || hir_map::map_crate(&mut hir_forest, &defs));\n+                           || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();\n@@ -218,7 +217,7 @@ pub fn compile_input(sess: &Session,\n                                     &arenas,\n                                     &crate_name,\n                                     &outputs,\n-                                    |tcx, analysis, incremental_hashes_map, rx, result| {\n+                                    |tcx, analysis, rx, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -246,9 +245,7 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm(tcx,\n-                                                  incremental_hashes_map,\n-                                                  rx);\n+            let trans = phase_4_translate_to_llvm::<DefaultTransCrate>(tcx, rx);\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -266,44 +263,42 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n-    if cfg!(not(feature=\"llvm\")) {\n-        let (_, _) = (outputs, trans);\n-        sess.fatal(\"LLVM is not supported by this rustc\");\n+    if sess.opts.debugging_opts.print_type_sizes {\n+        sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    #[cfg(feature=\"llvm\")]\n-    {\n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.borrow().print_type_sizes();\n-        }\n-\n-        let (phase5_result, trans) = phase_5_run_llvm_passes(sess, &dep_graph, trans);\n+    let (phase5_result, trans) =\n+        phase_5_run_llvm_passes::<DefaultTransCrate>(sess, &dep_graph, trans);\n \n-        controller_entry_point!(after_llvm,\n-                                sess,\n-                                CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n-                                phase5_result);\n-        phase5_result?;\n+    controller_entry_point!(after_llvm,\n+                            sess,\n+                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n+                            phase5_result);\n+    phase5_result?;\n \n-        phase_6_link_output(sess, &trans, &outputs);\n-\n-        // Now that we won't touch anything in the incremental compilation directory\n-        // any more, we can finalize it (which involves renaming it)\n-        rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n+    // Run the linker on any artifacts that resulted from the LLVM run.\n+    // This should produce either a finished executable or library.\n+    time(sess.time_passes(), \"linking\", || {\n+        DefaultTransCrate::link_binary(sess, &trans, &outputs)\n+    });\n \n-        if sess.opts.debugging_opts.perf_stats {\n-            sess.print_perf_stats();\n-        }\n+    // Now that we won't touch anything in the incremental compilation directory\n+    // any more, we can finalize it (which involves renaming it)\n+    #[cfg(feature=\"llvm\")]\n+    rustc_incremental::finalize_session_directory(sess, trans.link.crate_hash);\n \n-        controller_entry_point!(\n-            compilation_done,\n-            sess,\n-            CompileState::state_when_compilation_done(input, sess, outdir, output),\n-            Ok(())\n-        );\n+    if sess.opts.debugging_opts.perf_stats {\n+        sess.print_perf_stats();\n+    }\n \n+    controller_entry_point!(\n+        compilation_done,\n+        sess,\n+        CompileState::state_when_compilation_done(input, sess, outdir, output),\n         Ok(())\n-    }\n+    );\n+\n+    Ok(())\n }\n \n fn keep_hygiene_data(sess: &Session) -> bool {\n@@ -645,7 +640,16 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         &crate_name,\n         &disambiguator.as_str(),\n     );\n-    let dep_graph = DepGraph::new(sess.opts.build_dep_graph());\n+\n+    let dep_graph = if sess.opts.build_dep_graph() {\n+        let prev_dep_graph = time(time_passes, \"load prev dep-graph (new)\", || {\n+            rustc_incremental::load_dep_graph_new(sess)\n+        });\n+\n+        DepGraph::new(prev_dep_graph)\n+    } else {\n+        DepGraph::new_disabled()\n+    };\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_limits(sess, &krate);\n@@ -715,7 +719,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n     // item, much like we do for macro expansion. In other words, the hash reflects not just\n     // its contents but the results of name resolution on those contents. Hopefully we'll push\n     // this back at some point.\n-    let _ignore = dep_graph.in_ignore();\n     let mut crate_loader = CrateLoader::new(sess, &cstore, crate_name);\n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess,\n@@ -921,7 +924,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                -> Result<R, CompileIncomplete>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             ty::CrateAnalysis,\n-                            IncrementalHashesMap,\n                             mpsc::Receiver<Box<Any + Send>>,\n                             CompileResult) -> R\n {\n@@ -965,7 +967,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    trans::provide_local(&mut local_providers);\n+    DefaultTransCrate::provide_local(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     traits::provide(&mut local_providers);\n@@ -977,7 +979,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n-    trans::provide_extern(&mut extern_providers);\n+    DefaultTransCrate::provide_extern(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n@@ -1000,19 +1002,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // What we need to run borrowck etc.\n \n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n-\n-    // FIXME: ariel points SimplifyBranches should run after\n-    // mir-borrowck; otherwise code within `if false { ... }` would\n-    // not be checked.\n-    passes.push_pass(MIR_VALIDATED,\n-                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n     // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n \n-    // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    passes.push_pass(MIR_OPTIMIZED,\n+                     mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n+\n+    // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n@@ -1053,22 +1052,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              tx,\n                              output_filenames,\n                              |tcx| {\n-        let incremental_hashes_map =\n-            time(time_passes,\n-                 \"compute_incremental_hashes_map\",\n-                 || rustc_incremental::compute_incremental_hashes_map(tcx));\n-\n         time(time_passes,\n              \"load_dep_graph\",\n-             || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n+             || rustc_incremental::load_dep_graph(tcx));\n \n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx),\n-                    (tcx, analysis, incremental_hashes_map, rx));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, rx));\n \n         time(time_passes,\n              \"const checking\",\n@@ -1081,10 +1074,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n \n-        time(time_passes,\n-             \"effect checking\",\n-             || middle::effect::check_crate(tcx));\n-\n         time(time_passes,\n              \"match checking\",\n              || check_match::check_crate(tcx));\n@@ -1105,14 +1094,19 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR borrow checking\",\n              || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n \n+        time(time_passes,\n+             \"MIR effect checking\",\n+             || for def_id in tcx.body_owners() {\n+                 mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+             });\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a\n         // lot of annoying errors in the compile-fail tests (basically,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, rx, sess.compile_status()));\n+            return Ok(f(tcx, analysis, rx, sess.compile_status()));\n         }\n \n         time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n@@ -1123,16 +1117,15 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n-        return Ok(f(tcx, analysis, incremental_hashes_map, rx, tcx.sess.compile_status()));\n+        return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           incremental_hashes_map: IncrementalHashesMap,\n+pub fn phase_4_translate_to_llvm<'a, 'tcx, Trans: TransCrate>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n-                                           -> write::OngoingCrateTranslation {\n+                                           -> <Trans as TransCrate>::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,\n@@ -1141,9 +1134,8 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let translation =\n         time(time_passes, \"translation\", move || {\n-            trans::trans_crate(tcx, incremental_hashes_map, rx)\n+            Trans::trans_crate(tcx, rx)\n         });\n-\n     if tcx.sess.profile_queries() {\n         profile::dump(\"profile_queries\".to_string())\n     }\n@@ -1153,15 +1145,14 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n-#[cfg(feature=\"llvm\")]\n-pub fn phase_5_run_llvm_passes(sess: &Session,\n+pub fn phase_5_run_llvm_passes<Trans: TransCrate>(sess: &Session,\n                                dep_graph: &DepGraph,\n-                               trans: write::OngoingCrateTranslation)\n-                               -> (CompileResult, trans::CrateTranslation) {\n-    let trans = trans.join(sess, dep_graph);\n+                               trans: <Trans as TransCrate>::OngoingCrateTranslation)\n+                               -> (CompileResult, <Trans as TransCrate>::TranslatedCrate) {\n+    let trans = Trans::join_trans(trans, sess, dep_graph);\n \n     if sess.opts.debugging_opts.incremental_info {\n-        write::dump_incremental_data(&trans);\n+        Trans::dump_incremental_data(&trans);\n     }\n \n     time(sess.time_passes(),\n@@ -1171,20 +1162,6 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n     (sess.compile_status(), trans)\n }\n \n-/// Run the linker on any artifacts that resulted from the LLVM run.\n-/// This should produce either a finished executable or library.\n-#[cfg(feature=\"llvm\")]\n-pub fn phase_6_link_output(sess: &Session,\n-                           trans: &trans::CrateTranslation,\n-                           outputs: &OutputFilenames) {\n-    time(sess.time_passes(), \"linking\", || {\n-        ::rustc_trans::back::link::link_binary(sess,\n-                                               trans,\n-                                               outputs,\n-                                               &trans.crate_name.as_str())\n-    });\n-}\n-\n fn escape_dep_filename(filename: &str) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4"}, {"sha": "6bdad0b212cf5d78a1fd92064b487c377910d844", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 8, "deletions": 76, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -75,6 +75,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n+use rustc_trans_utils::trans_crate::TransCrate;\n \n use serialize::json::ToJson;\n \n@@ -151,101 +152,31 @@ pub fn run<F>(run_compiler: F) -> isize\n }\n \n #[cfg(not(feature=\"llvm\"))]\n-pub use no_llvm_metadata_loader::NoLLvmMetadataLoader as MetadataLoader;\n+pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as DefaultTransCrate;\n #[cfg(feature=\"llvm\")]\n-pub use rustc_trans::LlvmMetadataLoader as MetadataLoader;\n-\n-#[cfg(not(feature=\"llvm\"))]\n-mod no_llvm_metadata_loader {\n-    extern crate ar;\n-    extern crate owning_ref;\n-\n-    use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n-    use rustc_back::target::Target;\n-    use std::io;\n-    use std::fs::File;\n-    use std::path::Path;\n-\n-    use self::ar::Archive;\n-    use self::owning_ref::{OwningRef, ErasedBoxRef};\n-\n-    pub struct NoLLvmMetadataLoader;\n-\n-    impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n-        fn get_rlib_metadata(\n-            &self,\n-            _: &Target,\n-            filename: &Path\n-        ) -> Result<ErasedBoxRef<[u8]>, String> {\n-            let file = File::open(filename).map_err(|e| {\n-                format!(\"metadata file open err: {:?}\", e)\n-            })?;\n-            let mut archive = Archive::new(file);\n-\n-            while let Some(entry_result) = archive.next_entry() {\n-                let mut entry = entry_result.map_err(|e| {\n-                    format!(\"metadata section read err: {:?}\", e)\n-                })?;\n-                if entry.header().identifier() == \"rust.metadata.bin\" {\n-                    let mut buf = Vec::new();\n-                    io::copy(&mut entry, &mut buf).unwrap();\n-                    let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n-                    return Ok(buf.map_owner_box().erase_owner());\n-                }\n-            }\n-\n-            Err(\"Couldnt find metadata section\".to_string())\n-        }\n-\n-        fn get_dylib_metadata(&self,\n-                            _target: &Target,\n-                            _filename: &Path)\n-                            -> Result<ErasedBoxRef<[u8]>, String> {\n-            panic!(\"Dylib metadata loading not supported without LLVM\")\n-        }\n-    }\n-}\n+pub use rustc_trans::LlvmTransCrate as DefaultTransCrate;\n \n #[cfg(not(feature=\"llvm\"))]\n mod rustc_trans {\n     use syntax_pos::symbol::Symbol;\n     use rustc::session::Session;\n-    use rustc::session::config::{PrintRequest, OutputFilenames};\n-    use rustc::ty::{TyCtxt, CrateAnalysis};\n-    use rustc::ty::maps::Providers;\n-    use rustc_incremental::IncrementalHashesMap;\n-\n-    use self::back::write::OngoingCrateTranslation;\n+    use rustc::session::config::PrintRequest;\n+    pub use rustc_trans_utils::trans_crate::MetadataOnlyTransCrate as LlvmTransCrate;\n+    pub use rustc_trans_utils::trans_crate::TranslatedCrate as CrateTranslation;\n \n     pub fn init(_sess: &Session) {}\n     pub fn enable_llvm_debug() {}\n-    pub fn provide(_providers: &mut Providers) {}\n     pub fn print_version() {}\n     pub fn print_passes() {}\n     pub fn print(_req: PrintRequest, _sess: &Session) {}\n     pub fn target_features(_sess: &Session) -> Vec<Symbol> { vec![] }\n \n-    pub fn trans_crate<'a, 'tcx>(\n-        _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        _analysis: CrateAnalysis,\n-        _incr_hashes_map: IncrementalHashesMap,\n-        _output_filenames: &OutputFilenames\n-    ) -> OngoingCrateTranslation {\n-        OngoingCrateTranslation(())\n-    }\n-\n-    pub struct CrateTranslation(());\n-\n     pub mod back {\n         pub mod write {\n-            pub struct OngoingCrateTranslation(pub (in ::rustc_trans) ());\n-\n             pub const RELOC_MODEL_ARGS: [(&'static str, ()); 0] = [];\n             pub const CODE_GEN_MODEL_ARGS: [(&'static str, ()); 0] = [];\n         }\n     }\n-\n-    __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n }\n \n // Parse args and run the compiler. This is the primary entry point for rustc.\n@@ -293,7 +224,7 @@ pub fn run_compiler<'a>(args: &[String],\n         },\n     };\n \n-    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(DefaultTransCrate::metadata_loader()));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n@@ -1331,6 +1262,7 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n+    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "2f665af8433b94a0863890e96b0a077e7df1211d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -20,7 +20,6 @@ use {abort_on_err, driver};\n use rustc::ty::{self, TyCtxt, GlobalArenas, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n-use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::session::config::{Input, OutputFilenames};\n@@ -237,7 +236,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  output_filenames,\n-                                                                 |tcx, _, _, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx,\n@@ -848,9 +847,6 @@ pub fn print_after_parsing(sess: &Session,\n                            krate: &ast::Crate,\n                            ppm: PpMode,\n                            ofile: Option<&Path>) {\n-    let dep_graph = DepGraph::new(false);\n-    let _ignore = dep_graph.in_ignore();\n-\n     let (src, src_name) = get_source(input, sess);\n \n     let mut rdr = &*src;\n@@ -893,9 +889,6 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 output_filenames: &OutputFilenames,\n                                                 opt_uii: Option<UserIdentifiedItem>,\n                                                 ofile: Option<&Path>) {\n-    let dep_graph = DepGraph::new(false);\n-    let _ignore = dep_graph.in_ignore();\n-\n     if ppm.needs_analysis() {\n         print_with_analysis(sess,\n                             cstore,\n@@ -1036,7 +1029,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      arenas,\n                                                      crate_name,\n                                                      output_filenames,\n-                                                     |tcx, _, _, _, _| {\n+                                                     |tcx, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {"}, {"sha": "280f3c8c79677d26e1228e506fa85db151fe9f3c", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::*;\n-use syntax_pos::Span;\n+use syntax_pos::SpanData;\n use rustc::ty::maps::QueryMsg;\n use std::fs::File;\n use std::time::{Duration, Instant};\n@@ -18,7 +18,7 @@ use rustc::dep_graph::{DepNode};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Query {\n-    pub span: Span,\n+    pub span: SpanData,\n     pub msg: QueryMsg,\n }\n pub enum Effect {"}, {"sha": "6de36820f0c19746508b8e849cec7888fa239251", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -30,6 +30,7 @@ use rustc::hir::map as hir_map;\n use rustc::mir::transform::Passes;\n use rustc::session::{self, config};\n use rustc::session::config::{OutputFilenames, OutputTypes};\n+use rustc_trans_utils::trans_crate::TransCrate;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -105,7 +106,7 @@ fn test_env<F>(source_string: &str,\n     options.unstable_features = UnstableFeatures::Allow;\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, emitter);\n \n-    let cstore = Rc::new(CStore::new(box ::MetadataLoader));\n+    let cstore = Rc::new(CStore::new(::DefaultTransCrate::metadata_loader()));\n     let sess = session::build_session_(options,\n                                        None,\n                                        diagnostic_handler,\n@@ -133,7 +134,7 @@ fn test_env<F>(source_string: &str,\n \n     let arena = DroplessArena::new();\n     let arenas = ty::GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n     let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);"}, {"sha": "0329aa8d6741b71e1476089419735d8d86eb3c14", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=d9d877221f65b26e52f49bfc639ef705ff396deb", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Calculation of the (misnamed) \"strict version hash\" for crates and\n-//! items. This hash is used to tell when the HIR changed in such a\n-//! way that results from previous compilations may no longer be\n-//! applicable and hence must be recomputed. It should probably be\n-//! renamed to the ICH (incremental compilation hash).\n-//!\n-//! The hashes for all items are computed once at the beginning of\n-//! compilation and stored into a map. In addition, a hash is computed\n-//! of the **entire crate**.\n-//!\n-//! Storing the hashes in a map avoids the need to compute them twice\n-//! (once when loading prior incremental results and once when\n-//! saving), but it is also important for correctness: at least as of\n-//! the time of this writing, the typeck passes rewrites entries in\n-//! the dep-map in-place to accommodate UFCS resolutions. Since name\n-//! resolution is part of the hash, the result is that hashes computed\n-//! at the end of compilation would be different from those computed\n-//! at the beginning.\n-\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use rustc::hir::map::DefPathHash;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ich::{Fingerprint, StableHashingContext};\n-use rustc::ty::TyCtxt;\n-use rustc::util::common::record_time;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-\n-pub type IchHasher = StableHasher<Fingerprint>;\n-\n-pub struct IncrementalHashesMap {\n-    hashes: FxHashMap<DepNode, Fingerprint>,\n-\n-    // These are the metadata hashes for the current crate as they were stored\n-    // during the last compilation session. They are only loaded if\n-    // -Z query-dep-graph was specified and are needed for auto-tests using\n-    // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n-    // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n-}\n-\n-impl IncrementalHashesMap {\n-    pub fn new() -> IncrementalHashesMap {\n-        IncrementalHashesMap {\n-            hashes: FxHashMap(),\n-            prev_metadata_hashes: RefCell::new(FxHashMap()),\n-        }\n-    }\n-\n-    pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n-        assert!(self.hashes.insert(k, v).is_none());\n-    }\n-\n-    pub fn iter<'a>(&'a self)\n-                    -> ::std::collections::hash_map::Iter<'a, DepNode, Fingerprint> {\n-        self.hashes.iter()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.hashes.len()\n-    }\n-}\n-\n-impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n-    type Output = Fingerprint;\n-\n-    fn index(&self, index: &'a DepNode) -> &Fingerprint {\n-        match self.hashes.get(index) {\n-            Some(fingerprint) => fingerprint,\n-            None => {\n-                bug!(\"Could not find ICH for {:?}\", index);\n-            }\n-        }\n-    }\n-}\n-\n-struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hcx: StableHashingContext<'tcx>,\n-    hashes: IncrementalHashesMap,\n-}\n-\n-impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              def_index: DefIndex,\n-                                              hash_bodies: bool,\n-                                              item_like: T)\n-        where T: HashStable<StableHashingContext<'tcx>>\n-    {\n-        if !hash_bodies && !self.tcx.sess.opts.build_dep_graph() {\n-            // If we just need the hashes in order to compute the SVH, we don't\n-            // need have two hashes per item. Just the one containing also the\n-            // item's body is sufficient.\n-            return\n-        }\n-\n-        let def_path_hash = self.hcx.local_def_path_hash(def_index);\n-\n-        let mut hasher = IchHasher::new();\n-        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n-            item_like.hash_stable(hcx, &mut hasher);\n-        });\n-\n-        let bytes_hashed = hasher.bytes_hashed();\n-        let item_hash = hasher.finish();\n-        let dep_node = if hash_bodies {\n-            def_path_hash.to_dep_node(DepKind::HirBody)\n-        } else {\n-            def_path_hash.to_dep_node(DepKind::Hir)\n-        };\n-        debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n-        self.hashes.insert(dep_node, item_hash);\n-\n-        let bytes_hashed =\n-            self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() + bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n-\n-        if hash_bodies {\n-            let in_scope_traits_map = self.tcx.in_scope_traits_map(def_index);\n-            let mut hasher = IchHasher::new();\n-            in_scope_traits_map.hash_stable(&mut self.hcx, &mut hasher);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::InScopeTraits);\n-            self.hashes.insert(dep_node, hasher.finish());\n-        }\n-    }\n-\n-    fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n-\n-        let mut crate_state = IchHasher::new();\n-\n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n-        \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.as_str().len().hash(&mut crate_state);\n-        crate_disambiguator.as_str().hash(&mut crate_state);\n-\n-        // add each item (in some deterministic order) to the overall\n-        // crate hash.\n-        {\n-            let mut item_hashes: Vec<_> =\n-                self.hashes.iter()\n-                           .filter_map(|(&item_dep_node, &item_hash)| {\n-                                // This `match` determines what kinds of nodes\n-                                // go into the SVH:\n-                                match item_dep_node.kind {\n-                                    DepKind::InScopeTraits |\n-                                    DepKind::Hir |\n-                                    DepKind::HirBody => {\n-                                        // We want to incoporate these into the\n-                                        // SVH.\n-                                    }\n-                                    DepKind::AllLocalTraitImpls => {\n-                                        // These are already covered by hashing\n-                                        // the HIR.\n-                                        return None\n-                                    }\n-                                    ref other => {\n-                                        bug!(\"Found unexpected DepKind during \\\n-                                              SVH computation: {:?}\",\n-                                             other)\n-                                    }\n-                                }\n-\n-                                Some((item_dep_node, item_hash))\n-                           })\n-                           .collect();\n-            item_hashes.sort_unstable(); // avoid artificial dependencies on item ordering\n-            item_hashes.hash(&mut crate_state);\n-        }\n-\n-        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n-\n-        let crate_hash = crate_state.finish();\n-        self.hashes.insert(DepNode::new_no_params(DepKind::Krate), crate_hash);\n-        debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n-    }\n-\n-    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n-        let hir::Crate {\n-            ref module,\n-            // Crate attributes are not copied over to the root `Mod`, so hash\n-            // them explicitly here.\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 false,\n-                                                 (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 true,\n-                                                 (module, (span, attrs)));\n-    }\n-\n-    fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n-    {\n-        let tcx = self.tcx;\n-\n-        let mut impls: Vec<(DefPathHash, Fingerprint)> = krate\n-            .trait_impls\n-            .iter()\n-            .map(|(&trait_id, impls)| {\n-                let trait_id = tcx.def_path_hash(trait_id);\n-                let mut impls: AccumulateVec<[_; 32]> = impls\n-                    .iter()\n-                    .map(|&node_id| {\n-                        let def_id = tcx.hir.local_def_id(node_id);\n-                        tcx.def_path_hash(def_id)\n-                    })\n-                    .collect();\n-\n-                impls.sort_unstable();\n-                let mut hasher = StableHasher::new();\n-                impls.hash_stable(&mut self.hcx, &mut hasher);\n-                (trait_id, hasher.finish())\n-            })\n-            .collect();\n-\n-        impls.sort_unstable();\n-\n-        let mut default_impls: AccumulateVec<[_; 32]> = krate\n-            .trait_default_impl\n-            .iter()\n-            .map(|(&trait_def_id, &impl_node_id)| {\n-                let impl_def_id = tcx.hir.local_def_id(impl_node_id);\n-                (tcx.def_path_hash(trait_def_id), tcx.def_path_hash(impl_def_id))\n-            })\n-            .collect();\n-\n-        default_impls.sort_unstable();\n-\n-        let mut hasher = StableHasher::new();\n-        impls.hash_stable(&mut self.hcx, &mut hasher);\n-\n-        self.hashes.insert(DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n-                           hasher.finish());\n-    }\n-}\n-\n-impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-}\n-\n-\n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-\n-    let mut visitor = ComputeItemHashesVisitor {\n-        tcx,\n-        hcx: tcx.create_stable_hashing_context(),\n-        hashes: IncrementalHashesMap::new(),\n-    };\n-\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.hash_crate_root_module(krate);\n-        krate.visit_all_item_likes(&mut visitor);\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            let def_index = tcx.hir.local_def_id(macro_def.id).index;\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        false,\n-                                                        macro_def);\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        true,\n-                                                        macro_def);\n-        }\n-\n-        visitor.compute_and_store_ich_for_trait_impls(krate);\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}"}, {"sha": "0fba6d8e9c67d13403e03f1d8d2807cc90cf8922", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -28,14 +28,11 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod assert_dep_graph;\n-mod calculate_svh;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use calculate_svh::compute_incremental_hashes_map;\n-pub use calculate_svh::IncrementalHashesMap;\n-pub use calculate_svh::IchHasher;\n pub use persist::load_dep_graph;\n+pub use persist::load_dep_graph_new;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;\n pub use persist::save_work_products;"}, {"sha": "9050702e3ca71f5598d0be85ba48189197c2978f", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -70,14 +70,6 @@ impl SerializedDepGraph {\n          RustcEncodable, RustcDecodable)]\n pub struct DepNodeIndex(pub u32);\n \n-impl DepNodeIndex {\n-    #[inline]\n-    pub fn new(idx: usize) -> DepNodeIndex {\n-        assert!(idx <= ::std::u32::MAX as usize);\n-        DepNodeIndex(idx as u32)\n-    }\n-}\n-\n impl Idx for DepNodeIndex {\n     #[inline]\n     fn new(idx: usize) -> Self {"}, {"sha": "a6d39a918631c67c49e5d5855618c5404a2b3878", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 25, "deletions": 80, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,18 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Debugging code to test the state of the dependency graph just\n-//! after it is loaded from disk and just after it has been saved.\n+//! Debugging code to test fingerprints computed for query results.\n //! For each node marked with `#[rustc_clean]` or `#[rustc_dirty]`,\n-//! we will check that a suitable node for that item either appears\n-//! or does not appear in the dep-graph, as appropriate:\n+//! we will compare the fingerprint from the current and from the previous\n+//! compilation session as appropriate:\n //!\n //! - `#[rustc_dirty(label=\"TypeckTables\", cfg=\"rev2\")]` if we are\n-//!   in `#[cfg(rev2)]`, then there MUST NOT be a node\n-//!   `DepNode::TypeckTables(X)` where `X` is the def-id of the\n-//!   current node.\n+//!   in `#[cfg(rev2)]`, then the fingerprints associated with\n+//!   `DepNode::TypeckTables(X)` must be DIFFERENT (`X` is the def-id of the\n+//!   current node).\n //! - `#[rustc_clean(label=\"TypeckTables\", cfg=\"rev2\")]` same as above,\n-//!   except that the node MUST exist.\n+//!   except that the fingerprints must be the SAME.\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n@@ -40,9 +39,7 @@\n //! previous revision to compare things to.\n //!\n \n-use super::data::DepNodeIndex;\n-use super::load::DirtyNodes;\n-use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -51,41 +48,22 @@ use rustc::ich::{Fingerprint, ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA,\n                  ATTR_CLEAN_METADATA};\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use rustc_data_structures::indexed_vec::IndexVec;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               nodes: &IndexVec<DepNodeIndex, DepNode>,\n-                                               dirty_inputs: &DirtyNodes) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // can't add `#[rustc_dirty]` etc without opting in to this feature\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let dirty_inputs: FxHashSet<DepNode> =\n-        dirty_inputs.keys()\n-                    .filter_map(|dep_node_index| {\n-                        let dep_node = nodes[*dep_node_index];\n-                        if dep_node.extract_def_id(tcx).is_some() {\n-                            Some(dep_node)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-\n-    let query = tcx.dep_graph.query();\n-    debug!(\"query-nodes: {:?}\", query.nodes());\n     let krate = tcx.hir.krate();\n     let mut dirty_clean_visitor = DirtyCleanVisitor {\n         tcx,\n-        query: &query,\n-        dirty_inputs,\n         checked_attrs: FxHashSet(),\n     };\n     krate.visit_all_item_likes(&mut dirty_clean_visitor);\n@@ -105,8 +83,6 @@ pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    query: &'a DepGraphQuery,\n-    dirty_inputs: FxHashSet<DepNode>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n@@ -143,59 +119,28 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                // HIR nodes are inputs, so if we are asserting that the HIR node is\n-                // dirty, we check the dirty input set.\n-                if !self.dirty_inputs.contains(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` not found in dirty set, but should be dirty\",\n-                                 dep_node_str));\n-                }\n-            }\n-            _ => {\n-                // Other kinds of nodes would be targets, so check if\n-                // the dep-graph contains the node.\n-                if self.query.contains_node(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` found in dep graph, but should be dirty\", dep_node_str));\n-                }\n-            }\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n+\n+        if current_fingerprint == prev_fingerprint {\n+            let dep_node_str = self.dep_node_str(&dep_node);\n+            self.tcx.sess.span_err(\n+                item_span,\n+                &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                // For HIR nodes, check the inputs.\n-                if self.dirty_inputs.contains(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` found in dirty-node set, but should be clean\",\n-                                 dep_node_str));\n-                }\n-            }\n-            _ => {\n-                // Otherwise, check if the dep-node exists.\n-                if !self.query.contains_node(&dep_node) {\n-                    let dep_node_str = self.dep_node_str(&dep_node);\n-                    self.tcx.sess.span_err(\n-                        item_span,\n-                        &format!(\"`{}` not found in dep graph, but should be clean\",\n-                                 dep_node_str));\n-                }\n-            }\n+        let current_fingerprint = self.tcx.dep_graph.fingerprint_of(&dep_node);\n+        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n+\n+        if current_fingerprint != prev_fingerprint {\n+            let dep_node_str = self.dep_node_str(&dep_node);\n+            self.tcx.sess.span_err(\n+                item_span,\n+                &format!(\"`{}` should be clean but is not\", dep_node_str));\n         }\n     }\n "}, {"sha": "592b8f1a9eb20d402216b979469b8d2cbf9de108", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 5, "deletions": 120, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -114,15 +114,12 @@\n //! unsupported file system and emit a warning in that case. This is not yet\n //! implemented.\n \n-use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc::session::Session;\n-use rustc::ty::TyCtxt;\n use rustc::util::fs as fs_util;\n use rustc_data_structures::{flock, base_n};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n-use std::ffi::OsString;\n use std::fs as std_fs;\n use std::io;\n use std::mem;\n@@ -132,6 +129,7 @@ use std::__rand::{thread_rng, Rng};\n \n const LOCK_FILE_EXT: &'static str = \".lock\";\n const DEP_GRAPH_FILENAME: &'static str = \"dep-graph.bin\";\n+const DEP_GRAPH_NEW_FILENAME: &'static str = \"dep-graph-new.bin\";\n const WORK_PRODUCTS_FILENAME: &'static str = \"work-products.bin\";\n const METADATA_HASHES_FILENAME: &'static str = \"metadata.bin\";\n \n@@ -145,6 +143,10 @@ pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n \n+pub fn dep_graph_path_new(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, DEP_GRAPH_NEW_FILENAME)\n+}\n+\n pub fn work_products_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, WORK_PRODUCTS_FILENAME)\n }\n@@ -153,10 +155,6 @@ pub fn metadata_hash_export_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, METADATA_HASHES_FILENAME)\n }\n \n-pub fn metadata_hash_import_path(import_session_dir: &Path) -> PathBuf {\n-    import_session_dir.join(METADATA_HASHES_FILENAME)\n-}\n-\n pub fn lock_file_path(session_dir: &Path) -> PathBuf {\n     let crate_dir = session_dir.parent().unwrap();\n \n@@ -616,70 +614,6 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n     Ok(UNIX_EPOCH + duration)\n }\n \n-fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n-}\n-\n-/// Finds the session directory containing the correct metadata hashes file for\n-/// the given crate. In order to do that it has to compute the crate directory\n-/// of the given crate, and in there, look for the session directory with the\n-/// correct SVH in it.\n-/// Note that we have to match on the exact SVH here, not just the\n-/// crate's (name, disambiguator) pair. The metadata hashes are only valid for\n-/// the exact version of the binary we are reading from now (i.e. the hashes\n-/// are part of the dependency graph of a specific compilation session).\n-pub fn find_metadata_hashes_for(tcx: TyCtxt, cnum: CrateNum) -> Option<PathBuf> {\n-    let crate_directory = crate_path_tcx(tcx, cnum);\n-\n-    if !crate_directory.exists() {\n-        return None\n-    }\n-\n-    let dir_entries = match crate_directory.read_dir() {\n-        Ok(dir_entries) => dir_entries,\n-        Err(e) => {\n-            tcx.sess\n-               .err(&format!(\"incremental compilation: Could not read crate directory `{}`: {}\",\n-                             crate_directory.display(), e));\n-            return None\n-        }\n-    };\n-\n-    let target_svh = tcx.crate_hash(cnum);\n-    let target_svh = base_n::encode(target_svh.as_u64(), INT_ENCODE_BASE);\n-\n-    let sub_dir = find_metadata_hashes_iter(&target_svh, dir_entries.filter_map(|e| {\n-        e.ok().map(|e| e.file_name().to_string_lossy().into_owned())\n-    }));\n-\n-    sub_dir.map(|sub_dir_name| crate_directory.join(&sub_dir_name))\n-}\n-\n-fn find_metadata_hashes_iter<'a, I>(target_svh: &str, iter: I) -> Option<OsString>\n-    where I: Iterator<Item=String>\n-{\n-    for sub_dir_name in iter {\n-        if !is_session_directory(&sub_dir_name) || !is_finalized(&sub_dir_name) {\n-            // This is not a usable session directory\n-            continue\n-        }\n-\n-        let is_match = if let Some(last_dash_pos) = sub_dir_name.rfind(\"-\") {\n-            let candidate_svh = &sub_dir_name[last_dash_pos + 1 .. ];\n-            target_svh == candidate_svh\n-        } else {\n-            // some kind of invalid directory name\n-            continue\n-        };\n-\n-        if is_match {\n-            return Some(OsString::from(sub_dir_name))\n-        }\n-    }\n-\n-    None\n-}\n-\n fn crate_path(sess: &Session,\n               crate_name: &str,\n               crate_disambiguator: &str)\n@@ -1019,52 +953,3 @@ fn test_find_source_directory_in_iter() {\n              PathBuf::from(\"crate-dir/s-1234-0000-working\")].into_iter(), &already_visited),\n         None);\n }\n-\n-#[test]\n-fn test_find_metadata_hashes_iter()\n-{\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2\"),\n-            String::from(\"s-timestamp3-testsvh3\"),\n-        ].into_iter()),\n-        Some(OsString::from(\"s-timestamp2-testsvh2\"))\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2\"),\n-            String::from(\"invalid-name\"),\n-        ].into_iter()),\n-        Some(OsString::from(\"s-timestamp2-testsvh2\"))\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"s-timestamp1-testsvh1\"),\n-            String::from(\"s-timestamp2-testsvh2-working\"),\n-            String::from(\"s-timestamp3-testsvh3\"),\n-        ].into_iter()),\n-        None\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh1\",\n-        vec![\n-            String::from(\"s-timestamp1-random1-working\"),\n-            String::from(\"s-timestamp2-random2-working\"),\n-            String::from(\"s-timestamp3-random3-working\"),\n-        ].into_iter()),\n-        None\n-    );\n-\n-    assert_eq!(find_metadata_hashes_iter(\"testsvh2\",\n-        vec![\n-            String::from(\"timestamp1-testsvh2\"),\n-            String::from(\"timestamp2-testsvh2\"),\n-            String::from(\"timestamp3-testsvh2\"),\n-        ].into_iter()),\n-        None\n-    );\n-}"}, {"sha": "8355f319139386b013204024f02ef5e60617c384", "filename": "src/librustc_incremental/persist/hash.rs", "status": "removed", "additions": 0, "deletions": 227, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9d877221f65b26e52f49bfc639ef705ff396deb/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=d9d877221f65b26e52f49bfc639ef705ff396deb", "patch": "@@ -1,227 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::hir::svh::Svh;\n-use rustc::ich::Fingerprint;\n-use rustc::ty::TyCtxt;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::flock;\n-use rustc_serialize::Decodable;\n-use rustc_serialize::opaque::Decoder;\n-\n-use IncrementalHashesMap;\n-use super::data::*;\n-use super::fs::*;\n-use super::file_format;\n-\n-use std::hash::Hash;\n-use std::fmt::Debug;\n-\n-pub struct HashContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    incremental_hashes_map: &'a IncrementalHashesMap,\n-    metadata_hashes: FxHashMap<DefId, Fingerprint>,\n-    crate_hashes: FxHashMap<CrateNum, Svh>,\n-}\n-\n-impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               incremental_hashes_map: &'a IncrementalHashesMap)\n-               -> Self {\n-        HashContext {\n-            tcx,\n-            incremental_hashes_map,\n-            metadata_hashes: FxHashMap(),\n-            crate_hashes: FxHashMap(),\n-        }\n-    }\n-\n-    pub fn is_hashable(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::InScopeTraits |\n-            DepKind::HirBody =>\n-                true,\n-            DepKind::MetaData => {\n-                let def_id = dep_node.extract_def_id(tcx).unwrap();\n-                !def_id.is_local()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        match dep_node.kind {\n-            DepKind::Krate => {\n-                Some(self.incremental_hashes_map[dep_node])\n-            }\n-\n-            // HIR nodes (which always come from our crate) are an input:\n-            DepKind::InScopeTraits |\n-            DepKind::Hir |\n-            DepKind::HirBody => {\n-                Some(self.incremental_hashes_map[dep_node])\n-            }\n-\n-            // MetaData from other crates is an *input* to us.\n-            // MetaData nodes from *our* crates are an *output*; we\n-            // don't hash them, but we do compute a hash for them and\n-            // save it for others to use.\n-            DepKind::MetaData => {\n-                let def_id = dep_node.extract_def_id(self.tcx).unwrap();\n-                if !def_id.is_local() {\n-                    Some(self.metadata_hash(def_id,\n-                                        def_id.krate,\n-                                        |this| &mut this.metadata_hashes))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            _ => {\n-                // Other kinds of nodes represent computed by-products\n-                // that we don't hash directly; instead, they should\n-                // have some transitive dependency on a Hir or\n-                // MetaData node, so we'll just hash that\n-                None\n-            }\n-        }\n-    }\n-\n-    fn metadata_hash<K, C>(&mut self,\n-                           key: K,\n-                           cnum: CrateNum,\n-                           cache: C)\n-                           -> Fingerprint\n-        where K: Hash + Eq + Debug,\n-              C: Fn(&mut Self) -> &mut FxHashMap<K, Fingerprint>,\n-    {\n-        debug!(\"metadata_hash(key={:?})\", key);\n-\n-        debug_assert!(cnum != LOCAL_CRATE);\n-        loop {\n-            // check whether we have a result cached for this def-id\n-            if let Some(&hash) = cache(self).get(&key) {\n-                return hash;\n-            }\n-\n-            // check whether we did not find detailed metadata for this\n-            // krate; in that case, we just use the krate's overall hash\n-            if let Some(&svh) = self.crate_hashes.get(&cnum) {\n-                // micro-\"optimization\": avoid a cache miss if we ask\n-                // for metadata from this particular def-id again.\n-                let fingerprint = svh_to_fingerprint(svh);\n-                cache(self).insert(key, fingerprint);\n-\n-                return fingerprint;\n-            }\n-\n-            // otherwise, load the data and repeat.\n-            self.load_data(cnum);\n-            assert!(self.crate_hashes.contains_key(&cnum));\n-        }\n-    }\n-\n-    fn load_data(&mut self, cnum: CrateNum) {\n-        debug!(\"load_data(cnum={})\", cnum);\n-\n-        let svh = self.tcx.crate_hash(cnum);\n-        let old = self.crate_hashes.insert(cnum, svh);\n-        debug!(\"load_data: svh={}\", svh);\n-        assert!(old.is_none(), \"loaded data for crate {:?} twice\", cnum);\n-\n-        if let Some(session_dir) = find_metadata_hashes_for(self.tcx, cnum) {\n-            debug!(\"load_data: session_dir={:?}\", session_dir);\n-\n-            // Lock the directory we'll be reading  the hashes from.\n-            let lock_file_path = lock_file_path(&session_dir);\n-            let _lock = match flock::Lock::new(&lock_file_path,\n-                                               false,   // don't wait\n-                                               false,   // don't create the lock-file\n-                                               false) { // shared lock\n-                Ok(lock) => lock,\n-                Err(err) => {\n-                    debug!(\"Could not acquire lock on `{}` while trying to \\\n-                            load metadata hashes: {}\",\n-                            lock_file_path.display(),\n-                            err);\n-\n-                    // Could not acquire the lock. The directory is probably in\n-                    // in the process of being deleted. It's OK to just exit\n-                    // here. It's the same scenario as if the file had not\n-                    // existed in the first place.\n-                    return\n-                }\n-            };\n-\n-            let hashes_file_path = metadata_hash_import_path(&session_dir);\n-\n-            match file_format::read_file(self.tcx.sess, &hashes_file_path)\n-            {\n-                Ok(Some(data)) => {\n-                    match self.load_from_data(cnum, &data, svh) {\n-                        Ok(()) => { }\n-                        Err(err) => {\n-                            bug!(\"decoding error in dep-graph from `{}`: {}\",\n-                                 &hashes_file_path.display(), err);\n-                        }\n-                    }\n-                }\n-                Ok(None) => {\n-                    // If the file is not found, that's ok.\n-                }\n-                Err(err) => {\n-                    self.tcx.sess.err(\n-                        &format!(\"could not load dep information from `{}`: {}\",\n-                                 hashes_file_path.display(), err));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn load_from_data(&mut self,\n-                      cnum: CrateNum,\n-                      data: &[u8],\n-                      expected_svh: Svh) -> Result<(), String> {\n-        debug!(\"load_from_data(cnum={})\", cnum);\n-\n-        // Load up the hashes for the def-ids from this crate.\n-        let mut decoder = Decoder::new(data, 0);\n-        let svh_in_hashes_file = Svh::decode(&mut decoder)?;\n-\n-        if svh_in_hashes_file != expected_svh {\n-            // We should not be able to get here. If we do, then\n-            // `fs::find_metadata_hashes_for()` has messed up.\n-            bug!(\"mismatch between SVH in crate and SVH in incr. comp. hashes\")\n-        }\n-\n-        let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder)?;\n-        for serialized_hash in serialized_hashes.entry_hashes {\n-            // the hashes are stored with just a def-index, which is\n-            // always relative to the old crate; convert that to use\n-            // our internal crate number\n-            let def_id = DefId { krate: cnum, index: serialized_hash.def_index };\n-\n-            // record the hash for this dep-node\n-            let old = self.metadata_hashes.insert(def_id, serialized_hash.hash);\n-            debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n-            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-fn svh_to_fingerprint(svh: Svh) -> Fingerprint {\n-    Fingerprint::from_smaller_hash(svh.as_u64())\n-}"}, {"sha": "6d019a25ed3ec4cc83ba4d2132a78b032ae005fc", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 55, "deletions": 32, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,22 +10,19 @@\n \n //! Code to save/load the dep-graph from files.\n \n-use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::dep_graph::{DepNode, WorkProductId, DepKind, PreviousDepGraph};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::{Path};\n \n-use IncrementalHashesMap;\n use super::data::*;\n-use super::dirty_clean;\n-use super::hash::*;\n use super::fs::*;\n use super::file_format;\n use super::work_product;\n@@ -40,16 +37,16 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: &IncrementalHashesMap) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.allocate_metadata_dep_nodes();\n+    tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n-        load_dep_graph_if_exists(tcx, incremental_hashes_map);\n+        load_dep_graph_if_exists(tcx);\n     }\n }\n \n-fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      incremental_hashes_map: &IncrementalHashesMap) {\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let dep_graph_path = dep_graph_path(tcx.sess);\n     let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n         Some(p) => p,\n@@ -62,7 +59,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None => return // no file\n     };\n \n-    match decode_dep_graph(tcx, incremental_hashes_map, &dep_graph_data, &work_products_data) {\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n         Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n@@ -105,7 +102,7 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n         DepKind::Hir |\n         DepKind::HirBody |\n         DepKind::InScopeTraits |\n-        DepKind::MetaData => {\n+        DepKind::CrateMetadata => {\n             dep_node.extract_def_id(tcx).is_some()\n         }\n         _ => {\n@@ -117,7 +114,6 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n                                   -> Result<(), String>\n@@ -150,7 +146,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Compute the set of nodes from the old graph where some input\n     // has changed or been removed.\n     let dirty_raw_nodes = initial_dirty_nodes(tcx,\n-                                              incremental_hashes_map,\n                                               &serialized_dep_graph.nodes,\n                                               &serialized_dep_graph.hashes);\n     let dirty_raw_nodes = transitive_dirty_nodes(&serialized_dep_graph,\n@@ -190,31 +185,21 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n \n-    dirty_clean::check_dirty_clean_annotations(tcx,\n-                                               &serialized_dep_graph.nodes,\n-                                               &dirty_raw_nodes);\n-\n-    load_prev_metadata_hashes(tcx,\n-                              &mut *incremental_hashes_map.prev_metadata_hashes.borrow_mut());\n     Ok(())\n }\n \n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 incremental_hashes_map: &IncrementalHashesMap,\n                                  nodes: &IndexVec<DepNodeIndex, DepNode>,\n                                  serialized_hashes: &[(DepNodeIndex, Fingerprint)])\n                                  -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FxHashMap();\n \n     for &(dep_node_index, prev_hash) in serialized_hashes {\n         let dep_node = nodes[dep_node_index];\n         if does_still_exist(tcx, &dep_node) {\n-            let current_hash = hcx.hash(&dep_node).unwrap_or_else(|| {\n-                bug!(\"Cannot find current ICH for input that still exists?\")\n-            });\n+            let current_hash = tcx.dep_graph.fingerprint_of(&dep_node);\n \n             if current_hash == prev_hash {\n                 debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n@@ -310,11 +295,12 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n     work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n }\n \n-fn load_prev_metadata_hashes(tcx: TyCtxt,\n-                             output: &mut FxHashMap<DefId, Fingerprint>) {\n+pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n+    let mut output = DefIdMap();\n+\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         // Previous metadata hashes are only needed for testing.\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - Loading previous metadata hashes\");\n@@ -324,7 +310,7 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     if !file_path.exists() {\n         debug!(\"load_prev_metadata_hashes() - Couldn't find file containing \\\n                 hashes at `{}`\", file_path.display());\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n@@ -334,12 +320,12 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n                     compiler version: {}\", file_path.display());\n-            return\n+            return output\n         }\n         Err(err) => {\n             debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n                    file_path.display(), err);\n-            return\n+            return output\n         }\n     };\n \n@@ -363,6 +349,8 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n            serialized_hashes.index_map.len());\n+\n+    output\n }\n \n fn process_edge<'a, 'tcx, 'edges>(\n@@ -421,7 +409,7 @@ fn process_edge<'a, 'tcx, 'edges>(\n     // clean target because removing the input would have dirtied the input\n     // node and transitively dirtied the target.\n     debug_assert!(match nodes[source].kind {\n-        DepKind::Hir | DepKind::HirBody | DepKind::MetaData => {\n+        DepKind::Hir | DepKind::HirBody | DepKind::CrateMetadata => {\n             does_still_exist(tcx, &nodes[source])\n         }\n         _ => true,\n@@ -438,3 +426,38 @@ fn process_edge<'a, 'tcx, 'edges>(\n         }\n     }\n }\n+\n+pub fn load_dep_graph_new(sess: &Session) -> PreviousDepGraph {\n+    use rustc::dep_graph::SerializedDepGraph as SerializedDepGraphNew;\n+\n+    let empty = PreviousDepGraph::new(SerializedDepGraphNew::new());\n+\n+    if sess.opts.incremental.is_none() {\n+        return empty\n+    }\n+\n+    if let Some(bytes) = load_data(sess, &dep_graph_path_new(sess)) {\n+        let mut decoder = Decoder::new(&bytes, 0);\n+        let prev_commandline_args_hash = u64::decode(&mut decoder)\n+            .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+\n+        if prev_commandline_args_hash != sess.opts.dep_tracking_hash() {\n+            if sess.opts.debugging_opts.incremental_info {\n+                eprintln!(\"incremental: completely ignoring cache because of \\\n+                           differing commandline arguments\");\n+            }\n+            // We can't reuse the cache, purge it.\n+            debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n+\n+            // No need to do any further work\n+            return empty\n+        }\n+\n+        let dep_graph = SerializedDepGraphNew::decode(&mut decoder)\n+            .expect(\"Error reading cached dep-graph\");\n+\n+        PreviousDepGraph::new(dep_graph)\n+    } else {\n+        empty\n+    }\n+}"}, {"sha": "688d8add57e3fd49f38dc67ebe317f3433ccd2f1", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,7 +15,6 @@\n mod data;\n mod dirty_clean;\n mod fs;\n-mod hash;\n mod load;\n mod preds;\n mod save;\n@@ -26,6 +25,7 @@ pub use self::fs::prepare_session_directory;\n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;\n pub use self::load::load_dep_graph;\n+pub use self::load::load_dep_graph_new;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;"}, {"sha": "a552a27c62af0f9eec9356a9a3e1ed88393d4fbf", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,10 +10,10 @@\n \n use rustc::dep_graph::{DepGraphQuery, DepNode, DepKind};\n use rustc::ich::Fingerprint;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::{Graph, NodeIndex};\n \n-use super::hash::*;\n \n mod compress;\n \n@@ -40,15 +40,13 @@ pub struct Predecessors<'query> {\n }\n \n impl<'q> Predecessors<'q> {\n-    pub fn new(query: &'q DepGraphQuery, hcx: &mut HashContext) -> Self {\n-        let tcx = hcx.tcx;\n-\n+    pub fn new(tcx: TyCtxt, query: &'q DepGraphQuery) -> Self {\n         // Find the set of \"start nodes\". These are nodes that we will\n         // possibly query later.\n         let is_output = |node: &DepNode| -> bool {\n             match node.kind {\n                 DepKind::WorkProduct => true,\n-                DepKind::MetaData => {\n+                DepKind::CrateMetadata => {\n                     // We do *not* create dep-nodes for the current crate's\n                     // metadata anymore, just for metadata that we import/read\n                     // from other crates.\n@@ -66,15 +64,15 @@ impl<'q> Predecessors<'q> {\n         // Reduce the graph to the most important nodes.\n         let compress::Reduction { graph, input_nodes } =\n             compress::reduce_graph(&query.graph,\n-                                   |n| HashContext::is_hashable(tcx, n),\n+                                   |n| n.kind.is_input(),\n                                    |n| is_output(n));\n \n         let mut hashes = FxHashMap();\n         for input_index in input_nodes {\n             let input = *graph.node_data(input_index);\n             debug!(\"computing hash for input node `{:?}`\", input);\n             hashes.entry(input)\n-                  .or_insert_with(|| hcx.hash(input).unwrap());\n+                  .or_insert_with(|| tcx.dep_graph.fingerprint_of(&input));\n         }\n \n         if tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -89,7 +87,7 @@ impl<'q> Predecessors<'q> {\n \n             for node in hir_nodes {\n                 hashes.entry(node)\n-                      .or_insert_with(|| hcx.hash(node).unwrap());\n+                      .or_insert_with(|| tcx.dep_graph.fingerprint_of(&node));\n             }\n         }\n "}, {"sha": "fd699229f1b7380d1f8013f2e1990110c851ab3d", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,26 +15,27 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::common::time;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n-use IncrementalHashesMap;\n use super::data::*;\n-use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n+use super::load::load_prev_metadata_hashes;\n+\n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: IncrementalHashesMap,\n                                 metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n@@ -44,15 +45,14 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n-    let query = tcx.dep_graph.query();\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n-        eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n-    }\n+    // We load the previous metadata hashes now before overwriting the file\n+    // (if we need them for testing).\n+    let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n+        load_prev_metadata_hashes(tcx)\n+    } else {\n+        DefIdMap()\n+    };\n \n-    let mut hcx = HashContext::new(tcx, &incremental_hashes_map);\n-    let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n     // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n@@ -69,13 +69,29 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            e));\n     }\n \n-    save_in(sess,\n-            dep_graph_path(sess),\n-            |e| encode_dep_graph(tcx, &preds, e));\n+    time(sess.time_passes(), \"persist dep-graph (old)\", || {\n+        let query = tcx.dep_graph.query();\n+\n+        if tcx.sess.opts.debugging_opts.incremental_info {\n+            eprintln!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n+            eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n+        }\n+\n+        let preds = Predecessors::new(tcx, &query);\n+        save_in(sess,\n+                dep_graph_path(sess),\n+                |e| encode_dep_graph(tcx, &preds, e));\n+    });\n \n-    let prev_metadata_hashes = incremental_hashes_map.prev_metadata_hashes.borrow();\n+    time(sess.time_passes(), \"persist dep-graph (new)\", || {\n+        save_in(sess,\n+                dep_graph_path_new(sess),\n+                |e| encode_dep_graph_new(tcx, e));\n+    });\n+\n+    dirty_clean::check_dirty_clean_annotations(tcx);\n     dirty_clean::check_dirty_clean_metadata(tcx,\n-                                            &*prev_metadata_hashes,\n+                                            &prev_metadata_hashes,\n                                             &current_metadata_hashes);\n }\n \n@@ -166,6 +182,19 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     }\n }\n \n+fn encode_dep_graph_new(tcx: TyCtxt,\n+                        encoder: &mut Encoder)\n+                        -> io::Result<()> {\n+    // First encode the commandline arguments hash\n+    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n+\n+    // Encode the graph data.\n+    let serialized_graph = tcx.dep_graph.serialize();\n+    serialized_graph.encode(encoder)?;\n+\n+    Ok(())\n+}\n+\n pub fn encode_dep_graph(tcx: TyCtxt,\n                         preds: &Predecessors,\n                         encoder: &mut Encoder)"}, {"sha": "cbc012a65faad04444c139df5e169deab1f4e06d", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_lifetime_def(&mut self, cx: &LateContext, t: &hir::LifetimeDef) {\n         self.check_snake_case(cx,\n                               \"lifetime\",\n-                              &t.lifetime.name.as_str(),\n+                              &t.lifetime.name.name().as_str(),\n                               Some(t.lifetime.span));\n     }\n "}, {"sha": "b97920dd18b77a1caccc3a9f2256c23393298573", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -153,6 +153,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n \n         let mut fn_warned = false;\n+        let mut op_warned = false;\n         if cx.tcx.sess.features.borrow().fn_must_use {\n             let maybe_def = match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n@@ -172,9 +173,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 let def_id = def.def_id();\n                 fn_warned = check_must_use(cx, def_id, s.span, \"return value of \");\n             }\n+\n+            if let hir::ExprBinary(bin_op, ..) = expr.node {\n+                match bin_op.node {\n+                    // Hardcoding the comparison operators here seemed more\n+                    // expedient than the refactoring that would be needed to\n+                    // look up the `#[must_use]` attribute which does exist on\n+                    // the comparison trait methods\n+                    hir::BiEq | hir::BiLt | hir::BiLe | hir::BiNe | hir::BiGe | hir::BiGt => {\n+                        let msg = \"unused comparison which must be used\";\n+                        cx.span_lint(UNUSED_MUST_USE, expr.span, msg);\n+                        op_warned = true;\n+                    },\n+                    _ => {},\n+                }\n+            }\n         }\n \n-        if !(ty_warned || fn_warned) {\n+        if !(ty_warned || fn_warned || op_warned) {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n "}, {"sha": "de5add56b761d1afb44d9b478c06044211a874f1", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,4 +18,4 @@ rustc_cratesio_shim = { path = \"../librustc_cratesio_shim\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\"\n+cc = \"1.0\""}, {"sha": "dde7a38efc7965b483f62e8fed764d82f9c4dfac", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate gcc;\n+extern crate cc;\n extern crate build_helper;\n \n use std::process::Command;\n@@ -136,7 +136,7 @@ fn main() {\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--cxxflags\");\n     let cxxflags = output(&mut cmd);\n-    let mut cfg = gcc::Build::new();\n+    let mut cfg = cc::Build::new();\n     cfg.warnings(false);\n     for flag in cxxflags.split_whitespace() {\n         // Ignore flags like `-m64` when we're doing a cross build"}, {"sha": "8eacc21ab003b59e96b6d303ea9671230a4a8edf", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -55,9 +55,14 @@ macro_rules! provide {\n                 let ($def_id, $other) = def_id_arg.into_args();\n                 assert!(!$def_id.is_local());\n \n-                let def_path_hash = $tcx.def_path_hash($def_id);\n-                let dep_node = def_path_hash.to_dep_node(::rustc::dep_graph::DepKind::MetaData);\n-\n+                let def_path_hash = $tcx.def_path_hash(DefId {\n+                    krate: $def_id.krate,\n+                    index: CRATE_DEF_INDEX\n+                });\n+                let dep_node = def_path_hash\n+                    .to_dep_node(::rustc::dep_graph::DepKind::CrateMetadata);\n+                // The DepNodeIndex of the DepNode::CrateMetadata should be\n+                // cached somewhere, so that we can use read_index().\n                 $tcx.dep_graph.read(dep_node);\n \n                 let $cdata = $tcx.crate_data_as_rc_any($def_id.krate);\n@@ -379,6 +384,16 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(cnum).name\n     }\n \n+    fn crate_disambiguator_untracked(&self, cnum: CrateNum) -> Symbol\n+    {\n+        self.get_crate_data(cnum).disambiguator()\n+    }\n+\n+    fn crate_hash_untracked(&self, cnum: CrateNum) -> hir::svh::Svh\n+    {\n+        self.get_crate_data(cnum).hash()\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to."}, {"sha": "902e2de841f264d5128c724adb9c9e98eb18904c", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 387, "deletions": 363, "changes": 750, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -173,14 +173,23 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n         let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n+                // NOTE: NLL RFC calls for *shallow* write; using Deep\n+                // for short-term compat w/ AST-borrowck. Also, switch\n+                // to shallow requires to dataflow: \"if this is an\n+                // assignment `lv = <rvalue>`, then any loan for some\n+                // path P of which `lv` is a prefix is killed.\"\n                 self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n-                                   (lhs, span), JustWrite, flow_state);\n+                                   (lhs, span), Deep, JustWrite, flow_state);\n+\n                 self.consume_rvalue(ContextKind::AssignRhs.new(location),\n                                     (rhs, span), location, flow_state);\n             }\n             StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n                 self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n-                                   (lvalue, span), JustWrite, flow_state);\n+                                   (lvalue, span),\n+                                   Shallow(Some(ArtificialField::Discriminant)),\n+                                   JustWrite,\n+                                   flow_state);\n             }\n             StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 for (o, output) in asm.outputs.iter().zip(outputs) {\n@@ -192,6 +201,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                     } else {\n                         self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n                                            (output, span),\n+                                           Deep,\n                                            if o.is_rw { WriteAndRead } else { JustWrite },\n                                            flow_state);\n                     }\n@@ -209,15 +219,15 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n             StatementKind::Nop |\n             StatementKind::Validate(..) |\n             StatementKind::StorageLive(..) => {\n-                // ignored by borrowck\n+                // `Nop`, `Validate`, and `StorageLive` are irrelevant\n+                // to borrow check.\n             }\n \n             StatementKind::StorageDead(local) => {\n-                // causes non-drop values to be dropped.\n-                self.consume_lvalue(ContextKind::StorageDead.new(location),\n-                                    ConsumeKind::Consume,\n-                                    (&Lvalue::Local(local), span),\n-                                    flow_state)\n+                self.access_lvalue(ContextKind::StorageDead.new(location),\n+                                   (&Lvalue::Local(local), span),\n+                                   (Shallow(None), Write(WriteKind::StorageDead)),\n+                                   flow_state);\n             }\n         }\n     }\n@@ -246,7 +256,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                                              target: _,\n                                              unwind: _ } => {\n                 self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n-                                   (drop_lvalue, span), JustWrite, flow_state);\n+                                   (drop_lvalue, span),\n+                                   Deep,\n+                                   JustWrite,\n+                                   flow_state);\n                 self.consume_operand(ContextKind::DropAndReplace.new(loc),\n                                      ConsumeKind::Drop,\n                                      (new_value, span), flow_state);\n@@ -262,7 +275,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                 }\n                 if let Some((ref dest, _/*bb*/)) = *destination {\n                     self.mutate_lvalue(ContextKind::CallDest.new(loc),\n-                                       (dest, span), JustWrite, flow_state);\n+                                       (dest, span),\n+                                       Deep,\n+                                       JustWrite,\n+                                       flow_state);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n@@ -309,29 +325,121 @@ enum ConsumeKind { Drop, Consume }\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum Control { Continue, Break }\n \n+use self::ShallowOrDeep::{Shallow, Deep};\n+use self::ReadOrWrite::{Read, Write};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ArtificialField {\n+    Discriminant,\n+    ArrayLength,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ShallowOrDeep {\n+    /// From the RFC: \"A *shallow* access means that the immediate\n+    /// fields reached at LV are accessed, but references or pointers\n+    /// found within are not dereferenced. Right now, the only access\n+    /// that is shallow is an assignment like `x = ...;`, which would\n+    /// be a *shallow write* of `x`.\"\n+    Shallow(Option<ArtificialField>),\n+\n+    /// From the RFC: \"A *deep* access means that all data reachable\n+    /// through the given lvalue may be invalidated or accesses by\n+    /// this action.\"\n+    Deep,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadOrWrite {\n+    /// From the RFC: \"A *read* means that the existing data may be\n+    /// read, but will not be changed.\"\n+    Read(ReadKind),\n+\n+    /// From the RFC: \"A *write* means that the data may be mutated to\n+    /// new values or otherwise invalidated (for example, it could be\n+    /// de-initialized, as in a move operation).\n+    Write(WriteKind),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadKind {\n+    Borrow(BorrowKind),\n+    Copy,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteKind {\n+    StorageDead,\n+    MutableBorrow(BorrowKind),\n+    Mutate,\n+    Move,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn access_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: (ShallowOrDeep, ReadOrWrite),\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: also need to check permissions (e.g. reject mut\n+        // borrow of immutable ref, moves through non-`Box`-ref)\n+        let (sd, rw) = kind;\n+        self.each_borrow_involving_path(\n+            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow| {\n+                match (rw, borrow.kind) {\n+                    (Read(_), BorrowKind::Shared) => {\n+                        Control::Continue\n+                    }\n+                    (Read(kind), BorrowKind::Unique) |\n+                    (Read(kind), BorrowKind::Mut) => {\n+                        match kind {\n+                            ReadKind::Copy =>\n+                                this.report_use_while_mutably_borrowed(\n+                                    context, lvalue_span, borrow),\n+                            ReadKind::Borrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                        }\n+                        Control::Break\n+                    }\n+                    (Write(kind), _) => {\n+                        match kind {\n+                            WriteKind::MutableBorrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                            WriteKind::StorageDead |\n+                            WriteKind::Mutate =>\n+                                this.report_illegal_mutation_of_borrowed(\n+                                    context, lvalue_span, borrow),\n+                            WriteKind::Move =>\n+                                this.report_move_out_while_borrowed(\n+                                    context, lvalue_span, borrow),\n+                        }\n+                        Control::Break\n+                    }\n+                }\n+            });\n+    }\n+\n     fn mutate_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: ShallowOrDeep,\n                      mode: MutateMode,\n                      flow_state: &InProgress<'b, 'gcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"update\", lvalue_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n                 self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n             }\n         }\n \n-        // check we don't invalidate any outstanding loans\n-        self.each_borrow_involving_path(context,\n-                                        lvalue_span.0, flow_state, |this, _index, _data| {\n-                                            this.report_illegal_mutation_of_borrowed(context,\n-                                                                                     lvalue_span);\n-                                            Control::Break\n-                                        });\n+        self.access_lvalue(context, lvalue_span, (kind, Write(WriteKind::Mutate)), flow_state);\n \n         // check for reassignments to immutable local variables\n         self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n@@ -340,11 +448,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_rvalue(&mut self,\n                       context: Context,\n                       (rvalue, span): (&Rvalue<'gcx>, Span),\n-                      location: Location,\n+                      _location: Location,\n                       flow_state: &InProgress<'b, 'gcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n-                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+                let access_kind = match bk {\n+                    BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n+                    BorrowKind::Unique |\n+                    BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n+                };\n+                self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n+                self.check_if_path_is_moved(context, \"borrow\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -356,8 +470,14 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n             Rvalue::Len(ref lvalue) |\n             Rvalue::Discriminant(ref lvalue) => {\n-                // len(_)/discriminant(_) merely read, not consume.\n-                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+                let af = match *rvalue {\n+                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n+                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    _ => unreachable!(),\n+                };\n+                self.access_lvalue(\n+                    context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n+                self.check_if_path_is_moved(context, \"use\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -388,8 +508,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                        (operand, span): (&Operand<'gcx>, Span),\n                        flow_state: &InProgress<'b, 'gcx>) {\n         match *operand {\n-            Operand::Consume(ref lvalue) =>\n-                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Consume(ref lvalue) => {\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n+            }\n             Operand::Constant(_) => {}\n         }\n     }\n@@ -405,26 +526,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n         if moves_by_default {\n             // move of lvalue: check if this is move of already borrowed path\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Mut) {\n-                        this.report_move_out_while_borrowed(context, lvalue_span);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)), flow_state);\n         } else {\n             // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Shared) {\n-                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n         }\n \n         // Finally, check if path was already moved.\n@@ -435,22 +540,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 // skip this check in that case).\n             }\n             ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"use\", lvalue_span, flow_state);\n             }\n         }\n     }\n-\n-    fn borrow(&mut self,\n-              context: Context,\n-              location: Location,\n-              bk: BorrowKind,\n-              lvalue_span: (&Lvalue<'gcx>, Span),\n-              flow_state: &InProgress<'b, 'gcx>) {\n-        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n-               location, lvalue_span.0, lvalue_span.1);\n-        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n-    }\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n@@ -487,13 +580,26 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             if flow_state.inits.curr_state.contains(&mpi) {\n                 // may already be assigned before reaching this statement;\n                 // report error.\n-                self.report_illegal_reassignment(context, (lvalue, span));\n+                // FIXME: Not ideal, it only finds the assignment that lexically comes first\n+                let assigned_lvalue = &move_data.move_paths[mpi].lvalue;\n+                let assignment_stmt = self.mir.basic_blocks().iter().filter_map(|bb| {\n+                    bb.statements.iter().find(|stmt| {\n+                        if let StatementKind::Assign(ref lv, _) = stmt.kind {\n+                            *lv == *assigned_lvalue\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                }).next().unwrap();\n+                self.report_illegal_reassignment(\n+                    context, (lvalue, span), assignment_stmt.source_info.span);\n             }\n         }\n     }\n \n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n+                              desired_action: &str,\n                               lvalue_span: (&Lvalue<'gcx>, Span),\n                               flow_state: &InProgress<'b, 'gcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n@@ -505,7 +611,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n             if maybe_uninits.curr_state.contains(&mpi) {\n                 // find and report move(s) that could cause this to be uninitialized\n-                self.report_use_of_moved(context, lvalue_span);\n+                self.report_use_of_moved(context, desired_action, lvalue_span);\n             } else {\n                 // sanity check: initialized on *some* path, right?\n                 assert!(flow_state.inits.curr_state.contains(&mpi));\n@@ -572,8 +678,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                     // check_loans.rs first maps\n                                     // `base` to its base_path.\n \n-                                    self.check_if_path_is_moved(context,\n-                                                                (base, span), flow_state);\n+                                    self.check_if_path_is_moved(\n+                                        context, \"assignment\", (base, span), flow_state);\n \n                                     // (base initialized; no need to\n                                     // recur further)\n@@ -590,72 +696,18 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n-\n-    fn check_for_conflicting_loans(&mut self,\n-                                   context: Context,\n-                                   _location: Location,\n-                                   _bk: BorrowKind,\n-                                   lvalue_span: (&Lvalue<'gcx>, Span),\n-                                   flow_state: &InProgress<'b, 'gcx>) {\n-        // NOTE FIXME: The analogous code in old borrowck\n-        // check_loans.rs is careful to iterate over every *issued*\n-        // loan, as opposed to just the in scope ones.\n-        //\n-        // (Or if you prefer, all the *other* iterations over loans\n-        // only consider loans that are in scope of some given\n-        // region::Scope)\n-        //\n-        // The (currently skeletal) code here does not encode such a\n-        // distinction, which means it is almost certainly over\n-        // looking something.\n-        //\n-        // (It is probably going to reject code that should be\n-        // accepted, I suspect, by treated issued-but-out-of-scope\n-        // loans as issued-and-in-scope, and thus causing them to\n-        // interfere with other loans.)\n-        //\n-        // However, I just want to get something running, especially\n-        // since I am trying to move into new territory with NLL, so\n-        // lets get this going first, and then address the issued vs\n-        // in-scope distinction later.\n-\n-        let state = &flow_state.borrows;\n-        let data = &state.base_results.operator().borrows();\n-\n-        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n-\n-        // does any loan generated here conflict with a previously issued loan?\n-        let mut loans_generated = 0;\n-        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n-            loans_generated += 1;\n-            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n-                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n-                       (g, gen, self.base_path(&gen.lvalue),\n-                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n-                       (i, issued, self.base_path(&issued.lvalue),\n-                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n-                       self.conflicts_with(gen, issued));\n-                if self.conflicts_with(gen, issued) {\n-                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n-                }\n-            }\n-        }\n-\n-        // MIR statically ensures each statement gens *at most one*\n-        // loan; mutual conflict (within a statement) can't arise.\n-        //\n-        // As safe-guard, assert that above property actually holds.\n-        assert!(loans_generated <= 1);\n-    } }\n+}\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     lvalue: &Lvalue<'gcx>,\n+                                     access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n                                      flow_state: &InProgress<'b, 'gcx>,\n                                      mut op: F)\n         where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n     {\n+        let (access, lvalue) = access_lvalue;\n+\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path.\n \n@@ -664,228 +716,182 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        for i in flow_state.borrows.elems_incoming() {\n-            // FIXME: check_loans.rs filtered this to \"in scope\"\n-            // loans; i.e. it took a scope S and checked that each\n-            // restriction's kill_scope was a superscope of S.\n+        'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n-            for restricted in self.restrictions(&borrowed.lvalue) {\n-                if restricted == lvalue {\n+\n+            // Is `lvalue` (or a prefix of it) already borrowed? If\n+            // so, that's relevant.\n+            //\n+            // FIXME: Differs from AST-borrowck; includes drive-by fix\n+            // to #38899. Will probably need back-compat mode flag.\n+            for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n+                if *accessed_prefix == borrowed.lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n-        }\n \n-        // check for loans (not restrictions) on any base path.\n-        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n-        // since that moves out of borrowed path `a.b`.\n-        //\n-        // Limiting to loans (not restrictions) keeps this one\n-        // working: `{ let x = &mut a.b; let y = a.c; }`\n-        let mut cursor = lvalue;\n-        loop {\n-            // FIXME: check_loans.rs invoked `op` *before* cursor\n-            // shift here.  Might just work (and even avoid redundant\n-            // errors?) given code above?  But for now, I want to try\n-            // doing what I think is more \"natural\" check.\n-            for i in flow_state.borrows.elems_incoming() {\n-                let borrowed = &data[i];\n-                if borrowed.lvalue == *cursor {\n+            // Is `lvalue` a prefix (modulo access type) of the\n+            // `borrowed.lvalue`? If so, that's relevant.\n+\n+            let prefix_kind = match access {\n+                Shallow(Some(ArtificialField::Discriminant)) |\n+                Shallow(Some(ArtificialField::ArrayLength)) => {\n+                    // The discriminant and array length are like\n+                    // additional fields on the type; they do not\n+                    // overlap any existing data there. Furthermore,\n+                    // they cannot actually be a prefix of any\n+                    // borrowed lvalue (at least in MIR as it is\n+                    // currently.)\n+                    continue 'next_borrow;\n+                }\n+                Shallow(None) => PrefixSet::Shallow,\n+                Deep => PrefixSet::Supporting,\n+            };\n+\n+            for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n+                if borrowed_prefix == lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n-\n-            match *cursor {\n-                Lvalue::Local(_) | Lvalue::Static(_) => break,\n-                Lvalue::Projection(ref proj) => cursor = &proj.base,\n-            }\n         }\n     }\n }\n \n-mod restrictions {\n-    use super::MirBorrowckCtxt;\n+use self::prefixes::PrefixSet;\n+\n+/// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n+/// lvalue are formed by stripping away fields and derefs, except that\n+/// we stop when we reach the deref of a shared reference. [...] \"\n+///\n+/// \"Shallow prefixes are found by stripping away fields, but stop at\n+/// any dereference. So: writing a path like `a` is illegal if `a.b`\n+/// is borrowed. But: writing `a` is legal if `*a` is borrowed,\n+/// whether or not `a` is a shared or mutable reference. [...] \"\n+mod prefixes {\n+    use super::{MirBorrowckCtxt};\n \n     use rustc::hir;\n     use rustc::ty::{self, TyCtxt};\n     use rustc::mir::{Lvalue, Mir, ProjectionElem};\n \n-    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+    pub(super) struct Prefixes<'c, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n         tcx: TyCtxt<'c, 'tcx, 'tcx>,\n-        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+        kind: PrefixSet,\n+        next: Option<&'c Lvalue<'tcx>>,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    pub(super) enum PrefixSet {\n+        All,\n+        Shallow,\n+        Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-        pub(super) fn restrictions<'d>(&self,\n-                                       lvalue: &'d Lvalue<'gcx>)\n-                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        pub(super) fn prefixes<'d>(&self,\n+                                   lvalue: &'d Lvalue<'gcx>,\n+                                   kind: PrefixSet)\n+                                   -> Prefixes<'d, 'gcx> where 'b: 'd\n         {\n-            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n-            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+            Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n         }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Prefixes<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            let mut cursor = match self.next {\n+                None => return None,\n+                Some(lvalue) => lvalue,\n+            };\n \n-        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n-            let mut cursor = lvalue;\n-            loop {\n+            // Post-processing `lvalue`: Enqueue any remaining\n+            // work. Also, `lvalue` may not be a prefix itself, but\n+            // may hold one further down (e.g. we never return\n+            // downcasts here, but may return a base of a downcast).\n+\n+            'cursor: loop {\n                 let proj = match *cursor {\n-                    Lvalue::Local(_) => return true,\n-                    Lvalue::Static(_) => return false,\n+                    Lvalue::Local(_) | // search yielded this leaf\n+                    Lvalue::Static(_) => {\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n+\n                     Lvalue::Projection(ref proj) => proj,\n                 };\n+\n                 match proj.elem {\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        // FIXME: add union handling\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n                     ProjectionElem::Downcast(..) |\n                     ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Index(_) => {\n                         cursor = &proj.base;\n-                        continue;\n+                        continue 'cursor;\n                     }\n                     ProjectionElem::Deref => {\n-                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        match ty.sty {\n-                            ty::TyRawPtr(_) => {\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                                // FIXME: do I need to check validity of\n-                                // region here though? (I think the original\n-                                // check_loans code did, like readme says)\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            ty::TyAdt(..) if ty.is_box() => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            _ => {\n-                                panic!(\"unknown type fed to Projection Deref.\");\n-                            }\n-                        }\n+                        // (handled below)\n                     }\n                 }\n-            }\n-        }\n-    }\n \n-    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n-        type Item = &'c Lvalue<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            'pop: loop {\n-                let lvalue = match self.lvalue_stack.pop() {\n-                    None => return None,\n-                    Some(lvalue) => lvalue,\n-                };\n+                assert_eq!(proj.elem, ProjectionElem::Deref);\n \n-                // `lvalue` may not be a restriction itself, but may\n-                // hold one further down (e.g. we never return\n-                // downcasts here, but may return a base of a\n-                // downcast).\n-                //\n-                // Also, we need to enqueue any additional\n-                // subrestrictions that it implies, since we can only\n-                // return from from this call alone.\n-\n-                let mut cursor = lvalue;\n-                'cursor: loop {\n-                    let proj = match *cursor {\n-                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n-                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n-                        Lvalue::Projection(ref proj) => proj,\n-                    };\n-\n-                    match proj.elem {\n-                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                            // FIXME: add union handling\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor);\n-                        }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(_) => {\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Deref => {\n-                            // (handled below)\n-                        }\n+                match self.kind {\n+                    PrefixSet::Shallow => {\n+                        // shallow prefixes are found by stripping away\n+                        // fields, but stop at *any* dereference.\n+                        // So we can just stop the traversal now.\n+                        self.next = None;\n+                        return Some(cursor);\n                     }\n+                    PrefixSet::All => {\n+                        // all prefixes: just blindly enqueue the base\n+                        // of the projection\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+                    PrefixSet::Supporting => {\n+                        // fall through!\n+                    }\n+                }\n \n-                    assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(_) => {\n-                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n-                            continue 'pop;\n-                        }\n-                        // R-Deref-Imm-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                            // immutably-borrowed referents do not\n-                            // have recursively-implied restrictions\n-                            // (because preventing actions on `*LV`\n-                            // does nothing about aliases like `*LV1`)\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // (And do I *really* not have to\n-                            // recursively process the `base` as a\n-                            // further search here? Leaving this `if\n-                            // false` here as a hint to look at this\n-                            // again later.\n-                            //\n-                            // Ah, it might be because the\n-                            // restrictions are distinct from the path\n-                            // substructure. Note that there is a\n-                            // separate loop over the path\n-                            // substructure in fn\n-                            // each_borrow_involving_path, for better\n-                            // or for worse.\n-\n-                            if false {\n-                                cursor = &proj.base;\n-                                continue 'cursor;\n-                            } else {\n-                                continue 'pop;\n-                            }\n-                        }\n-\n-                        // R-Deref-Mut-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                            // mutably-borrowed referents are\n-                            // themselves restricted.\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // schedule base for future iteration.\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n+                assert_eq!(self.kind, PrefixSet::Supporting);\n+                // supporting prefixes: strip away fields and\n+                // derefs, except we stop at the deref of a shared\n+                // reference.\n+\n+                let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match ty.sty {\n+                    ty::TyRawPtr(_) |\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                        // don't continue traversing over derefs of raw pointers or shared borrows.\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n \n-                        // R-Deref-Send-Pointer\n-                        ty::TyAdt(..) if ty.is_box() => {\n-                            // borrowing interior of a box implies that\n-                            // its base can no longer be mutated (o/w box\n-                            // storage would be freed)\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n \n-                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    ty::TyAdt(..) if ty.is_box() => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n                     }\n+\n+                    _ => panic!(\"unknown type fed to Projection Deref.\"),\n                 }\n             }\n         }\n@@ -895,71 +901,119 @@ mod restrictions {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn report_use_of_moved(&mut self,\n                            _context: Context,\n+                           desired_action: &str,\n                            (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n-            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span_label for use of uninitialized variable\n-        err.emit();\n+        self.tcx.cannot_act_on_uninitialized_variable(span,\n+                                                      desired_action,\n+                                                      &self.describe_lvalue(lvalue),\n+                                                      Origin::Mir)\n+                .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n+                                          self.describe_lvalue(lvalue)))\n+                .emit();\n     }\n \n     fn report_move_out_while_borrowed(&mut self,\n                                       _context: Context,\n-                                      (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_move_when_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n-        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n-        err.emit();\n+                                      (lvalue, span): (&Lvalue, Span),\n+                                      borrow: &BorrowData) {\n+        self.tcx.cannot_move_when_borrowed(span,\n+                                           &self.describe_lvalue(lvalue),\n+                                           Origin::Mir)\n+                .span_label(self.retrieve_borrow_span(borrow),\n+                            format!(\"borrow of `{}` occurs here\",\n+                                    self.describe_lvalue(&borrow.lvalue)))\n+                .span_label(span, format!(\"move out of `{}` occurs here\",\n+                                          self.describe_lvalue(lvalue)))\n+                .emit();\n     }\n \n     fn report_use_while_mutably_borrowed(&mut self,\n                                          _context: Context,\n-                                         (lvalue, span): (&Lvalue, Span)) {\n+                                         (lvalue, span): (&Lvalue, Span),\n+                                         borrow : &BorrowData) {\n+        let described_lvalue = self.describe_lvalue(lvalue);\n+        let borrow_span = self.retrieve_borrow_span(borrow);\n+\n         let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n-        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+            span, &described_lvalue, Origin::Mir);\n+\n+        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", described_lvalue));\n+        err.span_label(span, format!(\"use of borrowed `{}`\", described_lvalue));\n+\n         err.emit();\n     }\n \n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n                                  (lvalue, span): (&Lvalue, Span),\n-                                 loan1: &BorrowData,\n-                                 loan2: &BorrowData) {\n+                                 loan1: (&Lvalue, BorrowKind),\n+                                 loan2: (&Lvalue, BorrowKind)) {\n+        let (loan1_lvalue, loan1_kind) = loan1;\n+        let (loan2_lvalue, loan2_kind) = loan2;\n         // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1.lvalue, loan2.lvalue);\n+        assert_eq!(loan1_lvalue, loan2_lvalue);\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n-                             loan2.kind, \"immutable\", \"mutable\") {\n+        let mut err = match (loan1_kind, \"immutable\", \"mutable\",\n+                             loan2_kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n                     span, &self.describe_lvalue(lvalue),\n                     \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n \n-            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n-                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n+                self.tcx.cannot_mutably_borrow_multiply(\n+                    span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n+                self.tcx.cannot_uniquely_borrow_by_two_closures(\n+                    span, &self.describe_lvalue(lvalue), Origin::Mir),\n+\n+            (BorrowKind::Unique, _, _, _, _, _) =>\n+                self.tcx.cannot_uniquely_borrow_by_one_closure(\n+                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+\n+            (_, _, _, BorrowKind::Unique, _, _) =>\n+                self.tcx.cannot_reborrow_already_uniquely_borrowed(\n+                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n+                unreachable!(),\n+\n             // FIXME: add span labels for first and second mutable borrows, as well as\n             // end point for first.\n         };\n         err.emit();\n     }\n \n-    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n+    fn report_illegal_mutation_of_borrowed(&mut self,\n+                                           _: Context,\n+                                           (lvalue, span): (&Lvalue, Span),\n+                                           loan: &BorrowData) {\n+        let describe_lvalue = self.describe_lvalue(lvalue);\n+        let borrow_span = self.retrieve_borrow_span(loan);\n+\n         let mut err = self.tcx.cannot_assign_to_borrowed(\n             span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span labels for borrow and assignment points\n+\n+        err.span_label(borrow_span, format!(\"borrow of `{}` occurs here\", describe_lvalue));\n+        err.span_label(span, format!(\"assignment to borrowed `{}` occurs here\", describe_lvalue));\n+\n         err.emit();\n     }\n \n-    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n-        let mut err = self.tcx.cannot_reassign_immutable(\n-            span, &self.describe_lvalue(lvalue), Origin::Mir);\n-        // FIXME: add span labels for borrow and assignment points\n-        err.emit();\n+    fn report_illegal_reassignment(&mut self,\n+                                   _context: Context,\n+                                   (lvalue, span): (&Lvalue, Span),\n+                                   assigned_span: Span) {\n+        self.tcx.cannot_reassign_immutable(span,\n+                                           &self.describe_lvalue(lvalue),\n+                                           Origin::Mir)\n+                .span_label(span, \"re-assignment of immutable variable\")\n+                .span_label(assigned_span, format!(\"first assignment to `{}`\",\n+                                                   self.describe_lvalue(lvalue)))\n+                .emit();\n     }\n \n     fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n@@ -998,7 +1052,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                     ProjectionElem::Downcast(..) =>\n                         (\"\",   format!(\"\"), None), // (dont emit downcast info)\n                     ProjectionElem::Field(field, _ty) =>\n-                        (\"\",   format!(\".{}\", field.index()), None),\n+                        (\"\",   format!(\".{}\", field.index()), None), // FIXME: report name of field\n                     ProjectionElem::Index(index) =>\n                         (\"\",   format!(\"\"), Some(index)),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n@@ -1024,28 +1078,16 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n-}\n \n-impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    // FIXME: needs to be able to express errors analogous to check_loans.rs\n-    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n-        if loan1.compatible_with(loan2.kind) { return false; }\n-\n-        let loan2_base_path = self.base_path(&loan2.lvalue);\n-        for restricted in self.restrictions(&loan1.lvalue) {\n-            if restricted != loan2_base_path { continue; }\n-            return true;\n-        }\n-\n-        let loan1_base_path = self.base_path(&loan1.lvalue);\n-        for restricted in self.restrictions(&loan2.lvalue) {\n-            if restricted != loan1_base_path { continue; }\n-            return true;\n-        }\n-\n-        return false;\n+    // Retrieve span of given borrow from the current MIR representation\n+    fn retrieve_borrow_span(&self, borrow: &BorrowData) -> Span {\n+        self.mir.basic_blocks()[borrow.location.block]\n+            .statements[borrow.location.statement_index]\n+            .source_info.span\n     }\n+}\n \n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     // FIXME (#16118): function intended to allow the borrow checker\n     // to be less precise in its handling of Box while still allowing\n     // moves out of a Box. They should be removed when/if we stop\n@@ -1092,8 +1134,8 @@ enum ContextKind {\n     CallOperand,\n     CallDest,\n     Assert,\n-    StorageDead,\n     Yield,\n+    StorageDead,\n }\n \n impl ContextKind {\n@@ -1225,26 +1267,8 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n         self.curr_state.subtract(&self.stmt_kill);\n     }\n \n-    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.stmt_gen.elems(univ)\n-    }\n-\n     fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n         let univ = self.base_results.sets().bits_per_block();\n         self.curr_state.elems(univ)\n     }\n }\n-\n-impl<'tcx> BorrowData<'tcx> {\n-    fn compatible_with(&self, bk: BorrowKind) -> bool {\n-        match (self.kind, bk) {\n-            (BorrowKind::Shared, BorrowKind::Shared) => true,\n-\n-            (BorrowKind::Mut, _) |\n-            (BorrowKind::Unique, _) |\n-            (_, BorrowKind::Mut) |\n-            (_, BorrowKind::Unique) => false,\n-        }\n-    }\n-}"}, {"sha": "1fc96dbf451972eae1b440dcdea88dfe9a0df029", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -21,22 +21,32 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { region_scope, opt_destruction_scope, span, stmts, expr, targeted_by_break } =\n+        let Block {\n+            region_scope,\n+            opt_destruction_scope,\n+            span,\n+            stmts,\n+            expr,\n+            targeted_by_break,\n+            safety_mode\n+        } =\n             self.hir.mirror(ast_block);\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n-            this.in_scope((region_scope, source_info), block, move |this| {\n+            this.in_scope((region_scope, source_info), LintLevel::Inherited, block, move |this| {\n                 if targeted_by_break {\n                     // This is a `break`-able block (currently only `catch { ... }`)\n                     let exit_block = this.cfg.start_new_block();\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {\n-                            this.ast_block_stmts(destination, block, span, stmts, expr)\n+                            this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                                 safety_mode)\n                         });\n                     this.cfg.terminate(unpack!(block_exit), source_info,\n                                        TerminatorKind::Goto { target: exit_block });\n                     exit_block.unit()\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr)\n+                    this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                         safety_mode)\n                 }\n             })\n         })\n@@ -47,7 +57,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        mut block: BasicBlock,\n                        span: Span,\n                        stmts: Vec<StmtRef<'tcx>>,\n-                       expr: Option<ExprRef<'tcx>>)\n+                       expr: Option<ExprRef<'tcx>>,\n+                       safety_mode: BlockSafety)\n                        -> BlockAnd<()> {\n         let this = self;\n \n@@ -69,34 +80,46 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // First we build all the statements in the block.\n         let mut let_scope_stack = Vec::with_capacity(8);\n         let outer_visibility_scope = this.visibility_scope;\n+        let outer_push_unsafe_count = this.push_unsafe_count;\n+        let outer_unpushed_unsafe = this.unpushed_unsafe;\n+        this.update_visibility_scope_for_safety_mode(span, safety_mode);\n+\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n             let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n                         opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n-                            this.in_scope((scope, source_info), block, |this| {\n+                            let si = (scope, source_info);\n+                            this.in_scope(si, LintLevel::Inherited, block, |this| {\n                                 let expr = this.hir.mirror(expr);\n                                 this.stmt_expr(block, expr)\n                             })\n                         }));\n                 }\n-                StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                StmtKind::Let {\n+                    remainder_scope,\n+                    init_scope,\n+                    pattern,\n+                    initializer,\n+                    lint_level\n+                } => {\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_scope_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n                     let remainder_span = remainder_scope.span(this.hir.tcx(),\n                                                               &this.hir.region_scope_tree);\n-                    let scope = this.declare_bindings(None, remainder_span, &pattern);\n+                    let scope = this.declare_bindings(None, remainder_span, lint_level, &pattern);\n \n                     // Evaluate the initializer, if present.\n                     if let Some(init) = initializer {\n                         unpack!(block = this.in_opt_scope(\n                             opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n-                                this.in_scope((init_scope, source_info), block, move |this| {\n+                                let scope = (init_scope, source_info);\n+                                this.in_scope(scope, lint_level, block, move |this| {\n                                     // FIXME #30046                             ^~~~\n                                     this.expr_into_pattern(block, pattern, init)\n                                 })\n@@ -129,6 +152,48 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         // Restore the original visibility scope.\n         this.visibility_scope = outer_visibility_scope;\n+        this.push_unsafe_count = outer_push_unsafe_count;\n+        this.unpushed_unsafe = outer_unpushed_unsafe;\n         block.unit()\n     }\n+\n+    /// If we are changing the safety mode, create a new visibility scope\n+    fn update_visibility_scope_for_safety_mode(&mut self,\n+                                               span: Span,\n+                                               safety_mode: BlockSafety)\n+    {\n+        debug!(\"update_visibility_scope_for({:?}, {:?})\", span, safety_mode);\n+        let new_unsafety = match safety_mode {\n+            BlockSafety::Safe => None,\n+            BlockSafety::ExplicitUnsafe(node_id) => {\n+                assert_eq!(self.push_unsafe_count, 0);\n+                match self.unpushed_unsafe {\n+                    Safety::Safe => {}\n+                    _ => return\n+                }\n+                self.unpushed_unsafe = Safety::ExplicitUnsafe(node_id);\n+                Some(Safety::ExplicitUnsafe(node_id))\n+            }\n+            BlockSafety::PushUnsafe => {\n+                self.push_unsafe_count += 1;\n+                Some(Safety::BuiltinUnsafe)\n+            }\n+            BlockSafety::PopUnsafe => {\n+                self.push_unsafe_count =\n+                    self.push_unsafe_count.checked_sub(1).unwrap_or_else(|| {\n+                        span_bug!(span, \"unsafe count underflow\")\n+                    });\n+                if self.push_unsafe_count == 0 {\n+                    Some(self.unpushed_unsafe)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+\n+        if let Some(unsafety) = new_unsafety {\n+            self.visibility_scope = self.new_visibility_scope(\n+                span, LintLevel::Inherited, Some(unsafety));\n+        }\n+    }\n }"}, {"sha": "a57f1b95494855ca36d814b7ae7b2b3e1caec134", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let Expr { ty, temp_lifetime: _, span, kind }\n             = expr;\n         match kind {\n-            ExprKind::Scope { region_scope: _, value } =>\n+            ExprKind::Scope { region_scope: _, lint_level: _, value } =>\n                 this.as_constant(value),\n             ExprKind::Literal { literal } =>\n                 Constant { span: span, ty: ty, literal: literal },"}, {"sha": "69d0dd992281ed86e3aec2ba18db9ef71c1a5de1", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n-                this.in_scope((region_scope, source_info), block, |this| {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n+                this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                     this.as_lvalue(block, value)\n                 })\n             }"}, {"sha": "ea6e4342098bc6061ab78cd52c219b5af14ef3f7", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -55,10 +55,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { region_scope, value } = expr.kind {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n             let source_info = this.source_info(expr.span);\n             let region_scope = (region_scope, source_info);\n-            return this.in_scope(region_scope, block, |this| {\n+            return this.in_scope(region_scope, lint_level, block, |this| {\n                 this.as_operand(block, scope, value)\n             });\n         }"}, {"sha": "d17f00b489c318bb4a6bd3c99510983e374d0217", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -58,9 +58,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, block, |this| this.as_rvalue(block, scope, value))\n+                this.in_scope(region_scope, lint_level, block,\n+                              |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));"}, {"sha": "ba422a8183160fd3d5eacd3e8526c5354232d24b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -41,8 +41,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n-        if let ExprKind::Scope { region_scope, value } = expr.kind {\n-            return this.in_scope((region_scope, source_info), block, |this| {\n+        if let ExprKind::Scope { region_scope, lint_level, value } = expr.kind {\n+            return this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                 this.as_temp(block, temp_lifetime, value)\n             });\n         }"}, {"sha": "cdbcb43370fe0e6eb91f0d5829e53bfaa201bbc7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -38,9 +38,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr_span);\n \n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let region_scope = (region_scope, source_info);\n-                this.in_scope(region_scope, block, |this| this.into(destination, block, value))\n+                this.in_scope(region_scope, lint_level, block,\n+                              |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n@@ -227,9 +228,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let val = args.next().expect(\"1 argument to `move_val_init`\");\n                     assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n \n-                    let topmost_scope = this.topmost_scope();\n-                    let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n-                    this.into(&Lvalue::Local(ptr).deref(), block, val)\n+                    let ptr = this.hir.mirror(ptr);\n+                    let ptr_ty = ptr.ty;\n+                    // Create an *internal* temp for the pointer, so that unsafety\n+                    // checking won't complain about the raw pointer assignment.\n+                    let ptr_temp = this.local_decls.push(LocalDecl {\n+                        mutability: Mutability::Mut,\n+                        ty: ptr_ty,\n+                        name: None,\n+                        source_info,\n+                        lexical_scope: source_info.scope,\n+                        internal: true,\n+                        is_user_variable: false\n+                    });\n+                    let ptr_temp = Lvalue::Local(ptr_temp);\n+                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n+                    this.into(&ptr_temp.deref(), block, val)\n                 } else {\n                     let args: Vec<_> =\n                         args.into_iter()"}, {"sha": "3cfb0ff4010da753d3ad7fc32828eb258437ef2a", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -22,9 +22,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n         match expr.kind {\n-            ExprKind::Scope { region_scope, value } => {\n+            ExprKind::Scope { region_scope, lint_level, value } => {\n                 let value = this.hir.mirror(value);\n-                this.in_scope((region_scope, source_info), block, |this| {\n+                this.in_scope((region_scope, source_info), lint_level, block, |this| {\n                     this.stmt_expr(block, value)\n                 })\n             }"}, {"sha": "f04dede6e4005d55271442a332a63be99522dba7", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -46,8 +46,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n         let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n+            // BUG: use arm lint level\n             let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(None, body.span, &arm.patterns[0]);\n+            let scope = self.declare_bindings(None, body.span,\n+                                              LintLevel::Inherited,\n+                                              &arm.patterns[0]);\n             (body, scope.unwrap_or(self.visibility_scope))\n         }).collect();\n \n@@ -171,18 +174,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn declare_bindings(&mut self,\n                             mut var_scope: Option<VisibilityScope>,\n                             scope_span: Span,\n+                            lint_level: LintLevel,\n                             pattern: &Pattern<'tcx>)\n                             -> Option<VisibilityScope> {\n+        assert!(!(var_scope.is_some() && lint_level.is_explicit()),\n+               \"can't have both a var and a lint scope at the same time\");\n         self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n             if var_scope.is_none() {\n-                var_scope = Some(this.new_visibility_scope(scope_span));\n+                var_scope = Some(this.new_visibility_scope(scope_span,\n+                                                           LintLevel::Inherited,\n+                                                           None));\n+                // If we have lints, create a new visibility scope\n+                // that marks the lints for the locals.\n+                if lint_level.is_explicit() {\n+                    this.visibility_scope =\n+                        this.new_visibility_scope(scope_span, lint_level, None);\n+                }\n             }\n             let source_info = SourceInfo {\n                 span,\n                 scope: var_scope.unwrap()\n             };\n             this.declare_binding(source_info, mutability, name, var, ty);\n         });\n+        // Pop any scope we created for the locals.\n+        if let Some(var_scope) = var_scope {\n+            self.visibility_scope = var_scope;\n+        }\n         var_scope\n     }\n \n@@ -712,6 +730,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n+            lexical_scope: self.visibility_scope,\n             internal: false,\n             is_user_variable: true,\n         });"}, {"sha": "68ef646184c2c3a577624bece4aca793c8ef13d3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 43, "deletions": 12, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,6 +11,7 @@\n \n use build;\n use hair::cx::Cx;\n+use hair::LintLevel;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -71,14 +72,14 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // is a constant \"initializer\" expression.\n             match expr.node {\n                 hir::ExprClosure(_, _, body, _, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n+                _ => hir::BodyId { node_id: expr.id },\n             }\n         }\n         hir::map::NodeVariant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         hir::map::NodeStructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n+        _ => unsupported(),\n     };\n \n     let src = MirSource::from_node(tcx, id);\n@@ -108,6 +109,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 _ => None,\n             };\n \n+            // FIXME: safety in closures\n+            let safety = match fn_sig.unsafety {\n+                hir::Unsafety::Normal => Safety::Safe,\n+                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+            };\n+\n             let body = tcx.hir.body(body_id);\n             let explicit_arguments =\n                 body.arguments\n@@ -126,7 +133,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 (None, fn_sig.output())\n             };\n \n-            build::construct_fn(cx, id, arguments, abi, return_ty, yield_ty, body)\n+            build::construct_fn(cx, id, arguments, safety, abi,\n+                                return_ty, yield_ty, body)\n         } else {\n             build::construct_const(cx, body_id)\n         };\n@@ -270,13 +278,21 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n+    /// The current unsafe block in scope, even if it is hidden by\n+    /// a PushUnsafeBlock\n+    unpushed_unsafe: Safety,\n+\n+    /// The number of `push_unsafe_block` levels in scope\n+    push_unsafe_count: usize,\n+\n     /// the current set of breakables; see the `scope` module for more\n     /// details\n     breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n \n     /// the vector of all scopes that we have created thus far;\n     /// we track this for debuginfo later\n     visibility_scopes: IndexVec<VisibilityScope, VisibilityScopeData>,\n+    visibility_scope_info: IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     visibility_scope: VisibilityScope,\n \n     /// Maps node ids of variable bindings to the `Local`s created for them.\n@@ -358,6 +374,7 @@ macro_rules! unpack {\n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n                                    arguments: A,\n+                                   safety: Safety,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n@@ -372,14 +389,17 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir.clone(),\n         span,\n         arguments.len(),\n+        safety,\n         return_ty);\n \n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n     let arg_scope = region::Scope::Arguments(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n-    unpack!(block = builder.in_scope((call_site_scope, source_info), block, |builder| {\n-        unpack!(block = builder.in_scope((arg_scope, source_info), block, |builder| {\n+    let call_site_s = (call_site_scope, source_info);\n+    unpack!(block = builder.in_scope(call_site_s, LintLevel::Inherited, block, |builder| {\n+        let arg_scope_s = (arg_scope, source_info);\n+        unpack!(block = builder.in_scope(arg_scope_s, LintLevel::Inherited, block, |builder| {\n             builder.args_and_body(block, &arguments, arg_scope, &body.value)\n         }));\n         // Attribute epilogue to function's closing brace\n@@ -440,7 +460,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -456,11 +476,12 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                       body_id: hir::BodyId)\n-                                       -> Mir<'tcx> {\n-    let span = hir.tcx().hir.span(hir.tcx().hir.body_owner(body_id));\n+                                   body_id: hir::BodyId)\n+                                   -> Mir<'tcx> {\n+    let owner_id = hir.tcx().hir.body_owner(body_id);\n+    let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(vec![], ty, None)\n@@ -470,8 +491,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n+           safety: Safety,\n            return_ty: Ty<'tcx>)\n            -> Builder<'a, 'gcx, 'tcx> {\n+        let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n@@ -480,6 +503,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             scopes: vec![],\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n+            visibility_scope_info: IndexVec::new(),\n+            push_unsafe_count: 0,\n+            unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty,\n                                                                              span), 1),\n@@ -490,7 +516,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n-        assert_eq!(builder.new_visibility_scope(span), ARGUMENT_VISIBILITY_SCOPE);\n+        assert_eq!(\n+            builder.new_visibility_scope(span, lint_level, Some(safety)),\n+            ARGUMENT_VISIBILITY_SCOPE);\n         builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n \n         builder\n@@ -509,6 +537,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         Mir::new(self.cfg.basic_blocks,\n                  self.visibility_scopes,\n+                 ClearOnDecode::Set(self.visibility_scope_info),\n                  IndexVec::new(),\n                  return_ty,\n                  yield_ty,\n@@ -543,6 +572,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     scope: ARGUMENT_VISIBILITY_SCOPE,\n                     span: pattern.map_or(self.fn_span, |pat| pat.span)\n                 },\n+                lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n                 name,\n                 internal: false,\n                 is_user_variable: false,\n@@ -557,7 +587,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n-                scope = self.declare_bindings(scope, ast_body.span, &pattern);\n+                scope = self.declare_bindings(scope, ast_body.span,\n+                                              LintLevel::Inherited, &pattern);\n                 unpack!(block = self.lvalue_into_pattern(block, pattern, &lvalue));\n             }\n "}, {"sha": "032734194329cf87d1cd70838ed3a9504932da8a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -88,8 +88,10 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n+use hair::LintLevel;\n use rustc::middle::region;\n use rustc::ty::{Ty, TyCtxt};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use syntax_pos::{Span};\n@@ -304,15 +306,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,\n                           region_scope: (region::Scope, SourceInfo),\n+                          lint_level: LintLevel,\n                           mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n+        let visibility_scope = self.visibility_scope;\n+        let tcx = self.hir.tcx();\n+        if let LintLevel::Explicit(node_id) = lint_level {\n+            let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n+                let sets = tcx.lint_levels(LOCAL_CRATE);\n+                let parent_hir_id =\n+                    tcx.hir.definitions().node_to_hir_id(\n+                        self.visibility_scope_info[visibility_scope].lint_root\n+                            );\n+                let current_hir_id =\n+                    tcx.hir.definitions().node_to_hir_id(node_id);\n+                sets.lint_level_set(parent_hir_id) ==\n+                    sets.lint_level_set(current_hir_id)\n+            });\n+\n+            if !same_lint_scopes {\n+                self.visibility_scope =\n+                    self.new_visibility_scope(region_scope.1.span, lint_level,\n+                                              None);\n+            }\n+        }\n         self.push_scope(region_scope);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n+        self.visibility_scope = visibility_scope;\n         debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n         block.and(rv)\n     }\n@@ -474,13 +499,29 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Creates a new visibility scope, nested in the current one.\n-    pub fn new_visibility_scope(&mut self, span: Span) -> VisibilityScope {\n+    pub fn new_visibility_scope(&mut self,\n+                                span: Span,\n+                                lint_level: LintLevel,\n+                                safety: Option<Safety>) -> VisibilityScope {\n         let parent = self.visibility_scope;\n-        let scope = VisibilityScope::new(self.visibility_scopes.len());\n-        self.visibility_scopes.push(VisibilityScopeData {\n+        debug!(\"new_visibility_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n+               span, lint_level, safety,\n+               parent, self.visibility_scope_info.get(parent));\n+        let scope = self.visibility_scopes.push(VisibilityScopeData {\n             span,\n             parent_scope: Some(parent),\n         });\n+        let scope_info = VisibilityScopeInfo {\n+            lint_root: if let LintLevel::Explicit(lint_root) = lint_level {\n+                lint_root\n+            } else {\n+                self.visibility_scope_info[parent].lint_root\n+            },\n+            safety: safety.unwrap_or_else(|| {\n+                self.visibility_scope_info[parent].safety\n+            })\n+        };\n+        self.visibility_scope_info.push(scope_info);\n         scope\n     }\n \n@@ -514,8 +555,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match self.scopes[1].region_scope {\n-            region::Scope::Arguments(_) => true,\n+        assert!(match self.scopes[1].region_scope.data() {\n+            region::ScopeData::Arguments(_) => true,\n             _ => false,\n         });\n         self.scopes[1].region_scope"}, {"sha": "2c4afb0aa0e045f26e7c2883e032bee685ccf376", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -195,6 +195,40 @@ instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n "}, {"sha": "6f6258f52f794acb522010020e544d16e8930a4a", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -14,6 +14,8 @@ use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{self, BlockRemainder};\n use rustc::hir;\n \n+use rustc_data_structures::indexed_vec::Idx;\n+\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n@@ -30,6 +32,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             span: self.span,\n             stmts,\n             expr: self.expr.to_ref(),\n+            safety_mode: match self.rules {\n+                hir::BlockCheckMode::DefaultBlock =>\n+                    BlockSafety::Safe,\n+                hir::BlockCheckMode::UnsafeBlock(..) =>\n+                    BlockSafety::ExplicitUnsafe(self.id),\n+                hir::BlockCheckMode::PushUnsafeBlock(..) =>\n+                    BlockSafety::PushUnsafe,\n+                hir::BlockCheckMode::PopUnsafeBlock(..) =>\n+                    BlockSafety::PopUnsafe\n+            },\n         }\n     }\n }\n@@ -61,7 +73,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     hir::DeclLocal(ref local) => {\n                         let remainder_scope = region::Scope::Remainder(BlockRemainder {\n                             block: block_id,\n-                            first_statement_index: index as u32,\n+                            first_statement_index: region::FirstStatementIndex::new(index),\n                         });\n \n                         let pattern = cx.pattern_from_hir(&local.pat);\n@@ -71,6 +83,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 init_scope: region::Scope::Node(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n+                                lint_level: cx.lint_level_of(local.id),\n                             },\n                             opt_destruction_scope: opt_dxn_ext,\n                         })));"}, {"sha": "f5a53e2aa8eed92a11cff1df9e2298533160f4fa", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -48,22 +48,24 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n                 value: expr.to_ref(),\n+                lint_level: cx.lint_level_of(self.id),\n             },\n         };\n \n         // Finally, create a destruction scope, if any.\n         if let Some(region_scope) =\n-                cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id) {\n-            expr = Expr {\n-                temp_lifetime,\n-                ty: expr.ty,\n-                span: self.span,\n-                kind: ExprKind::Scope {\n-                    region_scope,\n-                    value: expr.to_ref(),\n-                },\n-            };\n-        }\n+            cx.region_scope_tree.opt_destruction_scope(self.hir_id.local_id) {\n+                expr = Expr {\n+                    temp_lifetime,\n+                    ty: expr.ty,\n+                    span: self.span,\n+                    kind: ExprKind::Scope {\n+                        region_scope,\n+                        value: expr.to_ref(),\n+                        lint_level: LintLevel::Inherited,\n+                    },\n+                };\n+            }\n \n         // OK, all done!\n         expr\n@@ -619,6 +621,8 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n         patterns: arm.pats.iter().map(|p| cx.pattern_from_hir(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n+        // BUG: fix this\n+        lint_level: LintLevel::Inherited,\n     }\n }\n "}, {"sha": "4434df0ac3e9bfaa36483d555eea4f78a599439f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -20,13 +20,14 @@ use rustc::mir::transform::MirSource;\n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n+use syntax::ast;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n@@ -37,6 +38,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n+    pub root_lint_level: ast::NodeId,\n     pub param_env: ty::ParamEnv<'gcx>,\n \n     /// Identity `Substs` for use with const-evaluation.\n@@ -57,7 +59,8 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               src: MirSource) -> Cx<'a, 'gcx, 'tcx> {\n         let constness = match src {\n             MirSource::Const(_) |\n             MirSource::Static(..) => hir::Constness::Const,\n@@ -87,9 +90,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n+        let lint_level = lint_level_for_hir_id(tcx, src_id);\n         Cx {\n             tcx,\n             infcx,\n+            root_lint_level: lint_level,\n             param_env: tcx.param_env(src_def_id),\n             identity_substs: Substs::identity_for_item(tcx.global_tcx(), src_def_id),\n             region_scope_tree: tcx.region_scope_tree(src_def_id),\n@@ -99,6 +104,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             check_overflow,\n         }\n     }\n+\n }\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n@@ -229,6 +235,19 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n+    fn lint_level_of(&self, node_id: ast::NodeId) -> LintLevel {\n+        let hir_id = self.tcx.hir.definitions().node_to_hir_id(node_id);\n+        let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n+            self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n+        });\n+\n+        if has_lint_level {\n+            LintLevel::Explicit(node_id)\n+        } else {\n+            LintLevel::Inherited\n+        }\n+    }\n+\n     pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n@@ -242,6 +261,31 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n }\n \n+fn lint_level_for_hir_id(tcx: TyCtxt, mut id: ast::NodeId) -> ast::NodeId {\n+    // Right now we insert a `with_ignore` node in the dep graph here to\n+    // ignore the fact that `lint_levels` below depends on the entire crate.\n+    // For now this'll prevent false positives of recompiling too much when\n+    // anything changes.\n+    //\n+    // Once red/green incremental compilation lands we should be able to\n+    // remove this because while the crate changes often the lint level map\n+    // will change rarely.\n+    tcx.dep_graph.with_ignore(|| {\n+        let sets = tcx.lint_levels(LOCAL_CRATE);\n+        loop {\n+            let hir_id = tcx.hir.definitions().node_to_hir_id(id);\n+            if sets.lint_level_set(hir_id).is_some() {\n+                return id\n+            }\n+            let next = tcx.hir.get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    })\n+}\n+\n mod block;\n mod expr;\n mod to_ref;"}, {"sha": "09a31f9ab8fa55d1c753d34ecf9bb429f0cc7f64", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -29,6 +29,21 @@ pub mod cx;\n \n pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum LintLevel {\n+    Inherited,\n+    Explicit(ast::NodeId)\n+}\n+\n+impl LintLevel {\n+    pub fn is_explicit(self) -> bool {\n+        match self {\n+            LintLevel::Inherited => false,\n+            LintLevel::Explicit(_) => true\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n@@ -37,6 +52,15 @@ pub struct Block<'tcx> {\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n+    pub safety_mode: BlockSafety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BlockSafety {\n+    Safe,\n+    ExplicitUnsafe(ast::NodeId),\n+    PushUnsafe,\n+    PopUnsafe\n }\n \n #[derive(Clone, Debug)]\n@@ -73,7 +97,10 @@ pub enum StmtKind<'tcx> {\n         pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>\n+        initializer: Option<ExprRef<'tcx>>,\n+\n+        /// the lint level for this let-statement\n+        lint_level: LintLevel,\n     },\n }\n \n@@ -111,6 +138,7 @@ pub struct Expr<'tcx> {\n pub enum ExprKind<'tcx> {\n     Scope {\n         region_scope: region::Scope,\n+        lint_level: LintLevel,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n@@ -275,6 +303,7 @@ pub struct Arm<'tcx> {\n     pub patterns: Vec<Pattern<'tcx>>,\n     pub guard: Option<ExprRef<'tcx>>,\n     pub body: ExprRef<'tcx>,\n+    pub lint_level: LintLevel,\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "a3a986918a4fd6395d06b2849d414335de364002", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -140,6 +140,7 @@ fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     LocalDecl {\n         mutability, ty, name: None,\n         source_info: SourceInfo { scope: ARGUMENT_VISIBILITY_SCOPE, span },\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false\n     }\n@@ -195,6 +196,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,\n@@ -342,6 +344,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             IndexVec::from_elem_n(\n                 VisibilityScopeData { span: self.span, parent_scope: None }, 1\n             ),\n+            ClearOnDecode::Clear,\n             IndexVec::new(),\n             self.sig.output(),\n             None,\n@@ -804,6 +807,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,\n@@ -876,6 +880,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         IndexVec::from_elem_n(\n             VisibilityScopeData { span: span, parent_scope: None }, 1\n         ),\n+        ClearOnDecode::Clear,\n         IndexVec::new(),\n         sig.output(),\n         None,"}, {"sha": "49ce36223994b56f53c8825da2773078532edd79", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+use rustc::ty::maps::Providers;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::{DefPathData, Node};\n+use rustc::lint::builtin::{SAFE_EXTERN_STATICS, UNUSED_UNSAFE};\n+use rustc::mir::*;\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+\n+use syntax::ast;\n+\n+use std::rc::Rc;\n+\n+\n+pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+    violations: Vec<UnsafetyViolation>,\n+    source_info: SourceInfo,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>) -> Self {\n+        Self {\n+            mir,\n+            visibility_scope_info,\n+            violations: vec![],\n+            source_info: SourceInfo {\n+                span: mir.span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            tcx,\n+            param_env,\n+            used_unsafe: FxHashSet(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location)\n+    {\n+        self.source_info = terminator.source_info;\n+        match terminator.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::SwitchInt { .. } |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            TerminatorKind::Call { ref func, .. } => {\n+                let func_ty = func.ty(self.mir, self.tcx);\n+                let sig = func_ty.fn_sig(self.tcx);\n+                if let hir::Unsafety::Unsafe = sig.unsafety() {\n+                    self.require_unsafe(\"call to unsafe function\")\n+                }\n+            }\n+        }\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location)\n+    {\n+        self.source_info = statement.source_info;\n+        match statement.kind {\n+            StatementKind::Assign(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(..) |\n+            StatementKind::StorageDead(..) |\n+            StatementKind::EndRegion(..) |\n+            StatementKind::Validate(..) |\n+            StatementKind::Nop => {\n+                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            StatementKind::InlineAsm { .. } => {\n+                self.require_unsafe(\"use of inline assembly\")\n+            },\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location)\n+    {\n+        if let &Rvalue::Aggregate(\n+            box AggregateKind::Closure(def_id, _),\n+            _\n+        ) = rvalue {\n+            let unsafety_violations = self.tcx.unsafety_violations(def_id);\n+            self.register_violations(&unsafety_violations);\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        match lvalue {\n+            &Lvalue::Projection(box Projection {\n+                ref base, ref elem\n+            }) => {\n+                let old_source_info = self.source_info;\n+                if let &Lvalue::Local(local) = base {\n+                    if self.mir.local_decls[local].internal {\n+                        // Internal locals are used in the `move_val_init` desugaring.\n+                        // We want to check unsafety against the source info of the\n+                        // desugaring, rather than the source info of the RHS.\n+                        self.source_info = self.mir.local_decls[local].source_info;\n+                    }\n+                }\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match base_ty.sty {\n+                    ty::TyRawPtr(..) => {\n+                        self.require_unsafe(\"dereference of raw pointer\")\n+                    }\n+                    ty::TyAdt(adt, _) if adt.is_union() => {\n+                        if context == LvalueContext::Store ||\n+                            context == LvalueContext::Drop\n+                        {\n+                            let elem_ty = match elem {\n+                                &ProjectionElem::Field(_, ty) => ty,\n+                                _ => span_bug!(\n+                                    self.source_info.span,\n+                                    \"non-field projection {:?} from union?\",\n+                                    lvalue)\n+                            };\n+                            if elem_ty.moves_by_default(self.tcx, self.param_env,\n+                                                        self.source_info.span) {\n+                                self.require_unsafe(\n+                                    \"assignment to non-`Copy` union field\")\n+                            } else {\n+                                // write to non-move union, safe\n+                            }\n+                        } else {\n+                            self.require_unsafe(\"access to union field\")\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                self.source_info = old_source_info;\n+            }\n+            &Lvalue::Local(..) => {\n+                // locals are safe\n+            }\n+            &Lvalue::Static(box Static { def_id, ty: _ }) => {\n+                if self.is_static_mut(def_id) {\n+                    self.require_unsafe(\"use of mutable static\");\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.visibility_scope_info[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: \"use of extern static\",\n+                        lint_node_id: Some(lint_root)\n+                    }]);\n+                }\n+            }\n+        }\n+        self.super_lvalue(lvalue, context, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn is_static_mut(&self, def_id: DefId) -> bool {\n+        if let Some(node) = self.tcx.hir.get_if_local(def_id) {\n+            match node {\n+                Node::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n+                }) => true,\n+                Node::NodeForeignItem(&hir::ForeignItem {\n+                    node: hir::ForeignItemStatic(_, mutbl), ..\n+                }) => mutbl,\n+                _ => false\n+            }\n+        } else {\n+            match self.tcx.describe_def(def_id) {\n+                Some(Def::Static(_, mutbl)) => mutbl,\n+                _ => false\n+            }\n+        }\n+    }\n+    fn require_unsafe(&mut self,\n+                      description: &'static str)\n+    {\n+        let source_info = self.source_info;\n+        self.register_violations(&[UnsafetyViolation {\n+            source_info, description, lint_node_id: None\n+        }]);\n+    }\n+\n+    fn register_violations(&mut self, violations: &[UnsafetyViolation]) {\n+        match self.visibility_scope_info[self.source_info.scope].safety {\n+            Safety::Safe => {\n+                for violation in violations {\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(violation.clone())\n+                    }\n+                }\n+            }\n+            Safety::BuiltinUnsafe | Safety::FnUnsafe => {}\n+            Safety::ExplicitUnsafe(node_id) => {\n+                if !violations.is_empty() {\n+                    self.used_unsafe.insert(node_id);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        unsafety_violations,\n+        ..*providers\n+    };\n+}\n+\n+struct UnusedUnsafeVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>\n+}\n+\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) ->\n+        hir::intravisit::NestedVisitorMap<'this, 'tcx>\n+    {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        hir::intravisit::walk_block(self, block);\n+\n+        if let hir::UnsafeBlock(hir::UserProvided) = block.rules {\n+            if !self.used_unsafe.contains(&block.id) {\n+                self.report_unused_unsafe(block);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> UnusedUnsafeVisitor<'a, 'tcx> {\n+    /// Return the NodeId for an enclosing scope that is also `unsafe`\n+    fn is_enclosed(&self, id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n+        let parent_id = self.tcx.hir.get_parent_node(id);\n+        if parent_id != id {\n+            if self.used_unsafe.contains(&parent_id) {\n+                Some((\"block\".to_string(), parent_id))\n+            } else if let Some(hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n+                ..\n+            })) = self.tcx.hir.find(parent_id) {\n+                Some((\"fn\".to_string(), parent_id))\n+            } else {\n+                self.is_enclosed(parent_id)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn report_unused_unsafe(&self, block: &'tcx hir::Block) {\n+        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n+                                                    block.id,\n+                                                    block.span,\n+                                                    \"unnecessary `unsafe` block\");\n+        db.span_label(block.span, \"unnecessary `unsafe` block\");\n+        if let Some((kind, id)) = self.is_enclosed(block.id) {\n+            db.span_note(self.tcx.hir.span(id),\n+                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n+        }\n+        db.emit();\n+    }\n+}\n+\n+fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 def_id: DefId,\n+                                 used_unsafe: FxHashSet<ast::NodeId>)\n+{\n+    let body_id =\n+        tcx.hir.as_local_node_id(def_id).and_then(|node_id| {\n+            tcx.hir.maybe_body_owned_by(node_id)\n+        });\n+\n+    let body_id = match body_id {\n+        Some(body) => body,\n+        None => {\n+            debug!(\"check_unused_unsafe({:?}) - no body found\", def_id);\n+            return\n+        }\n+    };\n+    let body = tcx.hir.body(body_id);\n+    debug!(\"check_unused_unsafe({:?}, body={:?}, used_unsafe={:?})\",\n+           def_id, body, used_unsafe);\n+\n+    hir::intravisit::Visitor::visit_body(\n+        &mut UnusedUnsafeVisitor { tcx, used_unsafe },\n+        body);\n+}\n+\n+fn unsafety_violations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) ->\n+    Rc<[UnsafetyViolation]>\n+{\n+    debug!(\"unsafety_violations({:?})\", def_id);\n+\n+    // NB: this borrow is valid because all the consumers of\n+    // `mir_const` force this.\n+    let mir = &tcx.mir_const(def_id).borrow();\n+\n+    let visibility_scope_info = match mir.visibility_scope_info {\n+        ClearOnDecode::Set(ref data) => data,\n+        ClearOnDecode::Clear => {\n+            debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n+            return Rc::new([])\n+        }\n+    };\n+\n+    let param_env = tcx.param_env(def_id);\n+    let mut checker = UnsafetyChecker::new(\n+        mir, visibility_scope_info, tcx, param_env);\n+    checker.visit_mir(mir);\n+\n+    check_unused_unsafe(tcx, def_id, checker.used_unsafe);\n+    checker.violations.into()\n+}\n+\n+pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    debug!(\"check_unsafety({:?})\", def_id);\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        // closures are handled by their parent fn.\n+        DefPathData::ClosureExpr => return,\n+        _ => {}\n+    };\n+\n+    for &UnsafetyViolation {\n+        source_info, description, lint_node_id\n+    } in &*tcx.unsafety_violations(def_id) {\n+        // Report an error.\n+        if let Some(lint_node_id) = lint_node_id {\n+            tcx.lint_node(SAFE_EXTERN_STATICS,\n+                          lint_node_id,\n+                          source_info.span,\n+                          &format!(\"{} requires unsafe function or \\\n+                                    block (error E0133)\", description));\n+        } else {\n+            struct_span_err!(\n+                tcx.sess, source_info.span, E0133,\n+                \"{} requires unsafe function or block\", description)\n+                .span_label(source_info.span, description)\n+                .emit();\n+        }\n+    }\n+}"}, {"sha": "729fe46ef37ecc7704db57216b2c7d2d3e08e269", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -301,6 +301,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n         ty: ret_ty,\n         name: None,\n         source_info: source_info(mir),\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -443,14 +444,15 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn insert_switch<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            mir: &mut Mir<'tcx>,\n                            cases: Vec<(u32, BasicBlock)>,\n-                           transform: &TransformVisitor<'a, 'tcx>) {\n-    let return_block = insert_return_block(mir);\n+                           transform: &TransformVisitor<'a, 'tcx>,\n+                           default: TerminatorKind<'tcx>) {\n+    let default_block = insert_term_block(mir, default);\n \n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Consume(transform.make_field(transform.state_field, tcx.types.u32)),\n         switch_ty: tcx.types.u32,\n         values: Cow::from(cases.iter().map(|&(i, _)| ConstInt::U32(i)).collect::<Vec<_>>()),\n-        targets: cases.iter().map(|&(_, d)| d).chain(once(return_block)).collect(),\n+        targets: cases.iter().map(|&(_, d)| d).chain(once(default_block)).collect(),\n     };\n \n     let source_info = source_info(mir);\n@@ -542,7 +544,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     // The returned state (1) and the poisoned state (2) falls through to\n     // the default case which is just to return\n \n-    insert_switch(tcx, &mut mir, cases, &transform);\n+    insert_switch(tcx, &mut mir, cases, &transform, TerminatorKind::Return);\n \n     for block in mir.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n@@ -558,6 +560,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         ty: tcx.mk_nil(),\n         name: None,\n         source_info,\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -573,6 +576,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         }),\n         name: None,\n         source_info,\n+        lexical_scope: ARGUMENT_VISIBILITY_SCOPE,\n         internal: false,\n         is_user_variable: false,\n     };\n@@ -588,18 +592,18 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir\n }\n \n-fn insert_return_block<'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n-    let return_block = BasicBlock::new(mir.basic_blocks().len());\n+fn insert_term_block<'tcx>(mir: &mut Mir<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+    let term_block = BasicBlock::new(mir.basic_blocks().len());\n     let source_info = source_info(mir);\n     mir.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n-            kind: TerminatorKind::Return,\n+            kind,\n         }),\n         is_cleanup: false,\n     });\n-    return_block\n+    term_block\n }\n \n fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -659,7 +663,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // Panic when resumed on the poisoned (2) state\n     cases.insert(2, (2, insert_panic_block(tcx, mir, AssertMessage::GeneratorResumedAfterPanic)));\n \n-    insert_switch(tcx, mir, cases, &transform);\n+    insert_switch(tcx, mir, cases, &transform, TerminatorKind::Unreachable);\n \n     make_generator_state_argument_indirect(tcx, def_id, mir);\n \n@@ -680,7 +684,7 @@ fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n }\n \n fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n-    let return_block = insert_return_block(mir);\n+    let return_block = insert_term_block(mir, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     let drop_clean = BasicBlock::new(mir.basic_blocks().len());"}, {"sha": "7245b2daa126081b57cd0329e55e3ec754ed9de6", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -26,6 +26,7 @@ use transform;\n \n pub mod add_validation;\n pub mod clean_end_regions;\n+pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -46,6 +47,7 @@ pub mod nll;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n+    self::check_unsafety::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,\n@@ -116,6 +118,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         // directly need the result or `mir_const_qualif`, so we can just force it.\n         ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n     }\n+    ty::queries::unsafety_violations::force(tcx, DUMMY_SP, def_id);\n \n     let mut mir = tcx.mir_const(def_id).steal();\n     transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);"}, {"sha": "bd02788df1653c63ed458c53a8b69bf5e92d5370", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "previous_filename": "src/librustc_mir/transform/nll.rs"}, {"sha": "339ea8a414b1e982da421159723a48c6463482ee", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -380,10 +380,10 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         let mut promoter = Promoter {\n             promoted: Mir::new(\n                 IndexVec::new(),\n-                Some(VisibilityScopeData {\n-                    span,\n-                    parent_scope: None\n-                }).into_iter().collect(),\n+                // FIXME: maybe try to filter this to avoid blowing up\n+                // memory usage?\n+                mir.visibility_scopes.clone(),\n+                mir.visibility_scope_info.clone(),\n                 IndexVec::new(),\n                 ty,\n                 None,"}, {"sha": "efb5b0318099822877662560b6fe457ecbd971f6", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -122,14 +122,6 @@ impl<'a> AstValidator<'a> {\n }\n \n impl<'a> Visitor<'a> for AstValidator<'a> {\n-    fn visit_lifetime(&mut self, lt: &'a Lifetime) {\n-        if lt.ident.name == \"'_\" {\n-            self.err_handler().span_err(lt.span, &format!(\"invalid lifetime name `{}`\", lt.ident));\n-        }\n-\n-        visit::walk_lifetime(self, lt)\n-    }\n-\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n             ExprKind::While(.., Some(ident)) |"}, {"sha": "c65312e9a8337e8fd48f3d290d91926bb97956d6", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,5 +10,6 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc = { path = \"../librustc\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e7a1dd6b043b173b51022a94877f785c0a301d35", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 118, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -17,6 +17,7 @@\n \n #[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n+extern crate rustc_typeck;\n extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -658,65 +659,6 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         }\n         false\n     }\n-\n-    fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n-        self.current_item = self.tcx.hir.local_def_id(item_id);\n-        self.span = self.tcx.hir.span(item_id);\n-        self\n-    }\n-\n-    // Convenience methods for checking item interfaces\n-    fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.generics_of(self.current_item).types {\n-            if def.has_default {\n-                self.tcx.type_of(def.def_id).visit_with(self);\n-            }\n-        }\n-        self\n-    }\n-\n-    fn predicates(&mut self) -> &mut Self {\n-        let predicates = self.tcx.predicates_of(self.current_item);\n-        for predicate in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n-        self\n-    }\n-\n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.current_item) {\n-            self.check_trait_ref(impl_trait_ref);\n-        }\n-        self.tcx.predicates_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n-        }\n-\n-        trait_ref.super_visit_with(self)\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -733,6 +675,35 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+        self.span = hir_ty.span;\n+        if let Some(ty) = self.tables.node_id_to_type_opt(hir_ty.hir_id) {\n+            // Types in bodies.\n+            if ty.visit_with(self) {\n+                return;\n+            }\n+        } else {\n+            // Types in signatures.\n+            // FIXME: This is very ineffective. Ideally each HIR type should be converted\n+            // into a semantic type only once and the result should be cached somehow.\n+            if rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty).visit_with(self) {\n+                return;\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, hir_ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n+        if !self.item_is_accessible(trait_ref.path.def.def_id()) {\n+            let msg = format!(\"trait `{:?}` is private\", trait_ref.path);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return;\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if self.check_expr_pat_type(expr.hir_id, expr.span) {\n@@ -807,63 +778,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                                         item.id,\n                                         &mut self.tables,\n                                         self.empty_tables);\n-\n-        match item.node {\n-            hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemUse(..) | hir::ItemGlobalAsm(..) => {}\n-            hir::ItemConst(..) | hir::ItemStatic(..) |\n-            hir::ItemTy(..) | hir::ItemFn(..) => {\n-                self.check_item(item.id).generics().predicates().ty();\n-            }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n-                self.check_item(item.id).generics().predicates();\n-                for trait_item_ref in trait_item_refs {\n-                    let check = self.check_item(trait_item_ref.id.node_id);\n-                    check.generics().predicates();\n-                    if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n-                       trait_item_ref.defaultness.has_value() {\n-                        check.ty();\n-                    }\n-                }\n-            }\n-            hir::ItemEnum(ref def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n-                        self.check_item(field.id).ty();\n-                    }\n-                }\n-            }\n-            hir::ItemForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n-                    self.check_item(foreign_item.id).generics().predicates().ty();\n-                }\n-            }\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for field in struct_def.fields() {\n-                    self.check_item(field.id).ty();\n-                }\n-            }\n-            hir::ItemDefaultImpl(..) => {\n-                self.check_item(item.id).impl_trait_ref();\n-            }\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                {\n-                    let check = self.check_item(item.id);\n-                    check.ty().generics().predicates();\n-                    if trait_ref.is_some() {\n-                        check.impl_trait_ref();\n-                    }\n-                }\n-                for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n-                    self.check_item(impl_item.id).generics().predicates().ty();\n-                }\n-            }\n-        }\n-\n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n@@ -924,8 +838,13 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::TyProjection(ref proj) => {\n-                let tcx = self.tcx;\n-                if self.check_trait_ref(proj.trait_ref(tcx)) {\n+                let trait_ref = proj.trait_ref(self.tcx);\n+                if !self.item_is_accessible(trait_ref.def_id) {\n+                    let msg = format!(\"trait `{}` is private\", trait_ref);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+                if trait_ref.super_visit_with(self) {\n                     return true;\n                 }\n             }"}, {"sha": "36cd69f91b9c34c6fd981cb74efa71d40aa702a3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -605,7 +605,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n-                    if item.span == DUMMY_SP {\n+                    if item.span.ctxt().outer().expn_info().is_none() {\n                         self.span = Some(item.span.with_hi(item.span.lo()));\n                         self.found_use = true;\n                         return;\n@@ -615,11 +615,22 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n                 ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n-                    self.span = Some(item.span.with_hi(item.span.lo()));\n+                    if item.span.ctxt().outer().expn_info().is_none() {\n+                        // don't insert between attributes and an item\n+                        if item.attrs.is_empty() {\n+                            self.span = Some(item.span.with_hi(item.span.lo()));\n+                        } else {\n+                            // find the first attribute on the item\n+                            for attr in &item.attrs {\n+                                if self.span.map_or(true, |span| attr.span < span) {\n+                                    self.span = Some(attr.span.with_hi(attr.span.lo()));\n+                                }\n+                            }\n+                        }\n+                    }\n                 },\n             }\n         }\n-        assert!(self.span.is_some(), \"a file can't have no items and emit suggestions\");\n     }\n }\n \n@@ -3553,8 +3564,7 @@ impl<'a> Resolver<'a> {\n             };\n             visit::walk_crate(&mut finder, krate);\n             if !candidates.is_empty() {\n-                let span = finder.span.expect(\"did not find module\");\n-                show_candidates(&mut err, span, &candidates, better, finder.found_use);\n+                show_candidates(&mut err, finder.span, &candidates, better, finder.found_use);\n             }\n             err.emit();\n         }\n@@ -3748,7 +3758,8 @@ fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, St\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n fn show_candidates(err: &mut DiagnosticBuilder,\n-                   span: Span,\n+                   // This is `None` if all placement locations are inside expansions\n+                   span: Option<Span>,\n                    candidates: &[ImportSuggestion],\n                    better: bool,\n                    found_use: bool) {\n@@ -3766,18 +3777,27 @@ fn show_candidates(err: &mut DiagnosticBuilder,\n     };\n     let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n \n-    for candidate in &mut path_strings {\n-        // produce an additional newline to separate the new use statement\n-        // from the directly following item.\n-        let additional_newline = if found_use {\n-            \"\"\n-        } else {\n-            \"\\n\"\n-        };\n-        *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n-    }\n+    if let Some(span) = span {\n+        for candidate in &mut path_strings {\n+            // produce an additional newline to separate the new use statement\n+            // from the directly following item.\n+            let additional_newline = if found_use {\n+                \"\"\n+            } else {\n+                \"\\n\"\n+            };\n+            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n+        }\n \n-    err.span_suggestions(span, &msg, path_strings);\n+        err.span_suggestions(span, &msg, path_strings);\n+    } else {\n+        let mut msg = msg;\n+        msg.push(':');\n+        for candidate in path_strings {\n+            msg.push('\\n');\n+            msg.push_str(&candidate);\n+        }\n+    }\n }\n \n /// A somewhat inefficient routine to obtain the name of a module."}, {"sha": "482350d04b5a72e539aa21c615900f9ee0cb843d", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -32,4 +32,4 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n \n [target.\"cfg(windows)\".dependencies]\n-gcc = \"0.3.50\"\n+cc = \"1.0\""}, {"sha": "619ea59ff1a2e61034fffcc48878c36a5bf059e0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 52, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate rustc_trans_utils;\n-\n use super::archive::{ArchiveBuilder, ArchiveConfig};\n use super::linker::Linker;\n use super::command::Command;\n@@ -20,17 +18,14 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n+use rustc::middle::cstore::{NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n-use rustc::dep_graph::{DepKind, DepNode};\n use rustc::hir::def_id::CrateNum;\n-use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_back::{PanicStrategy, RelroLevel};\n-use rustc_incremental::IncrementalHashesMap;\n use context::get_reloc_model;\n use llvm;\n \n@@ -89,17 +84,9 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n-pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n-                                        default_output_for_target, invalid_output_for_target};\n-\n-pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n-    let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n-    let r = LinkMeta {\n-        crate_hash: Svh::new(incremental_hashes_map[krate_dep_node].to_smaller_hash()),\n-    };\n-    info!(\"{:?}\", r);\n-    return r;\n-}\n+pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n+                                  invalid_output_for_target, build_link_meta, out_filename,\n+                                  check_file_is_writeable};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -138,7 +125,7 @@ pub fn get_linker(sess: &Session) -> (String, Command, Vec<(OsString, OsString)>\n \n #[cfg(windows)]\n pub fn msvc_link_exe_cmd(sess: &Session) -> (Command, Vec<(OsString, OsString)>) {\n-    use gcc::windows_registry;\n+    use cc::windows_registry;\n \n     let target = &sess.opts.target_triple;\n     let tool = windows_registry::find_tool(target, \"link.exe\");\n@@ -227,13 +214,6 @@ pub fn link_binary(sess: &Session,\n     out_filenames\n }\n \n-fn is_writeable(p: &Path) -> bool {\n-    match p.metadata() {\n-        Err(..) => true,\n-        Ok(m) => !m.permissions().readonly()\n-    }\n-}\n-\n fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilenames) -> PathBuf {\n     let out_filename = outputs.single_output_file.clone()\n         .unwrap_or(outputs\n@@ -297,32 +277,6 @@ pub fn ignored_for_lto(info: &CrateInfo, cnum: CrateNum) -> bool {\n     info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum)\n }\n \n-fn out_filename(sess: &Session,\n-                crate_type: config::CrateType,\n-                outputs: &OutputFilenames,\n-                crate_name: &str)\n-                -> PathBuf {\n-    let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n-    let out_filename = outputs.outputs.get(&OutputType::Exe)\n-                              .and_then(|s| s.to_owned())\n-                              .or_else(|| outputs.single_output_file.clone())\n-                              .unwrap_or(default_filename);\n-\n-    check_file_is_writeable(&out_filename, sess);\n-\n-    out_filename\n-}\n-\n-// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n-// check this already -- however, the Linux linker will happily overwrite a\n-// read-only file.  We should be consistent.\n-fn check_file_is_writeable(file: &Path, sess: &Session) {\n-    if !is_writeable(file) {\n-        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n-                            permissions\", file.display()));\n-    }\n-}\n-\n fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: config::CrateType,\n@@ -555,7 +509,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // of when we do and don't keep .#module-name#.bc files around.\n                 let user_wants_numbered_bitcode =\n                         sess.opts.output_types.contains_key(&OutputType::Bitcode) &&\n-                        sess.opts.cg.codegen_units > 1;\n+                        sess.opts.codegen_units > 1;\n                 if !sess.opts.cg.save_temps && !user_wants_numbered_bitcode {\n                     remove(sess, &bc_filename);\n                 }"}, {"sha": "6b980a37ac77837c8b3604e72f7103643314391e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -939,10 +939,10 @@ fn produce_final_output_artifacts(sess: &Session,\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n         let keep_numbered_bitcode = needs_crate_bitcode ||\n-                (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n+                (user_wants_bitcode && sess.opts.codegen_units > 1);\n \n         let keep_numbered_objects = needs_crate_object ||\n-                (user_wants_objects && sess.opts.cg.codegen_units > 1);\n+                (user_wants_objects && sess.opts.codegen_units > 1);\n \n         for module in compiled_modules.modules.iter() {\n             let module_name = Some(&module.name[..]);\n@@ -1520,6 +1520,11 @@ fn start_executing_work(tcx: TyCtxt,\n                                     total_llvm_time);\n         }\n \n+        // Regardless of what order these modules completed in, report them to\n+        // the backend in the same order every time to ensure that we're handing\n+        // out deterministic results.\n+        compiled_modules.sort_by(|a, b| a.name.cmp(&b.name));\n+\n         let compiled_metadata_module = compiled_metadata_module\n             .expect(\"Metadata module not compiled?\");\n \n@@ -1853,7 +1858,7 @@ impl OngoingCrateTranslation {\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n+        if sess.opts.codegen_units == 1 && sess.time_llvm_passes() {\n             unsafe { llvm::LLVMRustPrintPassTimings(); }\n         }\n "}, {"sha": "774acc813438fca05c5d15ca94ce093a58489b69", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 11, "deletions": 74, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -41,12 +41,12 @@ use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n+use rustc::dep_graph::{DepNode, DepKind};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n-use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n@@ -94,6 +94,8 @@ use syntax::ast;\n \n use mir::lvalue::Alignment;\n \n+pub use rustc_trans_utils::{find_exported_symbols, check_for_rustc_errors_attr};\n+\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n@@ -659,20 +661,6 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n-// check for the #[rustc_error] annotation, which forces an\n-// error in trans. This is used to write compile-fail tests\n-// that actually test that compilation succeeds without\n-// reporting an error.\n-fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n-    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n-        let main_def_id = tcx.hir.local_def_id(id);\n-\n-        if tcx.has_attr(main_def_id, \"rustc_error\") {\n-            tcx.sess.span_fatal(span, \"compilation successful\");\n-        }\n-    }\n-}\n-\n /// Create the `main` function which will initialize the rust runtime and call\n /// users main function.\n fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n@@ -884,63 +872,16 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     }\n }\n \n-/// The context provided lists a set of reachable ids as calculated by\n-/// middle::reachable, but this contains far more ids and symbols than we're\n-/// actually exposing from the object file. This function will filter the set in\n-/// the context to the set of ids which correspond to symbols that are exposed\n-/// from the object file being generated.\n-///\n-/// This list is later used by linkers to determine the set of symbols needed to\n-/// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n-        // Next, we want to ignore some FFI functions that are not exposed from\n-        // this crate. Reachable FFI functions can be lumped into two\n-        // categories:\n-        //\n-        // 1. Those that are included statically via a static library\n-        // 2. Those included otherwise (e.g. dynamically or via a framework)\n-        //\n-        // Although our LLVM module is not literally emitting code for the\n-        // statically included symbols, it's an export of our library which\n-        // needs to be passed on to the linker and encoded in the metadata.\n-        //\n-        // As a result, if this id is an FFI item (foreign item) then we only\n-        // let it through if it's included statically.\n-        match tcx.hir.get(id) {\n-            hir_map::NodeForeignItem(..) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.is_statically_included_foreign_item(def_id)\n-            }\n-\n-            // Only consider nodes that actually have exported symbols.\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemStatic(..), .. }) |\n-            hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(..), .. }) |\n-            hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(..), .. }) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                let generics = tcx.generics_of(def_id);\n-                let attributes = tcx.get_attrs(def_id);\n-                (generics.parent_types == 0 && generics.types.is_empty()) &&\n-                // Functions marked with #[inline] are only ever translated\n-                // with \"internal\" linkage and are never exported.\n-                !attr::requests_inline(&attributes)\n-            }\n-\n-            _ => false\n-        }\n-    }).collect()\n-}\n-\n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             incremental_hashes_map: IncrementalHashesMap,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCrateTranslation {\n+\n     check_for_rustc_errors_attr(tcx);\n \n-    let link_meta = link::build_link_meta(&incremental_hashes_map);\n+\n+    let crate_hash = tcx.dep_graph\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n+    let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     let shared_ccx = SharedCrateContext::new(tcx);\n@@ -980,7 +921,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.translation_finished(tcx);\n \n         assert_and_save_dep_graph(tcx,\n-                                  incremental_hashes_map,\n                                   metadata_incr_hashes,\n                                   link_meta);\n \n@@ -1113,7 +1053,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx,\n-                              incremental_hashes_map,\n                               metadata_incr_hashes,\n                               link_meta);\n     ongoing_translation\n@@ -1124,7 +1063,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n thread_local!(static DISPOSITIONS: RefCell<Vec<(String, Disposition)>> = Default::default());\n \n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       incremental_hashes_map: IncrementalHashesMap,\n                                        metadata_incr_hashes: EncodedMetadataHashes,\n                                        link_meta: LinkMeta) {\n     time(tcx.sess.time_passes(),\n@@ -1134,7 +1072,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(tcx.sess.time_passes(),\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx,\n-                                              incremental_hashes_map,\n                                               &metadata_incr_hashes,\n                                               link_meta.crate_hash));\n }\n@@ -1225,7 +1162,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     let strategy = if tcx.sess.opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.cg.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.opts.codegen_units)\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n@@ -1238,7 +1175,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n             .collect::<Vec<_>>()\n     });\n \n-    assert!(tcx.sess.opts.cg.codegen_units == codegen_units.len() ||\n+    assert!(tcx.sess.opts.codegen_units == codegen_units.len() ||\n             tcx.sess.opts.debugging_opts.incremental.is_some());\n \n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {"}, {"sha": "796dfd4417c6ad181ec565787e0e1e018be6f5fe", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -50,6 +50,7 @@ extern crate rustc_incremental;\n extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n+extern crate rustc_trans_utils;\n extern crate rustc_demangle;\n extern crate jobserver;\n extern crate num_cpus;\n@@ -60,7 +61,7 @@ extern crate syntax_pos;\n extern crate rustc_errors as errors;\n extern crate serialize;\n #[cfg(windows)]\n-extern crate gcc; // Used to locate MSVC, not gcc :)\n+extern crate cc; // Used to locate MSVC\n \n pub use base::trans_crate;\n \n@@ -137,6 +138,63 @@ mod type_;\n mod type_of;\n mod value;\n \n+use std::sync::mpsc;\n+use std::any::Any;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::session::Session;\n+use rustc::session::config::OutputFilenames;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc::dep_graph::DepGraph;\n+\n+pub struct LlvmTransCrate(());\n+\n+impl LlvmTransCrate {\n+    pub fn new() -> Self {\n+        LlvmTransCrate(())\n+    }\n+}\n+\n+impl rustc_trans_utils::trans_crate::TransCrate for LlvmTransCrate {\n+    type MetadataLoader = metadata::LlvmMetadataLoader;\n+    type OngoingCrateTranslation = back::write::OngoingCrateTranslation;\n+    type TranslatedCrate = CrateTranslation;\n+\n+    fn metadata_loader() -> Box<MetadataLoader> {\n+        box metadata::LlvmMetadataLoader\n+    }\n+\n+    fn provide_local(providers: &mut ty::maps::Providers) {\n+        provide_local(providers);\n+    }\n+\n+    fn provide_extern(providers: &mut ty::maps::Providers) {\n+        provide_extern(providers);\n+    }\n+\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        base::trans_crate(tcx, rx)\n+    }\n+\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        sess: &Session,\n+        dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate {\n+        trans.join(sess, dep_graph)\n+    }\n+\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        back::link::link_binary(sess, trans, outputs, &trans.crate_name.as_str());\n+    }\n+\n+    fn dump_incremental_data(trans: &Self::TranslatedCrate) {\n+        back::write::dump_incremental_data(trans);\n+    }\n+}\n+\n pub struct ModuleTranslation {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be"}, {"sha": "62ccd55b483caf314a40636ff37dc6505e34e3a2", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -112,7 +112,8 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(\n+        DUMMY_SP, ty::ParamEnv::empty(traits::Reveal::All), ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -226,7 +227,8 @@ pub fn custom_coerce_unsize_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match tcx.trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n+    match tcx.trans_fulfill_obligation(\n+        DUMMY_SP, ty::ParamEnv::empty(traits::Reveal::All), trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             tcx.coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }"}, {"sha": "7c29186f4657f721a5424d5c1c9c736569dc76bf", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -108,11 +108,12 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n+use rustc::ich::Fingerprint;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_incremental::IchHasher;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n@@ -155,7 +156,7 @@ pub trait CodegenUnitExt<'tcx> {\n     }\n \n     fn compute_symbol_name_hash<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> u64 {\n-        let mut state = IchHasher::new();\n+        let mut state: StableHasher<Fingerprint> = StableHasher::new();\n         let all_items = self.items_in_deterministic_order(tcx);\n         for (item, (linkage, visibility)) in all_items {\n             let symbol_name = item.symbol_name(tcx);"}, {"sha": "bedbea0068874dd848b195ae9645e87cd51465ac", "filename": "src/librustc_trans_utils/Cargo.toml", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,6 +10,12 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-rustc = { path = \"../librustc\" }\n+ar = \"0.3.0\"\n+flate2 = \"0.2\"\n+owning_ref = \"0.3.3\"\n+log = \"0.3\"\n+\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }"}, {"sha": "6873befd2bfcac5eb8b688d13d4d21944d8f4c10", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -29,8 +29,89 @@\n \n #![cfg_attr(stage0, feature(const_fn))]\n \n+extern crate ar;\n+extern crate flate2;\n+extern crate owning_ref;\n+#[macro_use]\n+extern crate log;\n+\n+#[macro_use]\n extern crate rustc;\n+extern crate rustc_back;\n extern crate syntax;\n extern crate syntax_pos;\n \n+use rustc::ty::TyCtxt;\n+use rustc::hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::hir::map as hir_map;\n+use rustc::util::nodemap::NodeSet;\n+\n+use syntax::attr;\n+\n pub mod link;\n+pub mod trans_crate;\n+\n+/// check for the #[rustc_error] annotation, which forces an\n+/// error in trans. This is used to write compile-fail tests\n+/// that actually test that compilation succeeds without\n+/// reporting an error.\n+pub fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n+    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n+        let main_def_id = tcx.hir.local_def_id(id);\n+\n+        if tcx.has_attr(main_def_id, \"rustc_error\") {\n+            tcx.sess.span_fatal(span, \"compilation successful\");\n+        }\n+    }\n+}\n+\n+/// The context provided lists a set of reachable ids as calculated by\n+/// middle::reachable, but this contains far more ids and symbols than we're\n+/// actually exposing from the object file. This function will filter the set in\n+/// the context to the set of ids which correspond to symbols that are exposed\n+/// from the object file being generated.\n+///\n+/// This list is later used by linkers to determine the set of symbols needed to\n+/// be exposed from a dynamic library and it's also encoded into the metadata.\n+pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n+    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n+        // Next, we want to ignore some FFI functions that are not exposed from\n+        // this crate. Reachable FFI functions can be lumped into two\n+        // categories:\n+        //\n+        // 1. Those that are included statically via a static library\n+        // 2. Those included otherwise (e.g. dynamically or via a framework)\n+        //\n+        // Although our LLVM module is not literally emitting code for the\n+        // statically included symbols, it's an export of our library which\n+        // needs to be passed on to the linker and encoded in the metadata.\n+        //\n+        // As a result, if this id is an FFI item (foreign item) then we only\n+        // let it through if it's included statically.\n+        match tcx.hir.get(id) {\n+            hir_map::NodeForeignItem(..) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                tcx.is_statically_included_foreign_item(def_id)\n+            }\n+\n+            // Only consider nodes that actually have exported symbols.\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemStatic(..), .. }) |\n+            hir_map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(..), .. }) |\n+            hir_map::NodeImplItem(&hir::ImplItem {\n+                node: hir::ImplItemKind::Method(..), .. }) => {\n+                let def_id = tcx.hir.local_def_id(id);\n+                let generics = tcx.generics_of(def_id);\n+                let attributes = tcx.get_attrs(def_id);\n+                (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                // Functions marked with #[inline] are only ever translated\n+                // with \"internal\" linkage and are never exported.\n+                !attr::requests_inline(&attributes)\n+            }\n+\n+            _ => false\n+        }\n+    }).collect()\n+}"}, {"sha": "47484488fb8e8792e92cb6e5015ed337b68f4d17", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,13 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::ich::Fingerprint;\n use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n use rustc::session::Session;\n-use rustc::middle::cstore;\n-use std::path::PathBuf;\n+use rustc::middle::cstore::{self, LinkMeta};\n+use rustc::hir::svh::Svh;\n+use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax_pos::Span;\n \n+pub fn out_filename(sess: &Session,\n+                crate_type: config::CrateType,\n+                outputs: &OutputFilenames,\n+                crate_name: &str)\n+                -> PathBuf {\n+    let default_filename = filename_for_input(sess, crate_type, crate_name, outputs);\n+    let out_filename = outputs.outputs.get(&OutputType::Exe)\n+                              .and_then(|s| s.to_owned())\n+                              .or_else(|| outputs.single_output_file.clone())\n+                              .unwrap_or(default_filename);\n+\n+    check_file_is_writeable(&out_filename, sess);\n+\n+    out_filename\n+}\n+\n+// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+// check this already -- however, the Linux linker will happily overwrite a\n+// read-only file.  We should be consistent.\n+pub fn check_file_is_writeable(file: &Path, sess: &Session) {\n+    if !is_writeable(file) {\n+        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n+                            permissions\", file.display()));\n+    }\n+}\n+\n+fn is_writeable(p: &Path) -> bool {\n+    match p.metadata() {\n+        Err(..) => true,\n+        Ok(m) => !m.permissions().readonly()\n+    }\n+}\n+\n+pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n+    let r = LinkMeta {\n+        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n+    };\n+    info!(\"{:?}\", r);\n+    return r;\n+}\n+\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {"}, {"sha": "f51a463fcc23e86c30bb57335f4d5d9b78b58585", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust compiler.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+\n+#![feature(box_syntax)]\n+\n+use std::any::Any;\n+use std::io::prelude::*;\n+use std::io::{self, Cursor};\n+use std::fs::File;\n+use std::path::Path;\n+use std::sync::mpsc;\n+\n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use ar::{Archive, Builder, Header};\n+use flate2::Compression;\n+use flate2::write::DeflateEncoder;\n+\n+use syntax::symbol::Symbol;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::session::Session;\n+use rustc::session::config::{CrateType, OutputFilenames};\n+use rustc::ty::TyCtxt;\n+use rustc::ty::maps::Providers;\n+use rustc::middle::cstore::EncodedMetadata;\n+use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n+use rustc::dep_graph::{DepGraph, DepNode, DepKind};\n+use rustc_back::target::Target;\n+use link::{build_link_meta, out_filename};\n+\n+pub trait TransCrate {\n+    type MetadataLoader: MetadataLoaderTrait;\n+    type OngoingCrateTranslation;\n+    type TranslatedCrate;\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait>;\n+    fn provide_local(_providers: &mut Providers);\n+    fn provide_extern(_providers: &mut Providers);\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation;\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        sess: &Session,\n+        dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate;\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames);\n+    fn dump_incremental_data(trans: &Self::TranslatedCrate);\n+}\n+\n+pub struct DummyTransCrate;\n+\n+impl TransCrate for DummyTransCrate {\n+    type MetadataLoader = DummyMetadataLoader;\n+    type OngoingCrateTranslation = ();\n+    type TranslatedCrate = ();\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+        box DummyMetadataLoader(())\n+    }\n+\n+    fn provide_local(_providers: &mut Providers) {\n+        bug!(\"DummyTransCrate::provide_local\");\n+    }\n+\n+    fn provide_extern(_providers: &mut Providers) {\n+        bug!(\"DummyTransCrate::provide_extern\");\n+    }\n+\n+    fn trans_crate<'a, 'tcx>(\n+        _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        bug!(\"DummyTransCrate::trans_crate\");\n+    }\n+\n+    fn join_trans(\n+        _trans: Self::OngoingCrateTranslation,\n+        _sess: &Session,\n+        _dep_graph: &DepGraph\n+    ) -> Self::TranslatedCrate {\n+        bug!(\"DummyTransCrate::join_trans\");\n+    }\n+\n+    fn link_binary(_sess: &Session, _trans: &Self::TranslatedCrate, _outputs: &OutputFilenames) {\n+        bug!(\"DummyTransCrate::link_binary\");\n+    }\n+\n+    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {\n+        bug!(\"DummyTransCrate::dump_incremental_data\");\n+    }\n+}\n+\n+pub struct DummyMetadataLoader(());\n+\n+impl MetadataLoaderTrait for DummyMetadataLoader {\n+    fn get_rlib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        bug!(\"DummyMetadataLoader::get_rlib_metadata\");\n+    }\n+\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        bug!(\"DummyMetadataLoader::get_dylib_metadata\");\n+    }\n+}\n+\n+pub struct NoLlvmMetadataLoader;\n+\n+impl MetadataLoaderTrait for NoLlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        let file = File::open(filename)\n+            .map_err(|e| format!(\"metadata file open err: {:?}\", e))?;\n+        let mut archive = Archive::new(file);\n+\n+        while let Some(entry_result) = archive.next_entry() {\n+            let mut entry = entry_result\n+                .map_err(|e| format!(\"metadata section read err: {:?}\", e))?;\n+            if entry.header().identifier() == \"rust.metadata.bin\" {\n+                let mut buf = Vec::new();\n+                io::copy(&mut entry, &mut buf).unwrap();\n+                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                return Ok(buf.map_owner_box().erase_owner());\n+            }\n+        }\n+\n+        Err(\"Couldnt find metadata section\".to_string())\n+    }\n+\n+    fn get_dylib_metadata(\n+        &self,\n+        _target: &Target,\n+        _filename: &Path,\n+    ) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // FIXME: Support reading dylibs from llvm enabled rustc\n+        self.get_rlib_metadata(_target, _filename)\n+    }\n+}\n+\n+pub struct MetadataOnlyTransCrate;\n+pub struct OngoingCrateTranslation {\n+    metadata: EncodedMetadata,\n+    metadata_version: Vec<u8>,\n+    crate_name: Symbol,\n+}\n+pub struct TranslatedCrate(OngoingCrateTranslation);\n+\n+impl MetadataOnlyTransCrate {\n+    #[allow(dead_code)]\n+    pub fn new() -> Self {\n+        MetadataOnlyTransCrate\n+    }\n+}\n+\n+impl TransCrate for MetadataOnlyTransCrate {\n+    type MetadataLoader = NoLlvmMetadataLoader;\n+    type OngoingCrateTranslation = OngoingCrateTranslation;\n+    type TranslatedCrate = TranslatedCrate;\n+\n+    fn metadata_loader() -> Box<MetadataLoaderTrait> {\n+        box NoLlvmMetadataLoader\n+    }\n+\n+    fn provide_local(_providers: &mut Providers) {}\n+    fn provide_extern(_providers: &mut Providers) {}\n+\n+    fn trans_crate<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _rx: mpsc::Receiver<Box<Any + Send>>\n+    ) -> Self::OngoingCrateTranslation {\n+        ::check_for_rustc_errors_attr(tcx);\n+        let _ = tcx.link_args(LOCAL_CRATE);\n+        let _ = tcx.native_libraries(LOCAL_CRATE);\n+        tcx.sess.abort_if_errors();\n+\n+        let crate_hash = tcx.dep_graph\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate));\n+        let link_meta = build_link_meta(crate_hash);\n+        let exported_symbols = ::find_exported_symbols(tcx);\n+        let (metadata, _hashes) = tcx.encode_metadata(&link_meta, &exported_symbols);\n+\n+        OngoingCrateTranslation {\n+            metadata: metadata,\n+            metadata_version: tcx.metadata_encoding_version().to_vec(),\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n+        }\n+    }\n+\n+    fn join_trans(\n+        trans: Self::OngoingCrateTranslation,\n+        _sess: &Session,\n+        _dep_graph: &DepGraph,\n+    ) -> Self::TranslatedCrate {\n+        TranslatedCrate(trans)\n+    }\n+\n+    fn link_binary(sess: &Session, trans: &Self::TranslatedCrate, outputs: &OutputFilenames) {\n+        for &crate_type in sess.opts.crate_types.iter() {\n+            if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n+                continue;\n+            }\n+            let output_name =\n+                out_filename(sess, crate_type, &outputs, &trans.0.crate_name.as_str());\n+            let mut compressed = trans.0.metadata_version.clone();\n+            let metadata = if crate_type == CrateType::CrateTypeDylib {\n+                DeflateEncoder::new(&mut compressed, Compression::Fast)\n+                    .write_all(&trans.0.metadata.raw_data)\n+                    .unwrap();\n+                &compressed\n+            } else {\n+                &trans.0.metadata.raw_data\n+            };\n+            let mut builder = Builder::new(File::create(&output_name).unwrap());\n+            let header = Header::new(\"rust.metadata.bin\".to_string(), metadata.len() as u64);\n+            builder.append(&header, Cursor::new(metadata)).unwrap();\n+        }\n+\n+        if !sess.opts.crate_types.contains(&CrateType::CrateTypeRlib)\n+            && !sess.opts.crate_types.contains(&CrateType::CrateTypeDylib) {\n+            sess.fatal(\"Executables are not supported by the metadata-only backend.\");\n+        }\n+    }\n+\n+    fn dump_incremental_data(_trans: &Self::TranslatedCrate) {}\n+}"}, {"sha": "54fd070e93cbcbb4943952386b405461bc83f606", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 83, "deletions": 53, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -76,6 +76,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// used to help suppress derived errors typeck might otherwise\n     /// report.\n     fn set_tainted_by_errors(&self);\n+\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n struct ConvertedBinding<'tcx> {\n@@ -155,11 +157,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n+\n         let (substs, assoc_bindings) =\n-            self.create_substs_for_ast_path(span,\n-                                            def_id,\n-                                            &item_segment.parameters,\n-                                            None);\n+            item_segment.with_parameters(|parameters| {\n+                self.create_substs_for_ast_path(\n+                    span,\n+                    def_id,\n+                    parameters,\n+                    item_segment.infer_types,\n+                    None)\n+            });\n \n         assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n \n@@ -175,6 +182,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         span: Span,\n         def_id: DefId,\n         parameters: &hir::PathParameters,\n+        infer_types: bool,\n         self_ty: Option<Ty<'tcx>>)\n         -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n     {\n@@ -202,7 +210,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check the number of type parameters supplied by the user.\n         let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-        if !parameters.infer_types || num_types_provided > ty_param_defs.len() {\n+        if !infer_types || num_types_provided > ty_param_defs.len() {\n             check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n@@ -238,7 +246,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             if i < num_types_provided {\n                 // A provided type parameter.\n                 self.ast_ty_to_ty(&parameters.types[i])\n-            } else if parameters.infer_types {\n+            } else if infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -388,7 +396,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().sess.features.borrow().unboxed_closures &&\n-           trait_segment.parameters.parenthesized != trait_def.paren_sugar {\n+           trait_segment.with_parameters(|p| p.parenthesized) != trait_def.paren_sugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let msg = if trait_def.paren_sugar {\n                 \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n@@ -400,10 +408,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                              span, GateIssue::Language, msg);\n         }\n \n-        self.create_substs_for_ast_path(span,\n-                                        trait_def_id,\n-                                        &trait_segment.parameters,\n-                                        Some(self_ty))\n+        trait_segment.with_parameters(|parameters| {\n+            self.create_substs_for_ast_path(span,\n+                                            trait_def_id,\n+                                            parameters,\n+                                            trait_segment.infer_types,\n+                                            Some(self_ty))\n+        })\n     }\n \n     fn trait_defines_associated_type_named(&self,\n@@ -874,25 +885,27 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            for typ in &segment.parameters.types {\n-                struct_span_err!(self.tcx().sess, typ.span, E0109,\n-                                 \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, \"type parameter not allowed\")\n-                    .emit();\n-                break;\n-            }\n-            for lifetime in &segment.parameters.lifetimes {\n-                struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n-                                 \"lifetime parameters are not allowed on this type\")\n-                    .span_label(lifetime.span,\n-                                \"lifetime parameter not allowed on this type\")\n-                    .emit();\n-                break;\n-            }\n-            for binding in &segment.parameters.bindings {\n-                self.prohibit_projection(binding.span);\n-                break;\n-            }\n+            segment.with_parameters(|parameters| {\n+                for typ in &parameters.types {\n+                    struct_span_err!(self.tcx().sess, typ.span, E0109,\n+                                     \"type parameters are not allowed on this type\")\n+                        .span_label(typ.span, \"type parameter not allowed\")\n+                        .emit();\n+                    break;\n+                }\n+                for lifetime in &parameters.lifetimes {\n+                    struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n+                                     \"lifetime parameters are not allowed on this type\")\n+                        .span_label(lifetime.span,\n+                                    \"lifetime parameter not allowed on this type\")\n+                        .emit();\n+                    break;\n+                }\n+                for binding in &parameters.bindings {\n+                    self.prohibit_projection(binding.span);\n+                    break;\n+                }\n+            })\n         }\n     }\n \n@@ -975,6 +988,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             Def::Err => {\n+                for segment in &path.segments {\n+                    segment.with_parameters(|parameters| {\n+                        for ty in &parameters.types {\n+                            self.ast_ty_to_ty(ty);\n+                        }\n+                        for binding in &parameters.bindings {\n+                            self.ast_ty_to_ty(&binding.ty);\n+                        }\n+                    });\n+                }\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n             }\n@@ -1115,6 +1138,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n+        self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty\n     }\n \n@@ -1124,8 +1148,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n-            hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(ty.span),\n+            hir::TyInfer if expected_ty.is_some() => {\n+                self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n+                expected_ty.unwrap()\n+            }\n             _ => self.ast_ty_to_ty(ty),\n         }\n     }\n@@ -1214,19 +1240,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n \n-        let is_infer = match decl.output {\n-            hir::Return(ref output) if output.node == hir::TyInfer => true,\n-            hir::DefaultReturn(..) => true,\n-            _ => false\n-        };\n-\n         let output_ty = match decl.output {\n-            _ if is_infer && expected_ret_ty.is_some() =>\n-                expected_ret_ty.unwrap(),\n-            _ if is_infer => self.ty_infer(decl.output.span()),\n-            hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&output),\n-            hir::DefaultReturn(..) => bug!(),\n+            hir::Return(ref output) => {\n+                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n+                    self.record_ty(output.hir_id, expected_ret_ty, output.span);\n+                    expected_ret_ty\n+                } else {\n+                    self.ast_ty_to_ty(&output)\n+                }\n+            }\n+            hir::DefaultReturn(span) => {\n+                if let Some(expected_ret_ty) = expected_ret_ty {\n+                    expected_ret_ty\n+                } else {\n+                    self.ty_infer(span)\n+                }\n+            }\n         };\n \n         debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n@@ -1298,15 +1327,16 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 if Some(trait_did) == tcx.lang_items().send_trait() ||\n                     Some(trait_did) == tcx.lang_items().sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n-                    let parameters = &segments[segments.len() - 1].parameters;\n-                    if !parameters.types.is_empty() {\n-                        check_type_argument_count(tcx, bound.trait_ref.path.span,\n-                                                  parameters.types.len(), &[]);\n-                    }\n-                    if !parameters.lifetimes.is_empty() {\n-                        report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n-                                                     parameters.lifetimes.len(), 0);\n-                    }\n+                    segments[segments.len() - 1].with_parameters(|parameters| {\n+                        if !parameters.types.is_empty() {\n+                            check_type_argument_count(tcx, bound.trait_ref.path.span,\n+                                                      parameters.types.len(), &[]);\n+                        }\n+                        if !parameters.lifetimes.is_empty() {\n+                            report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n+                                                         parameters.lifetimes.len(), 0);\n+                        }\n+                    });\n                     true\n                 } else {\n                     false"}, {"sha": "d942b2d123070da587408d319dc6d1211f928371", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -787,11 +787,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for field in variant.fields\n                 .iter()\n                 .filter(|field| !used_fields.contains_key(&field.name)) {\n-                struct_span_err!(tcx.sess, span, E0027,\n-                                \"pattern does not mention field `{}`\",\n-                                field.name)\n-                                .span_label(span, format!(\"missing field `{}`\", field.name))\n-                                .emit();\n+                let mut diag = struct_span_err!(tcx.sess, span, E0027,\n+                                                \"pattern does not mention field `{}`\",\n+                                                field.name);\n+                diag.span_label(span, format!(\"missing field `{}`\", field.name));\n+                if variant.ctor_kind == CtorKind::Fn {\n+                    diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n+                }\n+                diag.emit();\n             }\n         }\n     }"}, {"sha": "94422f93e5922fd7dd09308120aa397a94cd1bc7", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -187,7 +187,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         // Consider coercing the subtype to a DST\n-        let unsize = self.coerce_unsized(a, b);\n+        //\n+        // NOTE: this is wrapped in a `commit_if_ok` because it creates\n+        // a \"spurious\" type variable, and we don't want to have that\n+        // type variable in memory if the coercion fails.\n+        let unsize = self.commit_if_ok(|_| self.coerce_unsized(a, b));\n         if unsize.is_ok() {\n             debug!(\"coerce: unsize successful\");\n             return unsize;"}, {"sha": "7110a1ba81d8f4888891ca60ef464136e54e662c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -261,6 +261,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None\n             }\n+            (_, &ty::TyRef(_, checked)) => {\n+                // We have `&T`, check if what was expected was `T`. If so,\n+                // we may want to suggest adding a `*`, or removing\n+                // a `&`.\n+                //\n+                // (But, also check check the `expn_info()` to see if this is\n+                // a macro; if so, it's hard to extract the text and make a good\n+                // suggestion, so don't bother.)\n+                if self.infcx.can_sub(self.param_env, checked.ty, &expected).is_ok() &&\n+                   expr.span.ctxt().outer().expn_info().is_none() {\n+                    match expr.node {\n+                        // Maybe remove `&`?\n+                        hir::ExprAddrOf(_, ref expr) => {\n+                            if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                                return Some(format!(\"try with `{}`\", code));\n+                            }\n+                        }\n+\n+                        // Maybe add `*`? Only if `T: Copy`.\n+                        _ => {\n+                            if !self.infcx.type_moves_by_default(self.param_env,\n+                                                                checked.ty,\n+                                                                expr.span) {\n+                                let sp = self.sess().codemap().call_span_if_macro(expr.span);\n+                                if let Ok(code) = self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                    return Some(format!(\"try with `*{}`\", code));\n+                                }\n+                            }\n+                        },\n+                    }\n+                }\n+                None\n+            }\n             _ => None,\n         }\n     }"}, {"sha": "a9830dd5ddece3db97fb08d32a5a8687cfb87266", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             if i < parent_substs.len() {\n                 parent_substs.region_at(i)\n             } else if let Some(lifetime)\n-                    = provided.lifetimes.get(i - parent_substs.len()) {\n+                    = provided.as_ref().and_then(|p| p.lifetimes.get(i - parent_substs.len())) {\n                 AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n             } else {\n                 self.region_var_for_def(self.span, def)\n@@ -310,7 +310,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             if i < parent_substs.len() {\n                 parent_substs.type_at(i)\n             } else if let Some(ast_ty)\n-                    = provided.types.get(i - parent_substs.len() - method_generics.regions.len()) {\n+                = provided.as_ref().and_then(|p| {\n+                    p.types.get(i - parent_substs.len() - method_generics.regions.len())\n+                })\n+            {\n                 self.to_ty(ast_ty)\n             } else {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "4ee0b4cb46f1b87df51343cd7b2e5414d5d515e0", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -70,19 +70,22 @@ pub struct NoMatchData<'tcx> {\n     pub static_candidates: Vec<CandidateSource>,\n     pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n     pub out_of_scope_traits: Vec<DefId>,\n+    pub lev_candidate: Option<ty::AssociatedItem>,\n     pub mode: probe::Mode,\n }\n \n impl<'tcx> NoMatchData<'tcx> {\n     pub fn new(static_candidates: Vec<CandidateSource>,\n                unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n                out_of_scope_traits: Vec<DefId>,\n+               lev_candidate: Option<ty::AssociatedItem>,\n                mode: probe::Mode)\n                -> Self {\n         NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n+            lev_candidate,\n             mode,\n         }\n     }"}, {"sha": "a3b196f99d629ba7ed01368da62ea73f319f37e3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 76, "deletions": 10, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -23,11 +23,13 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n use syntax::ast;\n+use syntax::util::lev_distance::{lev_distance, find_best_match_for_name};\n use syntax_pos::Span;\n use rustc::hir;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::cmp::max;\n \n use self::CandidateKind::*;\n pub use self::PickKind::*;\n@@ -51,6 +53,10 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n \n+    /// When probing for names, include names that are close to the\n+    /// requested name (by Levensthein distance)\n+    allow_similar_names: bool,\n+\n     /// Some(candidate) if there is a private candidate\n     private_candidate: Option<Def>,\n \n@@ -242,6 +248,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n                                                                      Vec::new(),\n                                                                      Vec::new(),\n+                                                                     None,\n                                                                      mode)))\n                 }\n             }\n@@ -261,7 +268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, method_name, return_type, steps);\n+                ProbeContext::new(self, span, mode, method_name, return_type, Rc::new(steps));\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -333,7 +340,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n            mode: Mode,\n            method_name: Option<ast::Name>,\n            return_type: Option<Ty<'tcx>>,\n-           steps: Vec<CandidateStep<'tcx>>)\n+           steps: Rc<Vec<CandidateStep<'tcx>>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n@@ -344,8 +351,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n-            steps: Rc::new(steps),\n+            steps: steps,\n             static_candidates: Vec::new(),\n+            allow_similar_names: false,\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n         }\n@@ -798,10 +806,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         if let Some(def) = private_candidate {\n             return Err(MethodError::PrivateMatch(def, out_of_scope_traits));\n         }\n+        let lev_candidate = self.probe_for_lev_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates,\n                                                   unsatisfied_predicates,\n                                                   out_of_scope_traits,\n+                                                  lev_candidate,\n                                                   self.mode)))\n     }\n \n@@ -913,11 +923,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n-                Some(pick) => {\n-                    return Some(Ok(pick));\n-                }\n-                None => {}\n+            if let Some(pick) = self.collapse_candidates_to_trait_pick(&applicable_candidates[..]) {\n+                return Some(Ok(pick));\n             }\n         }\n \n@@ -1126,6 +1133,54 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n+    /// candidate method where the method name may have been misspelt. Similarly to other\n+    /// Levenshtein based suggestions, we provide at most one such suggestion.\n+    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssociatedItem>, MethodError<'tcx>> {\n+        debug!(\"Probing for method names similar to {:?}\",\n+               self.method_name);\n+\n+        let steps = self.steps.clone();\n+        self.probe(|_| {\n+            let mut pcx = ProbeContext::new(self.fcx, self.span, self.mode, self.method_name,\n+                                            self.return_type, steps);\n+            pcx.allow_similar_names = true;\n+            pcx.assemble_inherent_candidates();\n+            pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;\n+\n+            let method_names = pcx.candidate_method_names();\n+            pcx.allow_similar_names = false;\n+            let applicable_close_candidates: Vec<ty::AssociatedItem> = method_names\n+                .iter()\n+                .filter_map(|&method_name| {\n+                    pcx.reset();\n+                    pcx.method_name = Some(method_name);\n+                    pcx.assemble_inherent_candidates();\n+                    pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)\n+                        .ok().map_or(None, |_| {\n+                            pcx.pick_core()\n+                                .and_then(|pick| pick.ok())\n+                                .and_then(|pick| Some(pick.item))\n+                        })\n+                })\n+               .collect();\n+\n+            if applicable_close_candidates.is_empty() {\n+                Ok(None)\n+            } else {\n+                let best_name = {\n+                    let names = applicable_close_candidates.iter().map(|cand| &cand.name);\n+                    find_best_match_for_name(names,\n+                                             &self.method_name.unwrap().as_str(),\n+                                             None)\n+                }.unwrap();\n+                Ok(applicable_close_candidates\n+                   .into_iter()\n+                   .find(|method| method.name == best_name))\n+            }\n+        })\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n     fn has_applicable_self(&self, item: &ty::AssociatedItem) -> bool {\n@@ -1253,10 +1308,21 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.tcx.erase_late_bound_regions(value)\n     }\n \n-    /// Find the method with the appropriate name (or return type, as the case may be).\n+    /// Find the method with the appropriate name (or return type, as the case may be). If\n+    /// `allow_similar_names` is set, find methods with close-matching names.\n     fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n         if let Some(name) = self.method_name {\n-            self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            if self.allow_similar_names {\n+                let max_dist = max(name.as_str().len(), 3) / 3;\n+                self.tcx.associated_items(def_id)\n+                    .filter(|x| {\n+                        let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n+                        dist > 0 && dist <= max_dist\n+                    })\n+                    .collect()\n+            } else {\n+                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+            }\n         } else {\n             self.tcx.associated_items(def_id).collect()\n         }"}, {"sha": "90c5297b399859cdd140381552c0b98d05cb0650", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -164,6 +164,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                                unsatisfied_predicates,\n                                                out_of_scope_traits,\n+                                               lev_candidate,\n                                                mode,\n                                                .. }) => {\n                 let tcx = self.tcx;\n@@ -282,6 +283,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               item_name,\n                                               rcvr_expr,\n                                               out_of_scope_traits);\n+\n+                if let Some(lev_candidate) = lev_candidate {\n+                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.name));\n+                }\n                 err.emit();\n             }\n "}, {"sha": "a0099a48c896bc73bf28b6962bff527239bc61f1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1665,6 +1665,10 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn set_tainted_by_errors(&self) {\n         self.infcx.set_tainted_by_errors()\n     }\n+\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n+        self.write_ty(hir_id, ty)\n+    }\n }\n \n /// Controls whether the arguments are tupled. This is used for the call\n@@ -2232,7 +2236,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                adjusted_ty,\n                index_ty);\n \n-\n         // First, try built-in indexing.\n         match (adjusted_ty.builtin_index(), &index_ty.sty) {\n             (Some(ty), &ty::TyUint(ast::UintTy::Us)) | (Some(ty), &ty::TyInfer(ty::IntVar(_))) => {\n@@ -4644,6 +4647,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // a problem.\n         self.check_path_parameter_count(span, &mut type_segment, false);\n         self.check_path_parameter_count(span, &mut fn_segment, false);\n+        self.check_impl_trait(span, &mut fn_segment);\n \n         let (fn_start, has_self) = match (type_segment, fn_segment) {\n             (_, Some((_, generics))) => {\n@@ -4664,7 +4668,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let lifetimes = segment.map_or(&[][..], |(s, _)| &s.parameters.lifetimes[..]);\n+            let lifetimes = segment.map_or(&[][..], |(s, _)| {\n+                s.parameters.as_ref().map_or(&[][..], |p| &p.lifetimes[..])\n+            });\n \n             if let Some(lifetime) = lifetimes.get(i) {\n                 AstConv::ast_region_to_region(self, lifetime, Some(def))\n@@ -4688,7 +4694,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 fn_segment\n             };\n             let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n-                (&s.parameters.types[..], s.parameters.infer_types)\n+                (s.parameters.as_ref().map_or(&[][..], |p| &p.types[..]), s.infer_types)\n             });\n \n             // Skip over the lifetimes in the same segment.\n@@ -4765,8 +4771,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   is_method_call: bool) {\n         let (lifetimes, types, infer_types, bindings) = segment.map_or(\n             (&[][..], &[][..], true, &[][..]),\n-            |(s, _)| (&s.parameters.lifetimes[..], &s.parameters.types[..],\n-                      s.parameters.infer_types, &s.parameters.bindings[..]));\n+            |(s, _)| s.parameters.as_ref().map_or(\n+                (&[][..], &[][..], s.infer_types, &[][..]),\n+                |p| (&p.lifetimes[..], &p.types[..],\n+                     s.infer_types, &p.bindings[..])));\n         let infer_lifetimes = lifetimes.len() == 0;\n \n         let count_lifetime_params = |n| {\n@@ -4864,6 +4872,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Report error if there is an explicit type parameter when using `impl Trait`.\n+    fn check_impl_trait(&self,\n+                        span: Span,\n+                        segment: &mut Option<(&hir::PathSegment, &ty::Generics)>) {\n+        use hir::SyntheticTyParamKind::*;\n+\n+        segment.map(|(path_segment, generics)| {\n+            let explicit = !path_segment.infer_types;\n+            let impl_trait = generics.types.iter()\n+                                           .any(|ty_param| {\n+                                               match ty_param.synthetic {\n+                                                   Some(ImplTrait) => true,\n+                                                   _ => false,\n+                                               }\n+                                           });\n+\n+            if explicit && impl_trait {\n+                let mut err = struct_span_err! {\n+                    self.tcx.sess,\n+                    span,\n+                    E0632,\n+                    \"cannot provide explicit type parameters when `impl Trait` is \\\n+                    used in argument position.\"\n+                };\n+\n+                err.emit();\n+            }\n+        });\n+    }\n+\n     fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)\n                                             -> Ty<'tcx>\n         where F: Fn() -> Ty<'tcx>"}, {"sha": "ddbdd204305890f9e3dfffe463aab47d92583577", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n             let (span, name) = if index < ast_generics.lifetimes.len() {\n                 (ast_generics.lifetimes[index].lifetime.span,\n-                 ast_generics.lifetimes[index].lifetime.name)\n+                 ast_generics.lifetimes[index].lifetime.name.name())\n             } else {\n                 let index = index - ast_generics.lifetimes.len();\n                 (ast_generics.ty_params[index].span,"}, {"sha": "3c650718a4bfd72e4709afd1053a90ff14c5c171", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -207,6 +207,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n+\n+    fn visit_ty(&mut self, hir_ty: &'gcx hir::Ty) {\n+        intravisit::walk_ty(self, hir_ty);\n+        let ty = self.fcx.node_ty(hir_ty.hir_id);\n+        let ty = self.resolve(&ty, &hir_ty.span);\n+        self.write_ty_to_tables(hir_ty.hir_id, ty);\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "25a37a2c48cdbc99dd50262df65b75ac22fce665", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -221,6 +221,10 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     fn set_tainted_by_errors(&self) {\n         // no obvious place to track this, just let it go\n     }\n+\n+    fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n+        // no place to record types from signatures?\n+    }\n }\n \n fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -918,6 +922,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         has_default: false,\n                         object_lifetime_default: rl::Set1::Empty,\n                         pure_wrt_drop: false,\n+                        synthetic: None,\n                     });\n \n                     allow_defaults = true;\n@@ -953,7 +958,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     let regions = early_lifetimes.enumerate().map(|(i, l)| {\n         ty::RegionParameterDef {\n-            name: l.lifetime.name,\n+            name: l.lifetime.name.name(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n@@ -989,6 +994,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             object_lifetime_default:\n                 object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n             pure_wrt_drop: p.pure_wrt_drop,\n+            synthetic: p.synthetic,\n         }\n     });\n     let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n@@ -1005,6 +1011,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 has_default: false,\n                 object_lifetime_default: rl::Set1::Empty,\n                 pure_wrt_drop: false,\n+                synthetic: None,\n             }));\n         });\n     }\n@@ -1325,6 +1332,12 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            def_id: DefId)\n                            -> ty::GenericPredicates<'tcx> {\n+    explicit_predicates_of(tcx, def_id)\n+}\n+\n+fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           def_id: DefId)\n+                           -> ty::GenericPredicates<'tcx> {\n     use rustc::hir::map::*;\n     use rustc::hir::*;\n \n@@ -1423,7 +1436,7 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir.local_def_id(param.lifetime.id),\n             index,\n-            name: param.lifetime.name\n+            name: param.lifetime.name.name(),\n         }));\n         index += 1;\n "}, {"sha": "8df973555744b31f8cc9e81a75fa4cc628d002cf", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -4677,4 +4677,6 @@ register_diagnostics! {\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n     E0627, // yield statement outside of generator literal\n+    E0632, // cannot provide explicit type parameters when `impl Trait` is used in\n+           // argument position.\n }"}, {"sha": "15708ab766ae82956b38e16ccd41dc80b1983a1c", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -132,7 +132,7 @@ fn enforce_impl_params_are_constrained<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             !input_parameters.contains(&param)\n         {\n             report_unused_parameter(tcx, lifetime.lifetime.span,\n-                                    \"lifetime\", &lifetime.lifetime.name.to_string());\n+                                    \"lifetime\", &lifetime.lifetime.name.name().to_string());\n         }\n     }\n "}, {"sha": "b295b414a035b1be6de36a55363f8cfc397debe0", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,4 +18,4 @@ html-diff = \"0.0.4\"\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\"\n+cc = \"1.0\""}, {"sha": "97c9ca1e2d27c816e3bf58ceee6deffb9a89d87e", "filename": "src/librustdoc/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n extern crate build_helper;\n-extern crate gcc;\n+extern crate cc;\n \n fn main() {\n     let src_dir = std::path::Path::new(\"../rt/hoedown/src\");\n     build_helper::rerun_if_changed_anything_in_dir(src_dir);\n-    let mut cfg = gcc::Build::new();\n+    let mut cfg = cc::Build::new();\n     cfg.file(\"../rt/hoedown/src/autolink.c\")\n        .file(\"../rt/hoedown/src/buffer.c\")\n        .file(\"../rt/hoedown/src/document.c\")"}, {"sha": "c9afa3646b2da0ff260fafb2cc7bd84d22d5357f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -876,22 +876,22 @@ impl Clean<Lifetime> for hir::Lifetime {\n             }\n             _ => {}\n         }\n-        Lifetime(self.name.to_string())\n+        Lifetime(self.name.name().to_string())\n     }\n }\n \n impl Clean<Lifetime> for hir::LifetimeDef {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n         if self.bounds.len() > 0 {\n             let mut s = format!(\"{}: {}\",\n-                                self.lifetime.name.to_string(),\n-                                self.bounds[0].name.to_string());\n+                                self.lifetime.name.name(),\n+                                self.bounds[0].name.name());\n             for bound in self.bounds.iter().skip(1) {\n-                s.push_str(&format!(\" + {}\", bound.name.to_string()));\n+                s.push_str(&format!(\" + {}\", bound.name.name()));\n             }\n             Lifetime(s)\n         } else {\n-            Lifetime(self.lifetime.name.to_string())\n+            Lifetime(self.lifetime.name.name().to_string())\n         }\n     }\n }\n@@ -1852,25 +1852,27 @@ impl Clean<Type> for hir::Ty {\n                 };\n \n                 if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().unwrap().parameters;\n+                    let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n-                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                        if let Some(ty) = provided_params.types.get(i).cloned() {\n-                            ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n-                        } else if let Some(default) = ty_param.default.clone() {\n-                            ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                    provided_params.with_parameters(|provided_params| {\n+                        for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                            let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n+                            if let Some(ty) = provided_params.types.get(i).cloned() {\n+                                ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n+                            } else if let Some(default) = ty_param.default.clone() {\n+                                ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                            }\n                         }\n-                    }\n-                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                        if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n-                            if !lt.is_elided() {\n-                                let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n-                                lt_substs.insert(lt_def_id, lt.clean(cx));\n+                        for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                            if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n+                                if !lt.is_elided() {\n+                                    let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                    lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                }\n                             }\n                         }\n-                    }\n+                    });\n                     return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n@@ -2419,7 +2421,7 @@ impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n             name: self.name.clean(cx),\n-            params: self.parameters.clean(cx)\n+            params: self.with_parameters(|parameters| parameters.clean(cx))\n         }\n     }\n }"}, {"sha": "2ecb7b546fce2d5ba39a173023aeb8014154c01b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -175,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n     let output_filenames = driver::build_output_filenames(&input,\n                                                           &None,\n                                                           &None,\n@@ -191,7 +191,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      &arenas,\n                                                      &name,\n                                                      &output_filenames,\n-                                                     |tcx, analysis, _, _, result| {\n+                                                     |tcx, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "98863b229b51100d73e86410cfe6f637fc4415c3", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -249,8 +249,8 @@ impl<'a> Classifier<'a> {\n                 token::BinOpEq(..) | token::FatArrow => Class::Op,\n \n             // Miscellaneous, no highlighting.\n-            token::Dot | token::DotDot | token::DotDotDot | token::Comma | token::Semi |\n-                token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n+            token::Dot | token::DotDot | token::DotDotDot | token::DotDotEq | token::Comma |\n+                token::Semi | token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n                 token::CloseDelim(token::Brace) | token::CloseDelim(token::Paren) |\n                 token::CloseDelim(token::NoDelim) => Class::None,\n \n@@ -353,7 +353,7 @@ impl<'a> Classifier<'a> {\n             token::Lifetime(..) => Class::Lifetime,\n \n             token::Underscore | token::Eof | token::Interpolated(..) |\n-            token::Tilde | token::At => Class::None,\n+            token::Tilde | token::At | token::DotEq => Class::None,\n         };\n \n         // Anything that didn't return above is the simple case where we the"}, {"sha": "485e75443fe0851003358eb82f5c7d8908a8f985", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -2621,7 +2621,8 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                 href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n-        let mut head_len = format!(\"{}{}{:#}fn {}{:#}\",\n+        let mut head_len = format!(\"{}{}{}{:#}fn {}{:#}\",\n+                                   VisSpace(&meth.visibility),\n                                    ConstnessSpace(constness),\n                                    UnsafetySpace(unsafety),\n                                    AbiSpace(abi),\n@@ -2633,8 +2634,9 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n         } else {\n             (0, true)\n         };\n-        write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n+        write!(w, \"{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n+               VisSpace(&meth.visibility),\n                ConstnessSpace(constness),\n                UnsafetySpace(unsafety),\n                AbiSpace(abi),"}, {"sha": "1b7232bf1bca861e8c46f26ecd84e97564cd23e6", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -823,7 +823,7 @@ span.since {\n \n .information {\n \tposition: absolute;\n-\tleft: -1px;\n+\tleft: -20px;\n \tmargin-top: 7px;\n \tz-index: 1;\n }"}, {"sha": "7fa1b38bdadfac344b25fe39649ed193da2c57f3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -124,7 +124,7 @@ pub fn run(input: &str,\n                                        render_type);\n \n     {\n-        let map = hir::map::map_crate(&mut hir_forest, &defs);\n+        let map = hir::map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,\n@@ -348,7 +348,21 @@ pub fn make_test(s: &str,\n             }\n         }\n     }\n-    if dont_insert_main || s.contains(\"fn main\") {\n+\n+    // FIXME (#21299): prefer libsyntax or some other actual parser over this\n+    // best-effort ad hoc approach\n+    let already_has_main = s.lines()\n+        .map(|line| {\n+            let comment = line.find(\"//\");\n+            if let Some(comment_begins) = comment {\n+                &line[0..comment_begins]\n+            } else {\n+                line\n+            }\n+        })\n+        .any(|code| code.contains(\"fn main\"));\n+\n+    if dont_insert_main || already_has_main {\n         prog.push_str(&everything_else);\n     } else {\n         prog.push_str(\"fn main() {\\n\");"}, {"sha": "fb276448ffac4d126c10f9c55e3802e411868aa2", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -36,7 +36,7 @@ rustc_tsan = { path = \"../librustc_tsan\" }\n \n [build-dependencies]\n build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\"\n+cc = \"1.0\"\n \n [features]\n backtrace = []"}, {"sha": "7ca762c801a814a0e5186f2be6171a565d82c60e", "filename": "src/libstd/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,7 +11,7 @@\n #![deny(warnings)]\n \n extern crate build_helper;\n-extern crate gcc;\n+extern crate cc;\n \n use std::env;\n use std::process::Command;\n@@ -68,16 +68,16 @@ fn main() {\n         if cfg!(feature = \"backtrace\") {\n             println!(\"cargo:rustc-link-lib=backtrace\");\n         }\n-        println!(\"cargo:rustc-link-lib=magenta\");\n-        println!(\"cargo:rustc-link-lib=mxio\");\n+        println!(\"cargo:rustc-link-lib=zircon\");\n+        println!(\"cargo:rustc-link-lib=fdio\");\n         println!(\"cargo:rustc-link-lib=launchpad\"); // for std::process\n     }\n }\n \n fn build_libbacktrace(host: &str, target: &str) -> Result<(), ()> {\n     let native = native_lib_boilerplate(\"libbacktrace\", \"libbacktrace\", \"backtrace\", \".libs\")?;\n \n-    let compiler = gcc::Build::new().get_compiler();\n+    let compiler = cc::Build::new().get_compiler();\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), target).unwrap();\n     let mut cflags = compiler.args().iter().map(|s| s.to_str().unwrap())"}, {"sha": "7d000d7c859d395bd0a9085d9cfc2e8537390b8f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -691,6 +691,17 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Returns a reference to the map's [`BuildHasher`].\n     ///\n     /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let hasher = RandomState::new();\n+    /// let map: HashMap<isize, isize> = HashMap::with_hasher(hasher);\n+    /// let hasher: &RandomState = map.hasher();\n+    /// ```\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         &self.hash_builder\n@@ -2191,6 +2202,36 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     fn take_key(&mut self) -> Option<K> {\n         self.key.take()\n     }\n+\n+    /// Replaces the entry, returning the old key and value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_replace)]\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<String, u32> = HashMap::new();\n+    /// map.insert(\"poneyland\".to_string(), 15);\n+    ///\n+    /// if let Entry::Occupied(entry) = map.entry(\"poneyland\".to_string()) {\n+    ///     let (old_key, old_value): (String, u32) = entry.replace(16);\n+    ///     assert_eq!(old_key, \"poneyland\");\n+    ///     assert_eq!(old_value, 15);\n+    /// }\n+    ///\n+    /// assert_eq!(map.get(\"poneyland\"), Some(&16));\n+    /// ```\n+    #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n+    pub fn replace(mut self, value: V) -> (K, V) {\n+        let (old_key, old_value) = self.elem.read_mut();\n+\n+        let old_key = mem::replace(old_key, self.key.unwrap());\n+        let old_value = mem::replace(old_value, value);\n+\n+        (old_key, old_value)\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {"}, {"sha": "231b0be927612160bd16a6e57e0f36e7442e599d", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -56,6 +56,7 @@ use any::TypeId;\n use borrow::Cow;\n use cell;\n use char;\n+use convert;\n use core::array;\n use fmt::{self, Debug, Display};\n use mem::transmute;\n@@ -370,6 +371,13 @@ impl Error for char::ParseCharError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl Error for convert::Infallible {\n+    fn description(&self) -> &str {\n+        match *self {\n+        }\n+    }\n+}\n \n // copied from any.rs\n impl Error + 'static {"}, {"sha": "91600b01298a44ec724981216c2260134abfca4c", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1595,9 +1595,9 @@ pub fn create_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n ///\n /// Notable exception is made for situations where any of the directories\n /// specified in the `path` could not be created as it was being created concurrently.\n-/// Such cases are considered success. In other words: calling `create_dir_all`\n-/// concurrently from multiple threads or processes is guaranteed to not fail\n-/// due to race itself.\n+/// Such cases are considered to be successful. That is, calling `create_dir_all`\n+/// concurrently from multiple threads or processes is guaranteed not to fail\n+/// due to a race condition with itself.\n ///\n /// # Examples\n ///\n@@ -2160,6 +2160,27 @@ mod tests {\n         check!(fs::remove_file(&filename));\n     }\n \n+    #[test]\n+    #[cfg(unix)]\n+    fn set_get_unix_permissions() {\n+        use os::unix::fs::PermissionsExt;\n+\n+        let tmpdir = tmpdir();\n+        let filename = &tmpdir.join(\"set_get_unix_permissions\");\n+        check!(fs::create_dir(filename));\n+        let mask = 0o7777;\n+\n+        check!(fs::set_permissions(filename,\n+                                   fs::Permissions::from_mode(0)));\n+        let metadata0 = check!(fs::metadata(filename));\n+        assert_eq!(mask & metadata0.permissions().mode(), 0);\n+\n+        check!(fs::set_permissions(filename,\n+                                   fs::Permissions::from_mode(0o1777)));\n+        let metadata1 = check!(fs::metadata(filename));\n+        assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n+    }\n+\n     #[test]\n     #[cfg(windows)]\n     fn file_test_io_seek_read_write() {"}, {"sha": "45d281ee34acdb619ad38d1ff15ccc5f9378484f", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -40,9 +40,10 @@ use mem;\n ///\n /// io::copy(&mut reader, &mut writer)?;\n ///\n-/// assert_eq!(reader, &writer[..]);\n+/// assert_eq!(&b\"hello\"[..], &writer[..]);\n /// # Ok(())\n /// # }\n+/// # foo().unwrap();\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>"}, {"sha": "8d1e7882e5db4de4c9f0c1c252b7918037ef1ecb", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -167,7 +167,7 @@ impl TcpStream {\n     /// connection request.\n     ///\n     /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n-    #[stable(feature = \"tcpstream_connect_timeout\", since = \"1.22.0\")]\n+    #[stable(feature = \"tcpstream_connect_timeout\", since = \"1.21.0\")]\n     pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n         net_imp::TcpStream::connect_timeout(addr, timeout).map(TcpStream)\n     }"}, {"sha": "1edb35d8fe74120fee2f05fc346bb23a0174ebdd", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -710,6 +710,10 @@ mod prim_u128 { }\n //\n /// The pointer-sized signed integer type.\n ///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+///\n /// *[See also the `std::isize` module](isize/index.html).*\n ///\n /// However, please note that examples are shared between primitive integer\n@@ -722,6 +726,10 @@ mod prim_isize { }\n //\n /// The pointer-sized unsigned integer type.\n ///\n+/// The size of this primitive is how many bytes it takes to reference any\n+/// location in memory. For example, on a 32 bit target, this is 4 bytes\n+/// and on a 64 bit target, this is 8 bytes.\n+///\n /// *[See also the `std::usize` module](usize/index.html).*\n ///\n /// However, please note that examples are shared between primitive integer"}, {"sha": "1869ad3ed707a088260c6bdf80ce7e45431d6a82", "filename": "src/libstd/process.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -106,15 +106,18 @@ use sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n pub struct Child {\n     handle: imp::Process,\n \n-    /// The handle for writing to the child's stdin, if it has been captured\n+    /// The handle for writing to the child's standard input (stdin), if it has\n+    /// been captured.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdin: Option<ChildStdin>,\n \n-    /// The handle for reading from the child's stdout, if it has been captured\n+    /// The handle for reading from the child's standard output (stdout), if it\n+    /// has been captured.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stdout: Option<ChildStdout>,\n \n-    /// The handle for reading from the child's stderr, if it has been captured\n+    /// The handle for reading from the child's standard error (stderr), if it\n+    /// has been captured.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub stderr: Option<ChildStderr>,\n }\n@@ -149,12 +152,17 @@ impl fmt::Debug for Child {\n     }\n }\n \n-/// A handle to a child process's stdin.\n+/// A handle to a child process's standard input (stdin).\n ///\n /// This struct is used in the [`stdin`] field on [`Child`].\n ///\n+/// When an instance of `ChildStdin` is [dropped], the `ChildStdin`'s underlying\n+/// file handle will be closed. If the child process was blocked on input prior\n+/// to being dropped, it will become unblocked after dropping.\n+///\n /// [`Child`]: struct.Child.html\n /// [`stdin`]: struct.Child.html#structfield.stdin\n+/// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe\n@@ -192,12 +200,16 @@ impl fmt::Debug for ChildStdin {\n     }\n }\n \n-/// A handle to a child process's stdout.\n+/// A handle to a child process's standard output (stdout).\n ///\n /// This struct is used in the [`stdout`] field on [`Child`].\n ///\n+/// When an instance of `ChildStdout` is [dropped], the `ChildStdout`'s\n+/// underlying file handle will be closed.\n+///\n /// [`Child`]: struct.Child.html\n /// [`stdout`]: struct.Child.html#structfield.stdout\n+/// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdout {\n     inner: AnonPipe\n@@ -239,8 +251,12 @@ impl fmt::Debug for ChildStdout {\n ///\n /// This struct is used in the [`stderr`] field on [`Child`].\n ///\n+/// When an instance of `ChildStderr` is [dropped], the `ChildStderr`'s\n+/// underlying file handle will be closed.\n+///\n /// [`Child`]: struct.Child.html\n /// [`stderr`]: struct.Child.html#structfield.stderr\n+/// [dropped]: ../ops/trait.Drop.html\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStderr {\n     inner: AnonPipe\n@@ -534,7 +550,7 @@ impl Command {\n         self\n     }\n \n-    /// Configuration for the child process's stdin handle (file descriptor 0).\n+    /// Configuration for the child process's standard input (stdin) handle.\n     ///\n     /// # Examples\n     ///\n@@ -554,7 +570,7 @@ impl Command {\n         self\n     }\n \n-    /// Configuration for the child process's stdout handle (file descriptor 1).\n+    /// Configuration for the child process's standard output (stdout) handle.\n     ///\n     /// # Examples\n     ///\n@@ -574,7 +590,7 @@ impl Command {\n         self\n     }\n \n-    /// Configuration for the child process's stderr handle (file descriptor 2).\n+    /// Configuration for the child process's standard error (stderr) handle.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4757faabfb873aee9118656509e8f3734c296478", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 120, "deletions": 13, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -24,19 +24,24 @@ use sys_common::rwlock as sys;\n /// of the underlying data (exclusive access) and the read portion of this lock\n /// typically allows for read-only access (shared access).\n ///\n+/// In comparison, a [`Mutex`] does not distinguish between readers or writers\n+/// that aquire the lock, therefore blocking any threads waiting for the lock to\n+/// become available. An `RwLock` will allow any number of readers to aquire the\n+/// lock as long as a writer is not holding the lock.\n+///\n /// The priority policy of the lock is dependent on the underlying operating\n /// system's implementation, and this type does not guarantee that any\n /// particular policy will be used.\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n-/// allow concurrent access through readers. The RAII guards returned from the\n-/// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n-/// to allow access to the contained of the lock.\n+/// required that `T` satisfies [`Send`] to be shared across threads and\n+/// [`Sync`] to allow concurrent access through readers. The RAII guards\n+/// returned from the locking methods implement [`Deref`][] (and [`DerefMut`]\n+/// for the `write` methods) to allow access to the contained of the lock.\n ///\n /// # Poisoning\n ///\n-/// An `RwLock`, like `Mutex`, will become poisoned on a panic. Note, however,\n+/// An `RwLock`, like [`Mutex`], will become poisoned on a panic. Note, however,\n /// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n@@ -63,6 +68,12 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+///\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n+/// [`Mutex`]: struct.Mutex.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<sys::RWLock>,\n@@ -154,6 +165,24 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(1));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let r = c_lock.read();\n+    ///     assert!(r.is_ok());\n+    /// }).join().unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n@@ -180,6 +209,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// match lock.try_read() {\n+    ///     Ok(n) => assert_eq!(*n, 1),\n+    ///     Err(_) => unreachable!(),\n+    /// };\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n@@ -210,6 +252,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let mut n = lock.write().unwrap();\n+    /// *n = 2;\n+    ///\n+    /// assert!(lock.try_read().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n@@ -236,6 +291,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// assert!(lock.try_write().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n@@ -253,6 +321,22 @@ impl<T: ?Sized> RwLock<T> {\n     /// If another thread is active, the lock can still become poisoned at any\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(0));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_lock.write().unwrap();\n+    ///     panic!(); // the lock gets poisoned\n+    /// }).join();\n+    /// assert_eq!(lock.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -267,6 +351,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(String::new());\n+    /// {\n+    ///     let mut s = lock.write().unwrap();\n+    ///     *s = \"modified\".to_owned();\n+    /// }\n+    /// assert_eq!(lock.into_inner().unwrap(), \"modified\");\n+    /// ```\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -282,7 +379,7 @@ impl<T: ?Sized> RwLock<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -300,6 +397,16 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let mut lock = RwLock::new(0);\n+    /// *lock.get_mut().unwrap() = 10;\n+    /// assert_eq!(*lock.read().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n@@ -486,7 +593,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -498,7 +605,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -510,7 +617,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -521,7 +628,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -535,7 +642,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -550,7 +657,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -571,7 +678,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }"}, {"sha": "3e631ad40ac7ff2713111e29ad459e77651b6fc9", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -68,8 +68,8 @@ impl FileExt for fs::File {\n /// Unix-specific extensions to `Permissions`\n #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n pub trait PermissionsExt {\n-    /// Returns the underlying raw `mode_t` bits that are the standard Unix\n-    /// permissions for this file.\n+    /// Returns the underlying raw `st_mode` bits that contain the standard\n+    /// Unix permissions for this file.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c4616c3b395be07a8900a84fd6c9dd8b2c73bcbc", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -95,7 +95,7 @@ pub struct DirBuilder { mode: mode_t }\n impl FileAttr {\n     pub fn size(&self) -> u64 { self.stat.st_size as u64 }\n     pub fn perm(&self) -> FilePermissions {\n-        FilePermissions { mode: (self.stat.st_mode as mode_t) & 0o777 }\n+        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n     }\n \n     pub fn file_type(&self) -> FileType {"}, {"sha": "2a331069bc2c29e3378901a664ee3d80c3892467", "filename": "src/libstd/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -19,4 +19,4 @@ mod process_inner;\n #[path = \"process_fuchsia.rs\"]\n mod process_inner;\n #[cfg(target_os = \"fuchsia\")]\n-mod magenta;\n+mod zircon;"}, {"sha": "5d34da04446f1a37b95ae1597c8b3b02c103ca0d", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,7 +13,7 @@ use libc;\n use mem;\n use ptr;\n \n-use sys::process::magenta::{Handle, mx_handle_t};\n+use sys::process::zircon::{Handle, zx_handle_t};\n use sys::process::process_common::*;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -51,10 +51,10 @@ impl Command {\n     }\n \n     unsafe fn do_exec(&mut self, stdio: ChildPipes)\n-                      -> io::Result<mx_handle_t> {\n-        use sys::process::magenta::*;\n+                      -> io::Result<zx_handle_t> {\n+        use sys::process::zircon::*;\n \n-        let job_handle = mx_job_default();\n+        let job_handle = zx_job_default();\n         let envp = match *self.get_envp() {\n             Some(ref envp) => envp.as_ptr(),\n             None => ptr::null(),\n@@ -67,39 +67,39 @@ impl Command {\n         }\n \n         // Duplicate the job handle\n-        let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n-        mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS, &mut job_copy))?;\n+        let mut job_copy: zx_handle_t = ZX_HANDLE_INVALID;\n+        zx_cvt(zx_handle_duplicate(job_handle, ZX_RIGHT_SAME_RIGHTS, &mut job_copy))?;\n         // Create a launchpad\n         let mut launchpad: *mut launchpad_t = ptr::null_mut();\n-        mx_cvt(launchpad_create(job_copy, self.get_argv()[0], &mut launchpad))?;\n+        zx_cvt(launchpad_create(job_copy, self.get_argv()[0], &mut launchpad))?;\n         let launchpad_destructor = LaunchpadDestructor(launchpad);\n \n         // Set the process argv\n-        mx_cvt(launchpad_set_args(launchpad, self.get_argv().len() as i32 - 1,\n+        zx_cvt(launchpad_set_args(launchpad, self.get_argv().len() as i32 - 1,\n                                   self.get_argv().as_ptr()))?;\n         // Setup the environment vars\n-        mx_cvt(launchpad_set_environ(launchpad, envp))?;\n-        mx_cvt(launchpad_add_vdso_vmo(launchpad))?;\n+        zx_cvt(launchpad_set_environ(launchpad, envp))?;\n+        zx_cvt(launchpad_add_vdso_vmo(launchpad))?;\n         // Load the executable\n-        mx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.get_argv()[0])))?;\n-        mx_cvt(launchpad_load_vdso(launchpad, MX_HANDLE_INVALID))?;\n-        mx_cvt(launchpad_clone(launchpad, LP_CLONE_MXIO_ROOT | LP_CLONE_MXIO_CWD))?;\n+        zx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.get_argv()[0])))?;\n+        zx_cvt(launchpad_load_vdso(launchpad, ZX_HANDLE_INVALID))?;\n+        zx_cvt(launchpad_clone(launchpad, LP_CLONE_FDIO_NAMESPACE | LP_CLONE_FDIO_CWD))?;\n \n         // Clone stdin, stdout, and stderr\n         if let Some(fd) = stdio.stdin.fd() {\n-            mx_cvt(launchpad_transfer_fd(launchpad, fd, 0))?;\n+            zx_cvt(launchpad_transfer_fd(launchpad, fd, 0))?;\n         } else {\n-            mx_cvt(launchpad_clone_fd(launchpad, 0, 0))?;\n+            zx_cvt(launchpad_clone_fd(launchpad, 0, 0))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            mx_cvt(launchpad_transfer_fd(launchpad, fd, 1))?;\n+            zx_cvt(launchpad_transfer_fd(launchpad, fd, 1))?;\n         } else {\n-            mx_cvt(launchpad_clone_fd(launchpad, 1, 1))?;\n+            zx_cvt(launchpad_clone_fd(launchpad, 1, 1))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            mx_cvt(launchpad_transfer_fd(launchpad, fd, 2))?;\n+            zx_cvt(launchpad_transfer_fd(launchpad, fd, 2))?;\n         } else {\n-            mx_cvt(launchpad_clone_fd(launchpad, 2, 2))?;\n+            zx_cvt(launchpad_clone_fd(launchpad, 2, 2))?;\n         }\n \n         // We don't want FileDesc::drop to be called on any stdio. It would close their fds. The\n@@ -113,9 +113,9 @@ impl Command {\n         // `launchpad_go` destroys the launchpad, so we must not\n         mem::forget(launchpad_destructor);\n \n-        let mut process_handle: mx_handle_t = 0;\n+        let mut process_handle: zx_handle_t = 0;\n         let mut err_msg: *const libc::c_char = ptr::null();\n-        mx_cvt(launchpad_go(launchpad, &mut process_handle, &mut err_msg))?;\n+        zx_cvt(launchpad_go(launchpad, &mut process_handle, &mut err_msg))?;\n         // FIXME: See if we want to do something with that err_msg\n \n         Ok(process_handle)\n@@ -136,27 +136,27 @@ impl Process {\n     }\n \n     pub fn kill(&mut self) -> io::Result<()> {\n-        use sys::process::magenta::*;\n+        use sys::process::zircon::*;\n \n-        unsafe { mx_cvt(mx_task_kill(self.handle.raw()))?; }\n+        unsafe { zx_cvt(zx_task_kill(self.handle.raw()))?; }\n \n         Ok(())\n     }\n \n     pub fn wait(&mut self) -> io::Result<ExitStatus> {\n         use default::Default;\n-        use sys::process::magenta::*;\n+        use sys::process::zircon::*;\n \n-        let mut proc_info: mx_info_process_t = Default::default();\n-        let mut actual: mx_size_t = 0;\n-        let mut avail: mx_size_t = 0;\n+        let mut proc_info: zx_info_process_t = Default::default();\n+        let mut actual: zx_size_t = 0;\n+        let mut avail: zx_size_t = 0;\n \n         unsafe {\n-            mx_cvt(mx_object_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n-                                      MX_TIME_INFINITE, ptr::null_mut()))?;\n-            mx_cvt(mx_object_get_info(self.handle.raw(), MX_INFO_PROCESS,\n+            zx_cvt(zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n+                                      ZX_TIME_INFINITE, ptr::null_mut()))?;\n+            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n                                       &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n                                       &mut avail))?;\n         }\n         if actual != 1 {\n@@ -168,14 +168,14 @@ impl Process {\n \n     pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n         use default::Default;\n-        use sys::process::magenta::*;\n+        use sys::process::zircon::*;\n \n-        let mut proc_info: mx_info_process_t = Default::default();\n-        let mut actual: mx_size_t = 0;\n-        let mut avail: mx_size_t = 0;\n+        let mut proc_info: zx_info_process_t = Default::default();\n+        let mut actual: zx_size_t = 0;\n+        let mut avail: zx_size_t = 0;\n \n         unsafe {\n-            let status = mx_object_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n+            let status = zx_object_wait_one(self.handle.raw(), ZX_TASK_TERMINATED,\n                                             0, ptr::null_mut());\n             match status {\n                 0 => { }, // Success\n@@ -184,9 +184,9 @@ impl Process {\n                 },\n                 _ => { panic!(\"Failed to wait on process handle: {}\", status); },\n             }\n-            mx_cvt(mx_object_get_info(self.handle.raw(), MX_INFO_PROCESS,\n+            zx_cvt(zx_object_get_info(self.handle.raw(), ZX_INFO_PROCESS,\n                                       &mut proc_info as *mut _ as *mut libc::c_void,\n-                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      mem::size_of::<zx_info_process_t>(), &mut actual,\n                                       &mut avail))?;\n         }\n         if actual != 1 {"}, {"sha": "b5ec11b40fd3d0c7033e5e04f1864b3ce651f618", "filename": "src/libstd/sys/unix/process/zircon.rs", "status": "renamed", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fzircon.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -17,31 +17,31 @@ use u64;\n \n use libc::{c_int, c_void};\n \n-pub type mx_handle_t = i32;\n-pub type mx_vaddr_t = usize;\n-pub type mx_rights_t = u32;\n-pub type mx_status_t = i32;\n+pub type zx_handle_t = i32;\n+pub type zx_vaddr_t = usize;\n+pub type zx_rights_t = u32;\n+pub type zx_status_t = i32;\n \n-pub type mx_size_t = usize;\n+pub type zx_size_t = usize;\n \n-pub const MX_HANDLE_INVALID: mx_handle_t = 0;\n+pub const ZX_HANDLE_INVALID: zx_handle_t = 0;\n \n-pub type mx_time_t = u64;\n-pub const MX_TIME_INFINITE : mx_time_t = u64::MAX;\n+pub type zx_time_t = u64;\n+pub const ZX_TIME_INFINITE : zx_time_t = u64::MAX;\n \n-pub type mx_signals_t = u32;\n+pub type zx_signals_t = u32;\n \n-pub const MX_OBJECT_SIGNAL_3         : mx_signals_t = 1 << 3;\n+pub const ZX_OBJECT_SIGNAL_3         : zx_signals_t = 1 << 3;\n \n-pub const MX_TASK_TERMINATED        : mx_signals_t = MX_OBJECT_SIGNAL_3;\n+pub const ZX_TASK_TERMINATED        : zx_signals_t = ZX_OBJECT_SIGNAL_3;\n \n-pub const MX_RIGHT_SAME_RIGHTS  : mx_rights_t = 1 << 31;\n+pub const ZX_RIGHT_SAME_RIGHTS  : zx_rights_t = 1 << 31;\n \n-pub type mx_object_info_topic_t = u32;\n+pub type zx_object_info_topic_t = u32;\n \n-pub const MX_INFO_PROCESS         : mx_object_info_topic_t = 3;\n+pub const ZX_INFO_PROCESS         : zx_object_info_topic_t = 3;\n \n-pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy {\n+pub fn zx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<zx_status_t>+Copy {\n     if let Ok(status) = TryInto::try_into(t) {\n         if status < 0 {\n             Err(io::Error::from_raw_os_error(status))\n@@ -53,33 +53,33 @@ pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy {\n     }\n }\n \n-// Safe wrapper around mx_handle_t\n+// Safe wrapper around zx_handle_t\n pub struct Handle {\n-    raw: mx_handle_t,\n+    raw: zx_handle_t,\n }\n \n impl Handle {\n-    pub fn new(raw: mx_handle_t) -> Handle {\n+    pub fn new(raw: zx_handle_t) -> Handle {\n         Handle {\n             raw,\n         }\n     }\n \n-    pub fn raw(&self) -> mx_handle_t {\n+    pub fn raw(&self) -> zx_handle_t {\n         self.raw\n     }\n }\n \n impl Drop for Handle {\n     fn drop(&mut self) {\n-        unsafe { mx_cvt(mx_handle_close(self.raw)).expect(\"Failed to close mx_handle_t\"); }\n+        unsafe { zx_cvt(zx_handle_close(self.raw)).expect(\"Failed to close zx_handle_t\"); }\n     }\n }\n \n-// Common MX_INFO header\n+// Common ZX_INFO header\n #[derive(Default)]\n #[repr(C)]\n-pub struct mx_info_header_t {\n+pub struct zx_info_header_t {\n     pub topic: u32,              // identifies the info struct\n     pub avail_topic_size: u16,   // \u201cnative\u201d size of the struct\n     pub topic_size: u16,         // size of the returned struct (<=topic_size)\n@@ -89,34 +89,34 @@ pub struct mx_info_header_t {\n \n #[derive(Default)]\n #[repr(C)]\n-pub struct mx_record_process_t {\n+pub struct zx_record_process_t {\n     pub return_code: c_int,\n }\n \n-// Returned for topic MX_INFO_PROCESS\n+// Returned for topic ZX_INFO_PROCESS\n #[derive(Default)]\n #[repr(C)]\n-pub struct mx_info_process_t {\n-    pub hdr: mx_info_header_t,\n-    pub rec: mx_record_process_t,\n+pub struct zx_info_process_t {\n+    pub hdr: zx_info_header_t,\n+    pub rec: zx_record_process_t,\n }\n \n extern {\n-    pub fn mx_job_default() -> mx_handle_t;\n+    pub fn zx_job_default() -> zx_handle_t;\n \n-    pub fn mx_task_kill(handle: mx_handle_t) -> mx_status_t;\n+    pub fn zx_task_kill(handle: zx_handle_t) -> zx_status_t;\n \n-    pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;\n+    pub fn zx_handle_close(handle: zx_handle_t) -> zx_status_t;\n \n-    pub fn mx_handle_duplicate(handle: mx_handle_t, rights: mx_rights_t,\n-                               out: *const mx_handle_t) -> mx_handle_t;\n+    pub fn zx_handle_duplicate(handle: zx_handle_t, rights: zx_rights_t,\n+                               out: *const zx_handle_t) -> zx_handle_t;\n \n-    pub fn mx_object_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,\n-                              pending: *mut mx_signals_t) -> mx_status_t;\n+    pub fn zx_object_wait_one(handle: zx_handle_t, signals: zx_signals_t, timeout: zx_time_t,\n+                              pending: *mut zx_signals_t) -> zx_status_t;\n \n-    pub fn mx_object_get_info(handle: mx_handle_t, topic: u32, buffer: *mut c_void,\n-                              buffer_size: mx_size_t, actual_size: *mut mx_size_t,\n-                              avail: *mut mx_size_t) -> mx_status_t;\n+    pub fn zx_object_get_info(handle: zx_handle_t, topic: u32, buffer: *mut c_void,\n+                              buffer_size: zx_size_t, actual_size: *mut zx_size_t,\n+                              avail: *mut zx_size_t) -> zx_status_t;\n }\n \n // From `enum special_handles` in system/ulib/launchpad/launchpad.c\n@@ -133,117 +133,117 @@ pub struct launchpad_t {\n     env: *const c_char,\n     env_len: usize,\n \n-    handles: *mut mx_handle_t,\n+    handles: *mut zx_handle_t,\n     handles_info: *mut u32,\n     handle_count: usize,\n     handle_alloc: usize,\n \n-    entry: mx_vaddr_t,\n-    base: mx_vaddr_t,\n-    vdso_base: mx_vaddr_t,\n+    entry: zx_vaddr_t,\n+    base: zx_vaddr_t,\n+    vdso_base: zx_vaddr_t,\n \n     stack_size: usize,\n \n-    special_handles: [mx_handle_t; HND_SPECIAL_COUNT],\n+    special_handles: [zx_handle_t; HND_SPECIAL_COUNT],\n     loader_message: bool,\n }\n \n extern {\n-    pub fn launchpad_create(job: mx_handle_t, name: *const c_char,\n-                            lp: *mut *mut launchpad_t) -> mx_status_t;\n+    pub fn launchpad_create(job: zx_handle_t, name: *const c_char,\n+                            lp: *mut *mut launchpad_t) -> zx_status_t;\n \n     pub fn launchpad_go(lp: *mut launchpad_t,\n-                        proc_handle: *mut mx_handle_t,\n-                        err_msg: *mut *const c_char) -> mx_status_t;\n+                        proc_handle: *mut zx_handle_t,\n+                        err_msg: *mut *const c_char) -> zx_status_t;\n \n     pub fn launchpad_destroy(lp: *mut launchpad_t);\n \n     pub fn launchpad_set_args(lp: *mut launchpad_t, argc: c_int,\n-                               argv: *const *const c_char) -> mx_status_t;\n+                               argv: *const *const c_char) -> zx_status_t;\n \n-    pub fn launchpad_set_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;\n+    pub fn launchpad_set_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> zx_status_t;\n \n-    pub fn launchpad_clone(lp: *mut launchpad_t, what: u32) -> mx_status_t;\n+    pub fn launchpad_clone(lp: *mut launchpad_t, what: u32) -> zx_status_t;\n \n-    pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+    pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> zx_status_t;\n \n-    pub fn launchpad_transfer_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+    pub fn launchpad_transfer_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> zx_status_t;\n \n-    pub fn launchpad_elf_load(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+    pub fn launchpad_elf_load(lp: *mut launchpad_t, vmo: zx_handle_t) -> zx_status_t;\n \n-    pub fn launchpad_add_vdso_vmo(lp: *mut launchpad_t) -> mx_status_t;\n+    pub fn launchpad_add_vdso_vmo(lp: *mut launchpad_t) -> zx_status_t;\n \n-    pub fn launchpad_load_vdso(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+    pub fn launchpad_load_vdso(lp: *mut launchpad_t, vmo: zx_handle_t) -> zx_status_t;\n \n-    pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;\n+    pub fn launchpad_vmo_from_file(filename: *const c_char) -> zx_handle_t;\n }\n \n // Launchpad clone constants\n \n-pub const LP_CLONE_MXIO_ROOT: u32 = 0x0001;\n-pub const LP_CLONE_MXIO_CWD: u32 = 0x0002;\n-// LP_CLONE_MXIO_STDIO = 0x0004\n-// LP_CLONE_MXIO_ALL = 0x00FF\n+pub const LP_CLONE_FDIO_NAMESPACE: u32 = 0x0001;\n+pub const LP_CLONE_FDIO_CWD: u32 = 0x0002;\n+// LP_CLONE_FDIO_STDIO = 0x0004\n+// LP_CLONE_FDIO_ALL = 0x00FF\n // LP_CLONE_ENVIRON = 0x0100\n // LP_CLONE_DEFAULT_JOB = 0x0200\n // LP_CLONE_ALL = 0xFFFF\n \n // Errors\n \n-#[allow(unused)] pub const ERR_INTERNAL: mx_status_t = -1;\n+#[allow(unused)] pub const ERR_INTERNAL: zx_status_t = -1;\n \n // ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n // or enabled.\n-#[allow(unused)] pub const ERR_NOT_SUPPORTED: mx_status_t = -2;\n+#[allow(unused)] pub const ERR_NOT_SUPPORTED: zx_status_t = -2;\n \n // ERR_NO_RESOURCES: The system was not able to allocate some resource\n // needed for the operation.\n-#[allow(unused)] pub const ERR_NO_RESOURCES: mx_status_t = -3;\n+#[allow(unused)] pub const ERR_NO_RESOURCES: zx_status_t = -3;\n \n // ERR_NO_MEMORY: The system was not able to allocate memory needed\n // for the operation.\n-#[allow(unused)] pub const ERR_NO_MEMORY: mx_status_t = -4;\n+#[allow(unused)] pub const ERR_NO_MEMORY: zx_status_t = -4;\n \n-// ERR_CALL_FAILED: The second phase of mx_channel_call(; did not complete\n+// ERR_CALL_FAILED: The second phase of zx_channel_call(; did not complete\n // successfully.\n-#[allow(unused)] pub const ERR_CALL_FAILED: mx_status_t = -5;\n+#[allow(unused)] pub const ERR_CALL_FAILED: zx_status_t = -5;\n \n // ERR_INTERRUPTED_RETRY: The system call was interrupted, but should be\n // retried.  This should not be seen outside of the VDSO.\n-#[allow(unused)] pub const ERR_INTERRUPTED_RETRY: mx_status_t = -6;\n+#[allow(unused)] pub const ERR_INTERRUPTED_RETRY: zx_status_t = -6;\n \n // ======= Parameter errors =======\n // ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n-#[allow(unused)] pub const ERR_INVALID_ARGS: mx_status_t = -10;\n+#[allow(unused)] pub const ERR_INVALID_ARGS: zx_status_t = -10;\n \n // ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n-#[allow(unused)] pub const ERR_BAD_HANDLE: mx_status_t = -11;\n+#[allow(unused)] pub const ERR_BAD_HANDLE: zx_status_t = -11;\n \n // ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n // perform the operation.\n // Example: Attempting a message_read on a thread handle.\n-#[allow(unused)] pub const ERR_WRONG_TYPE: mx_status_t = -12;\n+#[allow(unused)] pub const ERR_WRONG_TYPE: zx_status_t = -12;\n \n // ERR_BAD_SYSCALL: The specified syscall number is invalid.\n-#[allow(unused)] pub const ERR_BAD_SYSCALL: mx_status_t = -13;\n+#[allow(unused)] pub const ERR_BAD_SYSCALL: zx_status_t = -13;\n \n // ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n // operation.\n-#[allow(unused)] pub const ERR_OUT_OF_RANGE: mx_status_t = -14;\n+#[allow(unused)] pub const ERR_OUT_OF_RANGE: zx_status_t = -14;\n \n // ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n // this operation.\n-#[allow(unused)] pub const ERR_BUFFER_TOO_SMALL: mx_status_t = -15;\n+#[allow(unused)] pub const ERR_BUFFER_TOO_SMALL: zx_status_t = -15;\n \n // ======= Precondition or state errors =======\n // ERR_BAD_STATE: operation failed because the current state of the\n // object does not allow it, or a precondition of the operation is\n // not satisfied\n-#[allow(unused)] pub const ERR_BAD_STATE: mx_status_t = -20;\n+#[allow(unused)] pub const ERR_BAD_STATE: zx_status_t = -20;\n \n // ERR_TIMED_OUT: The time limit for the operation elapsed before\n // the operation completed.\n-#[allow(unused)] pub const ERR_TIMED_OUT: mx_status_t = -21;\n+#[allow(unused)] pub const ERR_TIMED_OUT: zx_status_t = -21;\n \n // ERR_SHOULD_WAIT: The operation cannot be performed currently but\n // potentially could succeed if the caller waits for a prerequisite\n@@ -253,67 +253,67 @@ pub const LP_CLONE_MXIO_CWD: u32 = 0x0002;\n // messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n // Attempting to read from a message pipe that has no messages waiting\n // and has a closed remote end will return ERR_REMOTE_CLOSED.\n-#[allow(unused)] pub const ERR_SHOULD_WAIT: mx_status_t = -22;\n+#[allow(unused)] pub const ERR_SHOULD_WAIT: zx_status_t = -22;\n \n // ERR_CANCELED: The in-progress operation (e.g. a wait) has been\n // // canceled.\n-#[allow(unused)] pub const ERR_CANCELED: mx_status_t = -23;\n+#[allow(unused)] pub const ERR_CANCELED: zx_status_t = -23;\n \n // ERR_PEER_CLOSED: The operation failed because the remote end\n // of the subject of the operation was closed.\n-#[allow(unused)] pub const ERR_PEER_CLOSED: mx_status_t = -24;\n+#[allow(unused)] pub const ERR_PEER_CLOSED: zx_status_t = -24;\n \n // ERR_NOT_FOUND: The requested entity is not found.\n-#[allow(unused)] pub const ERR_NOT_FOUND: mx_status_t = -25;\n+#[allow(unused)] pub const ERR_NOT_FOUND: zx_status_t = -25;\n \n // ERR_ALREADY_EXISTS: An object with the specified identifier\n // already exists.\n // Example: Attempting to create a file when a file already exists\n // with that name.\n-#[allow(unused)] pub const ERR_ALREADY_EXISTS: mx_status_t = -26;\n+#[allow(unused)] pub const ERR_ALREADY_EXISTS: zx_status_t = -26;\n \n // ERR_ALREADY_BOUND: The operation failed because the named entity\n // is already owned or controlled by another entity. The operation\n // could succeed later if the current owner releases the entity.\n-#[allow(unused)] pub const ERR_ALREADY_BOUND: mx_status_t = -27;\n+#[allow(unused)] pub const ERR_ALREADY_BOUND: zx_status_t = -27;\n \n // ERR_UNAVAILABLE: The subject of the operation is currently unable\n // to perform the operation.\n // Note: This is used when there's no direct way for the caller to\n // observe when the subject will be able to perform the operation\n // and should thus retry.\n-#[allow(unused)] pub const ERR_UNAVAILABLE: mx_status_t = -28;\n+#[allow(unused)] pub const ERR_UNAVAILABLE: zx_status_t = -28;\n \n // ======= Permission check errors =======\n // ERR_ACCESS_DENIED: The caller did not have permission to perform\n // the specified operation.\n-#[allow(unused)] pub const ERR_ACCESS_DENIED: mx_status_t = -30;\n+#[allow(unused)] pub const ERR_ACCESS_DENIED: zx_status_t = -30;\n \n // ======= Input-output errors =======\n // ERR_IO: Otherwise unspecified error occurred during I/O.\n-#[allow(unused)] pub const ERR_IO: mx_status_t = -40;\n+#[allow(unused)] pub const ERR_IO: zx_status_t = -40;\n \n // ERR_REFUSED: The entity the I/O operation is being performed on\n // rejected the operation.\n // Example: an I2C device NAK'ing a transaction or a disk controller\n // rejecting an invalid command.\n-#[allow(unused)] pub const ERR_IO_REFUSED: mx_status_t = -41;\n+#[allow(unused)] pub const ERR_IO_REFUSED: zx_status_t = -41;\n \n // ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n // check and is possibly corrupted.\n // Example: CRC or Parity error.\n-#[allow(unused)] pub const ERR_IO_DATA_INTEGRITY: mx_status_t = -42;\n+#[allow(unused)] pub const ERR_IO_DATA_INTEGRITY: zx_status_t = -42;\n \n // ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n // and may be permanently lost.\n // Example: A disk block is irrecoverably damaged.\n-#[allow(unused)] pub const ERR_IO_DATA_LOSS: mx_status_t = -43;\n+#[allow(unused)] pub const ERR_IO_DATA_LOSS: zx_status_t = -43;\n \n // Filesystem specific errors\n-#[allow(unused)] pub const ERR_BAD_PATH: mx_status_t = -50;\n-#[allow(unused)] pub const ERR_NOT_DIR: mx_status_t = -51;\n-#[allow(unused)] pub const ERR_NOT_FILE: mx_status_t = -52;\n+#[allow(unused)] pub const ERR_BAD_PATH: zx_status_t = -50;\n+#[allow(unused)] pub const ERR_NOT_DIR: zx_status_t = -51;\n+#[allow(unused)] pub const ERR_NOT_FILE: zx_status_t = -52;\n // ERR_FILE_BIG: A file exceeds a filesystem-specific size limit.\n-#[allow(unused)] pub const ERR_FILE_BIG: mx_status_t = -53;\n+#[allow(unused)] pub const ERR_FILE_BIG: zx_status_t = -53;\n // ERR_NO_SPACE: Filesystem or device space is exhausted.\n-#[allow(unused)] pub const ERR_NO_SPACE: mx_status_t = -54;\n+#[allow(unused)] pub const ERR_NO_SPACE: zx_status_t = -54;", "previous_filename": "src/libstd/sys/unix/process/magenta.rs"}, {"sha": "fd066c9cdbeef417c32d659a3e87055e198cd8d6", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -344,15 +344,15 @@ mod imp {\n     use io;\n     use rand::Rng;\n \n-    #[link(name = \"magenta\")]\n+    #[link(name = \"zircon\")]\n     extern {\n-        fn mx_cprng_draw(buffer: *mut u8, len: usize, actual: *mut usize) -> i32;\n+        fn zx_cprng_draw(buffer: *mut u8, len: usize, actual: *mut usize) -> i32;\n     }\n \n     fn getrandom(buf: &mut [u8]) -> Result<usize, i32> {\n         unsafe {\n             let mut actual = 0;\n-            let status = mx_cprng_draw(buf.as_mut_ptr(), buf.len(), &mut actual);\n+            let status = zx_cprng_draw(buf.as_mut_ptr(), buf.len(), &mut actual);\n             if status == 0 {\n                 Ok(actual)\n             } else {\n@@ -387,7 +387,7 @@ mod imp {\n                 let ret = getrandom(buf);\n                 match ret {\n                     Err(err) => {\n-                        panic!(\"kernel mx_cprng_draw call failed! (returned {}, buf.len() {})\",\n+                        panic!(\"kernel zx_cprng_draw call failed! (returned {}, buf.len() {})\",\n                             err, buf.len())\n                     }\n                     Ok(actual) => {"}, {"sha": "934ac3edbf1f18538481577ae91501f567cd8ab4", "filename": "src/libstd/sys_common/poison.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -65,17 +65,48 @@ pub struct Guard {\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n ///\n+/// # Examples\n+///\n+/// ```\n+/// use std::sync::{Arc, Mutex};\n+/// use std::thread;\n+///\n+/// let mutex = Arc::new(Mutex::new(1));\n+///\n+/// // poison the mutex\n+/// let c_mutex = mutex.clone();\n+/// let _ = thread::spawn(move || {\n+///     let mut data = c_mutex.lock().unwrap();\n+///     *data = 2;\n+///     panic!();\n+/// }).join();\n+///\n+/// match mutex.lock() {\n+///     Ok(_) => unreachable!(),\n+///     Err(p_err) => {\n+///         let data = p_err.get_ref();\n+///         println!(\"recovered: {}\", data);\n+///     }\n+/// };\n+/// ```\n+///\n /// [`Mutex`]: ../../std/sync/struct.Mutex.html\n /// [`RwLock`]: ../../std/sync/struct.RwLock.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n-/// An enumeration of possible errors which can occur while calling the\n-/// [`try_lock`] method.\n+/// An enumeration of possible errors associated with a [`TryLockResult`] which\n+/// can occur while trying to aquire a lock, from the [`try_lock`] method on a\n+/// [`Mutex`] or the [`try_read`] and [`try_write`] methods on an [`RwLock`].\n ///\n+/// [`Mutex`]: struct.Mutex.html\n+/// [`RwLock`]: struct.RwLock.html\n+/// [`TryLockResult`]: type.TryLockResult.html\n /// [`try_lock`]: struct.Mutex.html#method.try_lock\n+/// [`try_read`]: struct.RwLock.html#method.try_read\n+/// [`try_write`]: struct.RwLock.html#method.try_write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another thread failed while holding\n@@ -148,6 +179,28 @@ impl<T> PoisonError<T> {\n \n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::sync::{Arc, Mutex};\n+    /// use std::thread;\n+    ///\n+    /// let mutex = Arc::new(Mutex::new(HashSet::new()));\n+    ///\n+    /// // poison the mutex\n+    /// let c_mutex = mutex.clone();\n+    /// let _ = thread::spawn(move || {\n+    ///     let mut data = c_mutex.lock().unwrap();\n+    ///     data.insert(10);\n+    ///     panic!();\n+    /// }).join();\n+    ///\n+    /// let p_err = mutex.lock().unwrap_err();\n+    /// let data = p_err.into_inner();\n+    /// println!(\"recovered {} items\", data.len());\n+    /// ```\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn into_inner(self) -> T { self.guard }\n "}, {"sha": "86927ce322eae89019d902342f537bc8eed8ec1e", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,7 +13,9 @@ use ops::{Add, Sub, Mul, Div, AddAssign, SubAssign, MulAssign, DivAssign};\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n+const NANOS_PER_MICRO: u32 = 1_000;\n const MILLIS_PER_SEC: u64 = 1_000;\n+const MICROS_PER_SEC: u64 = 1_000_000;\n \n /// A `Duration` type to represent a span of time, typically used for system\n /// timeouts.\n@@ -116,6 +118,27 @@ impl Duration {\n         Duration { secs: secs, nanos: nanos }\n     }\n \n+    /// Creates a new `Duration` from the specified number of microseconds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(duration_from_micros)]\n+    /// use std::time::Duration;\n+    ///\n+    /// let duration = Duration::from_micros(1_000_002);\n+    ///\n+    /// assert_eq!(1, duration.as_secs());\n+    /// assert_eq!(2000, duration.subsec_nanos());\n+    /// ```\n+    #[unstable(feature = \"duration_from_micros\", issue = \"44400\")]\n+    #[inline]\n+    pub fn from_micros(micros: u64) -> Duration {\n+        let secs = micros / MICROS_PER_SEC;\n+        let nanos = ((micros % MICROS_PER_SEC) as u32) * NANOS_PER_MICRO;\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+\n     /// Returns the number of _whole_ seconds contained by this `Duration`.\n     ///\n     /// The returned value does not include the fractional (nanosecond) part of the"}, {"sha": "0504e889ea10b4d9139cbe651e3796d5357b1f2a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -538,10 +538,16 @@ pub enum BindingMode {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum RangeEnd {\n-    Included,\n+    Included(RangeSyntax),\n     Excluded,\n }\n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum RangeSyntax {\n+    DotDotDot,\n+    DotDotEq,\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n@@ -578,7 +584,7 @@ pub enum PatKind {\n     Ref(P<Pat>, Mutability),\n     /// A literal\n     Lit(P<Expr>),\n-    /// A range pattern, e.g. `1...2` or `1..2`\n+    /// A range pattern, e.g. `1...2`, `1..=2` or `1..2`\n     Range(P<Expr>, P<Expr>, RangeEnd),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`"}, {"sha": "c3cf474783505d2d0b3f8a3d086ed92a5ea0e446", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -291,7 +291,7 @@ Erroneous code example:\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...]; // error: inclusive range was used with no end\n+    let x = &tmp[1..=]; // error: inclusive range was used with no end\n }\n ```\n \n@@ -312,7 +312,7 @@ Or put an end to your inclusive range:\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...3]; // ok!\n+    let x = &tmp[1..=3]; // ok!\n }\n ```\n \"##,"}, {"sha": "0e05cce35e2df2bec26e60081124b3c9c4bb7492", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -783,6 +783,10 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n+    pub fn mut_span_err(&self, sp: Span, msg: &str)\n+                        -> DiagnosticBuilder<'a> {\n+        self.parse_sess.span_diagnostic.mut_span_err(sp, msg)\n+    }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }"}, {"sha": "6e7a8203b61ca76d2c84ea5d7380b6085f72cb61", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -282,7 +282,33 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let expansion = self.expand_invoc(invoc, ext);\n                     self.collect_invocations(expansion, &[])\n                 } else if let InvocationKind::Attr { attr: None, traits, item } = invoc.kind {\n-                    let item = item\n+                    let derive_allowed = match item {\n+                        Annotatable::Item(ref item) => match item.node {\n+                            ast::ItemKind::Struct(..) |\n+                            ast::ItemKind::Enum(..) |\n+                            ast::ItemKind::Union(..) => true,\n+                            _ => false,\n+                        },\n+                        _ => false,\n+                    };\n+                    if !derive_allowed {\n+                        let attr = item.attrs().iter()\n+                            .find(|attr| attr.check_name(\"derive\"))\n+                            .expect(\"`derive` attribute should exist\");\n+                        let span = attr.span;\n+                        let mut err = self.cx.mut_span_err(span,\n+                                                           \"`derive` may only be applied to \\\n+                                                            structs, enums and unions\");\n+                        if let ast::AttrStyle::Inner = attr.style {\n+                            let trait_list = traits.iter()\n+                                .map(|t| format!(\"{}\", t)).collect::<Vec<_>>();\n+                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                            err.span_suggestion(span, \"try an outer attribute\", suggestion);\n+                        }\n+                        err.emit();\n+                    }\n+\n+                    let item = self.fully_configure(item)\n                         .map_attrs(|mut attrs| { attrs.retain(|a| a.path != \"derive\"); attrs });\n                     let item_with_markers =\n                         add_derived_markers(&mut self.cx, item.span(), &traits, item.clone());\n@@ -374,6 +400,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         result\n     }\n \n+    fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n+        let mut cfg = StripUnconfigured {\n+            should_test: self.cx.ecfg.should_test,\n+            sess: self.cx.parse_sess,\n+            features: self.cx.ecfg.features,\n+        };\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match item {\n+            Annotatable::Item(item) => {\n+                Annotatable::Item(cfg.fold_item(item).pop().unwrap())\n+            }\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(item.map(|item| cfg.fold_trait_item(item).pop().unwrap()))\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(item.map(|item| cfg.fold_impl_item(item).pop().unwrap()))\n+            }\n+        }\n+    }\n+\n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let result = match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n@@ -714,15 +761,6 @@ struct InvocationCollector<'a, 'b: 'a> {\n     monotonic: bool,\n }\n \n-macro_rules! fully_configure {\n-    ($this:ident, $node:ident, $noop_fold:ident) => {\n-        match $noop_fold($node, &mut $this.cfg).pop() {\n-            Some(node) => node,\n-            None => return SmallVector::new(),\n-        }\n-    }\n-}\n-\n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, expansion_kind: ExpansionKind, kind: InvocationKind) -> Expansion {\n         let mark = Mark::fresh(self.cx.current_expansion.mark);\n@@ -748,13 +786,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     item: Annotatable,\n                     kind: ExpansionKind)\n                     -> Expansion {\n-        if !traits.is_empty() &&\n-           (kind == ExpansionKind::TraitItems || kind == ExpansionKind::ImplItems) {\n-            self.cx.span_err(traits[0].span, \"`derive` can be only be applied to items\");\n-            self.cx.trace_macros_diag();\n-            return kind.expect_from_annotatables(::std::iter::once(item));\n-        }\n-        self.collect(kind, InvocationKind::Attr { attr: attr, traits: traits, item: item })\n+        self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n@@ -880,7 +912,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         let (attr, traits, mut item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::Item(fully_configure!(self, item, noop_fold_item));\n+            let item = Annotatable::Item(item);\n             return self.collect_attr(attr, traits, item, ExpansionKind::Items).make_items();\n         }\n \n@@ -954,8 +986,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item =\n-                Annotatable::TraitItem(P(fully_configure!(self, item, noop_fold_trait_item)));\n+            let item = Annotatable::TraitItem(P(item));\n             return self.collect_attr(attr, traits, item, ExpansionKind::TraitItems)\n                 .make_trait_items()\n         }\n@@ -975,7 +1006,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n-            let item = Annotatable::ImplItem(P(fully_configure!(self, item, noop_fold_impl_item)));\n+            let item = Annotatable::ImplItem(P(item));\n             return self.collect_attr(attr, traits, item, ExpansionKind::ImplItems)\n                 .make_impl_items();\n         }"}, {"sha": "bd8c9a0ed40b24b133d69c1e24c149a3d010227f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -686,7 +686,9 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::At           => \"At\",\n         token::Dot          => \"Dot\",\n         token::DotDot       => \"DotDot\",\n+        token::DotEq        => \"DotEq\",\n         token::DotDotDot    => \"DotDotDot\",\n+        token::DotDotEq     => \"DotDotEq\",\n         token::Comma        => \"Comma\",\n         token::Semi         => \"Semi\",\n         token::Colon        => \"Colon\","}, {"sha": "e92a7484f33676a1abf5725547536f95180549c4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -26,7 +26,7 @@ use self::AttributeType::*;\n use self::AttributeGate::*;\n \n use abi::Abi;\n-use ast::{self, NodeId, PatKind, RangeEnd};\n+use ast::{self, NodeId, PatKind, RangeEnd, RangeSyntax};\n use attr;\n use codemap::Spanned;\n use syntax_pos::Span;\n@@ -261,7 +261,7 @@ declare_features! (\n     // rustc internal\n     (active, abi_vectorcall, \"1.7.0\", None),\n \n-    // a...b and ...b\n+    // a..=b and ..=b\n     (active, inclusive_range_syntax, \"1.7.0\", Some(28237)),\n \n     // X..Y patterns\n@@ -380,7 +380,7 @@ declare_features! (\n     // #[doc(masked)]\n     (active, doc_masked, \"1.21.0\", None),\n \n-    // allow `#[must_use]` on functions (RFC 1940)\n+    // allow `#[must_use]` on functions and comparison operators (RFC 1940)\n     (active, fn_must_use, \"1.21.0\", Some(43302)),\n \n     // allow '|' at beginning of match arms (RFC 1925)\n@@ -389,6 +389,12 @@ declare_features! (\n     // Copy/Clone closures (RFC 2132)\n     (active, clone_closures, \"1.22.0\", Some(44490)),\n     (active, copy_closures, \"1.22.0\", Some(44490)),\n+\n+    // allow `'_` placeholder lifetimes\n+    (active, underscore_lifetimes, \"1.22.0\", Some(44524)),\n+\n+    // allow `..=` in patterns (RFC 1192)\n+    (active, dotdoteq_in_patterns, \"1.22.0\", Some(28237)),\n );\n \n declare_features! (\n@@ -721,6 +727,12 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                        is just used for rustc unit tests \\\n                                                        and will never be stable\",\n                                                       cfg_fn!(rustc_attrs))),\n+    (\"rustc_synthetic\", Whitelisted, Gated(Stability::Unstable,\n+                                                      \"rustc_attrs\",\n+                                                      \"this attribute \\\n+                                                       is just used for rustc unit tests \\\n+                                                       and will never be stable\",\n+                                                      cfg_fn!(rustc_attrs))),\n     (\"rustc_symbol_name\", Whitelisted, Gated(Stability::Unstable,\n                                              \"rustc_attrs\",\n                                              \"internal rustc attributes will never be stable\",\n@@ -1488,6 +1500,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, exclusive_range_pattern, pattern.span,\n                                    \"exclusive range pattern syntax is experimental\");\n             }\n+            PatKind::Range(_, _, RangeEnd::Included(RangeSyntax::DotDotEq)) => {\n+                gate_feature_post!(&self, dotdoteq_in_patterns, pattern.span,\n+                                   \"`..=` syntax in patterns is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_pat(self, pattern)\n@@ -1572,6 +1588,14 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         }\n         visit::walk_lifetime_def(self, lifetime_def)\n     }\n+\n+    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n+        if lt.ident.name == \"'_\" {\n+            gate_feature_post!(&self, underscore_lifetimes, lt.span,\n+                               \"underscore lifetimes are unstable\");\n+        }\n+        visit::walk_lifetime(self, lt)\n+    }\n }\n \n pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> Features {"}, {"sha": "1cb7b0eca58d0de722846320e2b88e675fb04c96", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1131,6 +1131,9 @@ impl<'a> StringReader<'a> {\n                     if self.ch_is('.') {\n                         self.bump();\n                         Ok(token::DotDotDot)\n+                    } else if self.ch_is('=') {\n+                        self.bump();\n+                        Ok(token::DotDotEq)\n                     } else {\n                         Ok(token::DotDot)\n                     }"}, {"sha": "d5ba4b54d901451686588d16c04d0e401db0a3ce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -38,7 +38,7 @@ use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n-use ast::RangeEnd;\n+use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n use syntax_pos::{self, Span, BytePos};\n@@ -432,7 +432,7 @@ impl Error {\n             Error::InclusiveRangeWithNoEnd => {\n                 let mut err = struct_span_err!(handler, sp, E0586,\n                                                \"inclusive range with no end\");\n-                err.help(\"inclusive ranges must be bounded at the end (`...b` or `a...b`)\");\n+                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n                 err\n             }\n         }\n@@ -2632,7 +2632,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Not, e))\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             // Suggest `!` for bitwise negation when encountering a `~`\n             token::Tilde => {\n@@ -2645,26 +2645,26 @@ impl<'a> Parser<'a> {\n                 err.span_label(span_of_tilde, \"did you mean `!`?\");\n                 err.help(\"use `!` instead of `~` if you meant to perform bitwise negation\");\n                 err.emit();\n-                (span, self.mk_unary(UnOp::Not, e))\n+                (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Neg, e))\n+                (lo.to(span), self.mk_unary(UnOp::Neg, e))\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, self.mk_unary(UnOp::Deref, e))\n+                (lo.to(span), self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 self.expect_and()?;\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, ExprKind::AddrOf(m, e))\n+                (lo.to(span), ExprKind::AddrOf(m, e))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2675,13 +2675,13 @@ impl<'a> Parser<'a> {\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n                 let blk_expr = self.mk_expr(span, ExprKind::Block(blk), ThinVec::new());\n-                (span, ExprKind::InPlace(place, blk_expr))\n+                (lo.to(span), ExprKind::InPlace(place, blk_expr))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (span, ExprKind::Box(e))\n+                (lo.to(span), ExprKind::Box(e))\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n@@ -2710,7 +2710,7 @@ impl<'a> Parser<'a> {\n                 LhsExpr::AttributesParsed(attrs) => Some(attrs),\n                 _ => None,\n             };\n-            if self.token == token::DotDot || self.token == token::DotDotDot {\n+            if [token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token) {\n                 return self.parse_prefix_range_expr(attrs);\n             } else {\n                 self.parse_prefix_expr(attrs)?\n@@ -2744,6 +2744,10 @@ impl<'a> Parser<'a> {\n             if op.precedence() < min_prec {\n                 break;\n             }\n+            // Warn about deprecated ... syntax (until SNAP)\n+            if self.token == token::DotDotDot {\n+                self.warn_dotdoteq(self.span);\n+            }\n             self.bump();\n             if op.is_comparison() {\n                 self.check_no_chained_comparison(&lhs, &op);\n@@ -2770,12 +2774,13 @@ impl<'a> Parser<'a> {\n                     }\n                 };\n                 continue\n-            } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n-                // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n+            } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n+                // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n                 //\n-                // We have 2 alternatives here: `x..y`/`x...y` and `x..`/`x...` The other\n+                // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n                 // two variants are handled with `parse_prefix_range_expr` call above.\n+                // (and `x...y`/`x...` until SNAP)\n                 let rhs = if self.is_at_start_of_range_notation_rhs() {\n                     Some(self.parse_assoc_expr_with(op.precedence() + 1,\n                                                     LhsExpr::NotYetParsed)?)\n@@ -2852,8 +2857,8 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(span, aopexpr, ThinVec::new())\n                 }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n-                    self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n+                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                    self.bug(\"AssocOp should have been handled by special case\")\n                 }\n             };\n \n@@ -2949,17 +2954,22 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse prefix-forms of range notation: `..expr`, `..`, `...expr`\n+    /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr` (and `...expr` until SNAP)\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot,\n-                      \"parse_prefix_range_expr: token {:?} is not DotDot or DotDotDot\",\n+        // SNAP remove DotDotDot\n+        debug_assert!([token::DotDot, token::DotDotDot, token::DotDotEq].contains(&self.token),\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot/DotDotDot/DotDotEq\",\n                       self.token);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span;\n         let mut hi = self.span;\n+        // Warn about deprecated ... syntax (until SNAP)\n+        if tok == token::DotDotDot {\n+            self.warn_dotdoteq(self.span);\n+        }\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n@@ -3450,7 +3460,7 @@ impl<'a> Parser<'a> {\n     fn parse_as_ident(&mut self) -> bool {\n         self.look_ahead(1, |t| match *t {\n             token::OpenDelim(token::Paren) | token::OpenDelim(token::Brace) |\n-            token::DotDotDot | token::ModSep | token::Not => Some(false),\n+            token::DotDotDot | token::DotDotEq | token::ModSep | token::Not => Some(false),\n             // ensure slice patterns [a, b.., c] and [a, b, c..] don't go into the\n             // range pattern branch\n             token::DotDot => None,\n@@ -3544,11 +3554,13 @@ impl<'a> Parser<'a> {\n                         let mac = respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n-                    token::DotDotDot | token::DotDot => {\n+                    token::DotDotDot | token::DotDotEq | token::DotDot => {\n                         let end_kind = match self.token {\n                             token::DotDot => RangeEnd::Excluded,\n-                            token::DotDotDot => RangeEnd::Included,\n-                            _ => panic!(\"can only parse `..` or `...` for ranges (checked above)\"),\n+                            token::DotDotDot => RangeEnd::Included(RangeSyntax::DotDotDot),\n+                            token::DotDotEq => RangeEnd::Included(RangeSyntax::DotDotEq),\n+                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n+                                         (checked above)\"),\n                         };\n                         // Parse range\n                         let span = lo.to(self.prev_span);\n@@ -3589,7 +3601,12 @@ impl<'a> Parser<'a> {\n                     Ok(begin) => {\n                         if self.eat(&token::DotDotDot) {\n                             let end = self.parse_pat_range_end()?;\n-                            pat = PatKind::Range(begin, end, RangeEnd::Included);\n+                            pat = PatKind::Range(begin, end,\n+                                    RangeEnd::Included(RangeSyntax::DotDotDot));\n+                        } else if self.eat(&token::DotDotEq) {\n+                            let end = self.parse_pat_range_end()?;\n+                            pat = PatKind::Range(begin, end,\n+                                    RangeEnd::Included(RangeSyntax::DotDotEq));\n                         } else if self.eat(&token::DotDot) {\n                             let end = self.parse_pat_range_end()?;\n                             pat = PatKind::Range(begin, end, RangeEnd::Excluded);\n@@ -3973,7 +3990,7 @@ impl<'a> Parser<'a> {\n                     token::BinOp(token::Minus) | token::BinOp(token::Star) |\n                     token::BinOp(token::And) | token::BinOp(token::Or) |\n                     token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot => false,\n+                    token::DotDot | token::DotDotDot | token::DotDotEq => false,\n                     _ => true,\n                 } {\n                     self.warn_missing_semicolon();\n@@ -4195,6 +4212,12 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n+    fn warn_dotdoteq(&self, span: Span) {\n+        self.diagnostic().struct_span_warn(span, {\n+            \"`...` is being replaced by `..=`\"\n+        }).emit();\n+    }\n+\n     // Parse bounds of a type parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     // BOUND = TY_BOUND | LT_BOUND\n     // LT_BOUND = LIFETIME (e.g. `'a`)"}, {"sha": "4888654fac9d0ed09c9454ee6f23b92731757b40", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -152,6 +152,8 @@ pub enum Token {\n     Dot,\n     DotDot,\n     DotDotDot,\n+    DotDotEq,\n+    DotEq, // HACK(durka42) never produced by the parser, only used for libproc_macro\n     Comma,\n     Semi,\n     Colon,\n@@ -212,18 +214,19 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             Ident(ident)                => ident_can_begin_expr(ident), // value name or keyword\n-            OpenDelim(..)               | // tuple, array or block\n-            Literal(..)                 | // literal\n-            Not                         | // operator not\n-            BinOp(Minus)                | // unary minus\n-            BinOp(Star)                 | // dereference\n-            BinOp(Or) | OrOr            | // closure\n-            BinOp(And)                  | // reference\n-            AndAnd                      | // double reference\n-            DotDot | DotDotDot          | // range notation\n-            Lt | BinOp(Shl)             | // associated path\n-            ModSep                      | // global path\n-            Pound                       => true, // expression attributes\n+            OpenDelim(..)                     | // tuple, array or block\n+            Literal(..)                       | // literal\n+            Not                               | // operator not\n+            BinOp(Minus)                      | // unary minus\n+            BinOp(Star)                       | // dereference\n+            BinOp(Or) | OrOr                  | // closure\n+            BinOp(And)                        | // reference\n+            AndAnd                            | // double reference\n+            DotDot | DotDotDot | DotDotEq     | // range notation\n+                // SNAP remove DotDotDot\n+            Lt | BinOp(Shl)                   | // associated path\n+            ModSep                            | // global path\n+            Pound                             => true, // expression attributes\n             Interpolated(ref nt) => match nt.0 {\n                 NtIdent(..) | NtExpr(..) | NtBlock(..) | NtPath(..) => true,\n                 _ => false,\n@@ -402,20 +405,22 @@ impl Token {\n             Dot => match joint {\n                 Dot => DotDot,\n                 DotDot => DotDotDot,\n+                DotEq => DotDotEq,\n                 _ => return None,\n             },\n             DotDot => match joint {\n                 Dot => DotDotDot,\n+                Eq => DotDotEq,\n                 _ => return None,\n             },\n             Colon => match joint {\n                 Colon => ModSep,\n                 _ => return None,\n             },\n \n-            Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot | Comma |\n-            Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar | Question |\n-            OpenDelim(..) | CloseDelim(..) | Underscore => return None,\n+            Le | EqEq | Ne | Ge | AndAnd | OrOr | Tilde | BinOpEq(..) | At | DotDotDot | DotEq |\n+            DotDotEq | Comma | Semi | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar |\n+            Question | OpenDelim(..) | CloseDelim(..) | Underscore => return None,\n \n             Literal(..) | Ident(..) | Lifetime(..) | Interpolated(..) | DocComment(..) |\n             Whitespace | Comment | Shebang(..) | Eof => return None,"}, {"sha": "959dd4ef30f29853506d4288199b5a14c0e44b0d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,7 +11,7 @@\n pub use self::AnnNode::*;\n \n use abi::{self, Abi};\n-use ast::{self, BlockCheckMode, PatKind, RangeEnd};\n+use ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use util::parser::{self, AssocOp, Fixity};\n@@ -203,6 +203,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Dot                  => \".\".to_string(),\n         token::DotDot               => \"..\".to_string(),\n         token::DotDotDot            => \"...\".to_string(),\n+        token::DotDotEq             => \"..=\".to_string(),\n+        token::DotEq                => \".=\".to_string(),\n         token::Comma                => \",\".to_string(),\n         token::Semi                 => \";\".to_string(),\n         token::Colon                => \":\".to_string(),\n@@ -2588,7 +2590,8 @@ impl<'a> State<'a> {\n                 self.print_expr(begin)?;\n                 self.s.space()?;\n                 match *end_kind {\n-                    RangeEnd::Included => self.s.word(\"...\")?,\n+                    RangeEnd::Included(RangeSyntax::DotDotDot) => self.s.word(\"...\")?,\n+                    RangeEnd::Included(RangeSyntax::DotDotEq) => self.s.word(\"..=\")?,\n                     RangeEnd::Excluded => self.s.word(\"..\")?,\n                 }\n                 self.print_expr(end)?;"}, {"sha": "590874806d7b5b1d7ade4780d8bc320eeb96ddd0", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -62,8 +62,8 @@ pub enum AssocOp {\n     As,\n     /// `..` range\n     DotDot,\n-    /// `...` range\n-    DotDotDot,\n+    /// `..=` range\n+    DotDotEq,\n     /// `:`\n     Colon,\n }\n@@ -105,7 +105,8 @@ impl AssocOp {\n             Token::AndAnd => Some(LAnd),\n             Token::OrOr => Some(LOr),\n             Token::DotDot => Some(DotDot),\n-            Token::DotDotDot => Some(DotDotDot),\n+            Token::DotDotEq => Some(DotDotEq),\n+            Token::DotDotDot => Some(DotDotEq), // remove this after SNAP\n             Token::Colon => Some(Colon),\n             _ if t.is_keyword(keywords::As) => Some(As),\n             _ => None\n@@ -151,7 +152,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => 7,\n             LAnd => 6,\n             LOr => 5,\n-            DotDot | DotDotDot => 4,\n+            DotDot | DotDotEq => 4,\n             Inplace => 3,\n             Assign | AssignOp(_) => 2,\n         }\n@@ -166,7 +167,7 @@ impl AssocOp {\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n             BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n             LAnd | LOr | Colon => Fixity::Left,\n-            DotDot | DotDotDot => Fixity::None\n+            DotDot | DotDotEq => Fixity::None\n         }\n     }\n \n@@ -176,7 +177,7 @@ impl AssocOp {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n             ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr |\n-            DotDot | DotDotDot | Colon => false\n+            DotDot | DotDotEq | Colon => false\n         }\n     }\n \n@@ -186,7 +187,7 @@ impl AssocOp {\n             Assign | AssignOp(_) | Inplace => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n             Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n-            LOr | DotDot | DotDotDot | Colon => false\n+            LOr | DotDot | DotDotEq | Colon => false\n         }\n     }\n \n@@ -211,7 +212,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotDot | Colon => None\n+            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None\n         }\n     }\n }"}, {"sha": "5c1ca19d635f7dc865e94d51f98f1df19cda7216", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -428,8 +428,9 @@ impl<'a> TraitDef<'a> {\n                         }\n                     }\n                     _ => {\n-                        cx.span_err(mitem.span,\n-                                    \"`derive` may only be applied to structs, enums and unions\");\n+                        // Non-ADT derive is an error, but it should have been\n+                        // set earlier; see\n+                        // libsyntax/ext/expand.rs:MacroExpander::expand()\n                         return;\n                     }\n                 };\n@@ -448,8 +449,10 @@ impl<'a> TraitDef<'a> {\n                 push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))\n             }\n             _ => {\n-                cx.span_err(mitem.span,\n-                            \"`derive` may only be applied to structs and enums\");\n+                // Non-Item derive is an error, but it should have been\n+                // set earlier; see\n+                // libsyntax/ext/expand.rs:MacroExpander::expand()\n+                return;\n             }\n         }\n     }"}, {"sha": "4790fa0a7edc2ed430640f4bc0ce21d742ec58b9", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n-pub struct SyntaxContext(u32);\n+pub struct SyntaxContext(pub(super) u32);\n \n #[derive(Copy, Clone, Default)]\n pub struct SyntaxContextData {"}, {"sha": "582f27981813417d7bcd3cd97d45e3441cf5c201", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -25,11 +25,10 @@\n #![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(specialization)]\n-#![feature(staged_api)]\n \n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hasher;\n use std::ops::{Add, Sub};\n@@ -47,6 +46,9 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod hygiene;\n pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n \n+mod span_encoding;\n+pub use span_encoding::{Span, DUMMY_SP};\n+\n pub mod symbol;\n \n pub type FileName = String;\n@@ -59,23 +61,33 @@ pub type FileName = String;\n /// able to use many of the functions on spans in codemap and you cannot assume\n /// that the length of the span = hi - lo; there may be space in the BytePos\n /// range between files.\n+///\n+/// `SpanData` is public because `Span` uses a thread-local interner and can't be\n+/// sent to other threads, but some pieces of performance infra run in a separate thread.\n+/// Using `Span` is generally preferred.\n #[derive(Clone, Copy, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-pub struct Span {\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n+pub struct SpanData {\n     pub lo: BytePos,\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n     pub ctxt: SyntaxContext,\n }\n \n-#[allow(deprecated)]\n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n+// The interner in thread-local, so `Span` shouldn't move between threads.\n+impl !Send for Span {}\n+impl !Sync for Span {}\n+\n+impl PartialOrd for Span {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&self.data(), &rhs.data())\n+    }\n+}\n+impl Ord for Span {\n+    fn cmp(&self, rhs: &Self) -> Ordering {\n+        Ord::cmp(&self.data(), &rhs.data())\n+    }\n+}\n \n /// A collection of spans. Spans have two orthogonal attributes:\n ///\n@@ -90,38 +102,32 @@ pub struct MultiSpan {\n }\n \n impl Span {\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n-        if lo <= hi { Span { lo, hi, ctxt } } else { Span { lo: hi, hi: lo, ctxt } }\n-    }\n-\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn lo(self) -> BytePos {\n-        self.lo\n+        self.data().lo\n     }\n     #[inline]\n     pub fn with_lo(self, lo: BytePos) -> Span {\n-        Span::new(lo, self.hi(), self.ctxt())\n+        let base = self.data();\n+        Span::new(lo, base.hi, base.ctxt)\n     }\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn hi(self) -> BytePos {\n-        self.hi\n+        self.data().hi\n     }\n     #[inline]\n     pub fn with_hi(self, hi: BytePos) -> Span {\n-        Span::new(self.lo(), hi, self.ctxt())\n+        let base = self.data();\n+        Span::new(base.lo, hi, base.ctxt)\n     }\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn ctxt(self) -> SyntaxContext {\n-        self.ctxt\n+        self.data().ctxt\n     }\n     #[inline]\n     pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n-        Span::new(self.lo(), self.hi(), ctxt)\n+        let base = self.data();\n+        Span::new(base.lo, base.hi, ctxt)\n     }\n \n     /// Returns a new span representing just the end-point of this span\n@@ -342,6 +348,12 @@ impl fmt::Debug for Span {\n     }\n }\n \n+impl fmt::Debug for SpanData {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        SPAN_DEBUG.with(|span_debug| span_debug.get()(Span::new(self.lo, self.hi, self.ctxt), f))\n+    }\n+}\n+\n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n         MultiSpan {"}, {"sha": "c2b32171a9a98313c52f6c6bbbe793b59ffd0959", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Spans are encoded using 1-bit tag and 2 different encoding formats (one for each tag value).\n+// One format is used for keeping span data inline,\n+// another contains index into an out-of-line span interner.\n+// The encoding format for inline spans were obtained by optimizing over crates in rustc/libstd.\n+// See https://internals.rust-lang.org/t/rfc-compiler-refactoring-spans/1357/28\n+\n+use {BytePos, SpanData};\n+use hygiene::SyntaxContext;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use std::cell::RefCell;\n+\n+/// A compressed span.\n+/// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n+/// The primary goal of `Span` is to be as small as possible and fit into other structures\n+/// (that's why it uses `packed` as well). Decoding speed is the second priority.\n+/// See `SpanData` for the info on span fields in decoded representation.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[repr(packed)]\n+pub struct Span(u32);\n+\n+/// Dummy span, both position and length are zero, syntax context is zero as well.\n+/// This span is kept inline and encoded with format 0.\n+pub const DUMMY_SP: Span = Span(0);\n+\n+impl Span {\n+    #[inline]\n+    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n+        encode(&match lo <= hi {\n+            true => SpanData { lo, hi, ctxt },\n+            false => SpanData { lo: hi, hi: lo, ctxt },\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn data(self) -> SpanData {\n+        decode(self)\n+    }\n+}\n+\n+// Tags\n+const TAG_INLINE: u32 = 0;\n+const TAG_INTERNED: u32 = 1;\n+const TAG_MASK: u32 = 1;\n+\n+// Fields indexes\n+const BASE_INDEX: usize = 0;\n+const LEN_INDEX: usize = 1;\n+const CTXT_INDEX: usize = 2;\n+\n+// Tag = 0, inline format.\n+// -----------------------------------\n+// | base 31:8  | len 7:1  | tag 0:0 |\n+// -----------------------------------\n+const INLINE_SIZES: [u32; 3] = [24, 7, 0];\n+const INLINE_OFFSETS: [u32; 3] = [8, 1, 1];\n+\n+// Tag = 1, interned format.\n+// ------------------------\n+// | index 31:1 | tag 0:0 |\n+// ------------------------\n+const INTERNED_INDEX_SIZE: u32 = 31;\n+const INTERNED_INDEX_OFFSET: u32 = 1;\n+\n+#[inline]\n+fn encode(sd: &SpanData) -> Span {\n+    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.0);\n+\n+    let val = if (base >> INLINE_SIZES[BASE_INDEX]) == 0 &&\n+                 (len >> INLINE_SIZES[LEN_INDEX]) == 0 &&\n+                 (ctxt >> INLINE_SIZES[CTXT_INDEX]) == 0 {\n+        (base << INLINE_OFFSETS[BASE_INDEX]) | (len << INLINE_OFFSETS[LEN_INDEX]) |\n+        (ctxt << INLINE_OFFSETS[CTXT_INDEX]) | TAG_INLINE\n+    } else {\n+        let index = with_span_interner(|interner| interner.intern(sd));\n+        (index << INTERNED_INDEX_OFFSET) | TAG_INTERNED\n+    };\n+    Span(val)\n+}\n+\n+#[inline]\n+fn decode(span: Span) -> SpanData {\n+    let val = span.0;\n+\n+    // Extract a field at position `pos` having size `size`.\n+    let extract = |pos: u32, size: u32| {\n+        let mask = ((!0u32) as u64 >> (32 - size)) as u32; // Can't shift u32 by 32\n+        (val >> pos) & mask\n+    };\n+\n+    let (base, len, ctxt) = if val & TAG_MASK == TAG_INLINE {(\n+        extract(INLINE_OFFSETS[BASE_INDEX], INLINE_SIZES[BASE_INDEX]),\n+        extract(INLINE_OFFSETS[LEN_INDEX], INLINE_SIZES[LEN_INDEX]),\n+        extract(INLINE_OFFSETS[CTXT_INDEX], INLINE_SIZES[CTXT_INDEX]),\n+    )} else {\n+        let index = extract(INTERNED_INDEX_OFFSET, INTERNED_INDEX_SIZE);\n+        return with_span_interner(|interner| *interner.get(index));\n+    };\n+    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext(ctxt) }\n+}\n+\n+#[derive(Default)]\n+struct SpanInterner {\n+    spans: FxHashMap<SpanData, u32>,\n+    span_data: Vec<SpanData>,\n+}\n+\n+impl SpanInterner {\n+    fn intern(&mut self, span_data: &SpanData) -> u32 {\n+        if let Some(index) = self.spans.get(span_data) {\n+            return *index;\n+        }\n+\n+        let index = self.spans.len() as u32;\n+        self.span_data.push(*span_data);\n+        self.spans.insert(*span_data, index);\n+        index\n+    }\n+\n+    #[inline]\n+    fn get(&self, index: u32) -> &SpanData {\n+        &self.span_data[index as usize]\n+    }\n+}\n+\n+// If an interner exists in TLS, return it. Otherwise, prepare a fresh one.\n+#[inline]\n+fn with_span_interner<T, F: FnOnce(&mut SpanInterner) -> T>(f: F) -> T {\n+    thread_local!(static INTERNER: RefCell<SpanInterner> = {\n+        RefCell::new(SpanInterner::default())\n+    });\n+    INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n+}"}, {"sha": "8733c7436d5bd9658280ab37bfa313d479759a5d", "filename": "src/rtstartup/rsbegin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -38,7 +38,7 @@ trait Copy {}\n trait Freeze {}\n impl Freeze for .. {}\n \n-#[lang=\"drop_in_place\"]\n+#[lang = \"drop_in_place\"]\n #[inline]\n #[allow(unconditional_recursion)]\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {"}, {"sha": "a6aed3540ddbb8b9d092f137a23322d7a9b49201", "filename": "src/rtstartup/rsend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frtstartup%2Frsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frtstartup%2Frsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsend.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -25,7 +25,7 @@ trait Copy {}\n trait Freeze {}\n impl Freeze for .. {}\n \n-#[lang=\"drop_in_place\"]\n+#[lang = \"drop_in_place\"]\n #[inline]\n #[allow(unconditional_recursion)]\n pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {"}, {"sha": "0c04402124a2de290c13d4c2f3b47c9083da6ea7", "filename": "src/rustc/libc_shim/Cargo.toml", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frustc%2Flibc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Frustc%2Flibc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2FCargo.toml?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,16 +1,7 @@\n-# This is a shim Cargo.toml over the \"real Cargo.toml\" found in the libc\n-# repository itself. The purpose for this is to add a build script which prints\n-# out `--cfg stdbuild` to mirror the makefiles' build system.\n-#\n-# Note that other than that this isn't actually needed, and we should probably\n-# remove this shim in favor of just working with cargo features directly with\n-# libc. That should make everything nicer!\n-\n [package]\n name = \"libc\"\n version = \"0.0.0\"\n authors = [\"The Rust Project Developers\"]\n-build = \"build.rs\"\n \n [lib]\n name = \"libc\"\n@@ -20,4 +11,27 @@ bench = false\n doc = false\n \n [dependencies]\n+# Specify the path to libcore; at the time of writing, removing this shim in\n+# favor of using libc from git results in a compilation failure:\n+#\n+# Building stage0 std artifacts (x86_64-apple-darwin -> x86_64-apple-darwin)\n+#    Compiling libc v0.0.0 (file:///Users/tamird/src/rust/src/rustc/libc_shim)\n+# error[E0463]: can't find crate for `core`\n+#\n+# error: aborting due to previous error\n+#\n+# error: Could not compile `libc`.\n+#\n+# Caused by:\n+#   process didn't exit successfully: `/Users/tamird/src/rust/build/bootstrap/debug/rustc --crate-name libc src/rustc/libc_shim/../../liblibc/src/lib.rs --error-format json --crate-type lib --emit=dep-info,link -C opt-level=2 --cfg feature=\"default\" --cfg feature=\"no_std\" --cfg feature=\"stdbuild\" -C metadata=d758f87058112d7d -C extra-filename=-d758f87058112d7d --out-dir /Users/tamird/src/rust/build/x86_64-apple-darwin/stage0-std/x86_64-apple-darwin/release/deps --target x86_64-apple-darwin -L dependency=/Users/tamird/src/rust/build/x86_64-apple-darwin/stage0-std/x86_64-apple-darwin/release/deps -L dependency=/Users/tamird/src/rust/build/x86_64-apple-darwin/stage0-std/release/deps` (exit code: 101)\n+# thread 'main' panicked at 'command did not execute successfully: \"/Users/tamird/src/rust/build/x86_64-apple-darwin/stage0/bin/cargo\" \"build\" \"-j\" \"4\" \"--target\" \"x86_64-apple-darwin\" \"--release\" \"--features\" \"panic-unwind jemalloc backtrace\" \"--manifest-path\" \"/Users/tamird/src/rust/src/libstd/Cargo.toml\" \"--message-format\" \"json\"\n+# expected success, got: exit code: 101', src/bootstrap/compile.rs:883:8\n+#\n+# See https://github.com/rust-lang/rfcs/pull/1133.\n core = { path = \"../../libcore\" }\n+\n+[features]\n+# Certain parts of libc are conditionally compiled differently than when used\n+# outside rustc. See https://github.com/rust-lang/libc/search?l=Rust&q=stdbuild&type=&utf8=%E2%9C%93.\n+stdbuild = []\n+default = [\"stdbuild\"]"}, {"sha": "b2cf66849c75978b50931ef9e1bfc0949a332602", "filename": "src/test/compile-fail/E0506.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0506.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0506.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0506.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n struct FancyNum {\n     num: u8,\n }\n \n fn main() {\n     let mut fancy_num = FancyNum { num: 5 };\n     let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 }; //~ ERROR E0506\n+    fancy_num = FancyNum { num: 6 }; //[ast]~ ERROR E0506\n+                                     //[mir]~^ ERROR (Mir) [E0506]\n+                                     //[mir]~| ERROR (Ast) [E0506]\n \n     println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n }"}, {"sha": "c1bfc5c73a1b37accd40004a3368112b57e0039c", "filename": "src/test/compile-fail/E0586.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0586.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-    let x = &tmp[1...]; //~ ERROR E0586\n+    let x = &tmp[1..=]; //~ ERROR E0586\n }"}, {"sha": "455529b088a2e517a5109faa1a5b2e2bc61a4fdd", "filename": "src/test/compile-fail/E0637.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0637.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2FE0637.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0637.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(underscore_lifetimes)]\n+\n+struct Foo<'a: '_>(&'a u8); //~ ERROR invalid lifetime bound name: `'_`\n+fn foo<'a: '_>(_: &'a u8) {} //~ ERROR invalid lifetime bound name: `'_`\n+\n+struct Bar<'a>(&'a u8);\n+impl<'a: '_> Bar<'a> { //~ ERROR invalid lifetime bound name: `'_`\n+  fn bar() {}\n+}\n+\n+fn main() {}"}, {"sha": "e63de3a3bed7970700afab2c41a2377c3ee5897e", "filename": "src/test/compile-fail/borrowck/borrowck-assign-comp.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-comp.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n struct point { x: isize, y: isize }\n \n fn a() {\n@@ -17,7 +20,9 @@ fn a() {\n     // This assignment is illegal because the field x is not\n     // inherently mutable; since `p` was made immutable, `p.x` is now\n     // immutable.  Otherwise the type of &_q.x (&isize) would be wrong.\n-    p.x = 5; //~ ERROR cannot assign to `p.x`\n+    p.x = 5; //[ast]~ ERROR cannot assign to `p.x`\n+             //[mir]~^ ERROR cannot assign to `p.x` because it is borrowed (Ast)\n+             //[mir]~| ERROR cannot assign to `p.0` because it is borrowed (Mir)\n     q.x;\n }\n \n@@ -27,7 +32,9 @@ fn c() {\n \n     let mut p = point {x: 3, y: 4};\n     let q = &p.y;\n-    p = point {x: 5, y: 7};//~ ERROR cannot assign to `p`\n+    p = point {x: 5, y: 7};//[ast]~ ERROR cannot assign to `p`\n+                           //[mir]~^ ERROR cannot assign to `p` because it is borrowed (Ast)\n+                           //[mir]~| ERROR cannot assign to `p` because it is borrowed (Mir)\n     p.x; // silence warning\n     *q; // stretch loan\n }\n@@ -38,7 +45,9 @@ fn d() {\n \n     let mut p = point {x: 3, y: 4};\n     let q = &p.y;\n-    p.y = 5; //~ ERROR cannot assign to `p.y`\n+    p.y = 5; //[ast]~ ERROR cannot assign to `p.y`\n+             //[mir]~^ ERROR cannot assign to `p.y` because it is borrowed (Ast)\n+             //[mir]~| ERROR cannot assign to `p.1` because it is borrowed (Mir)\n     *q;\n }\n "}, {"sha": "6c003ec2d48b3057f7801caf38050d6d87eac312", "filename": "src/test/compile-fail/borrowck/borrowck-closures-mut-and-imm.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-closures-mut-and-imm.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,6 +11,10 @@\n // Tests that two closures cannot simultaneously have mutable\n // and immutable access to the variable. Issue #6801.\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n #![feature(box_syntax)]\n \n fn get(x: &isize) -> isize {\n@@ -24,37 +28,49 @@ fn set(x: &mut isize) {\n fn a() {\n     let mut x = 3;\n     let c1 = || x = 4;\n-    let c2 = || x * 5; //~ ERROR cannot borrow `x`\n+    let c2 = || x * 5; //[ast]~ ERROR cannot borrow `x`\n+                       //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Ast)\n+                       //[mir]~| ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Mir)\n }\n \n fn b() {\n     let mut x = 3;\n     let c1 = || set(&mut x);\n-    let c2 = || get(&x); //~ ERROR cannot borrow `x`\n+    let c2 = || get(&x); //[ast]~ ERROR cannot borrow `x`\n+                         //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Ast)\n+                         //[mir]~| ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Mir)\n }\n \n fn c() {\n     let mut x = 3;\n     let c1 = || set(&mut x);\n-    let c2 = || x * 5; //~ ERROR cannot borrow `x`\n+    let c2 = || x * 5; //[ast]~ ERROR cannot borrow `x`\n+                       //[mir]~^ ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Ast)\n+                       //[mir]~| ERROR cannot borrow `x` as immutable because it is also borrowed as mutable (Mir)\n }\n \n fn d() {\n     let mut x = 3;\n     let c2 = || x * 5;\n-    x = 5; //~ ERROR cannot assign\n+    x = 5; //[ast]~ ERROR cannot assign\n+           //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast)\n+           //[mir]~| ERROR cannot assign to `x` because it is borrowed (Mir)\n }\n \n fn e() {\n     let mut x = 3;\n     let c1 = || get(&x);\n-    x = 5; //~ ERROR cannot assign\n+    x = 5; //[ast]~ ERROR cannot assign\n+           //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast)\n+           //[mir]~| ERROR cannot assign to `x` because it is borrowed (Mir)\n }\n \n fn f() {\n     let mut x: Box<_> = box 3;\n     let c1 = || get(&*x);\n-    *x = 5; //~ ERROR cannot assign\n+    *x = 5; //[ast]~ ERROR cannot assign\n+            //[mir]~^ ERROR cannot assign to `*x` because it is borrowed (Ast)\n+            //[mir]~| ERROR cannot assign to `(*x)` because it is borrowed (Mir)\n }\n \n fn g() {\n@@ -64,7 +80,9 @@ fn g() {\n \n     let mut x: Box<_> = box Foo { f: box 3 };\n     let c1 = || get(&*x.f);\n-    *x.f = 5; //~ ERROR cannot assign to `*x.f`\n+    *x.f = 5; //[ast]~ ERROR cannot assign to `*x.f`\n+              //[mir]~^ ERROR cannot assign to `*x.f` because it is borrowed (Ast)\n+              //[mir]~| ERROR cannot assign to `(*(*x).0)` because it is borrowed (Mir)\n }\n \n fn h() {\n@@ -74,7 +92,9 @@ fn h() {\n \n     let mut x: Box<_> = box Foo { f: box 3 };\n     let c1 = || get(&*x.f);\n-    let c2 = || *x.f = 5; //~ ERROR cannot borrow `x` as mutable\n+    let c2 = || *x.f = 5; //[ast]~ ERROR cannot borrow `x` as mutable\n+                          //[mir]~^ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable (Ast)\n+                          //[mir]~| ERROR cannot borrow `x` as mutable because it is also borrowed as immutable (Mir)\n }\n \n fn main() {"}, {"sha": "03b6b1d7324006edd8396cfedba10cfe0d1da439", "filename": "src/test/compile-fail/borrowck/borrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-imm-ref-to-mut-rec-field-issue-3162-c.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,11 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn main() {\n     let mut _a = 3;\n     let _b = &mut _a;\n     {\n         let _c = &*_b;\n-        _a = 4; //~ ERROR cannot assign to `_a`\n+        _a = 4; //[ast]~ ERROR cannot assign to `_a`\n+                //[mir]~^ ERROR cannot assign to `_a` because it is borrowed (Ast)\n+                //[mir]~| ERROR cannot assign to `_a` because it is borrowed (Mir)\n     }\n }"}, {"sha": "0e8c003e408f6dcf9e8cd48bebe6ff03913b6f12", "filename": "src/test/compile-fail/borrowck/borrowck-lend-flow-match.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-lend-flow-match.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n #![allow(unused_variables)]\n #![allow(unused_assignments)]\n \n@@ -22,7 +25,9 @@ fn separate_arms() {\n             x = Some(0);\n         }\n         Some(ref __isize) => {\n-            x = Some(1); //~ ERROR cannot assign\n+            x = Some(1); //[ast]~ ERROR cannot assign\n+                         //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast)\n+                         //[mir]~| ERROR cannot assign to `x` because it is borrowed (Mir)\n         }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "3639db5cfc4cd9da88b880ada23fd78ae0408f60", "filename": "src/test/compile-fail/borrowck/borrowck-match-binding-is-assignment.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-binding-is-assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-binding-is-assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-match-binding-is-assignment.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Zemit-end-regions -Zborrowck-mir\n+\n // Test that immutable pattern bindings cannot be reassigned.\n \n #![feature(slice_patterns)]\n@@ -23,31 +26,41 @@ struct S {\n pub fn main() {\n     match 1 {\n         x => {\n-            x += 1; //~ ERROR re-assignment of immutable variable `x`\n+            x += 1; //[ast]~ ERROR re-assignment of immutable variable `x`\n+                    //[mir]~^ ERROR (Mir) [E0384]\n+                    //[mir]~| ERROR (Ast) [E0384]\n         }\n     }\n \n     match E::Foo(1) {\n         E::Foo(x) => {\n-            x += 1; //~ ERROR re-assignment of immutable variable `x`\n+            x += 1; //[ast]~ ERROR re-assignment of immutable variable `x`\n+                    //[mir]~^ ERROR (Mir) [E0384]\n+                    //[mir]~| ERROR (Ast) [E0384]\n         }\n     }\n \n     match (S { bar: 1 }) {\n         S { bar: x } => {\n-            x += 1; //~ ERROR re-assignment of immutable variable `x`\n+            x += 1; //[ast]~ ERROR re-assignment of immutable variable `x`\n+                    //[mir]~^ ERROR (Mir) [E0384]\n+                    //[mir]~| ERROR (Ast) [E0384]\n         }\n     }\n \n     match (1,) {\n         (x,) => {\n-            x += 1; //~ ERROR re-assignment of immutable variable `x`\n+            x += 1; //[ast]~ ERROR re-assignment of immutable variable `x`\n+                    //[mir]~^ ERROR (Mir) [E0384]\n+                    //[mir]~| ERROR (Ast) [E0384]\n         }\n     }\n \n     match [1,2,3] {\n         [x,_,_] => {\n-            x += 1; //~ ERROR re-assignment of immutable variable `x`\n+            x += 1; //[ast]~ ERROR re-assignment of immutable variable `x`\n+                    //[mir]~^ ERROR (Mir) [E0384]\n+                    //[mir]~| ERROR (Ast) [E0384]\n         }\n     }\n }"}, {"sha": "9a39ff6206bfb5b6c0f3a6ef9505bcca29745a09", "filename": "src/test/compile-fail/borrowck/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-fn foo(x: *const Box<isize>) -> Box<isize> {\n-    let y = *x; //~ ERROR dereference of raw pointer requires unsafe function or block\n+unsafe fn foo(x: *const Box<isize>) -> Box<isize> {\n+    let y = *x; //~ ERROR cannot move out of dereference of raw pointer\n     return y;\n }\n "}, {"sha": "9b20cd470f62bc1a783e45dc98f9c5ddcaba094d", "filename": "src/test/compile-fail/borrowck/borrowck-overloaded-index-and-overloaded-deref.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-overloaded-index-and-overloaded-deref.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,6 +13,9 @@\n // operator. The accounting of the all the implicit things going on\n // here is rather subtle. Issue #20232.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n use std::ops::{Deref, Index};\n \n struct MyVec<T> { x: T }\n@@ -39,7 +42,9 @@ fn main() {\n     let mut v = MyVec { x: MyPtr { x: Foo { f: 22 } } };\n     let i = &v[0].f;\n     v = MyVec { x: MyPtr { x: Foo { f: 23 } } };\n-    //~^ ERROR cannot assign to `v`\n+    //[ast]~^ ERROR cannot assign to `v`\n+    //[mir]~^^ ERROR cannot assign to `v` because it is borrowed (Ast)\n+    //[mir]~| ERROR cannot assign to `v` because it is borrowed (Mir)\n     read(*i);\n }\n "}, {"sha": "06bb98fa0ec10f95cae615a459424f6a69da702d", "filename": "src/test/compile-fail/borrowck/borrowck-pat-reassign-binding.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-pat-reassign-binding.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn main() {\n     let mut x: Option<isize> = None;\n     match x {\n@@ -17,7 +20,9 @@ fn main() {\n       }\n       Some(ref i) => {\n           // But on this branch, `i` is an outstanding borrow\n-          x = Some(*i+1); //~ ERROR cannot assign to `x`\n+          x = Some(*i+1); //[ast]~ ERROR cannot assign to `x`\n+                          //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast)\n+                          //[mir]~| ERROR cannot assign to `x` because it is borrowed (Mir)\n       }\n     }\n     x.clone(); // just to prevent liveness warnings"}, {"sha": "73d323ea82cfb227eae2b822c79eebde43af3244", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n \n #[derive(Clone, Copy)]\n union U {\n@@ -30,11 +32,15 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+            let rma = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+                                //[mir]~^ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable (Ast)\n+                                //[mir]~| ERROR cannot borrow `u.0` as mutable because it is also borrowed as immutable (Mir)\n         }\n         {\n             let ra = &u.a;\n-            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n+                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n         }\n         // Imm borrow, other field\n         {\n@@ -47,45 +53,65 @@ fn main() {\n         }\n         {\n             let ra = &u.a;\n-            let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+            let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+                                //[mir]~^ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`) (Ast)\n+                                // FIXME Error for MIR (needs support for union)\n         }\n         {\n             let ra = &u.a;\n-            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed (Ast)\n+                     // FIXME Error for MIR (needs support for union)\n         }\n         // Mut borrow, same field\n         {\n             let rma = &mut u.a;\n-            let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+            let ra = &u.a; //[ast]~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+                         //[mir]~^ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable (Ast)\n+                         //[mir]~| ERROR cannot borrow `u.0` as immutable because it is also borrowed as mutable (Mir)\n         }\n         {\n             let ra = &mut u.a;\n-            let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n+            let a = u.a; //[ast]~ ERROR cannot use `u.a` because it was mutably borrowed\n+                         //[mir]~^ ERROR cannot use `u.a` because it was mutably borrowed (Ast)\n+                         //[mir]~| ERROR cannot use `u.0` because it was mutably borrowed (Mir)\n         }\n         {\n             let rma = &mut u.a;\n-            let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+            let rma2 = &mut u.a; //[ast]~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+                                 //[mir]~^ ERROR cannot borrow `u.a` as mutable more than once at a time (Ast)\n+                                 //[mir]~| ERROR cannot borrow `u.0` as mutable more than once at a time (Mir)\n         }\n         {\n             let rma = &mut u.a;\n-            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n+            u.a = 1; //[ast]~ ERROR cannot assign to `u.a` because it is borrowed\n+                     //[mir]~^ ERROR cannot assign to `u.a` because it is borrowed (Ast)\n+                     //[mir]~| ERROR cannot assign to `u.0` because it is borrowed (Mir)\n         }\n         // Mut borrow, other field\n         {\n             let rma = &mut u.a;\n-            let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+            let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+                           //[mir]~^ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`) (Ast)\n+                           // FIXME Error for MIR (needs support for union)\n         }\n         {\n             let ra = &mut u.a;\n-            let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n+            let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n+                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed (Ast)\n+                         // FIXME Error for MIR (needs support for union)\n         }\n         {\n             let rma = &mut u.a;\n-            let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+            let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+                                 //[mir]~^ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time (Ast)\n+                                 // FIXME Error for MIR (needs support for union)\n         }\n         {\n             let rma = &mut u.a;\n-            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n+            u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed (Ast)\n+                     // FIXME Error for MIR (needs support for union)\n         }\n     }\n }"}, {"sha": "b5916584930b811749c2e47ea0a5d2c1bd44b202", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n #![feature(slice_patterns)]\n \n fn main() {\n@@ -17,7 +20,9 @@ fn main() {\n         _ => unreachable!()\n     };\n     println!(\"t[0]: {}\", t[0]);\n-    a[2] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed\n+    a[2] = 0; //[ast]~ ERROR cannot assign to `a[..]` because it is borrowed\n+              //[mir]~^ ERROR cannot assign to `a[..]` because it is borrowed (Ast)\n+              // FIXME Error for MIR (error missed)\n     println!(\"t[0]: {}\", t[0]);\n     t[0];\n }"}, {"sha": "bf7189c21fbfdfc4a588d5df62a9fd6709da47da", "filename": "src/test/compile-fail/cdylib-deps-must-be-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcdylib-deps-must-be-static.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: dependency `cdylib_dep` not found in rlib format\n+// error-pattern: crate `cdylib_dep` required to be available in rlib format, but was not found\n // aux-build:cdylib-dep.rs\n // ignore-musl\n // ignore-emscripten"}, {"sha": "43b771ce5dbedcfe0152d78384dc86b606e339f0", "filename": "src/test/compile-fail/coerce-overloaded-autoderef.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn borrow_mut<T>(x: &mut T) -> &mut T { x }\n fn borrow<T>(x: &T) -> &T { x }\n \n@@ -17,24 +20,32 @@ fn borrow2<T>(_: &mut T, _: &T) {}\n fn double_mut_borrow<T>(x: &mut Box<T>) {\n     let y = borrow_mut(x);\n     let z = borrow_mut(x);\n-    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+    //[ast]~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+    //[mir]~^^ ERROR cannot borrow `*x` as mutable more than once at a time (Ast)\n+    //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n }\n \n fn double_imm_borrow(x: &mut Box<i32>) {\n     let y = borrow(x);\n     let z = borrow(x);\n     **x += 1;\n-    //~^ ERROR cannot assign to `**x` because it is borrowed\n+    //[ast]~^ ERROR cannot assign to `**x` because it is borrowed\n+    //[mir]~^^ ERROR cannot assign to `**x` because it is borrowed (Ast)\n+    //[mir]~| ERROR cannot assign to `(*(*x))` because it is borrowed (Mir)\n }\n \n fn double_mut_borrow2<T>(x: &mut Box<T>) {\n     borrow_mut2(x, x);\n-    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+    //[ast]~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+    //[mir]~^^ ERROR cannot borrow `*x` as mutable more than once at a time (Ast)\n+    //[mir]~| ERROR cannot borrow `(*x)` as mutable more than once at a time (Mir)\n }\n \n fn double_borrow2<T>(x: &mut Box<T>) {\n     borrow2(x, x);\n-    //~^ ERROR cannot borrow `*x` as immutable because it is also borrowed as mutable\n+    //[ast]~^ ERROR cannot borrow `*x` as immutable because it is also borrowed as mutable\n+    //[mir]~^^ ERROR cannot borrow `*x` as immutable because it is also borrowed as mutable (Ast)\n+    //[mir]~| ERROR cannot borrow `(*x)` as immutable because it is also borrowed as mutable (Mir)\n }\n \n pub fn main() {}"}, {"sha": "1fb139bf07f411fced6eb630d1594edce3b3e6ce", "filename": "src/test/compile-fail/feature-gate-dotdoteq_in_patterns.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dotdoteq_in_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dotdoteq_in_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-dotdoteq_in_patterns.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    match 22 {\n+        0 ..= 3 => {} //~ ERROR `..=` syntax in patterns is experimental\n+        _ => {}\n+    }\n+}"}, {"sha": "9da50c5c8771985bbe9cd9ef3f005722a2e403b7", "filename": "src/test/compile-fail/feature-gate-underscore-lifetimes.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate-underscore-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate-underscore-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-underscore-lifetimes.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(warnings)]\n+struct Foo<'a>(&'a u8);\n \n-// See comments in Cargo.toml for why this exists\n+fn foo(x: &u8) -> Foo<'_> { //~ ERROR underscore lifetimes are unstable\n+    Foo(x)\n+}\n \n fn main() {\n-    println!(\"cargo:rustc-cfg=stdbuild\");\n-    println!(\"cargo:rerun-if-changed=build.rs\");\n+    let x = 5;\n+    let _ = foo(&x);\n }", "previous_filename": "src/rustc/libc_shim/build.rs"}, {"sha": "2dbc6cb140db3f957c01f288516fefdc6f6e72b6", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-derive-2.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,23 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// `#![derive]` is interpreted (and raises errors) when it occurs at\n-// contexts other than ADT definitions. This test checks cases where\n-// the derive-macro does not exist.\n+// This test checks cases where the derive-macro does not exist.\n \n-#![derive(x3300)]\n-//~^ ERROR cannot find derive macro `x3300` in this scope\n-\n-#[derive(x3300)]\n-//~^ ERROR cannot find derive macro `x3300` in this scope\n mod derive {\n-    mod inner { #![derive(x3300)] }\n-    //~^ ERROR cannot find derive macro `x3300` in this scope\n-\n-    #[derive(x3300)]\n-    //~^ ERROR cannot find derive macro `x3300` in this scope\n-    fn derive() { }\n-\n     #[derive(x3300)]\n     //~^ ERROR cannot find derive macro `x3300` in this scope\n     union U { f: i32 }\n@@ -36,12 +22,4 @@ mod derive {\n     #[derive(x3300)]\n     //~^ ERROR cannot find derive macro `x3300` in this scope\n     struct S;\n-\n-    #[derive(x3300)]\n-    //~^ ERROR cannot find derive macro `x3300` in this scope\n-    type T = S;\n-\n-    #[derive(x3300)]\n-    //~^ ERROR cannot find derive macro `x3300` in this scope\n-    impl S { }\n }"}, {"sha": "e5293ebb94ddc8c0161a9147737efdd3385e473e", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-derive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// `#![derive]` is interpreted (and raises errors) when it occurs at\n-// contexts other than ADT definitions. This test checks cases where\n-// the derive-macro exists.\n+// `#![derive]` raises errors when it occurs at contexts other than ADT\n+// definitions.\n \n #![derive(Debug)]\n //~^ ERROR `derive` may only be applied to structs, enums and unions"}, {"sha": "b6216ce05891569fa8e625b57e9860514e821b2c", "filename": "src/test/compile-fail/hrtb-identity-fn-borrows.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,6 +11,9 @@\n // Test that the `'a` in the where clause correctly links the region\n // of the output to the region of the input.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n trait FnLike<A,R> {\n     fn call(&self, arg: A) -> R;\n }\n@@ -21,7 +24,9 @@ fn call_repeatedly<F>(f: F)\n     // Result is stored: cannot re-assign `x`\n     let mut x = 3;\n     let y = f.call(&x);\n-    x = 5; //~ ERROR cannot assign\n+    x = 5; //[ast]~ ERROR cannot assign\n+           //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast)\n+           //[mir]~| ERROR cannot assign to `x` because it is borrowed (Mir)\n \n     // Result is not stored: can re-assign `x`\n     let mut x = 3;"}, {"sha": "e4465e9f6b6115c5451fce0b855472abc7fe67ab", "filename": "src/test/compile-fail/impossible_range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpossible_range.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,12 +18,12 @@ pub fn main() {\n     ..1;\n     0..1;\n \n-    ...; //~ERROR inclusive range with no end\n+    ..=; //~ERROR inclusive range with no end\n          //~^HELP bounded at the end\n-    0...; //~ERROR inclusive range with no end\n+    0..=; //~ERROR inclusive range with no end\n           //~^HELP bounded at the end\n-    ...1;\n-    0...1;\n+    ..=1;\n+    0..=1;\n }\n \n "}, {"sha": "6a5f7a1136aaa7b4b6a8e119d986e34792313928", "filename": "src/test/compile-fail/issue-43023.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fissue-43023.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fissue-43023.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43023.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+impl S {\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    fn f() {\n+        file!();\n+    }\n+}\n+\n+trait Tr1 {\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    fn f();\n+}\n+\n+trait Tr2 {\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    type F;\n+}"}, {"sha": "90ccc589b4ea7378667a788541a1285349209a00", "filename": "src/test/compile-fail/issue-43733.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -9,11 +9,13 @@\n // except according to those terms.\n \n #![feature(const_fn)]\n+#![feature(thread_local)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n type Foo = std::cell::RefCell<String>;\n \n #[cfg(target_thread_local)]\n+#[thread_local]\n static __KEY: std::thread::__FastLocalKeyInner<Foo> =\n     std::thread::__FastLocalKeyInner::new();\n \n@@ -25,7 +27,7 @@ fn __getit() -> std::option::Option<\n     &'static std::cell::UnsafeCell<\n         std::option::Option<Foo>>>\n {\n-    __KEY.get() //~ ERROR  invocation of unsafe method requires unsafe\n+    __KEY.get() //~ ERROR call to unsafe function requires unsafe\n }\n \n static FOO: std::thread::LocalKey<Foo> ="}, {"sha": "30411bf878909448ea925a96032ec7639d2724d3", "filename": "src/test/compile-fail/label-underscore.rs", "status": "renamed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Flabel-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Flabel-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flabel-underscore.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,12 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn _f<'_>() //~ ERROR invalid lifetime name `'_`\n-    -> &'_ u8 //~ ERROR invalid lifetime name `'_`\n-{\n-    panic!();\n-}\n-\n fn main() {\n     '_: loop { //~ ERROR invalid label name `'_`\n         break '_ //~ ERROR invalid label name `'_`", "previous_filename": "src/test/compile-fail/lifetime-underscore.rs"}, {"sha": "de455afbd6629d73b4cc9fa265dc43528b800d07", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -107,6 +107,7 @@ mod cross_crate {\n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n         //~^ WARN use of deprecated item\n+        //~| WARN use of deprecated item\n \n         let _ = DeprecatedStruct { //~ WARN use of deprecated item\n             i: 0 //~ WARN use of deprecated item"}, {"sha": "3a84bd6565e8d10823fd69cf6298a1eb4b20cb49", "filename": "src/test/compile-fail/mut-pattern-internal-mutability.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-pattern-internal-mutability.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,17 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn main() {\n     let foo = &mut 1;\n \n     let &mut x = foo;\n-    x += 1; //~ ERROR re-assignment of immutable variable\n+    x += 1; //[ast]~ ERROR re-assignment of immutable variable\n+            //[mir]~^ ERROR re-assignment of immutable variable `x` (Ast)\n+            //[mir]~| ERROR re-assignment of immutable variable `x` (Mir)\n \n     // explicitly mut-ify internals\n     let &mut mut x = foo;\n     x += 1;\n \n     // check borrowing is detected successfully\n     let &mut ref x = foo;\n-    *foo += 1; //~ ERROR cannot assign to `*foo` because it is borrowed\n+    *foo += 1; //[ast]~ ERROR cannot assign to `*foo` because it is borrowed\n+               //[mir]~^ ERROR cannot assign to `*foo` because it is borrowed (Ast)\n+               //[mir]~| ERROR cannot assign to `(*foo)` because it is borrowed (Mir)\n }"}, {"sha": "54657e76e97022be4e70a5ce58d7c1eab073a334", "filename": "src/test/compile-fail/object-lifetime-default-mybox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-mybox.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -34,7 +34,7 @@ fn load1<'a,'b>(a: &'a MyBox<SomeTrait>,\n                 b: &'b MyBox<SomeTrait>)\n                 -> &'b MyBox<SomeTrait>\n {\n-    a //~ ERROR E0312\n+    a //~ ERROR lifetime mismatch\n }\n \n fn load2<'a>(ss: &MyBox<SomeTrait+'a>) -> MyBox<SomeTrait+'a> {"}, {"sha": "973d467b1122670184cbee8cf5e345b6ac899b22", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -103,10 +103,11 @@ mod adjust {\n \n fn main() {\n     let _: m::Alias; //~ ERROR type `m::Priv` is private\n-    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; // FIXME\n+                     //~^ ERROR type `m::Priv` is private\n+    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; //~ ERROR type `m::Priv` is private\n     m::Alias {}; //~ ERROR type `m::Priv` is private\n     m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n-    m::Pub { 0: loop {} }; // FIXME\n+    m::Pub { 0: loop {} }; // OK, `m::Pub` is in value context, so it means Pub<_>, not Pub<Priv>\n     m::Pub::static_method; //~ ERROR type `m::Priv` is private\n     m::Pub::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n     m::Pub(0u8).method_with_substs::<m::Alias>(); //~ ERROR type `m::Priv` is private"}, {"sha": "eb8c40a7dd5e821b0436334be6a073b900dfd1b6", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -31,7 +31,6 @@ fn f_ext(_: ext::Alias) {} //~ ERROR type `ext::Priv` is private\n trait Tr1 {}\n impl m::Alias {} //~ ERROR type `m::Priv` is private\n impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n-                           //~^ ERROR type `ext::Priv` is private\n type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n \n trait Tr2<T> {}"}, {"sha": "69b9a4c67adc3bc253d54d240b5d9976e0c11894", "filename": "src/test/compile-fail/range_inclusive_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_inclusive_gate.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -14,7 +14,7 @@\n // #![feature(inclusive_range)]\n \n pub fn main() {\n-    let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ... { use std::intrinsics; 2 };\n+    let _: std::ops::RangeInclusive<_> = { use std::intrinsics; 1 } ..= { use std::intrinsics; 2 };\n     //~^ ERROR use of unstable library feature 'inclusive_range'\n     //~| ERROR core_intrinsics\n     //~| ERROR core_intrinsics"}, {"sha": "91f5f048bc1c05676f45c21b8d3956066558f8b2", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19997.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,13 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn main() {\n     let a0 = 0;\n     let f = 1;\n     let mut a1 = &a0;\n     match (&a1,) {\n         (&ref b0,) => {\n-            a1 = &f; //~ ERROR cannot assign\n+            a1 = &f; //[ast]~ ERROR cannot assign\n+                     //[mir]~^ ERROR cannot assign to `a1` because it is borrowed (Ast)\n+                     //[mir]~| ERROR cannot assign to `a1` because it is borrowed (Mir)\n         }\n     }\n }"}, {"sha": "a61ff05e8c8b5c37bf7664453704df7f67b775a2", "filename": "src/test/compile-fail/rmeta_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:rmeta_meta.rs\n // no-prefer-dynamic\n-// error-pattern: crate `rmeta_meta` required to be available in rlib, but it was not available\n+// error-pattern: crate `rmeta_meta` required to be available in rlib format, but was not found\n \n // Check that building a non-metadata crate fails if a dependent crate is\n // metadata-only."}, {"sha": "a9762e383fe4e52e41dd3ea179f06c3e01e11975", "filename": "src/test/compile-fail/synthetic-param.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fsynthetic-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Fsynthetic-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsynthetic-param.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(generic_param_attrs, rustc_attrs)]\n+\n+fn func<#[rustc_synthetic] T>(_: T) {}\n+\n+struct Foo;\n+\n+impl Foo {\n+    pub fn func<#[rustc_synthetic] T>(_: T) {}\n+}\n+\n+struct Bar<S> {\n+    t: S\n+}\n+\n+impl<S> Bar<S> {\n+    pub fn func<#[rustc_synthetic] T>(_: T) {}\n+}\n+\n+fn main() {\n+    func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    func(42); // Ok\n+\n+    Foo::func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    Foo::func(42); // Ok\n+\n+    Bar::<i8>::func::<u8>(42); //~ ERROR cannot provide explicit type parameters\n+    Bar::<i8>::func(42); // Ok\n+}"}, {"sha": "8f26777b441d4e5849befc3c6fa855f053501db0", "filename": "src/test/compile-fail/type-path-err-node-types.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type arguments of unresolved types should have their types recorded\n+\n+fn main() {\n+    let _: Nonexistent<u8, Assoc = u16>; //~ ERROR cannot find type `Nonexistent` in this scope\n+\n+    let _ = |a, b: _| -> _ { 0 };\n+}"}, {"sha": "99b6e036f33ea976bd6701dc8b3c1c6bf734eae0", "filename": "src/test/compile-fail/underscore-lifetime-binders.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-binders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-binders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-binders.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(underscore_lifetimes)]\n+\n+struct Foo<'a>(&'a u8);\n+struct Baz<'a>(&'_ &'a u8); //~ ERROR missing lifetime specifier\n+\n+impl Foo<'_> { //~ ERROR missing lifetime specifier\n+    fn x() {}\n+}\n+\n+fn foo<'_> //~ ERROR invalid lifetime parameter name: `'_`\n+(_: Foo<'_>) {}\n+\n+trait Meh<'a> {}\n+impl<'a> Meh<'a> for u8 {}\n+\n+fn meh() -> Box<for<'_> Meh<'_>> //~ ERROR invalid lifetime parameter name: `'_`\n+//~^ ERROR missing lifetime specifier\n+//~^^ ERROR missing lifetime specifier\n+{\n+  Box::new(5u8)\n+}\n+\n+fn foo2(_: &'_ u8, y: &'_ u8) -> &'_ u8 { y } //~ ERROR missing lifetime specifier\n+\n+fn main() {\n+    let x = 5;\n+    foo(Foo(&x));\n+    let _ = meh();\n+}"}, {"sha": "a1c4e4a1fd93536e949b273ac8219d6cc3702055", "filename": "src/test/compile-fail/underscore-lifetime-elison-mismatch.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-elison-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-elison-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funderscore-lifetime-elison-mismatch.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(underscore_lifetimes)]\n+\n+fn foo(x: &mut Vec<&'_ u8>, y: &'_ u8) { x.push(y); } //~ ERROR lifetime mismatch\n+\n+fn main() {}"}, {"sha": "e57d65dcb891f7b5b1439969f12ac5e80e617be9", "filename": "src/test/compile-fail/union/union-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -42,8 +42,8 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field requires unsafe\n     u1.a = 11; // OK\n-    let U1 { a } = u1; //~ ERROR matching on union field requires unsafe\n-    if let U1 { a: 12 } = u1 {} //~ ERROR matching on union field requires unsafe\n+    let U1 { a } = u1; //~ ERROR access to union field requires unsafe\n+    if let U1 { a: 12 } = u1 {} //~ ERROR access to union field requires unsafe\n     // let U1 { .. } = u1; // OK\n \n     let mut u2 = U2 { a: String::from(\"old\") }; // OK"}, {"sha": "f30da250f6ac80f2eb8a0ec66d429a4d17c6d077", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -9,7 +10,7 @@\n // except according to those terms.\n \n \n-fn f(p: *const u8) {\n+fn f(p: *mut u8) {\n     *p = 0; //~ ERROR dereference of raw pointer requires unsafe function or block\n     return;\n }"}, {"sha": "84a8c84a0dbd203ae46cf6ca2e64a06e097b4fb6", "filename": "src/test/compile-fail/unsafe-move-val-init.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics;\n+\n+// `move_val_init` has an odd desugaring, check that it is still treated\n+// as unsafe.\n+fn main() {\n+    intrinsics::move_val_init(1 as *mut u32, 1);\n+    //~^ ERROR dereference of raw pointer requires unsafe function or block\n+}"}, {"sha": "355983e9ca1b9e53f3a8795d64087732ba458b41", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags:-Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "d58a9bacdb53ca4c7ed10f500ea7b65257cc8815", "filename": "src/test/incremental/change_private_fn_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fstruct_point.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "3f665f5c82052da07458916a2a5231583c5bec64", "filename": "src/test/incremental/change_private_impl_method_cc/struct_point.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fstruct_point.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,6 +15,8 @@\n // compile-flags: -Z query-dep-graph\n // aux-build:point.rs\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![allow(dead_code)]"}, {"sha": "6d54cf53660a9ce62e75c3e9fa78879cc04a7249", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -37,14 +37,14 @@ mod y {\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n     pub fn y() {\n-        //[cfail2]~^ ERROR `TypeckTables(y::y)` not found in dep graph, but should be clean\n+        //[cfail2]~^ ERROR `TypeckTables(y::y)` should be clean but is not\n         x::x();\n     }\n }\n \n mod z {\n     #[rustc_dirty(label=\"TypeckTables\", cfg=\"cfail2\")]\n     pub fn z() {\n-        //[cfail2]~^ ERROR `TypeckTables(z::z)` found in dep graph, but should be dirty\n+        //[cfail2]~^ ERROR `TypeckTables(z::z)` should be dirty but is not\n     }\n }"}, {"sha": "8f84266d5a4e5f7037ff4808780a6d05cb4a7034", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -143,7 +143,7 @@ enum EnumChangeValueCStyleVariant1 {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_clean(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]"}, {"sha": "a12624d083248db39badc601bfc7e4c2859659cc", "filename": "src/test/incremental/hashes/indexing_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Findexing_expressions.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -153,5 +153,5 @@ fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n #[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn exclusive_to_inclusive_range(slice: &[u32]) -> &[u32] {\n-    &slice[3...7]\n+    &slice[3..=7]\n }"}, {"sha": "39065d9671ace089b3736c11403e75b6835faf48", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -18,6 +18,8 @@\n // no-prefer-dynamic\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "760975b292f95fc01bfc64fc41b679354e76b6e3", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -27,7 +27,8 @@ mod x {\n     }\n \n     #[cfg(rpass2)]\n-    #[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn x() {\n         println!(\"{}\", \"2\");\n     }\n@@ -37,6 +38,7 @@ mod y {\n     use x;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn y() {\n         x::x();\n     }\n@@ -46,6 +48,7 @@ mod z {\n     use y;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"MirOptimized\", cfg=\"rpass2\")]\n     pub fn z() {\n         y::y();\n     }"}, {"sha": "e5ec9784847f0b4c5882a04441f0974aed7dda62", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "63e1437f0687be4398da2d6805e111ed77afac69", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -12,6 +12,8 @@\n // revisions:rpass1 rpass2 rpass3\n // compile-flags: -Z query-dep-graph\n \n+// ignore-test -- ignored until red/green restores cross-crate tracking fidelity\n+\n #![feature(rustc_attrs)]\n \n extern crate a;"}, {"sha": "857a3924aec01e8c69dade08869a98d8b2ed28d5", "filename": "src/test/parse-fail/pat-ranges-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-1.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let macropus!() ... 11 = 12; //~ error: expected one of `:`, `;`, or `=`, found `...`\n+    let macropus!() ..= 11 = 12; //~ error: expected one of `:`, `;`, or `=`, found `..=`\n }"}, {"sha": "64c749333cf4acc68307f2aa17b9b3e386e5d56f", "filename": "src/test/parse-fail/pat-ranges-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-2.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 ... makropulos!() = 12; //~ error: expected one of `::`, `:`, `;`, or `=`, found `!`\n+    let 10 ..= makropulos!() = 12; //~ error: expected one of `::`, `:`, `;`, or `=`, found `!`\n }"}, {"sha": "1327a9fab366180ca80f2ca6f1215de0b2087796", "filename": "src/test/parse-fail/pat-ranges-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-3.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,5 +11,5 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 ... 10 + 3 = 12; //~ expected one of `:`, `;`, or `=`, found `+`\n+    let 10 ..= 10 + 3 = 12; //~ expected one of `:`, `;`, or `=`, found `+`\n }"}, {"sha": "c159c7702502d5127cd2370641894ca38b9ceacf", "filename": "src/test/parse-fail/pat-ranges-4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-ranges-4.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -11,5 +11,6 @@\n // Parsing of range patterns\n \n fn main() {\n-    let 10 - 3 ... 10 = 8; //~ error: expected one of `...`, `..`, `:`, `;`, or `=`, found `-`\n+    let 10 - 3 ..= 10 = 8;\n+    //~^ error: expected one of `...`, `..=`, `..`, `:`, `;`, or `=`, found `-`\n }"}, {"sha": "cc32b9903b5acc81141d430c6863af5c15c6a4f4", "filename": "src/test/parse-fail/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -13,7 +13,7 @@\n #![feature(inclusive_range_syntax, inclusive_range)]\n \n pub fn main() {\n-    for _ in 1... {} //~ERROR inclusive range with no end\n+    for _ in 1..= {} //~ERROR inclusive range with no end\n                      //~^HELP bounded at the end\n }\n "}, {"sha": "de690c3fea3cf4ce5193bd475a3d63c19dab5e61", "filename": "src/test/parse-fail/range_inclusive_gate.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Frange_inclusive_gate.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -15,21 +15,21 @@\n // #![feature(inclusive_range_syntax, inclusive_range)]\n \n macro_rules! m {\n-    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+    () => { for _ in 1..=10 {} } //~ ERROR inclusive range syntax is experimental\n }\n \n #[cfg(nope)]\n fn f() {}\n #[cfg(not(nope))]\n fn f() {\n-    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n }\n \n #[cfg(nope)]\n macro_rules! n { () => {} }\n #[cfg(not(nope))]\n macro_rules! n {\n-    () => { for _ in 1...10 {} } //~ ERROR inclusive range syntax is experimental\n+    () => { for _ in 1..=10 {} } //~ ERROR inclusive range syntax is experimental\n }\n \n macro_rules! o {\n@@ -38,7 +38,7 @@ macro_rules! o {\n         fn g() {}\n         #[cfg(not(nope))]\n         fn g() {\n-            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+            for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n         }\n \n         g();\n@@ -54,16 +54,16 @@ macro_rules! p {\n         fn h() {}\n         #[cfg(not(nope))]\n         fn h() {\n-            for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n+            for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n         }\n \n         h();\n     }}\n }\n \n pub fn main() {\n-    for _ in 1...10 {} //~ ERROR inclusive range syntax is experimental\n-    for _ in ...10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in 1..=10 {} //~ ERROR inclusive range syntax is experimental\n+    for _ in ..=10 {} //~ ERROR inclusive range syntax is experimental\n \n     f(); // not allowed in cfg'ed functions\n "}, {"sha": "755e211a349966c568f63389840d1bceab6bf62b", "filename": "src/test/run-make/codegen-options-parsing/Makefile", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -1,26 +1,28 @@\n -include ../tools.mk\n \n+LOG = $(TMPDIR)/log.txt\n+\n all:\n \t#Option taking a number\n-\t$(RUSTC) -C codegen-units dummy.rs 2>&1 | \\\n-\t\tgrep 'codegen option `codegen-units` requires a number'\n-\t$(RUSTC) -C codegen-units= dummy.rs 2>&1 | \\\n-\t\tgrep 'incorrect value `` for codegen option `codegen-units` - a number was expected'\n-\t$(RUSTC) -C codegen-units=foo dummy.rs 2>&1 | \\\n-\t\tgrep 'incorrect value `foo` for codegen option `codegen-units` - a number was expected'\n+\t$(RUSTC) -C codegen-units dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'codegen option `codegen-units` requires a number' $(LOG)\n+\t$(RUSTC) -C codegen-units= dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'incorrect value `` for codegen option `codegen-units` - a number was expected' $(LOG)\n+\t$(RUSTC) -C codegen-units=foo dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'incorrect value `foo` for codegen option `codegen-units` - a number was expected' $(LOG)\n \t$(RUSTC) -C codegen-units=1 dummy.rs\n \t#Option taking a string\n-\t$(RUSTC) -C extra-filename dummy.rs 2>&1 | \\\n-\t\tgrep 'codegen option `extra-filename` requires a string'\n+\t$(RUSTC) -C extra-filename dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'codegen option `extra-filename` requires a string' $(LOG)\n \t$(RUSTC) -C extra-filename= dummy.rs 2>&1\n \t$(RUSTC) -C extra-filename=foo dummy.rs 2>&1\n \t#Option taking no argument\n-\t$(RUSTC) -C lto= dummy.rs 2>&1 | \\\n-\t\tgrep 'codegen option `lto` takes no value'\n-\t$(RUSTC) -C lto=1 dummy.rs 2>&1 | \\\n-\t\tgrep 'codegen option `lto` takes no value'\n-\t$(RUSTC) -C lto=foo dummy.rs 2>&1 | \\\n-\t\tgrep 'codegen option `lto` takes no value'\n+\t$(RUSTC) -C lto= dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'codegen option `lto` takes no value' $(LOG)\n+\t$(RUSTC) -C lto=1 dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'codegen option `lto` takes no value' $(LOG)\n+\t$(RUSTC) -C lto=foo dummy.rs 2>&1 | tee $(LOG)\n+\tgrep 'codegen option `lto` takes no value' $(LOG)\n \t$(RUSTC) -C lto dummy.rs\n \n \t# Should not link dead code..."}, {"sha": "2ff4593a801fe74601708e30d9ea0d79a87edf32", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -77,6 +77,7 @@ fn main() {\n         .split(' ').map(|s| s.to_string()).collect();\n     args.push(\"--out-dir\".to_string());\n     args.push(env::var(\"TMPDIR\").unwrap());\n+    args.push(\"-Ccodegen-units=1\".to_string());\n \n     let (result, _) = rustc_driver::run_compiler(\n         &args, &mut JitCalls, Some(box JitLoader), None);"}, {"sha": "5a28d756df5a55e151d99a51750d506d78bb9326", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-cfg.rs", "status": "renamed", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c853adce9103b8bc84cd6b0026bcdc2eed7da31/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-cfg.rs?ref=4c853adce9103b8bc84cd6b0026bcdc2eed7da31", "patch": "@@ -8,18 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<F: Fn(usize)>(x: F) { }\n+// aux-build:attr-cfg.rs\n+// ignore-stage1\n+// revisions: foo bar\n \n+#![feature(proc_macro)]\n+\n+extern crate attr_cfg;\n+use attr_cfg::attr_cfg;\n+\n+#[attr_cfg]\n+fn outer() -> u8 {\n+    #[cfg(foo)]\n+    fn inner() -> u8 { 1 }\n+\n+    #[cfg(bar)]\n+    fn inner() -> u8 { 2 }\n+\n+    inner()\n+}\n+\n+#[cfg(foo)]\n+fn main() {\n+    assert_eq!(outer(), 1);\n+}\n+\n+#[cfg(bar)]\n fn main() {\n-    foo(|y: String| { });\n-    //~^ ERROR E0281\n-    //~| ERROR E0281\n-    //~| NOTE implements\n-    //~| NOTE implements\n-    //~| NOTE requires\n-    //~| NOTE requires\n-    //~| NOTE expected usize, found struct `std::string::String`\n-    //~| NOTE expected usize, found struct `std::string::String`\n-    //~| NOTE required by `foo`\n-    //~| NOTE required by `foo`\n+    assert_eq!(outer(), 2);\n }", "previous_filename": "src/test/ui/mismatched_types/E0281.rs"}]}