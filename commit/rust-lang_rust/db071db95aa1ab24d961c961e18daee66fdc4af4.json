{"sha": "db071db95aa1ab24d961c961e18daee66fdc4af4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMDcxZGI5NWFhMWFiMjRkOTYxYzk2MWUxOGRhZWU2NmZkYzRhZjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T11:01:55Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-08-14T11:01:55Z"}, "message": "Calculate sign in trans{,_checked}_int_binop instead of caller", "tree": {"sha": "b99aabafeecff192ed3ed2c8f3ef590227698127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b99aabafeecff192ed3ed2c8f3ef590227698127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db071db95aa1ab24d961c961e18daee66fdc4af4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db071db95aa1ab24d961c961e18daee66fdc4af4", "html_url": "https://github.com/rust-lang/rust/commit/db071db95aa1ab24d961c961e18daee66fdc4af4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db071db95aa1ab24d961c961e18daee66fdc4af4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32cb5b8c8ef6ea3dd782bd72f57d3a0981581a3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32cb5b8c8ef6ea3dd782bd72f57d3a0981581a3d", "html_url": "https://github.com/rust-lang/rust/commit/32cb5b8c8ef6ea3dd782bd72f57d3a0981581a3d"}], "stats": {"total": 59, "additions": 17, "deletions": 42}, "files": [{"sha": "26dfb1548daa1165a20020a8051a538b23d3d87a", "filename": "src/base.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=db071db95aa1ab24d961c961e18daee66fdc4af4", "patch": "@@ -261,40 +261,33 @@ fn trans_stmt<'a, 'tcx: 'a>(\n                     place.write_place_ref(fx, lval);\n                 }\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n-                    let ty = fx.monomorphize(&lhs.ty(fx.mir, fx.tcx));\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n-                    let res = match ty.sty {\n+                    let res = match lhs.layout().ty.sty {\n                         ty::Bool => crate::num::trans_bool_binop(fx, *bin_op, lhs, rhs),\n-                        ty::Uint(_) => {\n-                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, false)\n-                        }\n-                        ty::Int(_) => {\n-                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, true)\n+                        ty::Uint(_) | ty::Int(_ )=> {\n+                            crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n                         ty::Float(_) => crate::num::trans_float_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n                         ty::Char => crate::num::trans_char_binop(fx, *bin_op, lhs, rhs, lval.layout().ty),\n                         ty::RawPtr(..) | ty::FnPtr(..) => {\n                             crate::num::trans_ptr_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                         }\n-                        _ => unimplemented!(\"binop {:?} for {:?}\", bin_op, ty),\n+                        _ => unimplemented!(\"{:?}({:?}, {:?})\", bin_op, lhs.layout().ty, rhs.layout().ty),\n                     };\n                     lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n-                    let ty = fx.monomorphize(&lhs.ty(fx.mir, fx.tcx));\n                     let lhs = trans_operand(fx, lhs);\n                     let rhs = trans_operand(fx, rhs);\n \n-                    let signed = type_sign(ty);\n-\n                     let res = if !fx.tcx.sess.overflow_checks() {\n-                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty, signed).load_scalar(fx);\n+                        let val = crate::num::trans_int_binop(fx, *bin_op, lhs, rhs, lhs.layout().ty).load_scalar(fx);\n                         let is_overflow = fx.bcx.ins().iconst(types::I8, 0);\n                         CValue::by_val_pair(val, is_overflow, lval.layout())\n                     } else {\n-                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty, signed)\n+                        crate::num::trans_checked_int_binop(fx, *bin_op, lhs, rhs, lval.layout().ty)\n                     };\n \n                     lval.write_cvalue(fx, res);"}, {"sha": "6fdd3042c52688255d27816e640ee2b3d4f7e5b0", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=db071db95aa1ab24d961c961e18daee66fdc4af4", "patch": "@@ -6,7 +6,6 @@ pub fn maybe_codegen<'a, 'tcx>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     bin_op: BinOp,\n     checked: bool,\n-    is_signed: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n     out_ty: Ty<'tcx>,\n@@ -18,6 +17,8 @@ pub fn maybe_codegen<'a, 'tcx>(\n     let lhs_val = lhs.load_scalar(fx);\n     let rhs_val = rhs.load_scalar(fx);\n \n+    let is_signed = type_sign(lhs.layout().ty);\n+\n     match bin_op {\n         BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => {\n             assert!(!checked);"}, {"sha": "45f8d82448e6b86f427cc746f215a26f8e9409ad", "filename": "src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=db071db95aa1ab24d961c961e18daee66fdc4af4", "patch": "@@ -446,28 +446,10 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 \"unchecked_shr\" => BinOp::Shr,\n                 _ => unimplemented!(\"intrinsic {}\", intrinsic),\n             };\n-            let res = match ret.layout().ty.sty {\n-                ty::Uint(_) => crate::num::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    false,\n-                ),\n-                ty::Int(_) => crate::num::trans_int_binop(\n-                    fx,\n-                    bin_op,\n-                    x,\n-                    y,\n-                    ret.layout().ty,\n-                    true,\n-                ),\n-                _ => panic!(),\n-            };\n+            let res = crate::num::trans_int_binop(fx, bin_op, x, y, ret.layout().ty);\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.ends_with(\"_with_overflow\"), <T> (c x, c y) {\n+        _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n             assert_eq!(x.layout().ty, y.layout().ty);\n             let bin_op = match intrinsic {\n                 \"add_with_overflow\" => BinOp::Add,\n@@ -482,11 +464,10 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 x,\n                 y,\n                 ret.layout().ty,\n-                type_sign(T),\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"overflowing_\"), <T> (c x, c y) {\n+        _ if intrinsic.starts_with(\"overflowing_\"), (c x, c y) {\n             assert_eq!(x.layout().ty, y.layout().ty);\n             let bin_op = match intrinsic {\n                 \"overflowing_add\" => BinOp::Add,\n@@ -500,7 +481,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 x,\n                 y,\n                 ret.layout().ty,\n-                type_sign(T),\n             );\n             ret.write_cvalue(fx, res);\n         };\n@@ -520,7 +500,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n                 x,\n                 y,\n                 fx.tcx.mk_tup([T, fx.tcx.types.bool].into_iter()),\n-                signed,\n             );\n \n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);"}, {"sha": "9210c040ff377f95577a1236ebcd3c70d218ebff", "filename": "src/num.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db071db95aa1ab24d961c961e18daee66fdc4af4/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=db071db95aa1ab24d961c961e18daee66fdc4af4", "patch": "@@ -78,7 +78,6 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n     out_ty: Ty<'tcx>,\n-    signed: bool,\n ) -> CValue<'tcx> {\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n@@ -93,10 +92,12 @@ pub fn trans_int_binop<'a, 'tcx: 'a>(\n         _ => unreachable!(\"Out ty {:?} is not an integer or bool\", out_ty),\n     }\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, signed, lhs, rhs, out_ty) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, lhs, rhs, out_ty) {\n         return res;\n     }\n \n+    let signed = type_sign(lhs.layout().ty);\n+\n     let (lhs, rhs) = if\n         (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n         && (lhs.layout().ty.sty == fx.tcx.types.i8.sty || lhs.layout().ty.sty == fx.tcx.types.i16.sty)\n@@ -149,7 +150,6 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n     out_ty: Ty<'tcx>,\n-    signed: bool,\n ) -> CValue<'tcx> {\n     if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n         assert_eq!(\n@@ -162,10 +162,12 @@ pub fn trans_checked_int_binop<'a, 'tcx: 'a>(\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, signed, in_lhs, in_rhs, out_ty) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs, out_ty) {\n         return res;\n     }\n \n+    let signed = type_sign(in_lhs.layout().ty);\n+\n     let (res, has_overflow) = match bin_op {\n         BinOp::Add => {\n             /*let (val, c_out) = fx.bcx.ins().iadd_cout(lhs, rhs);"}]}