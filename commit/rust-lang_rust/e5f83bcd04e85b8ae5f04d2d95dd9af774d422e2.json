{"sha": "e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZjgzYmNkMDRlODViOGFlNWYwNGQyZDk1ZGQ5YWY3NzRkNDIyZTI=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-08-12T22:39:15Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-10-07T20:40:52Z"}, "message": "Detect blocks that could be struct expr bodies\n\nThis approach lives exclusively in the parser, so struct expr bodies\nthat are syntactically correct on their own but are otherwise incorrect\nwill still emit confusing errors, like in the following case:\n\n```rust\nfn foo() -> Foo {\n    bar: Vec::new()\n}\n```\n\n```\nerror[E0425]: cannot find value `bar` in this scope\n --> src/file.rs:5:5\n  |\n5 |     bar: Vec::new()\n  |     ^^^ expecting a type here because of type ascription\n\nerror[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n --> src/file.rs:5:15\n  |\n5 |     bar: Vec::new()\n  |               ^^^^^ only `Fn` traits may use parentheses\n\nerror[E0107]: wrong number of type arguments: expected 1, found 0\n --> src/file.rs:5:10\n  |\n5 |     bar: Vec::new()\n  |          ^^^^^^^^^^ expected 1 type argument\n  ```\n\nIf that field had a trailing comma, that would be a parse error and it\nwould trigger the new, more targetted, error:\n\n```\nerror: struct literal body without path\n --> file.rs:4:17\n  |\n4 |   fn foo() -> Foo {\n  |  _________________^\n5 | |     bar: Vec::new(),\n6 | | }\n  | |_^\n  |\nhelp: you might have forgotten to add the struct literal inside the block\n  |\n4 | fn foo() -> Foo { Path {\n5 |     bar: Vec::new(),\n6 | } }\n  |\n```\n\nPartially address last part of #34255.", "tree": {"sha": "91a55ddfa401d3de3caa3930c232dcf43aa3c6c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91a55ddfa401d3de3caa3930c232dcf43aa3c6c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "html_url": "https://github.com/rust-lang/rust/commit/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deec53052312ac709f6a37110b59ada486bea0bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/deec53052312ac709f6a37110b59ada486bea0bd", "html_url": "https://github.com/rust-lang/rust/commit/deec53052312ac709f6a37110b59ada486bea0bd"}], "stats": {"total": 200, "additions": 183, "deletions": 17}, "files": [{"sha": "0b43225a242f709d37b3193ef51471c1d2ae8a63", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{struct_span_err, Applicability, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::Parser;\n+use rustc_parse::parser::{AttemptLocalParseRecovery, Parser};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -921,7 +921,7 @@ pub fn parse_ast_fragment<'a>(\n             let mut stmts = SmallVec::new();\n             // Won't make progress on a `}`.\n             while this.token != token::Eof && this.token != token::CloseDelim(token::Brace) {\n-                if let Some(stmt) = this.parse_full_stmt()? {\n+                if let Some(stmt) = this.parse_full_stmt(AttemptLocalParseRecovery::Yes)? {\n                     stmts.push(stmt);\n                 }\n             }"}, {"sha": "1ea01d95a134e09ae47eac2bc5f6f593f9a09122", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 2, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -5,8 +5,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n-    self as ast, AngleBracketedArgs, AttrVec, BinOpKind, BindingMode, BlockCheckMode, Expr,\n-    ExprKind, Item, ItemKind, Mutability, Param, Pat, PatKind, PathSegment, QSelf, Ty, TyKind,\n+    self as ast, AngleBracketedArgs, AttrVec, BinOpKind, BindingMode, Block, BlockCheckMode, Expr,\n+    ExprKind, Item, ItemKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QSelf, Ty,\n+    TyKind,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -119,6 +120,28 @@ crate enum ConsumeClosingDelim {\n     No,\n }\n \n+#[derive(Clone, Copy)]\n+pub enum AttemptLocalParseRecovery {\n+    Yes,\n+    No,\n+}\n+\n+impl AttemptLocalParseRecovery {\n+    pub fn yes(&self) -> bool {\n+        match self {\n+            AttemptLocalParseRecovery::Yes => true,\n+            AttemptLocalParseRecovery::No => false,\n+        }\n+    }\n+\n+    pub fn no(&self) -> bool {\n+        match self {\n+            AttemptLocalParseRecovery::Yes => false,\n+            AttemptLocalParseRecovery::No => true,\n+        }\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     pub(super) fn span_fatal_err<S: Into<MultiSpan>>(\n         &self,\n@@ -321,6 +344,66 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn maybe_suggest_struct_literal(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode,\n+    ) -> Option<PResult<'a, P<Block>>> {\n+        if self.token.is_ident() && self.look_ahead(1, |t| t == &token::Colon) {\n+            // We might be having a struct literal where people forgot to include the path:\n+            // fn foo() -> Foo {\n+            //     field: value,\n+            // }\n+            let mut snapshot = self.clone();\n+            let path =\n+                Path { segments: vec![], span: self.prev_token.span.shrink_to_lo(), tokens: None };\n+            let struct_expr = snapshot.parse_struct_expr(path, AttrVec::new(), false);\n+            let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n+            return Some(match (struct_expr, block_tail) {\n+                (Ok(expr), Err(mut err)) => {\n+                    // We have encountered the following:\n+                    // fn foo() -> Foo {\n+                    //     field: value,\n+                    // }\n+                    // Suggest:\n+                    // fn foo() -> Foo { Path {\n+                    //     field: value,\n+                    // } }\n+                    err.delay_as_bug();\n+                    self.struct_span_err(expr.span, \"struct literal body without path\")\n+                        .multipart_suggestion(\n+                            \"you might have forgotten to add the struct literal inside the block\",\n+                            vec![\n+                                (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                                (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    *self = snapshot;\n+                    Ok(self.mk_block(\n+                        vec![self.mk_stmt_err(expr.span)],\n+                        s,\n+                        lo.to(self.prev_token.span),\n+                    ))\n+                }\n+                (Err(mut err), Ok(tail)) => {\n+                    // We have a block tail that contains a somehow valid type ascription expr.\n+                    err.cancel();\n+                    Ok(tail)\n+                }\n+                (Err(mut snapshot_err), Err(err)) => {\n+                    // We don't know what went wrong, emit the normal error.\n+                    snapshot_err.cancel();\n+                    self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n+                    Err(err)\n+                }\n+                (Ok(_), Ok(tail)) => Ok(tail),\n+            });\n+        }\n+        None\n+    }\n+\n     pub fn maybe_annotate_with_ascription(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "0eac04df3c9f58bcddd5a0d6472fcdba7508b216", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -2015,9 +2015,12 @@ impl<'a> Parser<'a> {\n     ) -> Option<PResult<'a, P<Expr>>> {\n         let struct_allowed = !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL);\n         if struct_allowed || self.is_certainly_not_a_block() {\n-            // This is a struct literal, but we don't can't accept them here.\n-            let expr = self.parse_struct_expr(path.clone(), attrs.clone());\n+            if let Err(err) = self.expect(&token::OpenDelim(token::Brace)) {\n+                return Some(Err(err));\n+            }\n+            let expr = self.parse_struct_expr(path.clone(), attrs.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n+                // This is a struct literal, but we don't can't accept them here.\n                 self.error_struct_lit_not_allowed_here(path.span, expr.span);\n             }\n             return Some(expr);\n@@ -2035,12 +2038,13 @@ impl<'a> Parser<'a> {\n             .emit();\n     }\n \n+    /// Precondition: already parsed the '{'.\n     pub(super) fn parse_struct_expr(\n         &mut self,\n         pth: ast::Path,\n         mut attrs: AttrVec,\n+        recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        self.bump();\n         let mut fields = Vec::new();\n         let mut base = None;\n         let mut recover_async = false;\n@@ -2059,10 +2063,11 @@ impl<'a> Parser<'a> {\n                 let exp_span = self.prev_token.span;\n                 match self.parse_expr() {\n                     Ok(e) => base = Some(e),\n-                    Err(mut e) => {\n+                    Err(mut e) if recover => {\n                         e.emit();\n                         self.recover_stmt();\n                     }\n+                    Err(e) => return Err(e),\n                 }\n                 self.recover_struct_comma_after_dotdot(exp_span);\n                 break;\n@@ -2114,6 +2119,9 @@ impl<'a> Parser<'a> {\n                             );\n                         }\n                     }\n+                    if !recover {\n+                        return Err(e);\n+                    }\n                     e.emit();\n                     self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n                     self.eat(&token::Comma);"}, {"sha": "c10946812213b4ae3234e43a44f46628cca5dd04", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -10,6 +10,7 @@ mod stmt;\n mod ty;\n \n use crate::lexer::UnmatchedBrace;\n+pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n pub use path::PathStyle;\n "}, {"sha": "131ff1ae6b3da9a92f4fb7938a89c9d72140630d", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -1,5 +1,5 @@\n use super::attr::DEFAULT_INNER_ATTR_FORBIDDEN;\n-use super::diagnostics::Error;\n+use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n use super::pat::GateOr;\n use super::path::PathStyle;\n@@ -79,8 +79,8 @@ impl<'a> Parser<'a> {\n             return self.parse_stmt_mac(lo, attrs.into(), path);\n         }\n \n-        let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-            self.parse_struct_expr(path, AttrVec::new())?\n+        let expr = if self.eat(&token::OpenDelim(token::Brace)) {\n+            self.parse_struct_expr(path, AttrVec::new(), true)?\n         } else {\n             let hi = self.prev_token.span;\n             self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n@@ -321,25 +321,37 @@ impl<'a> Parser<'a> {\n             return self.error_block_no_opening_brace();\n         }\n \n-        Ok((self.parse_inner_attributes()?, self.parse_block_tail(lo, blk_mode)?))\n+        let attrs = self.parse_inner_attributes()?;\n+        let tail = if let Some(tail) = self.maybe_suggest_struct_literal(lo, blk_mode) {\n+            tail?\n+        } else {\n+            self.parse_block_tail(lo, blk_mode, AttemptLocalParseRecovery::Yes)?\n+        };\n+        Ok((attrs, tail))\n     }\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n+    crate fn parse_block_tail(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode,\n+        recover: AttemptLocalParseRecovery,\n+    ) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n         while !self.eat(&token::CloseDelim(token::Brace)) {\n             if self.token == token::Eof {\n                 break;\n             }\n-            let stmt = match self.parse_full_stmt() {\n-                Err(mut err) => {\n+            let stmt = match self.parse_full_stmt(recover) {\n+                Err(mut err) if recover.yes() => {\n                     self.maybe_annotate_with_ascription(&mut err, false);\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(self.mk_stmt_err(self.token.span))\n                 }\n                 Ok(stmt) => stmt,\n+                Err(err) => return Err(err),\n             };\n             if let Some(stmt) = stmt {\n                 stmts.push(stmt);\n@@ -352,7 +364,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n-    pub fn parse_full_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub fn parse_full_stmt(\n+        &mut self,\n+        recover: AttemptLocalParseRecovery,\n+    ) -> PResult<'a, Option<Stmt>> {\n         // Skip looking for a trailing semicolon when we have an interpolated statement.\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n@@ -391,6 +406,9 @@ impl<'a> Parser<'a> {\n                     if let Err(mut e) =\n                         self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n                     {\n+                        if recover.no() {\n+                            return Err(e);\n+                        }\n                         e.emit();\n                         self.recover_stmt();\n                     }\n@@ -432,7 +450,7 @@ impl<'a> Parser<'a> {\n         Stmt { id: DUMMY_NODE_ID, kind, span, tokens: None }\n     }\n \n-    fn mk_stmt_err(&self, span: Span) -> Stmt {\n+    pub(super) fn mk_stmt_err(&self, span: Span) -> Stmt {\n         self.mk_stmt(span, StmtKind::Expr(self.mk_expr_err(span)))\n     }\n "}, {"sha": "a557e861deeef2c629e182a5512da6ec4158bdf8", "filename": "src/test/ui/parser/bare-struct-body.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.rs?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -0,0 +1,15 @@\n+struct Foo {\n+    val: (),\n+}\n+\n+fn foo() -> Foo { //~ ERROR struct literal body without path\n+    val: (),\n+}\n+\n+fn main() {\n+    let x = foo();\n+    x.val == 42; //~ ERROR mismatched types\n+    let x = { //~ ERROR struct literal body without path\n+        val: (),\n+    };\n+}"}, {"sha": "df10b0ec2d2bc3156dabddb866d891c053d3782b", "filename": "src/test/ui/parser/bare-struct-body.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbare-struct-body.stderr?ref=e5f83bcd04e85b8ae5f04d2d95dd9af774d422e2", "patch": "@@ -0,0 +1,41 @@\n+error: struct literal body without path\n+  --> $DIR/bare-struct-body.rs:5:17\n+   |\n+LL |   fn foo() -> Foo {\n+   |  _________________^\n+LL | |     val: (),\n+LL | | }\n+   | |_^\n+   |\n+help: you might have forgotten to add the struct literal inside the block\n+   |\n+LL | fn foo() -> Foo { SomeStruct {\n+LL |     val: (),\n+LL | } }\n+   |\n+\n+error: struct literal body without path\n+  --> $DIR/bare-struct-body.rs:12:13\n+   |\n+LL |       let x = {\n+   |  _____________^\n+LL | |         val: (),\n+LL | |     };\n+   | |_____^\n+   |\n+help: you might have forgotten to add the struct literal inside the block\n+   |\n+LL |     let x = { SomeStruct {\n+LL |         val: (),\n+LL |     } };\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/bare-struct-body.rs:11:14\n+   |\n+LL |     x.val == 42;\n+   |              ^^ expected `()`, found integer\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}