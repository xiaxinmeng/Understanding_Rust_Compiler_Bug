{"sha": "1d100ba26cf9afe85a8a30122c568937c4710879", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMTAwYmEyNmNmOWFmZTg1YThhMzAxMjJjNTY4OTM3YzQ3MTA4Nzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T03:54:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T03:54:33Z"}, "message": "Auto merge of #75276 - JohnTitor:rollup-rz4hs0w, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #75224 (Don't call a function in function-arguments-naked.rs)\n - #75237 (Display elided lifetime for non-reference type in doc)\n - #75250 (make MaybeUninit::as_(mut_)ptr const)\n - #75253 (clean up const-hacks in int endianess conversion functions)\n - #75259 (Add missing backtick)\n - #75267 (Small cleanup)\n - #75270 (fix a couple of clippy findings)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "089ea829b0dc778659d2653a76a07a84f7e0a21e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/089ea829b0dc778659d2653a76a07a84f7e0a21e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d100ba26cf9afe85a8a30122c568937c4710879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d100ba26cf9afe85a8a30122c568937c4710879", "html_url": "https://github.com/rust-lang/rust/commit/1d100ba26cf9afe85a8a30122c568937c4710879", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d100ba26cf9afe85a8a30122c568937c4710879/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9c2177ddc605f9c75ca1a3e6ddb33835b8a178d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c2177ddc605f9c75ca1a3e6ddb33835b8a178d", "html_url": "https://github.com/rust-lang/rust/commit/f9c2177ddc605f9c75ca1a3e6ddb33835b8a178d"}, {"sha": "21bfe529c7ea65c3e77ea5b7657014b9200df904", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bfe529c7ea65c3e77ea5b7657014b9200df904", "html_url": "https://github.com/rust-lang/rust/commit/21bfe529c7ea65c3e77ea5b7657014b9200df904"}], "stats": {"total": 297, "additions": 170, "deletions": 127}, "files": [{"sha": "027498d3911c8fcac38383ee5df5cb0add760480", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -405,9 +405,11 @@ impl<T> MaybeUninit<T> {\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n     #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n+    pub const fn as_ptr(&self) -> *const T {\n+        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n+        self as *const _ as *const T\n     }\n \n     /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n@@ -442,9 +444,11 @@ impl<T> MaybeUninit<T> {\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n     #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n+    pub const fn as_mut_ptr(&mut self) -> *mut T {\n+        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n+        self as *mut _ as *mut T\n     }\n \n     /// Extracts the value from the `MaybeUninit<T>` container. This is a great way"}, {"sha": "68937176270356a031ac23cf1fed6053f5edff5a", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -2346,17 +2346,12 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n                 // arrays of bytes\n-                unsafe { Bytes { val: self }.bytes }\n+                unsafe { mem::transmute(self) }\n             }\n         }\n \n@@ -2464,16 +2459,11 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them\n-                unsafe { Bytes { bytes }.val }\n+                unsafe { mem::transmute(bytes) }\n             }\n         }\n \n@@ -4368,17 +4358,12 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n                 // arrays of bytes\n-                unsafe { Bytes { val: self }.bytes }\n+                unsafe { mem::transmute(self) }\n             }\n         }\n \n@@ -4486,16 +4471,11 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them\n-                unsafe { Bytes { bytes }.val }\n+                unsafe { mem::transmute(bytes) }\n             }\n         }\n "}, {"sha": "7ca27bf0dc15e90eb0852ef98a0c62bab1e2ba5e", "filename": "library/test/src/helpers/concurrency.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -4,7 +4,7 @@ use std::env;\n \n #[allow(deprecated)]\n pub fn get_concurrency() -> usize {\n-    return match env::var(\"RUST_TEST_THREADS\") {\n+    match env::var(\"RUST_TEST_THREADS\") {\n         Ok(s) => {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n@@ -13,7 +13,7 @@ pub fn get_concurrency() -> usize {\n             }\n         }\n         Err(..) => num_cpus(),\n-    };\n+    }\n }\n \n cfg_if::cfg_if! {"}, {"sha": "83a9de84ed8414f75bc9c56bae4d0be6a0facc7f", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -378,7 +378,7 @@ impl Default for Generics {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n     /// `true` if we ate a `where` token: this can happen\n-    /// if we parsed no predicates (e.g. `struct Foo where {}\n+    /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to accurately pretty-print\n     /// in `nt_to_tokenstream`\n     pub has_where_token: bool,"}, {"sha": "9d6b15ec4af8cc34f0e4a727ccdef0bc9bdf8729", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -960,15 +960,15 @@ fn pointer_type_metadata(\n fn param_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"param_type_metadata: {:?}\", t);\n     let name = format!(\"{:?}\", t);\n-    return unsafe {\n+    unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr().cast(),\n             name.len(),\n             Size::ZERO.bits(),\n             DW_ATE_unsigned,\n         )\n-    };\n+    }\n }\n \n pub fn compile_unit_metadata("}, {"sha": "ae3ec15fcd70a61c0b314e90b0e3cdb0f5b0627a", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -490,7 +490,7 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        let path = module.object.as_ref().map(|path| path.clone());\n+        let path = module.object.as_ref().cloned();\n \n         if let Some((id, product)) =\n             copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, &path)"}, {"sha": "89142edb2dc61dc58e738062c517b888eb78aae1", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -85,11 +85,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n                 if sub == &ty::ReStatic\n-                    && v.0\n-                        .into_iter()\n-                        .filter(|t| t.span.desugaring_kind().is_none())\n-                        .next()\n-                        .is_some()\n+                    && v.0.into_iter().find(|t| t.span.desugaring_kind().is_none()).is_some()\n                 {\n                     // If the failure is due to a `'static` requirement coming from a `dyn` or\n                     // `impl` Trait that *isn't* caused by `async fn` desugaring, handle this case"}, {"sha": "7493b8b0a9f772ec7e3fbb903ca3b6cd4ba0ece5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             param.param_ty.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if let Some(_) = opaque\n+                    } else if opaque\n                         .bounds\n                         .iter()\n                         .filter_map(|arg| match arg {\n@@ -269,6 +269,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             _ => None,\n                         })\n                         .next()\n+                        .is_some()\n                     {\n                     } else {\n                         err.span_suggestion_verbose("}, {"sha": "ccba904df9e002270f5e3655568ea091b5fecc35", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -50,7 +50,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n             // FIXME(#41044) -- not correct, need test\n-            ty::Bivariant => Ok(a.clone()),\n+            ty::Bivariant => Ok(a),\n             ty::Contravariant => self.fields.lub(self.a_is_expected).relate(a, b),\n         }\n     }\n@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n         self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n "}, {"sha": "3f5ed36035c1a3c38a8d27c866cffc53b1c64f85", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -719,7 +719,7 @@ where\n             self.a_scopes.pop().unwrap();\n         }\n \n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n "}, {"sha": "2d4c1e5d050baa160271b2c135b243289b3c1912", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -288,9 +288,9 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n     ) -> TypeError<'tcx> {\n         debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n         if self.overly_polymorphic {\n-            return TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region);\n+            TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region)\n         } else {\n-            return TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region);\n+            TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region)\n         }\n     }\n }"}, {"sha": "308f884f9a63fd59d88fd0acd9f5e1d831722ee6", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -68,7 +68,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => Ok(a.clone()),\n+            ty::Bivariant => Ok(a),\n             ty::Contravariant => self.with_expected_switched(|this| this.relate(b, a)),\n         }\n     }"}, {"sha": "d285449c69024574f53666e2dd04bb3b474b0d68", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -1074,7 +1074,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n             // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n             // argument, which after substitution, is `()`, then this branch can be hit.\n-            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n+            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => {}\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n             }"}, {"sha": "c91f81a13404a148b5ad994738f5459ae5242766", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'tcx> SpecializedEncoder<ExpnId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n         rustc_span::hygiene::raw_encode_expn_id(\n             *expn,\n-            &mut self.hygiene_ctxt,\n+            &self.hygiene_ctxt,\n             ExpnDataEncodeMode::Metadata,\n             self,\n         )"}, {"sha": "4b7663e9adec1364c8472f4ee0dd208c0596021a", "filename": "src/librustc_middle/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fquery.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -128,7 +128,7 @@ pub struct DropckOutlivesResult<'tcx> {\n \n impl<'tcx> DropckOutlivesResult<'tcx> {\n     pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-        if let Some(overflow_ty) = self.overflows.iter().next() {\n+        if let Some(overflow_ty) = self.overflows.get(0) {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 span,"}, {"sha": "ba74ffaa8d620f8536dda39b468ab48584061992", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -868,7 +868,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n         }\n-        return normal_ret;\n+        normal_ret\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "02896d7de357ff40524e740a303f75264bec4232", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -361,7 +361,7 @@ fn optimization_applies<'tcx>(\n     }\n \n     trace!(\"SUCCESS: optimization applies!\");\n-    return true;\n+    true\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {"}, {"sha": "9296e2ca7008fdb4840830992c8c052576cf9063", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -115,7 +115,7 @@ pub fn equal_up_to_regions(\n             T: Relate<'tcx>,\n         {\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a.clone())\n+            Ok(a)\n         }\n     }\n "}, {"sha": "b33ae4bed828b95ad518c274e778244e3f9cacef", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -103,6 +103,8 @@ pub struct Parser<'a> {\n     /// error.\n     pub(super) unclosed_delims: Vec<UnmatchedBrace>,\n     last_unexpected_token_span: Option<Span>,\n+    /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n+    /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n     pub last_type_ascription: Option<(Span, bool /* likely path typo */)>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     subparser_name: Option<&'static str>,"}, {"sha": "ebb3aa3866e43641faae1f0f2e0529339b001bb5", "filename": "src/librustc_parse_format/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_parse_format%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_parse_format%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse_format%2Flib.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -820,7 +820,7 @@ fn find_skips_from_snippet(\n     }\n \n     let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n-    let r_end = str_style.map(|r| r).unwrap_or(0);\n+    let r_end = str_style.unwrap_or(0);\n     let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n     (find_skips(s, str_style.is_some()), true)\n }"}, {"sha": "7ecfe2554ec8ab04e0d6bf7da75c21429dc0a5e7", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -226,7 +226,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match &parent.as_ref().map(|p| &p.kind) {\n+            PathSource::Expr(parent) => match parent.as_ref().map(|p| &p.kind) {\n                 // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(ExprKind::Call(call_expr, _)) => match &call_expr.kind {"}, {"sha": "31aa2c4035e6892b4784d5a6063af7bee084c442", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -702,7 +702,7 @@ impl<'tcx> SaveContext<'tcx> {\n             Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::Def(HirDefKind::Ctor(_, ..), def_id) => {\n+            Res::Def(HirDefKind::Ctor(..), def_id) => {\n                 // This is a reference to a tuple struct or an enum variant where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct or enum variant itself."}, {"sha": "8fe71b71caed1f92944ef66db883b4b2b6d9a30d", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -98,7 +98,7 @@ impl<'a> FileSearch<'a> {\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p.clone()] }\n+        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n     }\n }\n "}, {"sha": "fe5370b9644fc8585cae52d04b9f9654f37cf43b", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -1030,7 +1030,7 @@ pub fn decode_expn_id<\n         drop(expns);\n         expn_id\n     });\n-    return Ok(expn_id);\n+    Ok(expn_id)\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1103,7 +1103,7 @@ pub fn decode_syntax_context<\n         assert_eq!(dummy.dollar_crate_name, kw::Invalid);\n     });\n \n-    return Ok(new_ctxt);\n+    Ok(new_ctxt)\n }\n \n pub fn num_syntax_ctxts() -> usize {"}, {"sha": "02eefe5622384a8e4319a99c196466b2027f7897", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     pub fn span(&self) -> Span {\n-        self.span.clone()\n+        self.span\n     }\n \n     pub fn reached_recursion_limit(&self) -> bool {"}, {"sha": "e29e740f136697c58c7527ce184085e9ebd07f33", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         // Don't care about `&mut` because `DerefMut` is used less\n                         // often and user will not expect autoderef happens.\n-                        if src.starts_with(\"&\") && !src.starts_with(\"&mut \") {\n+                        if src.starts_with('&') && !src.starts_with(\"&mut \") {\n                             let derefs = \"*\".repeat(steps);\n                             err.span_suggestion(\n                                 span,"}, {"sha": "4c8be8eb610103d620c97e941f1b8befca09217e", "filename": "src/librustc_traits/chalk/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let predicates = self.tcx.predicates_of(adt_def.did).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n             .collect();\n@@ -174,7 +174,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 phantom_data: adt_def.is_phantom_data(),\n             },\n         });\n-        return struct_datum;\n+        struct_datum\n     }\n \n     fn fn_def_datum(\n@@ -187,7 +187,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n@@ -276,7 +276,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n         });\n \n-        let impls = matched_impls.map(|matched_impl| chalk_ir::ImplId(matched_impl)).collect();\n+        let impls = matched_impls.map(chalk_ir::ImplId).collect();\n         impls\n     }\n \n@@ -379,7 +379,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                         ty::AdtKind::Enum => {\n                             let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n+                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n                         }\n                     },\n                     _ => None,\n@@ -398,7 +398,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                         ty::AdtKind::Enum => {\n                             let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n+                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n                         }\n                     },\n                     _ => None,\n@@ -440,7 +440,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             FnOnce => self.tcx.lang_items().fn_once_trait(),\n             Unsize => self.tcx.lang_items().unsize_trait(),\n         };\n-        def_id.map(|t| chalk_ir::TraitId(t))\n+        def_id.map(chalk_ir::TraitId)\n     }\n \n     fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {"}, {"sha": "b31f9f3c7b14f9c30f6fb91f103be0df2775f268", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -443,7 +443,7 @@ fn opaque_type_projection_predicates(\n \n     let bounds = tcx.predicates_of(def_id);\n     let predicates =\n-        util::elaborate_predicates(tcx, bounds.predicates.into_iter().map(|&(pred, _)| pred));\n+        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n \n     let filtered_predicates = predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;"}, {"sha": "9ef9164191675cf6432dd918200323153b8fc085", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -368,6 +368,6 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n         self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n \n-        Ok(a.clone())\n+        Ok(a)\n     }\n }"}, {"sha": "f598ada900feecfd2f6062cac615917acfecfa41", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            unmentioned_err = Some(self.error_unmentioned_fields(pat.span, &unmentioned_fields));\n+            unmentioned_err = Some(self.error_unmentioned_fields(pat, &unmentioned_fields));\n         }\n         match (inexistent_fields_err, unmentioned_err) {\n             (Some(mut i), Some(mut u)) => {\n@@ -1237,13 +1237,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"This error indicates that a struct pattern attempted to \\\n-                    extract a non-existent field from a struct. Struct fields \\\n-                    are identified by the name used before the colon : so struct \\\n-                    patterns should resemble the declaration of the struct type \\\n-                    being matched.\\n\\n\\\n-                    If you are using shorthand field patterns but want to refer \\\n-                    to the struct field by a different name, you should rename \\\n-                    it explicitly.\",\n+                 extract a non-existent field from a struct. Struct fields \\\n+                 are identified by the name used before the colon : so struct \\\n+                 patterns should resemble the declaration of the struct type \\\n+                 being matched.\\n\\n\\\n+                 If you are using shorthand field patterns but want to refer \\\n+                 to the struct field by a different name, you should rename \\\n+                 it explicitly.\",\n             );\n         }\n         err\n@@ -1299,7 +1299,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn error_unmentioned_fields(\n         &self,\n-        span: Span,\n+        pat: &Pat<'_>,\n         unmentioned_fields: &[Ident],\n     ) -> DiagnosticBuilder<'tcx> {\n         let field_names = if unmentioned_fields.len() == 1 {\n@@ -1312,23 +1312,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .join(\", \");\n             format!(\"fields {}\", fields)\n         };\n-        let mut diag = struct_span_err!(\n+        let mut err = struct_span_err!(\n             self.tcx.sess,\n-            span,\n+            pat.span,\n             E0027,\n             \"pattern does not mention {}\",\n             field_names\n         );\n-        diag.span_label(span, format!(\"missing {}\", field_names));\n-        if self.tcx.sess.teach(&diag.get_code().unwrap()) {\n-            diag.note(\n+        err.span_label(pat.span, format!(\"missing {}\", field_names));\n+        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n                 \"This error indicates that a pattern for a struct fails to specify a \\\n-                    sub-pattern for every one of the struct's fields. Ensure that each field \\\n-                    from the struct's definition is mentioned in the pattern, or use `..` to \\\n-                    ignore unwanted fields.\",\n+                 sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                 from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                 ignore unwanted fields.\",\n             );\n         }\n-        diag\n+        err\n     }\n \n     fn check_pat_box("}, {"sha": "84f34c0039a0a11c2c4bd90b52bd0f0457180818", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -200,13 +200,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Gather up expressions we want to munge.\n         let mut exprs = vec![expr];\n \n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n+        while let hir::ExprKind::Field(ref expr, _)\n+        | hir::ExprKind::Index(ref expr, _)\n+        | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) = exprs.last().unwrap().kind\n+        {\n+            exprs.push(&expr);\n         }\n \n         debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);"}, {"sha": "8a6fe620af7a319758cf4d3c26960f2f908e2388", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -583,7 +583,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 self.tcx()\n                     .sess\n                     .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n-                return Err(());\n+                Err(())\n             }\n         }\n     }\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             ty::Tuple(substs) => Ok(substs.len()),\n             _ => {\n                 self.tcx().sess.delay_span_bug(span, \"tuple pattern not applied to a tuple\");\n-                return Err(());\n+                Err(())\n             }\n         }\n     }"}, {"sha": "7b1dd5b11ed0e014b97cc46674a2782eb3e5a6df", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -1395,10 +1395,13 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(lt) = lifetime.cloned() {\n-                                        if !lt.is_elided() {\n-                                            let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                            lt_substs.insert(lt_def_id.to_def_id(), lt.clean(cx));\n-                                        }\n+                                        let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                        let cleaned = if !lt.is_elided() {\n+                                            lt.clean(cx)\n+                                        } else {\n+                                            self::types::Lifetime::elided()\n+                                        };\n+                                        lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n@@ -1957,21 +1960,17 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None },\n             }\n         } else {\n-            let elide_lifetimes = self.args.iter().all(|arg| match arg {\n-                hir::GenericArg::Lifetime(lt) => lt.is_elided(),\n-                _ => true,\n-            });\n             GenericArgs::AngleBracketed {\n                 args: self\n                     .args\n                     .iter()\n-                    .filter_map(|arg| match arg {\n-                        hir::GenericArg::Lifetime(lt) if !elide_lifetimes => {\n-                            Some(GenericArg::Lifetime(lt.clean(cx)))\n+                    .map(|arg| match arg {\n+                        hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                            GenericArg::Lifetime(lt.clean(cx))\n                         }\n-                        hir::GenericArg::Lifetime(_) => None,\n-                        hir::GenericArg::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n-                        hir::GenericArg::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+                        hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                        hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                        hir::GenericArg::Const(ct) => GenericArg::Const(ct.clean(cx)),\n                     })\n                     .collect(),\n                 bindings: self.bindings.clean(cx),"}, {"sha": "50eca75d7cab2cc211e19f0d6b5986b18326c3c7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -750,6 +750,10 @@ impl Lifetime {\n     pub fn statik() -> Lifetime {\n         Lifetime(\"'static\".to_string())\n     }\n+\n+    pub fn elided() -> Lifetime {\n+        Lifetime(\"'_\".to_string())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "c22538f21f69fbefb567942de1fc61e8bbdb63ee", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -2,9 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Deprecation, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg,\n-    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, MacroKind, Path,\n-    PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type, TypeBinding,\n-    TypeKind, Visibility, WherePredicate,\n+    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, Lifetime,\n+    MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type,\n+    TypeBinding, TypeKind, Visibility, WherePredicate,\n };\n use crate::core::DocContext;\n \n@@ -121,7 +121,10 @@ pub fn external_generic_args(\n     let args: Vec<_> = substs\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.clean(cx).map(GenericArg::Lifetime),\n+            GenericArgKind::Lifetime(lt) => match lt {\n+                ty::ReLateBound(_, ty::BrAnon(_)) => Some(GenericArg::Lifetime(Lifetime::elided())),\n+                _ => lt.clean(cx).map(GenericArg::Lifetime),\n+            },\n             GenericArgKind::Type(_) if skip_self => {\n                 skip_self = false;\n                 None"}, {"sha": "8b52ce710a45fd329c59d5eac30cfe5eec1b1860", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -69,14 +69,14 @@ impl DocFS {\n             let sender = self.errors.clone().expect(\"can't write after closing\");\n             rayon::spawn(move || {\n                 fs::write(&path, contents).unwrap_or_else(|e| {\n-                    sender\n-                        .send(format!(\"\\\"{}\\\": {}\", path.display(), e))\n-                        .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                    sender.send(format!(\"\\\"{}\\\": {}\", path.display(), e)).unwrap_or_else(|_| {\n+                        panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n+                    })\n                 });\n             });\n-            Ok(())\n         } else {\n-            Ok(try_err!(fs::write(&path, contents), path))\n+            try_err!(fs::write(&path, contents), path);\n         }\n+        Ok(())\n     }\n }"}, {"sha": "5f3a1eb44e4e55179eeb49b90ae3182d6198aed7", "filename": "src/test/debuginfo/function-arguments-naked.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -3,6 +3,9 @@\n // We have to ignore android because of this issue:\n // https://github.com/rust-lang/rust/issues/74847\n // ignore-android\n+//\n+// We need to use inline assembly, so just use one platform\n+// only-x86_64\n \n // compile-flags:-g\n \n@@ -24,6 +27,7 @@\n // lldb-command:continue\n \n \n+#![feature(asm)]\n #![feature(naked_functions)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n@@ -33,8 +37,6 @@ fn main() {\n }\n \n #[naked]\n-fn naked(x: usize, y: usize) {\n-    zzz(); // #break\n+extern \"C\" fn naked(x: usize, y: usize) {\n+    unsafe { asm!(\"ret\"); } // #break\n }\n-\n-fn zzz() { () }"}, {"sha": "4f2c93379d88e88c33f3b3417a0b8054722ddae3", "filename": "src/test/rustdoc/auxiliary/elided-lifetime.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -0,0 +1,11 @@\n+#![crate_name = \"bar\"]\n+\n+pub struct Ref<'a>(&'a u32);\n+\n+pub fn test5(a: &u32) -> Ref {\n+    Ref(a)\n+}\n+\n+pub fn test6(a: &u32) -> Ref<'_> {\n+    Ref(a)\n+}"}, {"sha": "5a32554f972b726bdc9a9343bd2d018b97324761", "filename": "src/test/rustdoc/elided-lifetime.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Frustdoc%2Felided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d100ba26cf9afe85a8a30122c568937c4710879/src%2Ftest%2Frustdoc%2Felided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Felided-lifetime.rs?ref=1d100ba26cf9afe85a8a30122c568937c4710879", "patch": "@@ -0,0 +1,43 @@\n+// aux-build:elided-lifetime.rs\n+//\n+// rust-lang/rust#75225\n+//\n+// Since Rust 2018 we encourage writing out <'_> explicitly to make it clear\n+// that borrowing is occuring. Make sure rustdoc is following the same idiom.\n+\n+#![crate_name = \"foo\"]\n+\n+pub struct Ref<'a>(&'a u32);\n+type ARef<'a> = Ref<'a>;\n+\n+// @has foo/fn.test1.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test1(a: &u32) -> Ref {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test2.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test2(a: &u32) -> Ref<'_> {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test3.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test3(a: &u32) -> ARef {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test4.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test4(a: &u32) -> ARef<'_> {\n+    Ref(a)\n+}\n+\n+// Ensure external paths in inlined docs also display elided lifetime\n+// @has foo/bar/fn.test5.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+// @has foo/bar/fn.test6.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+#[doc(inline)]\n+pub extern crate bar;"}]}