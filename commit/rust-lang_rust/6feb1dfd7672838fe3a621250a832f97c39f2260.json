{"sha": "6feb1dfd7672838fe3a621250a832f97c39f2260", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZWIxZGZkNzY3MjgzOGZlM2E2MjEyNTBhODMyZjk3YzM5ZjIyNjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T01:39:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-09T01:42:34Z"}, "message": "rustc: Don't eagerly resolve type variables after unification", "tree": {"sha": "dd108d12f3f8abac5a4f0afb4ad812bd504ac7dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd108d12f3f8abac5a4f0afb4ad812bd504ac7dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6feb1dfd7672838fe3a621250a832f97c39f2260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6feb1dfd7672838fe3a621250a832f97c39f2260", "html_url": "https://github.com/rust-lang/rust/commit/6feb1dfd7672838fe3a621250a832f97c39f2260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6feb1dfd7672838fe3a621250a832f97c39f2260/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "537d4ac65a49c4d9932cc8871ffdb9020b5ac05d", "url": "https://api.github.com/repos/rust-lang/rust/commits/537d4ac65a49c4d9932cc8871ffdb9020b5ac05d", "html_url": "https://github.com/rust-lang/rust/commit/537d4ac65a49c4d9932cc8871ffdb9020b5ac05d"}], "stats": {"total": 99, "additions": 59, "deletions": 40}, "files": [{"sha": "3cd2602ed819fa5dde8b8efb0f013b7b0eebddf2", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6feb1dfd7672838fe3a621250a832f97c39f2260/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6feb1dfd7672838fe3a621250a832f97c39f2260/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6feb1dfd7672838fe3a621250a832f97c39f2260", "patch": "@@ -2126,6 +2126,25 @@ mod unify {\n         ret fold_ty(tcx, bind folder(tcx, vb, _), typ);\n     }\n \n+    // If the given type is a variable, returns the structure of that type.\n+    fn resolve_type_structure(&ty_ctxt tcx, &@var_bindings vb, t typ)\n+            -> fixup_result {\n+        alt (struct(tcx, typ)) {\n+            case (ty_var(?vid)) {\n+                if ((vid as uint) >= ufind::set_count(vb.sets)) {\n+                    ret fix_err(vid);\n+                }\n+\n+                auto root_id = ufind::find(vb.sets, vid as uint);\n+                alt (smallintmap::find[t](vb.types, root_id)) {\n+                    case (none[t]) { ret fix_err(vid); }\n+                    case (some[t](?rt)) { ret fix_ok(rt); }\n+                }\n+            }\n+            case (_) { ret fix_ok(typ); }\n+        }\n+    }\n+\n     fn unify_step(&@ctxt cx, &t expected, &t actual) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness."}, {"sha": "a76a377eae844886002bdad4ee2abc718eadc911", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6feb1dfd7672838fe3a621250a832f97c39f2260/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6feb1dfd7672838fe3a621250a832f97c39f2260/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6feb1dfd7672838fe3a621250a832f97c39f2260", "patch": "@@ -21,7 +21,6 @@ import middle::ty::mo_alias;\n import middle::ty::node_type_table;\n import middle::ty::pat_ty;\n import middle::ty::path_to_str;\n-import middle::ty::struct;\n import middle::ty::ty_param_substs_opt_and_ty;\n import middle::ty::ty_to_str;\n import middle::ty::type_is_integral;\n@@ -195,6 +194,19 @@ fn ast_mode_to_mode(ast::mode mode) -> ty::mode {\n     ret ty_mode;\n }\n \n+// Returns the one-level-deep structure of the given type.\n+fn structure_of(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::sty {\n+    auto r = ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings,\n+                                               typ);\n+    alt (r) {\n+        case (fix_ok(?typ_s)) { ret ty::struct(fcx.ccx.tcx, typ_s); }\n+        case (fix_err(_)) {\n+            fcx.ccx.tcx.sess.span_err(sp, \"the type of this value must be \" +\n+                \"known in this context\");\n+        }\n+    }\n+}\n+\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n@@ -810,20 +822,11 @@ mod collect {\n \n // Type unification\n \n+// TODO: rename to just \"unify\"\n mod unify {\n     fn simple(&@fn_ctxt fcx, &ty::t expected, &ty::t actual)\n             -> ty::unify::result {\n-        auto result = ty::unify::unify(expected, actual, fcx.var_bindings,\n-                                       fcx.ccx.tcx);\n-\n-        // FIXME: Shouldn't be necessary, but is until we remove pushdown.\n-        alt (result) {\n-            case (ures_ok(?typ)) {\n-                ret ures_ok(ty::unify::resolve_all_vars(fcx.ccx.tcx,\n-                    fcx.var_bindings, typ));\n-            }\n-            case (_) { ret result; }\n-        }\n+        ret ty::unify::unify(expected, actual, fcx.var_bindings, fcx.ccx.tcx);\n     }\n }\n \n@@ -833,10 +836,10 @@ tag autoderef_kind {\n     NO_AUTODEREF;\n }\n \n-fn strip_boxes(&ty::ctxt tcx, &ty::t t) -> ty::t {\n+fn strip_boxes(&@fn_ctxt fcx, &span sp, &ty::t t) -> ty::t {\n     auto t1 = t;\n     while (true) {\n-        alt (struct(tcx, t1)) {\n+        alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n@@ -854,11 +857,11 @@ fn add_boxes(&@crate_ctxt ccx, uint n, &ty::t t) -> ty::t {\n }\n \n \n-fn count_boxes(&ty::ctxt tcx, &ty::t t) -> uint {\n+fn count_boxes(&@fn_ctxt fcx, &span sp, &ty::t t) -> uint {\n     auto n = 0u;\n     auto t1 = t;\n     while (true) {\n-        alt (struct(tcx, t1)) {\n+        alt (structure_of(fcx, sp, t1)) {\n             case (ty::ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n@@ -897,9 +900,9 @@ mod demand {\n         auto implicit_boxes = 0u;\n \n         if (adk == AUTODEREF_OK) {\n-            expected_1 = strip_boxes(fcx.ccx.tcx, expected_1);\n-            actual_1 = strip_boxes(fcx.ccx.tcx, actual_1);\n-            implicit_boxes = count_boxes(fcx.ccx.tcx, actual);\n+            expected_1 = strip_boxes(fcx, sp, expected_1);\n+            actual_1 = strip_boxes(fcx, sp, actual_1);\n+            implicit_boxes = count_boxes(fcx, sp, actual);\n         }\n \n         let vec[mutable ty::t] ty_param_substs = [mutable];\n@@ -958,7 +961,7 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n     let vec[ty::t] result = [];\n \n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n-    alt (struct(ccx.tcx, tpt._1)) {\n+    alt (ty::struct(ccx.tcx, tpt._1)) {\n         case (ty::ty_fn(_, ?ins, _, _)) {\n             // N-ary variant.\n             for (ty::arg arg in ins) {\n@@ -1272,7 +1275,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n \n             // Take the tag type params out of `expected`.\n             auto expected_tps;\n-            alt (struct(fcx.ccx.tcx, expected)) {\n+            alt (structure_of(fcx, pat.span, expected)) {\n                 case (ty::ty_tag(_, ?tps)) { expected_tps = tps; }\n                 case (_) {\n                     // FIXME: Switch expected and actual in this message? I\n@@ -1405,14 +1408,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         // Check the function.\n         check_expr(fcx, f);\n \n-        // Get the function type. We need to have resolved it enough to know\n-        // it's a ty_fn or ty_native_fn.\n+        // Get the function type.\n         auto fty = expr_ty(fcx.ccx.tcx, f);\n-        fty = ty::unify::resolve_all_vars(fcx.ccx.tcx, fcx.var_bindings, fty);\n \n         // Grab the argument types and the return type.\n         auto arg_tys;\n-        alt (ty::struct(fcx.ccx.tcx, fty)) {\n+        alt (structure_of(fcx, sp, fty)) {\n             case (ty::ty_fn(_, ?arg_tys_0, _, _)) {\n                 arg_tys = arg_tys_0;\n             }\n@@ -1508,7 +1509,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n \n             // FIXME: Binops have a bit more subtlety than this.\n-            auto t = strip_boxes(fcx.ccx.tcx, lhs_t);\n+            auto t = strip_boxes(fcx, expr.span, lhs_t);\n             alt (binop) {\n                 case (ast::eq) { t = ty::mk_bool(fcx.ccx.tcx); }\n                 case (ast::lt) { t = ty::mk_bool(fcx.ccx.tcx); }\n@@ -1532,7 +1533,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                         rec(ty=oper_t, mut=mut));\n                 }\n                 case (ast::deref) {\n-                    alt (struct(fcx.ccx.tcx, oper_t)) {\n+                    alt (structure_of(fcx, expr.span, oper_t)) {\n                         case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n                         case (_) {\n                             fcx.ccx.tcx.sess.span_err\n@@ -1542,7 +1543,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         }\n                     }\n                 }\n-                case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n+                case (_) { oper_t = strip_boxes(fcx, expr.span, oper_t); }\n             }\n \n             write::ty_only_fixup(fcx, a.id, oper_t);\n@@ -1721,7 +1722,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             auto item_t;\n             auto lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n-            alt (struct(fcx.ccx.tcx, lhs_t)) {\n+            alt (structure_of(fcx, expr.span, lhs_t)) {\n                 case (ty::ty_chan(?it)) { item_t = it; }\n                 case (_) {\n                     fcx.ccx.tcx.sess.span_err(expr.span,\n@@ -1775,8 +1776,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         case (ast::expr_for(?decl, ?seq, ?body, ?a)) {\n             check_expr(fcx, seq);\n-            alt (struct (fcx.ccx.tcx,\n-                         expr_ty(fcx.ccx.tcx, seq))) {\n+            alt (structure_of(fcx, expr.span, expr_ty(fcx.ccx.tcx, seq))) {\n                 // FIXME: I include the check_for_or_each call in \n                 // each case because of a bug in typestate.\n                 // The bug is fixed; once there's a new snapshot,\n@@ -1877,7 +1877,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto rt_1;\n             auto fty = expr_ty(fcx.ccx.tcx, f);\n             auto t_1;\n-            alt (struct(fcx.ccx.tcx, fty)) {\n+            alt (structure_of(fcx, expr.span, fty)) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt, ?cf)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -1917,7 +1917,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // Pull the return type out of the type of the function.\n             auto rt_1 = ty::mk_nil(fcx.ccx.tcx); // FIXME: typestate botch\n             auto fty = ty::expr_ty(fcx.ccx.tcx, f);\n-            alt (struct(fcx.ccx.tcx, fty)) {\n+            alt (structure_of(fcx, expr.span, fty)) {\n                 case (ty::ty_fn(_,_,?rt,_))         { rt_1 = rt; }\n                 case (ty::ty_native_fn(_, _, ?rt))  { rt_1 = rt; }\n                 case (_) {\n@@ -1949,7 +1949,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             }\n \n             // Grab this method's type out of the current object type.\n-            alt (struct(fcx.ccx.tcx, this_obj_ty)) {\n+            alt (structure_of(fcx, expr.span, this_obj_ty)) {\n                 case (ty::ty_obj(?methods)) {\n                     for (ty::method method in methods) {\n                         if (method.ident == id) {\n@@ -2059,7 +2059,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n                     let vec[field] base_fields = [];\n \n-                    alt (struct(fcx.ccx.tcx, bexpr_t)) {\n+                    alt (structure_of(fcx, expr.span, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n                             fcx.ccx.tcx.sess.span_err\n@@ -2093,10 +2093,10 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_field(?base, ?field, ?a)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n-            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n+            base_t = strip_boxes(fcx, expr.span, base_t);\n             base_t = ty::unify::resolve_all_vars(fcx.ccx.tcx,\n                 fcx.var_bindings, base_t);\n-            alt (struct(fcx.ccx.tcx, base_t)) {\n+            alt (structure_of(fcx, expr.span, base_t)) {\n                 case (ty::ty_tup(?args)) {\n                     let uint ix = ty::field_num(fcx.ccx.tcx.sess,\n                                                 expr.span, field);\n@@ -2142,11 +2142,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_index(?base, ?idx, ?a)) {\n             check_expr(fcx, base);\n             auto base_t = expr_ty(fcx.ccx.tcx, base);\n-            base_t = strip_boxes(fcx.ccx.tcx, base_t);\n+            base_t = strip_boxes(fcx, expr.span, base_t);\n \n             check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tcx, idx);\n-            alt (struct(fcx.ccx.tcx, base_t)) {\n+            alt (structure_of(fcx, expr.span, base_t)) {\n                 case (ty::ty_vec(?mt)) {\n                     if (! type_is_integral(fcx.ccx.tcx, idx_t)) {\n                         fcx.ccx.tcx.sess.span_err\n@@ -2184,7 +2184,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_chan(?x, ?a)) {\n             check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tcx, x);\n-            alt (struct(fcx.ccx.tcx, port_t)) {\n+            alt (structure_of(fcx, expr.span, port_t)) {\n                 case (ty::ty_port(?subtype)) {\n                     auto ct = ty::mk_chan(fcx.ccx.tcx, subtype);\n                     write::ty_only_fixup(fcx, a.id, ct);"}]}