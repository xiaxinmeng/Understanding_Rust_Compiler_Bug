{"sha": "139a6d12de65f81a69e345731f0547c824730a19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzOWE2ZDEyZGU2NWY4MWE2OWUzNDU3MzFmMDU0N2M4MjQ3MzBhMTk=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-30T10:02:24Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-30T10:02:24Z"}, "message": "Fix 128bit checked math intrinsic calls", "tree": {"sha": "93e5d63599a64aac26cf77a872c5b9db91af4170", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93e5d63599a64aac26cf77a872c5b9db91af4170"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/139a6d12de65f81a69e345731f0547c824730a19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/139a6d12de65f81a69e345731f0547c824730a19", "html_url": "https://github.com/rust-lang/rust/commit/139a6d12de65f81a69e345731f0547c824730a19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/139a6d12de65f81a69e345731f0547c824730a19/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f48e4bae83295816f035474a726a5d92056453", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f48e4bae83295816f035474a726a5d92056453", "html_url": "https://github.com/rust-lang/rust/commit/e8f48e4bae83295816f035474a726a5d92056453"}], "stats": {"total": 93, "additions": 52, "deletions": 41}, "files": [{"sha": "6a025f2e88ae3f8b4c022663739fca48bcc9323b", "filename": "src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/139a6d12de65f81a69e345731f0547c824730a19/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139a6d12de65f81a69e345731f0547c824730a19/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=139a6d12de65f81a69e345731f0547c824730a19", "patch": "@@ -102,13 +102,13 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n     pub(crate) fn lib_call(\n         &mut self,\n         name: &str,\n-        input_tys: Vec<types::Type>,\n-        output_tys: Vec<types::Type>,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature {\n-            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n+            params,\n+            returns,\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n@@ -140,16 +140,18 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n             .iter()\n             .map(|arg| {\n                 (\n-                    self.clif_type(arg.layout().ty).unwrap(),\n+                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n                     arg.load_scalar(self),\n                 )\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n+            tup.types()\n+                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n+                .collect()\n         } else {\n-            vec![self.clif_type(return_ty).unwrap()]\n+            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n         let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n         match *ret_vals {\n@@ -208,7 +210,8 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         .block_params(start_block)\n         .to_vec()\n         .into_iter();\n-    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n+    let ret_place =\n+        self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n \n     // None means pass_mode == NoPass\n@@ -241,14 +244,16 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 let mut params = Vec::new();\n                 for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n                     let arg_abi = arg_abis_iter.next().unwrap();\n-                    let param = cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n+                    let param =\n+                        cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n                 let arg_abi = arg_abis_iter.next().unwrap();\n-                let param = cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n+                let param =\n+                    cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })"}, {"sha": "4842628a99da7d391cc6371617961290705180f2", "filename": "src/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/139a6d12de65f81a69e345731f0547c824730a19/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139a6d12de65f81a69e345731f0547c824730a19/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=139a6d12de65f81a69e345731f0547c824730a19", "patch": "@@ -1060,7 +1060,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+        ],\n         vec![],\n         args,\n     );"}, {"sha": "866ba90e4ae4ba5d9a73e67216f2ed7bf21872d5", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/139a6d12de65f81a69e345731f0547c824730a19/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/139a6d12de65f81a69e345731f0547c824730a19/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=139a6d12de65f81a69e345731f0547c824730a19", "patch": "@@ -1,5 +1,7 @@\n //! Replaces 128-bit operators with lang item calls where necessary\n \n+use cranelift_codegen::ir::ArgumentPurpose;\n+\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n@@ -24,41 +26,41 @@ pub(crate) fn maybe_codegen<'tcx>(\n             None\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Add => {\n-            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+        BinOp::Mul if !checked => {\n+            let val_ty = if is_signed {\n+                fx.tcx.types.i128\n             } else {\n-                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n-            });\n+                fx.tcx.types.u128\n+            };\n+            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n-        BinOp::Sub => {\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n-            } else {\n-                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n-            });\n-        }\n-        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Mul => {\n-            let res = if checked {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                if is_signed {\n-                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n-                } else {\n-                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n-                }\n-            } else {\n-                let val_ty = if is_signed {\n-                    fx.tcx.types.i128\n-                } else {\n-                    fx.tcx.types.u128\n-                };\n-                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [\n+                out_place.to_ptr().get_addr(fx),\n+                lhs.load_scalar(fx),\n+                rhs.load_scalar(fx),\n+            ];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                (BinOp::Mul, true) => \"__rust_i128_mulo\",\n+                _ => unreachable!(),\n             };\n-            Some(res)\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n         }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div => {\n             assert!(!checked);\n             if is_signed {"}]}