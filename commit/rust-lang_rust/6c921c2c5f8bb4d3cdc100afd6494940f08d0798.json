{"sha": "6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOTIxYzJjNWY4YmI0ZDNjZGMxMDBhZmQ2NDk0OTQwZjA4ZDA3OTg=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-18T22:09:28Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-04-20T17:42:25Z"}, "message": "Use more `Iterator`s instead of `Vec`s", "tree": {"sha": "eddb732f54f5c486e20a59b08450b84c38a92010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eddb732f54f5c486e20a59b08450b84c38a92010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "html_url": "https://github.com/rust-lang/rust/commit/6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faeb0404a5fb3719824cbdd6c1f0255f81c2cc25", "url": "https://api.github.com/repos/rust-lang/rust/commits/faeb0404a5fb3719824cbdd6c1f0255f81c2cc25", "html_url": "https://github.com/rust-lang/rust/commit/faeb0404a5fb3719824cbdd6c1f0255f81c2cc25"}], "stats": {"total": 141, "additions": 60, "deletions": 81}, "files": [{"sha": "3546e5f429ef5f58d7c517496ff6d27413e6fc6b", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -168,15 +168,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns a vector containing all impls\n-    pub fn all_impls(self, def_id: DefId) -> Vec<DefId> {\n-        let impls = self.trait_impls_of(def_id);\n+    pub fn all_impls(self, def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n+        let TraitImpls { blanket_impls, non_blanket_impls } = self.trait_impls_of(def_id);\n \n-        impls\n-            .blanket_impls\n-            .iter()\n-            .chain(impls.non_blanket_impls.values().flatten())\n+        blanket_impls\n+            .into_iter()\n+            .chain(non_blanket_impls.into_iter().map(|(_, v)| v).flatten())\n             .cloned()\n-            .collect()\n     }\n }\n "}, {"sha": "74cf06d54687d18ad79ef5841459da166a81e034", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -1208,22 +1208,18 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         match simp {\n             Some(simp) => all_impls\n-                .iter()\n-                .filter_map(|&def_id| {\n+                .filter_map(|def_id| {\n                     let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n                     let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n                     if let Some(imp_simp) = imp_simp {\n                         if simp != imp_simp {\n                             return None;\n                         }\n                     }\n-\n                     Some(imp)\n                 })\n                 .collect(),\n-            None => {\n-                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n-            }\n+            None => all_impls.map(|def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect(),\n         }\n     }\n "}, {"sha": "c5dbe816295504c7d391b03b0c27ebe35d4fce50", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -110,8 +110,8 @@ pub enum TraitQueryMode {\n pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> PredicateObligations<'tcx> {\n+    generic_bounds: ty::InstantiatedPredicates<'tcx>,\n+) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n     util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n }\n "}, {"sha": "a69c8acef5b168cb9ebc5ea72b06a5ee4db8da4e", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -189,26 +189,22 @@ fn fulfill_implication<'a, 'tcx>(\n \n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n-    let (target_trait_ref, mut obligations) =\n+    let (target_trait_ref, obligations) =\n         impl_trait_ref_and_oblig(selcx, param_env, target_impl, target_substs);\n-    debug!(\n-        \"fulfill_implication: target_trait_ref={:?}, obligations={:?}\",\n-        target_trait_ref, obligations\n-    );\n \n     // do the impls unify? If not, no specialization.\n-    match infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref) {\n-        Ok(InferOk { obligations: o, .. }) => {\n-            obligations.extend(o);\n-        }\n-        Err(_) => {\n-            debug!(\n-                \"fulfill_implication: {:?} does not unify with {:?}\",\n-                source_trait_ref, target_trait_ref\n-            );\n-            return Err(());\n-        }\n-    }\n+    let more_obligations =\n+        match infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref)\n+        {\n+            Ok(InferOk { obligations, .. }) => obligations,\n+            Err(_) => {\n+                debug!(\n+                    \"fulfill_implication: {:?} does not unify with {:?}\",\n+                    source_trait_ref, target_trait_ref\n+                );\n+                return Err(());\n+            }\n+        };\n \n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n@@ -226,7 +222,7 @@ fn fulfill_implication<'a, 'tcx>(\n         // we already make a mockery out of the region system, so\n         // why not ignore them a bit earlier?\n         let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        for oblig in obligations.into_iter() {\n+        for oblig in obligations.chain(more_obligations) {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n         match fulfill_cx.select_all_or_error(infcx) {\n@@ -261,7 +257,7 @@ pub(super) fn specialization_graph_provider(\n ) -> &specialization_graph::Graph {\n     let mut sg = specialization_graph::Graph::new();\n \n-    let mut trait_impls = tcx.all_impls(trait_id);\n+    let mut trait_impls: Vec<_> = tcx.all_impls(trait_id).collect();\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by"}, {"sha": "4aceccf64ce65156351dacf01680099a14fe6047", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -81,12 +81,10 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n \n pub fn expand_trait_aliases<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n+    trait_refs: impl Iterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n ) -> TraitAliasExpander<'tcx> {\n-    let items: Vec<_> = trait_refs\n-        .into_iter()\n-        .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n-        .collect();\n+    let items: Vec<_> =\n+        trait_refs.map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span)).collect();\n     TraitAliasExpander { tcx, stack: items }\n }\n \n@@ -199,7 +197,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n-) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n+) -> (ty::TraitRef<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n     let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n     let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n@@ -210,13 +208,11 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     let Normalized { value: predicates, obligations: normalization_obligations2 } =\n         super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n     let impl_obligations =\n-        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n+        predicates_for_generics(ObligationCause::dummy(), 0, param_env, predicates);\n \n-    let impl_obligations: Vec<_> = impl_obligations\n-        .into_iter()\n-        .chain(normalization_obligations1)\n-        .chain(normalization_obligations2)\n-        .collect();\n+    let impl_obligations = impl_obligations\n+        .chain(normalization_obligations1.into_iter())\n+        .chain(normalization_obligations2.into_iter());\n \n     (impl_trait_ref, impl_obligations)\n }\n@@ -226,20 +222,16 @@ pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n     recursion_depth: usize,\n     param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> Vec<PredicateObligation<'tcx>> {\n+    generic_bounds: ty::InstantiatedPredicates<'tcx>,\n+) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n     debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n \n-    generic_bounds\n-        .predicates\n-        .iter()\n-        .map(|&predicate| Obligation {\n-            cause: cause.clone(),\n-            recursion_depth,\n-            param_env,\n-            predicate,\n-        })\n-        .collect()\n+    generic_bounds.predicates.into_iter().map(move |predicate| Obligation {\n+        cause: cause.clone(),\n+        recursion_depth,\n+        param_env,\n+        predicate,\n+    })\n }\n \n pub fn predicate_for_trait_ref<'tcx>("}, {"sha": "22c81ece39181803897aca780faa4fea7e77d4b3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // a custom error in that case.\n         if illegal_sized_bound.is_none() {\n             let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig));\n-            self.add_obligations(method_ty, all_substs, &method_predicates);\n+            self.add_obligations(method_ty, all_substs, method_predicates);\n         }\n \n         // Create the final `MethodCallee`.\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         &mut self,\n         fty: Ty<'tcx>,\n         all_substs: SubstsRef<'tcx>,\n-        method_predicates: &ty::InstantiatedPredicates<'tcx>,\n+        method_predicates: ty::InstantiatedPredicates<'tcx>,\n     ) {\n         debug!(\n             \"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\","}, {"sha": "65e9abcd14644d8cc5415eaed20bbb9ad194e45a", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n-        obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, &bounds));\n+        obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, bounds));\n \n         // Also add an obligation for the method type being well-formed.\n         let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig));"}, {"sha": "03e32c21a54ac846b2dd1d4ddf68a29a39898681", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            let candidate_obligations: Vec<_> = match probe.kind {\n+            match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container.id();\n@@ -1353,19 +1353,23 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n                     // Convert the bounds into obligations.\n                     let impl_obligations =\n-                        traits::predicates_for_generics(cause, self.param_env, &impl_bounds);\n+                        traits::predicates_for_generics(cause, self.param_env, impl_bounds);\n \n-                    debug!(\"impl_obligations={:?}\", impl_obligations);\n-                    impl_obligations\n-                        .into_iter()\n+                    let candidate_obligations = impl_obligations\n                         .chain(norm_obligations.into_iter())\n-                        .chain(ref_obligations.iter().cloned())\n-                        .collect()\n+                        .chain(ref_obligations.iter().cloned());\n+                    // Evaluate those obligations to see if they might possibly hold.\n+                    for o in candidate_obligations {\n+                        let o = self.resolve_vars_if_possible(&o);\n+                        if !self.predicate_may_hold(&o) {\n+                            result = ProbeResult::NoMatch;\n+                            possibly_unsatisfied_predicates.push((o.predicate, None));\n+                        }\n+                    }\n                 }\n \n                 ObjectCandidate | WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    vec![]\n                 }\n \n                 TraitCandidate(trait_ref) => {\n@@ -1412,17 +1416,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                             return ProbeResult::NoMatch;\n                         }\n                     }\n-                    vec![]\n                 }\n-            };\n-\n-            debug!(\n-                \"consider_probe - candidate_obligations={:?} sub_obligations={:?}\",\n-                candidate_obligations, sub_obligations\n-            );\n+            }\n \n             // Evaluate those obligations to see if they might possibly hold.\n-            for o in candidate_obligations.into_iter().chain(sub_obligations) {\n+            for o in sub_obligations {\n                 let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;"}, {"sha": "ec5d3331956e582fa0407cb3cb3cc58b3aba9e55", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c921c2c5f8bb4d3cdc100afd6494940f08d0798/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6c921c2c5f8bb4d3cdc100afd6494940f08d0798", "patch": "@@ -3434,7 +3434,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn add_obligations_for_parameters(\n         &self,\n         cause: traits::ObligationCause<'tcx>,\n-        predicates: &ty::InstantiatedPredicates<'tcx>,\n+        predicates: ty::InstantiatedPredicates<'tcx>,\n     ) {\n         assert!(!predicates.has_escaping_bound_vars());\n \n@@ -4385,7 +4385,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let (bounds, _) = self.instantiate_bounds(path_span, did, substs);\n             let cause =\n                 traits::ObligationCause::new(path_span, self.body_id, traits::ItemObligation(did));\n-            self.add_obligations_for_parameters(cause, &bounds);\n+            self.add_obligations_for_parameters(cause, bounds);\n \n             Some((variant, ty))\n         } else {\n@@ -5654,9 +5654,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         for (i, mut obligation) in traits::predicates_for_generics(\n             traits::ObligationCause::new(span, self.body_id, traits::ItemObligation(def_id)),\n             self.param_env,\n-            &bounds,\n+            bounds,\n         )\n-        .into_iter()\n         .enumerate()\n         {\n             // This makes the error point at the bound, but we want to point at the argument"}]}