{"sha": "5144661d6bebdfcff7571c5251796f1b00447506", "node_id": "C_kwDOAAsO6NoAKDUxNDQ2NjFkNmJlYmRmY2ZmNzU3MWM1MjUxNzk2ZjFiMDA0NDc1MDY", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-03T11:35:55Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-03-14T15:52:47Z"}, "message": "Remove out-dated information from rustc_codegen_llvm/src/debuginfo/doc.md", "tree": {"sha": "fce44616b2eb5f921c9ddf1653df8a3ccd8fd633", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce44616b2eb5f921c9ddf1653df8a3ccd8fd633"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5144661d6bebdfcff7571c5251796f1b00447506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5144661d6bebdfcff7571c5251796f1b00447506", "html_url": "https://github.com/rust-lang/rust/commit/5144661d6bebdfcff7571c5251796f1b00447506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5144661d6bebdfcff7571c5251796f1b00447506/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe854f9850f281889b76c76265dbe4178aa8c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe854f9850f281889b76c76265dbe4178aa8c5f", "html_url": "https://github.com/rust-lang/rust/commit/abe854f9850f281889b76c76265dbe4178aa8c5f"}], "stats": {"total": 59, "additions": 5, "deletions": 54}, "files": [{"sha": "22d7f3775095e519e06edb6dc52a088bd86d6f20", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.md", "status": "modified", "additions": 5, "deletions": 54, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5144661d6bebdfcff7571c5251796f1b00447506/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/5144661d6bebdfcff7571c5251796f1b00447506/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.md?ref=5144661d6bebdfcff7571c5251796f1b00447506", "patch": "@@ -34,7 +34,7 @@ The function will take care of probing the cache for an existing node for\n that exact file path.\n \n All private state used by the module is stored within either the\n-CrateDebugContext struct (owned by the CodegenCx) or the\n+CodegenUnitDebugContext struct (owned by the CodegenCx) or the\n FunctionDebugContext (owned by the FunctionCx).\n \n This file consists of three conceptual sections:\n@@ -72,21 +72,16 @@ describe(t = List)\n       ...\n ```\n \n-To break cycles like these, we use \"forward declarations\". That is, when\n+To break cycles like these, we use \"stubs\". That is, when\n the algorithm encounters a possibly recursive type (any struct or enum), it\n immediately creates a type description node and inserts it into the cache\n *before* describing the members of the type. This type description is just\n a stub (as type members are not described and added to it yet) but it\n allows the algorithm to already refer to the type. After the stub is\n inserted into the cache, the algorithm continues as before. If it now\n encounters a recursive reference, it will hit the cache and does not try to\n-describe the type anew.\n-\n-This behavior is encapsulated in the 'RecursiveTypeDescription' enum,\n-which represents a kind of continuation, storing all state needed to\n-continue traversal at the type members after the type has been registered\n-with the cache. (This implementation approach might be a tad over-\n-engineered and may change in the future)\n+describe the type anew. This behavior is encapsulated in the\n+`type_map::build_type_with_children()` function.\n \n \n ## Source Locations and Line Information\n@@ -133,48 +128,4 @@ in the middle of the prologue, however, they are ignored by LLVM's prologue\n detection. The `create_argument_metadata()` and related functions take care\n of linking the `llvm.dbg.declare` instructions to the correct source\n locations even while source location emission is still disabled, so there\n-is no need to do anything special with source location handling here.\n-\n-## Unique Type Identification\n-\n-In order for link-time optimization to work properly, LLVM needs a unique\n-type identifier that tells it across compilation units which types are the\n-same as others. This type identifier is created by\n-`TypeMap::get_unique_type_id_of_type()` using the following algorithm:\n-\n-1. Primitive types have their name as ID\n-\n-2. Structs, enums and traits have a multipart identifier\n-\n-  1. The first part is the SVH (strict version hash) of the crate they\n-     were originally defined in\n-\n-  2. The second part is the ast::NodeId of the definition in their\n-     original crate\n-\n-  3. The final part is a concatenation of the type IDs of their concrete\n-     type arguments if they are generic types.\n-\n-3. Tuple-, pointer-, and function types are structurally identified, which\n-   means that they are equivalent if their component types are equivalent\n-   (i.e., `(i32, i32)` is the same regardless in which crate it is used).\n-\n-This algorithm also provides a stable ID for types that are defined in one\n-crate but instantiated from metadata within another crate. We just have to\n-take care to always map crate and `NodeId`s back to the original crate\n-context.\n-\n-As a side-effect these unique type IDs also help to solve a problem arising\n-from lifetime parameters. Since lifetime parameters are completely omitted\n-in debuginfo, more than one `Ty` instance may map to the same debuginfo\n-type metadata, that is, some struct `Struct<'a>` may have N instantiations\n-with different concrete substitutions for `'a`, and thus there will be N\n-`Ty` instances for the type `Struct<'a>` even though it is not generic\n-otherwise. Unfortunately this means that we cannot use `ty::type_id()` as\n-cheap identifier for type metadata -- we have done this in the past, but it\n-led to unnecessary metadata duplication in the best case and LLVM\n-assertions in the worst. However, the unique type ID as described above\n-*can* be used as identifier. Since it is comparatively expensive to\n-construct, though, `ty::type_id()` is still used additionally as an\n-optimization for cases where the exact same type has been seen before\n-(which is most of the time).\n+is no need to do anything special with source location handling here.\n\\ No newline at end of file"}]}