{"sha": "a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2QyZDYwYmM2ZDIyODU0Y2JjYjMwZWY3M2JiZDNjNzlhOGRmMjg=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "github@adolfo.ochagavia.xyz", "date": "2018-11-06T14:53:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-11-06T14:57:11Z"}, "message": "Clarifications and formatting", "tree": {"sha": "8e0b0aa82c5913b3de0d56aa614613655e73ac73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e0b0aa82c5913b3de0d56aa614613655e73ac73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "html_url": "https://github.com/rust-lang/rust/commit/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0bcb09b5e5e34810c302caff94d9bf911ee3ebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0bcb09b5e5e34810c302caff94d9bf911ee3ebc", "html_url": "https://github.com/rust-lang/rust/commit/f0bcb09b5e5e34810c302caff94d9bf911ee3ebc"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "951a092b438e90cabed6f0dc9ebec7e6b06000bc", "filename": "ROADMAP.md", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28/ROADMAP.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28/ROADMAP.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ROADMAP.md?ref=a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "patch": "@@ -1,65 +1,68 @@\n # Rust Analyzer Roadmap 01\n \n Written on 2018-11-06, extends approximately to February 2019.\n-After, we should coordinate with rustc/RLS developers to align goals and share code and experience.\n+After that, we should coordinate with the compiler/rls developers to align goals and share code and experience.\n \n \n # Overall Goals\n \n The mission is:\n-  * provide an excellent \"code analyzed as you type\" IDE experience for the Rust language,\n-  * implementing the bulk of the features in Rust itself.\n+  * Provide an excellent \"code analyzed as you type\" IDE experience for the Rust language,\n+  * Implement the bulk of the features in Rust itself.\n \n \n High-level architecture constraints:\n-  * Aim, long-term, to use the single code base with rustc.\n-    It's *obvious* then the code should be shared, but OTOH, all great IDEs started as from-scratch rewrites.\n+  * Long-term, replace the current rustc frontend.\n+    It's *obvious* that the code should be shared, but OTOH, all great IDEs started as from-scratch rewrites.\n   * Don't hard-code a particular protocol or mode of operation.\n     Produce a library which could be used for implementing an LSP server, or for in-process embedding.\n   * As long as possible, stick with stable Rust (NB: we currently use beta for 2018 edition and salsa).\n \n \n # Current Goals\n \n-We really should be coordinating with compiler/rls teams, but they are busy working on making Rust 2018 at the moment.\n-The sync-up point will happen some time after the edition, probably early next year.\n-In the mean time, the goal is to **experiment**, specifically, to figure out how a from-scratch written RLS might look like.\n+Ideally, we would be coordinating with the compiler/rls teams, but they are busy working on making Rust 2018 at the moment.\n+The sync-up point will happen some time after the edition, probably early 2019.\n+In the meantime, the goal is to **experiment**, specifically, to figure out how a from-scratch written RLS might look like.\n \n \n ## Data Storage and Protocol implementation\n \n-The fundamental part of any architecture is who owned what data, how the data is mutated and how the data is exposed to user.\n-For storage we use the [salsa](http://github.com/salsa-rs/salsa) library, and the model already seems solid.\n+The fundamental part of any architecture is who owns which data, how the data is mutated and how the data is exposed to user.\n+For storage we use the [salsa](http://github.com/salsa-rs/salsa) library, which provides a solid model that seems to be the way to go.\n \n-Most of modification is driven by the language client, but we also should support watching the file system, current implementation is a stub.\n+Modification to source files is mostly driven by the language client, but we also should support watching the file system. The current\n+file watching implementation is a stub.\n \n **Action Item:** implement reliable file watching service.\n \n We also should extract LSP bits as a reusable library. There's already `gen_lsp_server`, but it is pretty limited.\n \n **Action Item:** try using `gen_lsp_server` in more than one language server, for example for TOML and Nix.\n \n-Note that it is unclear what shape is ideal for `gen_lsp_server`.\n-I'd rather avoid futures: they bring significant runtime complexity (call stacks become insane), but we don't have c10k problem to solve.\n-Current interface is based on crossbeam-channel, but it's not clear if that is the best choice.\n+The ideal architecture for `gen_lsp_server` is still unclear. I'd rather avoid futures: they bring significant runtime complexity\n+(call stacks become insane) and the performance benefits are negligible for our use case (one thread per request is perfectly OK given\n+the low amount of requests a language server receives). The current interface is based on crossbeam-channel, but it's not clear\n+if that is the best choice.\n \n \n ## Low-effort, high payoff features\n \n Implementing 20% of type inference will give use 80% of completion.\n-Thus it makes sense to try to get some name resolution, type inference and trait matching implemented, even if all this code will be removed when we start sharing code with compiler.\n+Thus it makes sense to partially implement name resolution, type inference and trait matching, even though there is a chance that\n+this code is replaced later on when we integrate with the compiler\n \n Specifically, we need to:\n \n-**Action Item:** implement path resolution, so that we get completion in imports and such.\n-**Action Item:** implement simple type inference, so that we get completion for inherent methods.\n-**Action Item:** implement nicer completion infrastructure, so that we have icons, snippets, doc comments, after insert callbacks, ...\n+* **Action Item:** implement path resolution, so that we get completion in imports and such.\n+* **Action Item:** implement simple type inference, so that we get completion for inherent methods.\n+* **Action Item:** implement nicer completion infrastructure, so that we have icons, snippets, doc comments, after insert callbacks, ...\n \n \n ## Dragons to kill\n \n To make experiments most effective, we should try to prototype solutions for the hardest problems.\n-In case of Rust, the two hardest problems are:\n+In the case of Rust, the two hardest problems are:\n   * Conditional compilation and source/model mismatch.\n     A single source file might correspond to several entities in the semantic model.\n     For example, different cfg flags produce effectively different crates from the same source.\n@@ -68,7 +71,7 @@ In case of Rust, the two hardest problems are:\n \n \n For the first bullet point, we need to design descriptors infra and explicit mapping step between sources and semantic model, which is intentionally fuzzy in one direction.\n-The action item here is basically \"write code, see what works, keep high-level picture in mind\".\n+The **action item** here is basically \"write code, see what works, keep high-level picture in mind\".\n \n-For the second bullet point there's hope that salsa with its deep memorization will give us fast enough solution even without full on-demand.\n-Again, action item is to write the code and see what works. Salsa itself uses macros heavily, so it should be a great test.\n+For the second bullet point, there's hope that salsa with its deep memoization will result in a fast enough solution even without being fully on-demand.\n+Again, the **action item** is to write the code and see what works. Salsa itself uses macros heavily, so it should be a great test."}]}