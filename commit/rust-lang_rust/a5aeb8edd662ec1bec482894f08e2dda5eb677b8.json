{"sha": "a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YWViOGVkZDY2MmVjMWJlYzQ4Mjg5NGYwOGUyZGRhNWViNjc3Yjg=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-09-10T15:59:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Transfered memcpy and memset to BuilderMethods", "tree": {"sha": "71edd6239d1ce0f43eedf71ea47f28fef38fca13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71edd6239d1ce0f43eedf71ea47f28fef38fca13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "html_url": "https://github.com/rust-lang/rust/commit/a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0", "html_url": "https://github.com/rust-lang/rust/commit/3c082a23e838a4a852eefdaa9da61fd3dfe1e2d0"}], "stats": {"total": 209, "additions": 110, "deletions": 99}, "files": [{"sha": "18ad3153f312e4ae90f7ad12e1b97e1dbda3c863", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use llvm::{self, AttributePlace};\n-use base;\n use builder::{Builder, MemFlags};\n use context::CodegenCx;\n use mir::place::PlaceRef;\n@@ -239,13 +238,14 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                 bx.store(val, llscratch, scratch_align);\n \n                 // ...and then memcpy it to the intended destination.\n-                base::call_memcpy(bx,\n-                                  bx.pointercast(dst.llval, cx.type_i8p()),\n-                                  self.layout.align,\n-                                  bx.pointercast(llscratch, cx.type_i8p()),\n-                                  scratch_align,\n-                                  cx.const_usize(self.layout.size.bytes()),\n-                                  MemFlags::empty());\n+                bx.memcpy(\n+                    bx.pointercast(dst.llval, cx.type_i8p()),\n+                    self.layout.align,\n+                    bx.pointercast(llscratch, cx.type_i8p()),\n+                    scratch_align,\n+                    cx.const_usize(self.layout.size.bytes()),\n+                    MemFlags::empty()\n+                );\n \n                 bx.lifetime_end(llscratch, scratch_size);\n             }"}, {"sha": "9eb36e6f6905c5f7d7603f4d93e996c1b2bb7c8f", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -433,30 +433,6 @@ pub fn to_immediate_scalar<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n     val\n }\n \n-pub fn call_memcpy<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    dst: Builder::Value,\n-    dst_align: Align,\n-    src: Builder::Value,\n-    src_align: Align,\n-    n_bytes: Builder::Value,\n-    flags: MemFlags,\n-) {\n-    if flags.contains(MemFlags::NONTEMPORAL) {\n-        // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n-        let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, bx.cx().type_ptr_to(bx.cx().val_ty(val)));\n-        bx.store_with_flags(val, ptr, dst_align, flags);\n-        return;\n-    }\n-    let cx = bx.cx();\n-    let src_ptr = bx.pointercast(src, cx.type_i8p());\n-    let dst_ptr = bx.pointercast(dst, cx.type_i8p());\n-    let size = bx.intcast(n_bytes, cx.type_isize(), false);\n-    let volatile = flags.contains(MemFlags::VOLATILE);\n-    bx.memcpy(dst_ptr, dst_align.abi(), src_ptr, src_align.abi(), size, volatile);\n-}\n-\n pub fn memcpy_ty<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n     bx: &Builder,\n     dst: Builder::Value,\n@@ -471,22 +447,7 @@ pub fn memcpy_ty<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n         return;\n     }\n \n-    call_memcpy(bx, dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n-}\n-\n-pub fn call_memset<'a, 'tcx: 'a, Builder: BuilderMethods<'a, 'tcx>>(\n-    bx: &Builder,\n-    ptr: Builder::Value,\n-    fill_byte: Builder::Value,\n-    size: Builder::Value,\n-    align: Builder::Value,\n-    volatile: bool,\n-) -> Builder::Value {\n-    let ptr_width = &bx.sess().target.target.target_pointer_width;\n-    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = bx.cx().get_intrinsic(&intrinsic_key);\n-    let volatile = bx.cx().const_bool(volatile);\n-    bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n+    bx.memcpy(dst, dst_align, src, src_align, bx.cx().const_usize(size), flags);\n }\n \n pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'tcx>) {"}, {"sha": "b6a3267b4b4b6b6d087e5c54d713426a98535df0", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -785,24 +785,63 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn memcpy(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+    fn memcpy(&self, dst: &'ll Value, dst_align: Align,\n+                  src: &'ll Value, src_align: Align,\n+                  size: &'ll Value, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.cx().type_ptr_to(self.cx().val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.cx().type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.cx().type_i8p());\n+        let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align as c_uint,\n-                                      src, src_align as c_uint, size, is_volatile)\n+            llvm::LLVMRustBuildMemCpy(self.llbuilder, dst, dst_align.abi() as c_uint,\n+                                      src, src_align.abi() as c_uint, size, is_volatile);\n         }\n     }\n \n-    fn memmove(&self, dst: &'ll Value, dst_align: u64,\n-                  src: &'ll Value, src_align: u64,\n-                  size: &'ll Value, is_volatile: bool) -> &'ll Value {\n+    fn memmove(&self, dst: &'ll Value, dst_align: Align,\n+                  src: &'ll Value, src_align: Align,\n+                  size: &'ll Value, flags: MemFlags) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.cx().type_ptr_to(self.cx().val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.cx().type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.cx().type_i8p());\n+        let src = self.pointercast(src, self.cx().type_i8p());\n         unsafe {\n-            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align as c_uint,\n-                                      src, src_align as c_uint, size, is_volatile)\n+            llvm::LLVMRustBuildMemMove(self.llbuilder, dst, dst_align.abi() as c_uint,\n+                                      src, src_align.abi() as c_uint, size, is_volatile);\n         }\n     }\n \n+    fn memset(\n+        &self,\n+        ptr: &'ll Value,\n+        fill_byte: &'ll Value,\n+        size: &'ll Value,\n+        align: Align,\n+        flags: MemFlags,\n+    ) {\n+        let ptr_width = &self.sess().target.target.target_pointer_width;\n+        let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n+        let llintrinsicfn = self.cx().get_intrinsic(&intrinsic_key);\n+        let ptr = self.pointercast(ptr, self.cx().type_i8p());\n+        let align = self.cx().const_u32(align.abi() as u32);\n+        let volatile = self.cx().const_bool(flags.contains(MemFlags::VOLATILE));\n+        self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n+    }\n+\n     fn minnum(&self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n         self.count_insn(\"minnum\");\n         unsafe {"}, {"sha": "0a3f9dba6d8be068e225f0e66bc30f2ed4806939", "filename": "src/librustc_codegen_llvm/interfaces/builder.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbuilder.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -170,12 +170,20 @@ pub trait BuilderMethods<'a, 'tcx: 'a>: Backend {\n     ) -> Option<Self::Value>;\n \n \n-    fn memcpy(&self, dst: Self::Value, dst_align: u64,\n-                  src: Self::Value, src_align: u64,\n-                  size: Self::Value, is_volatile: bool) -> Self::Value;\n-    fn memmove(&self, dst: Self::Value, dst_align: u64,\n-                  src: Self::Value, src_align: u64,\n-                  size: Self::Value, is_volatile: bool) -> Self::Value;\n+    fn memcpy(&self, dst: Self::Value, dst_align: Align,\n+                  src: Self::Value, src_align: Align,\n+                  size: Self::Value, flags: MemFlags);\n+    fn memmove(&self, dst: Self::Value, dst_align: Align,\n+                  src: Self::Value, src_align: Align,\n+                  size: Self::Value, flags: MemFlags);\n+    fn memset(\n+        &self,\n+        ptr: Self::Value,\n+        fill_byte: Self::Value,\n+        size: Self::Value,\n+        align: Align,\n+        flags: MemFlags,\n+    );\n \n     fn minnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn maxnum(&self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;"}, {"sha": "4460be7e8e76632710f7a3314a65fd5fd5e55f61", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::layout::LayoutOf;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use value::Value;\n \n use interfaces::{\n@@ -228,28 +228,34 @@ pub fn codegen_intrinsic_call(\n \n         \"copy_nonoverlapping\" => {\n             copy_intrinsic(bx, false, false, substs.type_at(0),\n-                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate());\n+            return;\n         }\n         \"copy\" => {\n             copy_intrinsic(bx, true, false, substs.type_at(0),\n-                           args[1].immediate(), args[0].immediate(), args[2].immediate())\n+                           args[1].immediate(), args[0].immediate(), args[2].immediate());\n+            return;\n         }\n         \"write_bytes\" => {\n             memset_intrinsic(bx, false, substs.type_at(0),\n-                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate());\n+            return;\n         }\n \n         \"volatile_copy_nonoverlapping_memory\" => {\n             copy_intrinsic(bx, false, true, substs.type_at(0),\n-                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate());\n+            return;\n         }\n         \"volatile_copy_memory\" => {\n             copy_intrinsic(bx, true, true, substs.type_at(0),\n-                           args[0].immediate(), args[1].immediate(), args[2].immediate())\n+                           args[0].immediate(), args[1].immediate(), args[2].immediate());\n+            return;\n         }\n         \"volatile_set_memory\" => {\n             memset_intrinsic(bx, true, substs.type_at(0),\n-                             args[0].immediate(), args[1].immediate(), args[2].immediate())\n+                             args[0].immediate(), args[1].immediate(), args[2].immediate());\n+            return;\n         }\n         \"volatile_load\" | \"unaligned_volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n@@ -725,17 +731,18 @@ fn copy_intrinsic(\n     dst: &'ll Value,\n     src: &'ll Value,\n     count: &'ll Value,\n-) -> &'ll Value {\n-    let cx = bx.cx();\n-    let (size, align) = cx.size_and_align_of(ty);\n-    let size = cx.const_usize(size.bytes());\n-    let align = align.abi();\n-    let dst_ptr = bx.pointercast(dst, cx.type_i8p());\n-    let src_ptr = bx.pointercast(src, cx.type_i8p());\n+) {\n+    let (size, align) = bx.cx().size_and_align_of(ty);\n+    let size = bx.mul(bx.cx().const_usize(size.bytes()), count);\n+    let flags = if volatile {\n+        MemFlags::VOLATILE\n+    } else {\n+        MemFlags::empty()\n+    };\n     if allow_overlap {\n-        bx.memmove(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+        bx.memmove(dst, align, src, align, size, flags);\n     } else {\n-        bx.memcpy(dst_ptr, align, src_ptr, align, bx.mul(size, count), volatile)\n+        bx.memcpy(dst, align, src, align, size, flags);\n     }\n }\n \n@@ -746,13 +753,15 @@ fn memset_intrinsic(\n     dst: &'ll Value,\n     val: &'ll Value,\n     count: &'ll Value\n-) -> &'ll Value {\n-    let cx = bx.cx();\n-    let (size, align) = cx.size_and_align_of(ty);\n-    let size = cx.const_usize(size.bytes());\n-    let align = cx.const_i32(align.abi() as i32);\n-    let dst = bx.pointercast(dst, cx.type_i8p());\n-    call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n+) {\n+    let (size, align) = bx.cx().size_and_align_of(ty);\n+    let size = bx.cx().const_usize(size.bytes());\n+    let flags = if volatile {\n+        MemFlags::VOLATILE\n+    } else {\n+        MemFlags::empty()\n+    };\n+    bx.memset(dst, val, bx.mul(size, count), align, flags);\n }\n \n fn try_intrinsic("}, {"sha": "3e1fd946ea5d12a9065f9c835359a01f11f5ea5a", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -349,7 +349,7 @@ impl OperandValue<&'ll Value> {\n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n         let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, \"unsized_tmp\", max_align);\n-        base::call_memcpy(bx, lldst, max_align, llptr, min_align, llsize, flags);\n+        bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place.\n         let indirect_operand = OperandValue::Pair(lldst, llextra);"}, {"sha": "b26a2a3da39375af56b28f3735e6df8ddb9ae54a", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, Size, VariantIdx};\n use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use base;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use common::{CodegenCx, IntPredicate};\n use type_of::LayoutLlvmExt;\n use value::Value;\n@@ -381,15 +381,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                        bx.sess().target.target.arch == \"aarch64\" {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n-                        let llptr = bx.pointercast(\n-                            self.llval,\n-                            bx.cx().type_ptr_to(bx.cx().type_i8())\n-                        );\n                         let fill_byte = bx.cx().const_u8(0);\n                         let (size, align) = self.layout.size_and_align();\n                         let size = bx.cx().const_usize(size.bytes());\n-                        let align = bx.cx().const_u32(align.abi() as u32);\n-                        base::call_memset(bx, llptr, fill_byte, size, align, false);\n+                        bx.memset(self.llval, fill_byte, size, align, MemFlags::empty());\n                     }\n \n                     let niche = self.project_field(bx, 0);"}, {"sha": "1cb9a9b5ae12fe1b6b35b2e701f7213215cb397e", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5aeb8edd662ec1bec482894f08e2dda5eb677b8/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=a5aeb8edd662ec1bec482894f08e2dda5eb677b8", "patch": "@@ -17,7 +17,7 @@ use rustc_apfloat::{ieee, Float, Status, Round};\n use std::{u128, i128};\n \n use base;\n-use builder::Builder;\n+use builder::{Builder, MemFlags};\n use callee;\n use common::{self, IntPredicate, RealPredicate};\n use monomorphize;\n@@ -104,20 +104,19 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 let start = dest.project_index(&bx, bx.cx().const_usize(0)).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let align = bx.cx().const_i32(dest.align.abi() as i32);\n                     let size = bx.cx().const_usize(dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if bx.cx().is_const_integral(v) && bx.cx().const_to_uint(v) == 0 {\n                         let fill = bx.cx().const_u8(0);\n-                        base::call_memset(&bx, start, fill, size, align, false);\n+                        bx.memset(start, fill, size, dest.align, MemFlags::empty());\n                         return bx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n                     if bx.cx().val_ty(v) == bx.cx().type_i8() {\n-                        base::call_memset(&bx, start, v, size, align, false);\n+                        bx.memset(start, v, size, dest.align, MemFlags::empty());\n                         return bx;\n                     }\n                 }"}]}