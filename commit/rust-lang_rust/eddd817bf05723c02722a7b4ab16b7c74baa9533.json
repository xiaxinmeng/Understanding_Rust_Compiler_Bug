{"sha": "eddd817bf05723c02722a7b4ab16b7c74baa9533", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZGQ4MTdiZjA1NzIzYzAyNzIyYTdiNGFiMTZiN2M3NGJhYTk1MzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T03:16:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-19T19:05:18Z"}, "message": "core::rt: Add another context switching operation to the scheduler\n\n`switch_running_tasks_and_then` does a context switch to another\ntask then immediatly runs a closure.", "tree": {"sha": "85febac314930747d724ce7e6f2d4b1437801eab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85febac314930747d724ce7e6f2d4b1437801eab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eddd817bf05723c02722a7b4ab16b7c74baa9533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eddd817bf05723c02722a7b4ab16b7c74baa9533", "html_url": "https://github.com/rust-lang/rust/commit/eddd817bf05723c02722a7b4ab16b7c74baa9533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eddd817bf05723c02722a7b4ab16b7c74baa9533/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d261bb32d95732ef8aa74b010bb8c98f058785b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d261bb32d95732ef8aa74b010bb8c98f058785b2", "html_url": "https://github.com/rust-lang/rust/commit/d261bb32d95732ef8aa74b010bb8c98f058785b2"}], "stats": {"total": 117, "additions": 89, "deletions": 28}, "files": [{"sha": "e0f2397b64b928140ec59365c9e9f694e29e7a75", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 89, "deletions": 28, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/eddd817bf05723c02722a7b4ab16b7c74baa9533/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eddd817bf05723c02722a7b4ab16b7c74baa9533/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=eddd817bf05723c02722a7b4ab16b7c74baa9533", "patch": "@@ -65,6 +65,8 @@ enum CleanupJob {\n \n pub impl Scheduler {\n \n+    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n+\n     fn new(event_loop: ~EventLoopObject) -> Scheduler {\n \n         // Lazily initialize the global state, currently the scheduler TLS key\n@@ -131,6 +133,59 @@ pub impl Scheduler {\n         }\n     }\n \n+    // * Task-context operations\n+\n+    /// Called by a running task to end execution, after which it will\n+    /// be recycled by the scheduler for reuse in a new task.\n+    fn terminate_current_task(~self) {\n+        let mut self = self;\n+        assert!(self.in_task_context());\n+\n+        rtdebug!(\"ending running task\");\n+\n+        let dead_task = self.current_task.swap_unwrap();\n+        self.enqueue_cleanup_job(RecycleTask(dead_task));\n+\n+        local_sched::put(self);\n+\n+        let sched = unsafe { local_sched::unsafe_borrow() };\n+        let (sched_context, last_task_context, _) = sched.get_contexts();\n+        let last_task_context = last_task_context.unwrap();\n+        Context::swap(last_task_context, sched_context);\n+\n+        // Control never reaches here\n+    }\n+\n+    /// Switch directly to another task, without going through the scheduler.\n+    /// You would want to think hard about doing this, e.g. if there are\n+    /// pending I/O events it would be a bad idea.\n+    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+        let mut self = self;\n+        assert!(self.in_task_context());\n+\n+        rtdebug!(\"switching tasks\");\n+\n+        let old_running_task = self.current_task.swap_unwrap();\n+        self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n+        self.current_task = Some(next_task);\n+\n+        local_sched::put(self);\n+\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            let next_task_context = next_task_context.unwrap();\n+            Context::swap(last_task_context, next_task_context);\n+\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            sched.run_cleanup_job();\n+        }\n+    }\n+\n+    // Core scheduling ops\n+\n     fn resume_task_immediately(~self, task: ~Task) {\n         let mut self = self;\n         assert!(!self.in_task_context());\n@@ -161,30 +216,6 @@ pub impl Scheduler {\n         }\n     }\n \n-\n-    // * Task-context operations\n-\n-    /// Called by a running task to end execution, after which it will\n-    /// be recycled by the scheduler for reuse in a new task.\n-    fn terminate_current_task(~self) {\n-        let mut self = self;\n-        assert!(self.in_task_context());\n-\n-        rtdebug!(\"ending running task\");\n-\n-        let dead_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RecycleTask(dead_task));\n-\n-        local_sched::put(self);\n-\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n-\n-        // Control never reaches here\n-    }\n-\n     /// Block a running task, context switch to the scheduler, then pass the\n     /// blocked task to a closure.\n     ///\n@@ -219,14 +250,16 @@ pub impl Scheduler {\n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n         let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n+        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+        self.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         self.current_task = Some(next_task);\n \n         local_sched::put(self);\n@@ -244,9 +277,9 @@ pub impl Scheduler {\n         }\n     }\n \n-    // * Other stuff\n \n-    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n+\n+    // * Other stuff\n \n     fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n         assert!(self.cleanup_job.is_none());\n@@ -422,6 +455,34 @@ fn test_swap_tasks() {\n     }\n }\n \n+#[test]\n+fn test_swap_tasks_then() {\n+    do run_in_bare_thread {\n+        let mut count = 0;\n+        let count_ptr: *mut int = &mut count;\n+\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task1 = ~do Task::new(&mut sched.stack_pool) {\n+            unsafe { *count_ptr = *count_ptr + 1; }\n+            let mut sched = local_sched::take();\n+            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            // Context switch directly to the new task\n+            do sched.switch_running_tasks_and_then(task2) |task1| {\n+                let task1 = Cell(task1);\n+                do local_sched::borrow |sched| {\n+                    sched.task_queue.push_front(task1.take());\n+                }\n+            }\n+            unsafe { *count_ptr = *count_ptr + 1; }\n+        };\n+        sched.task_queue.push_back(task1);\n+        sched.run();\n+        assert!(count == 3);\n+    }\n+}\n+\n #[bench] #[test] #[ignore(reason = \"long test\")]\n fn test_run_a_lot_of_tasks_queued() {\n     do run_in_bare_thread {"}]}