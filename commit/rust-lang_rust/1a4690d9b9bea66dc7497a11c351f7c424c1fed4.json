{"sha": "1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "node_id": "C_kwDOAAsO6NoAKDFhNDY5MGQ5YjliZWE2NmRjNzQ5N2ExMWMzNTFmN2M0MjRjMWZlZDQ", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-05-01T11:29:47Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-05-09T21:02:57Z"}, "message": "Thorough merge after GC\n\nincluding accurate eq impl for UniMap\n\nCo-authored-by: Ralf Jung <post@ralfj.de>", "tree": {"sha": "f319001120583241462229301abaf6b080a95af7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f319001120583241462229301abaf6b080a95af7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "comment_count": 0, "verification": {"verified": false, "reason": "invalid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEE1bhy5AfUOHIeWIegAOdl+n9PLt4FAmRatQsACgkQAOdl+n9P\nLt7aNgwAju7w676TUueoJqc9PX1zod+Z915o0dCayVoVWx8tMJpYV4BBqbjiX6wI\nHwpH+hLJxLg0fQ2h2YGu7Ct/0PDHf8FL3VH0Kfp3E7ZC+7carV1RhANffJPzD4xR\n+3yozOqeIpME/yS8oWtNGoFRNGqeHLlUrmJPtoTJEV8V9l/gyvoAVV7bC4ektC40\nvCVAtDCcWd8NwlG0W1JUuzuuW/E742bMiPiFPBKLaDkklr7VWFaznMfKzYwNXbLw\nr3KRHE8s1cs9cJLffqBJelePepf/q8+d4RyDCc+o0ERRbk//ZUZZAPhrSzRzHfDO\nvjjw6OY2gO6RBT9oooAP89mA0JHgC8rI8TnlY/fQWMn0UgkbS7UeEBUtYC003dYI\nXLXIiWkijZcEhhAbGMcHTftWRC+Lx/TcdHZvcdYUwQsvMPQ6InBRHgwfyYoBgJAW\nIycDO7IKItmfaYMuAq7XCIiYHufftaluG7g9mzKZje5jy/G2RBdV7eJ0eWYuPSjL\n6BLX+fLA\n=dAK3\n-----END PGP SIGNATURE-----", "payload": "tree f319001120583241462229301abaf6b080a95af7\nparent 84f80f1fc9f89c8abbbbcbe55cc0bd1d0ae21c28\nauthor Neven Villani <vanille@crans.org> 1682940587 +0200\ncommitter Neven Villani <vanille@crans.org> 1683666177 +0200\n\nThorough merge after GC\n\nincluding accurate eq impl for UniMap\n\nCo-authored-by: Ralf Jung <post@ralfj.de>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "html_url": "https://github.com/rust-lang/rust/commit/1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f80f1fc9f89c8abbbbcbe55cc0bd1d0ae21c28", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f80f1fc9f89c8abbbbcbe55cc0bd1d0ae21c28", "html_url": "https://github.com/rust-lang/rust/commit/84f80f1fc9f89c8abbbbcbe55cc0bd1d0ae21c28"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "de6760a035969ad8a80c3e02eb1d71f8f61d6a88", "filename": "src/tools/miri/bench-cargo-miri/zip-equal/Cargo.lock", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.lock?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -0,0 +1,7 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"zip-equal\"\n+version = \"0.1.0\""}, {"sha": "f4208de727dbce505ee0e8ef504755e2719a651b", "filename": "src/tools/miri/bench-cargo-miri/zip-equal/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2FCargo.toml?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"zip-equal\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "ba4e9b41d1d1d093947503e6a213975039aa4c78", "filename": "src/tools/miri/bench-cargo-miri/zip-equal/src/main.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fbench-cargo-miri%2Fzip-equal%2Fsrc%2Fmain.rs?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -0,0 +1,22 @@\n+//! This is a pathological pattern in which opportunities to merge\n+//! adjacent identical items in the RangeMap are not properly detected\n+//! because `RangeMap::iter_mut` is never called on overlapping ranges\n+//! and thus never merges previously split ranges. This does not produce any\n+//! additional cost for access operations, but it makes the job of the Tree Borrows\n+//! GC procedure much more costly.\n+//! See https://github.com/rust-lang/miri/issues/2863\n+\n+const LENGTH: usize = (1 << 14) - 1;\n+const LONG: &[u8] = &[b'x'; LENGTH];\n+\n+fn main() {\n+    assert!(eq(LONG, LONG))\n+}\n+\n+fn eq(s1: &[u8], s2: &[u8]) -> bool {\n+    if s1.len() != s2.len() {\n+        return false;\n+    }\n+\n+    s1.iter().zip(s2).all(|(c1, c2)| *c1 == *c2)\n+}"}, {"sha": "52947aa0f9fe2baca934ed10d5ae2aae4ba4b9c5", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -488,7 +488,13 @@ impl<'tcx> Tree {\n /// Integration with the BorTag garbage collector\n impl Tree {\n     pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n-        assert!(self.keep_only_needed(self.root, live_tags)); // root can't be removed\n+        let root_is_needed = self.keep_only_needed(self.root, live_tags); // root can't be removed\n+        assert!(root_is_needed);\n+        // Right after the GC runs is a good moment to check if we can\n+        // merge some adjacent ranges that were made equal by the removal of some\n+        // tags (this does not necessarily mean that they have identical internal representations,\n+        // see the `PartialEq` impl for `UniValMap`)\n+        self.rperms.merge_adjacent_thorough();\n     }\n \n     /// Traverses the entire tree looking for useless tags."}, {"sha": "58af32385c5070fdd0a30ea4042918b1f1ecf60b", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/unimap.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -36,13 +36,42 @@ pub struct UniKeyMap<K> {\n }\n \n /// From UniIndex to V\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, Eq)]\n pub struct UniValMap<V> {\n     /// The mapping data. Thanks to Vec we get both fast accesses, and\n     /// a memory-optimal representation if there are few deletions.\n     data: Vec<Option<V>>,\n }\n \n+impl<V: PartialEq> UniValMap<V> {\n+    /// Exact equality of two maps.\n+    /// Less accurate but faster than `equivalent`, mostly because\n+    /// of the fast path when the lengths are different.\n+    pub fn identical(&self, other: &Self) -> bool {\n+        self.data == other.data\n+    }\n+\n+    /// Equality up to trailing `None`s of two maps, i.e.\n+    /// do they represent the same mapping ?\n+    pub fn equivalent(&self, other: &Self) -> bool {\n+        let min_len = self.data.len().min(other.data.len());\n+        self.data[min_len..].iter().all(Option::is_none)\n+            && other.data[min_len..].iter().all(Option::is_none)\n+            && (self.data[..min_len] == other.data[..min_len])\n+    }\n+}\n+\n+impl<V: PartialEq> PartialEq for UniValMap<V> {\n+    /// 2023-05: We found that using `equivalent` rather than `identical`\n+    /// in the equality testing of the `RangeMap` is neutral for most\n+    /// benchmarks, while being quite beneficial for `zip-equal`\n+    /// and to a lesser extent for `unicode`, `slice-get-unchecked` and\n+    /// `backtraces` as well.\n+    fn eq(&self, other: &Self) -> bool {\n+        self.equivalent(other)\n+    }\n+}\n+\n impl<V> Default for UniValMap<V> {\n     fn default() -> Self {\n         Self { data: Vec::default() }"}, {"sha": "146715ddda2380bcc5305cfd6b699842030c1916", "filename": "src/tools/miri/src/range_map.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4690d9b9bea66dc7497a11c351f7c424c1fed4/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Frange_map.rs?ref=1a4690d9b9bea66dc7497a11c351f7c424c1fed4", "patch": "@@ -227,6 +227,24 @@ impl<T> RangeMap<T> {\n         };\n         slice.iter_mut().map(|elem| (elem.range.clone(), &mut elem.data))\n     }\n+\n+    /// Remove all adjacent duplicates\n+    pub fn merge_adjacent_thorough(&mut self)\n+    where\n+        T: PartialEq,\n+    {\n+        let clean = Vec::with_capacity(self.v.len());\n+        for elem in std::mem::replace(&mut self.v, clean) {\n+            if let Some(prev) = self.v.last_mut() {\n+                if prev.data == elem.data {\n+                    assert_eq!(prev.range.end, elem.range.start);\n+                    prev.range.end = elem.range.end;\n+                    continue;\n+                }\n+            }\n+            self.v.push(elem);\n+        }\n+    }\n }\n \n #[cfg(test)]"}]}