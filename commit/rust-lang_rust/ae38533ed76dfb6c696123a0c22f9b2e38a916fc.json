{"sha": "ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "node_id": "C_kwDOAAsO6NoAKGFlMzg1MzNlZDc2ZGZiNmM2OTYxMjNhMGMyMmY5YjJlMzhhOTE2ZmM", "commit": {"author": {"name": "Lo\u00efc BRANSTETT", "email": "lolo.branstett@numericable.fr", "date": "2022-04-22T10:52:51Z"}, "committer": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2022-05-24T11:43:08Z"}, "message": "Clean up condition evaluation system", "tree": {"sha": "cda90eed23b024453cd0879e64a6abbef9e0515e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cda90eed23b024453cd0879e64a6abbef9e0515e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "html_url": "https://github.com/rust-lang/rust/commit/ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae38533ed76dfb6c696123a0c22f9b2e38a916fc/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "653463731a7f01f519cf85f444869def27f00395", "url": "https://api.github.com/repos/rust-lang/rust/commits/653463731a7f01f519cf85f444869def27f00395", "html_url": "https://github.com/rust-lang/rust/commit/653463731a7f01f519cf85f444869def27f00395"}], "stats": {"total": 138, "additions": 71, "deletions": 67}, "files": [{"sha": "947f04c6840e4dfdfb0a77908f14aa8e3a39a4a1", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ae38533ed76dfb6c696123a0c22f9b2e38a916fc/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae38533ed76dfb6c696123a0c22f9b2e38a916fc/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "patch": "@@ -454,6 +454,15 @@ pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n     sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n+#[derive(Clone, Debug)]\n+pub struct Condition {\n+    pub name: Symbol,\n+    pub name_span: Span,\n+    pub value: Option<Symbol>,\n+    pub value_span: Option<Span>,\n+    pub span: Span,\n+}\n+\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(\n     cfg: &ast::MetaItem,\n@@ -462,70 +471,42 @@ pub fn cfg_matches(\n     features: Option<&Features>,\n ) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n-        try_gate_cfg(cfg, sess, features);\n-        let error = |span, msg| {\n-            sess.span_diagnostic.span_err(span, msg);\n-            true\n-        };\n-        if cfg.path.segments.len() != 1 {\n-            return error(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n-        }\n-        match &cfg.kind {\n-            MetaItemKind::List(..) => {\n-                error(cfg.span, \"unexpected parentheses after `cfg` predicate key\")\n-            }\n-            MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n-                handle_errors(\n-                    sess,\n-                    lit.span,\n-                    AttrError::UnsupportedLiteral(\n-                        \"literal in `cfg` predicate value must be a string\",\n-                        lit.kind.is_bytestr(),\n-                    ),\n+        try_gate_cfg(cfg.name, cfg.span, sess, features);\n+        if let Some(names_valid) = &sess.check_config.names_valid {\n+            if !names_valid.contains(&cfg.name) {\n+                sess.buffer_lint_with_diagnostic(\n+                    UNEXPECTED_CFGS,\n+                    cfg.span,\n+                    lint_node_id,\n+                    \"unexpected `cfg` condition name\",\n+                    BuiltinLintDiagnostics::UnexpectedCfg((cfg.name, cfg.name_span), None),\n                 );\n-                true\n             }\n-            MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n-                let name = ident.name;\n-                let value = cfg.value_str();\n-                if let Some(names_valid) = &sess.check_config.names_valid {\n-                    if !names_valid.contains(&name) {\n-                        sess.buffer_lint_with_diagnostic(\n-                            UNEXPECTED_CFGS,\n-                            cfg.span,\n-                            lint_node_id,\n-                            \"unexpected `cfg` condition name\",\n-                            BuiltinLintDiagnostics::UnexpectedCfg((name, ident.span), None),\n-                        );\n-                    }\n-                }\n-                if let Some(value) = value {\n-                    if let Some(values) = &sess.check_config.values_valid.get(&name) {\n-                        if !values.contains(&value) {\n-                            sess.buffer_lint_with_diagnostic(\n-                                UNEXPECTED_CFGS,\n-                                cfg.span,\n-                                lint_node_id,\n-                                \"unexpected `cfg` condition value\",\n-                                BuiltinLintDiagnostics::UnexpectedCfg(\n-                                    (name, ident.span),\n-                                    Some((value, cfg.name_value_literal_span().unwrap())),\n-                                ),\n-                            );\n-                        }\n-                    }\n+        }\n+        if let Some(value) = cfg.value {\n+            if let Some(values) = &sess.check_config.values_valid.get(&cfg.name) {\n+                if !values.contains(&value) {\n+                    sess.buffer_lint_with_diagnostic(\n+                        UNEXPECTED_CFGS,\n+                        cfg.span,\n+                        lint_node_id,\n+                        \"unexpected `cfg` condition value\",\n+                        BuiltinLintDiagnostics::UnexpectedCfg(\n+                            (cfg.name, cfg.name_span),\n+                            cfg.value_span.map(|vs| (value, vs)),\n+                        ),\n+                    );\n                 }\n-                sess.config.contains(&(name, value))\n             }\n         }\n+        sess.config.contains(&(cfg.name, cfg.value))\n     })\n }\n \n-fn try_gate_cfg(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) {\n-    let gate = find_gated_cfg(|sym| cfg.has_name(sym));\n+fn try_gate_cfg(name: Symbol, span: Span, sess: &ParseSess, features: Option<&Features>) {\n+    let gate = find_gated_cfg(|sym| sym == name);\n     if let (Some(feats), Some(gated_cfg)) = (features, gate) {\n-        gate_cfg(&gated_cfg, cfg.span, sess, feats);\n+        gate_cfg(&gated_cfg, span, sess, feats);\n     }\n }\n \n@@ -563,11 +544,11 @@ pub fn eval_condition(\n     cfg: &ast::MetaItem,\n     sess: &ParseSess,\n     features: Option<&Features>,\n-    eval: &mut impl FnMut(&ast::MetaItem) -> bool,\n+    eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n     match cfg.kind {\n         ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n-            try_gate_cfg(cfg, sess, features);\n+            try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n                     (sym, span)\n@@ -662,7 +643,32 @@ pub fn eval_condition(\n                 }\n             }\n         }\n-        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => eval(cfg),\n+        ast::MetaItemKind::Word | MetaItemKind::NameValue(..) if cfg.path.segments.len() != 1 => {\n+            sess.span_diagnostic\n+                .span_err(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+            true\n+        }\n+        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+            handle_errors(\n+                sess,\n+                lit.span,\n+                AttrError::UnsupportedLiteral(\n+                    \"literal in `cfg` predicate value must be a string\",\n+                    lit.kind.is_bytestr(),\n+                ),\n+            );\n+            true\n+        }\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n+            let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+            eval(Condition {\n+                name: ident.name,\n+                name_span: ident.span,\n+                value: cfg.value_str(),\n+                value_span: cfg.name_value_literal_span(),\n+                span: cfg.span,\n+            })\n+        }\n     }\n }\n "}, {"sha": "ed7d16f7a5419e96a66be92abf801dea597b9cf3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae38533ed76dfb6c696123a0c22f9b2e38a916fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae38533ed76dfb6c696123a0c22f9b2e38a916fc/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=ae38533ed76dfb6c696123a0c22f9b2e38a916fc", "patch": "@@ -89,8 +89,8 @@ impl<'tcx> OnUnimplementedDirective {\n                         None,\n                     )\n                 })?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |item| {\n-                if let Some(symbol) = item.value_str() && let Err(guar) = parse_value(symbol) {\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n+                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n                     errored = Some(guar);\n                 }\n                 true\n@@ -226,14 +226,12 @@ impl<'tcx> OnUnimplementedDirective {\n                 condition,\n                 &tcx.sess.parse_sess,\n                 Some(tcx.features()),\n-                &mut |c| {\n-                    c.ident().map_or(false, |ident| {\n-                        let value = c.value_str().map(|s| {\n-                            OnUnimplementedFormatString(s).format(tcx, trait_ref, &options_map)\n-                        });\n+                &mut |cfg| {\n+                    let value = cfg.value.map(|v| {\n+                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n+                    });\n \n-                        options.contains(&(ident.name, value))\n-                    })\n+                    options.contains(&(cfg.name, value))\n                 },\n             ) {\n                 debug!(\"evaluate: skipping {:?} due to condition\", command);"}]}