{"sha": "78e094632ec6160c3d2cfaad777c16a27ce08609", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZTA5NDYzMmVjNjE2MGMzZDJjZmFhZDc3N2MxNmEyN2NlMDg2MDk=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-21T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-08-21T11:17:20Z"}, "message": "Remove wrapper type handling absent raw standard streams\n\nRaw standard streams are always available.  Remove unused wrapper type\nthat was supposed to be responsible for handling their absence.", "tree": {"sha": "3a34cfbbffb5a015e138f173f834de74ab3fb994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a34cfbbffb5a015e138f173f834de74ab3fb994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e094632ec6160c3d2cfaad777c16a27ce08609", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e094632ec6160c3d2cfaad777c16a27ce08609", "html_url": "https://github.com/rust-lang/rust/commit/78e094632ec6160c3d2cfaad777c16a27ce08609", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e094632ec6160c3d2cfaad777c16a27ce08609/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a00421ba4daae419d06b67bd1bb46d7930b0dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a00421ba4daae419d06b67bd1bb46d7930b0dc7", "html_url": "https://github.com/rust-lang/rust/commit/4a00421ba4daae419d06b67bd1bb46d7930b0dc7"}], "stats": {"total": 133, "additions": 33, "deletions": 100}, "files": [{"sha": "3943c66aad53a1ec9ecffd946c6c3401470bc7c7", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 33, "deletions": 100, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/78e094632ec6160c3d2cfaad777c16a27ce08609/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e094632ec6160c3d2cfaad777c16a27ce08609/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=78e094632ec6160c3d2cfaad777c16a27ce08609", "patch": "@@ -83,11 +83,11 @@ const fn stderr_raw() -> StderrRaw {\n \n impl Read for StdinRaw {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n+        handle_ebadf(self.0.read(buf), 0)\n     }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n+        handle_ebadf(self.0.read_vectored(bufs), 0)\n     }\n \n     #[inline]\n@@ -101,25 +101,22 @@ impl Read for StdinRaw {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        self.0.read_to_end(buf)\n+        handle_ebadf(self.0.read_to_end(buf), 0)\n     }\n \n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n-        self.0.read_to_string(buf)\n-    }\n-\n-    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n-        self.0.read_exact(buf)\n+        handle_ebadf(self.0.read_to_string(buf), 0)\n     }\n }\n \n impl Write for StdoutRaw {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n+        handle_ebadf(self.0.write(buf), buf.len())\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n+        let total = bufs.iter().map(|b| b.len()).sum();\n+        handle_ebadf(self.0.write_vectored(bufs), total)\n     }\n \n     #[inline]\n@@ -128,29 +125,30 @@ impl Write for StdoutRaw {\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        self.0.flush()\n+        handle_ebadf(self.0.flush(), ())\n     }\n \n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        self.0.write_all(buf)\n+        handle_ebadf(self.0.write_all(buf), ())\n     }\n \n     fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n-        self.0.write_all_vectored(bufs)\n+        handle_ebadf(self.0.write_all_vectored(bufs), ())\n     }\n \n     fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n-        self.0.write_fmt(fmt)\n+        handle_ebadf(self.0.write_fmt(fmt), ())\n     }\n }\n \n impl Write for StderrRaw {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n+        handle_ebadf(self.0.write(buf), buf.len())\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n+        let total = bufs.iter().map(|b| b.len()).sum();\n+        handle_ebadf(self.0.write_vectored(bufs), total)\n     }\n \n     #[inline]\n@@ -159,80 +157,19 @@ impl Write for StderrRaw {\n     }\n \n     fn flush(&mut self) -> io::Result<()> {\n-        self.0.flush()\n+        handle_ebadf(self.0.flush(), ())\n     }\n \n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        self.0.write_all(buf)\n+        handle_ebadf(self.0.write_all(buf), ())\n     }\n \n     fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n-        self.0.write_all_vectored(bufs)\n+        handle_ebadf(self.0.write_all_vectored(bufs), ())\n     }\n \n     fn write_fmt(&mut self, fmt: fmt::Arguments<'_>) -> io::Result<()> {\n-        self.0.write_fmt(fmt)\n-    }\n-}\n-\n-enum Maybe<T> {\n-    Real(T),\n-    Fake,\n-}\n-\n-impl<W: io::Write> io::Write for Maybe<W> {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match *self {\n-            Maybe::Real(ref mut w) => handle_ebadf(w.write(buf), buf.len()),\n-            Maybe::Fake => Ok(buf.len()),\n-        }\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let total = bufs.iter().map(|b| b.len()).sum();\n-        match self {\n-            Maybe::Real(w) => handle_ebadf(w.write_vectored(bufs), total),\n-            Maybe::Fake => Ok(total),\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_write_vectored(&self) -> bool {\n-        match self {\n-            Maybe::Real(w) => w.is_write_vectored(),\n-            Maybe::Fake => true,\n-        }\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        match *self {\n-            Maybe::Real(ref mut w) => handle_ebadf(w.flush(), ()),\n-            Maybe::Fake => Ok(()),\n-        }\n-    }\n-}\n-\n-impl<R: io::Read> io::Read for Maybe<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        match *self {\n-            Maybe::Real(ref mut r) => handle_ebadf(r.read(buf), 0),\n-            Maybe::Fake => Ok(0),\n-        }\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self {\n-            Maybe::Real(r) => handle_ebadf(r.read_vectored(bufs), 0),\n-            Maybe::Fake => Ok(0),\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_read_vectored(&self) -> bool {\n-        match self {\n-            Maybe::Real(w) => w.is_read_vectored(),\n-            Maybe::Fake => true,\n-        }\n+        handle_ebadf(self.0.write_fmt(fmt), ())\n     }\n }\n \n@@ -277,7 +214,7 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n-    inner: Arc<Mutex<BufReader<Maybe<StdinRaw>>>>,\n+    inner: Arc<Mutex<BufReader<StdinRaw>>>,\n }\n \n /// A locked reference to the `Stdin` handle.\n@@ -308,7 +245,7 @@ pub struct Stdin {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdinLock<'a> {\n-    inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n+    inner: MutexGuard<'a, BufReader<StdinRaw>>,\n }\n \n /// Constructs a new handle to the standard input of the current process.\n@@ -352,14 +289,14 @@ pub struct StdinLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<Maybe<StdinRaw>>>> = Lazy::new();\n+    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new();\n     return Stdin {\n         inner: unsafe { INSTANCE.get(stdin_init).expect(\"cannot access stdin during shutdown\") },\n     };\n \n-    fn stdin_init() -> Arc<Mutex<BufReader<Maybe<StdinRaw>>>> {\n+    fn stdin_init() -> Arc<Mutex<BufReader<StdinRaw>>> {\n         // This must not reentrantly access `INSTANCE`\n-        let stdin = Maybe::Real(stdin_raw());\n+        let stdin = stdin_raw();\n         Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n     }\n }\n@@ -536,7 +473,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>>,\n+    inner: Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n }\n \n /// A locked reference to the `Stdout` handle.\n@@ -550,7 +487,7 @@ pub struct Stdout {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n-    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n+    inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n /// Constructs a new handle to the standard output of the current process.\n@@ -594,14 +531,14 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> = Lazy::new();\n+    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new();\n     return Stdout {\n         inner: unsafe { INSTANCE.get(stdout_init).expect(\"cannot access stdout during shutdown\") },\n     };\n \n-    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<Maybe<StdoutRaw>>>>> {\n+    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> {\n         // This must not reentrantly access `INSTANCE`\n-        let stdout = Maybe::Real(stdout_raw());\n+        let stdout = stdout_raw();\n         unsafe {\n             let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n             ret.init();\n@@ -711,7 +648,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: &'static ReentrantMutex<RefCell<Maybe<StderrRaw>>>,\n+    inner: &'static ReentrantMutex<RefCell<StderrRaw>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n@@ -725,7 +662,7 @@ pub struct Stderr {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n-    inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,\n+    inner: ReentrantMutexGuard<'a, RefCell<StderrRaw>>,\n }\n \n /// Constructs a new handle to the standard error of the current process.\n@@ -774,18 +711,14 @@ pub fn stderr() -> Stderr {\n     //\n     // This has the added benefit of allowing `stderr` to be usable during\n     // process shutdown as well!\n-    static INSTANCE: ReentrantMutex<RefCell<Maybe<StderrRaw>>> =\n-        unsafe { ReentrantMutex::new(RefCell::new(Maybe::Fake)) };\n+    static INSTANCE: ReentrantMutex<RefCell<StderrRaw>> =\n+        unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) };\n \n     // When accessing stderr we need one-time initialization of the reentrant\n-    // mutex, followed by one-time detection of whether we actually have a\n-    // stderr handle or not. Afterwards we can just always use the now-filled-in\n-    // `INSTANCE` value.\n+    // mutex. Afterwards we can just always use the now-filled-in `INSTANCE` value.\n     static INIT: Once = Once::new();\n     INIT.call_once(|| unsafe {\n         INSTANCE.init();\n-        let stderr = stderr_raw();\n-        *INSTANCE.lock().borrow_mut() = Maybe::Real(stderr);\n     });\n     Stderr { inner: &INSTANCE }\n }"}]}