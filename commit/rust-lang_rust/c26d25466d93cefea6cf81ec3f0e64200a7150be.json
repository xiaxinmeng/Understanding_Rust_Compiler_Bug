{"sha": "c26d25466d93cefea6cf81ec3f0e64200a7150be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNmQyNTQ2NmQ5M2NlZmVhNmNmODFlYzNmMGU2NDIwMGE3MTUwYmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2014-03-27T14:47:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-10T22:21:57Z"}, "message": "debuginfo: Implement discriminator type metadata re-use.\n\nAn optimization for sharing the type metadata of generic enum discriminators between monomorphized instances (fixes issue #12840)", "tree": {"sha": "5e4308358f02642dba4be72553f82ee25db29b96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e4308358f02642dba4be72553f82ee25db29b96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c26d25466d93cefea6cf81ec3f0e64200a7150be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c26d25466d93cefea6cf81ec3f0e64200a7150be", "html_url": "https://github.com/rust-lang/rust/commit/c26d25466d93cefea6cf81ec3f0e64200a7150be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c26d25466d93cefea6cf81ec3f0e64200a7150be/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43e8ace76b01820032679f276f3e298b92288ad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/43e8ace76b01820032679f276f3e298b92288ad6", "html_url": "https://github.com/rust-lang/rust/commit/43e8ace76b01820032679f276f3e298b92288ad6"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "c2828b333edd1bb66ab962566a37d712de266678", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c26d25466d93cefea6cf81ec3f0e64200a7150be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c26d25466d93cefea6cf81ec3f0e64200a7150be/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c26d25466d93cefea6cf81ec3f0e64200a7150be", "patch": "@@ -130,6 +130,7 @@ use driver::session::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use lib::llvm::llvm;\n use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n+use metadata::csearch;\n use middle::trans::adt;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, Lvalue};\n@@ -178,6 +179,7 @@ pub struct CrateDebugContext {\n     current_debug_location: Cell<DebugLocation>,\n     created_files: RefCell<HashMap<~str, DIFile>>,\n     created_types: RefCell<HashMap<uint, DIType>>,\n+    created_enum_disr_types: RefCell<HashMap<ast::DefId, DIType>>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name> , @NamespaceTreeNode>>,\n     // This collection is used to assert that composite types (structs, enums, ...) have their\n     // members only set once:\n@@ -196,6 +198,7 @@ impl CrateDebugContext {\n             current_debug_location: Cell::new(UnknownLocation),\n             created_files: RefCell::new(HashMap::new()),\n             created_types: RefCell::new(HashMap::new()),\n+            created_enum_disr_types: RefCell::new(HashMap::new()),\n             namespace_map: RefCell::new(HashMap::new()),\n             composite_types_completed: RefCell::new(HashSet::new()),\n         };\n@@ -1542,24 +1545,45 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         .collect();\n \n     let discriminant_type_metadata = |inttype| {\n-        let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n-        let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n-        let discriminant_base_type_metadata = type_metadata(cx, adt::ty_of_inttype(inttype),\n-                                                            codemap::DUMMY_SP);\n-        enum_name.with_c_str(|enum_name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateEnumerationType(\n-                    DIB(cx),\n-                    containing_scope,\n-                    enum_name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    bytes_to_bits(discriminant_size),\n-                    bytes_to_bits(discriminant_align),\n-                    create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n-                    discriminant_base_type_metadata)\n+        // We can reuse the type of the discriminant for all monomorphized instances of an enum\n+        // because it doesn't depend on any type parameters. The def_id, uniquely identifying the\n+        // enum's polytype acts as key in this cache.\n+        let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n+                                                                 .borrow()\n+                                                                 .find_copy(&enum_def_id);\n+        match cached_discriminant_type_metadata {\n+            Some(discriminant_type_metadata) => discriminant_type_metadata,\n+            None => {\n+                let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n+                let (discriminant_size, discriminant_align) =\n+                    size_and_align_of(cx, discriminant_llvm_type);\n+                let discriminant_base_type_metadata = type_metadata(cx,\n+                                                                    adt::ty_of_inttype(inttype),\n+                                                                    codemap::DUMMY_SP);\n+                let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n+\n+                let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n+                    unsafe {\n+                        llvm::LLVMDIBuilderCreateEnumerationType(\n+                            DIB(cx),\n+                            containing_scope,\n+                            name,\n+                            file_metadata,\n+                            loc.line as c_uint,\n+                            bytes_to_bits(discriminant_size),\n+                            bytes_to_bits(discriminant_align),\n+                            create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n+                            discriminant_base_type_metadata)\n+                    }\n+                });\n+\n+                debug_context(cx).created_enum_disr_types\n+                                 .borrow_mut()\n+                                 .insert(enum_def_id, discriminant_type_metadata);\n+\n+                discriminant_type_metadata\n             }\n-        })\n+        }\n     };\n \n     let type_rep = adt::represent_type(cx, enum_type);\n@@ -1648,6 +1672,16 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             }\n         }\n     };\n+\n+    fn get_enum_discriminant_name(cx: &CrateContext, def_id: ast::DefId) -> token::InternedString {\n+        let name = if def_id.krate == ast::LOCAL_CRATE {\n+            cx.tcx.map.get_path_elem(def_id.node).name()\n+        } else {\n+            csearch::get_item_path(&cx.tcx, def_id).last().unwrap().name()\n+        };\n+\n+        token::get_name(name)\n+    }\n }\n \n enum MemberOffset {"}]}