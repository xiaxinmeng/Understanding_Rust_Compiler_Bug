{"sha": "bf3ef26713b8208e0127f4c51725897dbcd11bd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmM2VmMjY3MTNiODIwOGUwMTI3ZjRjNTE3MjU4OTdkYmNkMTFiZDk=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-14T11:33:20Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-14T22:01:14Z"}, "message": "polymorphize: `I` used if `T` used in `I: Foo<T>`\n\nThis commit adjusts polymorphization's handling of predicates so that\nafter ensuring that `T` is used in `I: Foo<T>` if `I` is used, it now\nensures that `I` is used if `T` is used in `I: Foo<T>`. This is\nnecessary to mark generic parameters that only exist in impl parameters\nas used - thereby avoiding symbol clashes when using the new mangling\nscheme.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "885a852b01789a6ddec14806197a7dd8eb02ede3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/885a852b01789a6ddec14806197a7dd8eb02ede3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf3ef26713b8208e0127f4c51725897dbcd11bd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl83CaoACgkQJZLnbIc4\nH9mGOA/7BK/dWERiCO9w7cFUtLBMHpyi9ysxxQ8xELDlldd5t6kgZU7xxxTeuoE9\nt/XP6OiwP5sBgpLuZBUGlZ+GKuklE3bvI9lzH2uVJs9ygsz+xG7QCNhsQQdh6ist\nG+GshxtPKsSI0Vs+S6ZZdQ4GpqZk+4U7wfEVNHrBasD/RZHQ7Uqy9hg7YAmWriHr\nGwSMSgw3HlB/HBYGRoAjjmrG3+47TdGyQXyy6WGDtzhkMd6MfKmPbVdw01uzHeZF\nARQ/hOWQRx5zM+6hZSEmbVeKvmkdWsV7LQuASjz9uz77sFQxOBwfAIjCF1avEzgv\n8x7AnRq8HazvoSQE5GEJUxDZwIvBBB9M80Q77y3ZANwMwRu4rS4k0dpbWtox5ns+\nS0Nn2Ilw2Q68v9jExkKdDwgGw3gPMPnBD/lK2k6HmXakPdZEMezEAY6XyCXRrJRv\nVnokXtrh4XUtbWco8DpxqRjjywaiH9F6D1jU4Tw1B1wMgmUqVRiTDlOtZnITbrzu\nEIOK8zL3q2OAUeczFrtxfZ8WTYbYTIpPDKY0g8rFvN0f7m7Fnie7UAmNTE/+3rIS\n9O015MonY+d7xxg05I2o7phn24QjBLDeOrD63TDbX2Y8JRHmjYLtfnZgM9s3zqxb\niAqSsaRV5vjKJCZZc0heVGirgXdteS/qmUEKqGJaE0q9FMrdsnw=\n=UJxr\n-----END PGP SIGNATURE-----", "payload": "tree 885a852b01789a6ddec14806197a7dd8eb02ede3\nparent 3fbed1739c384faabf00cd8a62abedbf506e949b\nauthor David Wood <david@davidtw.co> 1597404800 +0100\ncommitter David Wood <david@davidtw.co> 1597442474 +0100\n\npolymorphize: `I` used if `T` used in `I: Foo<T>`\n\nThis commit adjusts polymorphization's handling of predicates so that\nafter ensuring that `T` is used in `I: Foo<T>` if `I` is used, it now\nensures that `I` is used if `T` is used in `I: Foo<T>`. This is\nnecessary to mark generic parameters that only exist in impl parameters\nas used - thereby avoiding symbol clashes when using the new mangling\nscheme.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf3ef26713b8208e0127f4c51725897dbcd11bd9", "html_url": "https://github.com/rust-lang/rust/commit/bf3ef26713b8208e0127f4c51725897dbcd11bd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf3ef26713b8208e0127f4c51725897dbcd11bd9/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fbed1739c384faabf00cd8a62abedbf506e949b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbed1739c384faabf00cd8a62abedbf506e949b", "html_url": "https://github.com/rust-lang/rust/commit/3fbed1739c384faabf00cd8a62abedbf506e949b"}], "stats": {"total": 220, "additions": 189, "deletions": 31}, "files": [{"sha": "d946c1947c2df0178f7891976d8ab3455f23ee15", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 119, "deletions": 31, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=bf3ef26713b8208e0127f4c51725897dbcd11bd9", "patch": "@@ -69,8 +69,7 @@ fn unused_generic_params(tcx: TyCtxt<'_>, def_id: DefId) -> FiniteBitSet<u32> {\n \n     // Visit MIR and accumululate used generic parameters.\n     let body = tcx.optimized_mir(def_id);\n-    let mut vis =\n-        UsedGenericParametersVisitor { tcx, def_id, unused_parameters: &mut unused_parameters };\n+    let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters: &mut unused_parameters };\n     vis.visit_body(body);\n     debug!(\"unused_generic_params: (after visitor) unused_parameters={:?}\", unused_parameters);\n \n@@ -120,45 +119,101 @@ fn mark_used_by_predicates<'tcx>(\n     def_id: DefId,\n     unused_parameters: &mut FiniteBitSet<u32>,\n ) {\n-    let def_id = tcx.closure_base_def_id(def_id);\n-\n-    let is_self_ty_used = |unused_parameters: &mut FiniteBitSet<u32>, self_ty: Ty<'tcx>| {\n-        debug!(\"unused_generic_params: self_ty={:?}\", self_ty);\n-        if let ty::Param(param) = self_ty.kind {\n-            !unused_parameters.contains(param.index).unwrap_or(false)\n-        } else {\n-            false\n-        }\n+    let is_ty_used = |unused_parameters: &FiniteBitSet<u32>, ty: Ty<'tcx>| -> bool {\n+        let mut vis = IsUsedGenericParams { unused_parameters };\n+        ty.visit_with(&mut vis)\n     };\n \n     let mark_ty = |unused_parameters: &mut FiniteBitSet<u32>, ty: Ty<'tcx>| {\n-        let mut vis = UsedGenericParametersVisitor { tcx, def_id, unused_parameters };\n+        let mut vis = MarkUsedGenericParams { tcx, def_id, unused_parameters };\n         ty.visit_with(&mut vis);\n     };\n \n+    let def_id = tcx.closure_base_def_id(def_id);\n     let predicates = tcx.explicit_predicates_of(def_id);\n-    debug!(\"mark_parameters_used_in_predicates: predicates_of={:?}\", predicates);\n-    for (predicate, _) in predicates.predicates {\n-        match predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(predicate, ..) => {\n-                let trait_ref = predicate.trait_ref;\n-                if is_self_ty_used(unused_parameters, trait_ref.self_ty()) {\n+    debug!(\"mark_used_by_predicates: predicates_of={:?}\", predicates);\n+\n+    let mut current_unused_parameters = FiniteBitSet::new_empty();\n+    // Run to a fixed point to support `where T: Trait<U>, U: Trait<V>`, starting with an empty\n+    // bit set so that this is skipped if all parameters are already used.\n+    while current_unused_parameters != *unused_parameters {\n+        debug!(\n+            \"mark_used_by_predicates: current_unused_parameters={:?} = unused_parameters={:?}\",\n+            current_unused_parameters, unused_parameters\n+        );\n+        current_unused_parameters = *unused_parameters;\n+\n+        for (predicate, _) in predicates.predicates {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(predicate, ..) => {\n+                    let trait_ref = predicate.trait_ref;\n+                    debug!(\"mark_used_by_predicates: (trait) trait_ref={:?}\", trait_ref);\n+\n+                    // Consider `T` used if `I` is used in predicates of the form\n+                    // `I: Iterator<Item = T>`\n+                    debug!(\"mark_used_by_predicates: checking self\");\n+                    if is_ty_used(unused_parameters, trait_ref.self_ty()) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        for ty in trait_ref.substs.types() {\n+                            mark_ty(unused_parameters, ty);\n+                        }\n+\n+                        // No need to check for a type being used in the substs if `self_ty` was\n+                        // used.\n+                        continue;\n+                    }\n+\n+                    // Consider `I` used if `T` is used in predicates of the form\n+                    // `I: Iterator<Item = &'a (T, E)>` (see rust-lang/rust#75326)\n+                    debug!(\"mark_used_by_predicates: checking substs\");\n                     for ty in trait_ref.substs.types() {\n-                        debug!(\"unused_generic_params: (trait) ty={:?}\", ty);\n-                        mark_ty(unused_parameters, ty);\n+                        if is_ty_used(unused_parameters, ty) {\n+                            debug!(\"mark_used_by_predicates: used!\");\n+                            mark_ty(unused_parameters, trait_ref.self_ty());\n+                        }\n                     }\n                 }\n-            }\n-            ty::PredicateAtom::Projection(proj, ..) => {\n-                let self_ty = proj.projection_ty.self_ty();\n-                if is_self_ty_used(unused_parameters, self_ty) {\n-                    debug!(\"unused_generic_params: (projection ty={:?}\", proj.ty);\n-                    mark_ty(unused_parameters, proj.ty);\n+                ty::PredicateAtom::Projection(proj, ..) => {\n+                    let self_ty = proj.projection_ty.self_ty();\n+                    debug!(\n+                        \"mark_used_by_predicates: (projection) self_ty={:?} proj.ty={:?}\",\n+                        self_ty, proj.ty\n+                    );\n+\n+                    // Consider `T` used if `I` is used in predicates of the form\n+                    // `<I as Iterator>::Item = T`\n+                    debug!(\"mark_used_by_predicates: checking self\");\n+                    if is_ty_used(unused_parameters, self_ty) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        mark_ty(unused_parameters, proj.ty);\n+\n+                        // No need to check for projection type being used if `self_ty` was used.\n+                        continue;\n+                    }\n+\n+                    // Consider `I` used if `T` is used in predicates of the form\n+                    // `<I as Iterator>::Item = &'a (T, E)` (see rust-lang/rust#75326)\n+                    debug!(\"mark_used_by_predicates: checking projection ty\");\n+                    if is_ty_used(unused_parameters, proj.ty) {\n+                        debug!(\"mark_used_by_predicates: used!\");\n+                        mark_ty(unused_parameters, self_ty);\n+                    }\n                 }\n+                ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => (),\n             }\n-            _ => (),\n         }\n     }\n+\n+    if let Some(parent) = predicates.parent {\n+        mark_used_by_predicates(tcx, parent, unused_parameters);\n+    }\n }\n \n /// Emit errors for the function annotated by `#[rustc_polymorphize_error]`, labelling each generic\n@@ -204,13 +259,13 @@ fn emit_unused_generic_params_error<'tcx>(\n }\n \n /// Visitor used to aggregate generic parameter uses.\n-struct UsedGenericParametersVisitor<'a, 'tcx> {\n+struct MarkUsedGenericParams<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n     unused_parameters: &'a mut FiniteBitSet<u32>,\n }\n \n-impl<'a, 'tcx> UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> MarkUsedGenericParams<'a, 'tcx> {\n     /// Invoke `unused_generic_params` on a body contained within the current item (e.g.\n     /// a closure, generator or constant).\n     fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n@@ -229,7 +284,7 @@ impl<'a, 'tcx> UsedGenericParametersVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         debug!(\"visit_local_decl: local_decl={:?}\", local_decl);\n         if local == Local::from_usize(1) {\n@@ -256,7 +311,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n         debug!(\"visit_const: c={:?}\", c);\n         if !c.has_param_types_or_consts() {\n@@ -318,3 +373,36 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n         }\n     }\n }\n+\n+/// Visitor used to check if a generic parameter is used.\n+struct IsUsedGenericParams<'a> {\n+    unused_parameters: &'a FiniteBitSet<u32>,\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for IsUsedGenericParams<'a> {\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> bool {\n+        debug!(\"visit_const: c={:?}\", c);\n+        if !c.has_param_types_or_consts() {\n+            return false;\n+        }\n+\n+        match c.val {\n+            ty::ConstKind::Param(param) => {\n+                !self.unused_parameters.contains(param.index).unwrap_or(false)\n+            }\n+            _ => c.super_visit_with(self),\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        debug!(\"visit_ty: ty={:?}\", ty);\n+        if !ty.has_param_types_or_consts() {\n+            return false;\n+        }\n+\n+        match ty.kind {\n+            ty::Param(param) => !self.unused_parameters.contains(param.index).unwrap_or(false),\n+            _ => ty.super_visit_with(self),\n+        }\n+    }\n+}"}, {"sha": "60555dc12dcacc8e57a3a1a3cb2cf9f73f429add", "filename": "src/test/ui/polymorphization/predicates.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpredicates.rs?ref=bf3ef26713b8208e0127f4c51725897dbcd11bd9", "patch": "@@ -18,7 +18,55 @@ where\n     bar::<I>()\n }\n \n+#[rustc_polymorphize_error]\n+fn baz<I, T>(_: I)\n+where\n+    std::iter::Repeat<I>: Iterator<Item = T>,\n+{\n+    bar::<I>()\n+}\n+\n+// In addition, check that `I` is considered used in `next::{{closure}}`, because `T` is used and\n+// `T` is really just `I::Item`. `E` is used due to the fixed-point marking of predicates.\n+\n+pub(crate) struct Foo<'a, I, E>(I, &'a E);\n+\n+impl<'a, I, T: 'a, E> Iterator for Foo<'a, I, E>\n+where\n+    I: Iterator<Item = &'a (T, E)>,\n+{\n+    type Item = T;\n+\n+    #[rustc_polymorphize_error]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.find(|_| true)\n+    }\n+}\n+\n+// Furthermore, check that `B` is considered used because `C` is used, and that `A` is considered\n+// used because `B` is now used.\n+\n+trait Baz<Z> {}\n+\n+impl Baz<u16> for u8 {}\n+impl Baz<u32> for u16 {}\n+\n+#[rustc_polymorphize_error]\n+fn quux<A, B, C: Default>() -> usize\n+where\n+    A: Baz<B>,\n+    B: Baz<C>,\n+{\n+    std::mem::size_of::<C>()\n+}\n+\n fn main() {\n     let x = &[2u32];\n     foo(x.iter());\n+    baz(x.iter());\n+\n+    let mut a = Foo([(1u32, 1u16)].iter(), &1u16);\n+    let _ = a.next();\n+\n+    let _ = quux::<u8, u16, u32>();\n }"}, {"sha": "d97bae183d9c21712d1be11eef2fba9285a62e52", "filename": "src/test/ui/polymorphization/symbol-ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ef26713b8208e0127f4c51725897dbcd11bd9/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fsymbol-ambiguity.rs?ref=bf3ef26713b8208e0127f4c51725897dbcd11bd9", "patch": "@@ -0,0 +1,22 @@\n+// build-pass\n+// compile-flags: -Zpolymorphize=on -Zsymbol-mangling-version=v0\n+\n+pub(crate) struct Foo<'a, I, E>(I, &'a E);\n+\n+impl<'a, I, T: 'a, E> Iterator for Foo<'a, I, E>\n+where\n+    I: Iterator<Item = &'a (T, E)>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.find(|_| true)\n+    }\n+}\n+\n+fn main() {\n+    let mut a = Foo([(1u32, 1u16)].iter(), &1u16);\n+    let mut b = Foo([(1u16, 1u32)].iter(), &1u32);\n+    let _ = a.next();\n+    let _ = b.next();\n+}"}]}