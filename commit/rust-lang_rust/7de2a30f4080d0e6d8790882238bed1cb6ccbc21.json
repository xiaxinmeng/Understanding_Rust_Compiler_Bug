{"sha": "7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZTJhMzBmNDA4MGQwZTZkODc5MDg4MjIzOGJlZDFjYjZjY2JjMjE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-03T14:23:33Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-03T16:36:08Z"}, "message": "Fix import insertion breaking nested modules", "tree": {"sha": "450b363b8f6646ca7cda39325e4524af7b9389e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/450b363b8f6646ca7cda39325e4524af7b9389e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "html_url": "https://github.com/rust-lang/rust/commit/7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98e2f674e9e736720d1cd0a5b8c24e1fb10f64a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/98e2f674e9e736720d1cd0a5b8c24e1fb10f64a1", "html_url": "https://github.com/rust-lang/rust/commit/98e2f674e9e736720d1cd0a5b8c24e1fb10f64a1"}], "stats": {"total": 179, "additions": 117, "deletions": 62}, "files": [{"sha": "66e8191548a5c391749c51080330fd4d5cdbb10a", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "patch": "@@ -1,11 +1,13 @@\n use std::collections::BTreeSet;\n \n+use ast::make;\n use either::Either;\n use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n };\n use ide_db::{imports_locator, RootDatabase};\n+use insert_use::ImportScope;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n@@ -16,8 +18,6 @@ use crate::{\n     utils::{insert_use, MergeBehaviour},\n     AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n };\n-use ast::make;\n-use insert_use::find_insert_use_container;\n \n // Assist: auto_import\n //\n@@ -47,8 +47,9 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n     let range = ctx.sema.original_range(&auto_import_assets.syntax_under_caret).range;\n     let group = auto_import_assets.get_import_group_message();\n-    let container = find_insert_use_container(&auto_import_assets.syntax_under_caret, ctx)?;\n-    let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n+    let scope =\n+        ImportScope::find_insert_use_container(&auto_import_assets.syntax_under_caret, ctx)?;\n+    let syntax = scope.as_syntax_node();\n     for import in proposed_imports {\n         acc.add_group(\n             &group,\n@@ -57,7 +58,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             range,\n             |builder| {\n                 let new_syntax = insert_use(\n-                    &syntax,\n+                    &scope,\n                     make::path_from_text(&import.to_string()),\n                     Some(MergeBehaviour::Full),\n                 );"}, {"sha": "a50a57f1a90ed051c10a5953c6597ba0c2b5522d", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "patch": "@@ -15,7 +15,7 @@ use crate::{\n     AssistContext, AssistId, AssistKind, Assists,\n };\n use ast::make;\n-use insert_use::find_insert_use_container;\n+use insert_use::ImportScope;\n \n // Assist: extract_struct_from_enum_variant\n //\n@@ -110,11 +110,11 @@ fn insert_import(\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n-        let container = find_insert_use_container(path.syntax(), ctx)?;\n-        let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n+        let scope = ImportScope::find_insert_use_container(path.syntax(), ctx)?;\n+        let syntax = scope.as_syntax_node();\n \n         let new_syntax = insert_use(\n-            &syntax,\n+            &scope,\n             make::path_from_text(&mod_path.to_string()),\n             Some(MergeBehaviour::Full),\n         );"}, {"sha": "85c70d16b627fea1d0ff16dbf59e063a7d4d9741", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "patch": "@@ -2,7 +2,7 @@ use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode, TextRang\n use test_utils::mark;\n \n use crate::{\n-    utils::{find_insert_use_container, insert_use, MergeBehaviour},\n+    utils::{insert_use, ImportScope, MergeBehaviour},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n use ast::make;\n@@ -44,8 +44,8 @@ pub(crate) fn replace_qualified_name_with_use(\n     };\n \n     let target = path.syntax().text_range();\n-    let container = find_insert_use_container(path.syntax(), ctx)?;\n-    let syntax = container.either(|l| l.syntax().clone(), |r| r.syntax().clone());\n+    let scope = ImportScope::find_insert_use_container(path.syntax(), ctx)?;\n+    let syntax = scope.as_syntax_node();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n@@ -56,12 +56,14 @@ pub(crate) fn replace_qualified_name_with_use(\n             let mut rewriter = SyntaxRewriter::default();\n             shorten_paths(&mut rewriter, syntax.clone(), path);\n             let rewritten_syntax = rewriter.rewrite(&syntax);\n-            let new_syntax = insert_use(\n-                &rewritten_syntax,\n-                make::path_from_text(path_to_import),\n-                Some(MergeBehaviour::Full),\n-            );\n-            builder.replace(syntax.text_range(), new_syntax.to_string())\n+            if let Some(ref import_scope) = ImportScope::from(rewritten_syntax) {\n+                let new_syntax = insert_use(\n+                    import_scope,\n+                    make::path_from_text(path_to_import),\n+                    Some(MergeBehaviour::Full),\n+                );\n+                builder.replace(syntax.text_range(), new_syntax.to_string())\n+            }\n         },\n     )\n }"}, {"sha": "7559ddd6381177c963dc04caf436201a47b09584", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "patch": "@@ -16,7 +16,7 @@ use syntax::{\n \n use crate::assist_config::SnippetCap;\n \n-pub(crate) use insert_use::{find_insert_use_container, insert_use, MergeBehaviour};\n+pub(crate) use insert_use::{insert_use, ImportScope, MergeBehaviour};\n \n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)"}, {"sha": "40ff31075d168aa4749ea6c64cf13c98c44f631c", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 95, "deletions": 43, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7de2a30f4080d0e6d8790882238bed1cb6ccbc21/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=7de2a30f4080d0e6d8790882238bed1cb6ccbc21", "patch": "@@ -1,8 +1,10 @@\n use std::iter::{self, successors};\n \n use algo::skip_trivia_token;\n-use ast::{edit::AstNodeEdit, PathSegmentKind, VisibilityOwner};\n-use either::Either;\n+use ast::{\n+    edit::{AstNodeEdit, IndentLevel},\n+    PathSegmentKind, VisibilityOwner,\n+};\n use syntax::{\n     algo,\n     ast::{self, make, AstNode},\n@@ -11,64 +13,129 @@ use syntax::{\n \n use test_utils::mark;\n \n-/// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n-pub(crate) fn find_insert_use_container(\n-    position: &SyntaxNode,\n-    ctx: &crate::assist_context::AssistContext,\n-) -> Option<Either<ast::ItemList, ast::SourceFile>> {\n-    ctx.sema.ancestors_with_macros(position.clone()).find_map(|n| {\n-        if let Some(module) = ast::Module::cast(n.clone()) {\n-            module.item_list().map(Either::Left)\n+#[derive(Debug)]\n+pub enum ImportScope {\n+    File(ast::SourceFile),\n+    Module(ast::ItemList),\n+}\n+\n+impl ImportScope {\n+    pub fn from(syntax: SyntaxNode) -> Option<Self> {\n+        if let Some(module) = ast::Module::cast(syntax.clone()) {\n+            module.item_list().map(ImportScope::Module)\n+        } else if let this @ Some(_) = ast::SourceFile::cast(syntax.clone()) {\n+            this.map(ImportScope::File)\n         } else {\n-            Some(Either::Right(ast::SourceFile::cast(n)?))\n+            ast::ItemList::cast(syntax).map(ImportScope::Module)\n         }\n-    })\n+    }\n+\n+    /// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n+    pub(crate) fn find_insert_use_container(\n+        position: &SyntaxNode,\n+        ctx: &crate::assist_context::AssistContext,\n+    ) -> Option<Self> {\n+        ctx.sema.ancestors_with_macros(position.clone()).find_map(Self::from)\n+    }\n+\n+    pub(crate) fn as_syntax_node(&self) -> &SyntaxNode {\n+        match self {\n+            ImportScope::File(file) => file.syntax(),\n+            ImportScope::Module(item_list) => item_list.syntax(),\n+        }\n+    }\n+\n+    fn indent_level(&self) -> IndentLevel {\n+        match self {\n+            ImportScope::File(file) => file.indent_level(),\n+            ImportScope::Module(item_list) => item_list.indent_level() + 1,\n+        }\n+    }\n+\n+    fn first_insert_pos(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+        match self {\n+            ImportScope::File(_) => (InsertPosition::First, AddBlankLine::AfterTwice),\n+            // don't insert the impotrs before the item lists curly brace\n+            ImportScope::Module(item_list) => item_list\n+                .l_curly_token()\n+                .map(|b| (InsertPosition::After(b.into()), AddBlankLine::Around))\n+                .unwrap_or((InsertPosition::First, AddBlankLine::AfterTwice)),\n+        }\n+    }\n+\n+    fn insert_pos_after_inner_attribute(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+        // check if the scope has a inner attributes, we dont want to insert in front of it\n+        match self\n+            .as_syntax_node()\n+            .children()\n+            // no flat_map here cause we want to short circuit the iterator\n+            .map(ast::Attr::cast)\n+            .take_while(|attr| {\n+                attr.as_ref().map(|attr| attr.kind() == ast::AttrKind::Inner).unwrap_or(false)\n+            })\n+            .last()\n+            .flatten()\n+        {\n+            Some(attr) => {\n+                (InsertPosition::After(attr.syntax().clone().into()), AddBlankLine::BeforeTwice)\n+            }\n+            None => self.first_insert_pos(),\n+        }\n+    }\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n-pub fn insert_use(\n-    where_: &SyntaxNode,\n+pub(crate) fn insert_use(\n+    scope: &ImportScope,\n     path: ast::Path,\n     merge: Option<MergeBehaviour>,\n ) -> SyntaxNode {\n     let use_item = make::use_(make::use_tree(path.clone(), None, None, false));\n     // merge into existing imports if possible\n     if let Some(mb) = merge {\n-        for existing_use in where_.children().filter_map(ast::Use::cast) {\n+        for existing_use in scope.as_syntax_node().children().filter_map(ast::Use::cast) {\n             if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n                 let to_delete: SyntaxElement = existing_use.syntax().clone().into();\n                 let to_delete = to_delete.clone()..=to_delete;\n                 let to_insert = iter::once(merged.syntax().clone().into());\n-                return algo::replace_children(where_, to_delete, to_insert);\n+                return algo::replace_children(scope.as_syntax_node(), to_delete, to_insert);\n             }\n         }\n     }\n \n     // either we weren't allowed to merge or there is no import that fits the merge conditions\n     // so look for the place we have to insert to\n-    let (insert_position, add_blank) = find_insert_position(where_, path);\n+    let (insert_position, add_blank) = find_insert_position(scope, path);\n \n     let to_insert: Vec<SyntaxElement> = {\n         let mut buf = Vec::new();\n \n         match add_blank {\n-            AddBlankLine::Before => buf.push(make::tokens::single_newline().into()),\n+            AddBlankLine::Before | AddBlankLine::Around => {\n+                buf.push(make::tokens::single_newline().into())\n+            }\n             AddBlankLine::BeforeTwice => buf.push(make::tokens::blank_line().into()),\n             _ => (),\n         }\n \n+        if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n+            // TODO: this alone doesnt properly re-align all cases\n+            buf.push(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into());\n+        }\n         buf.push(use_item.syntax().clone().into());\n \n         match add_blank {\n-            AddBlankLine::After => buf.push(make::tokens::single_newline().into()),\n+            AddBlankLine::After | AddBlankLine::Around => {\n+                buf.push(make::tokens::single_newline().into())\n+            }\n             AddBlankLine::AfterTwice => buf.push(make::tokens::blank_line().into()),\n             _ => (),\n         }\n \n         buf\n     };\n \n-    algo::insert_children(where_, insert_position, to_insert)\n+    algo::insert_children(scope.as_syntax_node(), insert_position, to_insert)\n }\n \n fn try_merge_imports(\n@@ -218,16 +285,18 @@ fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Cl\n enum AddBlankLine {\n     Before,\n     BeforeTwice,\n+    Around,\n     After,\n     AfterTwice,\n }\n \n fn find_insert_position(\n-    scope: &SyntaxNode,\n+    scope: &ImportScope,\n     insert_path: ast::Path,\n ) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n     let group = ImportGroup::new(&insert_path);\n     let path_node_iter = scope\n+        .as_syntax_node()\n         .children()\n         .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n         .flat_map(|(use_, node)| use_.use_tree().and_then(|tree| tree.path()).zip(Some(node)));\n@@ -275,27 +344,7 @@ fn find_insert_position(\n                             (InsertPosition::After(node.into()), AddBlankLine::BeforeTwice)\n                         }\n                         // there are no imports in this file at all\n-                        None => {\n-                            // check if the scope has a inner attributes, we dont want to insert in front of it\n-                            match scope\n-                                .children()\n-                                // no flat_map here cause we want to short circuit the iterator\n-                                .map(ast::Attr::cast)\n-                                .take_while(|attr| {\n-                                    attr.as_ref()\n-                                        .map(|attr| attr.kind() == ast::AttrKind::Inner)\n-                                        .unwrap_or(false)\n-                                })\n-                                .last()\n-                                .flatten()\n-                            {\n-                                Some(attr) => (\n-                                    InsertPosition::After(attr.syntax().clone().into()),\n-                                    AddBlankLine::BeforeTwice,\n-                                ),\n-                                None => (InsertPosition::First, AddBlankLine::AfterTwice),\n-                            }\n-                        }\n+                        None => scope.insert_pos_after_inner_attribute(),\n                     },\n                 }\n             }\n@@ -640,7 +689,10 @@ use foo::bar;\",\n         ra_fixture_after: &str,\n         mb: Option<MergeBehaviour>,\n     ) {\n-        let file = ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone();\n+        let file = super::ImportScope::from(\n+            ast::SourceFile::parse(ra_fixture_before).tree().syntax().clone(),\n+        )\n+        .unwrap();\n         let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n             .tree()\n             .syntax()"}]}