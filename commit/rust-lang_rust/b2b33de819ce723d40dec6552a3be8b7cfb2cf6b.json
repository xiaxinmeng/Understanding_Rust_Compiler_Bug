{"sha": "b2b33de819ce723d40dec6552a3be8b7cfb2cf6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYjMzZGU4MTljZTcyM2Q0MGRlYzY1NTJhM2JlOGI3Y2ZiMmNmNmI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T20:09:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T20:09:20Z"}, "message": "Alias-ify a variety of fn signatures in ty. Cuts 180kb off rustc.", "tree": {"sha": "c867a47cdfa2133b8d3bc97019365ccdd494957d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c867a47cdfa2133b8d3bc97019365ccdd494957d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b", "html_url": "https://github.com/rust-lang/rust/commit/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "662e949540e19a5a906a5e4f13e62b625a13ba69", "url": "https://api.github.com/repos/rust-lang/rust/commits/662e949540e19a5a906a5e4f13e62b625a13ba69", "html_url": "https://github.com/rust-lang/rust/commit/662e949540e19a5a906a5e4f13e62b625a13ba69"}], "stats": {"total": 226, "additions": 114, "deletions": 112}, "files": [{"sha": "9e90d12582357c857702bf603608e998a53926ea", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 114, "deletions": 112, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2b33de819ce723d40dec6552a3be8b7cfb2cf6b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b2b33de819ce723d40dec6552a3be8b7cfb2cf6b", "patch": "@@ -231,7 +231,7 @@ fn mk_ctxt(session.session s) -> ctxt {\n }\n // Type constructors\n \n-fn mk_ty_full(&sty st, Option.t[str] cname) -> t {\n+fn mk_ty_full(&sty st, &Option.t[str] cname) -> t {\n     auto h = hash_type_info(st, cname);\n     auto magic = mk_magic(st);\n \n@@ -356,7 +356,7 @@ fn mk_ty_full(&sty st, Option.t[str] cname) -> t {\n              has_locals = has_locals);\n }\n \n-fn gen_ty_full(ctxt cx, &sty st, Option.t[str] cname) -> t {\n+fn gen_ty_full(&ctxt cx, &sty st, &Option.t[str] cname) -> t {\n     auto new_type = mk_ty_full(st, cname);\n \n     // Do not intern anything with locals or vars; it'll be nearly\n@@ -381,17 +381,17 @@ fn gen_ty_full(ctxt cx, &sty st, Option.t[str] cname) -> t {\n \n // These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(ctxt cx, &sty st) -> t {\n+fn gen_ty(&ctxt cx, &sty st) -> t {\n     ret gen_ty_full(cx, st, none[str]);\n }\n \n-fn mk_nil(ctxt cx) -> t          { ret cx.ts.t_nil; }\n-fn mk_bool(ctxt cx) -> t         { ret cx.ts.t_bool; }\n-fn mk_int(ctxt cx) -> t          { ret cx.ts.t_int; }\n-fn mk_float(ctxt cx) -> t        { ret cx.ts.t_float; }\n-fn mk_uint(ctxt cx) -> t         { ret cx.ts.t_uint; }\n+fn mk_nil(&ctxt cx) -> t          { ret cx.ts.t_nil; }\n+fn mk_bool(&ctxt cx) -> t         { ret cx.ts.t_bool; }\n+fn mk_int(&ctxt cx) -> t          { ret cx.ts.t_int; }\n+fn mk_float(&ctxt cx) -> t        { ret cx.ts.t_float; }\n+fn mk_uint(&ctxt cx) -> t         { ret cx.ts.t_uint; }\n \n-fn mk_mach(ctxt cx, util.common.ty_mach tm) -> t {\n+fn mk_mach(&ctxt cx, &util.common.ty_mach tm) -> t {\n     alt (tm) {\n         case (ty_u8)  { ret cx.ts.t_u8; }\n         case (ty_u16) { ret cx.ts.t_u16; }\n@@ -409,29 +409,29 @@ fn mk_mach(ctxt cx, util.common.ty_mach tm) -> t {\n     fail;\n }\n \n-fn mk_char(ctxt cx) -> t    { ret cx.ts.t_char; }\n-fn mk_str(ctxt cx) -> t     { ret cx.ts.t_str; }\n+fn mk_char(&ctxt cx) -> t    { ret cx.ts.t_char; }\n+fn mk_str(&ctxt cx) -> t     { ret cx.ts.t_str; }\n \n-fn mk_tag(ctxt cx, ast.def_id did, vec[t] tys) -> t {\n+fn mk_tag(&ctxt cx, &ast.def_id did, &vec[t] tys) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n-fn mk_box(ctxt cx, mt tm) -> t {\n+fn mk_box(&ctxt cx, &mt tm) -> t {\n     ret gen_ty(cx, ty_box(tm));\n }\n \n-fn mk_imm_box(ctxt cx, t ty) -> t {\n+fn mk_imm_box(&ctxt cx, &t ty) -> t {\n     ret mk_box(cx, rec(ty=ty, mut=ast.imm));\n }\n \n-fn mk_vec(ctxt cx, mt tm) -> t  { ret gen_ty(cx, ty_vec(tm)); }\n-fn mk_port(ctxt cx, t ty) -> t  { ret gen_ty(cx, ty_port(ty)); }\n-fn mk_chan(ctxt cx, t ty) -> t  { ret gen_ty(cx, ty_chan(ty)); }\n-fn mk_task(ctxt cx) -> t        { ret gen_ty(cx, ty_task); }\n+fn mk_vec(&ctxt cx, &mt tm) -> t  { ret gen_ty(cx, ty_vec(tm)); }\n+fn mk_port(&ctxt cx, &t ty) -> t  { ret gen_ty(cx, ty_port(ty)); }\n+fn mk_chan(&ctxt cx, &t ty) -> t  { ret gen_ty(cx, ty_chan(ty)); }\n+fn mk_task(&ctxt cx) -> t        { ret gen_ty(cx, ty_task); }\n \n-fn mk_tup(ctxt cx, vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n+fn mk_tup(&ctxt cx, &vec[mt] tms) -> t { ret gen_ty(cx, ty_tup(tms)); }\n \n-fn mk_imm_tup(ctxt cx, vec[t] tys) -> t {\n+fn mk_imm_tup(&ctxt cx, &vec[t] tys) -> t {\n     // TODO: map\n     let vec[ty.mt] mts = vec();\n     for (t typ in tys) {\n@@ -440,29 +440,29 @@ fn mk_imm_tup(ctxt cx, vec[t] tys) -> t {\n     ret mk_tup(cx, mts);\n }\n \n-fn mk_rec(ctxt cx, vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n+fn mk_rec(&ctxt cx, &vec[field] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_fn(ctxt cx, ast.proto proto, vec[arg] args, t ty) -> t {\n+fn mk_fn(&ctxt cx, &ast.proto proto, &vec[arg] args, &t ty) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty));\n }\n \n-fn mk_native_fn(ctxt cx, ast.native_abi abi, vec[arg] args, t ty) -> t {\n+fn mk_native_fn(&ctxt cx, &ast.native_abi abi, &vec[arg] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(ctxt cx, vec[method] meths) -> t {\n+fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n-fn mk_var(ctxt cx, int v) -> t {\n+fn mk_var(&ctxt cx, int v) -> t {\n     ret mk_ty_full(ty_var(v), none[str]);\n }\n \n-fn mk_local(ctxt cx, ast.def_id did) -> t {\n+fn mk_local(&ctxt cx, ast.def_id did) -> t {\n     ret mk_ty_full(ty_local(did), none[str]);\n }\n \n-fn mk_param(ctxt cx, uint n) -> t {\n+fn mk_param(&ctxt cx, uint n) -> t {\n     let uint i = Vec.len[t](cx.ts.t_params);\n     while (i <= n) {\n         cx.ts.t_params += vec(mk_ty_full(ty_param(i), none[str]));\n@@ -471,7 +471,7 @@ fn mk_param(ctxt cx, uint n) -> t {\n     ret cx.ts.t_params.(n);\n }\n \n-fn mk_bound_param(ctxt cx, uint n) -> t {\n+fn mk_bound_param(&ctxt cx, uint n) -> t {\n     let uint i = Vec.len[t](cx.ts.t_bound_params);\n     while (i <= n) {\n         cx.ts.t_bound_params += vec(mk_ty_full(ty_bound_param(i), none[str]));\n@@ -480,15 +480,15 @@ fn mk_bound_param(ctxt cx, uint n) -> t {\n     ret cx.ts.t_bound_params.(n);\n }\n \n-fn mk_type(ctxt cx) -> t    { ret cx.ts.t_type; }\n-fn mk_native(ctxt cx) -> t  { ret cx.ts.t_native; }\n+fn mk_type(&ctxt cx) -> t    { ret cx.ts.t_type; }\n+fn mk_native(&ctxt cx) -> t  { ret cx.ts.t_native; }\n \n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(ctxt cx, t typ) -> sty { ret typ.struct; }\n+fn struct(&ctxt cx, &t typ) -> sty { ret typ.struct; }\n \n // Returns the canonical name of the given type.\n-fn cname(ctxt cx, t typ) -> Option.t[str] { ret typ.cname; }\n+fn cname(&ctxt cx, &t typ) -> Option.t[str] { ret typ.cname; }\n \n \n // Stringification\n@@ -833,23 +833,23 @@ fn copy_cname(ctxt cx, t struct_ty, t cname_ty) -> t {\n     ret gen_ty_full(cx, struct(cx, struct_ty), cname_ty.cname);\n }\n \n-fn type_is_nil(ctxt cx, t ty) -> bool {\n+fn type_is_nil(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_nil) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_bool(ctxt cx, t ty) -> bool {\n+fn type_is_bool(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_bool) { ret true; }\n         case (_) { ret false; }\n     }\n }\n \n \n-fn type_is_structural(ctxt cx, t ty) -> bool {\n+fn type_is_structural(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(_))    { ret true; }\n         case (ty_rec(_))    { ret true; }\n@@ -861,7 +861,7 @@ fn type_is_structural(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_sequence(ctxt cx, t ty) -> bool {\n+fn type_is_sequence(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_str)    { ret true; }\n         case (ty_vec(_))    { ret true; }\n@@ -870,7 +870,7 @@ fn type_is_sequence(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn sequence_element_type(ctxt cx, t ty) -> t {\n+fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     alt (struct(cx, ty)) {\n         case (ty_str)      { ret mk_mach(cx, common.ty_u8); }\n         case (ty_vec(?mt)) { ret mt.ty; }\n@@ -879,7 +879,7 @@ fn sequence_element_type(ctxt cx, t ty) -> t {\n }\n \n \n-fn type_is_tup_like(ctxt cx, t ty) -> bool {\n+fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_box(_))    { ret true; }\n         case (ty_tup(_))    { ret true; }\n@@ -890,7 +890,7 @@ fn type_is_tup_like(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn get_element_type(ctxt cx, t ty, uint i) -> t {\n+fn get_element_type(&ctxt cx, &t ty, uint i) -> t {\n     assert (type_is_tup_like(cx, ty));\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n@@ -903,15 +903,15 @@ fn get_element_type(ctxt cx, t ty, uint i) -> t {\n     fail;\n }\n \n-fn type_is_box(ctxt cx, t ty) -> bool {\n+fn type_is_box(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_box(_)) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_is_boxed(ctxt cx, t ty) -> bool {\n+fn type_is_boxed(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_str) { ret true; }\n         case (ty_vec(_)) { ret true; }\n@@ -923,7 +923,7 @@ fn type_is_boxed(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_scalar(ctxt cx, t ty) -> bool {\n+fn type_is_scalar(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_nil) { ret true; }\n         case (ty_bool) { ret true; }\n@@ -941,15 +941,15 @@ fn type_is_scalar(ctxt cx, t ty) -> bool {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(ctxt cx, t ty) -> bool {\n+fn type_is_native(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n }\n \n-fn type_has_dynamic_size(ctxt cx, t ty) -> bool {\n+fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             auto i = 0u;\n@@ -980,7 +980,7 @@ fn type_has_dynamic_size(ctxt cx, t ty) -> bool {\n     ret false;\n }\n \n-fn type_is_integral(ctxt cx, t ty) -> bool {\n+fn type_is_integral(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_uint) { ret true; }\n@@ -1004,7 +1004,7 @@ fn type_is_integral(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_fp(ctxt cx, t ty) -> bool {\n+fn type_is_fp(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_machine(?tm)) {\n             alt (tm) {\n@@ -1021,7 +1021,7 @@ fn type_is_fp(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_is_signed(ctxt cx, t ty) -> bool {\n+fn type_is_signed(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_int) { ret true; }\n         case (ty_machine(?tm)) {\n@@ -1038,7 +1038,7 @@ fn type_is_signed(ctxt cx, t ty) -> bool {\n     fail;\n }\n \n-fn type_param(ctxt cx, t ty) -> Option.t[uint] {\n+fn type_param(&ctxt cx, &t ty) -> Option.t[uint] {\n     alt (struct(cx, ty)) {\n         case (ty_param(?id)) { ret some[uint](id); }\n         case (_)             { /* fall through */  }\n@@ -1101,13 +1101,13 @@ fn hash_type_structure(&sty st) -> uint {\n         ret h;\n     }\n \n-    fn hash_subty(uint id, t subty) -> uint {\n+    fn hash_subty(uint id, &t subty) -> uint {\n         auto h = id;\n         h += h << 5u + hash_ty(subty);\n         ret h;\n     }\n \n-    fn hash_fn(uint id, vec[arg] args, t rty) -> uint {\n+    fn hash_fn(uint id, &vec[arg] args, &t rty) -> uint {\n         auto h = id;\n         for (arg a in args) {\n             h += h << 5u + hash_ty(a.ty);\n@@ -1184,7 +1184,7 @@ fn hash_type_structure(&sty st) -> uint {\n     }\n }\n \n-fn hash_type_info(&sty st, Option.t[str] cname_opt) -> uint {\n+fn hash_type_info(&sty st, &Option.t[str] cname_opt) -> uint {\n     auto h = hash_type_structure(st);\n     alt (cname_opt) {\n         case (none[str]) { /* no-op */ }\n@@ -1273,8 +1273,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         ret equal_mut(a.mut, b.mut) && eq_ty(a.ty, b.ty);\n     }\n \n-    fn equal_fn(vec[arg] args_a, t rty_a,\n-                vec[arg] args_b, t rty_b) -> bool {\n+    fn equal_fn(&vec[arg] args_a, &t rty_a,\n+                &vec[arg] args_b, &t rty_b) -> bool {\n         if (!eq_ty(rty_a, rty_b)) { ret false; }\n \n         auto len = Vec.len[arg](args_a);\n@@ -1290,7 +1290,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         ret true;\n     }\n \n-    fn equal_def(ast.def_id did_a, ast.def_id did_b) -> bool {\n+    fn equal_def(&ast.def_id did_a, &ast.def_id did_b) -> bool {\n         ret did_a._0 == did_b._0 && did_a._1 == did_b._1;\n     }\n \n@@ -1634,55 +1634,55 @@ fn count_ty_params(ctxt cx, t ty) -> uint {\n     ret Vec.len[uint](*param_indices);\n }\n \n-fn type_contains_vars(ctxt cx, t typ) -> bool {\n+fn type_contains_vars(&ctxt cx, &t typ) -> bool {\n     ret typ.has_vars;\n }\n \n-fn type_contains_locals(ctxt cx, t typ) -> bool {\n+fn type_contains_locals(&ctxt cx, &t typ) -> bool {\n     ret typ.has_locals;\n }\n \n-fn type_contains_params(ctxt cx, t typ) -> bool {\n+fn type_contains_params(&ctxt cx, &t typ) -> bool {\n     ret typ.has_params;\n }\n \n-fn type_contains_bound_params(ctxt cx, t typ) -> bool {\n+fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n     ret typ.has_bound_params;\n }\n \n // Type accessors for substructures of types\n \n-fn ty_fn_args(ctxt cx, t fty) -> vec[arg] {\n+fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n     alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n         case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_proto(ctxt cx, t fty) -> ast.proto {\n+fn ty_fn_proto(&ctxt cx, &t fty) -> ast.proto {\n     alt (struct(cx, fty)) {\n         case (ty.ty_fn(?p, _, _)) { ret p; }\n     }\n     fail;\n }\n \n-fn ty_fn_abi(ctxt cx, t fty) -> ast.native_abi {\n+fn ty_fn_abi(&ctxt cx, &t fty) -> ast.native_abi {\n     alt (struct(cx, fty)) {\n         case (ty.ty_native_fn(?a, _, _)) { ret a; }\n     }\n     fail;\n }\n \n-fn ty_fn_ret(ctxt cx, t fty) -> t {\n+fn ty_fn_ret(&ctxt cx, &t fty) -> t {\n     alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n         case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n-fn is_fn_ty(ctxt cx, t fty) -> bool {\n+fn is_fn_ty(&ctxt cx, &t fty) -> bool {\n     alt (struct(cx, fty)) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n         case (ty.ty_native_fn(_, _, _)) { ret true; }\n@@ -1696,7 +1696,7 @@ fn is_fn_ty(ctxt cx, t fty) -> bool {\n \n // Given an item, returns the associated type as well as the number of type\n // parameters it has.\n-fn native_item_ty(@ast.native_item it) -> ty_param_count_and_ty {\n+fn native_item_ty(&@ast.native_item it) -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n@@ -1708,7 +1708,7 @@ fn native_item_ty(@ast.native_item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n+fn item_ty(&@ast.item it) -> ty_param_count_and_ty {\n     auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n@@ -1740,7 +1740,7 @@ fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n     ret tup(ty_param_count, result_ty);\n }\n \n-fn stmt_ty(ctxt cx, @ast.stmt s) -> t {\n+fn stmt_ty(&ctxt cx, &@ast.stmt s) -> t {\n     alt (s.node) {\n         case (ast.stmt_expr(?e,_)) {\n             ret expr_ty(cx, e);\n@@ -1751,7 +1751,7 @@ fn stmt_ty(ctxt cx, @ast.stmt s) -> t {\n     }\n }\n \n-fn block_ty(ctxt cx, &ast.block b) -> t {\n+fn block_ty(&ctxt cx, &ast.block b) -> t {\n     alt (b.node.expr) {\n         case (some[@ast.expr](?e)) { ret expr_ty(cx, e); }\n         case (none[@ast.expr])     { ret mk_nil(cx); }\n@@ -1760,7 +1760,7 @@ fn block_ty(ctxt cx, &ast.block b) -> t {\n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(ctxt cx, @ast.pat pat) -> t {\n+fn pat_ty(&ctxt cx, &@ast.pat pat) -> t {\n     alt (pat.node) {\n         case (ast.pat_wild(?ann))           { ret ann_to_monotype(cx, ann); }\n         case (ast.pat_lit(_, ?ann))         { ret ann_to_monotype(cx, ann); }\n@@ -1889,17 +1889,17 @@ fn expr_ann(&@ast.expr e) -> ast.ann {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(ctxt cx, @ast.expr expr) -> t {\n+fn expr_ty(&ctxt cx, &@ast.expr expr) -> t {\n     ret ann_to_monotype(cx, expr_ann(expr));\n }\n \n-fn expr_ty_params_and_ty(ctxt cx, @ast.expr expr) -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast.expr expr) -> tup(vec[t], t) {\n     auto a = expr_ann(expr);\n \n     ret tup(ann_to_type_params(a), ann_to_type(a));\n }\n \n-fn expr_has_ty_params(@ast.expr expr) -> bool {\n+fn expr_has_ty_params(&@ast.expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n         case (ast.ann_none) { fail; }\n@@ -1910,7 +1910,8 @@ fn expr_has_ty_params(@ast.expr expr) -> bool {\n }\n \n // FIXME: At the moment this works only for call, bind, and path expressions.\n-fn replace_expr_type(@ast.expr expr, tup(vec[t], t) new_tyt) -> @ast.expr {\n+fn replace_expr_type(&@ast.expr expr,\n+                     &tup(vec[t], t) new_tyt) -> @ast.expr {\n     auto new_tps;\n     if (expr_has_ty_params(expr)) {\n         new_tps = some[vec[t]](new_tyt._0);\n@@ -1951,7 +1952,8 @@ fn replace_expr_type(@ast.expr expr, tup(vec[t], t) new_tyt) -> @ast.expr {\n \n // Expression utilities\n \n-fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n+fn field_num(&session.session sess, &span sp,\n+             &ast.ident id) -> uint {\n     let uint accum = 0u;\n     let uint i = 0u;\n     for (u8 c in id) {\n@@ -1979,8 +1981,8 @@ fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n     ret accum;\n }\n \n-fn field_idx(session.session sess, &span sp,\n-             &ast.ident id, vec[field] fields) -> uint {\n+fn field_idx(&session.session sess, &span sp,\n+             &ast.ident id, &vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) {\n         if (Str.eq(f.ident, id)) {\n@@ -1992,8 +1994,8 @@ fn field_idx(session.session sess, &span sp,\n     fail;\n }\n \n-fn method_idx(session.session sess, &span sp,\n-              &ast.ident id, vec[method] meths) -> uint {\n+fn method_idx(&session.session sess, &span sp,\n+              &ast.ident id, &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) {\n         if (Str.eq(m.ident, id)) {\n@@ -2005,15 +2007,15 @@ fn method_idx(session.session sess, &span sp,\n     fail;\n }\n \n-fn sort_methods(vec[method] meths) -> vec[method] {\n+fn sort_methods(&vec[method] meths) -> vec[method] {\n     fn method_lteq(&method a, &method b) -> bool {\n         ret Str.lteq(a.ident, b.ident);\n     }\n \n     ret std.Sort.merge_sort[method](bind method_lteq(_,_), meths);\n }\n \n-fn is_lval(@ast.expr expr) -> bool {\n+fn is_lval(&@ast.expr expr) -> bool {\n     alt (expr.node) {\n         case (ast.expr_field(_,_,_))    { ret true;  }\n         case (ast.expr_index(_,_,_))    { ret true;  }\n@@ -2076,11 +2078,11 @@ mod Unify {\n         fn_common_res_ok(vec[arg], t);\n     }\n \n-    fn unify_fn_common(@ctxt cx,\n-                       t expected,\n-                       t actual,\n-                       vec[arg] expected_inputs, t expected_output,\n-                       vec[arg] actual_inputs, t actual_output)\n+    fn unify_fn_common(&@ctxt cx,\n+                       &t expected,\n+                       &t actual,\n+                       &vec[arg] expected_inputs, &t expected_output,\n+                       &vec[arg] actual_inputs, &t actual_output)\n         -> fn_common_res {\n         auto expected_len = Vec.len[arg](expected_inputs);\n         auto actual_len = Vec.len[arg](actual_inputs);\n@@ -2134,13 +2136,13 @@ mod Unify {\n         }\n     }\n \n-    fn unify_fn(@ctxt cx,\n-                ast.proto e_proto,\n-                ast.proto a_proto,\n-                t expected,\n-                t actual,\n-                vec[arg] expected_inputs, t expected_output,\n-                vec[arg] actual_inputs, t actual_output)\n+    fn unify_fn(&@ctxt cx,\n+                &ast.proto e_proto,\n+                &ast.proto a_proto,\n+                &t expected,\n+                &t actual,\n+                &vec[arg] expected_inputs, &t expected_output,\n+                &vec[arg] actual_inputs, &t actual_output)\n         -> result {\n \n         if (e_proto != a_proto) {\n@@ -2160,13 +2162,13 @@ mod Unify {\n         }\n     }\n \n-    fn unify_native_fn(@ctxt cx,\n-                       ast.native_abi e_abi,\n-                       ast.native_abi a_abi,\n-                       t expected,\n-                       t actual,\n-                       vec[arg] expected_inputs, t expected_output,\n-                       vec[arg] actual_inputs, t actual_output)\n+    fn unify_native_fn(&@ctxt cx,\n+                       &ast.native_abi e_abi,\n+                       &ast.native_abi a_abi,\n+                       &t expected,\n+                       &t actual,\n+                       &vec[arg] expected_inputs, &t expected_output,\n+                       &vec[arg] actual_inputs, &t actual_output)\n         -> result {\n         if (e_abi != a_abi) {\n             ret ures_err(terr_mismatch, expected, actual);\n@@ -2187,11 +2189,11 @@ mod Unify {\n         }\n     }\n \n-    fn unify_obj(@ctxt cx,\n-                 t expected,\n-                 t actual,\n-                 vec[method] expected_meths,\n-                 vec[method] actual_meths) -> result {\n+    fn unify_obj(&@ctxt cx,\n+                 &t expected,\n+                 &t actual,\n+                 &vec[method] expected_meths,\n+                 &vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n       let uint i = 0u;\n       let uint expected_len = Vec.len[method](expected_meths);\n@@ -2233,7 +2235,7 @@ mod Unify {\n       ret ures_ok(t);\n     }\n \n-    fn get_or_create_set(@ctxt cx, int id) -> uint {\n+    fn get_or_create_set(&@ctxt cx, int id) -> uint {\n         auto set_num;\n         alt (cx.var_ids.find(id)) {\n         case (none[uint]) {\n@@ -2245,7 +2247,7 @@ mod Unify {\n         ret set_num;\n     }\n \n-    fn unify_step(@ctxt cx, t expected, t actual) -> result {\n+    fn unify_step(&@ctxt cx, &t expected, &t actual) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -2673,7 +2675,7 @@ mod Unify {\n     }\n \n     // Performs type binding substitution.\n-    fn substitute(@ctxt cx, vec[t] set_types, t typ) -> t {\n+    fn substitute(&@ctxt cx, &vec[t] set_types, &t typ) -> t {\n         if (!type_contains_vars(cx.tcx, typ)) {\n             ret typ;\n         }\n@@ -2697,7 +2699,7 @@ mod Unify {\n         ret fold_ty(cx.tcx, f, typ);\n     }\n \n-    fn unify_sets(@ctxt cx) -> vec[t] {\n+    fn unify_sets(&@ctxt cx) -> vec[t] {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] set_types = vec(mutable throwaway);\n         Vec.pop[vec[t]](set_types);   // FIXME: botch\n@@ -2727,10 +2729,10 @@ mod Unify {\n         ret result;\n     }\n \n-    fn unify(t expected,\n-             t actual,\n+    fn unify(&t expected,\n+             &t actual,\n              &unify_handler handler,\n-             ty_ctxt tcx) -> result {\n+             &ty_ctxt tcx) -> result {\n         let vec[t] throwaway = vec();\n         let vec[mutable vec[t]] types = vec(mutable throwaway);\n         Vec.pop[vec[t]](types);   // FIXME: botch\n@@ -2808,7 +2810,7 @@ fn type_err_to_str(&ty.type_err err) -> str {\n \n // Performs bound type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n-fn substitute_type_params(ctxt cx, vec[t] bindings, t typ) -> t {\n+fn substitute_type_params(&ctxt cx, &vec[t] bindings, &t typ) -> t {\n     if (!type_contains_bound_params(cx, typ)) {\n         ret typ;\n     }\n@@ -2826,7 +2828,7 @@ fn substitute_type_params(ctxt cx, vec[t] bindings, t typ) -> t {\n }\n \n // Converts type parameters in a type to bound type parameters.\n-fn bind_params_in_type(ctxt cx, t typ) -> t {\n+fn bind_params_in_type(&ctxt cx, &t typ) -> t {\n     if (!type_contains_params(cx, typ)) {\n         ret typ;\n     }"}]}