{"sha": "4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMDdkOGRkNTg3YzI0YmNhODYyMmVlOGMzOWU1YTFlMTU2ODI1YjQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-17T23:23:46Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-18T01:24:14Z"}, "message": "Refactor attributes API to allow handling cfg_attr", "tree": {"sha": "d60fc981c2dcc2fe5b78d73ac419c65a5574d027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d60fc981c2dcc2fe5b78d73ac419c65a5574d027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "html_url": "https://github.com/rust-lang/rust/commit/4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4e17a5a96d3a8c15c91e90adce9d9b8cdc48a46", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e17a5a96d3a8c15c91e90adce9d9b8cdc48a46", "html_url": "https://github.com/rust-lang/rust/commit/a4e17a5a96d3a8c15c91e90adce9d9b8cdc48a46"}], "stats": {"total": 301, "additions": 187, "deletions": 114}, "files": [{"sha": "236d6f1b7c973951e9e4c38c6af8a112930f1527", "filename": "crates/hir_def/src/adt.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -3,6 +3,7 @@\n use std::sync::Arc;\n \n use arena::{map::ArenaMap, Arena};\n+use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n@@ -66,8 +67,13 @@ pub enum ReprKind {\n     Other,\n }\n \n-fn repr_from_value(item_tree: &ItemTree, of: AttrOwner) -> Option<ReprKind> {\n-    item_tree.attrs(of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n+fn repr_from_value(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+    item_tree: &ItemTree,\n+    of: AttrOwner,\n+) -> Option<ReprKind> {\n+    item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n }\n \n fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n@@ -86,12 +92,13 @@ fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n+        let krate = loc.container.module(db).krate;\n         let item_tree = db.item_tree(loc.id.file_id);\n-        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(&item_tree, &cfg_options, &strukt.fields, None);\n+        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n         Arc::new(StructData {\n             name: strukt.name.clone(),\n             variant_data: Arc::new(variant_data),\n@@ -100,12 +107,13 @@ impl StructData {\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n+        let krate = loc.container.module(db).krate;\n         let item_tree = db.item_tree(loc.id.file_id);\n-        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n-        let variant_data = lower_fields(&item_tree, &cfg_options, &union.fields, None);\n+        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n \n         Arc::new(StructData {\n             name: union.name.clone(),\n@@ -118,16 +126,23 @@ impl StructData {\n impl EnumData {\n     pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n         let loc = e.lookup(db);\n+        let krate = loc.container.module(db).krate;\n         let item_tree = db.item_tree(loc.id.file_id);\n-        let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n \n         let enum_ = &item_tree[loc.id.value];\n         let mut variants = Arena::new();\n         for var_id in enum_.variants.clone() {\n-            if item_tree.attrs(var_id.into()).is_cfg_enabled(&cfg_options) {\n+            if item_tree.attrs(db, krate, var_id.into()).is_cfg_enabled(&cfg_options) {\n                 let var = &item_tree[var_id];\n-                let var_data =\n-                    lower_fields(&item_tree, &cfg_options, &var.fields, Some(enum_.visibility));\n+                let var_data = lower_fields(\n+                    db,\n+                    krate,\n+                    &item_tree,\n+                    &cfg_options,\n+                    &var.fields,\n+                    Some(enum_.visibility),\n+                );\n \n                 variants.alloc(EnumVariantData {\n                     name: var.name.clone(),\n@@ -170,7 +185,7 @@ fn lower_enum(\n         .variant_list()\n         .into_iter()\n         .flat_map(|it| it.variants())\n-        .filter(|var| expander.is_cfg_enabled(var));\n+        .filter(|var| expander.is_cfg_enabled(db, var));\n     for var in variants {\n         trace.alloc(\n             || var.clone(),\n@@ -262,7 +277,7 @@ fn lower_struct(\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n-                if !expander.is_cfg_enabled(&fd) {\n+                if !expander.is_cfg_enabled(db, &fd) {\n                     continue;\n                 }\n \n@@ -279,7 +294,7 @@ fn lower_struct(\n         }\n         ast::StructKind::Record(fl) => {\n             for fd in fl.fields() {\n-                if !expander.is_cfg_enabled(&fd) {\n+                if !expander.is_cfg_enabled(db, &fd) {\n                     continue;\n                 }\n \n@@ -299,6 +314,8 @@ fn lower_struct(\n }\n \n fn lower_fields(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n     item_tree: &ItemTree,\n     cfg_options: &CfgOptions,\n     fields: &Fields,\n@@ -308,7 +325,7 @@ fn lower_fields(\n         Fields::Record(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(field_id.into()).is_cfg_enabled(cfg_options) {\n+                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n                     arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n                 }\n             }\n@@ -317,7 +334,7 @@ fn lower_fields(\n         Fields::Tuple(flds) => {\n             let mut arena = Arena::new();\n             for field_id in flds.clone() {\n-                if item_tree.attrs(field_id.into()).is_cfg_enabled(cfg_options) {\n+                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n                     arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n                 }\n             }"}, {"sha": "9cd0b72aa98613e6c55d66c3a763f05661de3068", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 93, "deletions": 53, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -2,6 +2,7 @@\n \n use std::{ops, sync::Arc};\n \n+use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n@@ -38,12 +39,16 @@ impl From<Documentation> for String {\n     }\n }\n \n+/// Syntactical attributes, without filtering of `cfg_attr`s.\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n-pub struct Attrs {\n+pub struct RawAttrs {\n     entries: Option<Arc<[Attr]>>,\n }\n \n-impl ops::Deref for Attrs {\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct Attrs(RawAttrs);\n+\n+impl ops::Deref for RawAttrs {\n     type Target = [Attr];\n \n     fn deref(&self) -> &[Attr] {\n@@ -54,19 +59,88 @@ impl ops::Deref for Attrs {\n     }\n }\n \n+impl ops::Deref for Attrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.0.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+\n+impl RawAttrs {\n+    pub const EMPTY: Self = Self { entries: None };\n+\n+    pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Self {\n+        let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n+            .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n+\n+        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n+        let attrs = outer_attrs\n+            .chain(inner_attrs.into_iter().flatten())\n+            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n+\n+        let outer_docs =\n+            ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n+        let docs = outer_docs.chain(inner_docs.into_iter().flatten()).map(|docs_text| {\n+            (\n+                docs_text.syntax().text_range().start(),\n+                docs_text.doc_comment().map(|doc| Attr {\n+                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n+                    path: ModPath::from(hir_expand::name!(doc)),\n+                }),\n+            )\n+        });\n+        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n+        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n+        let entries = if attrs.is_empty() {\n+            // Avoid heap allocation\n+            None\n+        } else {\n+            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n+        };\n+        Self { entries }\n+    }\n+\n+    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Self {\n+        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n+        Self::new(owner.value, &hygiene)\n+    }\n+\n+    pub(crate) fn merge(&self, other: Self) -> Self {\n+        match (&self.entries, &other.entries) {\n+            (None, None) => Self::EMPTY,\n+            (Some(entries), None) | (None, Some(entries)) => {\n+                Self { entries: Some(entries.clone()) }\n+            }\n+            (Some(a), Some(b)) => {\n+                Self { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+            }\n+        }\n+    }\n+\n+    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n+    pub(crate) fn filter(self, _db: &dyn DefDatabase, _krate: CrateId) -> Attrs {\n+        // FIXME actually implement this\n+        Attrs(self)\n+    }\n+}\n+\n impl Attrs {\n-    pub const EMPTY: Attrs = Attrs { entries: None };\n+    pub const EMPTY: Self = Self(RawAttrs::EMPTY);\n \n     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n-        match def {\n+        let raw_attrs = match def {\n             AttrDefId::ModuleId(module) => {\n                 let def_map = db.crate_def_map(module.krate);\n                 let mod_data = &def_map[module.local_id];\n                 match mod_data.declaration_source(db) {\n                     Some(it) => {\n-                        Attrs::from_attrs_owner(db, it.as_ref().map(|it| it as &dyn AttrsOwner))\n+                        RawAttrs::from_attrs_owner(db, it.as_ref().map(|it| it as &dyn AttrsOwner))\n                     }\n-                    None => Attrs::from_attrs_owner(\n+                    None => RawAttrs::from_attrs_owner(\n                         db,\n                         mod_data.definition_source(db).as_ref().map(|src| match src {\n                             ModuleSource::SourceFile(file) => file as &dyn AttrsOwner,\n@@ -78,14 +152,14 @@ impl Attrs {\n             AttrDefId::FieldId(it) => {\n                 let src = it.parent.child_source(db);\n                 match &src.value[it.local_id] {\n-                    Either::Left(_tuple) => Attrs::default(),\n-                    Either::Right(record) => Attrs::from_attrs_owner(db, src.with_value(record)),\n+                    Either::Left(_tuple) => RawAttrs::default(),\n+                    Either::Right(record) => RawAttrs::from_attrs_owner(db, src.with_value(record)),\n                 }\n             }\n             AttrDefId::EnumVariantId(var_id) => {\n                 let src = var_id.parent.child_source(db);\n                 let src = src.as_ref().map(|it| &it[var_id.local_id]);\n-                Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n+                RawAttrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::AdtId(it) => match it {\n                 AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n@@ -101,53 +175,19 @@ impl Attrs {\n             AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-        }\n-    }\n-\n-    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn AttrsOwner>) -> Attrs {\n-        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n-        Attrs::new(owner.value, &hygiene)\n-    }\n-\n-    pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n-        let (inner_attrs, inner_docs) = inner_attributes(owner.syntax())\n-            .map_or((None, None), |(attrs, docs)| ((Some(attrs), Some(docs))));\n-\n-        let outer_attrs = owner.attrs().filter(|attr| attr.excl_token().is_none());\n-        let attrs = outer_attrs\n-            .chain(inner_attrs.into_iter().flatten())\n-            .map(|attr| (attr.syntax().text_range().start(), Attr::from_src(attr, hygiene)));\n-\n-        let outer_docs =\n-            ast::CommentIter::from_syntax_node(owner.syntax()).filter(ast::Comment::is_outer);\n-        let docs = outer_docs.chain(inner_docs.into_iter().flatten()).map(|docs_text| {\n-            (\n-                docs_text.syntax().text_range().start(),\n-                docs_text.doc_comment().map(|doc| Attr {\n-                    input: Some(AttrInput::Literal(SmolStr::new(doc))),\n-                    path: ModPath::from(hir_expand::name!(doc)),\n-                }),\n-            )\n-        });\n-        // sort here by syntax node offset because the source can have doc attributes and doc strings be interleaved\n-        let attrs: Vec<_> = docs.chain(attrs).sorted_by_key(|&(offset, _)| offset).collect();\n-        let entries = if attrs.is_empty() {\n-            // Avoid heap allocation\n-            None\n-        } else {\n-            Some(attrs.into_iter().flat_map(|(_, attr)| attr).collect())\n         };\n-        Attrs { entries }\n+\n+        raw_attrs.filter(db, def.krate(db))\n     }\n \n     pub fn merge(&self, other: Attrs) -> Attrs {\n-        match (&self.entries, &other.entries) {\n-            (None, None) => Attrs { entries: None },\n+        match (&self.0.entries, &other.0.entries) {\n+            (None, None) => Attrs::EMPTY,\n             (Some(entries), None) | (None, Some(entries)) => {\n-                Attrs { entries: Some(entries.clone()) }\n+                Attrs(RawAttrs { entries: Some(entries.clone()) })\n             }\n             (Some(a), Some(b)) => {\n-                Attrs { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+                Attrs(RawAttrs { entries: Some(a.iter().chain(b.iter()).cloned().collect()) })\n             }\n         }\n     }\n@@ -291,16 +331,16 @@ impl<'a> AttrQuery<'a> {\n     }\n }\n \n-fn attrs_from_ast<N>(src: AstId<N>, db: &dyn DefDatabase) -> Attrs\n+fn attrs_from_ast<N>(src: AstId<N>, db: &dyn DefDatabase) -> RawAttrs\n where\n     N: ast::AttrsOwner,\n {\n     let src = InFile::new(src.file_id, src.to_node(db.upcast()));\n-    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+    RawAttrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }\n \n-fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> Attrs {\n+fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {\n     let tree = db.item_tree(id.file_id);\n     let mod_item = N::id_to_mod_item(id.value);\n-    tree.attrs(mod_item.into()).clone()\n+    tree.raw_attrs(mod_item.into()).clone()\n }"}, {"sha": "998b826010e4e7cbc8506740a2fd5dd98babc23b", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -24,7 +24,7 @@ use test_utils::mark;\n pub(crate) use lower::LowerCtx;\n \n use crate::{\n-    attr::Attrs,\n+    attr::{Attrs, RawAttrs},\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n     item_scope::BuiltinShadowMode,\n@@ -40,6 +40,7 @@ use crate::{\n pub(crate) struct CfgExpander {\n     cfg_options: CfgOptions,\n     hygiene: Hygiene,\n+    krate: CrateId,\n }\n \n pub(crate) struct Expander {\n@@ -65,15 +66,15 @@ impl CfgExpander {\n     ) -> CfgExpander {\n         let hygiene = Hygiene::new(db.upcast(), current_file_id);\n         let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n-        CfgExpander { cfg_options, hygiene }\n+        CfgExpander { cfg_options, hygiene, krate }\n     }\n \n-    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n-        Attrs::new(owner, &self.hygiene)\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::AttrsOwner) -> Attrs {\n+        RawAttrs::new(owner, &self.hygiene).filter(db, self.krate)\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, owner: &dyn ast::AttrsOwner) -> bool {\n-        let attrs = self.parse_attrs(owner);\n+    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::AttrsOwner) -> bool {\n+        let attrs = self.parse_attrs(db, owner);\n         attrs.is_cfg_enabled(&self.cfg_options)\n     }\n }\n@@ -189,8 +190,8 @@ impl Expander {\n         InFile { file_id: self.current_file_id, value }\n     }\n \n-    pub(crate) fn parse_attrs(&self, owner: &dyn ast::AttrsOwner) -> Attrs {\n-        self.cfg_expander.parse_attrs(owner)\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::AttrsOwner) -> Attrs {\n+        self.cfg_expander.parse_attrs(db, owner)\n     }\n \n     pub(crate) fn cfg_options(&self) -> &CfgOptions {"}, {"sha": "0f404be1b7c4b9e12e23cfc3de2bd725e2cd670a", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -963,7 +963,7 @@ impl ExprCollector<'_> {\n     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n     /// not.\n     fn check_cfg(&mut self, owner: &dyn ast::AttrsOwner) -> Option<()> {\n-        match self.expander.parse_attrs(owner).cfg() {\n+        match self.expander.parse_attrs(self.db, owner).cfg() {\n             Some(cfg) => {\n                 if self.expander.cfg_options().check(&cfg) != Some(false) {\n                     return Some(());"}, {"sha": "e7b7724f75fb245157d55f4d7e144673b0c17560", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -35,14 +35,15 @@ pub struct FunctionData {\n impl FunctionData {\n     pub(crate) fn fn_data_query(db: &dyn DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n+        let krate = loc.container.module(db).krate;\n         let item_tree = db.item_tree(loc.id.file_id);\n         let func = &item_tree[loc.id.value];\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n             params: func.params.to_vec(),\n             ret_type: func.ret_type.clone(),\n-            attrs: item_tree.attrs(ModItem::from(loc.id.value).into()).clone(),\n+            attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()).clone(),\n             has_self_param: func.has_self_param,\n             has_body: func.has_body,\n             is_unsafe: func.is_unsafe,\n@@ -233,7 +234,7 @@ fn collect_items(\n         match item {\n             AssocItem::Function(id) => {\n                 let item = &item_tree[id];\n-                let attrs = item_tree.attrs(ModItem::from(id).into());\n+                let attrs = item_tree.attrs(db, module.krate, ModItem::from(id).into());\n                 if !attrs.is_cfg_enabled(&cfg_options) {\n                     continue;\n                 }"}, {"sha": "5eb7cae7f04e4630e952436792d2241cf671554c", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -13,6 +13,7 @@ use std::{\n \n use arena::{Arena, Idx, RawId};\n use ast::{AstNode, AttrsOwner, NameOwner, StructKind};\n+use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::FileAstId,\n@@ -26,7 +27,7 @@ use syntax::{ast, match_ast};\n use test_utils::mark;\n \n use crate::{\n-    attr::Attrs,\n+    attr::{Attrs, RawAttrs},\n     db::DefDatabase,\n     generics::GenericParams,\n     path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n@@ -67,7 +68,7 @@ impl GenericParamsId {\n #[derive(Debug, Eq, PartialEq)]\n pub struct ItemTree {\n     top_level: SmallVec<[ModItem; 1]>,\n-    attrs: FxHashMap<AttrOwner, Attrs>,\n+    attrs: FxHashMap<AttrOwner, RawAttrs>,\n     inner_items: FxHashMap<FileAstId<ast::Item>, SmallVec<[ModItem; 1]>>,\n \n     data: Option<Box<ItemTreeData>>,\n@@ -88,7 +89,7 @@ impl ItemTree {\n         let mut item_tree = match_ast! {\n             match syntax {\n                 ast::SourceFile(file) => {\n-                    top_attrs = Some(Attrs::new(&file, &hygiene));\n+                    top_attrs = Some(RawAttrs::new(&file, &hygiene));\n                     ctx.lower_module_items(&file)\n                 },\n                 ast::MacroItems(items) => {\n@@ -180,12 +181,16 @@ impl ItemTree {\n     }\n \n     /// Returns the inner attributes of the source file.\n-    pub fn top_level_attrs(&self) -> &Attrs {\n-        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&Attrs::EMPTY)\n+    pub fn top_level_attrs(&self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n+        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone().filter(db, krate)\n     }\n \n-    pub fn attrs(&self, of: AttrOwner) -> &Attrs {\n-        self.attrs.get(&of).unwrap_or(&Attrs::EMPTY)\n+    pub(crate) fn raw_attrs(&self, of: AttrOwner) -> &RawAttrs {\n+        self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)\n+    }\n+\n+    pub fn attrs(&self, db: &dyn DefDatabase, krate: CrateId, of: AttrOwner) -> Attrs {\n+        self.raw_attrs(of).clone().filter(db, krate)\n     }\n \n     /// Returns the lowered inner items that `ast` corresponds to."}, {"sha": "c8f090c22c08c1ca78e2aa6a84d612a8787bb845", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -10,7 +10,6 @@ use syntax::{\n };\n \n use crate::{\n-    attr::Attrs,\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n     type_ref::LifetimeRef,\n };\n@@ -105,7 +104,7 @@ impl Ctx {\n             | ast::Item::MacroDef(_) => {}\n         };\n \n-        let attrs = Attrs::new(item, &self.hygiene);\n+        let attrs = RawAttrs::new(item, &self.hygiene);\n         let items = match item {\n             ast::Item::Struct(ast) => self.lower_struct(ast).map(Into::into),\n             ast::Item::Union(ast) => self.lower_union(ast).map(Into::into),\n@@ -138,7 +137,7 @@ impl Ctx {\n         items\n     }\n \n-    fn add_attrs(&mut self, item: AttrOwner, attrs: Attrs) {\n+    fn add_attrs(&mut self, item: AttrOwner, attrs: RawAttrs) {\n         match self.tree.attrs.entry(item) {\n             Entry::Occupied(mut entry) => {\n                 *entry.get_mut() = entry.get().merge(attrs);\n@@ -205,7 +204,7 @@ impl Ctx {\n         for field in fields.fields() {\n             if let Some(data) = self.lower_record_field(&field) {\n                 let idx = self.data().fields.alloc(data);\n-                self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(&field, &self.hygiene));\n             }\n         }\n         let end = self.next_field_idx();\n@@ -225,7 +224,7 @@ impl Ctx {\n         for (i, field) in fields.fields().enumerate() {\n             let data = self.lower_tuple_field(i, &field);\n             let idx = self.data().fields.alloc(data);\n-            self.add_attrs(idx.into(), Attrs::new(&field, &self.hygiene));\n+            self.add_attrs(idx.into(), RawAttrs::new(&field, &self.hygiene));\n         }\n         let end = self.next_field_idx();\n         IdRange::new(start..end)\n@@ -270,7 +269,7 @@ impl Ctx {\n         for variant in variants.variants() {\n             if let Some(data) = self.lower_variant(&variant) {\n                 let idx = self.data().variants.alloc(data);\n-                self.add_attrs(idx.into(), Attrs::new(&variant, &self.hygiene));\n+                self.add_attrs(idx.into(), RawAttrs::new(&variant, &self.hygiene));\n             }\n         }\n         let end = self.next_variant_idx();\n@@ -438,7 +437,7 @@ impl Ctx {\n             self.with_inherited_visibility(visibility, |this| {\n                 list.assoc_items()\n                     .filter_map(|item| {\n-                        let attrs = Attrs::new(&item, &this.hygiene);\n+                        let attrs = RawAttrs::new(&item, &this.hygiene);\n                         this.collect_inner_items(item.syntax());\n                         this.lower_assoc_item(&item).map(|item| {\n                             this.add_attrs(ModItem::from(item).into(), attrs);\n@@ -475,7 +474,7 @@ impl Ctx {\n             .filter_map(|item| {\n                 self.collect_inner_items(item.syntax());\n                 let assoc = self.lower_assoc_item(&item)?;\n-                let attrs = Attrs::new(&item, &self.hygiene);\n+                let attrs = RawAttrs::new(&item, &self.hygiene);\n                 self.add_attrs(ModItem::from(assoc).into(), attrs);\n                 Some(assoc)\n             })\n@@ -560,7 +559,7 @@ impl Ctx {\n             list.extern_items()\n                 .filter_map(|item| {\n                     self.collect_inner_items(item.syntax());\n-                    let attrs = Attrs::new(&item, &self.hygiene);\n+                    let attrs = RawAttrs::new(&item, &self.hygiene);\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => {\n                             let func_id = self.lower_function(&ast)?;"}, {"sha": "b114a6fe4ab0d6e337845d08c3675b21b90662eb", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f07d8dd587c24bca8622ee8c39e5a1e156825b4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=4f07d8dd587c24bca8622ee8c39e5a1e156825b4", "patch": "@@ -221,17 +221,20 @@ impl DefCollector<'_> {\n         let item_tree = self.db.item_tree(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n-        let mut root_collector = ModCollector {\n-            def_collector: &mut *self,\n-            macro_depth: 0,\n-            module_id,\n-            file_id: file_id.into(),\n-            item_tree: &item_tree,\n-            mod_dir: ModDir::root(),\n-        };\n-        if item_tree.top_level_attrs().cfg().map_or(true, |cfg| root_collector.is_cfg_enabled(&cfg))\n+        if item_tree\n+            .top_level_attrs(self.db, self.def_map.krate)\n+            .cfg()\n+            .map_or(true, |cfg| self.cfg_options.check(&cfg) != Some(false))\n         {\n-            root_collector.collect(item_tree.top_level_items());\n+            ModCollector {\n+                def_collector: &mut *self,\n+                macro_depth: 0,\n+                module_id,\n+                file_id: file_id.into(),\n+                item_tree: &item_tree,\n+                mod_dir: ModDir::root(),\n+            }\n+            .collect(item_tree.top_level_items());\n         }\n \n         // main name resolution fixed-point loop.\n@@ -905,6 +908,8 @@ struct ModCollector<'a, 'b> {\n \n impl ModCollector<'_, '_> {\n     fn collect(&mut self, items: &[ModItem]) {\n+        let krate = self.def_collector.def_map.krate;\n+\n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n@@ -921,7 +926,7 @@ impl ModCollector<'_, '_> {\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            let attrs = self.item_tree.attrs((*item).into());\n+            let attrs = self.item_tree.attrs(self.def_collector.db, krate, (*item).into());\n             if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n                 if let ModItem::ExternCrate(id) = item {\n                     let import = self.item_tree[*id].clone();\n@@ -933,7 +938,7 @@ impl ModCollector<'_, '_> {\n         }\n \n         for &item in items {\n-            let attrs = self.item_tree.attrs(item.into());\n+            let attrs = self.item_tree.attrs(self.def_collector.db, krate, item.into());\n             if let Some(cfg) = attrs.cfg() {\n                 if !self.is_cfg_enabled(&cfg) {\n                     self.emit_unconfigured_diagnostic(item, &cfg);\n@@ -946,7 +951,7 @@ impl ModCollector<'_, '_> {\n \n             let mut def = None;\n             match item {\n-                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n+                ModItem::Mod(m) => self.collect_module(&self.item_tree[m], &attrs),\n                 ModItem::Import(import_id) => {\n                     self.def_collector.unresolved_imports.push(ImportDirective {\n                         module_id: self.module_id,\n@@ -975,7 +980,11 @@ impl ModCollector<'_, '_> {\n \n                     // \"Macro 2.0\" is not currently supported by rust-analyzer, but libcore uses it\n                     // to define builtin macros, so we support at least that part.\n-                    let attrs = self.item_tree.attrs(ModItem::from(id).into());\n+                    let attrs = self.item_tree.attrs(\n+                        self.def_collector.db,\n+                        krate,\n+                        ModItem::from(id).into(),\n+                    );\n                     if attrs.by_key(\"rustc_builtin_macro\").exists() {\n                         let krate = self.def_collector.def_map.krate;\n                         let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n@@ -1012,7 +1021,7 @@ impl ModCollector<'_, '_> {\n                 ModItem::Function(id) => {\n                     let func = &self.item_tree[id];\n \n-                    self.collect_proc_macro_def(&func.name, attrs);\n+                    self.collect_proc_macro_def(&func.name, &attrs);\n \n                     def = Some(DefData {\n                         id: FunctionLoc {\n@@ -1032,7 +1041,7 @@ impl ModCollector<'_, '_> {\n                     // FIXME: check attrs to see if this is an attribute macro invocation;\n                     // in which case we don't add the invocation, just a single attribute\n                     // macro invocation\n-                    self.collect_derives(attrs, it.ast_id.upcast());\n+                    self.collect_derives(&attrs, it.ast_id.upcast());\n \n                     def = Some(DefData {\n                         id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n@@ -1049,7 +1058,7 @@ impl ModCollector<'_, '_> {\n                     // FIXME: check attrs to see if this is an attribute macro invocation;\n                     // in which case we don't add the invocation, just a single attribute\n                     // macro invocation\n-                    self.collect_derives(attrs, it.ast_id.upcast());\n+                    self.collect_derives(&attrs, it.ast_id.upcast());\n \n                     def = Some(DefData {\n                         id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n@@ -1066,7 +1075,7 @@ impl ModCollector<'_, '_> {\n                     // FIXME: check attrs to see if this is an attribute macro invocation;\n                     // in which case we don't add the invocation, just a single attribute\n                     // macro invocation\n-                    self.collect_derives(attrs, it.ast_id.upcast());\n+                    self.collect_derives(&attrs, it.ast_id.upcast());\n \n                     def = Some(DefData {\n                         id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n@@ -1303,8 +1312,9 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {\n+        let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];\n-        let attrs = self.item_tree.attrs(ModItem::from(id).into());\n+        let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n         let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n \n         let export_attr = attrs.by_key(\"macro_export\");"}]}