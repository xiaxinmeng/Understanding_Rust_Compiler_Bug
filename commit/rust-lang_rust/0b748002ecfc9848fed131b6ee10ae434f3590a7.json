{"sha": "0b748002ecfc9848fed131b6ee10ae434f3590a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNzQ4MDAyZWNmYzk4NDhmZWQxMzFiNmVlMTBhZTQzNGYzNTkwYTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-02T08:37:38Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-06-02T08:37:56Z"}, "message": "added test to ensure move_val_init still handles cleanups properly.", "tree": {"sha": "ba29f8d843b44ad3830d54f436c0129a7939eecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba29f8d843b44ad3830d54f436c0129a7939eecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b748002ecfc9848fed131b6ee10ae434f3590a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b748002ecfc9848fed131b6ee10ae434f3590a7", "html_url": "https://github.com/rust-lang/rust/commit/0b748002ecfc9848fed131b6ee10ae434f3590a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b748002ecfc9848fed131b6ee10ae434f3590a7/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "528ab1fe9b51228daf41c7110216c33a93cfa341", "url": "https://api.github.com/repos/rust-lang/rust/commits/528ab1fe9b51228daf41c7110216c33a93cfa341", "html_url": "https://github.com/rust-lang/rust/commit/528ab1fe9b51228daf41c7110216c33a93cfa341"}], "stats": {"total": 194, "additions": 194, "deletions": 0}, "files": [{"sha": "bc7a654f867ea5eb06014aa71becb6914f57cd6d", "filename": "src/test/run-pass/intrinsic-move-val-cleanups.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/0b748002ecfc9848fed131b6ee10ae434f3590a7/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b748002ecfc9848fed131b6ee10ae434f3590a7/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val-cleanups.rs?ref=0b748002ecfc9848fed131b6ee10ae434f3590a7", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is checking that the move_val_init intrinsic is\n+// respecting cleanups for both of its argument expressions.\n+//\n+// In other words, if either DEST or SOURCE in\n+//\n+//   `intrinsics::move_val_init(DEST, SOURCE)\n+//\n+// introduce temporaries that require cleanup, and SOURCE panics, then\n+// make sure the cleanups still occur.\n+\n+#![feature(core, std_misc)]\n+\n+use std::cell::RefCell;\n+use std::intrinsics;\n+use std::sync::{Arc, LockResult, Mutex, MutexGuard};\n+use std::thread;\n+\n+type LogEntry = (&'static str, i32);\n+type Guarded = RefCell<Vec<LogEntry>>;\n+#[derive(Clone)]\n+struct Log(Arc<Mutex<Guarded>>);\n+struct Acquired<'a>(MutexGuard<'a, Guarded>);\n+type LogState = (MutexWas, &'static [LogEntry]);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutexWas { Poisoned, NotPoisoned }\n+\n+impl Log {\n+    fn lock(&self) -> LockResult<MutexGuard<RefCell<Vec<LogEntry>>>> { self.0.lock() }\n+    fn acquire(&self) -> Acquired { Acquired(self.0.lock().unwrap()) }\n+}\n+\n+impl<'a> Acquired<'a> {\n+    fn log(&self, s: &'static str, i: i32) { self.0.borrow_mut().push((s, i)); }\n+}\n+\n+const TEST1_EXPECT: LogState = (MutexWas::NotPoisoned,\n+                                &[(\"double-check non-poisoning path\", 1)\n+                                  ]);\n+\n+fn test1(log: Log) {\n+    {\n+        let acq = log.acquire();\n+        acq.log(\"double-check non-poisoning path\", 1);\n+    }\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+const TEST2_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"double-check poisoning path\", 1),\n+                                  (\"and multiple log entries\", 2),\n+                                  ]);\n+fn test2(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"double-check poisoning path\", 1);\n+    acq.log(\"and multiple log entries\", 2);\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+struct LogOnDrop<'a>(&'a Acquired<'a>, &'static str, i32);\n+impl<'a> Drop for LogOnDrop<'a> {\n+    fn drop(&mut self) {\n+        self.0.log(self.1, self.2);\n+    }\n+}\n+\n+const TEST3_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"double-check destructors can log\", 1),\n+                                  (\"drop d2\", 2),\n+                                  (\"drop d1\", 3),\n+                                  ]);\n+fn test3(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"double-check destructors can log\", 1);\n+    let _d1 = LogOnDrop(&acq, \"drop d1\", 3);\n+    let _d2 = LogOnDrop(&acq, \"drop d2\", 2);\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+// The *real* tests of panic-handling for move_val_init intrinsic\n+// start here.\n+\n+const TEST4_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"neither arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop temp LOD\", 3),\n+                                  (\"drop dest_b\", 4),\n+                                  (\"drop dest_a\", 5),\n+                                  ]);\n+fn test4(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"neither arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"a will be overwritten, not dropped\", 0);\n+    let mut dest_b = LogOnDrop(&acq, \"b will be overwritten, not dropped\", 0);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  LogOnDrop(&acq, \"drop dest_a\", 5));\n+        intrinsics::move_val_init(&mut dest_b, { LogOnDrop(&acq, \"drop temp LOD\", 3);\n+                                                 LogOnDrop(&acq, \"drop dest_b\", 4) });\n+    }\n+    panic!(\"every test ends in a panic\");\n+}\n+\n+\n+// Check that move_val_init(PANIC, SOURCE_EXPR) never evaluates SOURCE_EXPR\n+const TEST5_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"first arg panics\", 1),\n+                                  (\"drop orig dest_a\", 2),\n+                                  ]);\n+fn test5(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"first arg panics\", 1);\n+    let mut _dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 2);\n+    unsafe {\n+        intrinsics::move_val_init({ panic!(\"every test ends in a panic\") },\n+                                  LogOnDrop(&acq, \"we never get here\", 0));\n+    }\n+}\n+\n+// Check that move_val_init(DEST_EXPR, PANIC) cleans up temps from DEST_EXPR.\n+const TEST6_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"second arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop orig dest_a\", 3),\n+                                  ]);\n+fn test6(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"second arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 3);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  { panic!(\"every test ends in a panic\"); });\n+    }\n+}\n+\n+// Check that move_val_init(DEST_EXPR, COMPLEX_PANIC) cleans up temps from COMPLEX_PANIC.\n+const TEST7_EXPECT: LogState = (MutexWas::Poisoned,\n+                                &[(\"second arg panics\", 1),\n+                                  (\"drop temp LOD\", 2),\n+                                  (\"drop temp LOD\", 3),\n+                                  (\"drop orig dest_a\", 4),\n+                                  ]);\n+fn test7(log: Log) {\n+    let acq = log.acquire();\n+    acq.log(\"second arg panics\", 1);\n+    let mut dest_a = LogOnDrop(&acq, \"drop orig dest_a\", 4);\n+    unsafe {\n+        intrinsics::move_val_init({ LogOnDrop(&acq, \"drop temp LOD\", 2); &mut dest_a },\n+                                  { LogOnDrop(&acq, \"drop temp LOD\", 3);\n+                                    panic!(\"every test ends in a panic\"); });\n+    }\n+}\n+\n+const TEST_SUITE: &'static [(&'static str, fn (Log), LogState)] =\n+    &[(\"test1\", test1, TEST1_EXPECT),\n+      (\"test2\", test2, TEST2_EXPECT),\n+      (\"test3\", test3, TEST3_EXPECT),\n+      (\"test4\", test4, TEST4_EXPECT),\n+      (\"test5\", test5, TEST5_EXPECT),\n+      (\"test6\", test6, TEST6_EXPECT),\n+      (\"test7\", test7, TEST7_EXPECT),\n+      ];\n+\n+fn main() {\n+    for &(name, test, expect) in TEST_SUITE {\n+        let log = Log(Arc::new(Mutex::new(RefCell::new(Vec::new()))));\n+        let ret = { let log = log.clone(); thread::spawn(move || test(log)).join() };\n+        assert!(ret.is_err(), \"{} must end with panic\", name);\n+        {\n+            let l = log.lock();\n+            match l {\n+                Ok(acq) => {\n+                    assert_eq!((MutexWas::NotPoisoned, &acq.borrow()[..]), expect);\n+                    println!(\"{} (unpoisoned) log: {:?}\", name, *acq);\n+                }\n+                Err(e) => {\n+                    let acq = e.into_inner();\n+                    assert_eq!((MutexWas::Poisoned, &acq.borrow()[..]), expect);\n+                    println!(\"{} (poisoned) log: {:?}\", name, *acq);\n+                }\n+            }\n+        }\n+    }\n+}"}]}