{"sha": "35d6d70a64d8db139a700ccfdb31824bbf4ba350", "node_id": "C_kwDOAAsO6NoAKDM1ZDZkNzBhNjRkOGRiMTM5YTcwMGNjZmRiMzE4MjRiYmY0YmEzNTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T00:03:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T00:03:02Z"}, "message": "Auto merge of #107693 - petrochenkov:metable, r=oli-obk\n\nrustc_metadata: Encode/decode some `LazyArrays` without an `Option`\n\nand a couple of related changes, see individual commits.\n\nAddresses comments in https://github.com/rust-lang/rust/pull/107166#discussion_r1083417124 and https://github.com/rust-lang/rust/pull/107166#discussion_r1083768417, cc `@cjgillot` `@oli-obk.`", "tree": {"sha": "974237e3bdc332244b2556b347cf945d7ed73064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/974237e3bdc332244b2556b347cf945d7ed73064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35d6d70a64d8db139a700ccfdb31824bbf4ba350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35d6d70a64d8db139a700ccfdb31824bbf4ba350", "html_url": "https://github.com/rust-lang/rust/commit/35d6d70a64d8db139a700ccfdb31824bbf4ba350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35d6d70a64d8db139a700ccfdb31824bbf4ba350/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1eaa2d5d4d1f5b7b89561a940718058d414e89c", "html_url": "https://github.com/rust-lang/rust/commit/e1eaa2d5d4d1f5b7b89561a940718058d414e89c"}, {"sha": "f4e2b954a1749bb215eb0f1365e7d1f95162d3ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e2b954a1749bb215eb0f1365e7d1f95162d3ba", "html_url": "https://github.com/rust-lang/rust/commit/f4e2b954a1749bb215eb0f1365e7d1f95162d3ba"}], "stats": {"total": 366, "additions": 229, "deletions": 137}, "files": [{"sha": "e2b07fad6e782ee24ed5e65f8889a15e1bea3516", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyValue<T> {\n impl<'a, 'tcx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         let len = decoder.read_usize();\n-        if len == 0 { LazyArray::empty() } else { decoder.read_lazy_array(len) }\n+        if len == 0 { LazyArray::default() } else { decoder.read_lazy_array(len) }\n     }\n }\n \n@@ -864,7 +864,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, index)\n-                .unwrap_or_else(LazyArray::empty)\n+                .expect(\"fields are not encoded for a variant\")\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n@@ -896,7 +896,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .children\n                 .get(self, item_id)\n-                .unwrap_or_else(LazyArray::empty)\n+                .expect(\"variants are not encoded for an enum\")\n                 .decode(self)\n                 .filter_map(|index| {\n                     let kind = self.def_kind(index);\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .fn_arg_names\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"argument names not encoded for a function\")\n             .decode((self, sess))\n             .nth(0)\n             .map_or(false, |ident| ident.name == kw::SelfLower)\n@@ -1060,21 +1060,20 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"associated items not encoded for an item\")\n             .decode((self, sess))\n             .map(move |child_index| self.local_def_id(child_index))\n     }\n \n     fn get_associated_item(self, id: DefIndex, sess: &'a Session) -> ty::AssocItem {\n         let name = self.item_name(id);\n \n-        let kind = match self.def_kind(id) {\n-            DefKind::AssocConst => ty::AssocKind::Const,\n-            DefKind::AssocFn => ty::AssocKind::Fn,\n-            DefKind::AssocTy => ty::AssocKind::Type,\n+        let (kind, has_self) = match self.def_kind(id) {\n+            DefKind::AssocConst => (ty::AssocKind::Const, false),\n+            DefKind::AssocFn => (ty::AssocKind::Fn, self.get_fn_has_self_parameter(id, sess)),\n+            DefKind::AssocTy => (ty::AssocKind::Type, false),\n             _ => bug!(\"cannot get associated-item of `{:?}`\", self.def_key(id)),\n         };\n-        let has_self = self.get_fn_has_self_parameter(id, sess);\n         let container = self.root.tables.assoc_container.get(self, id).unwrap();\n \n         ty::AssocItem {\n@@ -1131,7 +1130,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"fields not encoded for a struct\")\n             .decode(self)\n             .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n@@ -1144,7 +1143,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .tables\n             .children\n             .get(self, id)\n-            .unwrap_or_else(LazyArray::empty)\n+            .expect(\"fields not encoded for a struct\")\n             .decode(self)\n             .map(move |field_index| self.get_visibility(field_index))\n     }\n@@ -1159,7 +1158,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, id)\n-                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(|index| self.local_def_id(index)),\n         )\n@@ -1174,7 +1172,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .tables\n                 .inherent_impls\n                 .get(self, ty_index)\n-                .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n                 .map(move |impl_index| (ty_def_id, self.local_def_id(impl_index)))\n         })\n@@ -1322,7 +1319,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     ) -> DefPathHash {\n         *def_path_hashes\n             .entry(index)\n-            .or_insert_with(|| self.root.tables.def_path_hashes.get(self, index).unwrap())\n+            .or_insert_with(|| self.root.tables.def_path_hashes.get(self, index))\n     }\n \n     #[inline]"}, {"sha": "07cc84ab95368480a2ec09b80fe0bad29ed63e0c", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -1,6 +1,7 @@\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n+use crate::rmeta::table::IsDefault;\n use crate::rmeta::AttrFlags;\n \n use rustc_ast as ast;\n@@ -88,6 +89,14 @@ macro_rules! provide_one {\n             }\n         }\n     };\n+    ($tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table_defaulted_array }) => {\n+        provide_one! {\n+            $tcx, $def_id, $other, $cdata, $name => {\n+                let lazy = $cdata.root.tables.$name.get($cdata, $def_id.index);\n+                if lazy.is_default() { &[] } else { $tcx.arena.alloc_from_iter(lazy.decode(($cdata, $tcx))) }\n+            }\n+        }\n+    };\n     ($tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table_direct }) => {\n         provide_one! {\n             $tcx, $def_id, $other, $cdata, $name => {\n@@ -187,10 +196,10 @@ impl IntoArgs for (CrateNum, SimplifiedType) {\n }\n \n provide! { tcx, def_id, other, cdata,\n-    explicit_item_bounds => { table }\n+    explicit_item_bounds => { table_defaulted_array }\n     explicit_predicates_of => { table }\n     generics_of => { table }\n-    inferred_outlives_of => { table }\n+    inferred_outlives_of => { table_defaulted_array }\n     super_predicates_of => { table }\n     type_of => { table }\n     variances_of => { table }"}, {"sha": "85e9ae9a98302bb780f1866295e0768970998982", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 60, "deletions": 67, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -76,13 +76,13 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n     symbol_table: FxHashMap<Symbol, usize>,\n }\n \n-/// If the current crate is a proc-macro, returns early with `LazyArray::empty()`.\n+/// If the current crate is a proc-macro, returns early with `LazyArray::default()`.\n /// This is useful for skipping the encoding of things that aren't needed\n /// for proc-macro crates.\n macro_rules! empty_proc_macro {\n     ($self:ident) => {\n         if $self.is_proc_macro {\n-            return LazyArray::empty();\n+            return LazyArray::default();\n         }\n     };\n }\n@@ -365,21 +365,31 @@ impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy(value);\n-            $self.$tables.$table.set($def_id.index, lazy);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n         }\n     }};\n }\n \n-// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy_value($value))`, which would\n+// Shorthand for `$self.$tables.$table.set_some($def_id.index, $self.lazy_value($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record_array {\n+    ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n+        {\n+            let value = $value;\n+            let lazy = $self.lazy_array(value);\n+            $self.$tables.$table.set_some($def_id.index, lazy);\n+        }\n+    }};\n+}\n+\n+macro_rules! record_defaulted_array {\n     ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n@@ -467,13 +477,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             {\n                 let def_key = self.lazy(table.def_key(def_index));\n                 let def_path_hash = table.def_path_hash(def_index);\n-                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_keys.set_some(def_index, def_key);\n                 self.tables.def_path_hashes.set(def_index, def_path_hash);\n             }\n         } else {\n             for (def_index, def_key, def_path_hash) in table.enumerated_keys_and_path_hashes() {\n                 let def_key = self.lazy(def_key);\n-                self.tables.def_keys.set(def_index, def_key);\n+                self.tables.def_keys.set_some(def_index, def_key);\n                 self.tables.def_path_hashes.set(def_index, *def_path_hash);\n             }\n         }\n@@ -548,7 +558,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             let on_disk_index: u32 =\n                 on_disk_index.try_into().expect(\"cannot export more than U32_MAX files\");\n-            adapted.set(on_disk_index, self.lazy(source_file));\n+            adapted.set_some(on_disk_index, self.lazy(source_file));\n         }\n \n         adapted.encode(&mut self.opaque)\n@@ -1147,9 +1157,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n-        if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n-        }\n+        self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n     }\n \n     fn encode_def_ids(&mut self) {\n@@ -1161,7 +1169,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            self.tables.opt_def_kind.set(def_id.index, def_kind);\n+            self.tables.opt_def_kind.set_some(def_id.index, def_kind);\n             let def_span = tcx.def_span(local_id);\n             record!(self.tables.def_span[def_id] <- def_span);\n             self.encode_attrs(local_id);\n@@ -1192,9 +1200,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.generics_of[def_id] <- g);\n                 record!(self.tables.explicit_predicates_of[def_id] <- self.tcx.explicit_predicates_of(def_id));\n                 let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n-                if !inferred_outlives.is_empty() {\n-                    record_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n-                }\n+                record_defaulted_array!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n             }\n             if should_encode_type(tcx, local_id, def_kind) {\n                 record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n@@ -1215,15 +1221,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n         }\n+\n         let inherent_impls = tcx.with_stable_hashing_context(|hcx| {\n             tcx.crate_inherent_impls(()).inherent_impls.to_sorted(&hcx, true)\n         });\n-\n-        for (def_id, implementations) in inherent_impls {\n-            if implementations.is_empty() {\n-                continue;\n-            }\n-            record_array!(self.tables.inherent_impls[def_id.to_def_id()] <- implementations.iter().map(|&def_id| {\n+        for (def_id, impls) in inherent_impls {\n+            record_defaulted_array!(self.tables.inherent_impls[def_id.to_def_id()] <- impls.iter().map(|def_id| {\n                 assert!(def_id.is_local());\n                 def_id.index\n             }));\n@@ -1264,14 +1267,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             };\n             record!(self.tables.variant_data[variant.def_id] <- data);\n \n-            self.tables.constness.set(variant.def_id.index, hir::Constness::Const);\n+            self.tables.constness.set_some(variant.def_id.index, hir::Constness::Const);\n             record_array!(self.tables.children[variant.def_id] <- variant.fields.iter().map(|f| {\n                 assert!(f.did.is_local());\n                 f.did.index\n             }));\n \n             if let Some((CtorKind::Fn, ctor_def_id)) = variant.ctor {\n-                self.tables.constness.set(ctor_def_id.index, hir::Constness::Const);\n+                self.tables.constness.set_some(ctor_def_id.index, hir::Constness::Const);\n                 let fn_sig = tcx.fn_sig(ctor_def_id);\n                 record!(self.tables.fn_sig[ctor_def_id] <- fn_sig);\n                 // FIXME only encode signature for ctor_def_id\n@@ -1332,26 +1335,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_explicit_item_bounds(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_explicit_item_bounds({:?})\", def_id);\n         let bounds = self.tcx.explicit_item_bounds(def_id);\n-        if !bounds.is_empty() {\n-            record_array!(self.tables.explicit_item_bounds[def_id] <- bounds);\n-        }\n+        record_defaulted_array!(self.tables.explicit_item_bounds[def_id] <- bounds);\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let impl_defaultness = tcx.impl_defaultness(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, impl_defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, impl_defaultness);\n         let trait_item = tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, trait_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, trait_item.container);\n \n         match trait_item.kind {\n             ty::AssocKind::Const => {}\n             ty::AssocKind::Fn => {\n                 record_array!(self.tables.fn_arg_names[def_id] <- tcx.fn_arg_names(def_id));\n-                self.tables.asyncness.set(def_id.index, tcx.asyncness(def_id));\n-                self.tables.constness.set(def_id.index, hir::Constness::NotConst);\n+                self.tables.asyncness.set_some(def_id.index, tcx.asyncness(def_id));\n+                self.tables.constness.set_some(def_id.index, hir::Constness::NotConst);\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1367,33 +1368,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         let ast_item = self.tcx.hir().expect_impl_item(def_id.expect_local());\n-        self.tables.impl_defaultness.set(def_id.index, ast_item.defaultness);\n+        self.tables.impl_defaultness.set_some(def_id.index, ast_item.defaultness);\n         let impl_item = self.tcx.associated_item(def_id);\n-        self.tables.assoc_container.set(def_id.index, impl_item.container);\n+        self.tables.assoc_container.set_some(def_id.index, impl_item.container);\n \n         match impl_item.kind {\n             ty::AssocKind::Fn => {\n                 let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind else { bug!() };\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                 // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n             }\n             ty::AssocKind::Const | ty::AssocKind::Type => {}\n         }\n         if let Some(trait_item_def_id) = impl_item.trait_item_def_id {\n-            self.tables.trait_item_def_id.set(def_id.index, trait_item_def_id.into());\n+            self.tables.trait_item_def_id.set_some(def_id.index, trait_item_def_id.into());\n         }\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n \n@@ -1522,35 +1521,33 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match item.kind {\n             hir::ItemKind::Fn(ref sig, .., body) => {\n-                self.tables.asyncness.set(def_id.index, sig.header.asyncness);\n+                self.tables.asyncness.set_some(def_id.index, sig.header.asyncness);\n                 record_array!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n-                self.tables.constness.set(def_id.index, sig.header.constness);\n+                self.tables.constness.set_some(def_id.index, sig.header.constness);\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                if macro_def.macro_rules {\n-                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n-                }\n+                self.tables.is_macro_rules.set(def_id.index, macro_def.macro_rules);\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n-                }\n+                self.tables\n+                    .is_type_alias_impl_trait\n+                    .set(def_id.index, matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias));\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n-                self.tables.impl_defaultness.set(def_id.index, *defaultness);\n-                self.tables.constness.set(def_id.index, *constness);\n+                self.tables.impl_defaultness.set_some(def_id.index, *defaultness);\n+                self.tables.constness.set_some(def_id.index, *constness);\n \n                 let trait_ref = self.tcx.impl_trait_ref(def_id).map(ty::EarlyBinder::skip_binder);\n                 if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n                     if let Ok(mut an) = trait_def.ancestors(self.tcx, def_id) {\n                         if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n-                            self.tables.impl_parent.set(def_id.index, parent.into());\n+                            self.tables.impl_parent.set_some(def_id.index, parent.into());\n                         }\n                     }\n \n@@ -1564,7 +1561,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n \n                 let polarity = self.tcx.impl_polarity(def_id);\n-                self.tables.impl_polarity.set(def_id.index, polarity);\n+                self.tables.impl_polarity.set_some(def_id.index, polarity);\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n@@ -1601,9 +1598,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n@@ -1650,7 +1645,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             ty::Closure(_, substs) => {\n                 let constness = self.tcx.constness(def_id.to_def_id());\n-                self.tables.constness.set(def_id.to_def_id().index, constness);\n+                self.tables.constness.set_some(def_id.to_def_id().index, constness);\n                 record!(self.tables.fn_sig[def_id.to_def_id()] <- ty::EarlyBinder(substs.as_closure().sig()));\n             }\n \n@@ -1678,12 +1673,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.hygiene_ctxt.encode(\n             &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table, &mut expn_hash_table),\n             |(this, syntax_contexts, _, _), index, ctxt_data| {\n-                syntax_contexts.set(index, this.lazy(ctxt_data));\n+                syntax_contexts.set_some(index, this.lazy(ctxt_data));\n             },\n             |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n                 if let Some(index) = index.as_local() {\n-                    expn_data_table.set(index.as_raw(), this.lazy(expn_data));\n-                    expn_hash_table.set(index.as_raw(), this.lazy(hash));\n+                    expn_data_table.set_some(index.as_raw(), this.lazy(expn_data));\n+                    expn_hash_table.set_some(index.as_raw(), this.lazy(hash));\n                 }\n             },\n         );\n@@ -1708,10 +1703,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n             for (i, span) in spans.into_iter().enumerate() {\n                 let span = self.lazy(span);\n-                self.tables.proc_macro_quoted_spans.set(i, span);\n+                self.tables.proc_macro_quoted_spans.set_some(i, span);\n             }\n \n-            self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n+            self.tables.opt_def_kind.set_some(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n             let vis = tcx.local_visibility(CRATE_DEF_ID).map_id(|def_id| def_id.local_def_index);\n@@ -1753,8 +1748,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n-                self.tables.proc_macro.set(def_id.index, macro_kind);\n+                self.tables.opt_def_kind.set_some(def_id.index, DefKind::Macro(macro_kind));\n+                self.tables.proc_macro.set_some(def_id.index, macro_kind);\n                 self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n@@ -1969,7 +1964,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 Linkage::Static => Some(LinkagePreference::RequireStatic),\n             }));\n         }\n-        LazyArray::empty()\n+        LazyArray::default()\n     }\n \n     fn encode_info_for_foreign_item(&mut self, def_id: DefId, nitem: &hir::ForeignItem<'_>) {\n@@ -1979,22 +1974,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n-                self.tables.asyncness.set(def_id.index, hir::IsAsync::NotAsync);\n+                self.tables.asyncness.set_some(def_id.index, hir::IsAsync::NotAsync);\n                 record_array!(self.tables.fn_arg_names[def_id] <- *names);\n                 let constness = if self.tcx.is_const_fn_raw(def_id) {\n                     hir::Constness::Const\n                 } else {\n                     hir::Constness::NotConst\n                 };\n-                self.tables.constness.set(def_id.index, constness);\n+                self.tables.constness.set_some(def_id.index, constness);\n                 record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             }\n             hir::ForeignItemKind::Static(..) | hir::ForeignItemKind::Type => {}\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n-            if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n-            }\n+            self.tables.is_intrinsic.set(def_id.index, tcx.is_intrinsic(def_id));\n         }\n     }\n }"}, {"sha": "a74aa381d9eb829097c219163db4f04750a3d098", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -115,14 +115,16 @@ impl<T: ParameterizedOverTcx> ParameterizedOverTcx for LazyArray<T> {\n     type Value<'tcx> = LazyArray<T::Value<'tcx>>;\n }\n \n+impl<T> Default for LazyArray<T> {\n+    fn default() -> LazyArray<T> {\n+        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n+    }\n+}\n+\n impl<T> LazyArray<T> {\n     fn from_position_and_num_elems(position: NonZeroUsize, num_elems: usize) -> LazyArray<T> {\n         LazyArray { position, num_elems, _marker: PhantomData }\n     }\n-\n-    fn empty() -> LazyArray<T> {\n-        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n-    }\n }\n \n /// A list of lazily-decoded values, with the added capability of random access.\n@@ -316,7 +318,7 @@ pub(crate) struct IncoherentImpls {\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     (\n-        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - defaulted: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n         - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n     ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n@@ -343,11 +345,15 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-- nullable:\n+- defaulted:\n     is_intrinsic: Table<DefIndex, bool>,\n     is_macro_rules: Table<DefIndex, bool>,\n     is_type_alias_impl_trait: Table<DefIndex, bool>,\n     attr_flags: Table<DefIndex, AttrFlags>,\n+    def_path_hashes: Table<DefIndex, DefPathHash>,\n+    explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n+    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n+    inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n@@ -360,12 +366,8 @@ define_tables! {\n     lookup_const_stability: Table<DefIndex, LazyValue<attr::ConstStability>>,\n     lookup_default_body_stability: Table<DefIndex, LazyValue<attr::DefaultBodyStability>>,\n     lookup_deprecation_entry: Table<DefIndex, LazyValue<attr::Deprecation>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n     explicit_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     generics_of: Table<DefIndex, LazyValue<ty::Generics>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     super_predicates_of: Table<DefIndex, LazyValue<ty::GenericPredicates<'static>>>,\n     type_of: Table<DefIndex, LazyValue<Ty<'static>>>,\n     variances_of: Table<DefIndex, LazyArray<ty::Variance>>,\n@@ -393,7 +395,6 @@ define_tables! {\n     generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n-    inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n     unused_generic_params: Table<DefIndex, LazyValue<UnusedGenericParams>>,\n     params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n@@ -403,7 +404,6 @@ define_tables! {\n     // `DefPathTable` up front, since we may only ever use a few\n     // definitions from any given crate.\n     def_keys: Table<DefIndex, LazyValue<DefKey>>,\n-    def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,"}, {"sha": "99bec570600a0faae76c4afb1479ce834e1702c1", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 122, "deletions": 38, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -10,11 +10,51 @@ use rustc_span::hygiene::MacroKind;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+pub(super) trait IsDefault: Default {\n+    fn is_default(&self) -> bool;\n+}\n+\n+impl<T> IsDefault for Option<T> {\n+    fn is_default(&self) -> bool {\n+        self.is_none()\n+    }\n+}\n+\n+impl IsDefault for AttrFlags {\n+    fn is_default(&self) -> bool {\n+        self.is_empty()\n+    }\n+}\n+\n+impl IsDefault for bool {\n+    fn is_default(&self) -> bool {\n+        !self\n+    }\n+}\n+\n+impl IsDefault for u32 {\n+    fn is_default(&self) -> bool {\n+        *self == 0\n+    }\n+}\n+\n+impl<T> IsDefault for LazyArray<T> {\n+    fn is_default(&self) -> bool {\n+        self.num_elems == 0\n+    }\n+}\n+\n+impl IsDefault for DefPathHash {\n+    fn is_default(&self) -> bool {\n+        self.0 == Fingerprint::ZERO\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-pub(super) trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: IsDefault {\n     /// This should be `[u8; BYTE_LEN]`;\n     /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n@@ -23,6 +63,8 @@ pub(super) trait FixedSizeEncoding: Default {\n     fn write_to_bytes(self, b: &mut Self::ByteArray);\n }\n \n+/// This implementation is not used generically, but for reading/writing\n+/// concrete `u32` fields in `Lazy*` structures, which may be zero.\n impl FixedSizeEncoding for u32 {\n     type ByteArray = [u8; 4];\n \n@@ -58,7 +100,7 @@ macro_rules! fixed_size_enum {\n             fn write_to_bytes(self, b: &mut [u8;1]) {\n                 use $ty::*;\n                 b[0] = match self {\n-                    None => 0,\n+                    None => unreachable!(),\n                     $(Some($($pat)*) => 1 + ${index()},)*\n                 }\n             }\n@@ -155,20 +197,18 @@ fixed_size_enum! {\n }\n \n // We directly encode `DefPathHash` because a `LazyValue` would incur a 25% cost.\n-impl FixedSizeEncoding for Option<DefPathHash> {\n+impl FixedSizeEncoding for DefPathHash {\n     type ByteArray = [u8; 16];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 16]) -> Self {\n-        Some(DefPathHash(Fingerprint::from_le_bytes(*b)))\n+        DefPathHash(Fingerprint::from_le_bytes(*b))\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 16]) {\n-        let Some(DefPathHash(fingerprint)) = self else {\n-            panic!(\"Trying to encode absent DefPathHash.\")\n-        };\n-        *b = fingerprint.to_le_bytes();\n+        debug_assert!(!self.is_default());\n+        *b = self.0.to_le_bytes();\n     }\n }\n \n@@ -179,17 +219,17 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n         let krate = u32::from_le_bytes(b[0..4].try_into().unwrap());\n-        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         if krate == 0 {\n             return None;\n         }\n+        let index = u32::from_le_bytes(b[4..8].try_into().unwrap());\n         Some(RawDefId { krate: krate - 1, index })\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n         match self {\n-            None => *b = [0; 8],\n+            None => unreachable!(),\n             Some(RawDefId { krate, index }) => {\n                 // CrateNum is less than `CrateNum::MAX_AS_U32`.\n                 debug_assert!(krate < u32::MAX);\n@@ -210,6 +250,7 @@ impl FixedSizeEncoding for AttrFlags {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self.bits();\n     }\n }\n@@ -224,6 +265,7 @@ impl FixedSizeEncoding for bool {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        debug_assert!(!self.is_default());\n         b[0] = self as u8\n     }\n }\n@@ -242,34 +284,72 @@ impl<T> FixedSizeEncoding for Option<LazyValue<T>> {\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 4]) {\n-        let position = self.map_or(0, |lazy| lazy.position.get());\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => {\n+                let position = lazy.position.get();\n+                let position: u32 = position.try_into().unwrap();\n+                position.write_to_bytes(b)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> LazyArray<T> {\n+    #[inline]\n+    fn write_to_bytes_impl(self, b: &mut [u8; 8]) {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+\n+        let position = self.position.get();\n         let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(b)\n+        position.write_to_bytes(position_bytes);\n+\n+        let len = self.num_elems;\n+        let len: u32 = len.try_into().unwrap();\n+        len.write_to_bytes(meta_bytes);\n+    }\n+\n+    fn from_bytes_impl(position_bytes: &[u8; 4], meta_bytes: &[u8; 4]) -> Option<LazyArray<T>> {\n+        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n+        let len = u32::from_bytes(meta_bytes) as usize;\n+        Some(LazyArray::from_position_and_num_elems(position, len))\n     }\n }\n \n-impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n+impl<T> FixedSizeEncoding for LazyArray<T> {\n     type ByteArray = [u8; 8];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 8]) -> Self {\n-        let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n-        let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n-        let len = u32::from_bytes(meta_bytes) as usize;\n-        Some(LazyArray::from_position_and_num_elems(position, len))\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        if *meta_bytes == [0; 4] {\n+            return Default::default();\n+        }\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes).unwrap()\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 8]) {\n-        let ([ref mut position_bytes, ref mut meta_bytes],[])= b.as_chunks_mut::<4>() else { panic!() };\n+        assert!(!self.is_default());\n+        self.write_to_bytes_impl(b)\n+    }\n+}\n \n-        let position = self.map_or(0, |lazy| lazy.position.get());\n-        let position: u32 = position.try_into().unwrap();\n-        position.write_to_bytes(position_bytes);\n+impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n+    type ByteArray = [u8; 8];\n \n-        let len = self.map_or(0, |lazy| lazy.num_elems);\n-        let len: u32 = len.try_into().unwrap();\n-        len.write_to_bytes(meta_bytes);\n+    #[inline]\n+    fn from_bytes(b: &[u8; 8]) -> Self {\n+        let ([position_bytes, meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n+        LazyArray::from_bytes_impl(position_bytes, meta_bytes)\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 8]) {\n+        match self {\n+            None => unreachable!(),\n+            Some(lazy) => lazy.write_to_bytes_impl(b),\n+        }\n     }\n }\n \n@@ -289,20 +369,27 @@ impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n     Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set(&mut self, i: I, value: T) {\n-        self.set_nullable(i, Some(value))\n+    pub(crate) fn set_some(&mut self, i: I, value: T) {\n+        self.set(i, Some(value))\n     }\n }\n \n impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n-    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n-        // FIXME(eddyb) investigate more compact encodings for sparse tables.\n-        // On the PR @michaelwoerister mentioned:\n-        // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n-        // > trick (i.e. divide things into buckets of 32 or 64 items and then\n-        // > store bit-masks of which item in each bucket is actually serialized).\n-        self.blocks.ensure_contains_elem(i, || [0; N]);\n-        value.write_to_bytes(&mut self.blocks[i]);\n+    /// Sets the table value if it is not default.\n+    /// ATTENTION: For optimization default values are simply ignored by this function, because\n+    /// right now metadata tables never need to reset non-default values to default. If such need\n+    /// arises in the future then a new method (e.g. `clear` or `reset`) will need to be introduced\n+    /// for doing that explicitly.\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        if !value.is_default() {\n+            // FIXME(eddyb) investigate more compact encodings for sparse tables.\n+            // On the PR @michaelwoerister mentioned:\n+            // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n+            // > trick (i.e. divide things into buckets of 32 or 64 items and then\n+            // > store bit-masks of which item in each bucket is actually serialized).\n+            self.blocks.ensure_contains_elem(i, || [0; N]);\n+            value.write_to_bytes(&mut self.blocks[i]);\n+        }\n     }\n \n     pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n@@ -331,10 +418,7 @@ where\n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        match bytes.get(i.index()) {\n-            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n-            None => FixedSizeEncoding::from_bytes(&[0; N]),\n-        }\n+        bytes.get(i.index()).map_or_else(Default::default, FixedSizeEncoding::from_bytes)\n     }\n \n     /// Size of the table in entries, including possible gaps."}, {"sha": "cdda052f529067a27f4c82d49c04bef4a8d7df6e", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -119,6 +119,12 @@ impl DefPathHash {\n     }\n }\n \n+impl Default for DefPathHash {\n+    fn default() -> Self {\n+        DefPathHash(Fingerprint::ZERO)\n+    }\n+}\n+\n impl Borrow<Fingerprint> for DefPathHash {\n     #[inline]\n     fn borrow(&self) -> &Fingerprint {"}, {"sha": "a6e0f13f69830350d8c55611c635841edc461212", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35d6d70a64d8db139a700ccfdb31824bbf4ba350/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=35d6d70a64d8db139a700ccfdb31824bbf4ba350", "patch": "@@ -22,14 +22,17 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n         hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n             impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n         ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n     }\n }\n \n fn associated_items(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItems<'_> {\n-    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n-    ty::AssocItems::new(items)\n+    if tcx.is_trait_alias(def_id) {\n+        ty::AssocItems::new(Vec::new())\n+    } else {\n+        let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n+        ty::AssocItems::new(items)\n+    }\n }\n \n fn impl_item_implementor_ids(tcx: TyCtxt<'_>, impl_id: DefId) -> FxHashMap<DefId, DefId> {"}]}