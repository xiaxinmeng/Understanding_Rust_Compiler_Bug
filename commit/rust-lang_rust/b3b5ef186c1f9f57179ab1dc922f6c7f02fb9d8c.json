{"sha": "b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYjVlZjE4NmMxZjlmNTcxNzlhYjFkYzkyMmY2YzdmMDJmYjlkOGM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-19T00:54:56Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:50:49Z"}, "message": "Remove more duplicated spans", "tree": {"sha": "b1be4e0b78828bf22a53633640c69badda4be0fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1be4e0b78828bf22a53633640c69badda4be0fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "html_url": "https://github.com/rust-lang/rust/commit/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62000c072e850f0a102db2b22e08b12d82e3c475", "url": "https://api.github.com/repos/rust-lang/rust/commits/62000c072e850f0a102db2b22e08b12d82e3c475", "html_url": "https://github.com/rust-lang/rust/commit/62000c072e850f0a102db2b22e08b12d82e3c475"}], "stats": {"total": 381, "additions": 181, "deletions": 200}, "files": [{"sha": "32697e46a08ac58787543402d0767f3ea72bf8bd", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -1099,13 +1099,15 @@ impl TokenTree {\n             self::TokenTree::Term(tt) => {\n                 let ident = ast::Ident::new(tt.sym, tt.span.0);\n                 let sym_str = tt.sym.as_str();\n-                let token =\n-                    if sym_str.starts_with(\"'\") { Lifetime(ident) }\n-                    else if sym_str.starts_with(\"r#\") {\n-                        let name = Symbol::intern(&sym_str[2..]);\n-                        let ident = ast::Ident { name, ctxt: tt.span.0.ctxt() };\n-                        Ident(ident, true)\n-                    } else { Ident(ident, false) };\n+                let token = if sym_str.starts_with(\"'\") {\n+                    Lifetime(ident)\n+                } else if sym_str.starts_with(\"r#\") {\n+                    let name = Symbol::intern(&sym_str[2..]);\n+                    let ident = ast::Ident::new(name, ident.span);\n+                    Ident(ident, true)\n+                } else {\n+                    Ident(ident, false)\n+                };\n                 return TokenTree::Token(tt.span.0, token).into();\n             }\n             self::TokenTree::Literal(self::Literal {"}, {"sha": "ec2aeed8ad8c45681df5bd2dfadba3fc410523de", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -920,7 +920,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n         label.map(|label| hir::Label {\n             name: label.ident.name,\n-            span: label.span,\n+            span: label.ident.span,\n         })\n     }\n \n@@ -1810,7 +1810,7 @@ impl<'a> LoweringContext<'a> {\n             default: tp.default\n                 .as_ref()\n                 .map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n-            span: tp.span,\n+            span: tp.ident.span,\n             pure_wrt_drop: attr::contains_name(&tp.attrs, \"may_dangle\"),\n             synthetic: tp.attrs\n                 .iter()\n@@ -1822,21 +1822,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n+        let span = l.ident.span;\n         match self.lower_ident(l.ident) {\n-            x if x == \"'static\" => self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Static),\n+            x if x == \"'static\" => self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n             x if x == \"'_\" => match self.anonymous_lifetime_mode {\n                 AnonymousLifetimeMode::CreateParameter => {\n-                    let fresh_name = self.collect_fresh_in_band_lifetime(l.span);\n-                    self.new_named_lifetime(l.id, l.span, fresh_name)\n+                    let fresh_name = self.collect_fresh_in_band_lifetime(span);\n+                    self.new_named_lifetime(l.id, span, fresh_name)\n                 }\n \n                 AnonymousLifetimeMode::PassThrough => {\n-                    self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Underscore)\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n                 }\n             },\n             name => {\n-                self.maybe_collect_in_band_lifetime(l.span, name);\n-                self.new_named_lifetime(l.id, l.span, hir::LifetimeName::Name(name))\n+                self.maybe_collect_in_band_lifetime(span, name);\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Name(name))\n             }\n         }\n     }\n@@ -2936,7 +2937,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed,\n                 );\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(hir_seg, seg.span, args)\n+                hir::ExprMethodCall(hir_seg, seg.ident.span, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);"}, {"sha": "4bd857c73e6cf6d50e73961d5b90542d2028e3d8", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -202,15 +202,15 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     lifetime_def.lifetime.id,\n                     DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_str()),\n                     REGULAR_SPACE,\n-                    lifetime_def.lifetime.span\n+                    lifetime_def.lifetime.ident.span\n                 );\n             }\n             GenericParam::Type(ref ty_param) => {\n                 self.create_def(\n                     ty_param.id,\n                     DefPathData::TypeParam(ty_param.ident.name.as_str()),\n                     REGULAR_SPACE,\n-                    ty_param.span\n+                    ty_param.ident.span\n                 );\n             }\n         }"}, {"sha": "f58300fd90ff2b8af291888adf91da7bb6be3dfc", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -162,7 +162,7 @@ impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });\n-impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n+impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n "}, {"sha": "9f8cc2f86992f54ffa5d73f15be5cf2c5a10cab9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -952,8 +952,8 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n         ast_visit::walk_ty(self, t);\n     }\n \n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n-        run_lints!(self, check_ident, early_passes, sp, id);\n+    fn visit_ident(&mut self, ident: ast::Ident) {\n+        run_lints!(self, check_ident, early_passes, ident);\n     }\n \n     fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {"}, {"sha": "89a9f3034787b8ed61eeec8a11e54274b86cdc69", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -236,7 +236,7 @@ pub trait LateLintPass<'a, 'tcx>: LintPass {\n }\n \n pub trait EarlyLintPass: LintPass {\n-    fn check_ident(&mut self, _: &EarlyContext, _: Span, _: ast::Ident) { }\n+    fn check_ident(&mut self, _: &EarlyContext, _: ast::Ident) { }\n     fn check_crate(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n     fn check_crate_post(&mut self, _: &EarlyContext, _: &ast::Crate) { }\n     fn check_mod(&mut self, _: &EarlyContext, _: &ast::Mod, _: Span, _: ast::NodeId) { }"}, {"sha": "1866122454c7057cab50c8511a3a1d2775512a0a", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -36,19 +36,20 @@ impl<'a> AstValidator<'a> {\n         &self.session.parse_sess.span_diagnostic\n     }\n \n-    fn check_lifetime(&self, lifetime: &Lifetime) {\n+    fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [keywords::UnderscoreLifetime.name(),\n                            keywords::StaticLifetime.name(),\n                            keywords::Invalid.name()];\n-        if !valid_names.contains(&lifetime.ident.name) &&\n-            token::is_reserved_ident(lifetime.ident.without_first_quote()) {\n-            self.err_handler().span_err(lifetime.span, \"lifetimes cannot use keyword names\");\n+        if !valid_names.contains(&ident.name) &&\n+            token::is_reserved_ident(ident.without_first_quote()) {\n+            self.err_handler().span_err(ident.span, \"lifetimes cannot use keyword names\");\n         }\n     }\n \n-    fn check_label(&self, label: Ident, span: Span) {\n-        if token::is_reserved_ident(label.without_first_quote()) {\n-            self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n+    fn check_label(&self, ident: Ident) {\n+        if token::is_reserved_ident(ident.without_first_quote()) {\n+            self.err_handler()\n+                .span_err(ident.span, &format!(\"invalid label name `{}`\", ident.name));\n         }\n     }\n \n@@ -144,7 +145,7 @@ impl<'a> AstValidator<'a> {\n         let non_lifetime_param_spans : Vec<_> = params.iter()\n             .filter_map(|param| match *param {\n                 GenericParam::Lifetime(_) => None,\n-                GenericParam::Type(ref t) => Some(t.span),\n+                GenericParam::Type(ref t) => Some(t.ident.span),\n             }).collect();\n         if !non_lifetime_param_spans.is_empty() {\n             self.err_handler().span_err(non_lifetime_param_spans,\n@@ -156,7 +157,7 @@ impl<'a> AstValidator<'a> {\n             match *param {\n                 GenericParam::Lifetime(ref l) => {\n                     if !l.bounds.is_empty() {\n-                        let spans : Vec<_> = l.bounds.iter().map(|b| b.span).collect();\n+                        let spans: Vec<_> = l.bounds.iter().map(|b| b.ident.span).collect();\n                         self.err_handler().span_err(spans,\n                             \"lifetime bounds cannot be used in this context\");\n                     }\n@@ -193,7 +194,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 for bound in bounds {\n                     if let RegionTyParamBound(ref lifetime) = *bound {\n                         if any_lifetime_bounds {\n-                            span_err!(self.session, lifetime.span, E0226,\n+                            span_err!(self.session, lifetime.ident.span, E0226,\n                                       \"only a single explicit lifetime bound is permitted\");\n                             break;\n                         }\n@@ -234,12 +235,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_label(&mut self, label: &'a Label) {\n-        self.check_label(label.ident, label.span);\n+        self.check_label(label.ident);\n         visit::walk_label(self, label);\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'a Lifetime) {\n-        self.check_lifetime(lifetime);\n+        self.check_lifetime(lifetime.ident);\n         visit::walk_lifetime(self, lifetime);\n     }\n \n@@ -328,19 +329,19 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n                 for param in params {\n                     if let GenericParam::Type(TyParam {\n+                        ident,\n                         ref bounds,\n                         ref default,\n-                        span,\n                         ..\n                     }) = *param\n                     {\n                         if !bounds.is_empty() {\n-                            self.err_handler().span_err(span,\n+                            self.err_handler().span_err(ident.span,\n                                                         \"type parameters on the left side of a \\\n                                                          trait alias cannot be bounded\");\n                         }\n                         if !default.is_none() {\n-                            self.err_handler().span_err(span,\n+                            self.err_handler().span_err(ident.span,\n                                                         \"type parameters on the left side of a \\\n                                                          trait alias cannot have defaults\");\n                         }\n@@ -408,7 +409,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match (param, seen_non_lifetime_param) {\n                 (&GenericParam::Lifetime(ref ld), true) => {\n                     self.err_handler()\n-                        .span_err(ld.lifetime.span, \"lifetime parameters must be leading\");\n+                        .span_err(ld.lifetime.ident.span, \"lifetime parameters must be leading\");\n                 },\n                 (&GenericParam::Lifetime(_), false) => {}\n                 _ => {\n@@ -417,7 +418,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n \n             if let GenericParam::Type(ref ty_param @ TyParam { default: Some(_), .. }) = *param {\n-                seen_default = Some(ty_param.span);\n+                seen_default = Some(ty_param.ident.span);\n             } else if let Some(span) = seen_default {\n                 self.err_handler()\n                     .span_err(span, \"type parameters with a default must be trailing\");"}, {"sha": "b95b7deab48300de8e480421e5dcde6addcc9974", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -195,7 +195,7 @@ impl<'a> Resolver<'a> {\n             ast::UseTreeKind::Nested(ref items) => {\n                 let prefix = ast::Path {\n                     segments: module_path.into_iter()\n-                        .map(|ident| ast::PathSegment::from_ident(ident, ident.span))\n+                        .map(|ident| ast::PathSegment::from_ident(ident))\n                         .collect(),\n                     span: path.span,\n                 };"}, {"sha": "2bf17cd1317d449d4fcc5d20200ebdda9d30a57b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -2281,9 +2281,9 @@ impl<'a> Resolver<'a> {\n                                 ident.name,\n                                 span,\n                             );\n-                            resolve_error(self, type_parameter.span, err);\n+                            resolve_error(self, type_parameter.ident.span, err);\n                         }\n-                        seen_bindings.entry(ident).or_insert(type_parameter.span);\n+                        seen_bindings.entry(ident).or_insert(type_parameter.ident.span);\n \n                         // plain insert (no renaming)\n                         let def_id = self.definitions.local_def_id(type_parameter.id);\n@@ -3634,7 +3634,7 @@ impl<'a> Resolver<'a> {\n                         });\n                         self.record_def(expr.id, err_path_resolution());\n                         resolve_error(self,\n-                                      label.span,\n+                                      label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.name.as_str(),\n                                                                        close_match));\n                     }\n@@ -3865,7 +3865,7 @@ impl<'a> Resolver<'a> {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n                         let mut segms = path_segments.clone();\n-                        segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                        segms.push(ast::PathSegment::from_ident(ident));\n                         let path = Path {\n                             span: name_binding.span,\n                             segments: segms,\n@@ -3887,7 +3887,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3926,7 +3926,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n                     if module.def() == Some(module_def) {\n                         let path = Path {\n                             span: name_binding.span,\n@@ -3958,7 +3958,7 @@ impl<'a> Resolver<'a> {\n             enum_module.for_each_child_stable(|ident, _, name_binding| {\n                 if let Def::Variant(..) = name_binding.def() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident, name_binding.span));\n+                    segms.push(ast::PathSegment::from_ident(ident));\n                     variants.push(Path {\n                         span: name_binding.span,\n                         segments: segms,"}, {"sha": "0388465b485cb5527727dc50045c16db5ed16351", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -141,10 +141,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     path.segments[0].ident.name = keywords::CrateRoot.name();\n                     let module = self.0.resolve_crate_root(ident.span.ctxt(), true);\n                     if !module.is_local() {\n-                        let span = path.segments[0].span;\n+                        let span = path.segments[0].ident.span;\n                         path.segments.insert(1, match module.kind {\n                             ModuleKind::Def(_, name) => ast::PathSegment::from_ident(\n-                                ast::Ident::with_empty_ctxt(name), span\n+                                ast::Ident::with_empty_ctxt(name).with_span_pos(span)\n                             ),\n                             _ => unreachable!(),\n                         })\n@@ -277,7 +277,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                         }).into();\n                     }\n                     return Some(ast::Attribute {\n-                        path: ast::Path::from_ident(span, Ident::with_empty_ctxt(legacy_name)),\n+                        path: ast::Path::from_ident(Ident::new(legacy_name, span)),\n                         tokens: TokenStream::empty(),\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,"}, {"sha": "ed8904b34a214dd8180bedc133feef320aad1512", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -183,15 +183,15 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         for (i, seg) in segments.iter().enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n-                span: seg.span, // span for the last segment\n+                span: seg.ident.span, // span for the last segment\n                 segments: segs,\n             };\n             let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n             };\n-            result.push((seg.span, qualname));\n+            result.push((seg.ident.span, qualname));\n             segs = sub_path.segments;\n         }\n \n@@ -351,14 +351,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n \n-            for (id, i, sp, ..) in collector.collected_idents {\n+            for (id, ident, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                let sub_span = span_utils.span_for_last_ident(sp);\n-                if !self.span.filter_generated(sub_span, sp) {\n+                let sub_span = span_utils.span_for_last_ident(ident.span);\n+                if !self.span.filter_generated(sub_span, ident.span) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n@@ -371,8 +371,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                             kind: DefKind::Local,\n                             id,\n                             span,\n-                            name: i.to_string(),\n-                            qualname: format!(\"{}::{}\", qualname, i.to_string()),\n+                            name: ident.to_string(),\n+                            qualname: format!(\"{}::{}\", qualname, ident.to_string()),\n                             value: typ,\n                             parent: None,\n                             children: vec![],\n@@ -447,7 +447,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     ) {\n         for param in &generics.params {\n             if let ast::GenericParam::Type(ref ty_param) = *param {\n-                let param_ss = ty_param.span;\n+                let param_ss = ty_param.ident.span;\n                 let name = escape(self.span.snippet(param_ss));\n                 // Append $id to name to make sure each one is unique\n                 let qualname = format!(\"{}::{}${}\", prefix, name, id);\n@@ -1040,11 +1040,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n \n         // process collected paths\n-        for (id, i, sp, immut) in collector.collected_idents {\n+        for (id, ident, immut) in collector.collected_idents {\n             match self.save_ctxt.get_path_def(id) {\n                 HirDef::Local(id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(sp).to_string()\n+                        self.span.snippet(ident.span).to_string()\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n@@ -1057,10 +1057,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    if !self.span.filter_generated(Some(sp), sp) {\n-                        let qualname = format!(\"{}${}\", i.to_string(), id);\n+                    if !self.span.filter_generated(Some(ident.span), ident.span) {\n+                        let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(sp);\n+                        let span = self.span_from_span(ident.span);\n \n                         self.dumper.dump_def(\n                             &Access {\n@@ -1071,7 +1071,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                 kind: DefKind::Local,\n                                 id,\n                                 span,\n-                                name: i.to_string(),\n+                                name: ident.to_string(),\n                                 qualname,\n                                 value: typ,\n                                 parent: None,\n@@ -1093,7 +1093,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 HirDef::TyAlias(..) |\n                 HirDef::AssociatedTy(..) |\n                 HirDef::SelfTy(..) => {\n-                    self.dump_path_ref(id, &ast::Path::from_ident(sp, i));\n+                    self.dump_path_ref(id, &ast::Path::from_ident(ident));\n                 }\n                 def => error!(\n                     \"unexpected definition kind when processing collected idents: {:?}\",\n@@ -1114,7 +1114,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         collector.visit_pat(&p);\n         self.visit_pat(&p);\n \n-        for (id, i, sp, immut) in collector.collected_idents {\n+        for (id, ident, immut) in collector.collected_idents {\n             let mut value = match immut {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n@@ -1134,10 +1134,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(sp);\n+            let sub_span = self.span.span_for_last_ident(ident.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, sp) {\n-                let qualname = format!(\"{}${}\", i.to_string(), id);\n+            if !self.span.filter_generated(sub_span, ident.span) {\n+                let qualname = format!(\"{}${}\", ident.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n@@ -1150,7 +1150,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         kind: DefKind::Local,\n                         id,\n                         span,\n-                        name: i.to_string(),\n+                        name: ident.to_string(),\n                         qualname,\n                         value: typ,\n                         parent: None,"}, {"sha": "4f46fb3545b15833f314e6d8ae1dda38067ac28a", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -603,7 +603,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n                 };\n-                let sub_span = seg.span;\n+                let sub_span = seg.ident.span;\n                 filter!(self.span_utils, Some(sub_span), expr.span, None);\n                 let span = self.span_from_span(sub_span);\n                 Some(Data::RefData(Ref {\n@@ -707,7 +707,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let def = self.get_path_def(id);\n         let last_seg = &path.segments[path.segments.len() - 1];\n-        let sub_span = last_seg.span;\n+        let sub_span = last_seg.ident.span;\n         filter!(self.span_utils, Some(sub_span), path.span, None);\n         match def {\n             HirDef::Upvar(id, ..) | HirDef::Local(id) => {\n@@ -961,7 +961,7 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n // variables (idents) from patterns.\n struct PathCollector<'l> {\n     collected_paths: Vec<(NodeId, &'l ast::Path)>,\n-    collected_idents: Vec<(NodeId, ast::Ident, Span, ast::Mutability)>,\n+    collected_idents: Vec<(NodeId, ast::Ident, ast::Mutability)>,\n }\n \n impl<'l> PathCollector<'l> {\n@@ -997,7 +997,7 @@ impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n                 self.collected_idents\n-                    .push((p.id, ident, ident.span, immut));\n+                    .push((p.id, ident, immut));\n             }\n             _ => {}\n         }"}, {"sha": "b8f7d3db9fda63498651696acb800b8f560d1c16", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -1146,7 +1146,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment::from_ident(ast::Ident::from_str(path_str), DUMMY_SP);\n+    let segment = ast::PathSegment::from_ident(ast::Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();"}, {"sha": "e51702c2eb85f37da4ffc3a07fcb9e943a73702c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -36,7 +36,6 @@ use std::u32;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n     pub ident: Ident,\n-    pub span: Span,\n }\n \n impl fmt::Debug for Label {\n@@ -48,7 +47,6 @@ impl fmt::Debug for Label {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n-    pub span: Span,\n     pub ident: Ident,\n }\n \n@@ -101,11 +99,8 @@ impl fmt::Display for Path {\n impl Path {\n     // convert a span and an identifier to the corresponding\n     // 1-segment path\n-    pub fn from_ident(s: Span, ident: Ident) -> Path {\n-        Path {\n-            span: s,\n-            segments: vec![PathSegment::from_ident(ident, s)],\n-        }\n+    pub fn from_ident(ident: Ident) -> Path {\n+        Path { segments: vec![PathSegment::from_ident(ident)], span: ident.span }\n     }\n \n     // Make a \"crate root\" segment for this path unless it already has it\n@@ -132,8 +127,6 @@ impl Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n-    /// Span of the segment identifier.\n-    pub span: Span,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`.\n@@ -145,11 +138,11 @@ pub struct PathSegment {\n }\n \n impl PathSegment {\n-    pub fn from_ident(ident: Ident, span: Span) -> Self {\n-        PathSegment { ident, span, parameters: None }\n+    pub fn from_ident(ident: Ident) -> Self {\n+        PathSegment { ident, parameters: None }\n     }\n     pub fn crate_root(span: Span) -> Self {\n-        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span), span)\n+        PathSegment::from_ident(Ident::new(keywords::CrateRoot.name(), span))\n     }\n }\n \n@@ -293,7 +286,7 @@ impl TyParamBound {\n     pub fn span(&self) -> Span {\n         match self {\n             &TraitTyParamBound(ref t, ..) => t.span,\n-            &RegionTyParamBound(ref l) => l.span,\n+            &RegionTyParamBound(ref l) => l.ident.span,\n         }\n     }\n }\n@@ -315,7 +308,6 @@ pub struct TyParam {\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n-    pub span: Span,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -366,7 +358,7 @@ impl Generics {\n         for param in &self.params {\n             if let GenericParam::Type(ref t) = *param {\n                 if t.ident.name == name {\n-                    return Some(t.span);\n+                    return Some(t.ident.span);\n                 }\n             }\n         }\n@@ -541,7 +533,7 @@ impl Pat {\n         let node = match &self.node {\n             PatKind::Wild => TyKind::Infer,\n             PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None) =>\n-                TyKind::Path(None, Path::from_ident(ident.span, *ident)),\n+                TyKind::Path(None, Path::from_ident(*ident)),\n             PatKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             PatKind::Mac(mac) => TyKind::Mac(mac.clone()),\n             PatKind::Ref(pat, mutbl) =>"}, {"sha": "04232bf15bc0f5a4dff7e07db830854b0d7e2319", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -436,10 +436,11 @@ pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    let ident = ast::Ident::with_empty_ctxt(item.name).with_span_pos(item.span);\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        path: ast::Path::from_ident(ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -454,10 +455,11 @@ pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    let ident = ast::Ident::with_empty_ctxt(item.name).with_span_pos(item.span);\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(item.span, ast::Ident::with_empty_ctxt(item.name)),\n+        path: ast::Path::from_ident(ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -470,7 +472,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id,\n         style,\n-        path: ast::Path::from_ident(span, ast::Ident::from_str(\"doc\")),\n+        path: ast::Path::from_ident(ast::Ident::from_str(\"doc\").with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,"}, {"sha": "40d9d242ae6d9d19087d9f0fe175710225e42734", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -322,13 +322,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let last_ident = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = Vec::new();\n \n-        segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, span)));\n+        segments.extend(idents.into_iter().map(|ident| {\n+            ast::PathSegment::from_ident(ident.with_span_pos(span))\n+        }));\n         let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n             ast::AngleBracketedParameterData { lifetimes, types, bindings, span }.into()\n         } else {\n             None\n         };\n-        segments.push(ast::PathSegment { ident: last_ident, span, parameters });\n+        segments.push(ast::PathSegment { ident: last_ident.with_span_pos(span), parameters });\n         let mut path = ast::Path { span, segments };\n         if global {\n             if let Some(seg) = path.make_root() {\n@@ -366,7 +368,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         } else {\n             None\n         };\n-        path.segments.push(ast::PathSegment { ident, span: ident.span, parameters });\n+        path.segments.push(ast::PathSegment { ident, parameters });\n \n         (ast::QSelf {\n             ty: self_type,\n@@ -435,17 +437,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn typaram(&self,\n                span: Span,\n-               id: ast::Ident,\n+               ident: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n                bounds: ast::TyParamBounds,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n-            ident: id,\n+            ident: ident.with_span_pos(span),\n             id: ast::DUMMY_NODE_ID,\n             attrs: attrs.into(),\n             bounds,\n             default,\n-            span,\n         }\n     }\n \n@@ -469,7 +470,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n-        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, ident: ident }\n+        ast::Lifetime { id: ast::DUMMY_NODE_ID, ident: ident.with_span_pos(span) }\n     }\n \n     fn lifetime_def(&self,\n@@ -662,7 +663,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         args.insert(0, expr);\n-        self.expr(span, ast::ExprKind::MethodCall(ast::PathSegment::from_ident(ident, span), args))\n+        let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n+        self.expr(span, ast::ExprKind::MethodCall(segment, args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b))"}, {"sha": "3303955d398a64375035a3223ace0c1ba6347e1f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -193,7 +193,7 @@ pub mod rt {\n \n     impl ToTokens for ast::Lifetime {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(DUMMY_SP, token::Lifetime(self.ident))]\n+            vec![TokenTree::Token(self.ident.span, token::Lifetime(self.ident))]\n         }\n     }\n "}, {"sha": "cd2fc0eabd052962ef9a2fbf34cc9689fa653827", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -823,7 +823,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n         \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        \"ident\" => if let Some((ident, is_raw))) = get_macro_ident(&p.token) {\n+        \"ident\" => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n             let span = p.span;\n             p.bump();\n             token::NtIdent(Ident::new(ident.name, span), is_raw)"}, {"sha": "ffe68289d5224be79aa5cb086791919d07b08abc", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -53,7 +53,7 @@ impl<'a> ParserAnyMacro<'a> {\n         }\n \n         // Make sure we don't have any tokens left to parse so we don't silently drop anything.\n-        let path = ast::Path::from_ident(site_span, macro_ident);\n+        let path = ast::Path::from_ident(macro_ident.with_span_pos(site_span));\n         parser.ensure_complete_parse(&path, kind.name(), site_span);\n         expansion\n     }"}, {"sha": "b55a268800fabd0ee5a92a45d80bbe825f777b53", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -1767,10 +1767,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_path(&mut self, path: &'a ast::Path, _id: NodeId) {\n         for segment in &path.segments {\n             if segment.ident.name == keywords::Crate.name() {\n-                gate_feature_post!(&self, crate_in_paths, segment.span,\n+                gate_feature_post!(&self, crate_in_paths, segment.ident.span,\n                                    \"`crate` in paths is experimental\");\n             } else if segment.ident.name == keywords::Extern.name() {\n-                gate_feature_post!(&self, extern_in_paths, segment.span,\n+                gate_feature_post!(&self, extern_in_paths, segment.ident.span,\n                                    \"`extern` in paths is experimental\");\n             }\n         }"}, {"sha": "745ff76de085d6e44087017425ca7a459305d8ee", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -449,9 +449,8 @@ pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n \n pub fn noop_fold_path<T: Folder>(Path { segments, span }: Path, fld: &mut T) -> Path {\n     Path {\n-        segments: segments.move_map(|PathSegment {ident, span, parameters}| PathSegment {\n+        segments: segments.move_map(|PathSegment {ident, parameters}| PathSegment {\n             ident: fld.fold_ident(ident),\n-            span: fld.new_span(span),\n             parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)\n@@ -679,7 +678,7 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n }\n \n pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {attrs, id, ident, bounds, default, span} = tp;\n+    let TyParam {attrs, id, ident, bounds, default} = tp;\n     let attrs: Vec<_> = attrs.into();\n     TyParam {\n         attrs: attrs.into_iter()\n@@ -690,7 +689,6 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n         ident: fld.fold_ident(ident),\n         bounds: fld.fold_bounds(bounds),\n         default: default.map(|x| fld.fold_ty(x)),\n-        span: fld.new_span(span),\n     }\n }\n \n@@ -711,15 +709,13 @@ pub fn noop_fold_generic_params<T: Folder>(\n pub fn noop_fold_label<T: Folder>(label: Label, fld: &mut T) -> Label {\n     Label {\n         ident: fld.fold_ident(label.ident),\n-        span: fld.new_span(label.span),\n     }\n }\n \n pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         ident: fld.fold_ident(l.ident),\n-        span: fld.new_span(l.span)\n     }\n }\n \n@@ -1194,7 +1190,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 ExprKind::MethodCall(\n                     PathSegment {\n                         ident: folder.fold_ident(seg.ident),\n-                        span: folder.new_span(seg.span),\n                         parameters: seg.parameters.map(|ps| {\n                             ps.map(|ps| folder.fold_path_parameters(ps))\n                         }),"}, {"sha": "6f0e382c047240592ca873ceb22ec9f06f097a33", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -149,7 +149,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (ast::Path::from_ident(meta.span, ast::Ident::with_empty_ctxt(meta.name)),\n+            (ast::Path::from_ident(ast::Ident::with_empty_ctxt(meta.name).with_span_pos(meta.span)),\n              meta.node.tokens(meta.span))\n         } else {\n             (self.parse_path(PathStyle::Mod)?, self.parse_tokens())"}, {"sha": "428b3b136df76edb2c51a507d130db258fd9a355", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -689,7 +689,7 @@ mod tests {\n     }\n \n     fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {\n-        ast::PathSegment::from_ident(Ident::from_str(s), sp(lo, hi))\n+        ast::PathSegment::from_ident(Ident::new(Symbol::intern(s), sp(lo, hi)))\n     }\n \n     #[test] fn path_exprs_1() {"}, {"sha": "72c1b52ba03a0fc589a1f3fd61ec0eb7d0ce3dae", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -1317,19 +1317,6 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern) && self.is_extern_non_path()\n     }\n \n-    fn eat_label(&mut self) -> Option<Label> {\n-        let ident = match self.token {\n-            token::Lifetime(ident) => ident,\n-            token::Interpolated(ref nt) => match nt.0 {\n-                token::NtLifetime(lifetime) => lifetime.ident,\n-                _ => return None,\n-            },\n-            _ => return None,\n-        };\n-        self.bump();\n-        Some(Label { ident, span: self.prev_span })\n-    }\n-\n     /// parse a TyKind::BareFn type:\n     pub fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>)\n                             -> PResult<'a, TyKind> {\n@@ -1979,7 +1966,7 @@ impl<'a> Parser<'a> {\n         };\n         if let Some(ident) = meta_ident {\n             self.bump();\n-            return Ok(ast::Path::from_ident(self.prev_span, ident));\n+            return Ok(ast::Path::from_ident(ident.with_span_pos(self.prev_span)));\n         }\n         self.parse_path(style)\n     }\n@@ -2047,10 +2034,10 @@ impl<'a> Parser<'a> {\n                 ParenthesizedParameterData { inputs, output, span }.into()\n             };\n \n-            PathSegment { ident, span: ident.span, parameters }\n+            PathSegment { ident, parameters }\n         } else {\n             // Generic arguments are not found.\n-            PathSegment::from_ident(ident, ident.span)\n+            PathSegment::from_ident(ident)\n         })\n     }\n \n@@ -2061,14 +2048,23 @@ impl<'a> Parser<'a> {\n \n     /// Parse single lifetime 'a or panic.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n-        if let Some(lifetime) = self.token.lifetime(self.span) {\n+        if let Some(lifetime) = self.token.lifetime2(self.span) {\n             self.bump();\n             lifetime\n         } else {\n             self.span_bug(self.span, \"not a lifetime\")\n         }\n     }\n \n+    fn eat_label(&mut self) -> Option<Label> {\n+        if let Some(lifetime) = self.token.lifetime2(self.span) {\n+            self.bump();\n+            Some(Label { ident: lifetime.ident })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Parse mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(keywords::Mut) {\n@@ -2101,7 +2097,7 @@ impl<'a> Parser<'a> {\n             let fieldname = self.parse_ident_common(false)?;\n \n             // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(fieldname.span, fieldname);\n+            let path = ast::Path::from_ident(fieldname);\n             let expr = self.mk_expr(fieldname.span, ExprKind::Path(None, path), ThinVec::new());\n             (fieldname, expr, true)\n         };\n@@ -2312,7 +2308,7 @@ impl<'a> Parser<'a> {\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if let Some(label) = self.eat_label() {\n-                    let lo = label.span;\n+                    let lo = label.ident.span;\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n                         return self.parse_while_expr(Some(label), lo, attrs)\n@@ -4689,7 +4685,6 @@ impl<'a> Parser<'a> {\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n-        let span = self.span;\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n@@ -4711,15 +4706,13 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             bounds,\n             default,\n-            span,\n         })\n     }\n \n     /// Parses the following grammar:\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [TyParamBounds]] [\"where\" ...] [\"=\" Ty]\n     fn parse_trait_item_assoc_ty(&mut self, preceding_attrs: Vec<Attribute>)\n         -> PResult<'a, (ast::Generics, TyParam)> {\n-        let span = self.span;\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -4744,7 +4737,6 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             bounds,\n             default,\n-            span,\n         }))\n     }\n \n@@ -5555,7 +5547,7 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, path) => path,\n                     _ => {\n                         self.span_err(ty_first.span, \"expected a trait, found type\");\n-                        ast::Path::from_ident(ty_first.span, keywords::Invalid.ident())\n+                        ast::Path::from_ident(Ident::new(keywords::Invalid.name(), ty_first.span))\n                     }\n                 };\n                 let trait_ref = TraitRef { path, ref_id: ty_first.id };\n@@ -5940,8 +5932,7 @@ impl<'a> Parser<'a> {\n                     let attr = Attribute {\n                         id: attr::mk_attr_id(),\n                         style: ast::AttrStyle::Outer,\n-                        path: ast::Path::from_ident(syntax_pos::DUMMY_SP,\n-                                                    Ident::from_str(\"warn_directory_ownership\")),\n+                        path: ast::Path::from_ident(Ident::from_str(\"warn_directory_ownership\")),\n                         tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n                         span: syntax_pos::DUMMY_SP,"}, {"sha": "c1049beea9f3240e347b90dd4d5ddb5706cdfa6b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -362,10 +362,10 @@ impl Token {\n     /// Returns a lifetime with the span and a dummy id if it is a lifetime,\n     /// or the original lifetime if it is an interpolated lifetime, ignoring\n     /// the span.\n-    pub fn lifetime(&self, span: Span) -> Option<ast::Lifetime> {\n+    pub fn lifetime2(&self, span: Span) -> Option<ast::Lifetime> {\n         match *self {\n-            Lifetime(ident) =>\n-                Some(ast::Lifetime { ident: ident, span: span, id: ast::DUMMY_NODE_ID }),\n+            Lifetime(ident) => Some(ast::Lifetime { id: ast::DUMMY_NODE_ID,\n+                                                    ident: ast::Ident::new(ident.name, span) }),\n             Interpolated(ref nt) => match nt.0 {\n                 NtLifetime(lifetime) => Some(lifetime),\n                 _ => None,\n@@ -376,7 +376,7 @@ impl Token {\n \n     /// Returns `true` if the token is a lifetime.\n     pub fn is_lifetime(&self) -> bool {\n-        self.lifetime(syntax_pos::DUMMY_SP).is_some()\n+        self.lifetime2(syntax_pos::DUMMY_SP).is_some()\n     }\n \n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n@@ -544,7 +544,7 @@ impl Token {\n             }\n             Nonterminal::NtLifetime(lifetime) => {\n                 let token = Token::Lifetime(lifetime.ident);\n-                tokens = Some(TokenTree::Token(lifetime.span, token).into());\n+                tokens = Some(TokenTree::Token(lifetime.ident.span, token).into());\n             }\n             Nonterminal::NtTT(ref tt) => {\n                 tokens = Some(tt.clone().into());"}, {"sha": "8ef2471318813383b198fe69361de27afc1e2fcf", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -70,7 +70,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n             style: ast::AttrStyle::Outer,\n-            path: ast::Path::from_ident(span, ast::Ident::from_str(\"prelude_import\")),\n+            path: ast::Path::from_ident(ast::Ident::new(Symbol::intern(\"prelude_import\"), span)),\n             tokens: TokenStream::empty(),\n             id: attr::mk_attr_id(),\n             is_sugared_doc: false,\n@@ -80,7 +80,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n         node: ast::ItemKind::Use(P(ast::UseTree {\n             prefix: ast::Path {\n                 segments: [name, \"prelude\", \"v1\"].into_iter().map(|name| {\n-                    ast::PathSegment::from_ident(ast::Ident::from_str(name), DUMMY_SP)\n+                    ast::PathSegment::from_ident(ast::Ident::from_str(name))\n                 }).collect(),\n                 span,\n             },"}, {"sha": "308b53c1a38a26352c2a0939f99278d4a7dddb8c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -623,7 +623,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n-        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id, DUMMY_SP)).collect(),\n+        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id)).collect(),\n     }\n }\n "}, {"sha": "d4c6b4b158b25dc2590063e1e04d6e0cced892c7", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -27,9 +27,9 @@ impl NodeCounter {\n }\n \n impl<'ast> Visitor<'ast> for NodeCounter {\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n+    fn visit_ident(&mut self, ident: Ident) {\n         self.count += 1;\n-        walk_ident(self, span, ident);\n+        walk_ident(self, ident);\n     }\n     fn visit_mod(&mut self, m: &Mod, _s: Span, _a: &[Attribute], _n: NodeId) {\n         self.count += 1;"}, {"sha": "fdb3e2c5f31db138e55b23eeda7c4500df1a23f7", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -55,8 +55,8 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n-    fn visit_ident(&mut self, span: Span, ident: Ident) {\n-        walk_ident(self, span, ident);\n+    fn visit_ident(&mut self, ident: Ident) {\n+        walk_ident(self, ident);\n     }\n     fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n         walk_mod(self, m);\n@@ -166,8 +166,8 @@ macro_rules! walk_list {\n     }\n }\n \n-pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident) {\n-    visitor.visit_name(span, ident.name);\n+pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.span, ident.name);\n }\n \n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n@@ -189,11 +189,11 @@ pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n }\n \n pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {\n-    visitor.visit_ident(label.span, label.ident);\n+    visitor.visit_ident(label.ident);\n }\n \n pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n-    visitor.visit_ident(lifetime.span, lifetime.ident);\n+    visitor.visit_ident(lifetime.ident);\n }\n \n pub fn walk_poly_trait_ref<'a, V>(visitor: &mut V,\n@@ -211,7 +211,7 @@ pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitR\n \n pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n     visitor.visit_vis(&item.vis);\n-    visitor.visit_ident(item.span, item.ident);\n+    visitor.visit_ident(item.ident);\n     match item.node {\n         ItemKind::ExternCrate(orig_name) => {\n             if let Some(orig_name) = orig_name {\n@@ -293,7 +293,7 @@ pub fn walk_variant<'a, V>(visitor: &mut V,\n                            item_id: NodeId)\n     where V: Visitor<'a>,\n {\n-    visitor.visit_ident(variant.span, variant.node.ident);\n+    visitor.visit_ident(variant.node.ident);\n     visitor.visit_variant_data(&variant.node.data, variant.node.ident,\n                              generics, item_id, variant.span);\n     walk_list!(visitor, visit_expr, &variant.node.disr_expr);\n@@ -357,7 +357,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n     match use_tree.kind {\n         UseTreeKind::Simple(rename) => {\n             if let Some(rename) = rename {\n-                visitor.visit_ident(use_tree.span, rename);\n+                visitor.visit_ident(rename);\n             }\n         }\n         UseTreeKind::Glob => {},\n@@ -372,7 +372,7 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n-    visitor.visit_ident(path_span, segment.ident);\n+    visitor.visit_ident(segment.ident);\n     if let Some(ref parameters) = segment.parameters {\n         visitor.visit_path_parameters(path_span, parameters);\n     }\n@@ -398,7 +398,7 @@ pub fn walk_path_parameters<'a, V>(visitor: &mut V,\n \n pub fn walk_assoc_type_binding<'a, V: Visitor<'a>>(visitor: &mut V,\n                                                    type_binding: &'a TypeBinding) {\n-    visitor.visit_ident(type_binding.span, type_binding.ident);\n+    visitor.visit_ident(type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n@@ -418,7 +418,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n                 walk_list!(visitor, visit_attribute, field.node.attrs.iter());\n-                visitor.visit_ident(field.span, field.node.ident);\n+                visitor.visit_ident(field.node.ident);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n@@ -431,7 +431,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n             visitor.visit_pat(subpattern)\n         }\n         PatKind::Ident(_, ident, ref optional_subpattern) => {\n-            visitor.visit_ident(ident.span, ident);\n+            visitor.visit_ident(ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n@@ -451,7 +451,7 @@ pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n \n pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, foreign_item: &'a ForeignItem) {\n     visitor.visit_vis(&foreign_item.vis);\n-    visitor.visit_ident(foreign_item.span, foreign_item.ident);\n+    visitor.visit_ident(foreign_item.ident);\n \n     match foreign_item.node {\n         ForeignItemKind::Fn(ref function_declaration, ref generics) => {\n@@ -489,7 +489,7 @@ pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Generi\n             walk_list!(visitor, visit_attribute, &*l.attrs);\n         }\n         GenericParam::Type(ref t) => {\n-            visitor.visit_ident(t.span, t.ident);\n+            visitor.visit_ident(t.ident);\n             walk_list!(visitor, visit_ty_param_bound, &t.bounds);\n             walk_list!(visitor, visit_ty, &t.default);\n             walk_list!(visitor, visit_attribute, &*t.attrs);\n@@ -561,7 +561,7 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n }\n \n pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) {\n-    visitor.visit_ident(trait_item.span, trait_item.ident);\n+    visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n@@ -588,7 +588,7 @@ pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a Trai\n \n pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplItem) {\n     visitor.visit_vis(&impl_item.vis);\n-    visitor.visit_ident(impl_item.span, impl_item.ident);\n+    visitor.visit_ident(impl_item.ident);\n     walk_list!(visitor, visit_attribute, &impl_item.attrs);\n     visitor.visit_generics(&impl_item.generics);\n     match impl_item.node {\n@@ -616,7 +616,7 @@ pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &\n pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n     visitor.visit_vis(&struct_field.vis);\n     if let Some(ident) = struct_field.ident {\n-        visitor.visit_ident(struct_field.span, ident);\n+        visitor.visit_ident(ident);\n     }\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n@@ -666,7 +666,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_path(path, expression.id);\n             for field in fields {\n                 walk_list!(visitor, visit_attribute, field.attrs.iter());\n-                visitor.visit_ident(field.ident.span, field.ident);\n+                visitor.visit_ident(field.ident);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n@@ -747,7 +747,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident.span, ident);\n+            visitor.visit_ident(ident);\n         }\n         ExprKind::TupField(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "7352c494a426cf3c8468d1ee7c55861b5f45e32c", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -14,6 +14,7 @@ use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -37,7 +38,7 @@ pub fn expand_assert<'cx>(\n \n     let sp = sp.apply_mark(cx.current_expansion.mark);\n     let panic_call = Mac_ {\n-        path: Path::from_ident(sp, Ident::from_str(\"panic\")),\n+        path: Path::from_ident(Ident::new(Symbol::intern(\"panic\"), sp)),\n         tts: if let Some(ts) = custom_msg_args {\n             ts.into()\n         } else {"}, {"sha": "544b1410d3d912135d8550c01d5345635ebb40d6", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -61,7 +61,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n             Some(P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident.span, self.ident)),\n+                node: ast::ExprKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n                 attrs: ast::ThinVec::new(),\n             }))\n@@ -70,7 +70,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n         fn make_ty(self: Box<Self>) -> Option<P<ast::Ty>> {\n             Some(P(ast::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident.span, self.ident)),\n+                node: ast::TyKind::Path(None, ast::Path::from_ident(self.ident)),\n                 span: self.ident.span,\n             }))\n         }"}, {"sha": "3a848a31c4dd7671e712322a322d1132168f15fa", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -61,7 +61,7 @@ fn expr(kind: ExprKind) -> P<Expr> {\n }\n \n fn make_x() -> P<Expr> {\n-    let seg = PathSegment::from_ident(Ident::from_str(\"x\"), DUMMY_SP);\n+    let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n     let path = Path { segments: vec![seg], span: DUMMY_SP };\n     expr(ExprKind::Path(None, path))\n }\n@@ -82,7 +82,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n             1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n             2 => {\n-                let seg = PathSegment::from_ident(Ident::from_str(\"x\"), DUMMY_SP);\n+                let seg = PathSegment::from_ident(Ident::from_str(\"x\"));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n                             seg.clone(), vec![e, make_x()])));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n@@ -150,7 +150,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n             },\n             14 => {\n-                let path = Path::from_ident(DUMMY_SP, Ident::from_str(\"S\"));\n+                let path = Path::from_ident(Ident::from_str(\"S\"));\n                 g(ExprKind::Struct(path, vec![], Some(make_x())));\n             },\n             15 => {"}, {"sha": "a2853570d6d3fa1a04f11b6246d1ef723f829122", "filename": "src/test/ui/feature-gate-non_ascii_idents.stderr", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-non_ascii_idents.stderr?ref=b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "patch": "@@ -1,38 +1,32 @@\n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:11:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:11:22\n    |\n LL | extern crate core as b\u00e4z; //~ ERROR non-ascii idents\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                      ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:13:5\n    |\n LL | use f\u00f6\u00f6::bar; //~ ERROR non-ascii idents\n-   |     ^^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:15:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:15:5\n    |\n LL | mod f\u00f6\u00f6 { //~ ERROR non-ascii idents\n-   | ^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:19:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:19:4\n    |\n-LL | / fn b\u00e4r( //~ ERROR non-ascii idents\n-LL | |     b\u00e4z: isize //~ ERROR non-ascii idents\n-LL | |     ) {\n-LL | |     let _\u00f6: isize; //~ ERROR non-ascii idents\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL | fn b\u00e4r( //~ ERROR non-ascii idents\n+   |    ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n@@ -61,26 +55,26 @@ LL |         (_\u00e4, _) => {} //~ ERROR non-ascii idents\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:29:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:29:8\n    |\n LL | struct F\u00f6\u00f6 { //~ ERROR non-ascii idents\n-   | ^^^^^^^^^^\n+   |        ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:30:5\n    |\n LL |     f\u00f6\u00f6: isize //~ ERROR non-ascii idents\n-   |     ^^^^^^^^^^\n+   |     ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:33:1\n+  --> $DIR/feature-gate-non_ascii_idents.rs:33:6\n    |\n LL | enum B\u00e4r { //~ ERROR non-ascii idents\n-   | ^^^^^^^^\n+   |      ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n@@ -96,15 +90,15 @@ error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n   --> $DIR/feature-gate-non_ascii_idents.rs:35:9\n    |\n LL |         q\u00fcx: isize //~ ERROR non-ascii idents\n-   |         ^^^^^^^^^^\n+   |         ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n \n error[E0658]: non-ascii idents are not fully supported. (see issue #28979)\n-  --> $DIR/feature-gate-non_ascii_idents.rs:40:5\n+  --> $DIR/feature-gate-non_ascii_idents.rs:40:8\n    |\n LL |     fn q\u00fcx();  //~ ERROR non-ascii idents\n-   |     ^^^^^^^^^\n+   |        ^^^\n    |\n    = help: add #![feature(non_ascii_idents)] to the crate attributes to enable\n "}]}