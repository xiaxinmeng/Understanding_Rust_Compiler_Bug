{"sha": "2d1e0750792529248ed6f11061940c7203d668c9", "node_id": "C_kwDOAAsO6NoAKDJkMWUwNzUwNzkyNTI5MjQ4ZWQ2ZjExMDYxOTQwYzcyMDNkNjY4Yzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T21:37:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-14T21:37:11Z"}, "message": "Auto merge of #96285 - flip1995:pk-vfe, r=nagisa\n\nIntroduce `-Zvirtual-function-elimination` codegen flag\n\nFixes #68262\n\nThis PR adds a codegen flag `-Zvirtual-function-elimination` to enable the VFE optimization in LLVM. To make this work, additonal  information has to be added to vtables ([`!vcall_visibility` metadata](https://llvm.org/docs/TypeMetadata.html#vcall-visibility-metadata) and a `typeid` of the trait). Furthermore, instead of just `load`ing functions, the [`llvm.type.checked.load` intrinsic](https://llvm.org/docs/LangRef.html#llvm-type-checked-load-intrinsic) has to be used to map functions to vtables.\n\nFor technical details of the changes, see the commit messages.\n\nI also tested this flag on https://github.com/tock/tock on different boards to verify that this fixes the issue https://github.com/tock/tock/issues/2594. This flag is able to improve the size of the resulting binary by about 8k-9k bytes by removing the unused debug print functions.\n\n[Rendered documentation update](https://github.com/flip1995/rust/blob/pk-vfe/src/doc/rustc/src/codegen-options/index.md#virtual-function-elimination)", "tree": {"sha": "354b2d33e105f927b0e0a25d509b56f003eb0597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/354b2d33e105f927b0e0a25d509b56f003eb0597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d1e0750792529248ed6f11061940c7203d668c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1e0750792529248ed6f11061940c7203d668c9", "html_url": "https://github.com/rust-lang/rust/commit/2d1e0750792529248ed6f11061940c7203d668c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d1e0750792529248ed6f11061940c7203d668c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "html_url": "https://github.com/rust-lang/rust/commit/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966"}, {"sha": "195f2082002c9db456e0fde8c1d5db79929ae293", "url": "https://api.github.com/repos/rust-lang/rust/commits/195f2082002c9db456e0fde8c1d5db79929ae293", "html_url": "https://github.com/rust-lang/rust/commit/195f2082002c9db456e0fde8c1d5db79929ae293"}], "stats": {"total": 463, "additions": 431, "deletions": 32}, "files": [{"sha": "f586e9facc62a2ead2a4b31a7d6aa0200388c4d0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -3695,6 +3695,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_symbol_mangling\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"tracing\","}, {"sha": "5fbdedac0c45c1def6d1cafd7325d23361688460", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -356,6 +356,16 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.context.new_rvalue_from_int(self.int_type, 0)\n     }\n \n+    fn type_checked_load(\n+        &mut self,\n+        _llvtable: Self::Value,\n+        _vtable_byte_offset: u64,\n+        _typeid: Self::Value,\n+    ) -> Self::Value {\n+        // Unsupported.\n+        self.context.new_rvalue_from_int(self.int_type, 0)\n+    }\n+\n     fn va_start(&mut self, _va_list: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }"}, {"sha": "9bded25c09e0772da148c703bfab75cd86c43d07", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -19,6 +19,7 @@ rustc-demangle = \"0.1.21\"\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }"}, {"sha": "38402e0431379ffb3f5f83c7951591788e504c4c", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -586,9 +586,21 @@ pub(crate) fn run_pass_manager(\n     // LTO-specific optimization passes that LLVM provides.\n     //\n     // This code is based off the code found in llvm's LTO code generator:\n-    //      tools/lto/LTOCodeGenerator.cpp\n+    //      llvm/lib/LTO/LTOCodeGenerator.cpp\n     debug!(\"running the pass manager\");\n     unsafe {\n+        if !llvm::LLVMRustHasModuleFlag(\n+            module.module_llvm.llmod(),\n+            \"LTOPostLink\".as_ptr().cast(),\n+            11,\n+        ) {\n+            llvm::LLVMRustAddModuleFlag(\n+                module.module_llvm.llmod(),\n+                llvm::LLVMModFlagBehavior::Error,\n+                \"LTOPostLink\\0\".as_ptr().cast(),\n+                1,\n+            );\n+        }\n         if llvm_util::should_use_new_llvm_pass_manager(\n             &config.new_llvm_pass_manager,\n             &cgcx.target_arch,"}, {"sha": "b5c31fcebe0c2eed3d8600f7599e7174f9c747c9", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -326,6 +326,15 @@ pub unsafe fn create_module<'ll>(\n         )\n     }\n \n+    if sess.opts.debugging_opts.virtual_function_elimination {\n+        llvm::LLVMRustAddModuleFlag(\n+            llmod,\n+            llvm::LLVMModFlagBehavior::Error,\n+            \"Virtual Function Elim\\0\".as_ptr().cast(),\n+            1,\n+        );\n+    }\n+\n     llmod\n }\n \n@@ -656,6 +665,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         let t_isize = self.type_isize();\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n+        let t_metadata = self.type_metadata();\n \n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n@@ -881,11 +891,12 @@ impl<'ll> CodegenCx<'ll, '_> {\n             ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n         }\n \n-        ifn!(\"llvm.type.test\", fn(i8p, self.type_metadata()) -> i1);\n+        ifn!(\"llvm.type.test\", fn(i8p, t_metadata) -> i1);\n+        ifn!(\"llvm.type.checked.load\", fn(i8p, t_i32, t_metadata) -> mk_struct! {i8p, i1});\n \n         if self.sess().opts.debuginfo != DebugInfo::None {\n-            ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n-            ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);\n+            ifn!(\"llvm.dbg.declare\", fn(t_metadata, t_metadata) -> void);\n+            ifn!(\"llvm.dbg.value\", fn(t_metadata, t_i64, t_metadata) -> void);\n         }\n         None\n     }"}, {"sha": "d5f39a456706626758adec25f43f642ab787e704", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 92, "deletions": 7, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -30,20 +30,21 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n use rustc_middle::mir::{self, GeneratorLayout};\n-use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt};\n-use rustc_session::config::{self, DebugInfo};\n+use rustc_middle::ty::{\n+    self, AdtKind, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt, Visibility,\n+};\n+use rustc_session::config::{self, DebugInfo, Lto};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileName;\n-use rustc_span::FileNameDisplayPreference;\n-use rustc_span::{self, SourceFile};\n+use rustc_span::{self, FileNameDisplayPreference, SourceFile};\n+use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::{Align, Size};\n use smallvec::smallvec;\n use tracing::debug;\n \n-use libc::{c_longlong, c_uint};\n+use libc::{c_char, c_longlong, c_uint};\n use std::borrow::Cow;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n@@ -1468,6 +1469,84 @@ fn build_vtable_type_di_node<'ll, 'tcx>(\n     .di_node\n }\n \n+fn vcall_visibility_metadata<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_ref: Option<PolyExistentialTraitRef<'tcx>>,\n+    vtable: &'ll Value,\n+) {\n+    enum VCallVisibility {\n+        Public = 0,\n+        LinkageUnit = 1,\n+        TranslationUnit = 2,\n+    }\n+\n+    let Some(trait_ref) = trait_ref else { return };\n+\n+    let trait_ref_self = trait_ref.with_self_ty(cx.tcx, ty);\n+    let trait_ref_self = cx.tcx.erase_regions(trait_ref_self);\n+    let trait_def_id = trait_ref_self.def_id();\n+    let trait_vis = cx.tcx.visibility(trait_def_id);\n+\n+    let cgus = cx.sess().codegen_units();\n+    let single_cgu = cgus == 1;\n+\n+    let lto = cx.sess().lto();\n+\n+    // Since LLVM requires full LTO for the virtual function elimination optimization to apply,\n+    // only the `Lto::Fat` cases are relevant currently.\n+    let vcall_visibility = match (lto, trait_vis, single_cgu) {\n+        // If there is not LTO and the visibility in public, we have to assume that the vtable can\n+        // be seen from anywhere. With multiple CGUs, the vtable is quasi-public.\n+        (Lto::No | Lto::ThinLocal, Visibility::Public, _)\n+        | (Lto::No, Visibility::Restricted(_) | Visibility::Invisible, false) => {\n+            VCallVisibility::Public\n+        }\n+        // With LTO and a quasi-public visibility, the usages of the functions of the vtable are\n+        // all known by the `LinkageUnit`.\n+        // FIXME: LLVM only supports this optimization for `Lto::Fat` currently. Once it also\n+        // supports `Lto::Thin` the `VCallVisibility` may have to be adjusted for those.\n+        (Lto::Fat | Lto::Thin, Visibility::Public, _)\n+        | (\n+            Lto::ThinLocal | Lto::Thin | Lto::Fat,\n+            Visibility::Restricted(_) | Visibility::Invisible,\n+            false,\n+        ) => VCallVisibility::LinkageUnit,\n+        // If there is only one CGU, private vtables can only be seen by that CGU/translation unit\n+        // and therefore we know of all usages of functions in the vtable.\n+        (_, Visibility::Restricted(_) | Visibility::Invisible, true) => {\n+            VCallVisibility::TranslationUnit\n+        }\n+    };\n+\n+    let trait_ref_typeid = typeid_for_trait_ref(cx.tcx, trait_ref);\n+\n+    unsafe {\n+        let typeid = llvm::LLVMMDStringInContext(\n+            cx.llcx,\n+            trait_ref_typeid.as_ptr() as *const c_char,\n+            trait_ref_typeid.as_bytes().len() as c_uint,\n+        );\n+        let v = [cx.const_usize(0), typeid];\n+        llvm::LLVMRustGlobalAddMetadata(\n+            vtable,\n+            llvm::MD_type as c_uint,\n+            llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n+                cx.llcx,\n+                v.as_ptr(),\n+                v.len() as c_uint,\n+            )),\n+        );\n+        let vcall_visibility = llvm::LLVMValueAsMetadata(cx.const_u64(vcall_visibility as u64));\n+        let vcall_visibility_metadata = llvm::LLVMMDNodeInContext2(cx.llcx, &vcall_visibility, 1);\n+        llvm::LLVMGlobalSetMetadata(\n+            vtable,\n+            llvm::MetadataType::MD_vcall_visibility as c_uint,\n+            vcall_visibility_metadata,\n+        );\n+    }\n+}\n+\n /// Creates debug information for the given vtable, which is for the\n /// given type.\n ///\n@@ -1478,6 +1557,12 @@ pub fn create_vtable_di_node<'ll, 'tcx>(\n     poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n     vtable: &'ll Value,\n ) {\n+    // FIXME(flip1995): The virtual function elimination optimization only works with full LTO in\n+    // LLVM at the moment.\n+    if cx.sess().opts.debugging_opts.virtual_function_elimination && cx.sess().lto() == Lto::Fat {\n+        vcall_visibility_metadata(cx, ty, poly_trait_ref, vtable);\n+    }\n+\n     if cx.dbg_cx.is_none() {\n         return;\n     }"}, {"sha": "a18f5b9dd7f9cdb8d19bb0f4f6c41958afd78bbf", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -406,6 +406,16 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         self.call_intrinsic(\"llvm.type.test\", &[bitcast, typeid])\n     }\n \n+    fn type_checked_load(\n+        &mut self,\n+        llvtable: &'ll Value,\n+        vtable_byte_offset: u64,\n+        typeid: &'ll Value,\n+    ) -> Self::Value {\n+        let vtable_byte_offset = self.const_i32(vtable_byte_offset as i32);\n+        self.call_intrinsic(\"llvm.type.checked.load\", &[llvtable, vtable_byte_offset, typeid])\n+    }\n+\n     fn va_start(&mut self, va_list: &'ll Value) -> &'ll Value {\n         self.call_intrinsic(\"llvm.va_start\", &[va_list])\n     }"}, {"sha": "b831423994f240b9505700567c13e8dfa84a05e3", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -442,6 +442,7 @@ pub enum MetadataType {\n     MD_nonnull = 11,\n     MD_align = 17,\n     MD_type = 19,\n+    MD_vcall_visibility = 28,\n     MD_noundef = 29,\n }\n \n@@ -1067,6 +1068,7 @@ extern \"C\" {\n     pub fn LLVMReplaceAllUsesWith<'a>(OldVal: &'a Value, NewVal: &'a Value);\n     pub fn LLVMSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Node: &'a Value);\n     pub fn LLVMGlobalSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n+    pub fn LLVMRustGlobalAddMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMValueAsMetadata(Node: &Value) -> &Metadata;\n \n     // Operations on constants of any type\n@@ -1080,6 +1082,11 @@ extern \"C\" {\n         Vals: *const &'a Value,\n         Count: c_uint,\n     ) -> &'a Value;\n+    pub fn LLVMMDNodeInContext2<'a>(\n+        C: &'a Context,\n+        Vals: *const &'a Metadata,\n+        Count: size_t,\n+    ) -> &'a Metadata;\n     pub fn LLVMAddNamedMetadataOperand<'a>(M: &'a Module, Name: *const c_char, Val: &'a Value);\n \n     // Operations on scalar constants\n@@ -1936,6 +1943,7 @@ extern \"C\" {\n         name: *const c_char,\n         value: u32,\n     );\n+    pub fn LLVMRustHasModuleFlag(M: &Module, name: *const c_char, len: size_t) -> bool;\n \n     pub fn LLVMRustMetadataAsValue<'a>(C: &'a Context, MD: &'a Metadata) -> &'a Value;\n "}, {"sha": "5203ebfad75dee39d994777069fc0258021db74a", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 42, "deletions": 10, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -1,6 +1,8 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, subst::GenericArgKind, ExistentialPredicate, Ty, TyCtxt};\n+use rustc_session::config::Lto;\n+use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]\n@@ -15,20 +17,32 @@ impl<'a, 'tcx> VirtualIndex {\n         self,\n         bx: &mut Bx,\n         llvtable: Bx::Value,\n+        ty: Ty<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n     ) -> Bx::Value {\n         // Load the data pointer from the object.\n-        debug!(\"get_fn({:?}, {:?})\", llvtable, self);\n-\n+        debug!(\"get_fn({llvtable:?}, {ty:?}, {self:?})\");\n         let llty = bx.fn_ptr_backend_type(fn_abi);\n         let llvtable = bx.pointercast(llvtable, bx.type_ptr_to(llty));\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let gep = bx.inbounds_gep(llty, llvtable, &[bx.const_usize(self.0)]);\n-        let ptr = bx.load(llty, gep, ptr_align);\n-        bx.nonnull_metadata(ptr);\n-        // Vtable loads are invariant.\n-        bx.set_invariant_load(ptr);\n-        ptr\n+\n+        if bx.cx().sess().opts.debugging_opts.virtual_function_elimination\n+            && bx.cx().sess().lto() == Lto::Fat\n+        {\n+            let typeid =\n+                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), get_trait_ref(bx.tcx(), ty)));\n+            let vtable_byte_offset = self.0 * bx.data_layout().pointer_size.bytes();\n+            let type_checked_load = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n+            let func = bx.extract_value(type_checked_load, 0);\n+            bx.pointercast(func, llty)\n+        } else {\n+            let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n+            let gep = bx.inbounds_gep(llty, llvtable, &[bx.const_usize(self.0)]);\n+            let ptr = bx.load(llty, gep, ptr_align);\n+            bx.nonnull_metadata(ptr);\n+            // Vtable loads are invariant.\n+            bx.set_invariant_load(ptr);\n+            ptr\n+        }\n     }\n \n     pub fn get_usize<Bx: BuilderMethods<'a, 'tcx>>(\n@@ -50,6 +64,24 @@ impl<'a, 'tcx> VirtualIndex {\n     }\n }\n \n+fn get_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n+    for arg in ty.peel_refs().walk() {\n+        if let GenericArgKind::Type(ty) = arg.unpack() {\n+            if let ty::Dynamic(trait_refs, _) = ty.kind() {\n+                return trait_refs[0].map_bound(|trait_ref| match trait_ref {\n+                    ExistentialPredicate::Trait(tr) => tr,\n+                    ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n+                    ExistentialPredicate::AutoTrait(_) => {\n+                        bug!(\"auto traits don't have functions\")\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    bug!(\"expected a `dyn Trait` ty, found {ty:?}\")\n+}\n+\n /// Creates a dynamic vtable for the given type and vtable origin.\n /// This is used only for objects.\n ///"}, {"sha": "db348f2bdd507faa3964a477087a7b3950f8e5c2", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 args = &args[..1];\n                 (\n                     meth::VirtualIndex::from_index(ty::COMMON_VTABLE_ENTRIES_DROPINPLACE)\n-                        .get_fn(&mut bx, vtable, &fn_abi),\n+                        .get_fn(&mut bx, vtable, ty, &fn_abi),\n                     fn_abi,\n                 )\n             }\n@@ -819,17 +819,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // the data pointer as the first argument\n                     match op.val {\n                         Pair(data_ptr, meta) => {\n-                            llfn = Some(\n-                                meth::VirtualIndex::from_index(idx).get_fn(&mut bx, meta, &fn_abi),\n-                            );\n+                            llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                                &mut bx,\n+                                meta,\n+                                op.layout.ty,\n+                                &fn_abi,\n+                            ));\n                             llargs.push(data_ptr);\n                             continue 'make_args;\n                         }\n                         other => bug!(\"expected a Pair, got {:?}\", other),\n                     }\n                 } else if let Ref(data_ptr, Some(meta), _) = op.val {\n                     // by-value dynamic dispatch\n-                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(&mut bx, meta, &fn_abi));\n+                    llfn = Some(meth::VirtualIndex::from_index(idx).get_fn(\n+                        &mut bx,\n+                        meta,\n+                        op.layout.ty,\n+                        &fn_abi,\n+                    ));\n                     llargs.push(data_ptr);\n                     continue;\n                 } else {"}, {"sha": "7755e67938c32e7df09879fc1f999df0dd18bc44", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -22,6 +22,14 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n     /// Trait method used to test whether a given pointer is associated with a type identifier.\n     fn type_test(&mut self, pointer: Self::Value, typeid: Self::Value) -> Self::Value;\n+    /// Trait method used to load a function while testing if it is associated with a type\n+    /// identifier.\n+    fn type_checked_load(\n+        &mut self,\n+        llvtable: Self::Value,\n+        vtable_byte_offset: u64,\n+        typeid: Self::Value,\n+    ) -> Self::Value;\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "30a29ed6ed38f8640bfe80adf2872f9b89c2801f", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -797,6 +797,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(unleash_the_miri_inside_of_you, true);\n     tracked!(use_ctors_section, Some(true));\n     tracked!(verify_llvm_ir, true);\n+    tracked!(virtual_function_elimination, true);\n     tracked!(wasi_exec_model, Some(WasiExecModel::Reactor));\n \n     macro_rules! tracked_no_crate_hash {"}, {"sha": "a52d534024206e4c68c4912172965c4fa79a9282", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -672,10 +672,20 @@ extern \"C\" void LLVMRustAddModuleFlag(\n   unwrap(M)->addModuleFlag(MergeBehavior, Name, Value);\n }\n \n+extern \"C\" bool LLVMRustHasModuleFlag(LLVMModuleRef M, const char *Name,\n+                                      size_t Len) {\n+  return unwrap(M)->getModuleFlag(StringRef(Name, Len)) != nullptr;\n+}\n+\n extern \"C\" LLVMValueRef LLVMRustMetadataAsValue(LLVMContextRef C, LLVMMetadataRef MD) {\n   return wrap(MetadataAsValue::get(*unwrap(C), unwrap(MD)));\n }\n \n+extern \"C\" void LLVMRustGlobalAddMetadata(\n+    LLVMValueRef Global, unsigned Kind, LLVMMetadataRef MD) {\n+  unwrap<GlobalObject>(Global)->addMetadata(Kind, *unwrap<MDNode>(MD));\n+}\n+\n extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n   return new DIBuilder(*unwrap(M));\n }"}, {"sha": "441e1f9f6a2b8c3efdf4cb67637d2fc3caf3601c", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -1585,6 +1585,9 @@ options! {\n         \"in general, enable more debug printouts (default: no)\"),\n     verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n         \"verify LLVM IR (default: no)\"),\n+    virtual_function_elimination: bool = (false, parse_bool, [TRACKED],\n+        \"enables dead virtual function elimination optimization. \\\n+        Requires `-Clto[=[fat,yes]]`\"),\n     wasi_exec_model: Option<WasiExecModel> = (None, parse_wasi_exec_model, [TRACKED],\n         \"whether to build a wasi command or reactor\"),\n "}, {"sha": "2186456576a34ade8c0c06933653130d8caf0c92", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -1433,14 +1433,14 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         );\n     }\n \n-    // LLVM CFI requires LTO.\n-    if sess.is_sanitizer_cfi_enabled() {\n-        if sess.opts.cg.lto == config::LtoCli::Unspecified\n-            || sess.opts.cg.lto == config::LtoCli::No\n-            || sess.opts.cg.lto == config::LtoCli::Thin\n-        {\n+    // LLVM CFI and VFE both require LTO.\n+    if sess.lto() != config::Lto::Fat {\n+        if sess.is_sanitizer_cfi_enabled() {\n             sess.err(\"`-Zsanitizer=cfi` requires `-Clto`\");\n         }\n+        if sess.opts.debugging_opts.virtual_function_elimination {\n+            sess.err(\"`-Zvirtual-function-elimination` requires `-Clto`\");\n+        }\n     }\n \n     if sess.opts.debugging_opts.stack_protector != StackProtector::None {"}, {"sha": "bed0e81e66e142b863d7172eb3ee5865bb80e932", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -155,6 +155,13 @@ pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>)\n     v0::mangle_typeid_for_fnabi(tcx, fn_abi)\n }\n \n+pub fn typeid_for_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n+) -> String {\n+    v0::mangle_typeid_for_trait_ref(tcx, trait_ref)\n+}\n+\n /// Computes the symbol name for the given instance. This function will call\n /// `compute_instantiating_crate` if it needs to factor the instantiating crate\n /// into the symbol name."}, {"sha": "1036c5d941ba1ffc6bbfbbb8125e714d526d0e09", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -94,6 +94,24 @@ pub(super) fn mangle_typeid_for_fnabi<'tcx>(\n     format!(\"typeid{}\", arg_count)\n }\n \n+pub(super) fn mangle_typeid_for_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n+) -> String {\n+    // FIXME(flip1995): See comment in `mangle_typeid_for_fnabi`.\n+    let mut cx = &mut SymbolMangler {\n+        tcx,\n+        start_offset: 0,\n+        paths: FxHashMap::default(),\n+        types: FxHashMap::default(),\n+        consts: FxHashMap::default(),\n+        binders: vec![],\n+        out: String::new(),\n+    };\n+    cx = cx.print_def_path(trait_ref.def_id(), &[]).unwrap();\n+    std::mem::take(&mut cx.out)\n+}\n+\n struct BinderLevel {\n     /// The range of distances from the root of what's\n     /// being printed, to the lifetimes in a binder."}, {"sha": "c6516d838ddc8d99bc6c6b9a3446dd0f92442091", "filename": "src/doc/unstable-book/src/compiler-flags/virtual-function-elimination.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fvirtual-function-elimination.md", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fvirtual-function-elimination.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fvirtual-function-elimination.md?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -0,0 +1,39 @@\n+# `virtual-function-elimination`\n+\n+This option controls whether LLVM runs the Virtual Function Elimination (VFE)\n+optimization. This optimization in only available with LTO, so this flag can\n+only be passed if [`-Clto`][Clto] is also passed.\n+\n+VFE makes it possible to remove functions from vtables that are never\n+dynamically called by the rest of the code. Without this flag, LLVM makes the\n+really conservative assumption, that if any function in a vtable is called, no\n+function that is referenced by this vtable can be removed. With this flag\n+additional information are given to LLVM, so that it can determine which\n+functions are actually called and remove the unused functions.\n+\n+## Limitations\n+\n+At the time of writing this flag may remove vtable functions too eagerly. One\n+such example is in this code:\n+\n+```rust\n+trait Foo { fn foo(&self) { println!(\"foo\") } }\n+\n+impl Foo for usize {}\n+\n+pub struct FooBox(Box<dyn Foo>);\n+\n+pub fn make_foo() -> FooBox { FooBox(Box::new(0)) }\n+\n+#[inline]\n+pub fn f(a: FooBox) { a.0.foo() }\n+```\n+\n+In the above code the `Foo` trait is private, so an assumption is made that its\n+functions can only be seen/called from the current crate and can therefore get\n+optimized out, if unused. However, with `make_foo` you can produce a wrapped\n+`dyn Foo` type outside of the current crate, which can then be used in `f`. Due\n+to inlining of `f`, `Foo::foo` can then be called from a foreign crate. This can\n+lead to miscompilations.\n+\n+[Clto]: https://doc.rust-lang.org/rustc/codegen-options/index.html#lto"}, {"sha": "6f963363a998c576d03861721324accda24302c6", "filename": "src/test/codegen/virtual-function-elimination-32bit.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination-32bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination-32bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination-32bit.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Zvirtual-function-elimination -Clto -O -Csymbol-mangling-version=v0\n+// ignore-64bit\n+\n+// CHECK: @vtable.0 = {{.*}}, !type ![[TYPE0:[0-9]+]], !vcall_visibility ![[VCALL_VIS0:[0-9]+]]\n+\n+#![crate_type = \"lib\"]\n+\n+trait T {\n+    // CHECK-LABEL: ; <virtual_function_elimination_32bit::S as virtual_function_elimination_32bit::T>::used\n+    fn used(&self) -> i32 {\n+        1\n+    }\n+    // CHECK-LABEL-NOT: {{.*}}::unused\n+    fn unused(&self) -> i32 {\n+        2\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct S;\n+\n+impl T for S {}\n+\n+fn taking_t(t: &dyn T) -> i32 {\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 12, metadata !\"[[MANGLED_TYPE0:[0-9a-zA-Z_]+]]\")\n+    t.used()\n+}\n+\n+pub fn main() {\n+    let s = S;\n+    taking_t(&s);\n+}\n+\n+// CHECK: ![[TYPE0]] = !{i32 0, !\"[[MANGLED_TYPE0]]\"}\n+// CHECK: ![[VCALL_VIS0]] = !{i64 2}"}, {"sha": "4cf7e12fee215f079f6b208da91a914a5f84798c", "filename": "src/test/codegen/virtual-function-elimination.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2d1e0750792529248ed6f11061940c7203d668c9/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d1e0750792529248ed6f11061940c7203d668c9/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvirtual-function-elimination.rs?ref=2d1e0750792529248ed6f11061940c7203d668c9", "patch": "@@ -0,0 +1,100 @@\n+// compile-flags: -Zvirtual-function-elimination -Clto -O -Csymbol-mangling-version=v0\n+// ignore-32bit\n+\n+// CHECK: @vtable.0 = {{.*}}, !type ![[TYPE0:[0-9]+]], !vcall_visibility ![[VCALL_VIS0:[0-9]+]]\n+// CHECK: @vtable.1 = {{.*}}, !type ![[TYPE1:[0-9]+]], !vcall_visibility ![[VCALL_VIS0:[0-9]+]]\n+// CHECK: @vtable.2 = {{.*}}, !type ![[TYPE2:[0-9]+]], !vcall_visibility ![[VCALL_VIS2:[0-9]+]]\n+\n+#![crate_type = \"lib\"]\n+#![allow(incomplete_features)]\n+#![feature(unsized_locals)]\n+\n+use std::rc::Rc;\n+\n+trait T {\n+    // CHECK-LABEL: ; <virtual_function_elimination::S as virtual_function_elimination::T>::used\n+    fn used(&self) -> i32 {\n+        1\n+    }\n+    // CHECK-LABEL: ; <virtual_function_elimination::S as virtual_function_elimination::T>::used_through_sub_trait\n+    fn used_through_sub_trait(&self) -> i32 {\n+        3\n+    }\n+    // CHECK-LABEL: ; <virtual_function_elimination::S as virtual_function_elimination::T>::by_rc\n+    fn by_rc(self: Rc<Self>) -> i32 {\n+        self.used() + self.used()\n+    }\n+    // CHECK-LABEL-NOT: {{.*}}::unused\n+    fn unused(&self) -> i32 {\n+        2\n+    }\n+    // CHECK-LABEL-NOT: {{.*}}::by_rc_unused\n+    fn by_rc_unused(self: Rc<Self>) -> i32 {\n+        self.by_rc()\n+    }\n+}\n+\n+trait U: T {\n+    // CHECK-LABEL: ; <virtual_function_elimination::S as virtual_function_elimination::U>::subtrait_used\n+    fn subtrait_used(&self) -> i32 {\n+        4\n+    }\n+    // CHECK-LABEL-NOT: {{.*}}::subtrait_unused\n+    fn subtrait_unused(&self) -> i32 {\n+        5\n+    }\n+}\n+\n+pub trait V {\n+    // CHECK-LABEL: ; <virtual_function_elimination::S as virtual_function_elimination::V>::public_function\n+    fn public_function(&self) -> i32;\n+}\n+\n+#[derive(Copy, Clone)]\n+struct S;\n+\n+impl T for S {}\n+\n+impl U for S {}\n+\n+impl V for S {\n+    fn public_function(&self) -> i32 {\n+        6\n+    }\n+}\n+\n+fn taking_t(t: &dyn T) -> i32 {\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 24, metadata !\"[[MANGLED_TYPE0:[0-9a-zA-Z_]+]]\")\n+    t.used()\n+}\n+\n+fn taking_rc_t(t: Rc<dyn T>) -> i32 {\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 40, metadata !\"[[MANGLED_TYPE0:[0-9a-zA-Z_]+]]\")\n+    t.by_rc()\n+}\n+\n+fn taking_u(u: &dyn U) -> i32 {\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 64, metadata !\"[[MANGLED_TYPE1:[0-9a-zA-Z_]+]]\")\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 24, metadata !\"[[MANGLED_TYPE1:[0-9a-zA-Z_]+]]\")\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 32, metadata !\"[[MANGLED_TYPE1:[0-9a-zA-Z_]+]]\")\n+    u.subtrait_used() + u.used() + u.used_through_sub_trait()\n+}\n+\n+pub fn taking_v(v: &dyn V) -> i32 {\n+    // CHECK: @llvm.type.checked.load({{.*}}, i32 24, metadata !\"NtCsfRpWlKdQPZn_28virtual_function_elimination1V\")\n+    v.public_function()\n+}\n+\n+pub fn main() {\n+    let s = S;\n+    taking_t(&s);\n+    taking_rc_t(Rc::new(s));\n+    taking_u(&s);\n+    taking_v(&s);\n+}\n+\n+// CHECK: ![[TYPE0]] = !{i64 0, !\"[[MANGLED_TYPE0]]\"}\n+// CHECK: ![[VCALL_VIS0]] = !{i64 2}\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"[[MANGLED_TYPE1]]\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"NtCsfRpWlKdQPZn_28virtual_function_elimination1V\"}\n+// CHECK: ![[VCALL_VIS2]] = !{i64 1}"}]}