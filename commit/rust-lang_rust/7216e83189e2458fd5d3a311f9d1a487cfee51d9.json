{"sha": "7216e83189e2458fd5d3a311f9d1a487cfee51d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMTZlODMxODllMjQ1OGZkNWQzYTMxMWY5ZDFhNDg3Y2ZlZTUxZDk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2015-12-23T00:14:10Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2015-12-23T01:42:01Z"}, "message": "Implement #471", "tree": {"sha": "5b20d3bc6302b352baeca74021366155c02985d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b20d3bc6302b352baeca74021366155c02985d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7216e83189e2458fd5d3a311f9d1a487cfee51d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7216e83189e2458fd5d3a311f9d1a487cfee51d9", "html_url": "https://github.com/rust-lang/rust/commit/7216e83189e2458fd5d3a311f9d1a487cfee51d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7216e83189e2458fd5d3a311f9d1a487cfee51d9/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd16ac2ad7eeae85bfb9dccb6d57428bce1fbbdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd16ac2ad7eeae85bfb9dccb6d57428bce1fbbdf", "html_url": "https://github.com/rust-lang/rust/commit/dd16ac2ad7eeae85bfb9dccb6d57428bce1fbbdf"}], "stats": {"total": 216, "additions": 210, "deletions": 6}, "files": [{"sha": "2e05fd1fc431fce0afa0d2ea5834cb93ed1a0e78", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7216e83189e2458fd5d3a311f9d1a487cfee51d9/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7216e83189e2458fd5d3a311f9d1a487cfee51d9/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7216e83189e2458fd5d3a311f9d1a487cfee51d9", "patch": "@@ -172,6 +172,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         loops::WHILE_LET_ON_ITERATOR,\n         map_clone::MAP_CLONE,\n         matches::MATCH_BOOL,\n+        matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n         methods::OK_EXPECT,"}, {"sha": "69a6fdf6016d28bf408825b64a126a1ea0f64e89", "filename": "src/matches.rs", "status": "modified", "additions": 182, "deletions": 2, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7216e83189e2458fd5d3a311f9d1a487cfee51d9/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7216e83189e2458fd5d3a311f9d1a487cfee51d9/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=7216e83189e2458fd5d3a311f9d1a487cfee51d9", "patch": "@@ -1,10 +1,14 @@\n use rustc::lint::*;\n-use rustc_front::hir::*;\n+use rustc::middle::const_eval::ConstVal::{Int, Uint};\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+use rustc::middle::const_eval::{eval_const_expr_partial, ConstVal};\n use rustc::middle::ty;\n+use rustc_front::hir::*;\n+use std::cmp::Ordering;\n use syntax::ast::Lit_::LitBool;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_block};\n+use utils::{snippet, span_lint, span_note_and_lint, span_help_and_lint, in_external_macro, expr_block};\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice. It is `Warn` by default.\n ///\n@@ -22,6 +26,7 @@ use utils::{snippet, span_lint, span_help_and_lint, in_external_macro, expr_bloc\n declare_lint!(pub SINGLE_MATCH, Warn,\n               \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n                is `_ => {}`) is used; recommends `if let` instead\");\n+\n /// **What it does:** This lint checks for matches where all arms match a reference, suggesting to remove the reference and deref the matched expression instead. It is `Warn` by default.\n ///\n /// **Why is this bad?** It just makes the code less readable. That reference destructuring adds nothing to the code.\n@@ -40,6 +45,7 @@ declare_lint!(pub SINGLE_MATCH, Warn,\n declare_lint!(pub MATCH_REF_PATS, Warn,\n               \"a match has all arms prefixed with `&`; the match expression can be \\\n                dereferenced instead\");\n+\n /// **What it does:** This lint checks for matches where match expression is a `bool`. It suggests to replace the expression with an `if...else` block. It is `Warn` by default.\n ///\n /// **Why is this bad?** It makes the code less readable.\n@@ -58,6 +64,25 @@ declare_lint!(pub MATCH_REF_PATS, Warn,\n declare_lint!(pub MATCH_BOOL, Warn,\n               \"a match on boolean expression; recommends `if..else` block instead\");\n \n+/// **What it does:** This lint checks for overlapping match arms. It is `Warn` by default.\n+///\n+/// **Why is this bad?** It is likely to be an error and if not, makes the code less obvious.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let x = 5;\n+/// match x {\n+///     1 ... 10 => println!(\"1 ... 10\"),\n+///     5 ... 15 => println!(\"5 ... 15\"),\n+///     _ => (),\n+/// }\n+/// ```\n+declare_lint!(pub MATCH_OVERLAPPING_ARM, Warn,\n+              \"overlapping match arms\");\n+\n #[allow(missing_copy_implementations)]\n pub struct MatchPass;\n \n@@ -150,6 +175,22 @@ impl LateLintPass for MatchPass {\n                         Consider using an if..else block\");\n                 }\n             }\n+\n+            // MATCH_OVERLAPPING_ARM\n+            if arms.len() >= 2 {\n+                let ranges = all_ranges(cx, arms);\n+                let overlap = match type_ranges(&ranges) {\n+                    TypedRanges::IntRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n+                    TypedRanges::UintRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n+                    TypedRanges::None => None,\n+                };\n+\n+                if let Some((start, end)) = overlap {\n+                    span_note_and_lint(cx, MATCH_OVERLAPPING_ARM, start,\n+                                       \"some ranges overlap\",\n+                                       end, \"overlaps with this\");\n+                }\n+            }\n         }\n         if let ExprMatch(ref ex, ref arms, source) = expr.node {\n             // check preconditions for MATCH_REF_PATS\n@@ -170,6 +211,77 @@ impl LateLintPass for MatchPass {\n     }\n }\n \n+/// Get all arms that are unbounded PatRange-s.\n+fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { ref pats, guard: None, .. } = *arm {\n+                Some(pats.iter().filter_map(|pat| {\n+                    if_let_chain! {[\n+                        let PatRange(ref lhs, ref rhs) = pat.node,\n+                        let Ok(lhs) = eval_const_expr_partial(cx.tcx, &lhs, ExprTypeChecked, None),\n+                        let Ok(rhs) = eval_const_expr_partial(cx.tcx, &rhs, ExprTypeChecked, None)\n+                    ], {\n+                        return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n+                    }}\n+\n+                    None\n+                }))\n+            }\n+            else {\n+                None\n+            }\n+        })\n+        .flat_map(IntoIterator::into_iter)\n+        .collect()\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct SpannedRange<T> {\n+    span: Span,\n+    node: (T, T),\n+}\n+\n+#[derive(Debug)]\n+enum TypedRanges {\n+    IntRanges(Vec<SpannedRange<i64>>),\n+    UintRanges(Vec<SpannedRange<u64>>),\n+    None,\n+}\n+\n+/// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway and other types than\n+/// `Uint` and `Int` probably don't make sense.\n+fn type_ranges(ranges: &[SpannedRange<ConstVal>]) -> TypedRanges {\n+    if ranges.is_empty() {\n+        TypedRanges::None\n+    }\n+    else {\n+        match ranges[0].node {\n+            (Int(_), Int(_)) => {\n+                TypedRanges::IntRanges(ranges.iter().filter_map(|range| {\n+                    if let (Int(start), Int(end)) = range.node {\n+                        Some(SpannedRange { span: range.span, node: (start, end) })\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }).collect())\n+            },\n+            (Uint(_), Uint(_)) => {\n+                TypedRanges::UintRanges(ranges.iter().filter_map(|range| {\n+                    if let (Uint(start), Uint(end)) = range.node {\n+                        Some(SpannedRange { span: range.span, node: (start, end) })\n+                    }\n+                    else {\n+                        None\n+                    }\n+                }).collect())\n+            },\n+            _ => TypedRanges::None,\n+        }\n+    }\n+}\n+\n fn is_unit_expr(expr: &Expr) -> bool {\n     match expr.node {\n         ExprTup(ref v) if v.is_empty() => true,\n@@ -209,3 +321,71 @@ fn match_template(cx: &LateContext,\n         }\n     }\n }\n+\n+fn overlaping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+    where T: Copy + Ord {\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    enum Kind<'a, T: 'a> {\n+        Start(T, &'a SpannedRange<T>),\n+        End(T, &'a SpannedRange<T>),\n+    }\n+\n+    impl<'a, T: Copy> Kind<'a, T> {\n+        fn range(&self) -> &'a SpannedRange<T> {\n+            match *self {\n+                Kind::Start(_, r) | Kind::End(_, r) => r\n+            }\n+        }\n+\n+        fn value(self) -> T {\n+            match self {\n+                Kind::Start(t, _) | Kind::End(t, _) => t\n+            }\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for Kind<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            self.value().cmp(&other.value())\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2*ranges.len());\n+\n+    for r in ranges {\n+        values.push(Kind::Start(r.node.0, &r));\n+        values.push(Kind::End(r.node.1, &r));\n+    }\n+\n+    values.sort();\n+\n+    for (a, b) in values.iter().zip(values.iter().skip(1)) {\n+        match (a, b) {\n+            (&Kind::Start(_, ra), &Kind::End(_, rb)) => if ra.node != rb.node { return Some((ra, rb)) },\n+            (&Kind::End(a, _), &Kind::Start(b, _)) if a != b => (),\n+            _ => return Some((&a.range(), &b.range())),\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn test_overlapping() {\n+    use syntax::codemap::DUMMY_SP;\n+\n+    let sp = |s, e| SpannedRange { span: DUMMY_SP, node: (s, e) };\n+\n+    assert_eq!(None, overlaping::<u8>(&[]));\n+    assert_eq!(None, overlaping(&[sp(1, 4)]));\n+    assert_eq!(None, overlaping(&[sp(1, 4), sp(5, 6)]));\n+    assert_eq!(None, overlaping(&[sp(1, 4), sp(5, 6), sp(10, 11)]));\n+    assert_eq!(Some((&sp(1, 4), &sp(3, 6))), overlaping(&[sp(1, 4), sp(3, 6)]));\n+    assert_eq!(Some((&sp(5, 6), &sp(6, 11))), overlaping(&[sp(1, 4), sp(5, 6), sp(6, 11)]));\n+}"}, {"sha": "ab181901c9c15ea262905d281778e86fae242e8b", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7216e83189e2458fd5d3a311f9d1a487cfee51d9/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7216e83189e2458fd5d3a311f9d1a487cfee51d9/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=7216e83189e2458fd5d3a311f9d1a487cfee51d9", "patch": "@@ -51,17 +51,17 @@ fn match_bool() {\n         true => 1,\n         false => 0,\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         true => (),\n         false => { println!(\"Noooo!\"); }\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         false => { println!(\"Noooo!\"); }\n         _ => (),\n     };\n-    \n+\n     match test { //~ ERROR you seem to be trying to match on a boolean expression\n         false => { println!(\"Noooo!\"); }\n         true => { println!(\"Yes!\"); }\n@@ -70,7 +70,7 @@ fn match_bool() {\n     // Not linted\n     match option {\n         1 ... 10 => (),\n-        10 ... 20 => (),\n+        11 ... 20 => (),\n         _ => (),\n     };\n }\n@@ -115,5 +115,28 @@ fn ref_pats() {\n     }\n }\n \n+fn overlapping() {\n+    const FOO : u64 = 2;\n+\n+    match 42 {\n+        0 ... 10 => println!(\"0 ... 10\"), //~ERROR\n+        0 ... 11 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+\n+    match 42 {\n+        0 ... 5 => println!(\"0 ... 10\"), //~ERROR\n+        6 ... 7 => println!(\"6 ... 7\"),\n+        FOO ... 11 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+\n+    match 42 {\n+        0 ... 10 => println!(\"0 ... 10\"),\n+        11 ... 50 => println!(\"0 ... 10\"),\n+        _ => (),\n+    }\n+}\n+\n fn main() {\n }"}]}