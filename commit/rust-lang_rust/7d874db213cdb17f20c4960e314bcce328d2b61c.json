{"sha": "7d874db213cdb17f20c4960e314bcce328d2b61c", "node_id": "C_kwDOAAsO6NoAKDdkODc0ZGIyMTNjZGIxN2YyMGM0OTYwZTMxNGJjY2UzMjhkMmI2MWM", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-12T21:04:37Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:25Z"}, "message": "Add tests showing weak memory behaviours", "tree": {"sha": "781fc7872c5292bfc02c7be97c243897a21715b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/781fc7872c5292bfc02c7be97c243897a21715b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d874db213cdb17f20c4960e314bcce328d2b61c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRD0ACgkQGBtJ+fOP\nM3Rz9Qv6Aqgwm7lVIZEhXdmiu6iscFuHkEcA+9BLNw4liORLD8UjI2tms6yZLrBX\nfu10csQLMf0XXiW8EcqfjeQnBqnvbo6fjrEXhVMLDF2OL600c7aqhm3TwE5RhwmO\n1jQ2uk9PpZr0sIlp/el7ow0ny/48eDUzXW3KlwXBizvRc39OpgQTLw3BX2Itf7Nx\nIyDeKDRFjNO3VfWgPjbTpkOkgcbd14HdFoj6nAdtlfHk1SMlMTwpNsscGXNKI7s3\nDJomTTkga89Z+Ro54E+JYPkkvBxbnioXDDJb419gKucr+tlX1yt5XxouDVOpgcX8\nMs0/9GF1z+lhAwh3manIm4I7wNz23aBRShB8IMO5gptq6kXCuVNSQDPzRsvwDsYL\n/z7sookU9wtf0CLc6Yil/U0L4ngQFKOpqbXsAyojGxV7YXYC5o9E8w6jb3qxUtcu\nQqL1UUsAw3pPMuiok5fx/RVnXauPaSbubAe6MdLMJAbKhWXjj1dG5Bt2lsWtJwY9\nw0RrZsoO\n=1rmI\n-----END PGP SIGNATURE-----", "payload": "tree 781fc7872c5292bfc02c7be97c243897a21715b5\nparent 773131bb261a2a96426f9024271f5557bbbf5c1a\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652389477 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539325 +0100\n\nAdd tests showing weak memory behaviours\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d874db213cdb17f20c4960e314bcce328d2b61c", "html_url": "https://github.com/rust-lang/rust/commit/7d874db213cdb17f20c4960e314bcce328d2b61c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d874db213cdb17f20c4960e314bcce328d2b61c/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "773131bb261a2a96426f9024271f5557bbbf5c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/773131bb261a2a96426f9024271f5557bbbf5c1a", "html_url": "https://github.com/rust-lang/rust/commit/773131bb261a2a96426f9024271f5557bbbf5c1a"}], "stats": {"total": 147, "additions": 112, "deletions": 35}, "files": [{"sha": "d7c44f6ac281484d6feb7c433f945b36a0e77219", "filename": "tests/run-pass/weak_memory/consistency.rs", "status": "renamed", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fconsistency.rs?ref=7d874db213cdb17f20c4960e314bcce328d2b61c", "patch": "@@ -1,8 +1,8 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n // compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-stacked-borrows\n \n-// Weak memory emulation tests. All of the following test if\n-// our weak memory emulation produces any inconsistent execution outcomes\n+// The following tests check whether our weak memory emulation produces\n+// any inconsistent execution outcomes\n //\n // Due to the random nature of choosing valid stores, it is always\n // possible that our tests spuriously succeeds: even though our weak\n@@ -12,26 +12,16 @@\n //\n // To mitigate this, each test is ran enough times such that the chance\n // of spurious success is very low. These tests never supriously fail.\n-//\n-// Note that we can't effectively test whether our weak memory emulation\n-// can produce *all* consistent execution outcomes. This may be possible\n-// if Miri's scheduler is sufficiently random and explores all possible\n-// interleavings of our small test cases after a reasonable number of runs.\n-// However, since Miri's scheduler is not even pre-emptive, there will\n-// always be possible interleavings (and possible execution outcomes),\n-// that can never be observed regardless of how weak memory emulation is\n-// implemented.\n \n // Test cases and their consistent outcomes are from\n // http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/\n // Based on\n // M. Batty, S. Owens, S. Sarkar, P. Sewell and T. Weber,\n // \"Mathematizing C++ concurrency\", ACM SIGPLAN Notices, vol. 46, no. 1, pp. 55-66, 2011.\n // Available: https://ss265.host.cs.st-andrews.ac.uk/papers/n3132.pdf.\n-#![feature(atomic_from_mut)]\n \n+use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::*;\n-use std::sync::atomic::{AtomicU16, AtomicU32, AtomicUsize};\n use std::thread::{spawn, yield_now};\n \n #[derive(Copy, Clone)]\n@@ -41,7 +31,7 @@ unsafe impl<T> Send for EvilSend<T> {}\n unsafe impl<T> Sync for EvilSend<T> {}\n \n // We can't create static items because we need to run each test\n-// multiple tests\n+// multiple times\n fn static_atomic(val: usize) -> &'static AtomicUsize {\n     let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n     // A workaround to put the initialisation value in the store buffer\n@@ -190,26 +180,6 @@ fn test_mixed_access() {\n     assert_eq!(r2, 2);\n }\n \n-// Strictly speaking, atomic accesses that imperfectly overlap with existing\n-// atomic objects are UB. Nonetheless we'd like to provide a sane value when\n-// the access is not racy.\n-fn test_imperfectly_overlapping_access() {\n-    let mut qword = AtomicU32::new(42);\n-    assert_eq!(qword.load(Relaxed), 42);\n-    qword.store(u32::to_be(0xabbafafa), Relaxed);\n-\n-    let qword_mut = qword.get_mut();\n-\n-    let dwords_mut = unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(qword_mut) };\n-\n-    let (hi_mut, lo_mut) = dwords_mut.split_at_mut(1);\n-\n-    let (hi, lo) = (AtomicU16::from_mut(&mut hi_mut[0]), AtomicU16::from_mut(&mut lo_mut[0]));\n-\n-    assert_eq!(u16::from_be(hi.load(Relaxed)), 0xabba);\n-    assert_eq!(u16::from_be(lo.load(Relaxed)), 0xfafa);\n-}\n-\n // The following two tests are taken from Repairing Sequential Consistency in C/C++11\n // by Lahav et al.\n // https://plv.mpi-sws.org/scfix/paper.pdf\n@@ -236,7 +206,6 @@ fn test_sc_store_buffering() {\n }\n \n pub fn main() {\n-    test_imperfectly_overlapping_access();\n     // TODO: does this make chances of spurious success\n     // \"sufficiently low\"? This also takes a long time to run,\n     // prehaps each function should be its own test case so they", "previous_filename": "tests/run-pass/concurrency/weak_memory.rs"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/weak_memory/consistency.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fconsistency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fconsistency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fconsistency.stderr?ref=7d874db213cdb17f20c4960e314bcce328d2b61c", "previous_filename": "tests/run-pass/concurrency/weak_memory.stderr"}, {"sha": "2a8e8e5f323d5abcbda259d698a3e43a2cea5b30", "filename": "tests/run-pass/weak_memory/imperfectly_overlapping.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fimperfectly_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fimperfectly_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fimperfectly_overlapping.rs?ref=7d874db213cdb17f20c4960e314bcce328d2b61c", "patch": "@@ -0,0 +1,29 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+#![feature(atomic_from_mut)]\n+\n+use std::sync::atomic::Ordering::*;\n+use std::sync::atomic::{AtomicU16, AtomicU32};\n+\n+// Strictly speaking, atomic accesses that imperfectly overlap with existing\n+// atomic objects are UB. Nonetheless we'd like to provide a sane value when\n+// the access is not racy.\n+fn test_same_thread() {\n+    let mut qword = AtomicU32::new(42);\n+    assert_eq!(qword.load(Relaxed), 42);\n+    qword.store(u32::to_be(0xabbafafa), Relaxed);\n+\n+    let qword_mut = qword.get_mut();\n+\n+    let dwords_mut = unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(qword_mut) };\n+\n+    let (hi_mut, lo_mut) = dwords_mut.split_at_mut(1);\n+\n+    let (hi, lo) = (AtomicU16::from_mut(&mut hi_mut[0]), AtomicU16::from_mut(&mut lo_mut[0]));\n+\n+    assert_eq!(u16::from_be(hi.load(Relaxed)), 0xabba);\n+    assert_eq!(u16::from_be(lo.load(Relaxed)), 0xfafa);\n+}\n+\n+pub fn main() {\n+    test_same_thread();\n+}"}, {"sha": "ab0c20cc977215c3ec865b1f1a685e16684d95f8", "filename": "tests/run-pass/weak_memory/weak.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fweak.rs?ref=7d874db213cdb17f20c4960e314bcce328d2b61c", "patch": "@@ -0,0 +1,77 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks\n+\n+// Tests showing weak memory behaviours are exhibited. All tests\n+// return true when the desired behaviour is seen.\n+// This is scheduler and pseudo-RNG dependent, so each test is\n+// run multiple times until one try returns true.\n+// Spurious failure is possible, if you are really unlucky with\n+// the RNG.\n+\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering::*;\n+use std::thread::spawn;\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+// We can't create static items because we need to run each test\n+// multiple times\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    // A workaround to put the initialisation value in the store buffer\n+    ret.store(val, Relaxed);\n+    ret\n+}\n+\n+fn relaxed() -> bool {\n+    let x = static_atomic(0);\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+        x.store(2, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || x.load(Relaxed));\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    r2 == 1\n+}\n+\n+// https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf Figure 8\n+fn seq_cst() -> bool {\n+    let x = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        x.store(2, SeqCst);\n+        x.store(3, SeqCst);\n+    });\n+\n+    let j3 = spawn(move || x.load(SeqCst));\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+\n+    r3 == 1\n+}\n+\n+// Asserts that the function returns true at least once in 100 runs\n+macro_rules! assert_once {\n+    ($f:ident) => {\n+        assert!(std::iter::repeat_with(|| $f()).take(100).any(|x| x));\n+    };\n+}\n+\n+pub fn main() {\n+    assert_once!(relaxed);\n+    assert_once!(seq_cst);\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/weak_memory/weak.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fweak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d874db213cdb17f20c4960e314bcce328d2b61c/tests%2Frun-pass%2Fweak_memory%2Fweak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fweak_memory%2Fweak.stderr?ref=7d874db213cdb17f20c4960e314bcce328d2b61c", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}