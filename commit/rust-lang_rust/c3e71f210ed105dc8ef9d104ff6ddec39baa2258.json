{"sha": "c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZTcxZjIxMGVkMTA1ZGM4ZWY5ZDEwNGZmNmRkZWMzOWJhYTIyNTg=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-27T20:47:30Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-27T20:52:03Z"}, "message": "Make eval_place iterate instead of recurse", "tree": {"sha": "de1b52dbd3ba148994dac8a3a1dc150b23ff2d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de1b52dbd3ba148994dac8a3a1dc150b23ff2d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "html_url": "https://github.com/rust-lang/rust/commit/c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3e71f210ed105dc8ef9d104ff6ddec39baa2258/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dbc7f96d6438b93c9274675b276cfe934164704", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbc7f96d6438b93c9274675b276cfe934164704", "html_url": "https://github.com/rust-lang/rust/commit/4dbc7f96d6438b93c9274675b276cfe934164704"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "24e7fa009b40cf4a47e75f8f17cc0dbc259b894c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c3e71f210ed105dc8ef9d104ff6ddec39baa2258/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3e71f210ed105dc8ef9d104ff6ddec39baa2258/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "patch": "@@ -296,47 +296,50 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        match *place {\n-            Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _) => {\n-                    trace!(\"field proj on {:?}\", proj.base);\n-                    let base = self.eval_place(&proj.base, source_info)?;\n+        place.iterate(|place_base, place_projection| {\n+            let mut eval = match place_base {\n+                PlaceBase::Local(loc) => self.places[*loc].clone()?,\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..}) => {\n+                    let generics = self.tcx.generics_of(self.source.def_id());\n+                    if generics.requires_monomorphization(self.tcx) {\n+                        // FIXME: can't handle code with generics\n+                        return None;\n+                    }\n+                    let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                    let instance = Instance::new(self.source.def_id(), substs);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: Some(*promoted),\n+                    };\n+                    // cannot use `const_eval` here, because that would require having the MIR\n+                    // for the current function available, but we're producing said MIR right now\n                     let res = self.use_ecx(source_info, |this| {\n-                        this.ecx.operand_field(base, field.index() as u64)\n+                        let mir = &this.promoted[*promoted];\n+                        eval_promoted(this.tcx, cid, mir, this.param_env)\n                     })?;\n-                    Some(res)\n-                },\n-                // We could get more projections by using e.g., `operand_projection`,\n-                // but we do not even have the stack frame set up properly so\n-                // an `Index` projection would throw us off-track.\n-                _ => None,\n-            },\n-            Place::Base(\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n-            ) => {\n-                let generics = self.tcx.generics_of(self.source.def_id());\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n+                    trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                    res.into()\n                 }\n-                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                let instance = Instance::new(self.source.def_id(), substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(promoted),\n-                };\n-                // cannot use `const_eval` here, because that would require having the MIR\n-                // for the current function available, but we're producing said MIR right now\n-                let res = self.use_ecx(source_info, |this| {\n-                    let mir = &this.promoted[promoted];\n-                    eval_promoted(this.tcx, cid, mir, this.param_env)\n-                })?;\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some(res.into())\n-            },\n-            _ => None,\n-        }\n+                _ => return None,\n+            };\n+\n+            for proj in place_projection {\n+                match proj.elem {\n+                    ProjectionElem::Field(field, _) => {\n+                        trace!(\"field proj on {:?}\", proj.base);\n+                        eval = self.use_ecx(source_info, |this| {\n+                            this.ecx.operand_field(eval, field.index() as u64)\n+                        })?;\n+                    },\n+                    // We could get more projections by using e.g., `operand_projection`,\n+                    // but we do not even have the stack frame set up properly so\n+                    // an `Index` projection would throw us off-track.\n+                    _ => return None,\n+                }\n+            }\n+\n+            Some(eval)\n+        })\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {"}]}