{"sha": "41f124c8248f360404b77cfa6a789de2fe90c1fc", "node_id": "C_kwDOAAsO6NoAKDQxZjEyNGM4MjQ4ZjM2MDQwNGI3N2NmYTZhNzg5ZGUyZmU5MGMxZmM", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T17:57:52Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2022-02-20T19:57:34Z"}, "message": "Avoid sharding query caches entirely in single-threaded mode", "tree": {"sha": "f77d4ea8b90963302fad50e75402d4925361dd8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f77d4ea8b90963302fad50e75402d4925361dd8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f124c8248f360404b77cfa6a789de2fe90c1fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f124c8248f360404b77cfa6a789de2fe90c1fc", "html_url": "https://github.com/rust-lang/rust/commit/41f124c8248f360404b77cfa6a789de2fe90c1fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f124c8248f360404b77cfa6a789de2fe90c1fc/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8443816176199e3b552f26050aa67ea3c3a2173d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8443816176199e3b552f26050aa67ea3c3a2173d", "html_url": "https://github.com/rust-lang/rust/commit/8443816176199e3b552f26050aa67ea3c3a2173d"}], "stats": {"total": 79, "additions": 59, "deletions": 20}, "files": [{"sha": "85c5af72ef5353fad56cfc1735f3e4b2886478be", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 59, "deletions": 20, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/41f124c8248f360404b77cfa6a789de2fe90c1fc/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f124c8248f360404b77cfa6a789de2fe90c1fc/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=41f124c8248f360404b77cfa6a789de2fe90c1fc", "patch": "@@ -2,7 +2,11 @@ use crate::dep_graph::DepNodeIndex;\n \n use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sharded::{self, Sharded};\n+use rustc_data_structures::sharded;\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::sharded::Sharded;\n+#[cfg(not(parallel_compiler))]\n+use rustc_data_structures::sync::Lock;\n use rustc_data_structures::sync::WorkerLocal;\n use std::default::Default;\n use std::fmt::Debug;\n@@ -50,12 +54,15 @@ impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n }\n \n pub struct DefaultCache<K, V> {\n-    shards: Sharded<FxHashMap<K, (V, DepNodeIndex)>>,\n+    #[cfg(parallel_compiler)]\n+    cache: Sharded<FxHashMap<K, (V, DepNodeIndex)>>,\n+    #[cfg(not(parallel_compiler))]\n+    cache: Lock<FxHashMap<K, (V, DepNodeIndex)>>,\n }\n \n impl<K, V> Default for DefaultCache<K, V> {\n     fn default() -> Self {\n-        DefaultCache { shards: Default::default() }\n+        DefaultCache { cache: Default::default() }\n     }\n }\n \n@@ -83,8 +90,10 @@ where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n     {\n         let key_hash = sharded::make_hash(key);\n-        let shard = sharded::get_shard_index_by_hash(key_hash);\n-        let lock = self.shards.get_shard_by_index(shard).lock();\n+        #[cfg(parallel_compiler)]\n+        let lock = self.cache.get_shard_by_hash(key_hash).lock();\n+        #[cfg(not(parallel_compiler))]\n+        let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n         if let Some((_, value)) = result {\n@@ -97,14 +106,28 @@ where\n \n     #[inline]\n     fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n-        self.shards.get_shard_by_value(&key).lock().insert(key, (value.clone(), index));\n+        #[cfg(parallel_compiler)]\n+        let mut lock = self.cache.get_shard_by_value(&key).lock();\n+        #[cfg(not(parallel_compiler))]\n+        let mut lock = self.cache.lock();\n+        lock.insert(key, (value.clone(), index));\n         value\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        let shards = self.shards.lock_shards();\n-        for shard in shards.iter() {\n-            for (k, v) in shard.iter() {\n+        #[cfg(parallel_compiler)]\n+        {\n+            let shards = self.cache.lock_shards();\n+            for shard in shards.iter() {\n+                for (k, v) in shard.iter() {\n+                    f(k, &v.0, v.1);\n+                }\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            let map = self.cache.lock();\n+            for (k, v) in map.iter() {\n                 f(k, &v.0, v.1);\n             }\n         }\n@@ -119,15 +142,15 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> CacheSelector<K, V> for ArenaCacheSelector<'tc\n \n pub struct ArenaCache<'tcx, K, V> {\n     arena: WorkerLocal<TypedArena<(V, DepNodeIndex)>>,\n-    shards: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n+    #[cfg(parallel_compiler)]\n+    cache: Sharded<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n+    #[cfg(not(parallel_compiler))]\n+    cache: Lock<FxHashMap<K, &'tcx (V, DepNodeIndex)>>,\n }\n \n impl<'tcx, K, V> Default for ArenaCache<'tcx, K, V> {\n     fn default() -> Self {\n-        ArenaCache {\n-            arena: WorkerLocal::new(|_| TypedArena::default()),\n-            shards: Default::default(),\n-        }\n+        ArenaCache { arena: WorkerLocal::new(|_| TypedArena::default()), cache: Default::default() }\n     }\n }\n \n@@ -156,8 +179,10 @@ where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n     {\n         let key_hash = sharded::make_hash(key);\n-        let shard = sharded::get_shard_index_by_hash(key_hash);\n-        let lock = self.shards.get_shard_by_index(shard).lock();\n+        #[cfg(parallel_compiler)]\n+        let lock = self.cache.get_shard_by_hash(key_hash).lock();\n+        #[cfg(not(parallel_compiler))]\n+        let lock = self.cache.lock();\n         let result = lock.raw_entry().from_key_hashed_nocheck(key_hash, key);\n \n         if let Some((_, value)) = result {\n@@ -172,14 +197,28 @@ where\n     fn complete(&self, key: K, value: V, index: DepNodeIndex) -> Self::Stored {\n         let value = self.arena.alloc((value, index));\n         let value = unsafe { &*(value as *const _) };\n-        self.shards.get_shard_by_value(&key).lock().insert(key, value);\n+        #[cfg(parallel_compiler)]\n+        let mut lock = self.cache.get_shard_by_value(&key).lock();\n+        #[cfg(not(parallel_compiler))]\n+        let mut lock = self.cache.lock();\n+        lock.insert(key, value);\n         &value.0\n     }\n \n     fn iter(&self, f: &mut dyn FnMut(&Self::Key, &Self::Value, DepNodeIndex)) {\n-        let shards = self.shards.lock_shards();\n-        for shard in shards.iter() {\n-            for (k, v) in shard.iter() {\n+        #[cfg(parallel_compiler)]\n+        {\n+            let shards = self.cache.lock_shards();\n+            for shard in shards.iter() {\n+                for (k, v) in shard.iter() {\n+                    f(k, &v.0, v.1);\n+                }\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            let map = self.cache.lock();\n+            for (k, v) in map.iter() {\n                 f(k, &v.0, v.1);\n             }\n         }"}]}