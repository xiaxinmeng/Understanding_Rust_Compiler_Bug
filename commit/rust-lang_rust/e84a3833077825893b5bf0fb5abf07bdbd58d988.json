{"sha": "e84a3833077825893b5bf0fb5abf07bdbd58d988", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NGEzODMzMDc3ODI1ODkzYjViZjBmYjVhYmYwN2JkYmQ1OGQ5ODg=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2014-12-13T01:13:06Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-12-20T14:10:05Z"}, "message": "Add a new invariant to `Bitv`\n\nThe length of the underlying vector must now be exactly as long as it needs to\nbe.", "tree": {"sha": "366e11674922256b1329c099a17708fa7e92bc4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366e11674922256b1329c099a17708fa7e92bc4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84a3833077825893b5bf0fb5abf07bdbd58d988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84a3833077825893b5bf0fb5abf07bdbd58d988", "html_url": "https://github.com/rust-lang/rust/commit/e84a3833077825893b5bf0fb5abf07bdbd58d988", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84a3833077825893b5bf0fb5abf07bdbd58d988/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3deb97f5d02ddbdbf20a587815fe84934cda948c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3deb97f5d02ddbdbf20a587815fe84934cda948c", "html_url": "https://github.com/rust-lang/rust/commit/3deb97f5d02ddbdbf20a587815fe84934cda948c"}], "stats": {"total": 154, "additions": 84, "deletions": 70}, "files": [{"sha": "3f33d85ba569ea163f6ed709c1364db151087a37", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 84, "deletions": 70, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e84a3833077825893b5bf0fb5abf07bdbd58d988/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84a3833077825893b5bf0fb5abf07bdbd58d988/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=e84a3833077825893b5bf0fb5abf07bdbd58d988", "patch": "@@ -8,18 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for maintenance),\n-// they should be in separate files/modules, with BitvSet only using Bitv's public API.\n-\n-// First rule of Bitv club: almost everything can actually overflow because we're working with\n-// bits and not bytes.\n-//\n-// Second rule of Bitv club: the last \"block\" of bits may be partially used. We must ensure that\n-// those unused bits are zeroed out, as other methods will assume this is the case. It may be\n-// the case that this isn't a great design, but having \"undefined\" bits is headache-inducing.\n-//\n-// Third rule of Bitv club: BitvSet is fairly tightly coupled to Bitv's implementation details.\n-// Make sure any changes to Bitv are properly addressed in BitvSet.\n+// FIXME(Gankro): Bitv and BitvSet are very tightly coupled. Ideally (for\n+// maintenance), they should be in separate files/modules, with BitvSet only\n+// using Bitv's public API. This will be hard for performance though, because\n+// `Bitv` will not want to leak its internal representation while its internal\n+// representation as `u32`s must be assumed for best performance.\n+\n+// FIXME(tbu-): `Bitv`'s methods shouldn't be `union`, `intersection`, but\n+// rather `or` and `and`.\n+\n+// (1) Be careful, most things can overflow here because the amount of bits in\n+//     memory can overflow `uint`.\n+// (2) Make sure that the underlying vector has no excess length:\n+//     E. g. `nbits == 16`, `storage.len() == 2` would be excess length,\n+//     because the last word isn't used at all. This is important because some\n+//     methods rely on it (for *CORRECTNESS*).\n+// (3) Make sure that the unused bits in the last word are zeroed out, again\n+//     other methods rely on it for *CORRECTNESS*.\n+// (4) `BitvSet` is tightly coupled with `Bitv`, so any changes you make in\n+// `Bitv` will need to be reflected in `BitvSet`.\n \n //! Collections implemented with bit vectors.\n //!\n@@ -82,10 +89,10 @@ use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n use core::iter;\n use core::num::Int;\n use core::slice::{Items, MutItems};\n-use core::{u32, uint};\n-use std::hash;\n+use core::{u8, u32, uint};\n \n-use vec::Vec;\n+use hash;\n+use Vec;\n \n type Blocks<'a> = Cloned<Items<'a, u32>>;\n type MutBlocks<'a> = MutItems<'a, u32>;\n@@ -181,17 +188,15 @@ fn mask_for_bits(bits: uint) -> u32 {\n }\n \n impl Bitv {\n-    /// Applies the given operation to the blocks of self and other, and sets self to\n-    /// be the result.\n+    /// Applies the given operation to the blocks of self and other, and sets\n+    /// self to be the result. This relies on the caller not to corrupt the\n+    /// last word.\n     #[inline]\n     fn process<F>(&mut self, other: &Bitv, mut op: F) -> bool where F: FnMut(u32, u32) -> u32 {\n-        let len = other.storage.len();\n-        assert_eq!(self.storage.len(), len);\n+        assert_eq!(self.len(), other.len());\n+        // This could theoretically be a `debug_assert!`.\n+        assert_eq!(self.storage.len(), other.storage.len());\n         let mut changed = false;\n-        // Notice: `a` is *not* masked here, which is fine as long as\n-        // `op` is a bitwise operation, since any bits that should've\n-        // been masked were fine to change anyway. `b` is masked to\n-        // make sure its unmasked bits do not cause damage.\n         for (a, b) in self.blocks_mut().zip(other.blocks()) {\n             let w = op(*a, b);\n             if *a != w {\n@@ -204,21 +209,20 @@ impl Bitv {\n \n     /// Iterator over mutable refs to  the underlying blocks of data.\n     fn blocks_mut(&mut self) -> MutBlocks {\n-        let blocks = blocks_for_bits(self.len());\n-        self.storage.slice_to_mut(blocks).iter_mut()\n+        // (2)\n+        self.storage.iter_mut()\n     }\n \n     /// Iterator over the underlying blocks of data\n     fn blocks(&self) -> Blocks {\n-        let blocks = blocks_for_bits(self.len());\n-        self.storage[..blocks].iter().cloned()\n+        // (2)\n+        self.storage.iter().cloned()\n     }\n \n-    /// An operation might screw up the unused bits in the last block of the Bitv.\n-    /// It's assumed to be all 0's. This fixes it up.\n+    /// An operation might screw up the unused bits in the last block of the\n+    /// `Bitv`. As per (3), it's assumed to be all 0s. This method fixes it up.\n     fn fix_last_block(&mut self) {\n-        let len = self.len();\n-        let extra_bits = len % u32::BITS;\n+        let extra_bits = self.len() % u32::BITS;\n         if extra_bits > 0 {\n             let mask = (1 << extra_bits) - 1;\n             let storage_len = self.storage.len();\n@@ -259,7 +263,6 @@ impl Bitv {\n             storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n             nbits: nbits\n         };\n-\n         bitv.fix_last_block();\n         bitv\n     }\n@@ -295,15 +298,33 @@ impl Bitv {\n     ///                     false, false, true, false]));\n     /// ```\n     pub fn from_bytes(bytes: &[u8]) -> Bitv {\n-        Bitv::from_fn(bytes.len() * 8, |i| {\n-            let b = bytes[i / 8] as u32;\n-            let offset = i % 8;\n-            b >> (7 - offset) & 1 == 1\n-        })\n+        let len = bytes.len().checked_mul(u8::BITS).expect(\"capacity overflow\");\n+        let mut bitv = Bitv::with_capacity(len);\n+        let complete_words = bytes.len() / 4;\n+        let extra_bytes = bytes.len() % 4;\n+\n+        for i in range(0, complete_words) {\n+            bitv.storage.push(\n+                (bytes[i * 4 + 0] as u32 << 0) |\n+                (bytes[i * 4 + 1] as u32 << 8) |\n+                (bytes[i * 4 + 2] as u32 << 16) |\n+                (bytes[i * 4 + 3] as u32 << 24)\n+            );\n+        }\n+\n+        if extra_bytes > 0 {\n+            let mut last_word = 0u32;\n+            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n+                last_word |= byte as u32 << (i * 8);\n+            }\n+            bitv.storage.push(last_word);\n+        }\n+\n+        bitv\n     }\n \n-    /// Creates a `Bitv` of the specified length where the value at each\n-    /// index is `f(index)`.\n+    /// Creates a `Bitv` of the specified length where the value at each index\n+    /// is `f(index)`.\n     ///\n     /// # Examples\n     ///\n@@ -339,7 +360,9 @@ impl Bitv {\n     #[inline]\n     #[unstable = \"panic semantics are likely to change in the future\"]\n     pub fn get(&self, i: uint) -> Option<bool> {\n-        assert!(i < self.nbits);\n+        if i >= self.nbits {\n+            return None;\n+        }\n         let w = i / u32::BITS;\n         let b = i % u32::BITS;\n         self.storage.get(w).map(|&block|\n@@ -548,7 +571,7 @@ impl Bitv {\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> Bits<'a> {\n-        Bits {bitv: self, next_idx: 0, end_idx: self.nbits}\n+        Bits { bitv: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n     /// Returns `true` if all bits are 0.\n@@ -608,7 +631,7 @@ impl Bitv {\n     /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n-        fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n+        fn bit(bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n             if offset >= bitv.nbits {\n                 0\n@@ -634,7 +657,7 @@ impl Bitv {\n     /// Deprecated: Use `iter().collect()`.\n     #[deprecated = \"Use `iter().collect()`\"]\n     pub fn to_bools(&self) -> Vec<bool> {\n-        Vec::from_fn(self.nbits, |i| self[i])\n+        self.iter().collect()\n     }\n \n     /// Compares a `Bitv` to a slice of `bool`s.\n@@ -656,12 +679,7 @@ impl Bitv {\n     /// ```\n     pub fn eq_vec(&self, v: &[bool]) -> bool {\n         assert_eq!(self.nbits, v.len());\n-        let mut i = 0;\n-        while i < self.nbits {\n-            if self[i] != v[i] { return false; }\n-            i = i + 1;\n-        }\n-        true\n+        iter::order::eq(self.iter(), v.iter().cloned())\n     }\n \n     /// Shortens a `Bitv`, dropping excess elements.\n@@ -682,6 +700,7 @@ impl Bitv {\n     pub fn truncate(&mut self, len: uint) {\n         if len < self.len() {\n             self.nbits = len;\n+            // This fixes (2).\n             self.storage.truncate(blocks_for_bits(len));\n             self.fix_last_block();\n         }\n@@ -707,13 +726,9 @@ impl Bitv {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        match self.storage.len().checked_mul(u32::BITS) {\n-            None => {} // Vec has more initialized capacity than we can ever use\n-            Some(initialized_cap) => {\n-                if desired_cap > initialized_cap {\n-                    self.storage.reserve(blocks_for_bits(desired_cap - initialized_cap));\n-                }\n-            }\n+        let storage_len = self.storage.len();\n+        if desired_cap > self.capacity() {\n+            self.storage.reserve(blocks_for_bits(desired_cap) - storage_len);\n         }\n     }\n \n@@ -741,13 +756,9 @@ impl Bitv {\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn reserve_exact(&mut self, additional: uint) {\n         let desired_cap = self.len().checked_add(additional).expect(\"capacity overflow\");\n-        match self.storage.len().checked_mul(u32::BITS) {\n-            None => {} // Vec has more initialized capacity than we can ever use\n-            Some(initialized_cap) => {\n-                if desired_cap > initialized_cap {\n-                    self.storage.reserve_exact(blocks_for_bits(desired_cap - initialized_cap));\n-                }\n-            }\n+        let storage_len = self.storage.len();\n+        if desired_cap > self.capacity() {\n+            self.storage.reserve_exact(blocks_for_bits(desired_cap) - storage_len);\n         }\n     }\n \n@@ -801,8 +812,7 @@ impl Bitv {\n             if value {\n                 self.storage[old_last_word] |= !mask;\n             } else {\n-                // Extra bits are already supposed to be zero by invariant, but play it safe...\n-                self.storage[old_last_word] &= mask;\n+                // Extra bits are already zero by invariant.\n             }\n         }\n \n@@ -843,9 +853,13 @@ impl Bitv {\n         } else {\n             let i = self.nbits - 1;\n             let ret = self[i];\n-            // Second rule of Bitv Club\n+            // (3)\n             self.set(i, false);\n             self.nbits = i;\n+            if self.nbits % u32::BITS == 0 {\n+                // (2)\n+                self.storage.pop();\n+            }\n             Some(ret)\n         }\n     }\n@@ -864,11 +878,11 @@ impl Bitv {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn push(&mut self, elem: bool) {\n-        let insert_pos = self.nbits;\n-        self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n-        if self.storage.len().checked_mul(u32::BITS).unwrap_or(uint::MAX) < self.nbits {\n+        if self.nbits % u32::BITS == 0 {\n             self.storage.push(0);\n         }\n+        let insert_pos = self.nbits;\n+        self.nbits = self.nbits.checked_add(1).expect(\"Capacity overflow\");\n         self.set(insert_pos, elem);\n     }\n \n@@ -958,7 +972,7 @@ impl Ord for Bitv {\n impl fmt::Show for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n-            try!(write!(fmt, \"{}\", if bit { 1u } else { 0u }));\n+            try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n         }\n         Ok(())\n     }"}]}