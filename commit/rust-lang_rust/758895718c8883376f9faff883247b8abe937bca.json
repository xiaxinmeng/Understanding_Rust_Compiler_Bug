{"sha": "758895718c8883376f9faff883247b8abe937bca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODg5NTcxOGM4ODgzMzc2ZjlmYWZmODgzMjQ3YjhhYmU5MzdiY2E=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-25T16:46:59Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-25T16:47:11Z"}, "message": "rewrap uninit", "tree": {"sha": "efbd26269f374fcb293981a380edee3f52cfe72f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efbd26269f374fcb293981a380edee3f52cfe72f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758895718c8883376f9faff883247b8abe937bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758895718c8883376f9faff883247b8abe937bca", "html_url": "https://github.com/rust-lang/rust/commit/758895718c8883376f9faff883247b8abe937bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758895718c8883376f9faff883247b8abe937bca/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14d11b37675953020ce2b9d3964f649cf9c8b0bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/14d11b37675953020ce2b9d3964f649cf9c8b0bf", "html_url": "https://github.com/rust-lang/rust/commit/14d11b37675953020ce2b9d3964f649cf9c8b0bf"}], "stats": {"total": 174, "additions": 98, "deletions": 76}, "files": [{"sha": "88cc7deac47258afc1da4b2e0cb3971284a9f9c2", "filename": "uninitialized.md", "status": "modified", "additions": 98, "deletions": 76, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/758895718c8883376f9faff883247b8abe937bca/uninitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/758895718c8883376f9faff883247b8abe937bca/uninitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/uninitialized.md?ref=758895718c8883376f9faff883247b8abe937bca", "patch": "@@ -1,8 +1,14 @@\n % Working With Uninitialized Memory\n \n-All runtime-allocated memory in a Rust program begins its life as *uninitialized*. In this state the value of the memory is an indeterminate pile of bits that may or may not even reflect a valid state for the type that is supposed to inhabit that location of memory. Attempting to interpret this memory as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n+All runtime-allocated memory in a Rust program begins its life as\n+*uninitialized*. In this state the value of the memory is an indeterminate pile\n+of bits that may or may not even reflect a valid state for the type that is\n+supposed to inhabit that location of memory. Attempting to interpret this memory\n+as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n \n-Like C, all stack variables in Rust begin their life as uninitialized until a value is explicitly assigned to them. Unlike C, Rust statically prevents you from ever reading them until you do:\n+Like C, all stack variables in Rust begin their life as uninitialized until a\n+value is explicitly assigned to them. Unlike C, Rust statically prevents you\n+from ever reading them until you do:\n \n ```rust\n fn main() {\n@@ -17,8 +23,11 @@ src/main.rs:3     println!(\"{}\", x);\n                                  ^\n ```\n \n-This is based off of a basic branch analysis: every branch must assign a value to `x` before it\n-is first used. Interestingly, Rust doesn't require the variable to be mutable to perform a delayed initialization if every branch assigns exactly once. However the analysis does not take advantage of constant analysis or anything like that. So this compiles:\n+This is based off of a basic branch analysis: every branch must assign a value\n+to `x` before it is first used. Interestingly, Rust doesn't require the variable\n+to be mutable to perform a delayed initialization if every branch assigns\n+exactly once. However the analysis does not take advantage of constant analysis\n+or anything like that. So this compiles:\n \n ```rust\n fn main() {\n@@ -68,76 +77,88 @@ fn main() {\n }\n ```\n \n-If a value is moved out of a variable, that variable becomes logically uninitialized if the type\n-of the value isn't Copy. That is:\n+If a value is moved out of a variable, that variable becomes logically\n+uninitialized if the type of the value isn't Copy. That is:\n \n ```rust\n fn main() {\n \tlet x = 0;\n \tlet y = Box::new(0);\n \tlet z1 = x; // x is still valid because i32 is Copy\n-\tlet z2 = y; // y has once more become logically uninitialized, since Box is not Copy\n+\tlet z2 = y; // y is now logically uninitialized because Box isn't Copy\n }\n ```\n \n-However reassigning `y` in this example *would* require `y` to be marked as mutable, as a\n-Safe Rust program could observe that the value of `y` changed. Otherwise the variable is\n-exactly like new.\n-\n-This raises an interesting question with respect to `Drop`: where does Rust\n-try to call the destructor of a variable that is conditionally initialized?\n-It turns out that Rust actually tracks whether a type should be dropped or not *at runtime*. As a\n-variable becomes initialized and uninitialized, a *drop flag* for that variable is set and unset.\n-When a variable goes out of scope or is assigned it evaluates whether the current value of the\n-variable should be dropped. Of course, static analysis can remove these checks. If the compiler\n-can prove that a value is guaranteed to be either initialized or not, then it can theoretically\n-generate more efficient code! As such it may be desirable to structure code to have *static drop\n-semantics* when possible.\n-\n-As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a secret field of any type\n-that implements Drop. The language sets the drop flag by overwriting the entire struct with a\n-particular value. This is pretty obviously Not The Fastest and causes a bunch of trouble with\n-optimizing code. As such work is currently under way to move the flags out onto the stack frame\n-where they more reasonably belong. Unfortunately this work will take some time as it requires\n-fairly substantial changes to the compiler.\n-\n-So in general, Rust programs don't need to worry about uninitialized values on the stack for\n-correctness. Although they might care for performance. Thankfully, Rust makes it easy to take\n-control here! Uninitialized values are there, and Safe Rust lets you work with them, but you're\n-never in trouble.\n-\n-One interesting exception to this rule is working with arrays. Safe Rust doesn't permit you to\n-partially initialize an array. When you initialize an array, you can either set every value to the\n-same thing with `let x = [val; N]`, or you can specify each member individually with\n-`let x = [val1, val2, val3]`. Unfortunately this is pretty rigid, especially if you need\n-to initialize your array in a more incremental or dynamic way.\n-\n-Unsafe Rust gives us a powerful tool to handle this problem: `std::mem::uninitialized`.\n-This function pretends to return a value when really it does nothing at all. Using it, we can\n-convince Rust that we have initialized a variable, allowing us to do trickier things with\n-conditional and incremental initialization.\n-\n-Unfortunately, this raises a tricky problem. Assignment has a different meaning to Rust based on\n-whether it believes that a variable is initialized or not. If it's uninitialized, then Rust will\n-semantically just memcopy the bits over the uninit ones, and do nothing else. However if Rust\n-believes a value to be initialized, it will try to `Drop` the old value! Since we've tricked Rust\n-into believing that the value is initialized, we can no longer safely use normal assignment.\n-\n-This is also a problem if you're working with a raw system allocator, which of course returns a\n-pointer to uninitialized memory.\n-\n-To handle this, we must use the `std::ptr` module. In particular, it provides three functions that\n-allow us to assign bytes to a location in memory without evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n-\n-* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed to by `ptr`.\n-* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy from src to dest. (this is equivalent to memmove -- note that the argument order is reversed!)\n-* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a little faster on the\n-assumption that the two ranges of memory don't overlap. (this is equivalent to memcopy -- note that the argument order is reversed!)\n-\n-It should go without saying that these functions, if misused, will cause serious havoc or just\n-straight up Undefined Behaviour. The only things that these functions *themselves* require is that\n-the locations you want to read and write are allocated. However the ways writing arbitrary bit\n-patterns to arbitrary locations of memory can break things are basically uncountable!\n+However reassigning `y` in this example *would* require `y` to be marked as\n+mutable, as a Safe Rust program could observe that the value of `y` changed.\n+Otherwise the variable is exactly like new.\n+\n+This raises an interesting question with respect to `Drop`: where does Rust try\n+to call the destructor of a variable that is conditionally initialized? It turns\n+out that Rust actually tracks whether a type should be dropped or not *at\n+runtime*. As a variable becomes initialized and uninitialized, a *drop flag* for\n+that variable is set and unset. When a variable goes out of scope or is assigned\n+it evaluates whether the current value of the variable should be dropped. Of\n+course, static analysis can remove these checks. If the compiler can prove that\n+a value is guaranteed to be either initialized or not, then it can theoretically\n+generate more efficient code! As such it may be desirable to structure code to\n+have *static drop semantics* when possible.\n+\n+As of Rust 1.0, the drop flags are actually not-so-secretly stashed in a secret\n+field of any type that implements Drop. The language sets the drop flag by\n+overwriting the entire struct with a particular value. This is pretty obviously\n+Not The Fastest and causes a bunch of trouble with optimizing code. As such work\n+is currently under way to move the flags out onto the stack frame where they\n+more reasonably belong. Unfortunately this work will take some time as it\n+requires fairly substantial changes to the compiler.\n+\n+So in general, Rust programs don't need to worry about uninitialized values on\n+the stack for correctness. Although they might care for performance. Thankfully,\n+Rust makes it easy to take control here! Uninitialized values are there, and\n+Safe Rust lets you work with them, but you're never in trouble.\n+\n+One interesting exception to this rule is working with arrays. Safe Rust doesn't\n+permit you to partially initialize an array. When you initialize an array, you\n+can either set every value to the same thing with `let x = [val; N]`, or you can\n+specify each member individually with `let x = [val1, val2, val3]`.\n+Unfortunately this is pretty rigid, especially if you need to initialize your\n+array in a more incremental or dynamic way.\n+\n+Unsafe Rust gives us a powerful tool to handle this problem:\n+`std::mem::uninitialized`. This function pretends to return a value when really\n+it does nothing at all. Using it, we can convince Rust that we have initialized\n+a variable, allowing us to do trickier things with conditional and incremental\n+initialization.\n+\n+Unfortunately, this raises a tricky problem. Assignment has a different meaning\n+to Rust based on whether it believes that a variable is initialized or not. If\n+it's uninitialized, then Rust will semantically just memcopy the bits over the\n+uninit ones, and do nothing else. However if Rust believes a value to be\n+initialized, it will try to `Drop` the old value! Since we've tricked Rust into\n+believing that the value is initialized, we can no longer safely use normal\n+assignment.\n+\n+This is also a problem if you're working with a raw system allocator, which of\n+course returns a pointer to uninitialized memory.\n+\n+To handle this, we must use the `std::ptr` module. In particular, it provides\n+three functions that allow us to assign bytes to a location in memory without\n+evaluating the old value: `write`, `copy`, and `copy_nonoverlapping`.\n+\n+* `ptr::write(ptr, val)` takes a `val` and moves it into the address pointed\n+  to by `ptr`.\n+* `ptr::copy(src, dest, count)` copies the bits that `count` T's would occupy\n+  from src to dest. (this is equivalent to memmove -- note that the argument\n+  order is reversed!)\n+* `ptr::copy_nonoverlapping(src, dest, count)` does what `copy` does, but a\n+  little faster on the assumption that the two ranges of memory don't overlap.\n+  (this is equivalent to memcopy -- note that the argument order is reversed!)\n+\n+It should go without saying that these functions, if misused, will cause serious\n+havoc or just straight up Undefined Behaviour. The only things that these\n+functions *themselves* require is that the locations you want to read and write\n+are allocated. However the ways writing arbitrary bit patterns to arbitrary\n+locations of memory can break things are basically uncountable!\n \n Putting this all together, we get the following:\n \n@@ -164,16 +185,17 @@ fn main() {\n }\n ```\n \n-It's worth noting that you don't need to worry about ptr::write-style shenanigans with\n-Plain Old Data (POD; types which don't implement Drop, nor contain Drop types),\n-because Rust knows not to try to Drop them. Similarly you should be able to assign the POD\n-fields of partially initialized structs directly.\n+It's worth noting that you don't need to worry about ptr::write-style\n+shenanigans with Plain Old Data (POD; types which don't implement Drop, nor\n+contain Drop types), because Rust knows not to try to Drop them. Similarly you\n+should be able to assign the POD fields of partially initialized structs\n+directly.\n \n-However when working with uninitialized memory you need to be ever vigilant for Rust trying to\n-Drop values you make like this before they're fully initialized. So every control path through\n-that variable's scope must initialize the value before it ends. *This includes code panicking*.\n-Again, POD types need not worry.\n+However when working with uninitialized memory you need to be ever vigilant for\n+Rust trying to Drop values you make like this before they're fully initialized.\n+So every control path through that variable's scope must initialize the value\n+before it ends. *This includes code panicking*. Again, POD types need not worry.\n \n-And that's about it for working with uninitialized memory! Basically nothing anywhere expects\n-to be handed uninitialized memory, so if you're going to pass it around at all, be sure to be\n-*really* careful.\n+And that's about it for working with uninitialized memory! Basically nothing\n+anywhere expects to be handed uninitialized memory, so if you're going to pass\n+it around at all, be sure to be *really* careful."}]}