{"sha": "4b3b02f8f4f57046956d42c4c19d00c7bb260189", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiM2IwMmY4ZjRmNTcwNDY5NTZkNDJjNGMxOWQwMGM3YmIyNjAxODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T00:37:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T00:37:24Z"}, "message": "Auto merge of #22940 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "e10fa9a4a2f6fe235c201d64e560d13e2004493c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e10fa9a4a2f6fe235c201d64e560d13e2004493c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b3b02f8f4f57046956d42c4c19d00c7bb260189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b3b02f8f4f57046956d42c4c19d00c7bb260189", "html_url": "https://github.com/rust-lang/rust/commit/4b3b02f8f4f57046956d42c4c19d00c7bb260189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b3b02f8f4f57046956d42c4c19d00c7bb260189/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "157614249594f187f421cd97f928e64c5ab5c1fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/157614249594f187f421cd97f928e64c5ab5c1fa", "html_url": "https://github.com/rust-lang/rust/commit/157614249594f187f421cd97f928e64c5ab5c1fa"}, {"sha": "69881574f74177a7aef068fa6dafd1619a76a1d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/69881574f74177a7aef068fa6dafd1619a76a1d4", "html_url": "https://github.com/rust-lang/rust/commit/69881574f74177a7aef068fa6dafd1619a76a1d4"}], "stats": {"total": 915, "additions": 589, "deletions": 326}, "files": [{"sha": "7cc963bed358f9aa666ff401bc3f520a3d84109a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -39,7 +39,7 @@\n //!   distribution.\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n-//!   `fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n+//!   `fmt::Arguments`, a `&str`, and a `usize`. These three arguments dictate\n //!   the panic message, the file at which panic was invoked, and the line.\n //!   It is up to consumers of this core library to define this panic\n //!   function; it is only required to never return.\n@@ -88,14 +88,12 @@ mod int_macros;\n #[macro_use]\n mod uint_macros;\n \n-#[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/isize.rs\"]  pub mod isize;\n #[path = \"num/i8.rs\"]   pub mod i8;\n #[path = \"num/i16.rs\"]  pub mod i16;\n #[path = \"num/i32.rs\"]  pub mod i32;\n #[path = \"num/i64.rs\"]  pub mod i64;\n \n-#[path = \"num/uint.rs\"] pub mod uint;\n #[path = \"num/usize.rs\"] pub mod usize;\n #[path = \"num/u8.rs\"]   pub mod u8;\n #[path = \"num/u16.rs\"]  pub mod u16;"}, {"sha": "2132b9516abad0973d95c422f34e503f246c6c03", "filename": "src/libcore/num/int.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=157614249594f187f421cd97f928e64c5ab5c1fa", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `isize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"core\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n-\n-#[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n-#[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "f66a0eed971612913bf5e7e0b1fa98cfbdbfeab4", "filename": "src/libcore/num/uint.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=157614249594f187f421cd97f928e64c5ab5c1fa", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `usize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"core\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n-\n-uint_module! { uint, int, ::int::BITS }"}, {"sha": "abf88583c03ffac03f1a6a40a0c9c51a86e20060", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -12,7 +12,7 @@ use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n use core::num::SignedInt;\n-use core::uint;\n+use core::usize;\n use core::cmp;\n \n use test::Bencher;\n@@ -292,7 +292,7 @@ fn test_unfoldr() {\n fn test_cycle() {\n     let cycle_len = 3;\n     let it = count(0, 1).take(cycle_len).cycle();\n-    assert_eq!(it.size_hint(), (uint::MAX, None));\n+    assert_eq!(it.size_hint(), (usize::MAX, None));\n     for (i, x) in it.take(100).enumerate() {\n         assert_eq!(i % cycle_len, x);\n     }\n@@ -365,19 +365,19 @@ fn test_iterator_size_hint() {\n     let v2 = &[10, 11, 12];\n     let vi = v.iter();\n \n-    assert_eq!(c.size_hint(), (uint::MAX, None));\n+    assert_eq!(c.size_hint(), (usize::MAX, None));\n     assert_eq!(vi.clone().size_hint(), (10, Some(10)));\n \n     assert_eq!(c.clone().take(5).size_hint(), (5, Some(5)));\n     assert_eq!(c.clone().skip(5).size_hint().1, None);\n     assert_eq!(c.clone().take_while(|_| false).size_hint(), (0, None));\n     assert_eq!(c.clone().skip_while(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.clone().enumerate().size_hint(), (uint::MAX, None));\n-    assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().enumerate().size_hint(), (usize::MAX, None));\n+    assert_eq!(c.clone().chain(vi.clone().cloned()).size_hint(), (usize::MAX, None));\n     assert_eq!(c.clone().zip(vi.clone()).size_hint(), (10, Some(10)));\n     assert_eq!(c.clone().scan(0, |_,_| Some(0)).size_hint(), (0, None));\n     assert_eq!(c.clone().filter(|_| false).size_hint(), (0, None));\n-    assert_eq!(c.clone().map(|_| 0).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.clone().map(|_| 0).size_hint(), (usize::MAX, None));\n     assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n \n     assert_eq!(vi.clone().take(5).size_hint(), (5, Some(5)));\n@@ -753,7 +753,7 @@ fn test_range() {\n \n     assert_eq!((0..100).size_hint(), (100, Some(100)));\n     // this test is only meaningful when sizeof uint < sizeof u64\n-    assert_eq!((uint::MAX - 1..uint::MAX).size_hint(), (1, Some(1)));\n+    assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n     assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n }"}, {"sha": "be8dfd02ee196bf25ea73f4603e49fc1e0b4ad01", "filename": "src/libcoretest/num/int.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcoretest%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcoretest%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint.rs?ref=157614249594f187f421cd97f928e64c5ab5c1fa", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-int_module!(int, int);"}, {"sha": "d1bfb475b074b41d2a38faebbccf16cffaf3ab09", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -12,7 +12,7 @@ macro_rules! int_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n-    use core::int;\n+    use core::isize;\n     use core::num::{FromStrRadix, Int, SignedInt};\n     use core::ops::{Shl, Shr, Not, BitXor, BitAnd, BitOr};\n     use num;\n@@ -153,7 +153,7 @@ mod tests {\n     fn test_signed_checked_div() {\n         assert!(10.checked_div(2) == Some(5));\n         assert!(5.checked_div(0) == None);\n-        assert!(int::MIN.checked_div(-1) == None);\n+        assert!(isize::MIN.checked_div(-1) == None);\n     }\n \n     #[test]"}, {"sha": "1cd1989c11dc3e5088cf210b06ff74965677d0e0", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -21,7 +21,6 @@ mod i8;\n mod i16;\n mod i32;\n mod i64;\n-mod int;\n \n #[macro_use]\n mod uint_macros;\n@@ -30,7 +29,6 @@ mod u8;\n mod u16;\n mod u32;\n mod u64;\n-mod uint;\n \n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where"}, {"sha": "395e55cf255d248bce8a47b2f69ee2a132d94657", "filename": "src/libcoretest/num/uint.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcoretest%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/157614249594f187f421cd97f928e64c5ab5c1fa/src%2Flibcoretest%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint.rs?ref=157614249594f187f421cd97f928e64c5ab5c1fa", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-uint_module!(uint, uint);"}, {"sha": "6240b0e6afdd50861f59ced7b8a752cd8dd626b9", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -963,7 +963,7 @@ fn test_split_within() {\n         \"little lamb\".to_string(),\n         \"Little lamb\".to_string()\n     ]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::usize::MAX,\n         &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n }\n "}, {"sha": "42143b06ca0e391678583b6e9cfced390ffa897c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -1115,7 +1115,6 @@ pub mod types {\n             pub mod posix88 {\n                 pub type off_t = i64;\n                 pub type dev_t = u32;\n-                pub type ino_t = u32;\n                 pub type pid_t = i32;\n                 pub type uid_t = u32;\n                 pub type gid_t = u32;"}, {"sha": "74d2c408060cbc2c595cd95678e4bbb409ad0468", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -12,18 +12,18 @@\n \n use core::prelude::*;\n use core::char;\n-use core::int;\n-use core::uint;\n+use core::isize;\n+use core::usize;\n \n use {Rand,Rng};\n \n-impl Rand for int {\n+impl Rand for isize {\n     #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> int {\n-        if int::BITS == 32 {\n-            rng.gen::<i32>() as int\n+    fn rand<R: Rng>(rng: &mut R) -> isize {\n+        if isize::BITS == 32 {\n+            rng.gen::<i32>() as isize\n         } else {\n-            rng.gen::<i64>() as int\n+            rng.gen::<i64>() as isize\n         }\n     }\n }\n@@ -56,13 +56,13 @@ impl Rand for i64 {\n     }\n }\n \n-impl Rand for uint {\n+impl Rand for usize {\n     #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> uint {\n-        if uint::BITS == 32 {\n-            rng.gen::<u32>() as uint\n+    fn rand<R: Rng>(rng: &mut R) -> usize {\n+        if usize::BITS == 32 {\n+            rng.gen::<u32>() as usize\n         } else {\n-            rng.gen::<u64>() as uint\n+            rng.gen::<u64>() as usize\n         }\n     }\n }"}, {"sha": "f635c77af9b2a1053bbc5d05f619b81d8ab60ae8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, m: &ast::TraitItem) {\n-        run_lints!(self, check_trait_method, m);\n+        run_lints!(self, check_trait_item, m);\n         visit::walk_trait_item(self, m);\n     }\n "}, {"sha": "506d20133bdc78e8679f1dd8253b7284cedea232", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -144,7 +144,7 @@ pub trait LintPass {\n     fn check_fn(&mut self, _: &Context,\n         _: FnKind, _: &ast::FnDecl, _: &ast::Block, _: Span, _: ast::NodeId) { }\n     fn check_ty_method(&mut self, _: &Context, _: &ast::TypeMethod) { }\n-    fn check_trait_method(&mut self, _: &Context, _: &ast::TraitItem) { }\n+    fn check_trait_item(&mut self, _: &Context, _: &ast::TraitItem) { }\n     fn check_struct_def(&mut self, _: &Context,\n         _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, _: ast::NodeId) { }\n     fn check_struct_def_post(&mut self, _: &Context,"}, {"sha": "5cb034667cc64ad9ffa982e4f753f37f63b8edc2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -51,8 +51,8 @@\n //! enclosing function.  On the way down the tree, it identifies those AST\n //! nodes and variable IDs that will be needed for the liveness analysis\n //! and assigns them contiguous IDs.  The liveness id for an AST node is\n-//! called a `live_node` (it's a newtype'd uint) and the id for a variable\n-//! is called a `variable` (another newtype'd uint).\n+//! called a `live_node` (it's a newtype'd usize) and the id for a variable\n+//! is called a `variable` (another newtype'd usize).\n //!\n //! On the way back up the tree, as we are about to exit from a function\n //! declaration we allocate a `liveness` instance.  Now that we know\n@@ -118,7 +118,7 @@ use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n-use std::{fmt, old_io, uint};\n+use std::{fmt, old_io, usize};\n use std::rc::Rc;\n use std::iter::repeat;\n use syntax::ast::{self, NodeId, Expr};\n@@ -138,17 +138,17 @@ enum LoopKind<'a> {\n }\n \n #[derive(Copy, PartialEq)]\n-struct Variable(uint);\n+struct Variable(usize);\n \n #[derive(Copy, PartialEq)]\n-struct LiveNode(uint);\n+struct LiveNode(usize);\n \n impl Variable {\n-    fn get(&self) -> uint { let Variable(v) = *self; v }\n+    fn get(&self) -> usize { let Variable(v) = *self; v }\n }\n \n impl LiveNode {\n-    fn get(&self) -> uint { let LiveNode(v) = *self; v }\n+    fn get(&self) -> usize { let LiveNode(v) = *self; v }\n }\n \n impl Clone for LiveNode {\n@@ -232,11 +232,11 @@ impl fmt::Debug for Variable {\n \n impl LiveNode {\n     fn is_valid(&self) -> bool {\n-        self.get() != uint::MAX\n+        self.get() != usize::MAX\n     }\n }\n \n-fn invalid_node() -> LiveNode { LiveNode(uint::MAX) }\n+fn invalid_node() -> LiveNode { LiveNode(usize::MAX) }\n \n struct CaptureInfo {\n     ln: LiveNode,\n@@ -260,8 +260,8 @@ enum VarKind {\n struct IrMaps<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n \n-    num_live_nodes: uint,\n-    num_vars: uint,\n+    num_live_nodes: usize,\n+    num_vars: usize,\n     live_node_map: NodeMap<LiveNode>,\n     variable_map: NodeMap<Variable>,\n     capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n@@ -540,9 +540,9 @@ struct Specials {\n     clean_exit_var: Variable\n }\n \n-static ACC_READ: uint = 1;\n-static ACC_WRITE: uint = 2;\n-static ACC_USE: uint = 4;\n+static ACC_READ: u32 = 1;\n+static ACC_WRITE: u32 = 2;\n+static ACC_USE: u32 = 4;\n \n struct Liveness<'a, 'tcx: 'a> {\n     ir: &'a mut IrMaps<'a, 'tcx>,\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         succ\n     }\n \n-    fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n+    fn idx(&self, ln: LiveNode, var: Variable) -> usize {\n         ln.get() * self.ir.num_vars + var.get()\n     }\n \n@@ -670,7 +670,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn indices2<F>(&mut self, ln: LiveNode, succ_ln: LiveNode, mut op: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, uint, uint),\n+        F: FnMut(&mut Liveness<'a, 'tcx>, usize, usize),\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n         let succ_base_idx = self.idx(succ_ln, Variable(0));\n@@ -684,7 +684,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                      ln: LiveNode,\n                      mut test: F)\n                      -> old_io::IoResult<()> where\n-        F: FnMut(uint) -> LiveNode,\n+        F: FnMut(usize) -> LiveNode,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in 0..self.ir.num_vars {\n@@ -807,7 +807,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n+    fn acc(&mut self, ln: LiveNode, var: Variable, acc: u32) {\n         debug!(\"{:?} accesses[{:x}] {:?}: {}\",\n                ln, acc, var, self.ln_str(ln));\n \n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n           ast::ExprPath(..) => {\n@@ -1298,7 +1298,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n           DefLocal(nid) => {"}, {"sha": "fe047d2334eecec5650e1fb346339ae2d5a309a0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 174, "deletions": 154, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -28,8 +28,6 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use self::MethodContext::*;\n-\n use metadata::{csearch, decoder};\n use middle::def::*;\n use middle::subst::Substs;\n@@ -228,7 +226,9 @@ impl LintPass for TypeLimits {\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n                                 let int_type = if let ast::TyIs(_) = t {\n                                     cx.sess().target.int_type\n-                                } else { t };\n+                                } else {\n+                                    t\n+                                };\n                                 let (min, max) = int_ty_range(int_type);\n                                 let negative = self.negated_expr_id == e.id;\n \n@@ -245,14 +245,16 @@ impl LintPass for TypeLimits {\n                     ty::ty_uint(t) => {\n                         let uint_type = if let ast::TyUs(_) = t {\n                             cx.sess().target.uint_type\n-                        } else { t };\n+                        } else {\n+                            t\n+                        };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n                             ast::LitByte(_v) => return,  // _v is u8, within range by definition\n                             ast::LitInt(v, _) => v,\n                             _ => panic!()\n                         };\n-                        if  lit_val < min || lit_val > max {\n+                        if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          &*format!(\"literal out of range for {:?}\", t));\n                         }\n@@ -262,9 +264,9 @@ impl LintPass for TypeLimits {\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n                             ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse().ok() {\n-                                    Some(f) => f,\n-                                    None => return\n+                                match v.parse() {\n+                                    Ok(f) => f,\n+                                    Err(_) => return\n                                 }\n                             }\n                             _ => panic!()\n@@ -302,52 +304,52 @@ impl LintPass for TypeLimits {\n             })\n         }\n \n-        // for int & uint, be conservative with the warnings, so that the\n+        // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs(_) =>    (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+                ast::TyIs(_) => (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n             }\n         }\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs(_) =>   (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 => (u64::MIN,         u64::MAX)\n+                ast::TyUs(_) => (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n             }\n         }\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                ast::TyF32  => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64  => (f64::MIN,        f64::MAX)\n+                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64 => (f64::MIN,        f64::MAX)\n             }\n         }\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs(_) =>    int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>   i8::BITS  as u64,\n-                ast::TyI16 =>  i16::BITS as u64,\n-                ast::TyI32 =>  i32::BITS as u64,\n-                ast::TyI64 =>  i64::BITS as u64\n+                ast::TyIs(_) => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyI8 =>    i8::BITS  as u64,\n+                ast::TyI16 =>   i16::BITS as u64,\n+                ast::TyI32 =>   i32::BITS as u64,\n+                ast::TyI64 =>   i64::BITS as u64\n             }\n         }\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs(_) =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>   u8::BITS  as u64,\n-                ast::TyU16 =>  u16::BITS as u64,\n-                ast::TyU32 =>  u32::BITS as u64,\n-                ast::TyU64 =>  u64::BITS as u64\n+                ast::TyUs(_) => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyU8 =>    u8::BITS  as u64,\n+                ast::TyU16 =>   u16::BITS as u64,\n+                ast::TyU32 =>   u32::BITS as u64,\n+                ast::TyU64 =>   u64::BITS as u64\n             }\n         }\n \n@@ -360,7 +362,11 @@ impl LintPass for TypeLimits {\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n-            let norm_binop = if swap { rev_binop(binop) } else { binop };\n+            let norm_binop = if swap {\n+                rev_binop(binop)\n+            } else {\n+                binop\n+            };\n             match ty::expr_ty(tcx, expr).sty {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n@@ -432,9 +438,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {\n                     self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                      \"found type without foreign-function-safe\n-                                      representation annotation in foreign module, consider \\\n-                                      adding a #[repr(...)] attribute to the type\");\n+                                      \"found type without foreign-function-safe \\\n+                                       representation annotation in foreign module, consider \\\n+                                       adding a #[repr(...)] attribute to the type\");\n                 }\n             }\n             _ => ()\n@@ -595,15 +601,15 @@ impl LintPass for RawPointerDerive {\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n-            return\n+            return;\n         }\n         let did = match item.node {\n             ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n                 if let &Some(ref trait_ref) = t_ref_opt {\n                     let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n                     if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n-                        return\n+                        return;\n                     }\n                 }\n \n@@ -615,12 +621,16 @@ impl LintPass for RawPointerDerive {\n             }\n             _ => return,\n         };\n-        if !ast_util::is_local(did) { return }\n+        if !ast_util::is_local(did) {\n+            return;\n+        }\n         let item = match cx.tcx.map.find(did.node) {\n             Some(ast_map::NodeItem(item)) => item,\n             _ => return,\n         };\n-        if !self.checked_raw_pointers.insert(item.id) { return }\n+        if !self.checked_raw_pointers.insert(item.id) {\n+            return;\n+        }\n         match item.node {\n             ast::ItemStruct(..) | ast::ItemEnum(..) => {\n                 let mut visitor = RawPtrDeriveVisitor { cx: cx };\n@@ -646,6 +656,7 @@ impl LintPass for UnusedAttributes {\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+        // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty) in KNOWN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted\n@@ -730,23 +741,24 @@ impl LintPass for UnusedResults {\n         }\n \n         let t = ty::expr_ty(cx.tcx, expr);\n-        let mut warned = false;\n-        match t.sty {\n+        let warned = match t.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => return,\n             ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, &it.attrs, s.span);\n+                        check_must_use(cx, &it.attrs, s.span)\n+                    } else {\n+                        false\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n-                    warned |= check_must_use(cx, &attrs[..], s.span);\n+                    check_must_use(cx, &attrs[..], s.span)\n                 }\n             }\n-            _ => {}\n-        }\n+            _ => false,\n+        };\n         if !warned {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n@@ -785,7 +797,9 @@ impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n+            if ident.is_empty() {\n+                return true;\n+            }\n             let ident = ident.trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n@@ -795,8 +809,11 @@ impl NonCamelCaseTypes {\n \n         fn to_camel_case(s: &str) -> String {\n             s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 { c.to_uppercase() }\n-                else { c }\n+                if i == 0 {\n+                    c.to_uppercase()\n+                } else {\n+                    c\n+                }\n             )).collect()\n         }\n \n@@ -820,11 +837,13 @@ impl LintPass for NonCamelCaseTypes {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let has_extern_repr = it.attrs.iter().map(|attr| {\n+        let has_extern_repr = it.attrs.iter().any(|attr| {\n             attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n                 .any(|r| r == &attr::ReprExtern)\n-        }).any(|x| x);\n-        if has_extern_repr { return }\n+        });\n+        if has_extern_repr {\n+            return;\n+        }\n \n         match it.node {\n             ast::ItemTy(..) | ast::ItemStruct(..) => {\n@@ -834,7 +853,9 @@ impl LintPass for NonCamelCaseTypes {\n                 self.check_case(cx, \"trait\", it.ident, it.span)\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr { return }\n+                if has_extern_repr {\n+                    return;\n+                }\n                 self.check_case(cx, \"type\", it.ident, it.span);\n                 for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n@@ -866,32 +887,28 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n \n     match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n         None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(md) => {\n-            match md {\n-                ty::MethodTraitItem(md) => {\n-                    match md.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n+        Some(ty::MethodTraitItem(md)) => {\n+            match md.container {\n+                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => MethodContext::TraitImpl,\n+                        None => MethodContext::PlainImpl\n                     }\n                 }\n-                ty::TypeTraitItem(typedef) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n+            }\n+        },\n+        Some(ty::TypeTraitItem(typedef)) => {\n+            match typedef.container {\n+                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => MethodContext::TraitImpl,\n+                        None => MethodContext::PlainImpl\n                     }\n                 }\n             }\n-        }\n+        },\n     }\n }\n \n@@ -912,12 +929,16 @@ impl NonSnakeCase {\n             if c == '_' {\n                 words.push(String::new());\n                 true\n-            } else { false }\n+            } else {\n+                false\n+            }\n         });\n         for s in str.split('_') {\n             let mut last_upper = false;\n             let mut buf = String::new();\n-            if s.is_empty() { continue; }\n+            if s.is_empty() {\n+                continue;\n+            }\n             for ch in s.chars() {\n                 if !buf.is_empty() && buf != \"'\"\n                                    && ch.is_uppercase()\n@@ -936,7 +957,9 @@ impl NonSnakeCase {\n     fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n+            if ident.is_empty() {\n+                return true;\n+            }\n             let ident = ident.trim_left_matches('\\'');\n             let ident = ident.trim_matches('_');\n \n@@ -979,14 +1002,17 @@ impl LintPass for NonSnakeCase {\n                 _: &ast::Block, span: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n-                PlainImpl\n-                    => self.check_snake_case(cx, \"method\", ident, span),\n-                TraitDefaultImpl\n-                    => self.check_snake_case(cx, \"trait method\", ident, span),\n+                MethodContext::PlainImpl => {\n+                    self.check_snake_case(cx, \"method\", ident, span)\n+                },\n+                MethodContext::TraitDefaultImpl => {\n+                    self.check_snake_case(cx, \"trait method\", ident, span)\n+                },\n                 _ => (),\n             },\n-            visit::FkItemFn(ident, _, _, _)\n-                => self.check_snake_case(cx, \"function\", ident, span),\n+            visit::FkItemFn(ident, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", ident, span)\n+            },\n             _ => (),\n         }\n     }\n@@ -1015,7 +1041,7 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n-            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+                        _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n             if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", ident, sf.span);\n@@ -1094,13 +1120,12 @@ pub struct UnusedParens;\n \n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n-                                     struct_lit_needs_parens: bool) {\n+                                struct_lit_needs_parens: bool) {\n         if let ast::ExprParen(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n-                             &format!(\"unnecessary parentheses around {}\",\n-                                     msg))\n+                             &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n \n@@ -1193,26 +1218,17 @@ impl LintPass for UnusedImportBraces {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ast::ViewPathList(_, ref items) => {\n-                        if items.len() == 1 {\n-                            match items[0].node {\n-                                ast::PathListIdent {ref name, ..} => {\n-                                    let m = format!(\"braces around {} is unnecessary\",\n-                                                    &token::get_ident(*name));\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                                 &m[..]);\n-                                },\n-                                _ => ()\n-                            }\n-                        }\n+        if let ast::ItemUse(ref view_path) = item.node {\n+            if let ast::ViewPathList(_, ref items) = view_path.node {\n+                if items.len() == 1 {\n+                    if let ast::PathListIdent {ref name, ..} = items[0].node {\n+                        let m = format!(\"braces around {} is unnecessary\",\n+                                        &token::get_ident(*name));\n+                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n+                                     &m[..]);\n                     }\n-                    _ => ()\n                 }\n-            },\n-            _ => ()\n+            }\n         }\n     }\n }\n@@ -1234,9 +1250,10 @@ impl LintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let ast::PatStruct(_, ref v, _) = pat.node {\n-            let field_pats = v.iter()\n-                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                              .filter(|fieldpat| {\n+            let field_pats = v.iter().filter(|fieldpat| {\n+                if fieldpat.node.is_shorthand {\n+                    return false;\n+                }\n                 let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n                 def == Some(def::DefLocal(fieldpat.node.pat.id))\n             });\n@@ -1482,10 +1499,14 @@ impl MissingDoc {\n                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n-        if cx.sess().opts.test { return }\n+        if cx.sess().opts.test {\n+            return;\n+        }\n \n         // `#[doc(hidden)]` disables missing_docs check.\n-        if self.doc_hidden() { return }\n+        if self.doc_hidden() {\n+            return;\n+        }\n \n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n@@ -1504,7 +1525,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                &format!(\"missing documentation for {}\", desc));\n+                         &format!(\"missing documentation for {}\", desc));\n         }\n     }\n }\n@@ -1528,20 +1549,19 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def(&mut self, _: &Context, _: &ast::StructDef,\n+                        _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self, _: &Context, _: &ast::StructDef,\n+                             _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n-                                     krate.span, \"crate\");\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -1554,30 +1574,28 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n-                                     it.span, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n-            fk: visit::FnKind, _: &ast::FnDecl,\n-            _: &ast::Block, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, _: Span, _: ast::NodeId) {\n         if let visit::FkMethod(_, _, m) = fk {\n             // If the method is an impl for a trait, don't doc.\n-            if method_context(cx, m) == TraitImpl { return; }\n+            if method_context(cx, m) == MethodContext::TraitImpl {\n+                return;\n+            }\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n-                                          m.span, \"a method\");\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs, m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n-                                     tm.span, \"a type method\");\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs, tm.span, \"a type method\");\n     }\n \n-    fn check_trait_method(&mut self, cx: &Context, it: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &Context, it: &ast::TraitItem) {\n         if let ast::TraitItem::TypeTraitItem(ref ty) = *it {\n             let assoc_ty = &ty.ty_param;\n             self.check_missing_docs_attrs(cx, Some(assoc_ty.id), &ty.attrs,\n@@ -1598,8 +1616,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n-                                     v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n@@ -1626,26 +1643,26 @@ impl LintPass for MissingCopyImplementations {\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         if !cx.exported_items.contains(&item.id) {\n-            return\n+            return;\n         }\n         if cx.tcx\n              .destructor_for_type\n              .borrow()\n              .contains_key(&ast_util::local_def(item.id)) {\n-            return\n+            return;\n         }\n         let ty = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n-                    return\n+                    return;\n                 }\n                 ty::mk_struct(cx.tcx,\n                               ast_util::local_def(item.id),\n                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n-                    return\n+                    return;\n                 }\n                 ty::mk_enum(cx.tcx,\n                             ast_util::local_def(item.id),\n@@ -1655,7 +1672,7 @@ impl LintPass for MissingCopyImplementations {\n         };\n         let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n         if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n-            return\n+            return;\n         }\n         if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n@@ -1709,10 +1726,10 @@ impl LintPass for MissingDebugImplementations {\n             let impls = match impls.get(&debug) {\n                 Some(impls) => {\n                     impls.borrow().iter()\n-                        .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                        .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                        .map(|d| d.node)\n-                        .collect()\n+                         .filter(|d| d.krate == ast::LOCAL_CRATE)\n+                         .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n+                         .map(|d| d.node)\n+                         .collect()\n                 }\n                 None => NodeSet(),\n             };\n@@ -1741,8 +1758,7 @@ pub struct Stability;\n \n impl Stability {\n     fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n-\n-        // deprecated attributes apply in-crate and cross-crate\n+        // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n             Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n@@ -1857,25 +1873,27 @@ impl LintPass for UnconditionalRecursion {\n         let mut visited = BitSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n-            let cfg_id = idx.node_id();\n             if idx == cfg.exit {\n                 // found a path!\n                 reached_exit_without_self_call = true;\n-                break\n-            } else if visited.contains(&cfg_id) {\n+                break;\n+            }\n+\n+            let cfg_id = idx.node_id();\n+            if visited.contains(&cfg_id) {\n                 // already done\n-                continue\n+                continue;\n             }\n             visited.insert(cfg_id);\n+\n             let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n             if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n-\n                 self_call_spans.push(cx.tcx.map.span(node_id));\n                 // this is a self call, so we shouldn't explore past\n                 // this node in the CFG.\n-                continue\n+                continue;\n             }\n             // add the successors of this node to explore the graph further.\n             cfg.graph.each_outgoing_edge(idx, |_, edge| {\n@@ -1888,7 +1906,7 @@ impl LintPass for UnconditionalRecursion {\n             });\n         }\n \n-        // check the number of sell calls because a function that\n+        // Check the number of self calls because a function that\n         // doesn't return (e.g. calls a `-> !` function or `loop { /*\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n@@ -1920,7 +1938,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n+               .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`\n@@ -1962,7 +1980,7 @@ impl LintPass for UnconditionalRecursion {\n                                 tcx.map.span(id),\n                                 \"non-method call expr behaving like a method call?\")\n                         };\n-                        // it matches if it comes from the same impl,\n+                        // It matches if it comes from the same impl,\n                         // and has the same method name.\n                         return ast_util::is_local(impl_def_id)\n                             && impl_def_id.node == impl_id\n@@ -2013,7 +2031,7 @@ impl LintPass for PluginAsLibrary {\n \n         if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n             cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n-                \"compiler plugin used as an ordinary library\");\n+                         \"compiler plugin used as an ordinary library\");\n         }\n     }\n }\n@@ -2069,7 +2087,7 @@ impl LintPass for InvalidNoMangleItems {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle], consider instead using \\\n-                        `pub static`\";\n+                               `pub static`\";\n                     cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n                 }\n             }\n@@ -2082,15 +2100,17 @@ impl LintPass for InvalidNoMangleItems {\n #[derive(Copy)]\n pub struct UnstableFeatures;\n \n-declare_lint!(UNSTABLE_FEATURES, Allow,\n-              \"enabling unstable features\");\n+declare_lint! {\n+    UNSTABLE_FEATURES,\n+    Allow,\n+    \"enabling unstable features\"\n+}\n \n impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n     fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n-        use syntax::attr;\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             ctx.span_lint(UNSTABLE_FEATURES, attr.span, \"unstable feature\");\n         }"}, {"sha": "2ab6f5b0f952178b3637b9998fdb3d290b207c55", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -789,7 +789,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n \n         // Irrefutable columns always go first, they'd only be duplicated in the branches.\n         if total_score == 0 {\n-            std::uint::MAX\n+            std::usize::MAX\n         } else {\n             total_score\n         }"}, {"sha": "1f578ac0bdbab2b8d80d354d73af7934cec02137", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -2435,21 +2435,19 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     use middle::ty::{BrAnon, ReLateBound};\n \n     let function_type;\n-    let (fn_sig, abi, has_env) = match fn_ty.sty {\n-        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, false),\n+    let (fn_sig, abi, env_ty) = match fn_ty.sty {\n+        ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n         ty::ty_closure(closure_did, _, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n-            (&function_type.sig, RustCall, true)\n+            let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n+            (&function_type.sig, RustCall, Some(self_type))\n         }\n         _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n \n-    // Since index 0 is the return value of the llvm func, we start\n-    // at either 1 or 2 depending on whether there's an env slot or not\n-    let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n     let ret_ty = fn_sig.output;\n \n@@ -2460,7 +2458,11 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n             assert!(abi == RustCall);\n \n             match fn_sig.inputs[0].sty {\n-                ty::ty_tup(ref inputs) => inputs.clone(),\n+                ty::ty_tup(ref inputs) => {\n+                    let mut full_inputs = vec![env_ty.expect(\"Missing closure environment\")];\n+                    full_inputs.push_all(inputs);\n+                    full_inputs\n+                }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n@@ -2478,6 +2480,8 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n         _ => fn_sig.inputs.clone()\n     };\n \n+    // Index 0 is the return value of the llvm func, so we start at 1\n+    let mut first_arg_offset = 1;\n     if let ty::FnConverging(ret_ty) = ret_ty {\n         // A function pointer is called without the declaration\n         // available, so we have to apply any attributes with ABI"}, {"sha": "861233bafdfac01405d6a51f847d5af276bcc7ab", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -603,7 +603,18 @@ pub fn trans_method_call<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_expr={})\", call_expr.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_expr.id);\n-    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n+    let method_ty = match bcx.tcx().method_map.borrow().get(&method_call) {\n+        Some(method) => match method.origin {\n+            ty::MethodTraitObject(_) => match method.ty.sty {\n+                ty::ty_bare_fn(_, ref fty) => {\n+                    ty::mk_bare_fn(bcx.tcx(), None, meth::opaque_method_ty(bcx.tcx(), fty))\n+                }\n+                _ => method.ty\n+            },\n+            _ => method.ty\n+        },\n+        None => panic!(\"method not found in trans_method_call\")\n+    };\n     trans_call_inner(\n         bcx,\n         call_expr.debug_loc(),\n@@ -927,20 +938,21 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                                                           tuple_expr.id));\n             let repr = adt::represent_type(bcx.ccx(), tuple_type);\n             let repr_ptr = &*repr;\n-            for i in 0..field_types.len() {\n+            llargs.extend(field_types.iter().enumerate().map(|(i, field_type)| {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n-                    field_types[i],\n+                    field_type,\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n-                    });\n-                let arg_datum = arg_datum.to_expr_datum();\n-                let arg_datum =\n-                    unpack_datum!(bcx, arg_datum.to_rvalue_datum(bcx, \"arg\"));\n-                let arg_datum =\n-                    unpack_datum!(bcx, arg_datum.to_appropriate_datum(bcx));\n-                llargs.push(arg_datum.add_clean(bcx.fcx, arg_cleanup_scope));\n-            }\n+                    }).to_expr_datum();\n+                unpack_result!(bcx, trans_arg_datum(\n+                    bcx,\n+                    field_type,\n+                    arg_datum,\n+                    arg_cleanup_scope,\n+                    DontAutorefArg)\n+                )\n+            }));\n         }\n         _ => {\n             bcx.sess().span_bug(tuple_expr.span,"}, {"sha": "67f1c39c6e094f114d4f2b7a423bc1e6557442cb", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -589,15 +589,16 @@ pub fn trans_object_shim<'a, 'tcx>(\n     };\n     let fty = monomorphize::apply_param_substs(tcx, &object_substs, &method_ty.fty);\n     let fty = tcx.mk_bare_fn(fty);\n-    debug!(\"trans_object_shim: fty={}\", fty.repr(tcx));\n+    let method_ty = opaque_method_ty(tcx, fty);\n+    debug!(\"trans_object_shim: fty={} method_ty={}\", fty.repr(tcx), method_ty.repr(tcx));\n \n     //\n-    let method_bare_fn_ty =\n-        ty::mk_bare_fn(tcx, None, fty);\n+    let shim_fn_ty = ty::mk_bare_fn(tcx, None, fty);\n+    let method_bare_fn_ty = ty::mk_bare_fn(tcx, None, method_ty);\n     let function_name =\n-        link::mangle_internal_name_by_type_and_seq(ccx, method_bare_fn_ty, \"object_shim\");\n+        link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n     let llfn =\n-        decl_internal_rust_fn(ccx, method_bare_fn_ty, &function_name);\n+        decl_internal_rust_fn(ccx, shim_fn_ty, &function_name);\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n@@ -866,3 +867,20 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     bcx\n }\n+\n+/// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n+pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n+        -> &'tcx ty::BareFnTy<'tcx> {\n+    let mut inputs = method_ty.sig.0.inputs.clone();\n+    inputs[0] = ty::mk_mut_ptr(tcx, ty::mk_mach_int(tcx, ast::TyI8));\n+\n+    tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: method_ty.unsafety,\n+        abi: method_ty.abi,\n+        sig: ty::Binder(ty::FnSig {\n+            inputs: inputs,\n+            output: method_ty.sig.0.output,\n+            variadic: method_ty.sig.0.variadic,\n+        }),\n+    })\n+}"}, {"sha": "cffd74ccd7218c3da9458131a756bfd3e1578cb6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 123, "deletions": 23, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -14,8 +14,9 @@ use middle::infer;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use util::ppaux::{Repr};\n+use util::ppaux::{Repr, UserString};\n \n+use syntax::ast;\n use syntax::codemap::Span;\n \n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n@@ -28,29 +29,98 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n     // types that have been traversed so far by `traverse_type_if_unseen`\n     let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n \n-    iterate_over_potentially_unsafe_regions_in_type(\n+    let result = iterate_over_potentially_unsafe_regions_in_type(\n         rcx,\n         &mut breadcrumbs,\n+        TypeContext::Root,\n         typ,\n         span,\n         scope,\n+        0,\n         0);\n+    match result {\n+        Ok(()) => {}\n+        Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n+            let tcx = rcx.tcx();\n+            span_err!(tcx.sess, span, E0320,\n+                      \"overflow while adding drop-check rules for {}\",\n+                      typ.user_string(rcx.tcx()));\n+            match *ctxt {\n+                TypeContext::Root => {\n+                    // no need for an additional note if the overflow\n+                    // was somehow on the root.\n+                }\n+                TypeContext::EnumVariant { def_id, variant, arg_index } => {\n+                    // FIXME (pnkfelix): eventually lookup arg_name\n+                    // for the given index on struct variants.\n+                    span_note!(\n+                        rcx.tcx().sess,\n+                        span,\n+                        \"overflowed on enum {} variant {} argument {} type: {}\",\n+                        ty::item_path_str(tcx, def_id),\n+                        variant,\n+                        arg_index,\n+                        detected_on_typ.user_string(rcx.tcx()));\n+                }\n+                TypeContext::Struct { def_id, field } => {\n+                    span_note!(\n+                        rcx.tcx().sess,\n+                        span,\n+                        \"overflowed on struct {} field {} type: {}\",\n+                        ty::item_path_str(tcx, def_id),\n+                        field,\n+                        detected_on_typ.user_string(rcx.tcx()));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+enum Error<'tcx> {\n+    Overflow(TypeContext, ty::Ty<'tcx>),\n+}\n+\n+enum TypeContext {\n+    Root,\n+    EnumVariant {\n+        def_id: ast::DefId,\n+        variant: ast::Name,\n+        arg_index: usize,\n+    },\n+    Struct {\n+        def_id: ast::DefId,\n+        field: ast::Name,\n+    }\n }\n \n+// The `depth` counts the number of calls to this function;\n+// the `xref_depth` counts the subset of such calls that go\n+// across a `Box<T>` or `PhantomData<T>`.\n fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     rcx: &mut Rcx<'a, 'tcx>,\n     breadcrumbs: &mut Vec<Ty<'tcx>>,\n+    context: TypeContext,\n     ty_root: ty::Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent,\n-    depth: uint)\n+    depth: uint,\n+    xref_depth: uint) -> Result<(), Error<'tcx>>\n {\n+    // Issue #22443: Watch out for overflow. While we are careful to\n+    // handle regular types properly, non-regular ones cause problems.\n+    let recursion_limit = rcx.tcx().sess.recursion_limit.get();\n+    if xref_depth >= recursion_limit {\n+        return Err(Error::Overflow(context, ty_root))\n+    }\n+\n     let origin = || infer::SubregionOrigin::SafeDestructor(span);\n     let mut walker = ty_root.walk();\n     let opt_phantom_data_def_id = rcx.tcx().lang_items.phantom_data();\n \n     let destructor_for_type = rcx.tcx().destructor_for_type.borrow();\n \n+    let xref_depth_orig = xref_depth;\n+\n     while let Some(typ) = walker.next() {\n         // Avoid recursing forever.\n         if breadcrumbs.contains(&typ) {\n@@ -61,20 +131,33 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         // If we encounter `PhantomData<T>`, then we should replace it\n         // with `T`, the type it represents as owned by the\n         // surrounding context, before doing further analysis.\n-        let typ = if let ty::ty_struct(struct_did, substs) = typ.sty {\n-            if opt_phantom_data_def_id == Some(struct_did) {\n-                let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n-                let tp_def = item_type.generics.types\n-                    .opt_get(subst::TypeSpace, 0).unwrap();\n-                let new_typ = substs.type_for_def(tp_def);\n-                debug!(\"replacing phantom {} with {}\",\n+        let (typ, xref_depth) = match typ.sty {\n+            ty::ty_struct(struct_did, substs) => {\n+                if opt_phantom_data_def_id == Some(struct_did) {\n+                    let item_type = ty::lookup_item_type(rcx.tcx(), struct_did);\n+                    let tp_def = item_type.generics.types\n+                        .opt_get(subst::TypeSpace, 0).unwrap();\n+                    let new_typ = substs.type_for_def(tp_def);\n+                    debug!(\"replacing phantom {} with {}\",\n+                           typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n+                    (new_typ, xref_depth_orig + 1)\n+                } else {\n+                    (typ, xref_depth_orig)\n+                }\n+            }\n+\n+            // Note: When ty_uniq is removed from compiler, the\n+            // definition of `Box<T>` must carry a PhantomData that\n+            // puts us into the previous case.\n+            ty::ty_uniq(new_typ) => {\n+                debug!(\"replacing ty_uniq {} with {}\",\n                        typ.repr(rcx.tcx()), new_typ.repr(rcx.tcx()));\n-                new_typ\n-            } else {\n-                typ\n+                (new_typ, xref_depth_orig + 1)\n+            }\n+\n+            _ => {\n+                (typ, xref_depth_orig)\n             }\n-        } else {\n-            typ\n         };\n \n         let opt_type_did = match typ.sty {\n@@ -87,9 +170,9 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             opt_type_did.and_then(|did| destructor_for_type.get(&did));\n \n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} opt_dtor: {:?}\",\n+                {}typ: {} scope: {:?} opt_dtor: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, opt_dtor);\n+               typ.repr(rcx.tcx()), scope, opt_dtor, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -228,6 +311,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             match typ.sty {\n                 ty::ty_struct(struct_did, substs) => {\n+                    debug!(\"typ: {} is struct; traverse structure and not type-expression\",\n+                           typ.repr(rcx.tcx()));\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -240,17 +325,24 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                                                   struct_did,\n                                                   field.id,\n                                                   substs);\n-                        iterate_over_potentially_unsafe_regions_in_type(\n+                        try!(iterate_over_potentially_unsafe_regions_in_type(\n                             rcx,\n                             breadcrumbs,\n+                            TypeContext::Struct {\n+                                def_id: struct_did,\n+                                field: field.name,\n+                            },\n                             field_type,\n                             span,\n                             scope,\n-                            depth+1)\n+                            depth+1,\n+                            xref_depth))\n                     }\n                 }\n \n                 ty::ty_enum(enum_did, substs) => {\n+                    debug!(\"typ: {} is enum; traverse structure and not type-expression\",\n+                           typ.repr(rcx.tcx()));\n                     // Don't recurse; we extract type's substructure,\n                     // so do not process subparts of type expression.\n                     walker.skip_current_subtree();\n@@ -260,14 +352,20 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n                                                  enum_did,\n                                                  substs);\n                     for variant_info in all_variant_info.iter() {\n-                        for argument_type in variant_info.args.iter() {\n-                            iterate_over_potentially_unsafe_regions_in_type(\n+                        for (i, arg_type) in variant_info.args.iter().enumerate() {\n+                            try!(iterate_over_potentially_unsafe_regions_in_type(\n                                 rcx,\n                                 breadcrumbs,\n-                                *argument_type,\n+                                TypeContext::EnumVariant {\n+                                    def_id: enum_did,\n+                                    variant: variant_info.name,\n+                                    arg_index: i,\n+                                },\n+                                *arg_type,\n                                 span,\n                                 scope,\n-                                depth+1)\n+                                depth+1,\n+                                xref_depth));\n                         }\n                     }\n                 }\n@@ -290,4 +388,6 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             // is done.\n         }\n     }\n+\n+    return Ok(());\n }"}, {"sha": "3bd15fbc7dbea774fb55ebad140bd1ab85fed0ff", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -174,7 +174,8 @@ register_diagnostics! {\n     E0249, // expected constant expr for array length\n     E0250, // expected constant expr for array length\n     E0318, // can't create default impls for traits outside their crates\n-    E0319  // trait impls for defaulted traits allowed just for structs/enums\n+    E0319, // trait impls for defaulted traits allowed just for structs/enums\n+    E0320  // recursive overflow during dropck\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "7957bc35b76b5c3e90507df79c6b624e9b2c6326", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -109,7 +109,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n+#![feature(hash)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(linkage, thread_local, asm)]\n@@ -221,14 +221,12 @@ mod int_macros;\n mod uint_macros;\n \n #[path = \"num/isize.rs\"]  pub mod isize;\n-pub use isize as int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n #[path = \"num/i16.rs\"]  pub mod i16;\n #[path = \"num/i32.rs\"]  pub mod i32;\n #[path = \"num/i64.rs\"]  pub mod i64;\n \n #[path = \"num/usize.rs\"] pub mod usize;\n-pub use usize as uint;\n #[path = \"num/u8.rs\"]   pub mod u8;\n #[path = \"num/u16.rs\"]  pub mod u16;\n #[path = \"num/u32.rs\"]  pub mod u32;"}, {"sha": "f09688538198905d2ba88ccfb823c1d76941ca26", "filename": "src/test/compile-fail/dropck_no_diverge_on_nonregular_1.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_1.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 22443: Reject code using non-regular types that would\n+// otherwise cause dropck to loop infinitely.\n+\n+use std::marker::PhantomData;\n+\n+struct Digit<T> {\n+    elem: T\n+}\n+\n+struct Node<T:'static> { m: PhantomData<&'static T> }\n+\n+\n+enum FingerTree<T:'static> {\n+    Single(T),\n+    // Bug report said Digit after Box would stack overflow (versus\n+    // Digit before Box; see dropck_no_diverge_on_nonregular_2).\n+    Deep(\n+        Box<FingerTree<Node<T>>>,\n+        Digit<T>,\n+        )\n+}\n+\n+fn main() {\n+    let ft = //~ ERROR overflow while adding drop-check rules for FingerTree\n+        FingerTree::Single(1);\n+    //~^ ERROR overflow while adding drop-check rules for FingerTree\n+}"}, {"sha": "886bd6bea20d785f4e1a2c90e95058c3b7aa288c", "filename": "src/test/compile-fail/dropck_no_diverge_on_nonregular_2.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_2.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 22443: Reject code using non-regular types that would\n+// otherwise cause dropck to loop infinitely.\n+\n+use std::marker::PhantomData;\n+\n+struct Digit<T> {\n+    elem: T\n+}\n+\n+struct Node<T:'static> { m: PhantomData<&'static T> }\n+\n+enum FingerTree<T:'static> {\n+    Single(T),\n+    // Bug report said Digit before Box would infinite loop (versus\n+    // Digit after Box; see dropck_no_diverge_on_nonregular_1).\n+    Deep(\n+        Digit<T>,\n+        Box<FingerTree<Node<T>>>,\n+        )\n+}\n+\n+fn main() {\n+    let ft = //~ ERROR overflow while adding drop-check rules for FingerTree\n+        FingerTree::Single(1);\n+    //~^ ERROR overflow while adding drop-check rules for FingerTree\n+}"}, {"sha": "f7eb6e10ca78827cc9f7a09ed263ebab99e56cdc", "filename": "src/test/compile-fail/dropck_no_diverge_on_nonregular_3.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_no_diverge_on_nonregular_3.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 22443: Reject code using non-regular types that would\n+// otherwise cause dropck to loop infinitely.\n+//\n+// This version is just checking that we still sanely handle a trivial\n+// wrapper around the non-regular type. (It also demonstrates how the\n+// error messages will report different types depending on which type\n+// dropck is analyzing.)\n+\n+use std::marker::PhantomData;\n+\n+struct Digit<T> {\n+    elem: T\n+}\n+\n+struct Node<T:'static> { m: PhantomData<&'static T> }\n+\n+enum FingerTree<T:'static> {\n+    Single(T),\n+    // According to the bug report, Digit before Box would infinite loop.\n+    Deep(\n+        Digit<T>,\n+        Box<FingerTree<Node<T>>>,\n+        )\n+}\n+\n+enum Wrapper<T:'static> {\n+    Simple,\n+    Other(FingerTree<T>),\n+}\n+\n+fn main() {\n+    let w = //~ ERROR overflow while adding drop-check rules for core::option\n+        Some(Wrapper::Simple::<u32>);\n+    //~^ ERROR overflow while adding drop-check rules for core::option::Option\n+    //~| ERROR overflow while adding drop-check rules for Wrapper\n+}"}, {"sha": "9c2e8d278ab0b8310db1190bd21c2ee27c824730", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{int, i8, i16, i32, i64};\n+use std::{isize, i8, i16, i32, i64};\n use std::thread;\n \n fn main() {\n-    assert!(thread::spawn(move|| { int::MIN / -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n     assert!(thread::spawn(move|| { i8::MIN / -1; }).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n@@ -32,7 +32,7 @@ fn main() {\n     //~^ ERROR attempted to divide by zero in a constant expression\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(thread::spawn(move|| { int::MIN % -1; }).join().is_err());\n+    assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression"}, {"sha": "5f3744712ccb4c2b5b2049b70533ec4bdfe8e9c7", "filename": "src/test/compile-fail/unnecessary-private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-private.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    pub use std::uint; //~ ERROR: visibility has no effect\n+    pub use std::usize; //~ ERROR: visibility has no effect\n     pub struct A; //~ ERROR: visibility has no effect\n     pub enum B {} //~ ERROR: visibility has no effect\n     pub trait C { //~ ERROR: visibility has no effect"}, {"sha": "c15c4b83828a34bff88dde7f2c43eea5a36535b8", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -10,10 +10,10 @@\n \n // error-pattern:index out of bounds: the len is 3 but the index is\n \n-use std::uint;\n+use std::usize;\n use std::mem::size_of;\n \n fn main() {\n     let xs = [1, 2, 3];\n-    xs[uint::MAX / size_of::<int>() + 1];\n+    xs[usize::MAX / size_of::<isize>() + 1];\n }"}, {"sha": "2c7c0875227d9baeddb83028f6bf45cf2c6290d8", "filename": "src/test/run-fail/hashmap-capacity-overflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fhashmap-capacity-overflow.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -11,11 +11,11 @@\n // error-pattern:capacity overflow\n \n use std::collections::hash_map::HashMap;\n-use std::uint;\n+use std::usize;\n use std::mem::size_of;\n \n fn main() {\n-    let threshold = uint::MAX / size_of::<(u64, u64, u64)>();\n+    let threshold = usize::MAX / size_of::<(u64, u64, u64)>();\n     let mut h = HashMap::<u64, u64>::with_capacity(threshold + 100);\n     h.insert(0, 0);\n }"}, {"sha": "82543f543da839b73ffd3cf95631a5d38cba7a3f", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// DON'T REENABLE THIS UNLESS YOU'VE ACTUALLY FIXED THE UNDERLYING ISSUE\n+// ignore-android seems to block forever\n \n #![forbid(warnings)]\n "}, {"sha": "cab33beda405f619afc786f6b5c94c64e99a2475", "filename": "src/test/run-pass/issue-22777.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fissue-22777.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fissue-22777.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22777.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is reduced from libsyntax.  It is just checking that we\n+// can successfully deal with a \"deep\" structure, which the drop-check\n+// was hitting a recursion limit on at one point.\n+\n+#![allow(non_camel_case_types)]\n+\n+pub fn noop_fold_impl_item() -> SmallVector<ImplItem> {\n+    loop  { }\n+}\n+\n+pub struct SmallVector<T>(P<T>);\n+pub struct ImplItem(P<S01_Method>);\n+\n+struct P<T>(Box<T>);\n+\n+struct S01_Method(P<S02_Generics>);\n+struct S02_Generics(P<S03_TyParam>);\n+struct S03_TyParam(P<S04_TyParamBound>);\n+struct S04_TyParamBound(S05_PolyTraitRef);\n+struct S05_PolyTraitRef(S06_TraitRef);\n+struct S06_TraitRef(S07_Path);\n+struct S07_Path(Vec<S08_PathSegment>);\n+struct S08_PathSegment(S09_PathParameters);\n+struct S09_PathParameters(P<S10_ParenthesizedParameterData>);\n+struct S10_ParenthesizedParameterData(Option<P<S11_Ty>>);\n+struct S11_Ty(P<S12_Expr>);\n+struct S12_Expr(P<S13_Block>);\n+struct S13_Block(Vec<P<S14_Stmt>>);\n+struct S14_Stmt(P<S15_Decl>);\n+struct S15_Decl(P<S16_Local>);\n+struct S16_Local(P<S17_Pat>);\n+struct S17_Pat(P<S18_Mac>);\n+struct S18_Mac(Vec<P<S19_TokenTree>>);\n+struct S19_TokenTree(P<S20_Token>);\n+struct S20_Token(P<S21_Nonterminal>);\n+struct S21_Nonterminal(P<S22_Item>);\n+struct S22_Item(P<S23_EnumDef>);\n+struct S23_EnumDef(Vec<P<S24_Variant>>);\n+struct S24_Variant(P<S25_VariantKind>);\n+struct S25_VariantKind(P<S26_StructDef>);\n+struct S26_StructDef(Vec<P<S27_StructField>>);\n+struct S27_StructField(P<S28_StructFieldKind>);\n+struct S28_StructFieldKind;\n+\n+pub fn main() {}"}, {"sha": "2752fc88b456b2b45c171d1a19bdf4d27d4f768d", "filename": "src/test/run-pass/macro-attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b3b02f8f4f57046956d42c4c19d00c7bb260189/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs?ref=4b3b02f8f4f57046956d42c4c19d00c7bb260189", "patch": "@@ -10,6 +10,8 @@\n \n // ignore-pretty - token trees can't pretty print\n \n+#![feature(custom_attribute)]\n+\n macro_rules! compiles_fine {\n     (#[$at:meta]) => {\n         // test that the different types of attributes work"}]}