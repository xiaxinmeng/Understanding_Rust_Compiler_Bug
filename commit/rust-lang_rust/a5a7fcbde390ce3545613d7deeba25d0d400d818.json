{"sha": "a5a7fcbde390ce3545613d7deeba25d0d400d818", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YTdmY2JkZTM5MGNlMzU0NTYxM2Q3ZGVlYmEyNWQwZDQwMGQ4MTg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-05T17:31:49Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-10T15:34:44Z"}, "message": "Don't depend on `Allocation` sizes for pattern length", "tree": {"sha": "25e3e65ec71e24eeedeecd8c04f8631ccf2ebc11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25e3e65ec71e24eeedeecd8c04f8631ccf2ebc11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5a7fcbde390ce3545613d7deeba25d0d400d818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a7fcbde390ce3545613d7deeba25d0d400d818", "html_url": "https://github.com/rust-lang/rust/commit/a5a7fcbde390ce3545613d7deeba25d0d400d818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5a7fcbde390ce3545613d7deeba25d0d400d818/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a75e80557a103497cffbcab395a2f37061a77ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a75e80557a103497cffbcab395a2f37061a77ea", "html_url": "https://github.com/rust-lang/rust/commit/3a75e80557a103497cffbcab395a2f37061a77ea"}], "stats": {"total": 205, "additions": 137, "deletions": 68}, "files": [{"sha": "601b08203fadab67f652eba3d8d425b0605412ca", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 116, "deletions": 45, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a5a7fcbde390ce3545613d7deeba25d0d400d818/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a7fcbde390ce3545613d7deeba25d0d400d818/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a5a7fcbde390ce3545613d7deeba25d0d400d818", "patch": "@@ -178,11 +178,11 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::layout::{Integer, IntegerExt, VariantIdx};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n+use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n-use rustc::mir::interpret::ConstValue;\n+use rustc::mir::interpret::{ConstValue, Pointer, Scalar};\n use rustc::util::common::ErrorReported;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n@@ -200,22 +200,66 @@ use std::u128;\n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pattern<'tcx>)\n                                 -> &'a Pattern<'tcx>\n {\n-    cx.pattern_arena.alloc(LiteralExpander.fold_pattern(&pat))\n+    cx.pattern_arena.alloc(LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat))\n }\n \n-struct LiteralExpander;\n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n+struct LiteralExpander<'a, 'tcx> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+}\n+\n+impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n+    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice\n+    fn fold_const_value_deref(\n+        &mut self,\n+        val: ConstValue<'tcx>,\n+        rty: Ty<'tcx>,\n+        crty: Ty<'tcx>,\n+    ) -> ConstValue<'tcx> {\n+        match (val, &crty.sty, &rty.sty) {\n+            // the easy case, deref a reference\n+            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n+                p.alloc_id,\n+                self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n+                p.offset,\n+            ),\n+            // unsize array to slice if pattern is array but match value or other patterns are slice\n+            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n+                assert_eq!(t, u);\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(p),\n+                    n.val.try_to_scalar().unwrap(),\n+                )\n+            },\n+            // fat pointers stay the same\n+            (ConstValue::ScalarPair(..), _, _) => val,\n+            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n+            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n     fn fold_pattern(&mut self, pat: &Pattern<'tcx>) -> Pattern<'tcx> {\n         match (&pat.ty.sty, &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatternKind::Constant { ref value }) => {\n+            (\n+                &ty::Ref(_, rty, _),\n+                &PatternKind::Constant { value: Const {\n+                    val,\n+                    ty: ty::TyS { sty: ty::Ref(_, crty, _), .. },\n+                } },\n+            ) => {\n                 Pattern {\n                     ty: pat.ty,\n                     span: pat.span,\n                     kind: box PatternKind::Deref {\n                         subpattern: Pattern {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: value.clone() },\n+                            kind: box PatternKind::Constant { value: Const::from_const_value(\n+                                self.tcx,\n+                                self.fold_const_value_deref(*val, rty, crty),\n+                                rty,\n+                            ) },\n                         }\n                     }\n                 }\n@@ -732,15 +776,16 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     for row in patterns {\n         match *row.kind {\n             PatternKind::Constant { value } => {\n-                if let Some(ptr) = value.to_ptr() {\n-                    let is_array_ptr = value.ty\n-                        .builtin_deref(true)\n-                        .and_then(|t| t.ty.builtin_index())\n-                        .map_or(false, |t| t == cx.tcx.types.u8);\n-                    if is_array_ptr {\n-                        let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                        max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n-                    }\n+                match (value.val, &value.ty.sty) {\n+                    (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n+                        max_fixed_len,\n+                        n.unwrap_usize(cx.tcx),\n+                    ),\n+                    (ConstValue::ScalarPair(_, n), ty::Slice(_)) => max_fixed_len = cmp::max(\n+                        max_fixed_len,\n+                        n.to_usize(&cx.tcx).unwrap(),\n+                    ),\n+                    _ => {},\n                 }\n             }\n             PatternKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -1358,18 +1403,44 @@ fn slice_pat_covered_by_constructor<'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match *ctor {\n         ConstantValue(const_val) => {\n-            let val = match const_val.val {\n-                ConstValue::Unevaluated(..) |\n-                ConstValue::ByRef(..) => bug!(\"unexpected ConstValue: {:?}\", const_val),\n-                ConstValue::Scalar(val) | ConstValue::ScalarPair(val, _) => val,\n-            };\n-            if let Ok(ptr) = val.to_ptr() {\n-                tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id).bytes.as_ref()\n-            } else {\n-                bug!(\"unexpected non-ptr ConstantValue\")\n+            match (const_val.val, &const_val.ty.sty) {\n+                (ConstValue::ByRef(id, alloc, offset), ty::Array(t, n)) => {\n+                    if *t != tcx.types.u8 {\n+                        // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                        // any sort of exhaustiveness/unreachable check yet\n+                        return Ok(false);\n+                    }\n+                    let ptr = Pointer::new(id, offset);\n+                    let n = n.assert_usize(tcx).unwrap();\n+                    alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n+                },\n+                (ConstValue::ScalarPair(Scalar::Bits { .. }, n), ty::Slice(_)) => {\n+                    assert_eq!(n.to_usize(&tcx).unwrap(), 0);\n+                    &[]\n+                },\n+                (ConstValue::ScalarPair(Scalar::Ptr(ptr), n), ty::Slice(t)) => {\n+                    if *t != tcx.types.u8 {\n+                        // FIXME(oli-obk): can't mix const patterns with slice patterns and get\n+                        // any sort of exhaustiveness/unreachable check yet\n+                        return Ok(false);\n+                    }\n+                    let n = n.to_usize(&tcx).unwrap();\n+                    tcx.alloc_map\n+                        .lock()\n+                        .unwrap_memory(ptr.alloc_id)\n+                        .get_bytes(&tcx, ptr, Size::from_bytes(n))\n+                        .unwrap()\n+                },\n+                _ => bug!(\n+                    \"slice_pat_covered_by_constructor: {:#?}, {:#?}, {:#?}, {:#?}\",\n+                    ctor, prefix, slice, suffix,\n+                ),\n             }\n         }\n-        _ => bug!()\n+        _ => bug!(\n+            \"slice_pat_covered_by_constructor not ConstValue: {:#?}, {:#?}, {:#?}, {:#?}\",\n+            ctor, prefix, slice, suffix,\n+        ),\n     };\n \n     let pat_len = prefix.len() + suffix.len();\n@@ -1675,22 +1746,23 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, n, ty) = match value.ty.builtin_deref(false).unwrap().ty.sty {\n-                        ty::TyKind::Array(t, n) => (value.to_ptr(), n.unwrap_usize(cx.tcx), t),\n-                        ty::TyKind::Slice(t) => {\n-                            match value.val {\n-                                ConstValue::ScalarPair(ptr, n) => (\n-                                    ptr.to_ptr().ok(),\n-                                    n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n-                                    t,\n-                                ),\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"slice pattern constant must be scalar pair but is {:?}\",\n-                                    value,\n-                                ),\n-                            }\n-                        },\n+                    let (opt_ptr, n, ty) = match (value.val, &value.ty.sty) {\n+                        (ConstValue::ByRef(id, alloc, offset), ty::TyKind::Array(t, n)) => (\n+                            Some((\n+                                Pointer::new(id, offset),\n+                                alloc,\n+                            )),\n+                            n.unwrap_usize(cx.tcx),\n+                            t,\n+                        ),\n+                        (ConstValue::ScalarPair(ptr, n), ty::TyKind::Slice(t)) => (\n+                            ptr.to_ptr().ok().map(|ptr| (\n+                                ptr,\n+                                cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                            )),\n+                            n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n+                            t,\n+                        ),\n                         _ => span_bug!(\n                             pat.span,\n                             \"unexpected const-val {:?} with ctor {:?}\",\n@@ -1702,8 +1774,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         // convert a constant slice/array pattern to a list of patterns.\n                         match (n, opt_ptr) {\n                             (0, _) => Some(SmallVec::new()),\n-                            (_, Some(ptr)) => {\n-                                let alloc = cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                            (_, Some((ptr, alloc))) => {\n                                 let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n                                 (0..n).map(|i| {\n                                     let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;"}, {"sha": "ddd6a705b04d116a8d1135d91d4342ef19e20552", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a5a7fcbde390ce3545613d7deeba25d0d400d818/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5a7fcbde390ce3545613d7deeba25d0d400d818/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a5a7fcbde390ce3545613d7deeba25d0d400d818", "patch": "@@ -1259,34 +1259,32 @@ pub fn compare_const_vals<'a, 'tcx>(\n         }\n     }\n \n-    if let ty::Ref(_, rty, _) = ty.value.sty {\n-        if let ty::Str = rty.sty {\n-            match (a.val, b.val) {\n-                (\n-                    ConstValue::ScalarPair(\n-                        Scalar::Ptr(ptr_a),\n-                        len_a,\n-                    ),\n-                    ConstValue::ScalarPair(\n-                        Scalar::Ptr(ptr_b),\n-                        len_b,\n-                    ),\n-                ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                    if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n-                        if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n-                            if len_a == len_b {\n-                                let map = tcx.alloc_map.lock();\n-                                let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n-                                let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n-                                if alloc_a.bytes.len() as u128 == len_a {\n-                                    return from_bool(alloc_a == alloc_b);\n-                                }\n+    if let ty::Str = ty.value.sty {\n+        match (a.val, b.val) {\n+            (\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(ptr_a),\n+                    len_a,\n+                ),\n+                ConstValue::ScalarPair(\n+                    Scalar::Ptr(ptr_b),\n+                    len_b,\n+                ),\n+            ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n+                if let Ok(len_a) = len_a.to_bits(tcx.data_layout.pointer_size) {\n+                    if let Ok(len_b) = len_b.to_bits(tcx.data_layout.pointer_size) {\n+                        if len_a == len_b {\n+                            let map = tcx.alloc_map.lock();\n+                            let alloc_a = map.unwrap_memory(ptr_a.alloc_id);\n+                            let alloc_b = map.unwrap_memory(ptr_b.alloc_id);\n+                            if alloc_a.bytes.len() as u128 == len_a {\n+                                return from_bool(alloc_a == alloc_b);\n                             }\n                         }\n                     }\n                 }\n-                _ => (),\n             }\n+            _ => (),\n         }\n     }\n "}]}