{"sha": "22c5c83a680b17a01669e01246cc7b39cea5c8d2", "node_id": "C_kwDOAAsO6NoAKDIyYzVjODNhNjgwYjE3YTAxNjY5ZTAxMjQ2Y2M3YjM5Y2VhNWM4ZDI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T19:30:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T19:30:09Z"}, "message": "Rollup merge of #100844 - evopen:migrate-diag, r=davidtwco\n\nmigrate rustc_query_system to use SessionDiagnostic\n\nissues:\n* variable list is not supported in fluent\n* ~~cannot have two sub diagnostic with the same tag (eg. 2 .note or 2 .help)~~\n\nallow multiple tag with SessionSubdiagnostic derive", "tree": {"sha": "18fcc2604253c4cb5244c22915e86e073c5bf5f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18fcc2604253c4cb5244c22915e86e073c5bf5f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22c5c83a680b17a01669e01246cc7b39cea5c8d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjD7bBCRBK7hj4Ov3rIwAAq2AIAEmIomZ6/gU/I5uif1WwXz6O\nv0exrYJ1O+5mIOIi3xQZarpNgMhB3Ekjx1p2/E053PKgnaTEQwHK4NGqmngvvBYS\n16ytEymz0pURk0Ep2nP6rnlxDLpBbz/6poRHjxji89k/XJIR3+qo5XP9/pSrBNmz\nQaNB84fmfQTvnz/SH0hz5zTmrv4z22GLM7zL3o/Sria8vlyD2iI7YUTN0y/ZGuMz\nr6Z22RAVU1IHCWJvfoyI3zXwkVSHL1s8cK0J9aJ7nXutSmKVSTEMHb1/2MaIFui1\nhxNCfcKmTuEhpR+ULti88B0J23o/8J04Pw1Mw2Lj0RMaOQ80jkh2wMXsdiaoxRw=\n=phkx\n-----END PGP SIGNATURE-----\n", "payload": "tree 18fcc2604253c4cb5244c22915e86e073c5bf5f7\nparent 2af2cda32a251d792bfef58e49a25a866f622766\nparent 7ce59ebf496590c8b2ba3693c13e981d369add4b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661974209 +0200\ncommitter GitHub <noreply@github.com> 1661974209 +0200\n\nRollup merge of #100844 - evopen:migrate-diag, r=davidtwco\n\nmigrate rustc_query_system to use SessionDiagnostic\n\nissues:\n* variable list is not supported in fluent\n* ~~cannot have two sub diagnostic with the same tag (eg. 2 .note or 2 .help)~~\n\nallow multiple tag with SessionSubdiagnostic derive\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22c5c83a680b17a01669e01246cc7b39cea5c8d2", "html_url": "https://github.com/rust-lang/rust/commit/22c5c83a680b17a01669e01246cc7b39cea5c8d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22c5c83a680b17a01669e01246cc7b39cea5c8d2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af2cda32a251d792bfef58e49a25a866f622766", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af2cda32a251d792bfef58e49a25a866f622766", "html_url": "https://github.com/rust-lang/rust/commit/2af2cda32a251d792bfef58e49a25a866f622766"}, {"sha": "7ce59ebf496590c8b2ba3693c13e981d369add4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce59ebf496590c8b2ba3693c13e981d369add4b", "html_url": "https://github.com/rust-lang/rust/commit/7ce59ebf496590c8b2ba3693c13e981d369add4b"}], "stats": {"total": 1279, "additions": 475, "deletions": 804}, "files": [{"sha": "167704e46c07d5139ab47115c0f8fa02b967f973", "filename": "compiler/rustc_error_messages/locales/en-US/query_system.ftl", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -0,0 +1,25 @@\n+query_system_reentrant = internal compiler error: re-entrant incremental verify failure, suppressing message\n+\n+query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n+    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n+\n+query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n+query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n+\n+query_system_cycle = cycle detected when {$stack_bottom}\n+\n+query_system_cycle_usage = cycle used when {$usage}\n+\n+query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n+\n+query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n+\n+query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n+query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n+query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n+\n+query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n+\n+query_system_cycle_which_requires = ...which requires {$desc}...\n+\n+query_system_query_overflow = queries overflow the depth limit!"}, {"sha": "8f47be25db917dc7934297b6e9ec25e77397b2fb", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -50,6 +50,7 @@ fluent_messages! {\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n+    query_system => \"../locales/en-US/query_system.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n     ty_utils => \"../locales/en-US/ty_utils.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\","}, {"sha": "c1b82abc1e064a8da1b8dd62e3610232f7722393", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 249, "deletions": 445, "changes": 694, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -12,7 +12,7 @@ use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::fmt;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n+use syn::{spanned::Spanned, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// Which kind of suggestion is being created?\n@@ -28,41 +28,8 @@ enum SubdiagnosticSuggestionKind {\n     Verbose,\n }\n \n-impl FromStr for SubdiagnosticSuggestionKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"\" => Ok(SubdiagnosticSuggestionKind::Normal),\n-            \"_short\" => Ok(SubdiagnosticSuggestionKind::Short),\n-            \"_hidden\" => Ok(SubdiagnosticSuggestionKind::Hidden),\n-            \"_verbose\" => Ok(SubdiagnosticSuggestionKind::Verbose),\n-            _ => Err(()),\n-        }\n-    }\n-}\n-\n-impl SubdiagnosticSuggestionKind {\n-    pub fn to_suggestion_style(&self) -> TokenStream {\n-        match self {\n-            SubdiagnosticSuggestionKind::Normal => {\n-                quote! { rustc_errors::SuggestionStyle::ShowCode }\n-            }\n-            SubdiagnosticSuggestionKind::Short => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n-            }\n-            SubdiagnosticSuggestionKind::Hidden => {\n-                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n-            }\n-            SubdiagnosticSuggestionKind::Verbose => {\n-                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n-            }\n-        }\n-    }\n-}\n-\n /// Which kind of subdiagnostic is being created from a variant?\n-#[derive(Clone)]\n+#[derive(Clone, Copy)]\n enum SubdiagnosticKind {\n     /// `#[label(...)]`\n     Label,\n@@ -73,9 +40,31 @@ enum SubdiagnosticKind {\n     /// `#[warning(...)]`\n     Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion { suggestion_kind: SubdiagnosticSuggestionKind, code: TokenStream },\n-    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n-    MultipartSuggestion { suggestion_kind: SubdiagnosticSuggestionKind },\n+    Suggestion(SubdiagnosticSuggestionKind),\n+}\n+\n+impl FromStr for SubdiagnosticKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"label\" => Ok(SubdiagnosticKind::Label),\n+            \"note\" => Ok(SubdiagnosticKind::Note),\n+            \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"warning\" => Ok(SubdiagnosticKind::Warn),\n+            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n+            \"suggestion_short\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n+            }\n+            \"suggestion_hidden\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n+            }\n+            \"suggestion_verbose\" => {\n+                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n+            }\n+            _ => Err(()),\n+        }\n+    }\n }\n \n impl quote::IdentFragment for SubdiagnosticKind {\n@@ -85,9 +74,17 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n             SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n-            SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                write!(f, \"multipart_suggestion_with_style\")\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n+                write!(f, \"suggestion\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n+                write!(f, \"suggestion_short\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n+                write!(f, \"suggestion_hidden\")\n+            }\n+            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n+                write!(f, \"suggestion_verbose\")\n             }\n         }\n     }\n@@ -151,9 +148,11 @@ impl<'a> SessionSubdiagnosticDerive<'a> {\n                     variant,\n                     span,\n                     fields: fields_map,\n+                    kinds: Vec::new(),\n+                    slugs: Vec::new(),\n+                    code: None,\n                     span_field: None,\n                     applicability: None,\n-                    has_suggestion_parts: false,\n                 };\n                 builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n             });\n@@ -194,15 +193,21 @@ struct SessionSubdiagnosticDeriveBuilder<'a> {\n     /// derive builder.\n     fields: HashMap<String, TokenStream>,\n \n+    /// Subdiagnostic kind of the type/variant.\n+    kinds: Vec<(SubdiagnosticKind, proc_macro::Span)>,\n+\n+    /// Slugs of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n+    /// `#[kind(slug)]` attribute on the type or variant.\n+    slugs: Vec<(Path, proc_macro::Span)>,\n+    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n+    /// attribute on the type or variant.\n+    code: Option<(TokenStream, proc_macro::Span)>,\n+\n     /// Identifier for the binding to the `#[primary_span]` field.\n     span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n     /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n     /// `rustc_errors::Applicability::*` variant directly.\n     applicability: Option<(TokenStream, proc_macro::Span)>,\n-\n-    /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n-    /// during finalization if still `false`.\n-    has_suggestion_parts: bool,\n }\n \n impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n@@ -212,472 +217,271 @@ impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n }\n \n impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn identify_kind(\n-        &mut self,\n-    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n-        let mut kind_slug = None;\n-\n-        for attr in self.variant.ast().attrs {\n+    fn identify_kind(&mut self) -> Result<(), DiagnosticDeriveError> {\n+        for (i, attr) in self.variant.ast().attrs.iter().enumerate() {\n             let span = attr.span().unwrap();\n \n             let name = attr.path.segments.last().unwrap().ident.to_string();\n             let name = name.as_str();\n \n             let meta = attr.parse_meta()?;\n-            let Meta::List(MetaList { ref nested, .. }) = meta else {\n-                throw_invalid_attr!(attr, &meta);\n-            };\n-\n-            let mut kind = match name {\n-                \"label\" => SubdiagnosticKind::Label,\n-                \"note\" => SubdiagnosticKind::Note,\n-                \"help\" => SubdiagnosticKind::Help,\n-                \"warning\" => SubdiagnosticKind::Warn,\n-                _ => {\n-                    if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::Suggestion { suggestion_kind, code: TokenStream::new() }\n-                    } else if let Some(suggestion_kind) =\n-                        name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n-                    {\n-                        SubdiagnosticKind::MultipartSuggestion { suggestion_kind }\n-                    } else {\n-                        throw_invalid_attr!(attr, &meta);\n+            let kind = match meta {\n+                Meta::List(MetaList { ref nested, .. }) => {\n+                    let mut nested_iter = nested.into_iter();\n+                    if let Some(nested_attr) = nested_iter.next() {\n+                        match nested_attr {\n+                            NestedMeta::Meta(Meta::Path(path)) => {\n+                                self.slugs.push((path.clone(), span));\n+                            }\n+                            NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                                if matches!(\n+                                    meta.path().segments.last().unwrap().ident.to_string().as_str(),\n+                                    \"code\" | \"applicability\"\n+                                ) =>\n+                            {\n+                                // don't error for valid follow-up attributes\n+                            }\n+                            nested_attr => {\n+                                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                    diag.help(\n+                                        \"first argument of the attribute should be the diagnostic \\\n+                                         slug\",\n+                                    )\n+                                })\n+                            }\n+                        };\n                     }\n-                }\n-            };\n \n-            let mut slug = None;\n-            let mut code = None;\n-\n-            let mut nested_iter = nested.into_iter();\n-            if let Some(nested_attr) = nested_iter.next() {\n-                match nested_attr {\n-                    NestedMeta::Meta(Meta::Path(path)) => {\n-                        slug.set_once((path.clone(), span));\n-                    }\n-                    NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                        if matches!(\n-                            meta.path().segments.last().unwrap().ident.to_string().as_str(),\n-                            \"code\" | \"applicability\"\n-                        ) =>\n-                    {\n-                        // Don't error for valid follow-up attributes.\n-                    }\n-                    nested_attr => {\n-                        throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"first argument of the attribute should be the diagnostic \\\n-                                 slug\",\n-                            )\n-                        })\n+                    for nested_attr in nested_iter {\n+                        let meta = match nested_attr {\n+                            NestedMeta::Meta(ref meta) => meta,\n+                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                        };\n+\n+                        let span = meta.span().unwrap();\n+                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                        let nested_name = nested_name.as_str();\n+\n+                        match meta {\n+                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                                match nested_name {\n+                                    \"code\" => {\n+                                        let formatted_str = self.build_format(&s.value(), s.span());\n+                                        self.code.set_once((formatted_str, span));\n+                                    }\n+                                    \"applicability\" => {\n+                                        let value = match Applicability::from_str(&s.value()) {\n+                                            Ok(v) => v,\n+                                            Err(()) => {\n+                                                span_err(span, \"invalid applicability\").emit();\n+                                                Applicability::Unspecified\n+                                            }\n+                                        };\n+                                        self.applicability.set_once((quote! { #value }, span));\n+                                    }\n+                                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                        diag.help(\n+                                            \"only `code` and `applicability` are valid nested \\\n+                                             attributes\",\n+                                        )\n+                                    }),\n+                                }\n+                            }\n+                            _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                                if matches!(meta, Meta::Path(_)) {\n+                                    diag.help(\n+                                        \"a diagnostic slug must be the first argument to the \\\n+                                         attribute\",\n+                                    )\n+                                } else {\n+                                    diag\n+                                }\n+                            }),\n+                        }\n                     }\n-                };\n-            }\n \n-            for nested_attr in nested_iter {\n-                let meta = match nested_attr {\n-                    NestedMeta::Meta(ref meta) => meta,\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n+                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n+                        throw_invalid_attr!(attr, &meta)\n+                    };\n \n-                let span = meta.span().unwrap();\n-                let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                let nested_name = nested_name.as_str();\n+                    kind\n+                }\n+                _ => throw_invalid_attr!(attr, &meta),\n+            };\n \n-                let value = match meta {\n-                    Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n-                    Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    }),\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                };\n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.code.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n+                );\n+            }\n \n-                match nested_name {\n-                    \"code\" => {\n-                        if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`code` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                ),\n-                            )\n-                            .emit();\n-                        }\n-                    }\n-                    \"applicability\" => {\n-                        if matches!(\n-                            kind,\n-                            SubdiagnosticKind::Suggestion { .. }\n-                                | SubdiagnosticKind::MultipartSuggestion { .. }\n-                        ) {\n-                            let value =\n-                                Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n-                                    span_err(span, \"invalid applicability\").emit();\n-                                    Applicability::Unspecified\n-                                });\n-                            self.applicability.set_once((quote! { #value }, span));\n-                        } else {\n-                            span_err(\n-                                span,\n-                                &format!(\n-                                    \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n-                                    name\n-                                )\n-                            ).emit();\n-                        }\n-                    }\n-                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                        diag.help(\"only `code` and `applicability` are valid nested attributes\")\n-                    }),\n-                }\n+            if matches!(\n+                kind,\n+                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n+            ) && self.applicability.is_some()\n+            {\n+                throw_span_err!(\n+                    span,\n+                    &format!(\n+                        \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n+                        name\n+                    )\n+                );\n             }\n \n-            let Some((slug, _)) = slug else {\n+            if self.slugs.len() != i + 1 {\n                 throw_span_err!(\n                     span,\n                     &format!(\n                         \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n                         name\n                     )\n                 );\n-            };\n-\n-            match kind {\n-                SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n-                    let Some((code, _)) = code else {\n-                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\");\n-                    };\n-                    *code_field = code;\n-                }\n-                SubdiagnosticKind::Label\n-                | SubdiagnosticKind::Note\n-                | SubdiagnosticKind::Help\n-                | SubdiagnosticKind::Warn\n-                | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n             }\n \n-            kind_slug.set_once(((kind, slug), span))\n+            self.kinds.push((kind, span));\n         }\n \n-        Ok(kind_slug.map(|(kind_slug, _)| kind_slug))\n-    }\n-\n-    /// Generates the code for a field with no attributes.\n-    fn generate_field_set_arg(&mut self, binding: &BindingInfo<'_>) -> TokenStream {\n-        let ast = binding.ast();\n-        assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n-\n-        let diag = &self.diag;\n-        let ident = ast.ident.as_ref().unwrap();\n-        quote! {\n-            #diag.set_arg(\n-                stringify!(#ident),\n-                #binding\n-            );\n-        }\n+        Ok(())\n     }\n \n-    /// Generates the necessary code for all attributes on a field.\n-    fn generate_field_attr_code(\n+    fn generate_field_code(\n         &mut self,\n         binding: &BindingInfo<'_>,\n-        kind: &SubdiagnosticKind,\n-    ) -> TokenStream {\n+        have_suggestion: bool,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let ast = binding.ast();\n-        assert!(ast.attrs.len() > 0, \"field without attributes generating attr code\");\n \n-        // Abstract over `Vec<T>` and `Option<T>` fields using `FieldInnerTy`, which will\n-        // apply the generated code on each element in the `Vec` or `Option`.\n         let inner_ty = FieldInnerTy::from_type(&ast.ty);\n-        ast.attrs\n-            .iter()\n-            .map(|attr| {\n-                let info = FieldInfo {\n-                    binding,\n-                    ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n-                    span: &ast.span(),\n-                };\n-\n-                let generated = self\n-                    .generate_field_code_inner(kind, attr, info)\n-                    .unwrap_or_else(|v| v.to_compile_error());\n-\n-                inner_ty.with(binding, generated)\n-            })\n-            .collect()\n-    }\n-\n-    fn generate_field_code_inner(\n-        &mut self,\n-        kind: &SubdiagnosticKind,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(path) => self.generate_field_code_inner_path(kind, attr, info, path),\n-            Meta::List(list @ MetaList { .. }) => {\n-                self.generate_field_code_inner_list(kind, attr, info, list)\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n-    }\n-\n-    /// Generates the code for a `[Meta::Path]`-like attribute on a field (e.g. `#[primary_span]`).\n-    fn generate_field_code_inner_path(\n-        &mut self,\n-        kind: &SubdiagnosticKind,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        path: Path,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let span = attr.span().unwrap();\n-        let ident = &path.segments.last().unwrap().ident;\n-        let name = ident.to_string();\n-        let name = name.as_str();\n-\n-        match name {\n-            \"skip_arg\" => Ok(quote! {}),\n-            \"primary_span\" => {\n-                if matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n-                    throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n-                        diag.help(\n-                            \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n-                            than one `#[primary_span]`\",\n-                        )\n-                    })\n-                }\n-\n-                report_error_if_not_applied_to_span(attr, &info)?;\n+        let info = FieldInfo {\n+            binding: binding,\n+            ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n+            span: &ast.span(),\n+        };\n \n-                let binding = info.binding.binding.clone();\n-                self.span_field.set_once((binding, span));\n+        for attr in &ast.attrs {\n+            let name = attr.path.segments.last().unwrap().ident.to_string();\n+            let name = name.as_str();\n+            let span = attr.span().unwrap();\n \n-                Ok(quote! {})\n-            }\n-            \"suggestion_part\" => {\n-                self.has_suggestion_parts = true;\n-\n-                match kind {\n-                    SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                        span_err(\n-                            span,\n-                            \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\",\n-                        )\n-                        .emit();\n-                        Ok(quote! {})\n+            let meta = attr.parse_meta()?;\n+            match meta {\n+                Meta::Path(_) => match name {\n+                    \"primary_span\" => {\n+                        report_error_if_not_applied_to_span(attr, &info)?;\n+                        self.span_field.set_once((binding.binding.clone(), span));\n+                        return Ok(quote! {});\n                     }\n-                    SubdiagnosticKind::Label\n-                    | SubdiagnosticKind::Note\n-                    | SubdiagnosticKind::Help\n-                    | SubdiagnosticKind::Warn\n-                    | SubdiagnosticKind::Suggestion { .. } => {\n-                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n-                            diag.help(\n-                                \"`#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\",\n-                            )\n-                        });\n+                    \"applicability\" if have_suggestion => {\n+                        report_error_if_not_applied_to_applicability(attr, &info)?;\n+                        let binding = binding.binding.clone();\n+                        self.applicability.set_once((quote! { #binding }, span));\n+                        return Ok(quote! {});\n                     }\n-                }\n-            }\n-            \"applicability\" => {\n-                if let SubdiagnosticKind::Suggestion { .. }\n-                | SubdiagnosticKind::MultipartSuggestion { .. } = kind\n-                {\n-                    report_error_if_not_applied_to_applicability(attr, &info)?;\n-\n-                    let binding = info.binding.binding.clone();\n-                    self.applicability.set_once((quote! { #binding }, span));\n-                } else {\n-                    span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n-                }\n-\n-                Ok(quote! {})\n-            }\n-            _ => throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n-                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n-                    \"suggestion_part\"\n-                } else {\n-                    \"primary_span\"\n-                };\n-                diag.help(format!(\n-                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n-                ))\n-            }),\n-        }\n-    }\n-\n-    /// Generates the code for a `[Meta::List]`-like attribute on a field (e.g.\n-    /// `#[suggestion_part(code = \"...\")]`).\n-    fn generate_field_code_inner_list(\n-        &mut self,\n-        kind: &SubdiagnosticKind,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        list: MetaList,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let span = attr.span().unwrap();\n-        let ident = &list.path.segments.last().unwrap().ident;\n-        let name = ident.to_string();\n-        let name = name.as_str();\n-\n-        match name {\n-            \"suggestion_part\" => {\n-                if !matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n-                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                    \"applicability\" => {\n+                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                        return Ok(quote! {});\n+                    }\n+                    \"skip_arg\" => {\n+                        return Ok(quote! {});\n+                    }\n+                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n                         diag.help(\n-                            \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n+                            \"only `primary_span`, `applicability` and `skip_arg` are valid field \\\n+                             attributes\",\n                         )\n-                    })\n-                }\n-\n-                self.has_suggestion_parts = true;\n-\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-\n-                let mut code = None;\n-                for nested_attr in list.nested.iter() {\n-                    let NestedMeta::Meta(ref meta) = nested_attr else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n-                    };\n-\n-                    let span = meta.span().unwrap();\n-                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                    let nested_name = nested_name.as_str();\n-\n-                    let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) = meta else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n-                    };\n+                    }),\n+                },\n+                _ => throw_invalid_attr!(attr, &meta),\n+            }\n+        }\n \n-                    match nested_name {\n-                        \"code\" => {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n-                        }\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\"`code` is the only valid nested attribute\")\n-                        }),\n-                    }\n-                }\n+        let ident = ast.ident.as_ref().unwrap();\n \n-                let Some((code, _)) = code else {\n-                    span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n-                        .emit();\n-                    return Ok(quote! {});\n-                };\n-                let binding = info.binding;\n+        let diag = &self.diag;\n+        let generated = quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding\n+            );\n+        };\n \n-                Ok(quote! { suggestions.push((#binding, #code)); })\n-            }\n-            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n-                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n-                    \"suggestion_part\"\n-                } else {\n-                    \"primary_span\"\n-                };\n-                diag.help(format!(\n-                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n-                ))\n-            }),\n-        }\n+        Ok(inner_ty.with(binding, generated))\n     }\n \n-    pub fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let Some((kind, slug)) = self.identify_kind()? else {\n+    fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n+        self.identify_kind()?;\n+        if self.kinds.is_empty() {\n             throw_span_err!(\n                 self.variant.ast().ident.span().unwrap(),\n                 \"subdiagnostic kind not specified\"\n             );\n         };\n+        let have_suggestion =\n+            self.kinds.iter().any(|(k, _)| matches!(k, SubdiagnosticKind::Suggestion(_)));\n+        let mut args = TokenStream::new();\n+        for binding in self.variant.bindings() {\n+            let arg = self\n+                .generate_field_code(binding, have_suggestion)\n+                .unwrap_or_else(|v| v.to_compile_error());\n+            args.extend(arg);\n+        }\n+        let mut tokens = TokenStream::new();\n+        for ((kind, _), (slug, _)) in self.kinds.iter().zip(&self.slugs) {\n+            let code = match self.code.as_ref() {\n+                Some((code, _)) => Some(quote! { #code }),\n+                None if have_suggestion => {\n+                    span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n+                    Some(quote! { /* macro error */ \"...\" })\n+                }\n+                None => None,\n+            };\n \n-        let init = match &kind {\n-            SubdiagnosticKind::Label\n-            | SubdiagnosticKind::Note\n-            | SubdiagnosticKind::Help\n-            | SubdiagnosticKind::Warn\n-            | SubdiagnosticKind::Suggestion { .. } => quote! {},\n-            SubdiagnosticKind::MultipartSuggestion { .. } => {\n-                quote! { let mut suggestions = Vec::new(); }\n-            }\n-        };\n-\n-        let attr_args: TokenStream = self\n-            .variant\n-            .bindings()\n-            .iter()\n-            .filter(|binding| !binding.ast().attrs.is_empty())\n-            .map(|binding| self.generate_field_attr_code(binding, &kind))\n-            .collect();\n-\n-        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = self.applicability.take().map_or_else(\n-            || quote! { rustc_errors::Applicability::Unspecified },\n-            |(applicability, _)| applicability,\n-        );\n+            let span_field = self.span_field.as_ref().map(|(span, _)| span);\n+            let applicability = match self.applicability.clone() {\n+                Some((applicability, _)) => Some(applicability),\n+                None if have_suggestion => {\n+                    span_err(self.span, \"suggestion without `applicability`\").emit();\n+                    Some(quote! { rustc_errors::Applicability::Unspecified })\n+                }\n+                None => None,\n+            };\n \n-        let diag = &self.diag;\n-        let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n-        let message = quote! { rustc_errors::fluent::#slug };\n-        let call = match kind {\n-            SubdiagnosticKind::Suggestion { suggestion_kind, code } => {\n+            let diag = &self.diag;\n+            let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n+            let message = quote! { rustc_errors::fluent::#slug };\n+            let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n                 if let Some(span) = span_field {\n-                    let style = suggestion_kind.to_suggestion_style();\n-\n-                    quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                    quote! { #diag.#name(#span, #message, #code, #applicability); }\n                 } else {\n                     span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n                     quote! { unreachable!(); }\n                 }\n-            }\n-            SubdiagnosticKind::MultipartSuggestion { suggestion_kind } => {\n-                if !self.has_suggestion_parts {\n-                    span_err(\n-                        self.span,\n-                        \"multipart suggestion without any `#[suggestion_part(...)]` fields\",\n-                    )\n-                    .emit();\n-                }\n-\n-                let style = suggestion_kind.to_suggestion_style();\n-\n-                quote! { #diag.#name(#message, suggestions, #applicability, #style); }\n-            }\n-            SubdiagnosticKind::Label => {\n+            } else if matches!(kind, SubdiagnosticKind::Label) {\n                 if let Some(span) = span_field {\n                     quote! { #diag.#name(#span, #message); }\n                 } else {\n                     span_err(self.span, \"label without `#[primary_span]` field\").emit();\n                     quote! { unreachable!(); }\n                 }\n-            }\n-            _ => {\n+            } else {\n                 if let Some(span) = span_field {\n                     quote! { #diag.#name(#span, #message); }\n                 } else {\n                     quote! { #diag.#name(#message); }\n                 }\n-            }\n-        };\n+            };\n+            tokens.extend(quote! {\n+                #call\n+                #args\n+            });\n+        }\n \n-        let plain_args: TokenStream = self\n-            .variant\n-            .bindings()\n-            .iter()\n-            .filter(|binding| binding.ast().attrs.is_empty())\n-            .map(|binding| self.generate_field_set_arg(binding))\n-            .collect();\n-\n-        Ok(quote! {\n-            #init\n-            #attr_args\n-            #call\n-            #plain_args\n-        })\n+        Ok(tokens)\n     }\n }"}, {"sha": "5f992ec9e21ea85987addb5f9beb465b074850ce", "filename": "compiler/rustc_query_system/src/error.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -0,0 +1,73 @@\n+use rustc_errors::AddSubdiagnostic;\n+use rustc_span::Span;\n+\n+pub struct CycleStack {\n+    pub span: Span,\n+    pub desc: String,\n+}\n+\n+impl AddSubdiagnostic for CycleStack {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.span_note(self.span, &format!(\"...which requires {}...\", self.desc));\n+    }\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum StackCount {\n+    #[note(query_system::cycle_stack_single)]\n+    Single,\n+    #[note(query_system::cycle_stack_multiple)]\n+    Multiple,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum Alias {\n+    #[note(query_system::cycle_recursive_ty_alias)]\n+    #[help(query_system::cycle_recursive_ty_alias_help1)]\n+    #[help(query_system::cycle_recursive_ty_alias_help2)]\n+    Ty,\n+    #[note(query_system::cycle_recursive_trait_alias)]\n+    Trait,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[note(query_system::cycle_usage)]\n+pub struct CycleUsage {\n+    #[primary_span]\n+    pub span: Span,\n+    pub usage: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(query_system::cycle, code = \"E0391\")]\n+pub struct Cycle {\n+    #[primary_span]\n+    pub span: Span,\n+    pub stack_bottom: String,\n+    #[subdiagnostic]\n+    pub cycle_stack: Vec<CycleStack>,\n+    #[subdiagnostic]\n+    pub stack_count: StackCount,\n+    #[subdiagnostic]\n+    pub alias: Option<Alias>,\n+    #[subdiagnostic]\n+    pub cycle_usage: Option<CycleUsage>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(query_system::reentrant)]\n+pub struct Reentrant;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(query_system::increment_compilation)]\n+#[help]\n+#[note(query_system::increment_compilation_note1)]\n+#[note(query_system::increment_compilation_note2)]\n+pub struct IncrementCompilation {\n+    pub run_cmd: String,\n+    pub dep_node: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(query_system::query_overflow)]\n+pub struct QueryOverflow;"}, {"sha": "7067bc5f09cfc07229179036d4042896b836611b", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -5,6 +5,8 @@\n #![feature(min_specialization)]\n #![feature(extern_types)]\n #![allow(rustc::potential_query_instability)]\n+// #![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;\n@@ -15,5 +17,6 @@ extern crate rustc_macros;\n \n pub mod cache;\n pub mod dep_graph;\n+mod error;\n pub mod ich;\n pub mod query;"}, {"sha": "ddb5cd0634407c5d09e9341b2018789ef415ca6c", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -1,12 +1,11 @@\n+use crate::error::CycleStack;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryStackFrame};\n-use rustc_hir::def::DefKind;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{\n-    struct_span_err, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, Handler, Level,\n-};\n-use rustc_session::Session;\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed, Handler, Level};\n+use rustc_hir::def::DefKind;\n+use rustc_session::{Session, SessionDiagnostic};\n use rustc_span::Span;\n \n use std::hash::Hash;\n@@ -536,46 +535,44 @@ pub(crate) fn report_cycle<'a>(\n     assert!(!stack.is_empty());\n \n     let span = stack[0].query.default_span(stack[1 % stack.len()].span);\n-    let mut err =\n-        struct_span_err!(sess, span, E0391, \"cycle detected when {}\", stack[0].query.description);\n+\n+    let mut cycle_stack = Vec::new();\n+\n+    use crate::error::StackCount;\n+    let stack_count = if stack.len() == 1 { StackCount::Single } else { StackCount::Multiple };\n \n     for i in 1..stack.len() {\n         let query = &stack[i].query;\n         let span = query.default_span(stack[(i + 1) % stack.len()].span);\n-        err.span_note(span, &format!(\"...which requires {}...\", query.description));\n-    }\n-\n-    if stack.len() == 1 {\n-        err.note(&format!(\"...which immediately requires {} again\", stack[0].query.description));\n-    } else {\n-        err.note(&format!(\n-            \"...which again requires {}, completing the cycle\",\n-            stack[0].query.description\n-        ));\n-    }\n-\n-    if stack.iter().all(|entry| {\n-        entry\n-            .query\n-            .def_kind\n-            .map_or(false, |def_kind| matches!(def_kind, DefKind::TyAlias | DefKind::TraitAlias))\n-    }) {\n-        if stack.iter().all(|entry| {\n-            entry.query.def_kind.map_or(false, |def_kind| matches!(def_kind, DefKind::TyAlias))\n-        }) {\n-            err.note(\"type aliases cannot be recursive\");\n-            err.help(\"consider using a struct, enum, or union instead to break the cycle\");\n-            err.help(\"see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\");\n-        } else {\n-            err.note(\"trait aliases cannot be recursive\");\n-        }\n+        cycle_stack.push(CycleStack { span, desc: query.description.to_owned() });\n     }\n \n+    let mut cycle_usage = None;\n     if let Some((span, query)) = usage {\n-        err.span_note(query.default_span(span), &format!(\"cycle used when {}\", query.description));\n+        cycle_usage = Some(crate::error::CycleUsage {\n+            span: query.default_span(span),\n+            usage: query.description,\n+        });\n     }\n \n-    err\n+    let alias = if stack.iter().all(|entry| entry.query.def_kind == Some(DefKind::TyAlias)) {\n+        Some(crate::error::Alias::Ty)\n+    } else if stack.iter().all(|entry| entry.query.def_kind == Some(DefKind::TraitAlias)) {\n+        Some(crate::error::Alias::Trait)\n+    } else {\n+        None\n+    };\n+\n+    let cycle_diag = crate::error::Cycle {\n+        span,\n+        cycle_stack,\n+        stack_bottom: stack[0].query.description.to_owned(),\n+        alias,\n+        cycle_usage: cycle_usage,\n+        stack_count,\n+    };\n+\n+    cycle_diag.into_diagnostic(&sess.parse_sess)\n }\n \n pub fn print_query_stack<CTX: QueryContext>("}, {"sha": "c6197b9fedb225c0356539f4370b501a3f8dadde", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -125,6 +125,6 @@ pub trait QueryContext: HasDepContext {\n     ) -> R;\n \n     fn depth_limit_error(&self) {\n-        self.dep_context().sess().fatal(\"queries overflow the depth limit!\");\n+        self.dep_context().sess().emit_fatal(crate::error::QueryOverflow);\n     }\n }"}, {"sha": "e97411b777b4f847740916904d6390621f8a724b", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -618,16 +618,12 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n     let old_in_panic = INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.replace(true));\n \n     if old_in_panic {\n-        sess.struct_err(\n-            \"internal compiler error: re-entrant incremental verify failure, suppressing message\",\n-        )\n-        .emit();\n+        sess.emit_err(crate::error::Reentrant);\n     } else {\n-        sess.struct_err(&format!(\"internal compiler error: encountered incremental compilation error with {:?}\", dep_node))\n-                .help(&format!(\"This is a known issue with the compiler. Run {} to allow your project to compile\", run_cmd))\n-                .note(\"Please follow the instructions below to create a bug report with the provided information\")\n-                .note(\"See <https://github.com/rust-lang/rust/issues/84970> for more information\")\n-                .emit();\n+        sess.emit_err(crate::error::IncrementCompilation {\n+            run_cmd,\n+            dep_node: format!(\"{:?}\", dep_node),\n+        });\n         panic!(\"Found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n     }\n "}, {"sha": "f0843c60543df4203c9a15cb6a8560196567aa82", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 20, "deletions": 144, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -167,8 +167,8 @@ enum P {\n #[derive(SessionSubdiagnostic)]\n enum Q {\n     #[bar]\n-    //~^ ERROR `#[bar]` is not a valid attribute\n-    //~^^ ERROR cannot find attribute `bar` in this scope\n+//~^ ERROR `#[bar]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -179,8 +179,8 @@ enum Q {\n #[derive(SessionSubdiagnostic)]\n enum R {\n     #[bar = \"...\"]\n-    //~^ ERROR `#[bar = ...]` is not a valid attribute\n-    //~^^ ERROR cannot find attribute `bar` in this scope\n+//~^ ERROR `#[bar = ...]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -191,8 +191,8 @@ enum R {\n #[derive(SessionSubdiagnostic)]\n enum S {\n     #[bar = 4]\n-    //~^ ERROR `#[bar = ...]` is not a valid attribute\n-    //~^^ ERROR cannot find attribute `bar` in this scope\n+//~^ ERROR `#[bar = ...]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -203,8 +203,8 @@ enum S {\n #[derive(SessionSubdiagnostic)]\n enum T {\n     #[bar(\"...\")]\n-    //~^ ERROR `#[bar(...)]` is not a valid attribute\n-    //~^^ ERROR cannot find attribute `bar` in this scope\n+//~^ ERROR `#[bar(\"...\")]` is not a valid attribute\n+//~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -215,7 +215,7 @@ enum T {\n #[derive(SessionSubdiagnostic)]\n enum U {\n     #[label(code = \"...\")]\n-    //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -232,7 +232,7 @@ enum V {\n         var: String,\n     },\n     B {\n-    //~^ ERROR subdiagnostic kind not specified\n+//~^ ERROR subdiagnostic kind not specified\n         #[primary_span]\n         span: Span,\n         var: String,\n@@ -307,16 +307,6 @@ union AC {\n     b: u64\n }\n \n-#[derive(SessionSubdiagnostic)]\n-#[label(parser::add_paren)]\n-//~^ NOTE previously specified here\n-#[label(parser::add_paren)]\n-//~^ ERROR specified multiple times\n-struct AD {\n-    #[primary_span]\n-    span: Span,\n-}\n-\n #[derive(SessionSubdiagnostic)]\n #[label(parser::add_paren, parser::add_paren)]\n //~^ ERROR `#[label(parser::add_paren)]` is not a valid attribute\n@@ -329,16 +319,16 @@ struct AE {\n #[label(parser::add_paren)]\n struct AF {\n     #[primary_span]\n-    //~^ NOTE previously specified here\n+//~^ NOTE previously specified here\n     span_a: Span,\n     #[primary_span]\n-    //~^ ERROR specified multiple times\n+//~^ ERROR specified multiple times\n     span_b: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n struct AG {\n-    //~^ ERROR subdiagnostic kind not specified\n+//~^ ERROR subdiagnostic kind not specified\n     #[primary_span]\n     span: Span,\n }\n@@ -390,25 +380,27 @@ struct AK {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-    //~^ NOTE previously specified here\n+//~^ NOTE previously specified here\n     applicability_a: Applicability,\n     #[applicability]\n-    //~^ ERROR specified multiple times\n+//~^ ERROR specified multiple times\n     applicability_b: Applicability,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n struct AL {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-    //~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+//~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n     applicability: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n+//~^ ERROR suggestion without `applicability`\n struct AM {\n     #[primary_span]\n     span: Span,\n@@ -444,7 +436,8 @@ struct AQ;\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `#[primary_span]` field\n+//~^ ERROR suggestion without `applicability`\n+//~^^ ERROR suggestion without `#[primary_span]` field\n struct AR {\n     var: String,\n }\n@@ -514,120 +507,3 @@ struct AZ {\n     #[primary_span]\n     span: Span,\n }\n-\n-#[derive(SessionSubdiagnostic)]\n-#[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `#[primary_span]` field\n-struct BA {\n-    #[suggestion_part]\n-    //~^ ERROR `#[suggestion_part]` is not a valid attribute\n-    span: Span,\n-    #[suggestion_part(code = \"...\")]\n-    //~^ ERROR `#[suggestion_part(...)]` is not a valid attribute\n-    span2: Span,\n-    #[applicability]\n-    applicability: Applicability,\n-    var: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n-//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n-//~| ERROR `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n-struct BBa {\n-    var: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-struct BBb {\n-    #[suggestion_part]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-    span1: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-struct BBc {\n-    #[suggestion_part()]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-    span1: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n-//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n-struct BC {\n-    #[primary_span]\n-    //~^ ERROR `#[primary_span]` is not a valid attribute\n-    span: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n-struct BD {\n-    #[suggestion_part]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-    span1: Span,\n-    #[suggestion_part()]\n-    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-    span2: Span,\n-    #[suggestion_part(foo = \"bar\")]\n-    //~^ ERROR `#[suggestion_part(foo = ...)]` is not a valid attribute\n-    span4: Span,\n-    #[suggestion_part(code = \"...\")]\n-    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-    s1: String,\n-    #[suggestion_part()]\n-    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-    s2: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-struct BE {\n-    #[suggestion_part(code = \"...\", code = \",,,\")]\n-    //~^ ERROR specified multiple times\n-    //~| NOTE previously specified here\n-    span: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-struct BF {\n-    #[suggestion_part(code = \"(\")]\n-    first: Span,\n-    #[suggestion_part(code = \")\")]\n-    second: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren)]\n-struct BG {\n-    #[applicability]\n-    appl: Applicability,\n-    #[suggestion_part(code = \"(\")]\n-    first: Span,\n-    #[suggestion_part(code = \")\")]\n-    second: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-//~^ NOTE previously specified here\n-struct BH {\n-    #[applicability]\n-    //~^ ERROR specified multiple times\n-    appl: Applicability,\n-    #[suggestion_part(code = \"(\")]\n-    first: Span,\n-    #[suggestion_part(code = \")\")]\n-    second: Span,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-struct BI {\n-    #[suggestion_part(code = \"\")]\n-    spans: Vec<Span>,\n-}"}, {"sha": "6bd9144dbf6f0b8e8be1ca2dfb273f4cb1b17cb8", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 65, "deletions": 169, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/22c5c83a680b17a01669e01246cc7b39cea5c8d2/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22c5c83a680b17a01669e01246cc7b39cea5c8d2/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=22c5c83a680b17a01669e01246cc7b39cea5c8d2", "patch": "@@ -65,16 +65,16 @@ LL | #[label()]\n    | ^^^^^^^^^^\n \n error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:137:28\n+  --> $DIR/subdiagnostic-derive.rs:137:1\n    |\n LL | #[label(parser::add_paren, code = \"...\")]\n-   |                            ^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `applicability` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:146:28\n+  --> $DIR/subdiagnostic-derive.rs:146:1\n    |\n LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n   --> $DIR/subdiagnostic-derive.rs:155:1\n@@ -100,11 +100,13 @@ error: `#[bar = ...]` is not a valid attribute\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n-error: `#[bar(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:205:5\n+error: `#[bar(\"...\")]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:205:11\n    |\n LL |     #[bar(\"...\")]\n-   |     ^^^^^^^^^^^^^\n+   |           ^^^^^\n+   |\n+   = help: first argument of the attribute should be the diagnostic slug\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:217:5\n@@ -161,8 +163,6 @@ error: `#[bar(...)]` is not a valid attribute\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n-   |\n-   = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n   --> $DIR/subdiagnostic-derive.rs:304:1\n@@ -174,246 +174,142 @@ LL | |     b: u64\n LL | | }\n    | |_^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:313:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:311:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:321:28\n+  --> $DIR/subdiagnostic-derive.rs:311:28\n    |\n LL | #[label(parser::add_paren, parser::add_paren)]\n    |                            ^^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:334:5\n+  --> $DIR/subdiagnostic-derive.rs:324:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:331:5\n+  --> $DIR/subdiagnostic-derive.rs:321:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:340:8\n+  --> $DIR/subdiagnostic-derive.rs:330:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:377:47\n+  --> $DIR/subdiagnostic-derive.rs:367:47\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:377:33\n+  --> $DIR/subdiagnostic-derive.rs:367:33\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:395:5\n+  --> $DIR/subdiagnostic-derive.rs:385:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:392:5\n+  --> $DIR/subdiagnostic-derive.rs:382:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:405:5\n+  --> $DIR/subdiagnostic-derive.rs:396:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:418:1\n-   |\n-LL | #[suggestion(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:428:46\n-   |\n-LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^\n-\n-error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:446:1\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:391:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AR {\n-LL | |     var: String,\n+LL | | struct AL {\n+LL | |     #[primary_span]\n+...  |\n+LL | |     applicability: Span,\n LL | | }\n    | |_^\n \n-error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:460:1\n-   |\n-LL | #[label]\n-   | ^^^^^^^^\n-\n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:480:39\n-   |\n-LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                       ^^^^^^^\n-\n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:499:43\n-   |\n-LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^\n-\n-error: `#[suggestion_part]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:522:5\n-   |\n-LL |     #[suggestion_part]\n-   |     ^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n-\n-error: `#[suggestion_part(...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:525:5\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:402:1\n    |\n-LL |     #[suggestion_part(code = \"...\")]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | |\n+LL | | struct AM {\n+LL | |     #[primary_span]\n+LL | |     span: Span,\n+LL | | }\n+   | |_^\n \n-error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:519:1\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:410:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | / #[suggestion(parser::add_paren)]\n LL | |\n-LL | | struct BA {\n-LL | |     #[suggestion_part]\n+LL | | struct AN {\n+LL | |     #[primary_span]\n ...  |\n-LL | |     var: String,\n+LL | |     applicability: Applicability,\n LL | | }\n    | |_^\n \n-error: `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n-  --> $DIR/subdiagnostic-derive.rs:534:43\n+error: invalid applicability\n+  --> $DIR/subdiagnostic-derive.rs:420:46\n    |\n-LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^^^^^^\n+LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n-error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:534:1\n+error: suggestion without `applicability`\n+  --> $DIR/subdiagnostic-derive.rs:438:1\n    |\n-LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n LL | |\n-LL | | struct BBa {\n+LL | | struct AR {\n LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:544:5\n-   |\n-LL |     #[suggestion_part]\n-   |     ^^^^^^^^^^^^^^^^^^\n-\n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:552:5\n-   |\n-LL |     #[suggestion_part()]\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n-error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:561:5\n-   |\n-LL |     #[primary_span]\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-   = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n-\n-error: multipart suggestion without any `#[suggestion_part(...)]` fields\n-  --> $DIR/subdiagnostic-derive.rs:558:1\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:438:1\n    |\n-LL | / #[multipart_suggestion(parser::add_paren)]\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct BC {\n-LL | |     #[primary_span]\n LL | |\n-LL | |     span: Span,\n+LL | | struct AR {\n+LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:569:5\n-   |\n-LL |     #[suggestion_part]\n-   |     ^^^^^^^^^^^^^^^^^^\n-\n-error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:572:5\n-   |\n-LL |     #[suggestion_part()]\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-\n-error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:575:23\n-   |\n-LL |     #[suggestion_part(foo = \"bar\")]\n-   |                       ^^^^^^^^^^^\n-   |\n-   = help: `code` is the only valid nested attribute\n-\n-error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:578:5\n-   |\n-LL |     #[suggestion_part(code = \"...\")]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/subdiagnostic-derive.rs:581:5\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:453:1\n    |\n-LL |     #[suggestion_part()]\n-   |     ^^^^^^^^^^^^^^^^^^^^\n+LL | #[label]\n+   | ^^^^^^^^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:589:37\n-   |\n-LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n-   |                                     ^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:589:23\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:473:39\n    |\n-LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n-   |                       ^^^^^^^^^^^^\n+LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                       ^^^^^^^\n \n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:619:5\n-   |\n-LL |     #[applicability]\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:616:43\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:492:43\n    |\n-LL | #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -475,6 +371,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 64 previous errors\n+error: aborting due to 50 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}]}