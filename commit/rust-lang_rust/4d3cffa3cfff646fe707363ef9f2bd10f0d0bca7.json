{"sha": "4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkM2NmZmEzY2ZmZjY0NmZlNzA3MzYzZWY5ZjJiZDEwZjBkMGJjYTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-01T20:57:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-01T21:56:49Z"}, "message": "std: Fix unsoundness of std::thread::ScopedKey\n\nCurrently the compiler has no knowledge of `#[thread_local]` which forces users\nto take on two burdens of unsafety:\n\n* The lifetime of the borrow of a `#[thread_local]` static is **not** `'static`\n* Types in `static`s are required to be `Sync`\n\nThe thread-local modules mostly curb these facets of unsafety by only allowing\nvery limited scopes of borrows as well as allowing all types to be stored in a\nthread-local key (regardless of whether they are `Sync`) through an `unsafe\nimpl`.\n\nUnfortunately these measures have the consequence of being able to take the\naddress of the key itself and send it to another thread, allowing the same key\nto be accessed from two different threads. This is clearly unsafe, and this\ncommit fixes this problem with the same trick used by `LocalKey`, which is to\nhave an indirect function call to find the address of the *current thread's*\nthread local. This way the address of thread local keys can safely be sent among\nthreads as their lifetime truly is `'static`.\n\nThis commit will reduce the performance of cross-crate scoped thread locals as\nit now requires an indirect function call, but this can likely be overcome in a\nfuture commit.\n\nCloses #25894", "tree": {"sha": "1b1f6e324db673ee9e52637ace4dbddc307354f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1f6e324db673ee9e52637ace4dbddc307354f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "html_url": "https://github.com/rust-lang/rust/commit/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a49ae5bd4378cb47fd5cfdcd0c31e04d55373696", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49ae5bd4378cb47fd5cfdcd0c31e04d55373696", "html_url": "https://github.com/rust-lang/rust/commit/a49ae5bd4378cb47fd5cfdcd0c31e04d55373696"}], "stats": {"total": 80, "additions": 48, "deletions": 32}, "files": [{"sha": "153b04360877b36546e62ffbf6b5220f9379717d", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "patch": "@@ -217,6 +217,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n pub use self::scoped_tls::ScopedKey;\n \n #[doc(hidden)] pub use self::local::__KeyInner as __LocalKeyInner;\n+#[doc(hidden)] pub use self::scoped_tls::__KeyInner as __ScopedKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "679902ec7abdb0fdaad47b0deb44b4de3e7c1a13", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=4d3cffa3cfff646fe707363ef9f2bd10f0d0bca7", "patch": "@@ -43,6 +43,9 @@\n \n use prelude::v1::*;\n \n+#[doc(hidden)]\n+pub use self::imp::KeyInner as __KeyInner;\n+\n /// Type representing a thread local storage key corresponding to a reference\n /// to the type parameter `T`.\n ///\n@@ -53,7 +56,7 @@ use prelude::v1::*;\n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n-pub struct ScopedKey<T> { inner: imp::KeyInner<T> }\n+pub struct ScopedKey<T> { inner: fn() -> &'static imp::KeyInner<T> }\n \n /// Declare a new scoped thread local storage key.\n ///\n@@ -64,51 +67,60 @@ pub struct ScopedKey<T> { inner: imp::KeyInner<T> }\n /// information.\n #[macro_export]\n #[allow_internal_unstable]\n-#[cfg(not(no_elf_tls))]\n macro_rules! scoped_thread_local {\n     (static $name:ident: $t:ty) => (\n-        #[cfg_attr(not(any(windows,\n-                           target_os = \"android\",\n-                           target_os = \"ios\",\n-                           target_os = \"openbsd\",\n-                           target_arch = \"aarch64\")),\n-                   thread_local)]\n         static $name: ::std::thread::ScopedKey<$t> =\n-            ::std::thread::ScopedKey::new();\n+            __scoped_thread_local_inner!($t);\n     );\n     (pub static $name:ident: $t:ty) => (\n-        #[cfg_attr(not(any(windows,\n-                           target_os = \"android\",\n-                           target_os = \"ios\",\n-                           target_os = \"openbsd\",\n-                           target_arch = \"aarch64\")),\n-                   thread_local)]\n         pub static $name: ::std::thread::ScopedKey<$t> =\n-            ::std::thread::ScopedKey::new();\n+            __scoped_thread_local_inner!($t);\n     );\n }\n \n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\",\n+           reason = \"should not be necessary\")]\n #[macro_export]\n #[allow_internal_unstable]\n #[cfg(no_elf_tls)]\n-macro_rules! scoped_thread_local {\n-    (static $name:ident: $t:ty) => (\n-        static $name: ::std::thread::ScopedKey<$t> =\n-            ::std::thread::ScopedKey::new();\n-    );\n-    (pub static $name:ident: $t:ty) => (\n-        pub static $name: ::std::thread::ScopedKey<$t> =\n-            ::std::thread::ScopedKey::new();\n-    );\n+macro_rules! __scoped_thread_local_inner {\n+    ($t:ty) => {{\n+        static _KEY: ::std::thread::__ScopedKeyInner<$t> =\n+            ::std::thread::__ScopedKeyInner::new();\n+        fn _getit() -> &'static ::std::thread::__ScopedKeyInner<$t> { &_KEY }\n+        ::std::thread::ScopedKey::new(_getit)\n+    }}\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\",\n+           reason = \"should not be necessary\")]\n+#[macro_export]\n+#[allow_internal_unstable]\n+#[cfg(not(no_elf_tls))]\n+macro_rules! __scoped_thread_local_inner {\n+    ($t:ty) => {{\n+        #[cfg_attr(not(any(windows,\n+                           target_os = \"android\",\n+                           target_os = \"ios\",\n+                           target_os = \"openbsd\",\n+                           target_arch = \"aarch64\")),\n+                   thread_local)]\n+        static _KEY: ::std::thread::__ScopedKeyInner<$t> =\n+            ::std::thread::__ScopedKeyInner::new();\n+        fn _getit() -> &'static ::std::thread::__ScopedKeyInner<$t> { &_KEY }\n+        ::std::thread::ScopedKey::new(_getit)\n+    }}\n }\n \n #[unstable(feature = \"scoped_tls\",\n            reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                      stabilizing its interface\")]\n impl<T> ScopedKey<T> {\n     #[doc(hidden)]\n-    pub const fn new() -> ScopedKey<T> {\n-        ScopedKey { inner: imp::KeyInner::new() }\n+    pub const fn new(inner: fn() -> &'static imp::KeyInner<T>) -> ScopedKey<T> {\n+        ScopedKey { inner: inner }\n     }\n \n     /// Inserts a value into this scoped thread local storage slot for a\n@@ -153,13 +165,14 @@ impl<T> ScopedKey<T> {\n             }\n         }\n \n+        let inner = (self.inner)();\n         let prev = unsafe {\n-            let prev = self.inner.get();\n-            self.inner.set(t as *const T as *mut T);\n+            let prev = inner.get();\n+            inner.set(t as *const T as *mut T);\n             prev\n         };\n \n-        let _reset = Reset { key: &self.inner, val: prev };\n+        let _reset = Reset { key: inner, val: prev };\n         cb()\n     }\n \n@@ -186,7 +199,7 @@ impl<T> ScopedKey<T> {\n         F: FnOnce(&T) -> R\n     {\n         unsafe {\n-            let ptr = self.inner.get();\n+            let ptr = (self.inner)().get();\n             assert!(!ptr.is_null(), \"cannot access a scoped thread local \\\n                                      variable without calling `set` first\");\n             cb(&*ptr)\n@@ -195,7 +208,7 @@ impl<T> ScopedKey<T> {\n \n     /// Test whether this TLS key has been `set` for the current thread.\n     pub fn is_set(&'static self) -> bool {\n-        unsafe { !self.inner.get().is_null() }\n+        unsafe { !(self.inner)().get().is_null() }\n     }\n }\n \n@@ -205,6 +218,7 @@ impl<T> ScopedKey<T> {\n               target_os = \"openbsd\",\n               target_arch = \"aarch64\",\n               no_elf_tls)))]\n+#[doc(hidden)]\n mod imp {\n     use std::cell::Cell;\n \n@@ -227,6 +241,7 @@ mod imp {\n           target_os = \"openbsd\",\n           target_arch = \"aarch64\",\n           no_elf_tls))]\n+#[doc(hidden)]\n mod imp {\n     use prelude::v1::*;\n "}]}