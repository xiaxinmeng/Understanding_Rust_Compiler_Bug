{"sha": "5919f62cf6681979cb5401d3907445f14d27ec8f", "node_id": "C_kwDOAAsO6NoAKDU5MTlmNjJjZjY2ODE5NzljYjU0MDFkMzkwNzQ0NWYxNGQyN2VjOGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T10:42:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-09T10:42:15Z"}, "message": "Auto merge of #107840 - matthiaskrgr:rollup-e6v7x0a, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #107446 (Migrate some of `rustc_parse` to derive diagnostics)\n - #107752 (Specify dlltool prefix when generating import libs)\n - #107808 (bootstrap.py: fix build-failure message)\n - #107834 (create symlink for legacy rustfmt path)\n - #107835 (use idiomatic formatting)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3c13a999562eee41ed85e413270c4e7f6a78c8ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c13a999562eee41ed85e413270c4e7f6a78c8ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5919f62cf6681979cb5401d3907445f14d27ec8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5919f62cf6681979cb5401d3907445f14d27ec8f", "html_url": "https://github.com/rust-lang/rust/commit/5919f62cf6681979cb5401d3907445f14d27ec8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5919f62cf6681979cb5401d3907445f14d27ec8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c40919b7a75f93ed7ef040361e82c656d246d41e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c40919b7a75f93ed7ef040361e82c656d246d41e", "html_url": "https://github.com/rust-lang/rust/commit/c40919b7a75f93ed7ef040361e82c656d246d41e"}, {"sha": "f2a2e298bafd113fc277ce6fc53df340f55c3cd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a2e298bafd113fc277ce6fc53df340f55c3cd0", "html_url": "https://github.com/rust-lang/rust/commit/f2a2e298bafd113fc277ce6fc53df340f55c3cd0"}], "stats": {"total": 1101, "additions": 696, "deletions": 405}, "files": [{"sha": "dd3268d7780c6acdc18a7a537e17d5b340dbb9c3", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -183,6 +183,12 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             // able to control the *exact* spelling of each of the symbols that are being imported:\n             // hence we don't want `dlltool` adding leading underscores automatically.\n             let dlltool = find_binutils_dlltool(sess);\n+            let temp_prefix = {\n+                let mut path = PathBuf::from(&output_path);\n+                path.pop();\n+                path.push(lib_name);\n+                path\n+            };\n             let result = std::process::Command::new(dlltool)\n                 .args([\n                     \"-d\",\n@@ -192,6 +198,8 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                     \"-l\",\n                     output_path.to_str().unwrap(),\n                     \"--no-leading-underscore\",\n+                    \"--temp-prefix\",\n+                    temp_prefix.to_str().unwrap(),\n                 ])\n                 .output();\n "}, {"sha": "c9cf7b62071fe0daa003562de45d31585f40b3dd", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -585,3 +585,118 @@ parse_negative_bounds_not_supported = negative bounds are not supported\n parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n+\n+parse_unexpected_token_after_dot = unexpected token: `{$actual}`\n+\n+parse_cannot_be_raw_ident = `{$ident}` cannot be a raw identifier\n+\n+parse_cr_doc_comment = bare CR not allowed in {$block ->\n+    [true] block doc-comment\n+    *[false] doc-comment\n+}\n+\n+parse_no_digits_literal = no valid digits found for number\n+\n+parse_invalid_digit_literal = invalid digit for a base {$base} literal\n+\n+parse_empty_exponent_float = expected at least one digit in exponent\n+\n+parse_float_literal_unsupported_base = {$base} float literal is not supported\n+\n+parse_more_than_one_char = character literal may only contain one codepoint\n+    .followed_by = this `{$chr}` is followed by the combining {$len ->\n+        [one] mark\n+        *[other] marks\n+        } `{$escaped_marks}`\n+    .non_printing = there are non-printing characters, the full sequence is `{$escaped}`\n+    .consider_normalized = consider using the normalized form `{$ch}` of this character\n+    .remove_non = consider removing the non-printing characters\n+    .use_double_quotes = if you meant to write a {$is_byte ->\n+        [true] byte string\n+        *[false] `str`\n+        } literal, use double quotes\n+\n+parse_no_brace_unicode_escape = incorrect unicode escape sequence\n+    .label = {parse_no_brace_unicode_escape}\n+    .use_braces = format of unicode escape sequences uses braces\n+    .format_of_unicode = format of unicode escape sequences is `\\u{\"{...}\"}`\n+\n+parse_invalid_unicode_escape = invalid unicode character escape\n+    .label = invalid escape\n+    .help = unicode escape must {$surrogate ->\n+    [true] not be a surrogate\n+    *[false] be at most 10FFFF\n+    }\n+\n+parse_escape_only_char = {$byte ->\n+    [true] byte\n+    *[false] character\n+    } constant must be escaped: `{$escaped_msg}`\n+    .escape = escape the character\n+\n+parse_bare_cr = {$double_quotes ->\n+    [true] bare CR not allowed in string, use `\\r` instead\n+    *[false] character constant must be escaped: `\\r`\n+    }\n+    .escape = escape the character\n+\n+parse_bare_cr_in_raw_string = bare CR not allowed in raw string\n+\n+parse_too_short_hex_escape = numeric character escape is too short\n+\n+parse_invalid_char_in_escape = {parse_invalid_char_in_escape_msg}: `{$ch}`\n+    .label = {parse_invalid_char_in_escape_msg}\n+\n+parse_invalid_char_in_escape_msg = invalid character in {$is_hex ->\n+    [true] numeric character\n+    *[false] unicode\n+    } escape\n+\n+parse_out_of_range_hex_escape = out of range hex escape\n+    .label = must be a character in the range [\\x00-\\x7f]\n+\n+parse_leading_underscore_unicode_escape = {parse_leading_underscore_unicode_escape_label}: `_`\n+parse_leading_underscore_unicode_escape_label = invalid start of unicode escape\n+\n+parse_overlong_unicode_escape = overlong unicode escape\n+    .label = must have at most 6 hex digits\n+\n+parse_unclosed_unicode_escape = unterminated unicode escape\n+    .label = missing a closing `{\"}\"}`\n+    .terminate = terminate the unicode escape\n+\n+parse_unicode_escape_in_byte = unicode escape in byte string\n+    .label = {parse_unicode_escape_in_byte}\n+    .help = unicode escape sequences cannot be used as a byte or in a byte string\n+\n+parse_empty_unicode_escape = empty unicode escape\n+    .label = this escape must have at least 1 hex digit\n+\n+parse_zero_chars = empty character literal\n+    .label = {parse_zero_chars}\n+\n+parse_lone_slash = invalid trailing slash in literal\n+    .label = {parse_lone_slash}\n+\n+parse_unskipped_whitespace = non-ASCII whitespace symbol '{$ch}' is not skipped\n+    .label = {parse_unskipped_whitespace}\n+\n+parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n+    .label = skipping everything up to and including this point\n+\n+parse_unknown_prefix = prefix `{$prefix}` is unknown\n+    .label = unknown prefix\n+    .note =  prefixed identifiers and literals are reserved since Rust 2021\n+    .suggestion_br = use `br` for a raw byte string\n+    .suggestion_whitespace = consider inserting whitespace here\n+\n+parse_too_many_hashes = too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found {$num}\n+\n+parse_unknown_start_of_token = unknown start of token: {$escaped}\n+    .sugg_quotes = Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '{$ascii_str}' ({$ascii_name}), but are not\n+    .sugg_other = Unicode character '{$ch}' ({$u_name}) looks like '{$ascii_str}' ({$ascii_name}), but it is not\n+    .help_null = source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\n+    .note_repeats = character appears {$repeats ->\n+        [one] once more\n+        *[other] {$repeats} more times\n+    }"}, {"sha": "b220a87bc658abe171e2f7cce84d9b1813710186", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -802,18 +802,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut walk = ty.walk();\n         while let Some(arg) = walk.next() {\n             if arg == param_to_point_at {\n-            return true;\n-        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, ..) = ty.kind()\n-        {\n-            // This logic may seem a bit strange, but typically when\n-            // we have a projection type in a function signature, the\n-            // argument that's being passed into that signature is\n-            // not actually constraining that projection's substs in\n-            // a meaningful way. So we skip it, and see improvements\n-            // in some UI tests.\n-            walk.skip_current_subtree();\n-        }\n+                return true;\n+            }\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Alias(ty::Projection, ..) = ty.kind()\n+            {\n+                // This logic may seem a bit strange, but typically when\n+                // we have a projection type in a function signature, the\n+                // argument that's being passed into that signature is\n+                // not actually constraining that projection's substs in\n+                // a meaningful way. So we skip it, and see improvements\n+                // in some UI tests.\n+                walk.skip_current_subtree();\n+            }\n         }\n         false\n     }"}, {"sha": "63bf864f2a812f8fc8de2159bbd3d677c8ff1223", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -1368,6 +1368,14 @@ pub(crate) struct SelfArgumentPointer {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_unexpected_token_after_dot)]\n+pub struct UnexpectedTokenAfterDot<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub actual: Cow<'a, str>,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_visibility_not_followed_by_item)]\n #[help]\n@@ -1658,6 +1666,310 @@ pub(crate) enum TopLevelOrPatternNotAllowed {\n     },\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_cannot_be_raw_ident)]\n+pub struct CannotBeRawIdent {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_cr_doc_comment)]\n+pub struct CrDocComment {\n+    #[primary_span]\n+    pub span: Span,\n+    pub block: bool,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_no_digits_literal, code = \"E0768\")]\n+pub struct NoDigitsLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_invalid_digit_literal)]\n+pub struct InvalidDigitLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+    pub base: u32,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_empty_exponent_float)]\n+pub struct EmptyExponentFloat {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_float_literal_unsupported_base)]\n+pub struct FloatLiteralUnsupportedBase {\n+    #[primary_span]\n+    pub span: Span,\n+    pub base: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unknown_prefix)]\n+#[note]\n+pub struct UnknownPrefix<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub prefix: &'a str,\n+    #[subdiagnostic]\n+    pub sugg: Option<UnknownPrefixSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UnknownPrefixSugg {\n+    #[suggestion(suggestion_br, code = \"br\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    UseBr(#[primary_span] Span),\n+    #[suggestion(\n+        suggestion_whitespace,\n+        code = \" \",\n+        applicability = \"maybe-incorrect\",\n+        style = \"verbose\"\n+    )]\n+    Whitespace(#[primary_span] Span),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_too_many_hashes)]\n+pub struct TooManyHashes {\n+    #[primary_span]\n+    pub span: Span,\n+    pub num: u32,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_unknown_start_of_token)]\n+pub struct UnknownTokenStart {\n+    #[primary_span]\n+    pub span: Span,\n+    pub escaped: String,\n+    #[subdiagnostic]\n+    pub sugg: Option<TokenSubstitution>,\n+    #[subdiagnostic]\n+    pub null: Option<UnknownTokenNull>,\n+    #[subdiagnostic]\n+    pub repeat: Option<UnknownTokenRepeat>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TokenSubstitution {\n+    #[suggestion(sugg_quotes, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    DirectedQuotes {\n+        #[primary_span]\n+        span: Span,\n+        suggestion: String,\n+        ascii_str: &'static str,\n+        ascii_name: &'static str,\n+    },\n+    #[suggestion(sugg_other, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+        suggestion: String,\n+        ch: String,\n+        u_name: &'static str,\n+        ascii_str: &'static str,\n+        ascii_name: &'static str,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(note_repeats)]\n+pub struct UnknownTokenRepeat {\n+    pub repeats: usize,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(help_null)]\n+pub struct UnknownTokenNull;\n+\n+#[derive(Diagnostic)]\n+pub enum UnescapeError {\n+    #[diag(parse_invalid_unicode_escape)]\n+    #[help]\n+    InvalidUnicodeEscape {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        surrogate: bool,\n+    },\n+    #[diag(parse_escape_only_char)]\n+    EscapeOnlyChar {\n+        #[primary_span]\n+        span: Span,\n+        #[suggestion(escape, applicability = \"machine-applicable\", code = \"{escaped_sugg}\")]\n+        char_span: Span,\n+        escaped_sugg: String,\n+        escaped_msg: String,\n+        byte: bool,\n+    },\n+    #[diag(parse_bare_cr)]\n+    BareCr {\n+        #[primary_span]\n+        #[suggestion(escape, applicability = \"machine-applicable\", code = \"\\\\r\")]\n+        span: Span,\n+        double_quotes: bool,\n+    },\n+    #[diag(parse_bare_cr_in_raw_string)]\n+    BareCrRawString(#[primary_span] Span),\n+    #[diag(parse_too_short_hex_escape)]\n+    TooShortHexEscape(#[primary_span] Span),\n+    #[diag(parse_invalid_char_in_escape)]\n+    InvalidCharInEscape {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        is_hex: bool,\n+        ch: String,\n+    },\n+    #[diag(parse_out_of_range_hex_escape)]\n+    OutOfRangeHexEscape(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_leading_underscore_unicode_escape)]\n+    LeadingUnderscoreUnicodeEscape {\n+        #[primary_span]\n+        #[label(parse_leading_underscore_unicode_escape_label)]\n+        span: Span,\n+        ch: String,\n+    },\n+    #[diag(parse_overlong_unicode_escape)]\n+    OverlongUnicodeEscape(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_unclosed_unicode_escape)]\n+    UnclosedUnicodeEscape(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+        #[suggestion(terminate, code = \"}}\", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+        Span,\n+    ),\n+    #[diag(parse_no_brace_unicode_escape)]\n+    NoBraceInUnicodeEscape {\n+        #[primary_span]\n+        span: Span,\n+        #[label]\n+        label: Option<Span>,\n+        #[subdiagnostic]\n+        sub: NoBraceUnicodeSub,\n+    },\n+    #[diag(parse_unicode_escape_in_byte)]\n+    #[help]\n+    UnicodeEscapeInByte(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_empty_unicode_escape)]\n+    EmptyUnicodeEscape(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_zero_chars)]\n+    ZeroChars(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_lone_slash)]\n+    LoneSlash(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_unskipped_whitespace)]\n+    UnskippedWhitespace {\n+        #[primary_span]\n+        span: Span,\n+        #[label]\n+        char_span: Span,\n+        ch: String,\n+    },\n+    #[diag(parse_multiple_skipped_lines)]\n+    MultipleSkippedLinesWarning(\n+        #[primary_span]\n+        #[label]\n+        Span,\n+    ),\n+    #[diag(parse_more_than_one_char)]\n+    MoreThanOneChar {\n+        #[primary_span]\n+        span: Span,\n+        #[subdiagnostic]\n+        note: Option<MoreThanOneCharNote>,\n+        #[subdiagnostic]\n+        suggestion: MoreThanOneCharSugg,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum MoreThanOneCharSugg {\n+    #[suggestion(consider_normalized, code = \"{normalized}\", applicability = \"machine-applicable\")]\n+    NormalizedForm {\n+        #[primary_span]\n+        span: Span,\n+        ch: String,\n+        normalized: String,\n+    },\n+    #[suggestion(remove_non, code = \"{ch}\", applicability = \"maybe-incorrect\")]\n+    RemoveNonPrinting {\n+        #[primary_span]\n+        span: Span,\n+        ch: String,\n+    },\n+    #[suggestion(use_double_quotes, code = \"{sugg}\", applicability = \"machine-applicable\")]\n+    Quotes {\n+        #[primary_span]\n+        span: Span,\n+        is_byte: bool,\n+        sugg: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum MoreThanOneCharNote {\n+    #[note(followed_by)]\n+    AllCombining {\n+        #[primary_span]\n+        span: Span,\n+        chr: String,\n+        len: usize,\n+        escaped_marks: String,\n+    },\n+    #[note(non_printing)]\n+    NonPrinting {\n+        #[primary_span]\n+        span: Span,\n+        escaped: String,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NoBraceUnicodeSub {\n+    #[suggestion(use_braces, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion: String,\n+    },\n+    #[help(format_of_unicode)]\n+    Help,\n+}\n+\n #[derive(Subdiagnostic)]\n pub(crate) enum TopLevelOrPatternNotAllowedSugg {\n     #[suggestion("}, {"sha": "bd998ed91d977d8f68a89e54f091e9b95b72e535", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 47, "deletions": 112, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -1,11 +1,10 @@\n+use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult, StashKey,\n-};\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, PResult, StashKey};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n@@ -151,7 +150,7 @@ impl<'a> StringReader<'a> {\n                     let span = self.mk_sp(start, self.pos);\n                     self.sess.symbol_gallery.insert(sym, span);\n                     if !sym.can_be_raw() {\n-                        self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", sym));\n+                        self.sess.emit_err(errors::CannotBeRawIdent { span, ident: sym });\n                     }\n                     self.sess.raw_identifier_spans.borrow_mut().push(span);\n                     token::Ident(sym, true)\n@@ -262,27 +261,24 @@ impl<'a> StringReader<'a> {\n                         self.nbsp_is_whitespace = true;\n                     }\n                     let repeats = it.take_while(|c1| *c1 == c).count();\n-                    let mut err =\n-                        self.struct_err_span_char(start, self.pos + Pos::from_usize(repeats * c.len_utf8()), \"unknown start of token\", c);\n                     // FIXME: the lexer could be used to turn the ASCII version of unicode\n                     // homoglyphs, instead of keeping a table in `check_for_substitution`into the\n                     // token. Ideally, this should be inside `rustc_lexer`. However, we should\n                     // first remove compound tokens like `<<` from `rustc_lexer`, and then add\n                     // fancier error recovery to it, as there will be less overall work to do this\n                     // way.\n-                    let token = unicode_chars::check_for_substitution(self, start, c, &mut err, repeats+1);\n-                    if c == '\\x00' {\n-                        err.help(\"source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\");\n-                    }\n-                    if repeats > 0 {\n-                        if repeats == 1 {\n-                            err.note(format!(\"character appears once more\"));\n-                        } else {\n-                            err.note(format!(\"character appears {repeats} more times\"));\n-                        }\n-                        swallow_next_invalid = repeats;\n-                    }\n-                    err.emit();\n+                    let (token, sugg) = unicode_chars::check_for_substitution(self, start, c, repeats+1);\n+                    self.sess.emit_err(errors::UnknownTokenStart {\n+                        span: self.mk_sp(start, self.pos + Pos::from_usize(repeats * c.len_utf8())),\n+                        escaped: escaped_char(c),\n+                        sugg,\n+                        null: if c == '\\x00' {Some(errors::UnknownTokenNull)} else {None},\n+                        repeat: if repeats > 0 {\n+                            swallow_next_invalid = repeats;\n+                            Some(errors::UnknownTokenRepeat { repeats })\n+                        } else {None}\n+                    });\n+\n                     if let Some(token) = token {\n                         token\n                     } else {\n@@ -297,26 +293,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    /// Report a fatal lexical error with a given span.\n-    fn fatal_span(&self, sp: Span, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_fatal(sp, m)\n-    }\n-\n-    /// Report a lexical error with a given span.\n-    fn err_span(&self, sp: Span, m: &str) {\n-        self.sess.span_diagnostic.struct_span_err(sp, m).emit();\n-    }\n-\n-    /// Report a fatal error spanning [`from_pos`, `to_pos`).\n-    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n-        self.fatal_span(self.mk_sp(from_pos, to_pos), m)\n-    }\n-\n-    /// Report a lexical error spanning [`from_pos`, `to_pos`).\n-    fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.err_span(self.mk_sp(from_pos, to_pos), m)\n-    }\n-\n     fn struct_fatal_span_char(\n         &self,\n         from_pos: BytePos,\n@@ -329,18 +305,6 @@ impl<'a> StringReader<'a> {\n             .struct_span_fatal(self.mk_sp(from_pos, to_pos), &format!(\"{}: {}\", m, escaped_char(c)))\n     }\n \n-    fn struct_err_span_char(\n-        &self,\n-        from_pos: BytePos,\n-        to_pos: BytePos,\n-        m: &str,\n-        c: char,\n-    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        self.sess\n-            .span_diagnostic\n-            .struct_span_err(self.mk_sp(from_pos, to_pos), &format!(\"{}: {}\", m, escaped_char(c)))\n-    }\n-\n     /// Detect usages of Unicode codepoints changing the direction of the text on screen and loudly\n     /// complain about it.\n     fn lint_unicode_text_flow(&self, start: BytePos) {\n@@ -368,14 +332,12 @@ impl<'a> StringReader<'a> {\n     ) -> TokenKind {\n         if content.contains('\\r') {\n             for (idx, _) in content.char_indices().filter(|&(_, c)| c == '\\r') {\n-                self.err_span_(\n+                let span = self.mk_sp(\n                     content_start + BytePos(idx as u32),\n                     content_start + BytePos(idx as u32 + 1),\n-                    match comment_kind {\n-                        CommentKind::Line => \"bare CR not allowed in doc-comment\",\n-                        CommentKind::Block => \"bare CR not allowed in block doc-comment\",\n-                    },\n                 );\n+                let block = matches!(comment_kind, CommentKind::Block);\n+                self.sess.emit_err(errors::CrDocComment { span, block });\n             }\n         }\n \n@@ -454,26 +416,20 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n                 if empty_int {\n-                    self.sess\n-                        .span_diagnostic\n-                        .struct_span_err_with_code(\n-                            self.mk_sp(start, end),\n-                            \"no valid digits found for number\",\n-                            error_code!(E0768),\n-                        )\n-                        .emit();\n+                    let span = self.mk_sp(start, end);\n+                    self.sess.emit_err(errors::NoDigitsLiteral { span });\n                     (token::Integer, sym::integer(0))\n                 } else {\n                     if matches!(base, Base::Binary | Base::Octal) {\n                         let base = base as u32;\n                         let s = self.str_from_to(start + BytePos(2), end);\n                         for (idx, c) in s.char_indices() {\n+                            let span = self.mk_sp(\n+                                start + BytePos::from_usize(2 + idx),\n+                                start + BytePos::from_usize(2 + idx + c.len_utf8()),\n+                            );\n                             if c != '_' && c.to_digit(base).is_none() {\n-                                self.err_span_(\n-                                    start + BytePos::from_usize(2 + idx),\n-                                    start + BytePos::from_usize(2 + idx + c.len_utf8()),\n-                                    &format!(\"invalid digit for a base {} literal\", base),\n-                                );\n+                                self.sess.emit_err(errors::InvalidDigitLiteral { span, base });\n                             }\n                         }\n                     }\n@@ -482,19 +438,18 @@ impl<'a> StringReader<'a> {\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n-                    self.err_span_(start, self.pos, \"expected at least one digit in exponent\");\n+                    let span = self.mk_sp(start, self.pos);\n+                    self.sess.emit_err(errors::EmptyExponentFloat { span });\n                 }\n-                match base {\n-                    Base::Hexadecimal => {\n-                        self.err_span_(start, end, \"hexadecimal float literal is not supported\")\n-                    }\n-                    Base::Octal => {\n-                        self.err_span_(start, end, \"octal float literal is not supported\")\n-                    }\n-                    Base::Binary => {\n-                        self.err_span_(start, end, \"binary float literal is not supported\")\n-                    }\n-                    _ => {}\n+                let base = match base {\n+                    Base::Hexadecimal => Some(\"hexadecimal\"),\n+                    Base::Octal => Some(\"octal\"),\n+                    Base::Binary => Some(\"binary\"),\n+                    _ => None,\n+                };\n+                if let Some(base) = base {\n+                    let span = self.mk_sp(start, end);\n+                    self.sess.emit_err(errors::FloatLiteralUnsupportedBase { span, base });\n                 }\n                 (token::Float, self.symbol_from_to(start, end))\n             }\n@@ -644,54 +599,34 @@ impl<'a> StringReader<'a> {\n     // identifier tokens.\n     fn report_unknown_prefix(&self, start: BytePos) {\n         let prefix_span = self.mk_sp(start, self.pos);\n-        let prefix_str = self.str_from_to(start, self.pos);\n-        let msg = format!(\"prefix `{}` is unknown\", prefix_str);\n+        let prefix = self.str_from_to(start, self.pos);\n \n         let expn_data = prefix_span.ctxt().outer_expn_data();\n \n         if expn_data.edition >= Edition::Edition2021 {\n             // In Rust 2021, this is a hard error.\n-            let mut err = self.sess.span_diagnostic.struct_span_err(prefix_span, &msg);\n-            err.span_label(prefix_span, \"unknown prefix\");\n-            if prefix_str == \"rb\" {\n-                err.span_suggestion_verbose(\n-                    prefix_span,\n-                    \"use `br` for a raw byte string\",\n-                    \"br\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+            let sugg = if prefix == \"rb\" {\n+                Some(errors::UnknownPrefixSugg::UseBr(prefix_span))\n             } else if expn_data.is_root() {\n-                err.span_suggestion_verbose(\n-                    prefix_span.shrink_to_hi(),\n-                    \"consider inserting whitespace here\",\n-                    \" \",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            err.note(\"prefixed identifiers and literals are reserved since Rust 2021\");\n-            err.emit();\n+                Some(errors::UnknownPrefixSugg::Whitespace(prefix_span.shrink_to_hi()))\n+            } else {\n+                None\n+            };\n+            self.sess.emit_err(errors::UnknownPrefix { span: prefix_span, prefix, sugg });\n         } else {\n             // Before Rust 2021, only emit a lint for migration.\n             self.sess.buffer_lint_with_diagnostic(\n                 &RUST_2021_PREFIXES_INCOMPATIBLE_SYNTAX,\n                 prefix_span,\n                 ast::CRATE_NODE_ID,\n-                &msg,\n+                &format!(\"prefix `{prefix}` is unknown\"),\n                 BuiltinLintDiagnostics::ReservedPrefix(prefix_span),\n             );\n         }\n     }\n \n-    fn report_too_many_hashes(&self, start: BytePos, found: u32) -> ! {\n-        self.fatal_span_(\n-            start,\n-            self.pos,\n-            &format!(\n-                \"too many `#` symbols: raw strings may be delimited \\\n-                by up to 255 `#` symbols, but found {}\",\n-                found\n-            ),\n-        )\n+    fn report_too_many_hashes(&self, start: BytePos, num: u32) -> ! {\n+        self.sess.emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });\n     }\n \n     fn cook_quoted("}, {"sha": "0d12ec6081d839adf0cfdecd8daf6ebbe5044c6c", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 74, "deletions": 174, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -3,10 +3,12 @@\n use std::iter::once;\n use std::ops::Range;\n \n-use rustc_errors::{pluralize, Applicability, Handler};\n+use rustc_errors::{Applicability, Handler};\n use rustc_lexer::unescape::{EscapeError, Mode};\n use rustc_span::{BytePos, Span};\n \n+use crate::errors::{MoreThanOneCharNote, MoreThanOneCharSugg, NoBraceUnicodeSub, UnescapeError};\n+\n pub(crate) fn emit_unescape_error(\n     handler: &Handler,\n     // interior part of the literal, without quotes\n@@ -31,53 +33,32 @@ pub(crate) fn emit_unescape_error(\n     };\n     match error {\n         EscapeError::LoneSurrogateUnicodeEscape => {\n-            handler\n-                .struct_span_err(span, \"invalid unicode character escape\")\n-                .span_label(span, \"invalid escape\")\n-                .help(\"unicode escape must not be a surrogate\")\n-                .emit();\n+            handler.emit_err(UnescapeError::InvalidUnicodeEscape { span, surrogate: true });\n         }\n         EscapeError::OutOfRangeUnicodeEscape => {\n-            handler\n-                .struct_span_err(span, \"invalid unicode character escape\")\n-                .span_label(span, \"invalid escape\")\n-                .help(\"unicode escape must be at most 10FFFF\")\n-                .emit();\n+            handler.emit_err(UnescapeError::InvalidUnicodeEscape { span, surrogate: false });\n         }\n         EscapeError::MoreThanOneChar => {\n             use unicode_normalization::{char::is_combining_mark, UnicodeNormalization};\n+            let mut sugg = None;\n+            let mut note = None;\n \n-            let mut has_help = false;\n-            let mut handler = handler.struct_span_err(\n-                span_with_quotes,\n-                \"character literal may only contain one codepoint\",\n-            );\n-\n-            if lit.chars().skip(1).all(|c| is_combining_mark(c)) {\n-                let escaped_marks =\n-                    lit.chars().skip(1).map(|c| c.escape_default().to_string()).collect::<Vec<_>>();\n-                handler.span_note(\n-                    span,\n-                    &format!(\n-                        \"this `{}` is followed by the combining mark{} `{}`\",\n-                        lit.chars().next().unwrap(),\n-                        pluralize!(escaped_marks.len()),\n-                        escaped_marks.join(\"\"),\n-                    ),\n-                );\n+            let lit_chars = lit.chars().collect::<Vec<_>>();\n+            let (first, rest) = lit_chars.split_first().unwrap();\n+            if rest.iter().copied().all(is_combining_mark) {\n                 let normalized = lit.nfc().to_string();\n                 if normalized.chars().count() == 1 {\n-                    has_help = true;\n-                    handler.span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"consider using the normalized form `{}` of this character\",\n-                            normalized.chars().next().unwrap().escape_default()\n-                        ),\n-                        normalized,\n-                        Applicability::MachineApplicable,\n-                    );\n+                    let ch = normalized.chars().next().unwrap().escape_default().to_string();\n+                    sugg = Some(MoreThanOneCharSugg::NormalizedForm { span, ch, normalized });\n                 }\n+                let escaped_marks =\n+                    rest.iter().map(|c| c.escape_default().to_string()).collect::<Vec<_>>();\n+                note = Some(MoreThanOneCharNote::AllCombining {\n+                    span,\n+                    chr: format!(\"{first}\"),\n+                    len: escaped_marks.len(),\n+                    escaped_marks: escaped_marks.join(\"\"),\n+                });\n             } else {\n                 let printable: Vec<char> = lit\n                     .chars()\n@@ -87,32 +68,18 @@ pub(crate) fn emit_unescape_error(\n                     })\n                     .collect();\n \n-                if let [ch] = printable.as_slice() {\n-                    has_help = true;\n-\n-                    handler.span_note(\n+                if let &[ch] = printable.as_slice() {\n+                    sugg =\n+                        Some(MoreThanOneCharSugg::RemoveNonPrinting { span, ch: ch.to_string() });\n+                    note = Some(MoreThanOneCharNote::NonPrinting {\n                         span,\n-                        &format!(\n-                            \"there are non-printing characters, the full sequence is `{}`\",\n-                            lit.escape_default(),\n-                        ),\n-                    );\n-\n-                    handler.span_suggestion(\n-                        span,\n-                        \"consider removing the non-printing characters\",\n-                        ch,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                        escaped: lit.escape_default().to_string(),\n+                    });\n                 }\n-            }\n-\n-            if !has_help {\n-                let (prefix, msg) = if mode.is_byte() {\n-                    (\"b\", \"if you meant to write a byte string literal, use double quotes\")\n-                } else {\n-                    (\"\", \"if you meant to write a `str` literal, use double quotes\")\n-                };\n+            };\n+            let sugg = sugg.unwrap_or_else(|| {\n+                let is_byte = mode.is_byte();\n+                let prefix = if is_byte { \"b\" } else { \"\" };\n                 let mut escaped = String::with_capacity(lit.len());\n                 let mut chrs = lit.chars().peekable();\n                 while let Some(first) = chrs.next() {\n@@ -129,54 +96,32 @@ pub(crate) fn emit_unescape_error(\n                         (c, _) => escaped.push(c),\n                     };\n                 }\n-                handler.span_suggestion(\n-                    span_with_quotes,\n-                    msg,\n-                    format!(\"{prefix}\\\"{escaped}\\\"\"),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            handler.emit();\n+                let sugg = format!(\"{prefix}\\\"{escaped}\\\"\");\n+                MoreThanOneCharSugg::Quotes { span: span_with_quotes, is_byte, sugg }\n+            });\n+            handler.emit_err(UnescapeError::MoreThanOneChar {\n+                span: span_with_quotes,\n+                note,\n+                suggestion: sugg,\n+            });\n         }\n         EscapeError::EscapeOnlyChar => {\n             let (c, char_span) = last_char();\n-\n-            let msg = if mode.is_byte() {\n-                \"byte constant must be escaped\"\n-            } else {\n-                \"character constant must be escaped\"\n-            };\n-            handler\n-                .struct_span_err(span, &format!(\"{}: `{}`\", msg, escaped_char(c)))\n-                .span_suggestion(\n-                    char_span,\n-                    \"escape the character\",\n-                    c.escape_default(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            handler.emit_err(UnescapeError::EscapeOnlyChar {\n+                span,\n+                char_span,\n+                escaped_sugg: c.escape_default().to_string(),\n+                escaped_msg: escaped_char(c),\n+                byte: mode.is_byte(),\n+            });\n         }\n         EscapeError::BareCarriageReturn => {\n-            let msg = if mode.in_double_quotes() {\n-                \"bare CR not allowed in string, use `\\\\r` instead\"\n-            } else {\n-                \"character constant must be escaped: `\\\\r`\"\n-            };\n-            handler\n-                .struct_span_err(span, msg)\n-                .span_suggestion(\n-                    span,\n-                    \"escape the character\",\n-                    \"\\\\r\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            let double_quotes = mode.in_double_quotes();\n+            handler.emit_err(UnescapeError::BareCr { span, double_quotes });\n         }\n         EscapeError::BareCarriageReturnInRawString => {\n             assert!(mode.in_double_quotes());\n-            let msg = \"bare CR not allowed in raw string\";\n-            handler.span_err(span, msg);\n+            handler.emit_err(UnescapeError::BareCrRawString(span));\n         }\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n@@ -213,22 +158,13 @@ pub(crate) fn emit_unescape_error(\n             diag.emit();\n         }\n         EscapeError::TooShortHexEscape => {\n-            handler.span_err(span, \"numeric character escape is too short\");\n+            handler.emit_err(UnescapeError::TooShortHexEscape(span));\n         }\n         EscapeError::InvalidCharInHexEscape | EscapeError::InvalidCharInUnicodeEscape => {\n             let (c, span) = last_char();\n-\n-            let msg = if error == EscapeError::InvalidCharInHexEscape {\n-                \"invalid character in numeric character escape\"\n-            } else {\n-                \"invalid character in unicode escape\"\n-            };\n-            let c = escaped_char(c);\n-\n-            handler\n-                .struct_span_err(span, &format!(\"{}: `{}`\", msg, c))\n-                .span_label(span, msg)\n-                .emit();\n+            let is_hex = error == EscapeError::InvalidCharInHexEscape;\n+            let ch = escaped_char(c);\n+            handler.emit_err(UnescapeError::InvalidCharInEscape { span, is_hex, ch });\n         }\n         EscapeError::NonAsciiCharInByte => {\n             let (c, span) = last_char();\n@@ -278,41 +214,22 @@ pub(crate) fn emit_unescape_error(\n             err.emit();\n         }\n         EscapeError::OutOfRangeHexEscape => {\n-            handler\n-                .struct_span_err(span, \"out of range hex escape\")\n-                .span_label(span, \"must be a character in the range [\\\\x00-\\\\x7f]\")\n-                .emit();\n+            handler.emit_err(UnescapeError::OutOfRangeHexEscape(span));\n         }\n         EscapeError::LeadingUnderscoreUnicodeEscape => {\n             let (c, span) = last_char();\n-            let msg = \"invalid start of unicode escape\";\n-            handler\n-                .struct_span_err(span, &format!(\"{}: `{}`\", msg, c))\n-                .span_label(span, msg)\n-                .emit();\n+            handler.emit_err(UnescapeError::LeadingUnderscoreUnicodeEscape {\n+                span,\n+                ch: escaped_char(c),\n+            });\n         }\n         EscapeError::OverlongUnicodeEscape => {\n-            handler\n-                .struct_span_err(span, \"overlong unicode escape\")\n-                .span_label(span, \"must have at most 6 hex digits\")\n-                .emit();\n+            handler.emit_err(UnescapeError::OverlongUnicodeEscape(span));\n         }\n         EscapeError::UnclosedUnicodeEscape => {\n-            handler\n-                .struct_span_err(span, \"unterminated unicode escape\")\n-                .span_label(span, \"missing a closing `}`\")\n-                .span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"terminate the unicode escape\",\n-                    \"}\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            handler.emit_err(UnescapeError::UnclosedUnicodeEscape(span, span.shrink_to_hi()));\n         }\n         EscapeError::NoBraceInUnicodeEscape => {\n-            let msg = \"incorrect unicode escape sequence\";\n-            let mut diag = handler.struct_span_err(span, msg);\n-\n             let mut suggestion = \"\\\\u{\".to_owned();\n             let mut suggestion_len = 0;\n             let (c, char_span) = last_char();\n@@ -322,54 +239,37 @@ pub(crate) fn emit_unescape_error(\n                 suggestion_len += c.len_utf8();\n             }\n \n-            if suggestion_len > 0 {\n+            let (label, sub) = if suggestion_len > 0 {\n                 suggestion.push('}');\n                 let hi = char_span.lo() + BytePos(suggestion_len as u32);\n-                diag.span_suggestion(\n-                    span.with_hi(hi),\n-                    \"format of unicode escape sequences uses braces\",\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n-                );\n+                (None, NoBraceUnicodeSub::Suggestion { span: span.with_hi(hi), suggestion })\n             } else {\n-                diag.span_label(span, msg);\n-                diag.help(\"format of unicode escape sequences is `\\\\u{...}`\");\n-            }\n-\n-            diag.emit();\n+                (Some(span), NoBraceUnicodeSub::Help)\n+            };\n+            handler.emit_err(UnescapeError::NoBraceInUnicodeEscape { span, label, sub });\n         }\n         EscapeError::UnicodeEscapeInByte => {\n-            let msg = \"unicode escape in byte string\";\n-            handler\n-                .struct_span_err(span, msg)\n-                .span_label(span, msg)\n-                .help(\"unicode escape sequences cannot be used as a byte or in a byte string\")\n-                .emit();\n+            handler.emit_err(UnescapeError::UnicodeEscapeInByte(span));\n         }\n         EscapeError::EmptyUnicodeEscape => {\n-            handler\n-                .struct_span_err(span, \"empty unicode escape\")\n-                .span_label(span, \"this escape must have at least 1 hex digit\")\n-                .emit();\n+            handler.emit_err(UnescapeError::EmptyUnicodeEscape(span));\n         }\n         EscapeError::ZeroChars => {\n-            let msg = \"empty character literal\";\n-            handler.struct_span_err(span, msg).span_label(span, msg).emit();\n+            handler.emit_err(UnescapeError::ZeroChars(span));\n         }\n         EscapeError::LoneSlash => {\n-            let msg = \"invalid trailing slash in literal\";\n-            handler.struct_span_err(span, msg).span_label(span, msg).emit();\n+            handler.emit_err(UnescapeError::LoneSlash(span));\n         }\n         EscapeError::UnskippedWhitespaceWarning => {\n             let (c, char_span) = last_char();\n-            let msg =\n-                format!(\"non-ASCII whitespace symbol '{}' is not skipped\", c.escape_unicode());\n-            handler.struct_span_warn(span, &msg).span_label(char_span, &msg).emit();\n+            handler.emit_warning(UnescapeError::UnskippedWhitespace {\n+                span,\n+                ch: escaped_char(c),\n+                char_span,\n+            });\n         }\n         EscapeError::MultipleSkippedLinesWarning => {\n-            let msg = \"multiple lines skipped by escaped newline\";\n-            let bottom_msg = \"skipping everything up to and including this point\";\n-            handler.struct_span_warn(span, msg).span_label(span, bottom_msg).emit();\n+            handler.emit_warning(UnescapeError::MultipleSkippedLinesWarning(span));\n         }\n     }\n }"}, {"sha": "d4f971d5bc84f86097a02ba526181e039fec7dc8", "filename": "compiler/rustc_parse/src/lexer/unicode_chars.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funicode_chars.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -2,8 +2,10 @@\n //! <https://www.unicode.org/Public/security/10.0.0/confusables.txt>\n \n use super::StringReader;\n-use crate::token::{self, Delimiter};\n-use rustc_errors::{Applicability, Diagnostic};\n+use crate::{\n+    errors::TokenSubstitution,\n+    token::{self, Delimiter},\n+};\n use rustc_span::{symbol::kw, BytePos, Pos, Span};\n \n #[rustfmt::skip] // for line breaks\n@@ -338,48 +340,44 @@ pub(super) fn check_for_substitution<'a>(\n     reader: &StringReader<'a>,\n     pos: BytePos,\n     ch: char,\n-    err: &mut Diagnostic,\n     count: usize,\n-) -> Option<token::TokenKind> {\n-    let &(_, u_name, ascii_str) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch)?;\n+) -> (Option<token::TokenKind>, Option<TokenSubstitution>) {\n+    let Some(&(_, u_name, ascii_str)) = UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) else {\n+        return (None, None);\n+    };\n \n     let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8() * count));\n \n     let Some((_, ascii_name, token)) = ASCII_ARRAY.iter().find(|&&(s, _, _)| s == ascii_str) else {\n         let msg = format!(\"substitution character not found for '{}'\", ch);\n         reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n-        return None;\n+        return (None, None);\n     };\n \n     // special help suggestion for \"directed\" double quotes\n-    if let Some(s) = peek_delimited(&reader.src[reader.src_index(pos)..], '\u201c', '\u201d') {\n-        let msg = format!(\n-            \"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n-             '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n-            ascii_str, ascii_name\n-        );\n-        err.span_suggestion(\n-            Span::with_root_ctxt(\n-                pos,\n-                pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n-            ),\n-            &msg,\n-            format!(\"\\\"{}\\\"\", s),\n-            Applicability::MaybeIncorrect,\n+    let sugg = if let Some(s) = peek_delimited(&reader.src[reader.src_index(pos)..], '\u201c', '\u201d') {\n+        let span = Span::with_root_ctxt(\n+            pos,\n+            pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n         );\n+        Some(TokenSubstitution::DirectedQuotes {\n+            span,\n+            suggestion: format!(\"\\\"{s}\\\"\"),\n+            ascii_str,\n+            ascii_name,\n+        })\n     } else {\n-        let msg = format!(\n-            \"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n-            ch, u_name, ascii_str, ascii_name\n-        );\n-        err.span_suggestion(\n+        let suggestion = ascii_str.to_string().repeat(count);\n+        Some(TokenSubstitution::Other {\n             span,\n-            &msg,\n-            ascii_str.to_string().repeat(count),\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-    token.clone()\n+            suggestion,\n+            ch: ch.to_string(),\n+            u_name,\n+            ascii_str,\n+            ascii_name,\n+        })\n+    };\n+    (token.clone(), sugg)\n }\n \n /// Extract string if found at current position with given delimiters"}, {"sha": "2fc8ce98af04d5f593d2aab779171e66a95a0620", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -5,6 +5,7 @@ use super::{\n     AttrWrapper, BlockMode, ClosureSpans, ForceCollect, Parser, PathStyle, Restrictions,\n     SemiColonMode, SeqSep, TokenExpectType, TokenType, TrailingToken,\n };\n+\n use crate::errors;\n use crate::maybe_recover_from_interpolated_ty_qpath;\n use core::mem;\n@@ -1017,7 +1018,7 @@ impl<'a> Parser<'a> {\n     fn error_unexpected_after_dot(&self) {\n         // FIXME Could factor this out into non_fatal_unexpected or something.\n         let actual = pprust::token_to_string(&self.token);\n-        self.struct_span_err(self.token.span, &format!(\"unexpected token: `{actual}`\")).emit();\n+        self.sess.emit_err(errors::UnexpectedTokenAfterDot { span: self.token.span, actual });\n     }\n \n     // We need an identifier or integer, but the next token is a float."}, {"sha": "fd46a1292a823d3fb367b6ba3b85f1a0e9f7cdb6", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -1,18 +1,8 @@\n-use crate::errors::{\n-    AmbiguousMissingKwForItemSub, AssociatedStaticItemNotAllowed, AsyncFnIn2015,\n-    BoundsNotAllowedOnTraitAliases, ConstGlobalCannotBeMutable, ConstLetMutuallyExclusive,\n-    DefaultNotFollowedByItem, DocCommentDoesNotDocumentAnything, EnumStructMutuallyExclusive,\n-    ExpectedTraitInTraitImplFoundType, ExternCrateNameWithDashes, ExternCrateNameWithDashesSugg,\n-    ExternItemCannotBeConst, HelpUseLatestEdition, MissingConstType, MissingForInTraitImpl,\n-    MissingKeywordForItemDefinition, MissingTraitInTraitImpl, SelfArgumentPointer,\n-    TraitAliasCannotBeAuto, TraitAliasCannotBeUnsafe, UnexpectedTokenAfterStructName,\n-    UseEmptyBlockNotSemi, VisibilityNotFollowedByItem,\n-};\n+use crate::errors;\n \n use super::diagnostics::{dummy_arg, ConsumeClosingDelim};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, FollowedByType, ForceCollect, Parser, PathStyle, TrailingToken};\n-use crate::errors::FnTypoWithImpl;\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -177,11 +167,11 @@ impl<'a> Parser<'a> {\n \n         // At this point, we have failed to parse an item.\n         if !matches!(vis.kind, VisibilityKind::Inherited) {\n-            self.sess.emit_err(VisibilityNotFollowedByItem { span: vis.span, vis });\n+            self.sess.emit_err(errors::VisibilityNotFollowedByItem { span: vis.span, vis });\n         }\n \n         if let Defaultness::Default(span) = def {\n-            self.sess.emit_err(DefaultNotFollowedByItem { span });\n+            self.sess.emit_err(errors::DefaultNotFollowedByItem { span });\n         }\n \n         if !attrs_allowed {\n@@ -403,7 +393,7 @@ impl<'a> Parser<'a> {\n \n         let err = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n             // possible public struct definition where `struct` was forgotten\n-            Some(MissingKeywordForItemDefinition::Struct { span: sp, ident })\n+            Some(errors::MissingKeywordForItemDefinition::Struct { span: sp, ident })\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // possible public function or tuple struct definition where `fn`/`struct` was\n             // forgotten\n@@ -412,34 +402,36 @@ impl<'a> Parser<'a> {\n \n             self.consume_block(Delimiter::Parenthesis, ConsumeClosingDelim::Yes);\n \n-            let err = if self.check(&token::RArrow)\n-                || self.check(&token::OpenDelim(Delimiter::Brace))\n-            {\n-                self.eat_to_tokens(&[&token::OpenDelim(Delimiter::Brace)]);\n-                self.bump(); // `{`\n-                self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n-                if is_method {\n-                    MissingKeywordForItemDefinition::Method { span: sp, ident }\n-                } else {\n-                    MissingKeywordForItemDefinition::Function { span: sp, ident }\n-                }\n-            } else if self.check(&token::Semi) {\n-                MissingKeywordForItemDefinition::Struct { span: sp, ident }\n-            } else {\n-                MissingKeywordForItemDefinition::Ambiguous {\n-                    span: sp,\n-                    subdiag: if found_generics {\n-                        None\n-                    } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n-                        Some(AmbiguousMissingKwForItemSub::SuggestMacro { span: full_sp, snippet })\n+            let err =\n+                if self.check(&token::RArrow) || self.check(&token::OpenDelim(Delimiter::Brace)) {\n+                    self.eat_to_tokens(&[&token::OpenDelim(Delimiter::Brace)]);\n+                    self.bump(); // `{`\n+                    self.consume_block(Delimiter::Brace, ConsumeClosingDelim::Yes);\n+                    if is_method {\n+                        errors::MissingKeywordForItemDefinition::Method { span: sp, ident }\n                     } else {\n-                        Some(AmbiguousMissingKwForItemSub::HelpMacro)\n-                    },\n-                }\n-            };\n+                        errors::MissingKeywordForItemDefinition::Function { span: sp, ident }\n+                    }\n+                } else if self.check(&token::Semi) {\n+                    errors::MissingKeywordForItemDefinition::Struct { span: sp, ident }\n+                } else {\n+                    errors::MissingKeywordForItemDefinition::Ambiguous {\n+                        span: sp,\n+                        subdiag: if found_generics {\n+                            None\n+                        } else if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n+                            Some(errors::AmbiguousMissingKwForItemSub::SuggestMacro {\n+                                span: full_sp,\n+                                snippet,\n+                            })\n+                        } else {\n+                            Some(errors::AmbiguousMissingKwForItemSub::HelpMacro)\n+                        },\n+                    }\n+                };\n             Some(err)\n         } else if found_generics {\n-            Some(MissingKeywordForItemDefinition::Ambiguous { span: sp, subdiag: None })\n+            Some(errors::MissingKeywordForItemDefinition::Ambiguous { span: sp, subdiag: None })\n         } else {\n             None\n         };\n@@ -567,8 +559,10 @@ impl<'a> Parser<'a> {\n         let ty_first = if self.token.is_keyword(kw::For) && self.look_ahead(1, |t| t != &token::Lt)\n         {\n             let span = self.prev_token.span.between(self.token.span);\n-            self.sess\n-                .emit_err(MissingTraitInTraitImpl { span, for_span: span.to(self.token.span) });\n+            self.sess.emit_err(errors::MissingTraitInTraitImpl {\n+                span,\n+                for_span: span.to(self.token.span),\n+            });\n \n             P(Ty {\n                 kind: TyKind::Path(None, err_path(span)),\n@@ -602,16 +596,17 @@ impl<'a> Parser<'a> {\n             Some(ty_second) => {\n                 // impl Trait for Type\n                 if !has_for {\n-                    self.sess.emit_err(MissingForInTraitImpl { span: missing_for_span });\n+                    self.sess.emit_err(errors::MissingForInTraitImpl { span: missing_for_span });\n                 }\n \n                 let ty_first = ty_first.into_inner();\n                 let path = match ty_first.kind {\n                     // This notably includes paths passed through `ty` macro fragments (#46438).\n                     TyKind::Path(None, path) => path,\n                     _ => {\n-                        self.sess\n-                            .emit_err(ExpectedTraitInTraitImplFoundType { span: ty_first.span });\n+                        self.sess.emit_err(errors::ExpectedTraitInTraitImplFoundType {\n+                            span: ty_first.span,\n+                        });\n                         err_path(ty_first.span)\n                     }\n                 };\n@@ -655,7 +650,7 @@ impl<'a> Parser<'a> {\n \n         // Recover `impl Ty;` instead of `impl Ty {}`\n         if self.token == TokenKind::Semi {\n-            self.sess.emit_err(UseEmptyBlockNotSemi { span: self.token.span });\n+            self.sess.emit_err(errors::UseEmptyBlockNotSemi { span: self.token.span });\n             self.bump();\n             return Ok(vec![]);\n         }\n@@ -812,7 +807,7 @@ impl<'a> Parser<'a> {\n             // It's a trait alias.\n             if had_colon {\n                 let span = span_at_colon.to(span_before_eq);\n-                self.sess.emit_err(BoundsNotAllowedOnTraitAliases { span });\n+                self.sess.emit_err(errors::BoundsNotAllowedOnTraitAliases { span });\n             }\n \n             let bounds = self.parse_generic_bounds(None)?;\n@@ -821,10 +816,10 @@ impl<'a> Parser<'a> {\n \n             let whole_span = lo.to(self.prev_token.span);\n             if is_auto == IsAuto::Yes {\n-                self.sess.emit_err(TraitAliasCannotBeAuto { span: whole_span });\n+                self.sess.emit_err(errors::TraitAliasCannotBeAuto { span: whole_span });\n             }\n             if let Unsafe::Yes(_) = unsafety {\n-                self.sess.emit_err(TraitAliasCannotBeUnsafe { span: whole_span });\n+                self.sess.emit_err(errors::TraitAliasCannotBeUnsafe { span: whole_span });\n             }\n \n             self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n@@ -870,7 +865,7 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Static(a, _, b) => {\n-                            self.sess.emit_err(AssociatedStaticItemNotAllowed { span });\n+                            self.sess.emit_err(errors::AssociatedStaticItemNotAllowed { span });\n                             AssocItemKind::Const(Defaultness::Final, a, b)\n                         }\n                         _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n@@ -1069,9 +1064,9 @@ impl<'a> Parser<'a> {\n             write!(fixed_name, \"_{}\", part.name).unwrap();\n         }\n \n-        self.sess.emit_err(ExternCrateNameWithDashes {\n+        self.sess.emit_err(errors::ExternCrateNameWithDashes {\n             span: fixed_name_sp,\n-            sugg: ExternCrateNameWithDashesSugg { dashes },\n+            sugg: errors::ExternCrateNameWithDashesSugg { dashes },\n         });\n \n         Ok(Ident::from_str_and_span(&fixed_name, fixed_name_sp))\n@@ -1122,7 +1117,7 @@ impl<'a> Parser<'a> {\n                     Ok(kind) => kind,\n                     Err(kind) => match kind {\n                         ItemKind::Const(_, a, b) => {\n-                            self.sess.emit_err(ExternItemCannotBeConst {\n+                            self.sess.emit_err(errors::ExternItemCannotBeConst {\n                                 ident_span: ident.span,\n                                 const_span: span.with_hi(ident.span.lo()),\n                             });\n@@ -1173,10 +1168,10 @@ impl<'a> Parser<'a> {\n     fn recover_const_mut(&mut self, const_span: Span) {\n         if self.eat_keyword(kw::Mut) {\n             let span = self.prev_token.span;\n-            self.sess.emit_err(ConstGlobalCannotBeMutable { ident_span: span, const_span });\n+            self.sess.emit_err(errors::ConstGlobalCannotBeMutable { ident_span: span, const_span });\n         } else if self.eat_keyword(kw::Let) {\n             let span = self.prev_token.span;\n-            self.sess.emit_err(ConstLetMutuallyExclusive { span: const_span.to(span) });\n+            self.sess.emit_err(errors::ConstLetMutuallyExclusive { span: const_span.to(span) });\n         }\n     }\n \n@@ -1262,7 +1257,8 @@ impl<'a> Parser<'a> {\n \n         let span = self.prev_token.span.shrink_to_hi();\n         let err: DiagnosticBuilder<'_, ErrorGuaranteed> =\n-            MissingConstType { span, colon, kind }.into_diagnostic(&self.sess.span_diagnostic);\n+            errors::MissingConstType { span, colon, kind }\n+                .into_diagnostic(&self.sess.span_diagnostic);\n         err.stash(span, StashKey::ItemNoType);\n \n         // The user intended that the type be inferred,\n@@ -1274,7 +1270,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         if self.token.is_keyword(kw::Struct) {\n             let span = self.prev_token.span.to(self.token.span);\n-            let err = EnumStructMutuallyExclusive { span };\n+            let err = errors::EnumStructMutuallyExclusive { span };\n             if self.look_ahead(1, |t| t.is_ident()) {\n                 self.bump();\n                 self.sess.emit_err(err);\n@@ -1289,7 +1285,7 @@ impl<'a> Parser<'a> {\n \n         // Possibly recover `enum Foo;` instead of `enum Foo {}`\n         let (variants, _) = if self.token == TokenKind::Semi {\n-            self.sess.emit_err(UseEmptyBlockNotSemi { span: self.token.span });\n+            self.sess.emit_err(errors::UseEmptyBlockNotSemi { span: self.token.span });\n             self.bump();\n             (vec![], false)\n         } else {\n@@ -1415,7 +1411,8 @@ impl<'a> Parser<'a> {\n             self.expect_semi()?;\n             body\n         } else {\n-            let err = UnexpectedTokenAfterStructName::new(self.token.span, self.token.clone());\n+            let err =\n+                errors::UnexpectedTokenAfterStructName::new(self.token.span, self.token.clone());\n             return Err(err.into_diagnostic(&self.sess.span_diagnostic));\n         };\n \n@@ -1593,7 +1590,7 @@ impl<'a> Parser<'a> {\n             token::CloseDelim(Delimiter::Brace) => {}\n             token::DocComment(..) => {\n                 let previous_span = self.prev_token.span;\n-                let mut err = DocCommentDoesNotDocumentAnything {\n+                let mut err = errors::DocCommentDoesNotDocumentAnything {\n                     span: self.token.span,\n                     missing_comma: None,\n                 };\n@@ -2103,7 +2100,7 @@ impl<'a> Parser<'a> {\n                 // If we see `for Ty ...` then user probably meant `impl` item.\n                 if self.token.is_keyword(kw::For) {\n                     old_err.cancel();\n-                    return Err(self.sess.create_err(FnTypoWithImpl { fn_span }));\n+                    return Err(self.sess.create_err(errors::FnTypoWithImpl { fn_span }));\n                 } else {\n                     return Err(old_err);\n                 }\n@@ -2248,7 +2245,10 @@ impl<'a> Parser<'a> {\n \n         if let Async::Yes { span, .. } = asyncness {\n             if span.is_rust_2015() {\n-                self.sess.emit_err(AsyncFnIn2015 { span, help: HelpUseLatestEdition::new() });\n+                self.sess.emit_err(errors::AsyncFnIn2015 {\n+                    span,\n+                    help: errors::HelpUseLatestEdition::new(),\n+                });\n             }\n         }\n \n@@ -2501,7 +2501,7 @@ impl<'a> Parser<'a> {\n         };\n         // Recover for the grammar `*self`, `*const self`, and `*mut self`.\n         let recover_self_ptr = |this: &mut Self| {\n-            self.sess.emit_err(SelfArgumentPointer { span: this.token.span });\n+            self.sess.emit_err(errors::SelfArgumentPointer { span: this.token.span });\n \n             Ok((SelfKind::Value(Mutability::Not), expect_self_ident(this), this.prev_token.span))\n         };"}, {"sha": "45f238ef4bf1f7202d5cfbe7bc3fcea992e7d139", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -937,6 +937,7 @@ def main():\n         )\n \n     exit_code = 0\n+    success_word = \"successfully\"\n     try:\n         bootstrap(args)\n     except (SystemExit, KeyboardInterrupt) as error:\n@@ -945,9 +946,10 @@ def main():\n         else:\n             exit_code = 1\n             print(error)\n+        success_word = \"unsuccessfully\"\n \n     if not help_triggered:\n-        print(\"Build completed successfully in\", format_build_time(time() - start_time))\n+        print(\"Build completed\", success_word, \"in\", format_build_time(time() - start_time))\n     sys.exit(exit_code)\n \n "}, {"sha": "5c863015adb278893d7ed2dbf7d6f3f1d4d9697f", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -2,7 +2,7 @@ use std::{\n     env,\n     ffi::{OsStr, OsString},\n     fs::{self, File},\n-    io::{BufRead, BufReader, ErrorKind},\n+    io::{self, BufRead, BufReader, ErrorKind},\n     path::{Path, PathBuf},\n     process::{Command, Stdio},\n };\n@@ -26,6 +26,14 @@ impl Config {\n         self.verbose > 0\n     }\n \n+    pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(&self, src: P, link: Q) -> io::Result<()> {\n+        #[cfg(unix)]\n+        use std::os::unix::fs::symlink as symlink_file;\n+        #[cfg(windows)]\n+        use std::os::windows::fs::symlink_file;\n+        if !self.dry_run() { symlink_file(src.as_ref(), link.as_ref()) } else { Ok(()) }\n+    }\n+\n     pub(crate) fn create(&self, path: &Path, s: &str) {\n         if self.dry_run() {\n             return;\n@@ -331,6 +339,12 @@ impl Config {\n         let bin_root = self.out.join(host.triple).join(\"rustfmt\");\n         let rustfmt_path = bin_root.join(\"bin\").join(exe(\"rustfmt\", host));\n         let rustfmt_stamp = bin_root.join(\".rustfmt-stamp\");\n+\n+        let legacy_rustfmt = self.initial_rustc.with_file_name(exe(\"rustfmt\", host));\n+        if !legacy_rustfmt.exists() {\n+            t!(self.symlink_file(&rustfmt_path, &legacy_rustfmt));\n+        }\n+\n         if rustfmt_path.exists() && !program_out_of_date(&rustfmt_stamp, &channel) {\n             return Some(rustfmt_path);\n         }"}, {"sha": "f753720b353066bcb05a8e9889a0d97497e70587", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -20,7 +20,6 @@ use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::env;\n use std::fs::{self, File};\n-use std::io;\n use std::io::ErrorKind;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -1407,7 +1406,7 @@ impl Build {\n                 src = t!(fs::canonicalize(src));\n             } else {\n                 let link = t!(fs::read_link(src));\n-                t!(self.symlink_file(link, dst));\n+                t!(self.config.symlink_file(link, dst));\n                 return;\n             }\n         }\n@@ -1525,14 +1524,6 @@ impl Build {\n         iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n     }\n \n-    fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(&self, src: P, link: Q) -> io::Result<()> {\n-        #[cfg(unix)]\n-        use std::os::unix::fs::symlink as symlink_file;\n-        #[cfg(windows)]\n-        use std::os::windows::fs::symlink_file;\n-        if !self.config.dry_run() { symlink_file(src.as_ref(), link.as_ref()) } else { Ok(()) }\n-    }\n-\n     /// Returns if config.ninja is enabled, and checks for ninja existence,\n     /// exiting with a nicer error message if not.\n     fn ninja(&self) -> bool {"}, {"sha": "07d339c067c860242ea0400a68b1b7575571895c", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -516,7 +516,7 @@ impl Step for Llvm {\n \n             let lib_llvm = out_dir.join(\"build\").join(\"lib\").join(lib_name);\n             if !lib_llvm.exists() {\n-                t!(builder.symlink_file(\"libLLVM.dylib\", &lib_llvm));\n+                t!(builder.build.config.symlink_file(\"libLLVM.dylib\", &lib_llvm));\n             }\n         }\n "}, {"sha": "f3d3b207fad6b2841f2b609cfc973331d8edb2cc", "filename": "tests/ui/parser/raw/too-many-hash.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.rs?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -0,0 +1,6 @@\n+// ignore-tidy-linelength\n+\n+fn main() {\n+    let s: &str = r################################################################################################################################################################################################################################################################\"very raw\"################################################################################################################################################################################################################################################################;\n+    //~^ ERROR too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found 256\n+}"}, {"sha": "29ec17842aacc683b7c600f7169adf6dcb3f10d6", "filename": "tests/ui/parser/raw/too-many-hash.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5919f62cf6681979cb5401d3907445f14d27ec8f/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5919f62cf6681979cb5401d3907445f14d27ec8f/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fraw%2Ftoo-many-hash.stderr?ref=5919f62cf6681979cb5401d3907445f14d27ec8f", "patch": "@@ -0,0 +1,8 @@\n+error: too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found 256\n+  --> $DIR/too-many-hash.rs:4:19\n+   |\n+LL | ... = r################################################################################################################################################################################################################################################################\"very raw\"##############################################################################################################################################################################################################################################################...\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}