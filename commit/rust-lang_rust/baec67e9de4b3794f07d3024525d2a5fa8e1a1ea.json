{"sha": "baec67e9de4b3794f07d3024525d2a5fa8e1a1ea", "node_id": "C_kwDOAAsO6NoAKGJhZWM2N2U5ZGU0YjM3OTRmMDdkMzAyNDUyNWQyYTVmYThlMWExZWE", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-09-28T05:09:23Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-09-28T05:23:17Z"}, "message": "Use a single if_chain", "tree": {"sha": "4c52f02c6265a9d1bc687c708e7e4fb926ca1d6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c52f02c6265a9d1bc687c708e7e4fb926ca1d6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea", "html_url": "https://github.com/rust-lang/rust/commit/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ffb2931553b4a2f0ccd9c6db51809cf9c13e7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ffb2931553b4a2f0ccd9c6db51809cf9c13e7c", "html_url": "https://github.com/rust-lang/rust/commit/b6ffb2931553b4a2f0ccd9c6db51809cf9c13e7c"}], "stats": {"total": 40, "additions": 9, "deletions": 31}, "files": [{"sha": "650bb167b73ca1d77a4cf967795f4fa5f0ace16b", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/baec67e9de4b3794f07d3024525d2a5fa8e1a1ea/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=baec67e9de4b3794f07d3024525d2a5fa8e1a1ea", "patch": "@@ -47,38 +47,15 @@ declare_lint_pass!(MatchResultOk => [MATCH_RESULT_OK]);\n \n impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr);\n-            if let ExprKind::MethodCall(_, ok_span, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n-            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::result_type);\n-            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n-\n-            then {\n-\n-                let mut applicability = Applicability::MachineApplicable;\n-                let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n-                let sugg = format!(\n-                    \"if let Ok({}) = {}\",\n-                    some_expr_string,\n-                    trimmed_ok.trim().trim_end_matches('.'),\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_RESULT_OK,\n-                    expr.span.with_hi(let_expr.span.hi()),\n-                    \"matching on `Some` with `ok()` is redundant\",\n-                    &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n-                    sugg,\n-                    applicability,\n-                );\n-            }\n-        }\n+        let (let_pat, let_expr, ifwhile) = if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(cx, expr) {\n+            (let_pat, let_expr, \"if\")\n+        } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+            (let_pat, let_expr, \"while\")\n+        } else {\n+            return\n+        };\n \n         if_chain! {\n-            if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr);\n             if let ExprKind::MethodCall(_, ok_span, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n             if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n@@ -91,7 +68,8 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n                 let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n                 let sugg = format!(\n-                    \"while let Ok({}) = {}\",\n+                    \"{} let Ok({}) = {}\",\n+                    ifwhile,\n                     some_expr_string,\n                     trimmed_ok.trim().trim_end_matches('.'),\n                 );"}]}