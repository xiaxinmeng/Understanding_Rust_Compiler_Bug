{"sha": "25e65239ad81af6123bcf9e4b5173dad2ced99c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZTY1MjM5YWQ4MWFmNjEyM2JjZjllNGI1MTczZGFkMmNlZDk5YzI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-22T07:45:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-23T17:11:36Z"}, "message": "Check impls methods against the type of their iface.", "tree": {"sha": "0ab4118d70109b3de721390ef6c3405e8c9dfa95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab4118d70109b3de721390ef6c3405e8c9dfa95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25e65239ad81af6123bcf9e4b5173dad2ced99c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25e65239ad81af6123bcf9e4b5173dad2ced99c2", "html_url": "https://github.com/rust-lang/rust/commit/25e65239ad81af6123bcf9e4b5173dad2ced99c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25e65239ad81af6123bcf9e4b5173dad2ced99c2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "057617c6654bfd5a677112cd26141d0b9c137145", "url": "https://api.github.com/repos/rust-lang/rust/commits/057617c6654bfd5a677112cd26141d0b9c137145", "html_url": "https://github.com/rust-lang/rust/commit/057617c6654bfd5a677112cd26141d0b9c137145"}], "stats": {"total": 131, "additions": 87, "deletions": 44}, "files": [{"sha": "d4dbbe264dcb6c107be2ecdb0d86bd3edb5190ad", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=25e65239ad81af6123bcf9e4b5173dad2ced99c2", "patch": "@@ -267,7 +267,7 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n             while peek(st) as char != '[' {\n                 name += str::unsafe_from_byte(next(st));\n             }\n-            methods += [{ident: name,\n+            methods += [{ident: name, tps: [],\n                          fty: {proto: proto with parse_ty_fn(st, sd)}}];\n         }\n         st.pos += 1u;"}, {"sha": "df78cbc3d85c86789c727e2aa39894869adcd47b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=25e65239ad81af6123bcf9e4b5173dad2ced99c2", "patch": "@@ -103,6 +103,7 @@ export substitute_type_params;\n export t;\n export new_ty_hash;\n export tag_variants;\n+export iface_methods, store_iface_methods;\n export tag_variant_with_id;\n export ty_param_substs_opt_and_ty;\n export ty_param_kinds_and_ty;\n@@ -191,7 +192,7 @@ type arg = {mode: mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n-type method = {ident: ast::ident, fty: fn_ty};\n+type method = {ident: ast::ident, tps: [ast::kind], fty: fn_ty};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -215,7 +216,8 @@ type ctxt =\n       needs_drop_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, ast::kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n-      tag_var_cache: hashmap<ast::def_id, @[variant_info]>};\n+      tag_var_cache: hashmap<ast::def_id, @[variant_info]>,\n+      iface_method_cache: hashmap<def_id, @[method]>};\n \n type ty_ctxt = ctxt;\n \n@@ -412,7 +414,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n           kind_cache: new_ty_hash(),\n           ast_ty_to_ty_cache:\n               map::mk_hashmap(ast_util::hash_ty, ast_util::eq_ty),\n-          tag_var_cache: new_def_hash()};\n+          tag_var_cache: new_def_hash(),\n+          iface_method_cache: new_def_hash()};\n     populate_type_store(cx);\n     ret cx;\n }\n@@ -752,7 +755,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n             let new_args = vec::map(m.fty.inputs, {|a|\n                 {mode: a.mode, ty: fold_ty(cx, fld, a.ty)}\n             });\n-            {ident: m.ident,\n+            {ident: m.ident, tps: m.tps,\n              fty: {inputs: new_args,\n                    output: fold_ty(cx, fld, m.fty.output)\n                    with m.fty}}\n@@ -1961,7 +1964,8 @@ mod unify {\n               ures_ok(tfn) {\n                 alt struct(cx.tcx, tfn) {\n                   ty_fn(f) {\n-                    result_meths += [{ident: e_meth.ident, fty: f}];\n+                    result_meths += [{ident: e_meth.ident,\n+                                      tps: a_meth.tps, fty: f}];\n                   }\n                 }\n               }\n@@ -2479,7 +2483,7 @@ fn same_type(cx: ctxt, a: t, b: t) -> bool {\n     }\n }\n fn same_method(cx: ctxt, a: method, b: method) -> bool {\n-    a.fty.proto == b.fty.proto && a.ident == b.ident &&\n+    a.tps == b.tps && a.fty.proto == b.fty.proto && a.ident == b.ident &&\n     vec::all2(a.fty.inputs, b.fty.inputs,\n               {|a, b| a.mode == b.mode && same_type(cx, a.ty, b.ty) }) &&\n     same_type(cx, a.fty.output, b.fty.output) &&\n@@ -2587,6 +2591,21 @@ fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n+fn store_iface_methods(cx: ctxt, id: ast::node_id, ms: @[method]) {\n+    cx.iface_method_cache.insert(ast_util::local_def(id), ms);\n+}\n+\n+fn iface_methods(cx: ctxt, id: ast::def_id) -> @[method] {\n+    alt cx.iface_method_cache.find(id) {\n+      some(ms) { ret ms; }\n+      _ {}\n+    }\n+    // Local interfaces are supposed to have been added explicitly.\n+    assert id.crate != ast::local_crate;\n+    let result = @[]; // FIXME[impl]\n+    cx.iface_method_cache.insert(id, result);\n+    result\n+}\n \n // Tag information\n type variant_info = @{args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n@@ -2600,20 +2619,16 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n         @csearch::get_tag_variants(cx, id)\n     } else {\n         alt cx.items.get(id.node) {\n-          ast_map::node_item(item) {\n-            alt item.node {\n-              ast::item_tag(variants, _) {\n-                @vec::map(variants, {|variant|\n-                    let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n-                    let arg_tys = if vec::len(variant.node.args) > 0u {\n-                        vec::map(ty_fn_args(cx, ctor_ty), {|a| a.ty})\n-                    } else { [] };\n-                    @{args: arg_tys,\n-                      ctor_ty: ctor_ty,\n-                      id: ast_util::local_def(variant.node.id)}\n-                })\n-              }\n-            }\n+          ast_map::node_item(@{node: ast::item_tag(variants, _), _}) {\n+            @vec::map(variants, {|variant|\n+                let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n+                let arg_tys = if vec::len(variant.node.args) > 0u {\n+                    vec::map(ty_fn_args(cx, ctor_ty), {|a| a.ty})\n+                } else { [] };\n+                @{args: arg_tys,\n+                  ctor_ty: ctor_ty,\n+                  id: ast_util::local_def(variant.node.id)}\n+            })\n           }\n         }\n     };"}, {"sha": "3a137bab2ce62ff36e49e4a3a4022bd8af6495e9", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=25e65239ad81af6123bcf9e4b5173dad2ced99c2", "patch": "@@ -422,12 +422,15 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_iface(tps, methods) {\n+      ast::item_iface(tps, ms) {\n         let t = ty::mk_named(tcx, ty::mk_iface(tcx, local_def(it.id),\n                                                mk_ty_params(tcx, tps)),\n                              @it.ident);\n         let tpt = {kinds: ty_param_kinds(tps), ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n+        ty::store_iface_methods(tcx, it.id, @vec::map(ms, {|m|\n+            ty_of_ty_method(tcx, m_collect, m)\n+        }));\n         ret tpt;\n       }\n       ast::item_impl(_, _, _, _) | ast::item_mod(_) |\n@@ -490,11 +493,13 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     ret tpt;\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    {ident: m.ident, fty: ty_of_fn_decl(tcx, mode, m.decl)}\n+    {ident: m.ident, tps: vec::map(m.tps, {|tp| tp.kind}),\n+     fty: ty_of_fn_decl(tcx, mode, m.decl)}\n }\n fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     -> ty::method {\n-    {ident: m.ident, fty: ty_of_fn_decl(tcx, mode, m.decl)}\n+    {ident: m.ident, tps: vec::map(m.tps, {|tp| tp.kind}),\n+     fty: ty_of_fn_decl(tcx, mode, m.decl)}\n }\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n@@ -1493,7 +1498,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // record projection work on type inferred arguments.\n     unify(fcx, expr.span, expected, fty);\n \n-    check_fn1(fcx.ccx, decl, body, expr.id, some(fcx));\n+    check_fn(fcx.ccx, decl, body, expr.id, some(fcx));\n }\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n@@ -2565,14 +2570,6 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n }\n \n fn check_fn(ccx: @crate_ctxt,\n-            decl: ast::fn_decl,\n-            body: ast::blk,\n-            id: ast::node_id,\n-            old_fcx: option::t<@fn_ctxt>) {\n-    check_fn1(ccx, decl, body, id, old_fcx);\n-}\n-\n-fn check_fn1(ccx: @crate_ctxt,\n              decl: ast::fn_decl,\n              body: ast::blk,\n              id: ast::node_id,\n@@ -2645,10 +2642,41 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         // Now remove the info from the stack.\n         vec::pop(ccx.self_infos);\n       }\n-      ast::item_impl(_, _, ty, ms) {\n+      ast::item_impl(_, ifce, ty, ms) {\n         ccx.self_infos += [self_impl(ast_ty_to_ty(ccx.tcx, m_check, ty))];\n-        for m in ms { check_method(ccx, m); }\n+        let my_methods = vec::map(ms, {|m|\n+            check_method(ccx, m);\n+            ty_of_method(ccx.tcx, m_check, m)\n+        });\n         vec::pop(ccx.self_infos);\n+        alt ifce {\n+          some(ty) {\n+            alt ty::struct(ccx.tcx, ast_ty_to_ty(ccx.tcx, m_check, ty)) {\n+              ty::ty_iface(did, tys) {\n+                for if_m in *ty::iface_methods(ccx.tcx, did) {\n+                    alt vec::find(my_methods, {|m| if_m.ident == m.ident}) {\n+                      some(m) {\n+                        if !ty::same_method(ccx.tcx, m, if_m) {\n+                            ccx.tcx.sess.span_err(\n+                                ty.span, \"method \" + if_m.ident +\n+                                \" has the wrong type\");\n+                        }\n+                      }\n+                      none. {\n+                        ccx.tcx.sess.span_err(ty.span, \"missing method \" +\n+                                              if_m.ident);\n+                      }\n+                    }\n+                }\n+              }\n+              _ {\n+                ccx.tcx.sess.span_err(ty.span, \"can only implement interface \\\n+                                                types\");\n+              }\n+            }\n+          }\n+          _ {}\n+        }\n       }\n       _ {/* nothing to do */ }\n     }"}, {"sha": "b1159affc10241ffc0b634b5211d3329a7b4788a", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=25e65239ad81af6123bcf9e4b5173dad2ced99c2", "patch": "@@ -309,7 +309,7 @@ type ty_field_ = {ident: ident, mt: mt};\n \n type ty_field = spanned<ty_field_>;\n \n-type ty_method = {ident: ident, decl: fn_decl, span: span};\n+type ty_method = {ident: ident, decl: fn_decl, tps: [ty_param], span: span};\n \n tag int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n "}, {"sha": "978b976eb03acedc660c1efbb528971398aeeb11", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e65239ad81af6123bcf9e4b5173dad2ced99c2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=25e65239ad81af6123bcf9e4b5173dad2ced99c2", "patch": "@@ -285,21 +285,21 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n                     constraints: constrs});\n }\n \n-fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n-    fn parse_method_sig(p: parser) -> ast::ty_method {\n+fn parse_ty_methods(p: parser, allow_tps: bool) -> [ast::ty_method] {\n+    parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(), {|p|\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_method_proto(p);\n         let ident = parse_value_ident(p);\n+        let tps = allow_tps ? parse_ty_params(p) : [];\n         let f = parse_ty_fn(proto, p), fhi = p.get_last_hi_pos();\n         expect(p, token::SEMI);\n         alt f {\n           ast::ty_fn(d) {\n-            {ident: ident, decl: d, span: ast_util::mk_sp(flo, fhi)}\n+            {ident: ident, decl: d, tps: tps,\n+             span: ast_util::mk_sp(flo, fhi)}\n           }\n         }\n-    }\n-    parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(),\n-              parse_method_sig, p).node\n+    }, p).node\n }\n \n fn parse_mt(p: parser) -> ast::mt {\n@@ -517,7 +517,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"sendfn\") {\n         t = parse_ty_fn(ast::proto_send, p);\n     } else if eat_word(p, \"obj\") {\n-        t = ast::ty_obj(parse_ty_methods(p));\n+        t = ast::ty_obj(parse_ty_methods(p, false));\n     } else if p.peek() == token::MOD_SEP || is_ident(p.peek()) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n@@ -1839,7 +1839,7 @@ fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n \n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos(), ident = parse_ident(p),\n-        tps = parse_ty_params(p), meths = parse_ty_methods(p);\n+        tps = parse_ty_params(p), meths = parse_ty_methods(p, true);\n     ret mk_item(p, lo, p.get_last_hi_pos(), ident,\n                 ast::item_iface(tps, meths), attrs);\n }"}]}