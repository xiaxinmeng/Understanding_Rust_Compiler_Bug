{"sha": "3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNGNmZGVlZTIwZWI1NGQ0MzYxMmZlZDQ2MTcyOWZmYTZmNmQyZWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T02:00:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T02:00:34Z"}, "message": "Merge remote-tracking branch 'mozilla/incoming'\n\nConflicts:\n\tsrc/rustc/middle/tstate/auxiliary.rs", "tree": {"sha": "0b41c070f1ce581842585fa307baec946af0e244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b41c070f1ce581842585fa307baec946af0e244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "html_url": "https://github.com/rust-lang/rust/commit/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1910a66db95468608c9cc02a5012e3db7f4e09", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1910a66db95468608c9cc02a5012e3db7f4e09", "html_url": "https://github.com/rust-lang/rust/commit/9c1910a66db95468608c9cc02a5012e3db7f4e09"}, {"sha": "d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d542e67827e0ad1a3df5fd248d9c09997b5dcbba", "html_url": "https://github.com/rust-lang/rust/commit/d542e67827e0ad1a3df5fd248d9c09997b5dcbba"}], "stats": {"total": 359, "additions": 170, "deletions": 189}, "files": [{"sha": "df9cb78ef8f17c5998d95f4cadffb6c4ace2b182", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -421,9 +421,9 @@ else\n TSREQS :=\t\t\t\t\t\t\t\t\t\t\t\\\n \t$(foreach target,$(CFG_TARGET_TRIPLES),\t\t\t\\\n \t\t$(SREQ3_T_$(target)_H_$(CFG_HOST_TRIPLE)))\n-FUZZ := $(HBIN3_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n-CARGO := $(HBIN3_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n-RUSTDOC := $(HBIN3_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n+FUZZ := $(HBIN2_H_$(CFG_HOST_TRIPLE))/fuzzer$(X)\n+CARGO := $(HBIN2_H_$(CFG_HOST_TRIPLE))/cargo$(X)\n+RUSTDOC := $(HBIN2_H_$(CFG_HOST_TRIPLE))/rustdoc$(X)\n \n all: rustc $(GENERATED) docs $(FUZZ) $(CARGO) $(RUSTDOC)\n "}, {"sha": "aea97cf1649f539042a10d9a72c622e15a3ce158", "filename": "src/libcore/cmp.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -0,0 +1,10 @@\n+#[doc=\"Interfaces used for comparison.\"]\n+\n+iface ord {\n+    fn lt(&&other: self) -> bool;\n+}\n+\n+iface eq {\n+    fn eq(&&other: self) -> bool;\n+}\n+"}, {"sha": "efcd424024a1c5db946cb3eb9af9bc9554c6d9d3", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -44,6 +44,7 @@ export extfmt;\n export tuple;\n export to_str;\n export dvec, dvec_iter;\n+export cmp;\n \n // NDM seems to be necessary for resolve to work\n export option_iter;\n@@ -152,6 +153,7 @@ mod tuple;\n \n // Ubiquitous-utility-type modules\n \n+mod cmp;\n mod either;\n mod iter;\n mod logging;"}, {"sha": "4011ac1a18a7d23e4511fda14bcd828664f05e0f", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,4 +1,5 @@\n import T = inst::T;\n+import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -10,6 +11,7 @@ export range;\n export compl;\n export abs;\n export parse_buf, from_str, to_str, to_str_bytes, str;\n+export ord, eq;\n \n const min_value: T = -1 as T << (inst::bits - 1 as T);\n const max_value: T = min_value - 1 as T;\n@@ -108,6 +110,18 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn([u8]/&) -> U) -> U {\n #[doc = \"Convert to a string\"]\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n+impl ord of ord for T {\n+    fn lt(&&other: T) -> bool {\n+        ret self < other;\n+    }\n+}\n+\n+impl eq of eq for T {\n+    fn eq(&&other: T) -> bool {\n+        ret self == other;\n+    }\n+}\n+\n \n // FIXME: Has alignment issues on windows and 32-bit linux\n #[test]"}, {"sha": "7126fb3d007d335f57ae7b124052eec47c6cbb10", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,4 +1,5 @@\n import T = inst::T;\n+import cmp::{eq, ord};\n \n export min_value, max_value;\n export min, max;\n@@ -10,6 +11,7 @@ export range;\n export compl;\n export to_str, to_str_bytes;\n export from_str, from_str_radix, str, parse_buf;\n+export ord, eq;\n \n const min_value: T = 0 as T;\n const max_value: T = 0 as T - 1 as T;\n@@ -49,6 +51,18 @@ pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n \n+impl ord of ord for T {\n+    fn lt(&&other: T) -> bool {\n+        ret self < other;\n+    }\n+}\n+\n+impl eq of eq for T {\n+    fn eq(&&other: T) -> bool {\n+        ret self == other;\n+    }\n+}\n+\n #[doc = \"\n Parse a buffer of bytes\n "}, {"sha": "76c71d7ed2aa24d3b144b988dc637c4928332b65", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,5 +1,6 @@\n #[doc = \"Sorting methods\"];\n import vec::len;\n+import int::{eq, ord};\n \n export le;\n export merge_sort;\n@@ -141,7 +142,6 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-// FIXME: This should take lt and eq types (#2348)\n #[doc = \"\n Fancy quicksort. Sorts a mut vector in place.\n \n@@ -152,22 +152,17 @@ According to these slides this is the algorithm of choice for\n \n This is an unstable sort.\n \"]\n-fn quick_sort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n-                       arr: [mut T]) {\n+fn quick_sort3<T: copy ord eq>(arr: [mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n-    qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n+    qsort3::<T>({ |x, y| x.lt(y) }, { |x, y| x.eq(y) }, arr, 0,\n                 (len::<T>(arr) as int) - 1);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n     fn check_sort(v1: [mut int], v2: [mut int]) {\n         let len = vec::len::<int>(v1);\n-        fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n-        fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n-        let f1 = lt;\n-        let f2 = equal;\n-        quick_sort3::<int>(f1, f2, v1);\n+        quick_sort3::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);"}, {"sha": "f58333c5599be338335a687e592651775bc39a4a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -86,11 +86,14 @@ impl codemap_handler of handler for handler_t {\n     }\n     fn has_errors() -> bool { self.err_count > 0u }\n     fn abort_if_errors() {\n-        if self.err_count > 0u {\n-            let s = #fmt[\"aborting due to %u previous errors\",\n-                         self.err_count];\n-            self.fatal(s);\n+        let s;\n+        alt self.err_count {\n+          0u { ret; }\n+          1u { s = \"aborting due to previous error\"; }\n+          _  { s = #fmt[\"aborting due to %u previous errors\",\n+                        self.err_count]; }\n         }\n+        self.fatal(s);\n     }\n     fn warn(msg: str) {\n         self.emit(none, msg, warning);"}, {"sha": "e769455376a5788f1617fb4e9ec5a58d0a57e721", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -194,7 +194,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n          bind middle::check_loop::check_crate(ty_cx, crate));\n     time(time_passes, \"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n-    let (last_use_map, spill_map) =\n+    let last_use_map =\n         time(time_passes, \"liveness checking\",\n              bind middle::liveness::check_crate(ty_cx, method_map, crate));\n     time(time_passes, \"typestate checking\",\n@@ -216,7 +216,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let maps = {mutbl_map: mutbl_map, root_map: root_map,\n                 copy_map: copy_map, last_use_map: last_use_map,\n                 impl_map: impl_map, method_map: method_map,\n-                vtable_map: vtable_map, spill_map: spill_map};\n+                vtable_map: vtable_map};\n \n     let (llmod, link_meta) =\n         time(time_passes, \"translation\","}, {"sha": "5e88df1de5ecfd2c043d9233b82693bafe33af94", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -15,7 +15,8 @@ import std::map::hashmap;\n import getopts::{opt_present};\n import rustc::driver::driver::*;\n import syntax::codemap;\n-import rustc::driver::{diagnostic, session};\n+import syntax::diagnostic;\n+import rustc::driver::session;\n import rustc::middle::lint;\n import io::reader_util;\n "}, {"sha": "4df45033a77c3d953756a2693c45ec09eeeb54d9", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -7,14 +7,14 @@ import syntax::{ast, ast_util};\n import syntax::attr;\n import middle::ty;\n import syntax::ast_map;\n-import common::*;\n import tydecode::{parse_ty_data, parse_def_id, parse_bounds_data,\n         parse_ident};\n import syntax::print::pprust;\n import cmd=cstore::crate_metadata;\n import util::ppaux::ty_to_str;\n import ebml::deserializer;\n import syntax::diagnostic::span_handler;\n+import common::*;\n \n export class_dtor;\n export get_class_fields;"}, {"sha": "6ebf0ed9ec65fae068ce3e45a06b4d664f078a5f", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -57,7 +57,6 @@ type maps = {\n     impl_map: middle::resolve::impl_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n-    spill_map: middle::liveness::spill_map\n };\n \n type decode_ctxt = @{\n@@ -839,12 +838,6 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    option::iter(maps.spill_map.find(id)) {|_m|\n-        ebml_w.tag(c::tag_table_spill) {||\n-            ebml_w.id(id);\n-        }\n-    }\n-\n     option::iter(maps.last_use_map.find(id)) {|m|\n         ebml_w.tag(c::tag_table_last_use) {||\n             ebml_w.id(id);\n@@ -953,8 +946,6 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.maps.mutbl_map.insert(id, ());\n         } else if tag == (c::tag_table_copy as uint) {\n             dcx.maps.copy_map.insert(id, ());\n-        } else if tag == (c::tag_table_spill as uint) {\n-            dcx.maps.spill_map.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = ebml::ebml_deserializer(val_doc);"}, {"sha": "0f1edb0c4158ac5442f1ad26d254ddbe64006dfd", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 52, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -57,7 +57,6 @@ import capture::{cap_move, cap_drop, cap_copy, cap_ref};\n \n export check_crate;\n export last_use_map;\n-export spill_map;\n \n // Maps from an expr id to a list of variable ids for which this expr\n // is the last use.  Typically, the expr is a path and the node id is\n@@ -66,13 +65,6 @@ export spill_map;\n // list of closed over variables that can be moved into the closure.\n type last_use_map = hashmap<node_id, @dvec<node_id>>;\n \n-// A set of variable ids which must be spilled (stored on the stack).\n-// We add in any variables or arguments where:\n-// (1) the variables are moved;\n-// (2) the address of the variable/argument is taken;\n-// or (3) we find a last use (as they may be moved).\n-type spill_map = hashmap<node_id, ()>;\n-\n enum variable = uint;\n enum live_node = uint;\n \n@@ -85,7 +77,7 @@ enum live_node_kind {\n \n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               crate: @crate) -> (last_use_map, spill_map) {\n+               crate: @crate) -> last_use_map {\n     let visitor = visit::mk_vt(@{\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n@@ -94,12 +86,11 @@ fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = int_hash();\n-    let spill_map = int_hash();\n     let initial_maps = @ir_maps(tcx, method_map,\n-                                last_use_map, spill_map);\n+                                last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n-    ret (last_use_map, spill_map);\n+    ret last_use_map;\n }\n \n impl of to_str::to_str for live_node {\n@@ -162,7 +153,6 @@ class ir_maps {\n     let tcx: ty::ctxt;\n     let method_map: typeck::method_map;\n     let last_use_map: last_use_map;\n-    let spill_map: spill_map;\n \n     let mut num_live_nodes: uint;\n     let mut num_vars: uint;\n@@ -174,11 +164,10 @@ class ir_maps {\n     let mut lnks: [live_node_kind];\n \n     new(tcx: ty::ctxt, method_map: typeck::method_map,\n-        last_use_map: last_use_map, spill_map: spill_map) {\n+        last_use_map: last_use_map) {\n         self.tcx = tcx;\n         self.method_map = method_map;\n         self.last_use_map = last_use_map;\n-        self.spill_map = spill_map;\n \n         self.num_live_nodes = 0u;\n         self.num_vars = 0u;\n@@ -264,17 +253,6 @@ class ir_maps {\n         self.lnks[*ln]\n     }\n \n-    fn add_spill(var: variable) {\n-        let vk = self.var_kinds[*var];\n-        alt vk {\n-          vk_local(id, _) | vk_arg(id, _, by_val) {\n-            #debug[\"adding spill for %?\", vk];\n-            self.spill_map.insert(id, ());\n-          }\n-          vk_arg(*) | vk_field(_) | vk_self | vk_implicit_ret {}\n-        }\n-    }\n-\n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n         #debug[\"Node %d is a last use of variable %?\", expr_id, vk];\n@@ -308,7 +286,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n-                           self.last_use_map, self.spill_map);\n+                           self.last_use_map);\n \n     #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n \n@@ -1407,11 +1385,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         vt.visit_expr(f, self, vt);\n         vec::iter2(args, targs) { |arg_expr, arg_ty|\n             alt ty::resolved_mode(self.tcx, arg_ty.mode) {\n-              by_val | by_copy {\n-                vt.visit_expr(arg_expr, self, vt);\n-              }\n-              by_ref | by_mutbl_ref {\n-                self.spill_expr(arg_expr);\n+              by_val | by_copy | by_ref | by_mutbl_ref{\n                 vt.visit_expr(arg_expr, self, vt);\n               }\n               by_move {\n@@ -1421,10 +1395,6 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n         }\n       }\n \n-      expr_addr_of(_, arg_expr) {\n-        self.spill_expr(arg_expr);\n-      }\n-\n       // no correctness conditions related to liveness\n       expr_if_check(*) | expr_if(*) | expr_alt(*) |\n       expr_while(*) | expr_loop(*) |\n@@ -1434,7 +1404,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_assert(*) | expr_check(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_cont | expr_lit(_) |\n-      expr_block(*) | expr_swap(*) | expr_mac(*) {\n+      expr_block(*) | expr_swap(*) | expr_mac(*) | expr_addr_of(*) {\n         visit::visit_expr(expr, self, vt);\n       }\n     }\n@@ -1501,10 +1471,7 @@ impl check_methods for @liveness {\n                ln.to_str(), var.to_str()];\n \n         alt (*self).live_on_exit(ln, var) {\n-          none {\n-            // update spill map to include this variable, as it is moved:\n-            (*self.ir).add_spill(var);\n-          }\n+          none { }\n           some(lnk) {\n             self.report_illegal_move(span, lnk, var);\n           }\n@@ -1516,20 +1483,10 @@ impl check_methods for @liveness {\n           some(_) {}\n           none {\n             (*self.ir).add_last_use(expr.id, var);\n-\n-            // update spill map to include this variable, as it may be moved:\n-            (*self.ir).add_spill(var);\n           }\n        }\n     }\n \n-    fn spill_expr(expr: @expr) {\n-        alt (*self).variable_from_path(expr) {\n-          some(var) {(*self.ir).add_spill(var)}\n-          none {}\n-        }\n-    }\n-\n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n         #debug[\"check_move_from_expr(node %d: %s)\",\n                expr.id, expr_to_str(expr)];\n@@ -1775,4 +1732,4 @@ impl check_methods for @liveness {\n             }\n         }\n     }\n- }\n\\ No newline at end of file\n+ }"}, {"sha": "ff297c5dcd484def007a47e624dbda7a6e86f812", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 78, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -62,6 +62,12 @@ enum dest {\n     ignore,\n }\n \n+// Heap selectors. Indicate which heap something should go on.\n+enum heap {\n+    heap_shared,\n+    heap_exchange,\n+}\n+\n fn dest_str(ccx: @crate_ctxt, d: dest) -> str {\n     alt d {\n       by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n@@ -341,75 +347,61 @@ fn opaque_box_body(bcx: block,\n     PointerCast(bcx, bodyptr, T_ptr(type_of(ccx, body_t)))\n }\n \n-// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n+// malloc_raw: expects an unboxed type and returns a pointer to\n // enough space for a box of that type.  This includes a rust_opaque_box\n // header.\n-fn malloc_boxed_raw(bcx: block, t: ty::t,\n-                    &static_ti: option<@tydesc_info>) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed_raw\");\n+fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_box(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    let (mk_fn, upcall) = alt heap {\n+      heap_shared { (ty::mk_imm_box, ccx.upcalls.malloc) }\n+      heap_exchange {\n+        (ty::mk_imm_uniq, ccx.upcalls.exchange_malloc )\n+      }\n+    };\n+\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = mk_fn(bcx.tcx(), t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n+    let mut static_ti = none;\n     let lltydesc = get_tydesc(ccx, t, static_ti);\n     lazily_emit_all_tydesc_glue(ccx, copy static_ti);\n \n     // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.malloc, [lltydesc]);\n+    let rval = Call(bcx, upcall, [lltydesc]);\n     ret PointerCast(bcx, rval, llty);\n }\n \n-// trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n-// initializes the reference count to 1, and pulls out the body and rc\n-fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"trans_malloc_boxed\");\n-    let mut ti = none;\n-    let box = malloc_boxed_raw(bcx, t, ti);\n-    let box_no_addrspace = non_gc_box_cast(\n-        bcx, box, ty::mk_imm_box(bcx.tcx(), t));\n-    let body = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n+// malloc_general: usefully wraps malloc_raw; allocates a box,\n+// and pulls out the body\n+fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n+    {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_general\");\n+    let mk_ty = alt heap { heap_shared { ty::mk_imm_box }\n+                           heap_exchange { ty::mk_imm_uniq } };\n+    let box = malloc_raw(bcx, t, heap);\n+    let non_gc_box = non_gc_box_cast(bcx, box, mk_ty(bcx.tcx(), t));\n+    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n \n-fn malloc_unique_raw(bcx: block, t: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n-    let ccx = bcx.ccx();\n-\n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n-\n-    // Get the tydesc for the body:\n-    let mut static_ti = none;\n-    let lltydesc = get_tydesc(ccx, t, static_ti);\n-    lazily_emit_all_tydesc_glue(ccx, static_ti);\n-\n-    // Allocate space:\n-    let rval = Call(bcx, ccx.upcalls.exchange_malloc, [lltydesc]);\n-    ret PointerCast(bcx, rval, llty);\n+fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    malloc_general(bcx, t, heap_shared)\n }\n-\n fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n-    let box = malloc_unique_raw(bcx, t);\n-    let non_gc_box = non_gc_box_cast(bcx, box, ty::mk_imm_uniq(bcx.tcx(), t));\n-    let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n-    ret {box: box, body: body};\n+    malloc_general(bcx, t, heap_exchange)\n }\n \n fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn_raw\");\n     let ccx = bcx.ccx();\n \n-    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n-    // wants.\n-    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n-    let llty = type_of(ccx, box_ptr);\n+    // Grab the TypeRef type of box_ptr_ty.\n+    let box_ptr_ty = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr_ty);\n \n     // Get the tydesc for the body:\n     let mut static_ti = none;\n@@ -423,7 +415,7 @@ fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n \n fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n                     ) -> {box: ValueRef, body: ValueRef} {\n-    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_dyn\");\n     let box = malloc_unique_dyn_raw(bcx, t, size);\n     let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n@@ -3749,6 +3741,8 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == owned && last_use_map.contains_key(e.id));\n+    #debug[\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n+           lv.kind as int];\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4039,29 +4033,10 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n     let ty = node_id_type(bcx, local.node.id);\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n-      some(_) { bcx.tcx().sess.span_bug(local.span,\n+      _ { bcx.tcx().sess.span_bug(local.span,\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init must be local_mem!\");\n-      }\n-      // This is a local that is kept immediate\n-      none {\n-        let initexpr = alt local.node.init {\n-                some({expr, _}) { expr }\n-                none { bcx.tcx().sess.span_bug(local.span,\n-                        \"init_local: late-initialized var appears to \\\n-                 be an immediate -- possibly init_local was called \\\n-                 without calling alloc_local\"); }\n-            };\n-        let mut {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n-        if kind != temporary {\n-            if kind == owned { val = Load(bcx, val); }\n-            let rs = take_ty_immediate(bcx, val, ty);\n-            bcx = rs.bcx; val = rs.val;\n-            add_clean_temp(bcx, val, ty);\n         }\n-        bcx.fcx.lllocals.insert(local.node.pat.id, local_imm(val));\n-        ret bcx;\n-      }\n     };\n \n     let mut bcx = bcx;\n@@ -4341,17 +4316,6 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n       ast::pat_ident(pth, none) { some(path_to_ident(pth)) }\n       _ { none }\n     };\n-    // Do not allocate space for locals that can be kept immediate.\n-    let ccx = cx.ccx();\n-    if option::is_some(simple_name) &&\n-       !ccx.maps.mutbl_map.contains_key(local.node.pat.id) &&\n-       !ccx.maps.spill_map.contains_key(local.node.pat.id) &&\n-       ty::type_is_immediate(t) {\n-        alt local.node.init {\n-          some({op: ast::init_assign, _}) { ret cx; }\n-          _ {}\n-        }\n-    }\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         option::iter(simple_name) {|name|"}, {"sha": "88cd126b1e4d375669adf0946ff9176ac3149791", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -175,11 +175,12 @@ fn allocate_cbox(bcx: block,\n     let mut temp_cleanups = [];\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n-        let box = malloc_boxed_raw(bcx, cdata_ty, ti);\n+        get_tydesc(ccx, cdata_ty, ti);\n+        let box = malloc_raw(bcx, cdata_ty, heap_shared);\n         (bcx, box)\n       }\n       ty::ck_uniq {\n-        let box = malloc_unique_raw(bcx, cdata_ty);\n+        let box = malloc_raw(bcx, cdata_ty, heap_exchange);\n         (bcx, box)\n       }\n       ty::ck_block {"}, {"sha": "6d6848336d49ca5a4fcfec154c02299a6c3c865a", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -13,10 +13,9 @@ import tstate::ann::{pre_and_post, pre_and_post_state, empty_ann, prestate,\n                      set_postcondition, ts_ann,\n                      clear_in_postcond,\n                      clear_in_poststate_};\n-import tritv::*;\n-import bitvectors::promises_;\n import driver::session::session;\n import dvec::{dvec, extensions};\n+import tritv::{dont_care, tfalse, tritv_get, ttrue};\n \n import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n \n@@ -817,7 +816,7 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n         // dest def_id\n         let insts = find_instances(fcx, subst, val);\n         for insts.each {|p|\n-            if promises_(p.from, src_post) {\n+            if bitvectors::promises_(p.from, src_post) {\n                 set_in_poststate_(p.to, target_post);\n             }\n         }"}, {"sha": "a426ded68f85e181d1541a00f8633212a404247f", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -4,19 +4,19 @@ import std::map::hashmap;\n import driver::session;\n import session::session;\n import syntax::{ast, ast_map};\n-import syntax::ast::*;\n import syntax::ast_util;\n import syntax::ast_util::{is_local, local_def, split_class_items,\n                           new_def_hash};\n import syntax::codemap::span;\n import metadata::csearch;\n-import util::common::*;\n import util::ppaux::region_to_str;\n import util::ppaux::vstore_to_str;\n import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n-import syntax::print::pprust::*;\n import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n                       ignore};\n+import syntax::ast::*;\n+import syntax::print::pprust::*;\n+\n export ty_vid, region_vid, vid;\n export br_hashmap;\n export is_instantiable;\n@@ -1678,11 +1678,8 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n           ty_class(did, substs) {\n             vec::push(*seen, did);\n-            let r = vec::any(lookup_class_fields(cx, did)) {|f|\n-                let fty = ty::lookup_item_type(cx, f.id);\n-                let sty = subst(cx, substs, fty.ty);\n-                type_requires(cx, seen, r_ty, sty)\n-            };\n+            let r = vec::any(class_items_as_fields(cx, did, substs)) {|f|\n+                      type_requires(cx, seen, r_ty, f.mt.ty)};\n             vec::pop(*seen);\n             r\n           }"}, {"sha": "476ef9d3ba55143dc723fa73330183c37f5db3c8", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -45,7 +45,8 @@ an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \"];\n \n import check::fn_ctxt;\n-import rscope::*;\n+import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n+import rscope::{in_binding_rscope, region_scope, type_rscope};\n \n iface ast_conv {\n     fn tcx() -> ty::ctxt;"}, {"sha": "b3f7c5a938856ad2e6ef9fb8048929c7ffb8e456", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -71,7 +71,8 @@ import collect::{methods}; // ccx.to_ty()\n import method::{methods};  // methods for method::lookup\n import middle::ty::tys_in_fn_ty;\n import regionmanip::{replace_bound_regions_in_fn_ty, region_of};\n-import rscope::*;\n+import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n+import rscope::{in_binding_rscope, region_scope, type_rscope};\n \n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n@@ -386,6 +387,12 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n           };\n           // typecheck the members\n           for members.each {|m| check_class_member(class_ccx, class_t, m); }\n+          // Check that there's at least one field\n+          let (fields,_) = split_class_items(members);\n+          if fields.len() < 1u {\n+              ccx.tcx.sess.span_err(it.span, \"A class must have at least one \\\n+                field\");\n+          }\n           // Check that the class is instantiable\n           check_instantiable(ccx.tcx, it.span, it.id);\n       }"}, {"sha": "c5c445702d517f1074550f478c0fb4ab85d18a75", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,6 +1,14 @@\n import std::map::hashmap;\n import middle::ty;\n-import middle::ty::*;\n+import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n+import middle::ty::{ck_block, ck_box, ck_uniq, constr, ctxt, field, method};\n+import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n+import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n+import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_iface, ty_int};\n+import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n+import middle::ty::{ty_ptr, ty_rec, ty_res, ty_rptr, ty_self, ty_str, ty_tup};\n+import middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n+import middle::ty::{ty_vec, vid};\n import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;"}, {"sha": "a500d249c07a8aa0071d35868d01090e788f32cb", "filename": "src/test/compile-fail/issue-2509-a.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2509-a.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -0,0 +1,9 @@\n+class c { //! ERROR A class must have at least one field\n+    new() { }\n+}\n+\n+fn main() {\n+    let a = c();\n+    let x = [a];\n+    let _y = x[0];\n+}"}, {"sha": "736fee0f66cb9e2ef575fe09974b9e0706f787de", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -3,14 +3,15 @@\n // Test that a class with a non-copyable field can't be\n // copied\n class bar {\n-  new() {}\n+  let x: int;\n+  new(x:int) {self.x = x;}\n   drop {}\n }\n \n class foo {\n   let i: int;\n   let j: bar;\n-  new(i:int) { self.i = i; self.j = bar(); }\n+  new(i:int) { self.i = i; self.j = bar(5); }\n }\n \n fn main() { let x <- foo(10); let y = x; log(error, x); }"}, {"sha": "c62db9b8fff2a123eca35dd352134f50dc3e1648", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -4,7 +4,7 @@\n \n enum an_enum/& { }\n iface an_iface/& { }\n-class a_class/& { new() { } }\n+class a_class/& { let x:int; new(x:int) { self.x = x; } }\n \n fn a_fn1(e: an_enum/&a) -> an_enum/&b {\n     ret e; //! ERROR mismatched types: expected `an_enum/&b` but found `an_enum/&a`"}, {"sha": "f6388b19798393e114e1ae9bcb5fdb33fcf41883", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,7 +1,8 @@\n // error-pattern: copying a noncopyable value\n \n class r {\n-  new(_i:int) {}\n+  let i:int;\n+  new(i:int) {self.i = i;}\n   drop {}\n }\n "}, {"sha": "d68e9c49789563c7107cfd541fc969ffba23a875", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -21,7 +21,8 @@ fn getbig_call_c_and_fail(i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {\n     fn getbig(i: int) {\n         if i != 0 {\n@@ -34,7 +35,7 @@ class and_then_get_big_again {\n \n fn main() {\n     task::spawn {||\n-        let r = and_then_get_big_again();\n+        let r = and_then_get_big_again(4);\n         getbig_call_c_and_fail(10000);\n     };\n }\n\\ No newline at end of file"}, {"sha": "0f0aea5ccd122a2d606929bfd26d3ddd0f1defcb", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -5,7 +5,7 @@\n use std;\n \n fn getbig_and_fail(&&i: int) {\n-    let _r = and_then_get_big_again();\n+    let _r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);\n     } else {\n@@ -14,7 +14,8 @@ fn getbig_and_fail(&&i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {\n     fn getbig(i: int) {\n         if i != 0 {"}, {"sha": "b1c86d5110a9a260abf6f4630d5a433c4126bbe1", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -5,7 +5,7 @@\n use std;\n \n fn getbig_and_fail(&&i: int) {\n-    let r = and_then_get_big_again();\n+    let r = and_then_get_big_again(5);\n     if i != 0 {\n         getbig_and_fail(i - 1);\n     } else {\n@@ -14,7 +14,8 @@ fn getbig_and_fail(&&i: int) {\n }\n \n class and_then_get_big_again {\n-  new() {}\n+  let x:int;\n+  new(x:int) {self.x = x;}\n   drop {}\n }\n "}, {"sha": "2c2665446cdf4f7f362be0c118c98063fcb7c0a0", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -1,19 +1,20 @@\n // error-pattern:whatever\n \n class r {\n+  let x:int;\n             // Setting the exit status after the runtime has already\n             // failed has no effect and the process exits with the\n             // runtime's exit code\n   drop {\n     os::set_exit_status(50);\n   }\n-  new() {}\n+  new(x:int) {self.x = x;}\n }\n \n fn main() {\n     log(error, \"whatever\");\n     task::spawn {||\n-      let i = r();\n+      let i = r(5);\n     };\n     fail;\n }\n\\ No newline at end of file"}, {"sha": "2b64840d8301f4ac20350fe5445ebb62c1efcfac", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4cfdeee20eb54d43612fed461729ffa6f6d2ec/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=3b4cfdeee20eb54d43612fed461729ffa6f6d2ec", "patch": "@@ -26,11 +26,13 @@ enum tg { bar, }\n \n #[cfg(bogus)]\n class r {\n-  new(i:int) {}\n+  let i: int;\n+  new(i:int) { self.i = i; }\n }\n \n class r {\n-  new(i:int) {}\n+  let i: int;\n+  new(i:int) { self.i = i; }\n }\n \n #[cfg(bogus)]"}]}