{"sha": "2a5cbb0e42f330617a061243f8725d861dd5118b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNWNiYjBlNDJmMzMwNjE3YTA2MTI0M2Y4NzI1ZDg2MWRkNTExOGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-04T10:17:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-04T10:17:38Z"}, "message": "Auto merge of #72975 - Dylan-DPC:rollup-6zvco5x, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #72718 (Add regression test for #72554)\n - #72782 (rustc_target: Remove `pre_link_args_crt`)\n - #72923 (Improve E0433, so that it suggests missing imports)\n - #72950 (fix `AdtDef` docs)\n - #72951 (Add Camelid per request)\n - #72964 (Bump libc dependency to latest version (0.2.71))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "233ca9a35aed52d9262c72bad1318f94792a356c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/233ca9a35aed52d9262c72bad1318f94792a356c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a5cbb0e42f330617a061243f8725d861dd5118b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5cbb0e42f330617a061243f8725d861dd5118b", "html_url": "https://github.com/rust-lang/rust/commit/2a5cbb0e42f330617a061243f8725d861dd5118b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a5cbb0e42f330617a061243f8725d861dd5118b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "627957100c9b810a10c30a11cf1a8a3188d5f9f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/627957100c9b810a10c30a11cf1a8a3188d5f9f4", "html_url": "https://github.com/rust-lang/rust/commit/627957100c9b810a10c30a11cf1a8a3188d5f9f4"}, {"sha": "26f0d7f5ffba150d650092b5511f555d68975c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f0d7f5ffba150d650092b5511f555d68975c6d", "html_url": "https://github.com/rust-lang/rust/commit/26f0d7f5ffba150d650092b5511f555d68975c6d"}], "stats": {"total": 324, "additions": 253, "deletions": 71}, "files": [{"sha": "7f640d40bb785fac4b93181bac0f804dacd5e9b1", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -44,6 +44,7 @@ Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n+Camelid <camelidcamel@gmail.com> <37223377+camelid@users.noreply.github.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>"}, {"sha": "e33d09bc21179eb4d4a888b14e8124f1d4ad1187", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1853,9 +1853,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.69\"\n+version = \"0.2.71\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n+checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "cff84b11aa09833acc29f76fe6591b8881b46e17", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1253,20 +1253,10 @@ fn add_post_link_objects(\n \n /// Add arbitrary \"pre-link\" args defined by the target spec or from command line.\n /// FIXME: Determine where exactly these args need to be inserted.\n-fn add_pre_link_args(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    flavor: LinkerFlavor,\n-    crate_type: CrateType,\n-) {\n+fn add_pre_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n-    if let Some(args) = sess.target.target.options.pre_link_args_crt.get(&flavor) {\n-        if sess.crt_static(Some(crate_type)) {\n-            cmd.args(args);\n-        }\n-    }\n     cmd.args(&sess.opts.debugging_opts.pre_link_args);\n }\n \n@@ -1502,7 +1492,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     let crt_objects_fallback = crt_objects_fallback(sess, crate_type);\n \n     // NO-OPT-OUT, OBJECT-FILES-MAYBE, CUSTOMIZATION-POINT\n-    add_pre_link_args(cmd, sess, flavor, crate_type);\n+    add_pre_link_args(cmd, sess, flavor);\n \n     // NO-OPT-OUT\n     add_link_script(cmd, sess, tmpdir, crate_type);"}, {"sha": "d9fed998c92fb8afd65618658447130f9d1e5980", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -315,6 +315,21 @@ impl<'a> Linker for GccLinker<'a> {\n                 self.build_dylib(out_filename);\n             }\n         }\n+        // VxWorks compiler driver introduced `--static-crt` flag specifically for rustc,\n+        // it switches linking for libc and similar system libraries to static without using\n+        // any `#[link]` attributes in the `libc` crate, see #72782 for details.\n+        // FIXME: Switch to using `#[link]` attributes in the `libc` crate\n+        // similarly to other targets.\n+        if self.sess.target.target.target_os == \"vxworks\"\n+            && matches!(\n+                output_kind,\n+                LinkOutputKind::StaticNoPicExe\n+                    | LinkOutputKind::StaticPicExe\n+                    | LinkOutputKind::StaticDylib\n+            )\n+        {\n+            self.cmd.arg(\"--static-crt\");\n+        }\n     }\n \n     fn link_dylib(&mut self, lib: Symbol) {"}, {"sha": "00c00a63b6b5db747849d59f5e530370af3a02a0", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1846,7 +1846,7 @@ pub struct FieldDef {\n \n /// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n ///\n-/// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n+/// These are all interned (by `alloc_adt_def`) into the global arena.\n ///\n /// The initialism *ADT* stands for an [*algebraic data type (ADT)*][adt].\n /// This is slightly wrong because `union`s are not ADTs."}, {"sha": "cbb2878011c5f2741e4fc206c421d6ea4cba901d", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1475,7 +1475,7 @@ crate fn show_candidates(\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],\n-    better: bool,\n+    instead: bool,\n     found_use: bool,\n ) {\n     if candidates.is_empty() {\n@@ -1486,6 +1486,7 @@ crate fn show_candidates(\n     // by iterating through a hash map, so make sure they are ordered:\n     let mut path_strings: Vec<_> =\n         candidates.iter().map(|c| path_names_to_string(&c.path)).collect();\n+\n     path_strings.sort();\n     path_strings.dedup();\n \n@@ -1494,8 +1495,9 @@ crate fn show_candidates(\n     } else {\n         (\"one of these\", \"items\")\n     };\n-    let instead = if better { \" instead\" } else { \"\" };\n-    let msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n+\n+    let instead = if instead { \" instead\" } else { \"\" };\n+    let mut msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n \n     if let Some(span) = use_placement_span {\n         for candidate in &mut path_strings {\n@@ -1507,12 +1509,13 @@ crate fn show_candidates(\n \n         err.span_suggestions(span, &msg, path_strings.into_iter(), Applicability::Unspecified);\n     } else {\n-        let mut msg = msg;\n         msg.push(':');\n+\n         for candidate in path_strings {\n             msg.push('\\n');\n             msg.push_str(&candidate);\n         }\n+\n         err.note(&msg);\n     }\n }"}, {"sha": "2085c8109fd5c826cb344531543b6245506a2981", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 116, "deletions": 30, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -29,8 +29,9 @@ use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use log::debug;\n+use rustc_span::source_map::{respan, Spanned};\n use std::collections::BTreeSet;\n-use std::mem::replace;\n+use std::mem::{replace, take};\n \n mod diagnostics;\n crate mod lifetimes;\n@@ -234,6 +235,13 @@ impl<'a> PathSource<'a> {\n         }\n     }\n \n+    fn is_call(self) -> bool {\n+        match self {\n+            PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })) => true,\n+            _ => false,\n+        }\n+    }\n+\n     crate fn is_expected(self, res: Res) -> bool {\n         match self {\n             PathSource::Type => match res {\n@@ -1620,14 +1628,83 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let better = res.is_some();\n+            let instead = res.is_some();\n             let suggestion =\n                 if res.is_none() { this.report_missing_type_error(path) } else { None };\n-            this.r.use_injections.push(UseError { err, candidates, def_id, better, suggestion });\n+\n+            this.r.use_injections.push(UseError { err, candidates, def_id, instead, suggestion });\n+\n             PartialRes::new(Res::Err)\n         };\n \n+        // For paths originating from calls (like in `HashMap::new()`), tries\n+        // to enrich the plain `failed to resolve: ...` message with hints\n+        // about possible missing imports.\n+        //\n+        // Similar thing, for types, happens in `report_errors` above.\n+        let report_errors_for_call = |this: &mut Self, parent_err: Spanned<ResolutionError<'a>>| {\n+            if !source.is_call() {\n+                return Some(parent_err);\n+            }\n+\n+            // Before we start looking for candidates, we have to get our hands\n+            // on the type user is trying to perform invocation on; basically:\n+            // we're transforming `HashMap::new` into just `HashMap`\n+            let path = if let Some((_, path)) = path.split_last() {\n+                path\n+            } else {\n+                return Some(parent_err);\n+            };\n+\n+            let (mut err, candidates) =\n+                this.smart_resolve_report_errors(path, span, PathSource::Type, None);\n+\n+            if candidates.is_empty() {\n+                err.cancel();\n+                return Some(parent_err);\n+            }\n+\n+            // There are two different error messages user might receive at\n+            // this point:\n+            // - E0412 cannot find type `{}` in this scope\n+            // - E0433 failed to resolve: use of undeclared type or module `{}`\n+            //\n+            // The first one is emitted for paths in type-position, and the\n+            // latter one - for paths in expression-position.\n+            //\n+            // Thus (since we're in expression-position at this point), not to\n+            // confuse the user, we want to keep the *message* from E0432 (so\n+            // `parent_err`), but we want *hints* from E0412 (so `err`).\n+            //\n+            // And that's what happens below - we're just mixing both messages\n+            // into a single one.\n+            let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n+\n+            parent_err.cancel();\n+\n+            err.message = take(&mut parent_err.message);\n+            err.code = take(&mut parent_err.code);\n+            err.children = take(&mut parent_err.children);\n+\n+            drop(parent_err);\n+\n+            let def_id = this.parent_scope.module.normal_ancestor_id;\n+\n+            this.r.use_injections.push(UseError {\n+                err,\n+                candidates,\n+                def_id,\n+                instead: false,\n+                suggestion: None,\n+            });\n+\n+            // We don't return `Some(parent_err)` here, because the error will\n+            // be already printed as part of the `use` injections\n+            None\n+        };\n+\n         let partial_res = match self.resolve_qpath_anywhere(\n             id,\n             qself,\n@@ -1637,14 +1714,15 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             source.defer_to_typeck(),\n             crate_lint,\n         ) {\n-            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+            Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n                 if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n                     partial_res\n                 } else {\n                     report_errors(self, Some(partial_res.base_res()))\n                 }\n             }\n-            Some(partial_res) if source.defer_to_typeck() => {\n+\n+            Ok(Some(partial_res)) if source.defer_to_typeck() => {\n                 // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n@@ -1655,25 +1733,34 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 }\n \n                 let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n+\n                 std_path.extend(path);\n+\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n-                    let cl = CrateLint::No;\n-                    let ns = Some(ns);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, ns, false, span, cl)\n+                        self.resolve_path(&std_path, Some(ns), false, span, CrateLint::No)\n                     {\n-                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n+                        // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n                             path.iter().last().map(|segment| segment.ident.span).unwrap_or(span);\n-                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n+\n                         let mut hm = self.r.session.confused_type_with_std_module.borrow_mut();\n                         hm.insert(item_span, span);\n-                        // In some places (E0223) we only have access to the full path\n                         hm.insert(span, span);\n                     }\n                 }\n+\n                 partial_res\n             }\n+\n+            Err(err) => {\n+                if let Some(err) = report_errors_for_call(self, err) {\n+                    self.r.report_error(err.span, err.node);\n+                }\n+\n+                PartialRes::new(Res::Err)\n+            }\n+\n             _ => report_errors(self, None),\n         };\n \n@@ -1682,6 +1769,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n             self.r.record_partial_res(id, partial_res);\n         }\n+\n         partial_res\n     }\n \n@@ -1711,17 +1799,16 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         span: Span,\n         defer_to_typeck: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n+    ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n+\n         for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n-                    // If defer_to_typeck, then resolution > no resolution,\n-                    // otherwise full resolution > partial resolution > no resolution.\n+                match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n                     Some(partial_res)\n                         if partial_res.unresolved_segments() == 0 || defer_to_typeck =>\n                     {\n-                        return Some(partial_res);\n+                        return Ok(Some(partial_res));\n                     }\n                     partial_res => {\n                         if fin_res.is_none() {\n@@ -1732,19 +1819,19 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        // `MacroNS`\n         assert!(primary_ns != MacroNS);\n+\n         if qself.is_none() {\n             let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n             let path = Path { segments: path.iter().map(path_seg).collect(), span };\n             if let Ok((_, res)) =\n                 self.r.resolve_macro_path(&path, None, &self.parent_scope, false, false)\n             {\n-                return Some(PartialRes::new(res));\n+                return Ok(Some(PartialRes::new(res)));\n             }\n         }\n \n-        fin_res\n+        Ok(fin_res)\n     }\n \n     /// Handles paths that may refer to associated items.\n@@ -1756,7 +1843,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ns: Namespace,\n         span: Span,\n         crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n+    ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n             id, qself, path, ns, span,\n@@ -1767,10 +1854,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // This is a case like `<T>::B`, where there is no\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n-                return Some(PartialRes::with_unresolved_segments(\n+                return Ok(Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)),\n                     path.len(),\n-                ));\n+                )));\n             }\n \n             // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n@@ -1800,10 +1887,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // The remaining segments (the `C` in our example) will\n             // have to be resolved by type-check, since that requires doing\n             // trait resolution.\n-            return Some(PartialRes::with_unresolved_segments(\n+            return Ok(Some(PartialRes::with_unresolved_segments(\n                 partial_res.base_res(),\n                 partial_res.unresolved_segments() + path.len() - qself.position - 1,\n-            ));\n+            )));\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n@@ -1838,11 +1925,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 PartialRes::new(module.res().unwrap())\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                self.r.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n-                PartialRes::new(Res::Err)\n+                return Err(respan(span, ResolutionError::FailedToResolve { label, suggestion }));\n             }\n-            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n-            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n+            PathResult::Module(..) | PathResult::Failed { .. } => return Ok(None),\n+            PathResult::Indeterminate => bug!(\"indeterminate path result in resolve_qpath\"),\n         };\n \n         if path.len() > 1\n@@ -1862,7 +1948,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n                     }\n-                    _ => return Some(result),\n+                    _ => return Ok(Some(result)),\n                 }\n             };\n             if result.base_res() == unqualified_result {\n@@ -1871,7 +1957,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        Some(result)\n+        Ok(Some(result))\n     }\n \n     fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {"}, {"sha": "c7f10fac6bc0826b9556a63b8bd54da5400fea7a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -618,13 +618,13 @@ struct PrivacyError<'a> {\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n-    /// Attach `use` statements for these candidates.\n+    /// Candidates which user could `use` to access the missing type.\n     candidates: Vec<ImportSuggestion>,\n-    /// The `NodeId` of the module to place the use-statements in.\n+    /// The `DefId` of the module to place the use-statements in.\n     def_id: DefId,\n-    /// Whether the diagnostic should state that it's \"better\".\n-    better: bool,\n-    /// Extra free form suggestion. Currently used to suggest new type parameter.\n+    /// Whether the diagnostic should say \"instead\" (as in `consider importing ... instead`).\n+    instead: bool,\n+    /// Extra free-form suggestion.\n     suggestion: Option<(Span, &'static str, String, Applicability)>,\n }\n \n@@ -2577,12 +2577,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, def_id, better, suggestion } in\n+        for UseError { mut err, candidates, def_id, instead, suggestion } in\n             self.use_injections.drain(..)\n         {\n             let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n             if !candidates.is_empty() {\n-                diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n+                diagnostics::show_candidates(&mut err, span, &candidates, instead, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n                 err.span_suggestion(span, msg, sugg, appl);\n             }"}, {"sha": "f329c8c06cc2edd860fd8c4d142c2cc7546be1ef", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -733,8 +733,7 @@ pub struct TargetOptions {\n     pub lld_flavor: LldFlavor,\n \n     /// Linker arguments that are passed *before* any user-defined libraries.\n-    pub pre_link_args: LinkArgs, // ... unconditionally\n-    pub pre_link_args_crt: LinkArgs, // ... when linking with a bundled crt\n+    pub pre_link_args: LinkArgs,\n     /// Objects to link before and after all other object code.\n     pub pre_link_objects: CrtObjects,\n     pub post_link_objects: CrtObjects,\n@@ -997,7 +996,6 @@ impl Default for TargetOptions {\n             linker: option_env!(\"CFG_DEFAULT_LINKER\").map(|s| s.to_string()),\n             lld_flavor: LldFlavor::Ld,\n             pre_link_args: LinkArgs::new(),\n-            pre_link_args_crt: LinkArgs::new(),\n             post_link_args: LinkArgs::new(),\n             link_script: None,\n             asm_args: Vec::new(),\n@@ -1397,7 +1395,6 @@ impl Target {\n         key!(post_link_objects_fallback, link_objects);\n         key!(crt_objects_fallback, crt_objects_fallback)?;\n         key!(pre_link_args, link_args);\n-        key!(pre_link_args_crt, link_args);\n         key!(late_link_args, link_args);\n         key!(late_link_args_dynamic, link_args);\n         key!(late_link_args_static, link_args);\n@@ -1629,7 +1626,6 @@ impl ToJson for Target {\n         target_option_val!(post_link_objects_fallback);\n         target_option_val!(crt_objects_fallback);\n         target_option_val!(link_args - pre_link_args);\n-        target_option_val!(link_args - pre_link_args_crt);\n         target_option_val!(link_args - late_link_args);\n         target_option_val!(link_args - late_link_args_dynamic);\n         target_option_val!(link_args - late_link_args_static);"}, {"sha": "788d1d2c48405f1762ba3dfcfbd3deb202531756", "filename": "src/librustc_target/spec/tests/tests_impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ftests%2Ftests_impl.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -25,7 +25,6 @@ impl Target {\n         );\n         for args in &[\n             &self.options.pre_link_args,\n-            &self.options.pre_link_args_crt,\n             &self.options.late_link_args,\n             &self.options.late_link_args_dynamic,\n             &self.options.late_link_args_static,"}, {"sha": "777bb58d7db8fc5bcd5524fd10a25a3e609d56dd", "filename": "src/librustc_target/spec/vxworks_base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fvxworks_base.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1,8 +1,6 @@\n use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};\n \n pub fn opts() -> TargetOptions {\n-    let mut args_crt = LinkArgs::new();\n-    args_crt.insert(LinkerFlavor::Gcc, vec![\"--static-crt\".to_string()]);\n     let mut args = LinkArgs::new();\n     args.insert(\n         LinkerFlavor::Gcc,\n@@ -29,7 +27,6 @@ pub fn opts() -> TargetOptions {\n         pre_link_args: args,\n         position_independent_executables: false,\n         has_elf_tls: true,\n-        pre_link_args_crt: args_crt,\n         crt_static_default: true,\n         crt_static_respected: true,\n         crt_static_allows_dylibs: true,"}, {"sha": "a4daf86cc8a211145cf2daf26a2fbb3e0513b58d", "filename": "src/test/ui/derived-errors/issue-31997-1.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -2,7 +2,14 @@ error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n   --> $DIR/issue-31997-1.rs:20:19\n    |\n LL |     let mut map = HashMap::new();\n-   |                   ^^^^^^^ use of undeclared type or module `HashMap`\n+   |                   ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "d555e6542632bcdc3c86940ef570b748b754ac60", "filename": "src/test/ui/error-codes/E0433.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1,3 +1,3 @@\n fn main () {\n-    let map = HashMap::new(); //~ ERROR E0433\n+    let map = NonExistingMap::new(); //~ ERROR E0433\n }"}, {"sha": "d9555e1fcf7a8718101600602f1565cf3dd03558", "filename": "src/test/ui/error-codes/E0433.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n+error[E0433]: failed to resolve: use of undeclared type or module `NonExistingMap`\n   --> $DIR/E0433.rs:2:15\n    |\n-LL |     let map = HashMap::new();\n-   |               ^^^^^^^ use of undeclared type or module `HashMap`\n+LL |     let map = NonExistingMap::new();\n+   |               ^^^^^^^^^^^^^^ use of undeclared type or module `NonExistingMap`\n \n error: aborting due to previous error\n "}, {"sha": "c0539434d02073e43920490c63404573a6a50122", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -13,9 +13,15 @@ LL |     fn f() { ::bar::m!(); }\n    |              ------------ in this macro invocation\n ...\n LL |         Vec::new();\n-   |         ^^^ use of undeclared type or module `Vec`\n+   |         ^^^ not found in this scope\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider importing one of these items\n+   |\n+LL |     use std::prelude::v1::Vec;\n+   |\n+LL |     use std::vec::Vec;\n+   |\n \n error[E0599]: no method named `clone` found for unit type `()` in the current scope\n   --> $DIR/no_implicit_prelude.rs:12:12"}, {"sha": "47aca05d7786fd5621c8e26ed73e47dfe311e731", "filename": "src/test/ui/issues/issue-72554.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -0,0 +1,20 @@\n+use std::collections::BTreeSet;\n+\n+#[derive(Hash)]\n+pub enum ElemDerived { //~ ERROR recursive type `ElemDerived` has infinite size\n+    A(ElemDerived)\n+}\n+\n+pub enum Elem {\n+    Derived(ElemDerived)\n+}\n+\n+pub struct Set(BTreeSet<Elem>);\n+\n+impl Set {\n+    pub fn into_iter(self) -> impl Iterator<Item = Elem> {\n+        self.0.into_iter()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9db65f4a2ee8f2d95ed780073d1a0d4fba7a1315", "filename": "src/test/ui/issues/issue-72554.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72554.stderr?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -0,0 +1,13 @@\n+error[E0072]: recursive type `ElemDerived` has infinite size\n+  --> $DIR/issue-72554.rs:4:1\n+   |\n+LL | pub enum ElemDerived {\n+   | ^^^^^^^^^^^^^^^^^^^^ recursive type has infinite size\n+LL |     A(ElemDerived)\n+   |       ----------- recursive without indirection\n+   |\n+   = help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `ElemDerived` representable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "8c9bc6d76b8b20895283eadf11a51e3580cd953b", "filename": "src/test/ui/resolve/use_suggestion.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x1 = HashMap::new(); //~ ERROR failed to resolve\n+    let x2 = GooMap::new(); //~ ERROR failed to resolve\n+\n+    let y1: HashMap; //~ ERROR cannot find type\n+    let y2: GooMap; //~ ERROR cannot find type\n+}"}, {"sha": "2fd3d5dccd23d16b17bf0d522b25ea7c2b3eb94f", "filename": "src/test/ui/resolve/use_suggestion.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a5cbb0e42f330617a061243f8725d861dd5118b/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr?ref=2a5cbb0e42f330617a061243f8725d861dd5118b", "patch": "@@ -0,0 +1,42 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `GooMap`\n+  --> $DIR/use_suggestion.rs:3:14\n+   |\n+LL |     let x2 = GooMap::new();\n+   |              ^^^^^^ use of undeclared type or module `GooMap`\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n+  --> $DIR/use_suggestion.rs:2:14\n+   |\n+LL |     let x1 = HashMap::new();\n+   |              ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n+\n+error[E0412]: cannot find type `HashMap` in this scope\n+  --> $DIR/use_suggestion.rs:5:13\n+   |\n+LL |     let y1: HashMap;\n+   |             ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n+\n+error[E0412]: cannot find type `GooMap` in this scope\n+  --> $DIR/use_suggestion.rs:6:13\n+   |\n+LL |     let y2: GooMap;\n+   |             ^^^^^^ not found in this scope\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0412, E0433.\n+For more information about an error, try `rustc --explain E0412`."}]}