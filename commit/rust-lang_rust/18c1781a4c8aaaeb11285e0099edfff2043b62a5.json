{"sha": "18c1781a4c8aaaeb11285e0099edfff2043b62a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YzE3ODFhNGM4YWFhZWIxMTI4NWUwMDk5ZWRmZmYyMDQzYjYyYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T19:26:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T19:26:05Z"}, "message": "Auto merge of #30834 - reem:rwlock-read-guard-map, r=alexcrichton\n\nThis is very useful when the RwLock is synchronizing access to a data\nstructure and you would like to return or store guards which contain\nreferences to data inside the data structure instead of the data structure\nitself.", "tree": {"sha": "79fd431495bb18cc956907592122cf76dbfa2c41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79fd431495bb18cc956907592122cf76dbfa2c41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18c1781a4c8aaaeb11285e0099edfff2043b62a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18c1781a4c8aaaeb11285e0099edfff2043b62a5", "html_url": "https://github.com/rust-lang/rust/commit/18c1781a4c8aaaeb11285e0099edfff2043b62a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18c1781a4c8aaaeb11285e0099edfff2043b62a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc73c703ab175577346773ad93de3aa2c3f44a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc73c703ab175577346773ad93de3aa2c3f44a2", "html_url": "https://github.com/rust-lang/rust/commit/8fc73c703ab175577346773ad93de3aa2c3f44a2"}, {"sha": "fc875b087cdd844fa61204db30c287f3c3179d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc875b087cdd844fa61204db30c287f3c3179d92", "html_url": "https://github.com/rust-lang/rust/commit/fc875b087cdd844fa61204db30c287f3c3179d92"}], "stats": {"total": 285, "additions": 228, "deletions": 57}, "files": [{"sha": "e83ebd10612840030f6747349eb56ea74457d96b", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 85, "deletions": 22, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/18c1781a4c8aaaeb11285e0099edfff2043b62a5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c1781a4c8aaaeb11285e0099edfff2043b62a5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=18c1781a4c8aaaeb11285e0099edfff2043b62a5", "patch": "@@ -172,7 +172,7 @@ pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n     __lock: &'a StaticMutex,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a mut T,\n     __poison: poison::Guard,\n }\n \n@@ -211,8 +211,10 @@ impl<T: ?Sized> Mutex<T> {\n     /// this call will return an error once the mutex is acquired.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> LockResult<MutexGuard<T>> {\n-        unsafe { self.inner.lock.lock() }\n-        MutexGuard::new(&*self.inner, &self.data)\n+        unsafe {\n+            self.inner.lock.lock();\n+            MutexGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to acquire this lock.\n@@ -230,10 +232,12 @@ impl<T: ?Sized> Mutex<T> {\n     /// acquired.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_lock(&self) -> TryLockResult<MutexGuard<T>> {\n-        if unsafe { self.inner.lock.try_lock() } {\n-            Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_lock() {\n+                Ok(try!(MutexGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -338,17 +342,21 @@ impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n-        unsafe { self.lock.lock() }\n-        MutexGuard::new(self, &DUMMY.0)\n+        unsafe {\n+            self.lock.lock();\n+            MutexGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n-        if unsafe { self.lock.try_lock() } {\n-            Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_lock() {\n+                Ok(try!(MutexGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -369,32 +377,72 @@ impl StaticMutex {\n \n impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n \n-    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n+    unsafe fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             MutexGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # #![feature(guard_map)]\n+    /// # use std::sync::{Mutex, MutexGuard};\n+    /// let x = Mutex::new(vec![1, 2]);\n+    ///\n+    /// {\n+    ///     let mut y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n+    ///     *y = 3;\n+    /// }\n+    ///\n+    /// assert_eq!(&*x.lock().unwrap(), &[3, 2]);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"27746\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n+        where F: FnOnce(&'mutex mut T) -> &'mutex mut U\n+    {\n+        // Compute the new data while still owning the original lock\n+        // in order to correctly poison if the callback panics.\n+        let data = unsafe { ptr::read(&this.__data) };\n+        let new_data = cb(data);\n+\n+        // We don't want to unlock the lock by running the destructor of the\n+        // original lock, so just read the fields we need and forget it.\n+        let (poison, lock) = unsafe {\n+            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n+        };\n+        mem::forget(this);\n+\n+        MutexGuard {\n+            __lock: lock,\n+            __data: new_data,\n+            __poison: poison\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T {\n-        unsafe { &*self.__data.get() }\n-    }\n+    fn deref(&self) -> &T {self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__data.get() }\n-    }\n+    fn deref_mut(&mut self) -> &mut T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -421,7 +469,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar, MutexGuard};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -665,4 +713,19 @@ mod tests {\n         let comp: &[i32] = &[4, 2, 5];\n         assert_eq!(&*mutex.lock().unwrap(), comp);\n     }\n+\n+    #[test]\n+    fn test_mutex_guard_map_panic() {\n+        let mutex = Arc::new(Mutex::new(vec![1, 2]));\n+        let mutex2 = mutex.clone();\n+\n+        thread::spawn(move || {\n+            let _ = MutexGuard::map::<usize, _>(mutex2.lock().unwrap(), |_| panic!());\n+        }).join().unwrap_err();\n+\n+        match mutex.lock() {\n+            Ok(r) => panic!(\"Lock on poisioned Mutex is Ok: {:?}\", &*r),\n+            Err(_) => {}\n+        };\n+    }\n }"}, {"sha": "1ecc8974369abeeccf04cd80ad902b7a4d32fda5", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 143, "deletions": 35, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/18c1781a4c8aaaeb11285e0099edfff2043b62a5/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18c1781a4c8aaaeb11285e0099edfff2043b62a5/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=18c1781a4c8aaaeb11285e0099edfff2043b62a5", "patch": "@@ -121,7 +121,7 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a T,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -133,7 +133,7 @@ impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a mut T,\n     __poison: poison::Guard,\n }\n \n@@ -177,8 +177,10 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n-        unsafe { self.inner.lock.read() }\n-        RwLockReadGuard::new(&*self.inner, &self.data)\n+        unsafe {\n+            self.inner.lock.read();\n+            RwLockReadGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to acquire this rwlock with shared read access.\n@@ -201,10 +203,12 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n-        if unsafe { self.inner.lock.try_read() } {\n-            Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_read() {\n+                Ok(try!(RwLockReadGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -225,8 +229,10 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n-        unsafe { self.inner.lock.write() }\n-        RwLockWriteGuard::new(&*self.inner, &self.data)\n+        unsafe {\n+            self.inner.lock.write();\n+            RwLockWriteGuard::new(&*self.inner, &self.data)\n+        }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -249,10 +255,12 @@ impl<T: ?Sized> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n-        if unsafe { self.inner.lock.try_write() } {\n-            Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.inner.lock.try_write() {\n+                Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -360,8 +368,10 @@ impl StaticRwLock {\n     /// See `RwLock::read`.\n     #[inline]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n-        unsafe { self.lock.read() }\n-        RwLockReadGuard::new(self, &DUMMY.0)\n+        unsafe {\n+            self.lock.read();\n+            RwLockReadGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to acquire this lock with shared read access.\n@@ -370,10 +380,12 @@ impl StaticRwLock {\n     #[inline]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n-        if unsafe { self.lock.try_read() } {\n-            Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_read(){\n+                Ok(try!(RwLockReadGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -383,8 +395,10 @@ impl StaticRwLock {\n     /// See `RwLock::write`.\n     #[inline]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n-        unsafe { self.lock.write() }\n-        RwLockWriteGuard::new(self, &DUMMY.0)\n+        unsafe {\n+            self.lock.write();\n+            RwLockWriteGuard::new(self, &DUMMY.0)\n+        }\n     }\n \n     /// Attempts to lock this rwlock with exclusive write access.\n@@ -393,10 +407,12 @@ impl StaticRwLock {\n     #[inline]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n-        if unsafe { self.lock.try_write() } {\n-            Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n-        } else {\n-            Err(TryLockError::WouldBlock)\n+        unsafe {\n+            if self.lock.try_write() {\n+                Ok(try!(RwLockWriteGuard::new(self, &DUMMY.0)))\n+            } else {\n+                Err(TryLockError::WouldBlock)\n+            }\n         }\n     }\n \n@@ -412,48 +428,124 @@ impl StaticRwLock {\n }\n \n impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: &*data.get(),\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # #![feature(guard_map)]\n+    /// # use std::sync::{RwLockReadGuard, RwLock};\n+    /// let x = RwLock::new(vec![1, 2]);\n+    ///\n+    /// let y = RwLockReadGuard::map(x.read().unwrap(), |v| &v[0]);\n+    /// assert_eq!(*y, 1);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"27746\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockReadGuard<'rwlock, U>\n+        where F: FnOnce(&'rwlock T) -> &'rwlock U\n+    {\n+        let new = RwLockReadGuard {\n+            __lock: this.__lock,\n+            __data: cb(this.__data)\n+        };\n+\n+        mem::forget(this);\n+\n+        new\n+    }\n }\n \n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n+    unsafe fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n             RwLockWriteGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: &mut *data.get(),\n                 __poison: guard,\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # #![feature(guard_map)]\n+    /// # use std::sync::{RwLockWriteGuard, RwLock};\n+    /// let x = RwLock::new(vec![1, 2]);\n+    ///\n+    /// {\n+    ///     let mut y = RwLockWriteGuard::map(x.write().unwrap(), |v| &mut v[0]);\n+    ///     assert_eq!(*y, 1);\n+    ///\n+    ///     *y = 10;\n+    /// }\n+    ///\n+    /// assert_eq!(&**x.read().unwrap(), &[10, 2]);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"27746\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockWriteGuard<'rwlock, U>\n+        where F: FnOnce(&'rwlock mut T) -> &'rwlock mut U\n+    {\n+        // Compute the new data while still owning the original lock\n+        // in order to correctly poison if the callback panics.\n+        let data = unsafe { ptr::read(&this.__data) };\n+        let new_data = cb(data);\n+\n+        // We don't want to unlock the lock by running the destructor of the\n+        // original lock, so just read the fields we need and forget it.\n+        let (poison, lock) = unsafe {\n+            (ptr::read(&this.__poison), ptr::read(&this.__lock))\n+        };\n+        mem::forget(this);\n+\n+        RwLockWriteGuard {\n+            __lock: lock,\n+            __data: new_data,\n+            __poison: poison\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n+    fn deref(&self) -> &T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n+    fn deref(&self) -> &T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        unsafe { &mut *self.__data.get() }\n+    fn deref_mut(&mut self) -> &mut T { self.__data\n     }\n }\n \n@@ -481,7 +573,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RwLockWriteGuard};\n     use sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Eq, PartialEq, Debug)]\n@@ -729,4 +821,20 @@ mod tests {\n             Ok(x) => panic!(\"get_mut of poisoned RwLock is Ok: {:?}\", x),\n         }\n     }\n+\n+    #[test]\n+    fn test_rwlock_write_map_poison() {\n+        let rwlock = Arc::new(RwLock::new(vec![1, 2]));\n+        let rwlock2 = rwlock.clone();\n+\n+        thread::spawn(move || {\n+            let _ = RwLockWriteGuard::map::<usize, _>(rwlock2.write().unwrap(), |_| panic!());\n+        }).join().unwrap_err();\n+\n+        match rwlock.read() {\n+            Ok(r) => panic!(\"Read lock on poisioned RwLock is Ok: {:?}\", &*r),\n+            Err(_) => {}\n+        };\n+    }\n }\n+"}]}