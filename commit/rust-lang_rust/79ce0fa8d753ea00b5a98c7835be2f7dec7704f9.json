{"sha": "79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Y2UwZmE4ZDc1M2VhMDBiNWE5OGM3ODM1YmUyZjdkZWM3NzA0Zjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-21T09:03:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-21T09:03:42Z"}, "message": "move whitespace handling to tree builder", "tree": {"sha": "a979b22ec18e0c0f464f93a99e61c2f9387fd4e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a979b22ec18e0c0f464f93a99e61c2f9387fd4e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "html_url": "https://github.com/rust-lang/rust/commit/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7", "html_url": "https://github.com/rust-lang/rust/commit/c84561bb624280b84eb2fe6c6b2a6b9fe3f1dbf7"}], "stats": {"total": 347, "additions": 159, "deletions": 188}, "files": [{"sha": "7e1b32035ba74ada1e4d0b5f7db20a8a84aa9d5f", "filename": "crates/ra_syntax/src/parsing.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing.rs?ref=79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "patch": "@@ -9,11 +9,11 @@ mod grammar;\n mod reparsing;\n \n use crate::{\n-    SyntaxKind, SmolStr, SyntaxError,\n+    SyntaxKind, SyntaxError,\n     parsing::{\n-        builder::GreenBuilder,\n+        builder::TreeBuilder,\n         input::ParserInput,\n-        event::EventProcessor,\n+        event::process,\n         parser::Parser,\n     },\n     syntax_node::GreenNode,\n@@ -28,37 +28,39 @@ pub(crate) use self::reparsing::incremental_reparse;\n \n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let tokens = tokenize(&text);\n-    parse_with(GreenBuilder::default(), text, &tokens, grammar::root)\n+    let tree_sink = TreeBuilder::new(text, &tokens);\n+    parse_with(tree_sink, text, &tokens, grammar::root)\n }\n \n fn parse_with<S: TreeSink>(\n-    tree_sink: S,\n+    mut tree_sink: S,\n     text: &str,\n     tokens: &[Token],\n     f: fn(&mut Parser),\n ) -> S::Tree {\n-    let mut events = {\n+    let events = {\n         let input = ParserInput::new(text, &tokens);\n         let mut p = Parser::new(&input);\n         f(&mut p);\n         p.finish()\n     };\n-    EventProcessor::new(tree_sink, text, tokens, &mut events).process().finish()\n+    process(&mut tree_sink, events);\n+    tree_sink.finish()\n }\n \n /// `TreeSink` abstracts details of a particular syntax tree implementation.\n trait TreeSink {\n     type Tree;\n \n     /// Adds new leaf to the current branch.\n-    fn leaf(&mut self, kind: SyntaxKind, text: SmolStr);\n+    fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8);\n \n     /// Start new branch and make it current.\n-    fn start_branch(&mut self, kind: SyntaxKind);\n+    fn start_branch(&mut self, kind: SyntaxKind, root: bool);\n \n     /// Finish current branch and restore previous\n     /// branch as current.\n-    fn finish_branch(&mut self);\n+    fn finish_branch(&mut self, root: bool);\n \n     fn error(&mut self, error: ParseError);\n "}, {"sha": "1041c6a7be5ab09d381cc38d0e2e56967c53abbc", "filename": "crates/ra_syntax/src/parsing/builder.rs", "status": "modified", "additions": 107, "deletions": 20, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fbuilder.rs?ref=79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "patch": "@@ -1,40 +1,63 @@\n use crate::{\n-    SmolStr, SyntaxKind, SyntaxError, SyntaxErrorKind, TextUnit,\n-    parsing::{TreeSink, ParseError},\n+    SmolStr, SyntaxError, SyntaxErrorKind, TextUnit, TextRange,\n+    SyntaxKind::{self, *},\n+    parsing::{TreeSink, ParseError, Token},\n     syntax_node::{GreenNode, RaTypes},\n };\n \n use rowan::GreenNodeBuilder;\n \n-pub(crate) struct GreenBuilder {\n+pub(crate) struct TreeBuilder<'a> {\n+    text: &'a str,\n+    tokens: &'a [Token],\n     text_pos: TextUnit,\n+    token_pos: usize,\n     errors: Vec<SyntaxError>,\n     inner: GreenNodeBuilder<RaTypes>,\n }\n \n-impl Default for GreenBuilder {\n-    fn default() -> GreenBuilder {\n-        GreenBuilder {\n-            text_pos: TextUnit::default(),\n-            errors: Vec::new(),\n-            inner: GreenNodeBuilder::new(),\n-        }\n-    }\n-}\n-\n-impl TreeSink for GreenBuilder {\n+impl<'a> TreeSink for TreeBuilder<'a> {\n     type Tree = (GreenNode, Vec<SyntaxError>);\n \n-    fn leaf(&mut self, kind: SyntaxKind, text: SmolStr) {\n-        self.text_pos += TextUnit::of_str(text.as_str());\n-        self.inner.leaf(kind, text);\n+    fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+        self.eat_trivias();\n+        let n_tokens = n_tokens as usize;\n+        let len = self.tokens[self.token_pos..self.token_pos + n_tokens]\n+            .iter()\n+            .map(|it| it.len)\n+            .sum::<TextUnit>();\n+        self.do_leaf(kind, len, n_tokens);\n     }\n \n-    fn start_branch(&mut self, kind: SyntaxKind) {\n-        self.inner.start_internal(kind)\n+    fn start_branch(&mut self, kind: SyntaxKind, root: bool) {\n+        if root {\n+            self.inner.start_internal(kind);\n+            return;\n+        }\n+        let n_trivias =\n+            self.tokens[self.token_pos..].iter().take_while(|it| it.kind.is_trivia()).count();\n+        let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n+        let mut trivia_end =\n+            self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextUnit>();\n+\n+        let n_attached_trivias = {\n+            let leading_trivias = leading_trivias.iter().rev().map(|it| {\n+                let next_end = trivia_end - it.len;\n+                let range = TextRange::from_to(next_end, trivia_end);\n+                trivia_end = next_end;\n+                (it.kind, &self.text[range])\n+            });\n+            n_attached_trivias(kind, leading_trivias)\n+        };\n+        self.eat_n_trivias(n_trivias - n_attached_trivias);\n+        self.inner.start_internal(kind);\n+        self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish_branch(&mut self) {\n+    fn finish_branch(&mut self, root: bool) {\n+        if root {\n+            self.eat_trivias()\n+        }\n         self.inner.finish_internal();\n     }\n \n@@ -47,3 +70,67 @@ impl TreeSink for GreenBuilder {\n         (self.inner.finish(), self.errors)\n     }\n }\n+\n+impl<'a> TreeBuilder<'a> {\n+    pub(super) fn new(text: &'a str, tokens: &'a [Token]) -> TreeBuilder<'a> {\n+        TreeBuilder {\n+            text,\n+            tokens,\n+            text_pos: 0.into(),\n+            token_pos: 0,\n+            errors: Vec::new(),\n+            inner: GreenNodeBuilder::new(),\n+        }\n+    }\n+    fn eat_trivias(&mut self) {\n+        while let Some(&token) = self.tokens.get(self.token_pos) {\n+            if !token.kind.is_trivia() {\n+                break;\n+            }\n+            self.do_leaf(token.kind, token.len, 1);\n+        }\n+    }\n+\n+    fn eat_n_trivias(&mut self, n: usize) {\n+        for _ in 0..n {\n+            let token = self.tokens[self.token_pos];\n+            assert!(token.kind.is_trivia());\n+            self.do_leaf(token.kind, token.len, 1);\n+        }\n+    }\n+\n+    fn do_leaf(&mut self, kind: SyntaxKind, len: TextUnit, n_tokens: usize) {\n+        let range = TextRange::offset_len(self.text_pos, len);\n+        let text: SmolStr = self.text[range].into();\n+        self.text_pos += len;\n+        self.token_pos += n_tokens;\n+        self.inner.leaf(kind, text);\n+    }\n+}\n+\n+fn n_attached_trivias<'a>(\n+    kind: SyntaxKind,\n+    trivias: impl Iterator<Item = (SyntaxKind, &'a str)>,\n+) -> usize {\n+    match kind {\n+        CONST_DEF | TYPE_DEF | STRUCT_DEF | ENUM_DEF | ENUM_VARIANT | FN_DEF | TRAIT_DEF\n+        | MODULE | NAMED_FIELD_DEF => {\n+            let mut res = 0;\n+            for (i, (kind, text)) in trivias.enumerate() {\n+                match kind {\n+                    WHITESPACE => {\n+                        if text.contains(\"\\n\\n\") {\n+                            break;\n+                        }\n+                    }\n+                    COMMENT => {\n+                        res = i + 1;\n+                    }\n+                    _ => (),\n+                }\n+            }\n+            res\n+        }\n+        _ => 0,\n+    }\n+}"}, {"sha": "d6cbdffe083ac4d682cd46e146942f0aae0da7a6", "filename": "crates/ra_syntax/src/parsing/event.rs", "status": "modified", "additions": 37, "deletions": 156, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Fevent.rs?ref=79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "patch": "@@ -10,13 +10,8 @@\n use std::mem;\n \n use crate::{\n-    SmolStr,\n     SyntaxKind::{self, *},\n-    TextRange, TextUnit,\n-    parsing::{\n-        ParseError, TreeSink,\n-        lexer::Token,\n-    },\n+    parsing::{ParseError, TreeSink},\n };\n \n /// `Parser` produces a flat list of `Event`s.\n@@ -88,160 +83,46 @@ impl Event {\n     }\n }\n \n-pub(super) struct EventProcessor<'a, S: TreeSink> {\n-    sink: S,\n-    text_pos: TextUnit,\n-    text: &'a str,\n-    token_pos: usize,\n-    tokens: &'a [Token],\n-    events: &'a mut [Event],\n-}\n-\n-impl<'a, S: TreeSink> EventProcessor<'a, S> {\n-    pub(super) fn new(\n-        sink: S,\n-        text: &'a str,\n-        tokens: &'a [Token],\n-        events: &'a mut [Event],\n-    ) -> EventProcessor<'a, S> {\n-        EventProcessor { sink, text_pos: 0.into(), text, token_pos: 0, tokens, events }\n-    }\n-\n-    /// Generate the syntax tree with the control of events.\n-    pub(crate) fn process(mut self) -> S {\n-        let mut forward_parents = Vec::new();\n-\n-        for i in 0..self.events.len() {\n-            match mem::replace(&mut self.events[i], Event::tombstone()) {\n-                Event::Start { kind: TOMBSTONE, .. } => (),\n-\n-                Event::Start { kind, forward_parent } => {\n-                    // For events[A, B, C], B is A's forward_parent, C is B's forward_parent,\n-                    // in the normal control flow, the parent-child relation: `A -> B -> C`,\n-                    // while with the magic forward_parent, it writes: `C <- B <- A`.\n-\n-                    // append `A` into parents.\n-                    forward_parents.push(kind);\n-                    let mut idx = i;\n-                    let mut fp = forward_parent;\n-                    while let Some(fwd) = fp {\n-                        idx += fwd as usize;\n-                        // append `A`'s forward_parent `B`\n-                        fp = match mem::replace(&mut self.events[idx], Event::tombstone()) {\n-                            Event::Start { kind, forward_parent } => {\n-                                forward_parents.push(kind);\n-                                forward_parent\n-                            }\n-                            _ => unreachable!(),\n-                        };\n-                        // append `B`'s forward_parent `C` in the next stage.\n-                    }\n-\n-                    for kind in forward_parents.drain(..).rev() {\n-                        self.start(kind);\n-                    }\n-                }\n-                Event::Finish => {\n-                    let is_last = i == self.events.len() - 1;\n-                    self.finish(is_last);\n-                }\n-                Event::Token { kind, n_raw_tokens } => {\n-                    self.eat_trivias();\n-                    let n_raw_tokens = n_raw_tokens as usize;\n-                    let len = self.tokens[self.token_pos..self.token_pos + n_raw_tokens]\n-                        .iter()\n-                        .map(|it| it.len)\n-                        .sum::<TextUnit>();\n-                    self.leaf(kind, len, n_raw_tokens);\n+/// Generate the syntax tree with the control of events.\n+pub(super) fn process(sink: &mut impl TreeSink, mut events: Vec<Event>) {\n+    let mut forward_parents = Vec::new();\n+\n+    for i in 0..events.len() {\n+        match mem::replace(&mut events[i], Event::tombstone()) {\n+            Event::Start { kind: TOMBSTONE, .. } => (),\n+\n+            Event::Start { kind, forward_parent } => {\n+                // For events[A, B, C], B is A's forward_parent, C is B's forward_parent,\n+                // in the normal control flow, the parent-child relation: `A -> B -> C`,\n+                // while with the magic forward_parent, it writes: `C <- B <- A`.\n+\n+                // append `A` into parents.\n+                forward_parents.push(kind);\n+                let mut idx = i;\n+                let mut fp = forward_parent;\n+                while let Some(fwd) = fp {\n+                    idx += fwd as usize;\n+                    // append `A`'s forward_parent `B`\n+                    fp = match mem::replace(&mut events[idx], Event::tombstone()) {\n+                        Event::Start { kind, forward_parent } => {\n+                            forward_parents.push(kind);\n+                            forward_parent\n+                        }\n+                        _ => unreachable!(),\n+                    };\n+                    // append `B`'s forward_parent `C` in the next stage.\n                 }\n-                Event::Error { msg } => self.sink.error(msg),\n-            }\n-        }\n-        self.sink\n-    }\n-\n-    /// Add the node into syntax tree but discard the comments/whitespaces.\n-    fn start(&mut self, kind: SyntaxKind) {\n-        if kind == SOURCE_FILE {\n-            self.sink.start_branch(kind);\n-            return;\n-        }\n-        let n_trivias =\n-            self.tokens[self.token_pos..].iter().take_while(|it| it.kind.is_trivia()).count();\n-        let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n-        let mut trivia_end =\n-            self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextUnit>();\n \n-        let n_attached_trivias = {\n-            let leading_trivias = leading_trivias.iter().rev().map(|it| {\n-                let next_end = trivia_end - it.len;\n-                let range = TextRange::from_to(next_end, trivia_end);\n-                trivia_end = next_end;\n-                (it.kind, &self.text[range])\n-            });\n-            n_attached_trivias(kind, leading_trivias)\n-        };\n-        self.eat_n_trivias(n_trivias - n_attached_trivias);\n-        self.sink.start_branch(kind);\n-        self.eat_n_trivias(n_attached_trivias);\n-    }\n-\n-    fn finish(&mut self, is_last: bool) {\n-        if is_last {\n-            self.eat_trivias()\n-        }\n-        self.sink.finish_branch();\n-    }\n-\n-    fn eat_trivias(&mut self) {\n-        while let Some(&token) = self.tokens.get(self.token_pos) {\n-            if !token.kind.is_trivia() {\n-                break;\n-            }\n-            self.leaf(token.kind, token.len, 1);\n-        }\n-    }\n-\n-    fn eat_n_trivias(&mut self, n: usize) {\n-        for _ in 0..n {\n-            let token = self.tokens[self.token_pos];\n-            assert!(token.kind.is_trivia());\n-            self.leaf(token.kind, token.len, 1);\n-        }\n-    }\n-\n-    fn leaf(&mut self, kind: SyntaxKind, len: TextUnit, n_tokens: usize) {\n-        let range = TextRange::offset_len(self.text_pos, len);\n-        let text: SmolStr = self.text[range].into();\n-        self.text_pos += len;\n-        self.token_pos += n_tokens;\n-        self.sink.leaf(kind, text);\n-    }\n-}\n-\n-fn n_attached_trivias<'a>(\n-    kind: SyntaxKind,\n-    trivias: impl Iterator<Item = (SyntaxKind, &'a str)>,\n-) -> usize {\n-    match kind {\n-        CONST_DEF | TYPE_DEF | STRUCT_DEF | ENUM_DEF | ENUM_VARIANT | FN_DEF | TRAIT_DEF\n-        | MODULE | NAMED_FIELD_DEF => {\n-            let mut res = 0;\n-            for (i, (kind, text)) in trivias.enumerate() {\n-                match kind {\n-                    WHITESPACE => {\n-                        if text.contains(\"\\n\\n\") {\n-                            break;\n-                        }\n-                    }\n-                    COMMENT => {\n-                        res = i + 1;\n-                    }\n-                    _ => (),\n+                for (j, kind) in forward_parents.drain(..).rev().enumerate() {\n+                    let is_root_node = i == 0 && j == 0;\n+                    sink.start_branch(kind, is_root_node);\n                 }\n             }\n-            res\n+            Event::Finish => sink.finish_branch(i == events.len() - 1),\n+            Event::Token { kind, n_raw_tokens } => {\n+                sink.leaf(kind, n_raw_tokens);\n+            }\n+            Event::Error { msg } => sink.error(msg),\n         }\n-        _ => 0,\n     }\n }"}, {"sha": "f4c2251d7c76a33cd07e828703ea0989f83d6418", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79ce0fa8d753ea00b5a98c7835be2f7dec7704f9/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=79ce0fa8d753ea00b5a98c7835be2f7dec7704f9", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     syntax_error::SyntaxError,\n     parsing::{\n         grammar, parse_with,\n-        builder::GreenBuilder,\n+        builder::TreeBuilder,\n         parser::Parser,\n         lexer::{tokenize, Token},\n     }\n@@ -61,7 +61,8 @@ fn reparse_block<'node>(\n     if !is_balanced(&tokens) {\n         return None;\n     }\n-    let (green, new_errors) = parse_with(GreenBuilder::default(), &text, &tokens, reparser);\n+    let tree_sink = TreeBuilder::new(&text, &tokens);\n+    let (green, new_errors) = parse_with(tree_sink, &text, &tokens, reparser);\n     Some((node, green, new_errors))\n }\n "}]}