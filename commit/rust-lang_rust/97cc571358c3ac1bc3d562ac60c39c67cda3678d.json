{"sha": "97cc571358c3ac1bc3d562ac60c39c67cda3678d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3Y2M1NzEzNThjM2FjMWJjM2Q1NjJhYzYwYzM5YzY3Y2RhMzY3OGQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T01:56:34Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T23:08:22Z"}, "message": "std: clean up the order of {De,En}codable methods", "tree": {"sha": "60382ad8d57eb6789426b0a58dd1be5f940e840a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60382ad8d57eb6789426b0a58dd1be5f940e840a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97cc571358c3ac1bc3d562ac60c39c67cda3678d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97cc571358c3ac1bc3d562ac60c39c67cda3678d", "html_url": "https://github.com/rust-lang/rust/commit/97cc571358c3ac1bc3d562ac60c39c67cda3678d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97cc571358c3ac1bc3d562ac60c39c67cda3678d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4464e447500c98242b536ee4a461fcd8c5d9adc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4464e447500c98242b536ee4a461fcd8c5d9adc5", "html_url": "https://github.com/rust-lang/rust/commit/4464e447500c98242b536ee4a461fcd8c5d9adc5"}], "stats": {"total": 175, "additions": 87, "deletions": 88}, "files": [{"sha": "3afc49d40addc6265fe51900234ef92c45c61e99", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=97cc571358c3ac1bc3d562ac60c39c67cda3678d", "patch": "@@ -335,20 +335,6 @@ pub mod reader {\n             f()\n         }\n \n-        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_seq()\");\n-            do self.push_doc(self.next_doc(EsVec)) {\n-                let len = self._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n-                f(len)\n-            }\n-        }\n-\n-        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_seq_elt(idx=%u)\", idx);\n-            self.push_doc(self.next_doc(EsVecElt), f)\n-        }\n-\n         fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n@@ -373,6 +359,20 @@ pub mod reader {\n             }\n         }\n \n+        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+            debug!(\"read_seq()\");\n+            do self.push_doc(self.next_doc(EsVec)) {\n+                let len = self._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(len)\n+            }\n+        }\n+\n+        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_seq_elt(idx=%u)\", idx);\n+            self.push_doc(self.next_doc(EsVecElt), f)\n+        }\n+\n         fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n             debug!(\"read_map()\");\n             fail!(~\"read_map is unimplemented\");\n@@ -613,17 +613,6 @@ pub mod writer {\n         }\n         fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n-        fn emit_seq(&self, len: uint, f: &fn()) {\n-            do self.wr_tag(EsVec as uint) {\n-                self._emit_tagged_uint(EsVecLen, len);\n-                f()\n-            }\n-        }\n-\n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.wr_tag(EsVecElt as uint, f)\n-        }\n-\n         fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n         fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n@@ -640,6 +629,17 @@ pub mod writer {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n+        fn emit_seq(&self, len: uint, f: &fn()) {\n+            do self.wr_tag(EsVec as uint) {\n+                self._emit_tagged_uint(EsVecLen, len);\n+                f()\n+            }\n+        }\n+\n+        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n+            self.wr_tag(EsVecElt as uint, f)\n+        }\n+\n         fn emit_map(&self, _len: uint, _f: &fn()) {\n             fail!(~\"emit_map is unimplemented\");\n         }"}, {"sha": "3714adb3055618dae4eeb3e8fce8187b269b5074", "filename": "src/libstd/json.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=97cc571358c3ac1bc3d562ac60c39c67cda3678d", "patch": "@@ -130,17 +130,6 @@ impl serialize::Encoder for Encoder {\n         f();\n     }\n \n-    fn emit_seq(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('[');\n-        f();\n-        self.wr.write_char(']');\n-    }\n-\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        f()\n-    }\n-\n     fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n@@ -157,6 +146,17 @@ impl serialize::Encoder for Encoder {\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n \n+    fn emit_seq(&self, _len: uint, f: &fn()) {\n+        self.wr.write_char('[');\n+        f();\n+        self.wr.write_char(']');\n+    }\n+\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f()\n+    }\n+\n     fn emit_map(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n@@ -241,58 +241,58 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_seq(&self, len: uint, f: &fn()) {\n+    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n         if len == 0 {\n-            self.wr.write_str(\"[]\");\n+            self.wr.write_str(\"{}\");\n         } else {\n-            self.wr.write_char('[');\n+            self.wr.write_char('{');\n             self.indent += 2;\n             f();\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            self.wr.write_char('}');\n         }\n     }\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        f()\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f();\n     }\n \n-    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_seq(&self, len: uint, f: &fn()) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            self.wr.write_str(\"[]\");\n         } else {\n-            self.wr.write_char('{');\n+            self.wr.write_char('[');\n             self.indent += 2;\n             f();\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            self.wr.write_char(']');\n         }\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n-        f();\n+        f()\n     }\n \n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n-\n     fn emit_map(&self, len: uint, f: &fn()) {\n         if len == 0 {\n             self.wr.write_str(\"{}\");\n@@ -827,26 +827,6 @@ impl serialize::Decoder for Decoder {\n         f()\n     }\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_seq()\");\n-        let len = match self.stack.pop() {\n-            List(list) => {\n-                let len = list.len();\n-                do vec::consume_reverse(list) |_i, v| {\n-                    self.stack.push(v);\n-                }\n-                len\n-            }\n-            _ => fail!(~\"not a list\"),\n-        };\n-        f(len)\n-    }\n-\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_seq_elt(idx=%u)\", idx);\n-        f()\n-    }\n-\n     fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n         debug!(\"read_struct(name=%s, len=%u)\", name, len);\n         let value = f();\n@@ -880,6 +860,26 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_seq()\");\n+        let len = match self.stack.pop() {\n+            List(list) => {\n+                let len = list.len();\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                len\n+            }\n+            _ => fail!(~\"not a list\"),\n+        };\n+        f(len)\n+    }\n+\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        f()\n+    }\n+\n     fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_map()\");\n         let len = match self.stack.pop() {"}, {"sha": "a49f43d485b1fdf89f7472e6757670fe80401312", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=97cc571358c3ac1bc3d562ac60c39c67cda3678d", "patch": "@@ -44,14 +44,10 @@ pub trait Encoder {\n     fn emit_str(&self, v: &str);\n \n     // Compound types:\n-\n     fn emit_enum(&self, name: &str, f: &fn());\n     fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n     fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_seq(&self, len: uint, f: &fn());\n-    fn emit_seq_elt(&self, idx: uint, f: &fn());\n-\n     fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n     fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n@@ -60,6 +56,9 @@ pub trait Encoder {\n     fn emit_option_none(&self);\n     fn emit_option_some(&self, f: &fn());\n \n+    fn emit_seq(&self, len: uint, f: &fn());\n+    fn emit_seq_elt(&self, idx: uint, f: &fn());\n+\n     fn emit_map(&self, len: uint, f: &fn());\n     fn emit_map_elt_key(&self, idx: uint, f: &fn());\n     fn emit_map_elt_val(&self, idx: uint, f: &fn());\n@@ -90,15 +89,15 @@ pub trait Decoder {\n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n-\n     fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n \n     // Specialized types:\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n \n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+\n     fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n     fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n     fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;"}, {"sha": "932c3477cf5bce22f43cfbd14caf2e44da9280d5", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97cc571358c3ac1bc3d562ac60c39c67cda3678d/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=97cc571358c3ac1bc3d562ac60c39c67cda3678d", "patch": "@@ -1253,13 +1253,6 @@ mod test {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n-        fn emit_seq(&self, +_len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n-        }\n-\n         fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n@@ -1279,6 +1272,13 @@ mod test {\n             f();\n         }\n \n+        fn emit_seq(&self, +_len: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n         fn emit_map(&self, _len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }"}]}