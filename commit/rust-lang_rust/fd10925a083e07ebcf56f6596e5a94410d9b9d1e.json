{"sha": "fd10925a083e07ebcf56f6596e5a94410d9b9d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTA5MjVhMDgzZTA3ZWJjZjU2ZjY1OTZlNWE5NDQxMGQ5YjlkMWU=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-08T09:24:03Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-11-08T09:24:03Z"}, "message": "Implement soft wrapping on doc comments", "tree": {"sha": "aa869a7be9543715e18b8c011b35dd3a894f9133", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa869a7be9543715e18b8c011b35dd3a894f9133"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd10925a083e07ebcf56f6596e5a94410d9b9d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd10925a083e07ebcf56f6596e5a94410d9b9d1e", "html_url": "https://github.com/rust-lang/rust/commit/fd10925a083e07ebcf56f6596e5a94410d9b9d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd10925a083e07ebcf56f6596e5a94410d9b9d1e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7f69ce77676e88f15e8567d09d5d5c0ebea3f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f69ce77676e88f15e8567d09d5d5c0ebea3f78", "html_url": "https://github.com/rust-lang/rust/commit/b7f69ce77676e88f15e8567d09d5d5c0ebea3f78"}], "stats": {"total": 219, "additions": 131, "deletions": 88}, "files": [{"sha": "a3fc1218145c4b7460e3f0dd4208807130b568fe", "filename": "src/visitor.rs", "status": "modified", "additions": 131, "deletions": 88, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/fd10925a083e07ebcf56f6596e5a94410d9b9d1e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd10925a083e07ebcf56f6596e5a94410d9b9d1e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=fd10925a083e07ebcf56f6596e5a94410d9b9d1e", "patch": "@@ -19,7 +19,7 @@ use syntax::parse::ParseSess;\n use expr::rewrite_literal;\n use spanned::Spanned;\n use codemap::{LineRangeUtils, SpanUtils};\n-use comment::{contains_comment, recover_missing_comment_in_span, remove_trailing_white_spaces,\n+use comment::{combine_strs_with_missing_comments, contains_comment, remove_trailing_white_spaces,\n               CodeCharKind, CommentCodeSlices, FindUncommented};\n use comment::rewrite_comment;\n use config::{BraceStyle, Config};\n@@ -791,106 +791,149 @@ impl Rewrite for ast::Attribute {\n     }\n }\n \n+/// Returns the first group of attributes that fills the given predicate.\n+/// We consider two doc comments are in different group if they are separated by normal comments.\n+fn take_while_with_pred<'a, P>(\n+    context: &RewriteContext,\n+    attrs: &'a [ast::Attribute],\n+    pred: P,\n+) -> Option<&'a [ast::Attribute]>\n+where\n+    P: Fn(&ast::Attribute) -> bool,\n+{\n+    let mut last_index = 0;\n+    let mut iter = attrs.iter().enumerate().peekable();\n+    while let Some((i, attr)) = iter.next() {\n+        if !pred(attr) {\n+            break;\n+        }\n+        if let Some(&(_, next_attr)) = iter.peek() {\n+            // Extract comments between two attributes.\n+            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n+            let snippet = context.snippet(span_between_attr);\n+            if snippet.chars().filter(|c| *c == '\\n').count() >= 2 || snippet.contains('/') {\n+                break;\n+            }\n+        }\n+        last_index = i;\n+    }\n+    if last_index == 0 {\n+        None\n+    } else {\n+        Some(&attrs[..last_index + 1])\n+    }\n+}\n+\n+fn rewrite_first_group_attrs(\n+    context: &RewriteContext,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<(usize, String)> {\n+    if attrs.is_empty() {\n+        return Some((0, String::new()));\n+    }\n+    // Rewrite doc comments\n+    match take_while_with_pred(context, attrs, |a| a.is_sugared_doc) {\n+        Some(sugared_docs) if !sugared_docs.is_empty() => {\n+            let snippet = sugared_docs\n+                .iter()\n+                .map(|a| context.snippet(a.span))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            return Some((\n+                sugared_docs.len(),\n+                rewrite_comment(&snippet, false, shape, context.config)?,\n+            ));\n+        }\n+        _ => (),\n+    }\n+    // Rewrite `#[derive(..)]`s.\n+    if context.config.merge_derives() {\n+        match take_while_with_pred(context, attrs, is_derive) {\n+            Some(derives) if !derives.is_empty() => {\n+                let mut derive_args = vec![];\n+                for derive in derives {\n+                    derive_args.append(&mut get_derive_args(context, derive)?);\n+                }\n+                return Some((\n+                    derives.len(),\n+                    format_derive(context, &derive_args, shape)?,\n+                ));\n+            }\n+            _ => (),\n+        }\n+    }\n+    // Rewrite the first attribute.\n+    Some((1, attrs[0].rewrite(context, shape)?))\n+}\n+\n+fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n+    // Look at before and after comment and see if there are any empty lines.\n+    let comment_begin = comment.chars().position(|c| c == '/');\n+    let len = comment_begin.unwrap_or_else(|| comment.len());\n+    let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n+    let mla = if comment_begin.is_none() {\n+        mlb\n+    } else {\n+        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n+        let len = comment_end.unwrap();\n+        comment\n+            .chars()\n+            .rev()\n+            .take(len)\n+            .filter(|c| *c == '\\n')\n+            .count() > 1\n+    };\n+    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n+}\n+\n impl<'a> Rewrite for [ast::Attribute] {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if self.is_empty() {\n             return Some(String::new());\n         }\n-        let mut result = String::with_capacity(128);\n-        let indent = shape.indent.to_string(context.config);\n-\n-        let mut derive_args = Vec::new();\n-\n-        let mut iter = self.iter().enumerate().peekable();\n-        let mut insert_new_line = true;\n-        let mut is_prev_sugared_doc = false;\n-        while let Some((i, a)) = iter.next() {\n-            let a_str = a.rewrite(context, shape)?;\n-\n-            // Write comments and blank lines between attributes.\n-            if i > 0 {\n-                let comment = context.snippet(mk_sp(self[i - 1].span.hi(), a.span.lo()));\n-                // This particular horror show is to preserve line breaks in between doc\n-                // comments. An alternative would be to force such line breaks to start\n-                // with the usual doc comment token.\n-                let (multi_line_before, multi_line_after) = if a.is_sugared_doc\n-                    || is_prev_sugared_doc\n-                {\n-                    // Look at before and after comment and see if there are any empty lines.\n-                    let comment_begin = comment.chars().position(|c| c == '/');\n-                    let len = comment_begin.unwrap_or_else(|| comment.len());\n-                    let mlb = comment.chars().take(len).filter(|c| *c == '\\n').count() > 1;\n-                    let mla = if comment_begin.is_none() {\n-                        mlb\n-                    } else {\n-                        let comment_end = comment.chars().rev().position(|c| !c.is_whitespace());\n-                        let len = comment_end.unwrap();\n-                        comment\n-                            .chars()\n-                            .rev()\n-                            .take(len)\n-                            .filter(|c| *c == '\\n')\n-                            .count() > 1\n-                    };\n-                    (mlb, mla)\n-                } else {\n-                    (false, false)\n-                };\n-\n-                let comment = recover_missing_comment_in_span(\n-                    mk_sp(self[i - 1].span.hi(), a.span.lo()),\n+        let (first_group_len, first_group_str) = rewrite_first_group_attrs(context, self, shape)?;\n+        if self.len() == 1 || first_group_len == self.len() {\n+            Some(first_group_str)\n+        } else {\n+            let rest_str = self[first_group_len..].rewrite(context, shape)?;\n+            let missing_span = mk_sp(\n+                self[first_group_len - 1].span.hi(),\n+                self[first_group_len].span.lo(),\n+            );\n+            // Preserve an empty line before/after doc comments.\n+            if self[0].is_sugared_doc || self[first_group_len].is_sugared_doc {\n+                let snippet = context.snippet(missing_span);\n+                let (mla, mlb) = has_newlines_before_after_comment(&snippet);\n+                let comment = ::comment::recover_missing_comment_in_span(\n+                    missing_span,\n                     shape.with_max_width(context.config),\n                     context,\n                     0,\n                 )?;\n-\n-                if !comment.is_empty() {\n-                    if multi_line_before {\n-                        result.push('\\n');\n-                    }\n-                    result.push_str(&comment);\n-                    result.push('\\n');\n-                    if multi_line_after {\n-                        result.push('\\n')\n-                    }\n-                } else if insert_new_line {\n-                    result.push('\\n');\n-                    if multi_line_after {\n-                        result.push('\\n')\n-                    }\n-                }\n-\n-                if derive_args.is_empty() {\n-                    result.push_str(&indent);\n-                }\n-\n-                insert_new_line = true;\n-            }\n-\n-            // Write the attribute itself.\n-            if context.config.merge_derives() {\n-                // If the attribute is `#[derive(...)]`, take the arguments.\n-                if let Some(mut args) = get_derive_args(context, a) {\n-                    derive_args.append(&mut args);\n-                    match iter.peek() {\n-                        // If the next attribute is `#[derive(...)]` as well, skip rewriting.\n-                        Some(&(_, next_attr)) if is_derive(next_attr) => insert_new_line = false,\n-                        // If not, rewrite the merged derives.\n-                        _ => {\n-                            result.push_str(&format_derive(context, &derive_args, shape)?);\n-                            derive_args.clear();\n-                        }\n-                    }\n+                let comment = if comment.is_empty() {\n+                    format!(\"\\n{}\", mlb)\n                 } else {\n-                    result.push_str(&a_str);\n-                }\n+                    format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                };\n+                Some(format!(\n+                    \"{}{}{}{}\",\n+                    first_group_str,\n+                    comment,\n+                    shape.indent.to_string(context.config),\n+                    rest_str\n+                ))\n             } else {\n-                result.push_str(&a_str);\n+                combine_strs_with_missing_comments(\n+                    context,\n+                    &first_group_str,\n+                    &rest_str,\n+                    missing_span,\n+                    shape,\n+                    false,\n+                )\n             }\n-\n-            is_prev_sugared_doc = a.is_sugared_doc;\n         }\n-        Some(result)\n     }\n }\n "}]}