{"sha": "55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1YjU0YTk5OWJjZGIwYjFjMWY0MmI2ZTFhZTY3MGJlYjA3MTcwODY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-01-31T19:41:29Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2018-01-31T19:41:29Z"}, "message": "Use a range to identify SIGSEGV in stack guards\n\nPreviously, the `guard::init()` and `guard::current()` functions were\nreturning a `usize` address representing the top of the stack guard,\nrespectively for the main thread and for spawned threads.  The `SIGSEGV`\nhandler on `unix` targets checked if a fault was within one page below\nthat address, if so reporting it as a stack overflow.\n\nNow `unix` targets report a `Range<usize>` representing the guard\nmemory, so it can cover arbitrary guard sizes.  Non-`unix` targets which\nalways return `None` for guards now do so with `Option<!>`, so they\ndon't pay any overhead.\n\nFor `linux-gnu` in particular, the previous guard upper-bound was\n`stackaddr + guardsize`, as the protected memory was *inside* the stack.\nThis was a glibc bug, and starting from 2.27 they are moving the guard\n*past* the end of the stack.  However, there's no simple way for us to\nknow where the guard page actually lies, so now we declare it as the\nwhole range of `stackaddr \u00b1 guardsize`, and any fault therein will be\ncalled a stack overflow.  This fixes #47863.", "tree": {"sha": "8aa51f05325480fb09568a50431cc48750d1c27f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aa51f05325480fb09568a50431cc48750d1c27f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "html_url": "https://github.com/rust-lang/rust/commit/55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2de8deb0927eb68dbc5986e1fbbd0a1359f8a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2de8deb0927eb68dbc5986e1fbbd0a1359f8a74", "html_url": "https://github.com/rust-lang/rust/commit/e2de8deb0927eb68dbc5986e1fbbd0a1359f8a74"}], "stats": {"total": 153, "additions": 89, "deletions": 64}, "files": [{"sha": "78a3b82546e3a93258d753b810c6846f45ad1da9", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -111,10 +111,11 @@ impl Drop for Thread {\n \n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n-    pub unsafe fn current() -> Option<usize> {\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> {\n         None\n     }\n-    pub unsafe fn init() -> Option<usize> {\n+    pub unsafe fn init() -> Option<Guard> {\n         None\n     }\n }"}, {"sha": "c4719a94c7e9dfa15252e216af2180c62b886a14", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -88,6 +88,7 @@ impl Thread {\n }\n \n pub mod guard {\n-    pub unsafe fn current() -> Option<usize> { None }\n-    pub unsafe fn init() -> Option<usize> { None }\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n }"}, {"sha": "40453f9b8a15b4e1dcdb2ddf64bb18332f33a734", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -57,9 +57,6 @@ mod imp {\n     use sys_common::thread_info;\n \n \n-    // This is initialized in init() and only read from after\n-    static mut PAGE_SIZE: usize = 0;\n-\n     #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n     unsafe fn siginfo_si_addr(info: *mut libc::siginfo_t) -> usize {\n         #[repr(C)]\n@@ -102,12 +99,12 @@ mod imp {\n                                     _data: *mut libc::c_void) {\n         use sys_common::util::report_overflow;\n \n-        let guard = thread_info::stack_guard().unwrap_or(0);\n+        let guard = thread_info::stack_guard().unwrap_or(0..0);\n         let addr = siginfo_si_addr(info);\n \n         // If the faulting address is within the guard page, then we print a\n         // message saying so and abort.\n-        if guard != 0 && guard - PAGE_SIZE <= addr && addr < guard {\n+        if guard.start <= addr && addr < guard.end {\n             report_overflow();\n             rtabort!(\"stack overflow\");\n         } else {\n@@ -123,8 +120,6 @@ mod imp {\n     static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n \n     pub unsafe fn init() {\n-        PAGE_SIZE = ::sys::os::page_size();\n-\n         let mut action: sigaction = mem::zeroed();\n         action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n         action.sa_sigaction = signal_handler as sighandler_t;"}, {"sha": "72cdb9440b8e7e3bdae6a51ebf554f0268dbdf10", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 70, "deletions": 45, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -205,8 +205,10 @@ impl Drop for Thread {\n           not(target_os = \"solaris\")))]\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n-    pub unsafe fn current() -> Option<usize> { None }\n-    pub unsafe fn init() -> Option<usize> { None }\n+    use ops::Range;\n+    pub type Guard = Range<usize>;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n }\n \n \n@@ -222,14 +224,43 @@ pub mod guard {\n     use libc;\n     use libc::mmap;\n     use libc::{PROT_NONE, MAP_PRIVATE, MAP_ANON, MAP_FAILED, MAP_FIXED};\n+    use ops::Range;\n     use sys::os;\n \n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"bitrig\",\n-              target_os = \"openbsd\",\n-              target_os = \"solaris\"))]\n+    // This is initialized in init() and only read from after\n+    static mut PAGE_SIZE: usize = 0;\n+\n+    pub type Guard = Range<usize>;\n+\n+    #[cfg(target_os = \"solaris\")]\n+    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n+        let mut current_stack: libc::stack_t = ::mem::zeroed();\n+        assert_eq!(libc::stack_getbounds(&mut current_stack), 0);\n+        Some(current_stack.ss_sp)\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n-        current().map(|s| s as *mut libc::c_void)\n+        let stackaddr = libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize -\n+             libc::pthread_get_stacksize_np(libc::pthread_self());\n+        Some(stackaddr as *mut libc::c_void)\n+    }\n+\n+    #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n+    unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n+        let mut current_stack: libc::stack_t = ::mem::zeroed();\n+        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n+                                             &mut current_stack), 0);\n+\n+        let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * PAGE_SIZE;\n+        let stackaddr = if libc::pthread_main_np() == 1 {\n+            // main thread\n+            current_stack.ss_sp as usize - current_stack.ss_size + extra\n+        } else {\n+            // new thread\n+            current_stack.ss_sp as usize - current_stack.ss_size\n+        };\n+        Some(stackaddr as *mut libc::c_void)\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n@@ -253,8 +284,9 @@ pub mod guard {\n         ret\n     }\n \n-    pub unsafe fn init() -> Option<usize> {\n-        let psize = os::page_size();\n+    pub unsafe fn init() -> Option<Guard> {\n+        PAGE_SIZE = os::page_size();\n+\n         let mut stackaddr = get_stack_start()?;\n \n         // Ensure stackaddr is page aligned! A parent process might\n@@ -263,9 +295,9 @@ pub mod guard {\n         // stackaddr < stackaddr + stacksize, so if stackaddr is not\n         // page-aligned, calculate the fix such that stackaddr <\n         // new_page_aligned_stackaddr < stackaddr + stacksize\n-        let remainder = (stackaddr as usize) % psize;\n+        let remainder = (stackaddr as usize) % PAGE_SIZE;\n         if remainder != 0 {\n-            stackaddr = ((stackaddr as usize) + psize - remainder)\n+            stackaddr = ((stackaddr as usize) + PAGE_SIZE - remainder)\n                 as *mut libc::c_void;\n         }\n \n@@ -280,60 +312,42 @@ pub mod guard {\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n             // trust that the kernel's own stack guard will work.\n-            Some(stackaddr as usize)\n+            let stackaddr = stackaddr as usize;\n+            Some(stackaddr - PAGE_SIZE..stackaddr)\n         } else {\n             // Reallocate the last page of the stack.\n             // This ensures SIGBUS will be raised on\n             // stack overflow.\n-            let result = mmap(stackaddr, psize, PROT_NONE,\n+            let result = mmap(stackaddr, PAGE_SIZE, PROT_NONE,\n                               MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n \n             if result != stackaddr || result == MAP_FAILED {\n                 panic!(\"failed to allocate a guard page\");\n             }\n \n+            let guardaddr = stackaddr as usize;\n             let offset = if cfg!(target_os = \"freebsd\") {\n                 2\n             } else {\n                 1\n             };\n \n-            Some(stackaddr as usize + offset * psize)\n+            Some(guardaddr..guardaddr + offset * PAGE_SIZE)\n         }\n     }\n \n-    #[cfg(target_os = \"solaris\")]\n-    pub unsafe fn current() -> Option<usize> {\n-        let mut current_stack: libc::stack_t = ::mem::zeroed();\n-        assert_eq!(libc::stack_getbounds(&mut current_stack), 0);\n-        Some(current_stack.ss_sp as usize)\n-    }\n-\n-    #[cfg(target_os = \"macos\")]\n-    pub unsafe fn current() -> Option<usize> {\n-        Some(libc::pthread_get_stackaddr_np(libc::pthread_self()) as usize -\n-             libc::pthread_get_stacksize_np(libc::pthread_self()))\n-    }\n-\n-    #[cfg(any(target_os = \"openbsd\", target_os = \"bitrig\"))]\n-    pub unsafe fn current() -> Option<usize> {\n-        let mut current_stack: libc::stack_t = ::mem::zeroed();\n-        assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(),\n-                                             &mut current_stack), 0);\n-\n-        let extra = if cfg!(target_os = \"bitrig\") {3} else {1} * os::page_size();\n-        Some(if libc::pthread_main_np() == 1 {\n-            // main thread\n-            current_stack.ss_sp as usize - current_stack.ss_size + extra\n-        } else {\n-            // new thread\n-            current_stack.ss_sp as usize - current_stack.ss_size\n-        })\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"bitrig\",\n+              target_os = \"openbsd\",\n+              target_os = \"solaris\"))]\n+    pub unsafe fn current() -> Option<Guard> {\n+        let stackaddr = get_stack_start()? as usize;\n+        Some(stackaddr - PAGE_SIZE..stackaddr)\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"freebsd\",\n               target_os = \"linux\", target_os = \"netbsd\", target_os = \"l4re\"))]\n-    pub unsafe fn current() -> Option<usize> {\n+    pub unsafe fn current() -> Option<Guard> {\n         let mut ret = None;\n         let mut attr: libc::pthread_attr_t = ::mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -352,12 +366,23 @@ pub mod guard {\n             assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr,\n                                                    &mut size), 0);\n \n+            let stackaddr = stackaddr as usize;\n             ret = if cfg!(target_os = \"freebsd\") {\n-                Some(stackaddr as usize - guardsize)\n+                // FIXME does freebsd really fault *below* the guard addr?\n+                let guardaddr = stackaddr - guardsize;\n+                Some(guardaddr - PAGE_SIZE..guardaddr)\n             } else if cfg!(target_os = \"netbsd\") {\n-                Some(stackaddr as usize)\n+                Some(stackaddr - guardsize..stackaddr)\n+            } else if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {\n+                // glibc used to include the guard area within the stack, as noted in the BUGS\n+                // section of `man pthread_attr_getguardsize`.  This has been corrected starting\n+                // with glibc 2.27, and in some distro backports, so the guard is now placed at the\n+                // end (below) the stack.  There's no easy way for us to know which we have at\n+                // runtime, so we'll just match any fault in the range right above or below the\n+                // stack base to call that fault a stack overflow.\n+                Some(stackaddr - guardsize..stackaddr + guardsize)\n             } else {\n-                Some(stackaddr as usize + guardsize)\n+                Some(stackaddr..stackaddr + guardsize)\n             };\n         }\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);"}, {"sha": "6a066509b492a6c1adac441367f233e1ed7c2726", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -43,6 +43,7 @@ impl Thread {\n }\n \n pub mod guard {\n-    pub unsafe fn current() -> Option<usize> { None }\n-    pub unsafe fn init() -> Option<usize> { None }\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n }"}, {"sha": "43abfbb1f645e9852974df82d7a26f2dc706787d", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -93,6 +93,7 @@ impl Thread {\n \n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n-    pub unsafe fn current() -> Option<usize> { None }\n-    pub unsafe fn init() -> Option<usize> { None }\n+    pub type Guard = !;\n+    pub unsafe fn current() -> Option<Guard> { None }\n+    pub unsafe fn init() -> Option<Guard> { None }\n }"}, {"sha": "6a2b6742367a5b4ce6032cfe943b9708fb9b9da9", "filename": "src/libstd/sys_common/thread_info.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55b54a999bcdb0b1c1f42b6e1ae670beb0717086/src%2Flibstd%2Fsys_common%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread_info.rs?ref=55b54a999bcdb0b1c1f42b6e1ae670beb0717086", "patch": "@@ -11,10 +11,11 @@\n #![allow(dead_code)] // stack_guard isn't used right now on all platforms\n \n use cell::RefCell;\n+use sys::thread::guard::Guard;\n use thread::Thread;\n \n struct ThreadInfo {\n-    stack_guard: Option<usize>,\n+    stack_guard: Option<Guard>,\n     thread: Thread,\n }\n \n@@ -38,11 +39,11 @@ pub fn current_thread() -> Option<Thread> {\n     ThreadInfo::with(|info| info.thread.clone())\n }\n \n-pub fn stack_guard() -> Option<usize> {\n-    ThreadInfo::with(|info| info.stack_guard).and_then(|o| o)\n+pub fn stack_guard() -> Option<Guard> {\n+    ThreadInfo::with(|info| info.stack_guard.clone()).and_then(|o| o)\n }\n \n-pub fn set(stack_guard: Option<usize>, thread: Thread) {\n+pub fn set(stack_guard: Option<Guard>, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_guard,"}]}