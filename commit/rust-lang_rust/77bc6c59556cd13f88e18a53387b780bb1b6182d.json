{"sha": "77bc6c59556cd13f88e18a53387b780bb1b6182d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YmM2YzU5NTU2Y2QxM2Y4OGUxOGE1MzM4N2I3ODBiYjFiNjE4MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T23:25:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T23:25:54Z"}, "message": "auto merge of #8218 : brson/rust/nogc, r=brson\n\nThese are both obsoleted by the forthcoming new GC.", "tree": {"sha": "8aa916f677cf8022615f0c01d22bcfd1f1a2b4bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aa916f677cf8022615f0c01d22bcfd1f1a2b4bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77bc6c59556cd13f88e18a53387b780bb1b6182d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77bc6c59556cd13f88e18a53387b780bb1b6182d", "html_url": "https://github.com/rust-lang/rust/commit/77bc6c59556cd13f88e18a53387b780bb1b6182d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77bc6c59556cd13f88e18a53387b780bb1b6182d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6f2364076ff0589463d88b14ac1c2b9e655998c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f2364076ff0589463d88b14ac1c2b9e655998c", "html_url": "https://github.com/rust-lang/rust/commit/d6f2364076ff0589463d88b14ac1c2b9e655998c"}, {"sha": "ea84c1fd693104a9f8d06ee0654d0a3bf470a32a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea84c1fd693104a9f8d06ee0654d0a3bf470a32a", "html_url": "https://github.com/rust-lang/rust/commit/ea84c1fd693104a9f8d06ee0654d0a3bf470a32a"}], "stats": {"total": 444, "additions": 0, "deletions": 444}, "files": [{"sha": "2e27f82f6f6efccc236b34253079245906b84376", "filename": "src/libstd/gc.rs", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/d6f2364076ff0589463d88b14ac1c2b9e655998c/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f2364076ff0589463d88b14ac1c2b9e655998c/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=d6f2364076ff0589463d88b14ac1c2b9e655998c", "patch": "@@ -1,358 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[doc(hidden)];\n-#[allow(non_uppercase_statics)];\n-\n-/*! Precise garbage collector\n-\n-The precise GC exposes two functions, gc and\n-cleanup_stack_for_failure. The gc function is the entry point to the\n-garbage collector itself. The cleanup_stack_for_failure is the entry\n-point for GC-based cleanup.\n-\n-Precise GC depends on changes to LLVM's GC which add support for\n-automatic rooting and addrspace-based metadata marking. Rather than\n-explicitly rooting pointers with LLVM's gcroot intrinsic, the GC\n-merely creates allocas for pointers, and allows an LLVM pass to\n-automatically infer roots based on the allocas present in a function\n-(and live at a given location). The compiler communicates the type of\n-the pointer to LLVM by setting the addrspace of the pointer type. The\n-compiler then emits a map from addrspace to tydesc, which LLVM then\n-uses to match pointers with their tydesc. The GC reads the metadata\n-table produced by LLVM, and uses it to determine which glue functions\n-to call to free objects on their respective heaps.\n-\n-GC-based cleanup is a replacement for landing pads which relies on the\n-GC infrastructure to find pointers on the stack to cleanup. Whereas\n-the normal GC needs to walk task-local heap allocations, the cleanup\n-code needs to walk exchange heap allocations and stack-allocations\n-with destructors.\n-\n-*/\n-\n-use cast;\n-use container::{Set, MutableSet};\n-use io;\n-use libc::{uintptr_t};\n-use option::{None, Option, Some};\n-use ptr;\n-use hashmap::HashSet;\n-use stackwalk::walk_stack;\n-use sys;\n-use unstable::intrinsics::{TyDesc};\n-\n-pub use stackwalk::Word;\n-\n-// Mirrors rust_stack.h stk_seg\n-pub struct StackSegment {\n-    prev: *StackSegment,\n-    next: *StackSegment,\n-    end: uintptr_t,\n-    // And other fields which we don't care about...\n-}\n-\n-pub mod rustrt {\n-    use stackwalk::Word;\n-    use super::StackSegment;\n-\n-    #[link_name = \"rustrt\"]\n-    extern {\n-        #[rust_stack]\n-        pub fn rust_gc_metadata() -> *Word;\n-\n-        pub fn rust_get_stack_segment() -> *StackSegment;\n-        pub fn rust_get_c_stack() -> *StackSegment;\n-    }\n-}\n-\n-unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n-    return ptr::offset(ptr, count as int) as *U;\n-}\n-\n-unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n-    let align = sys::min_align_of::<*T>();\n-    let ptr = ptr as uint;\n-    let ptr = (ptr + (align - 1)) & -align;\n-    return ptr as *T;\n-}\n-\n-unsafe fn get_safe_point_count() -> uint {\n-    let module_meta = rustrt::rust_gc_metadata();\n-    return *module_meta;\n-}\n-\n-struct SafePoint {\n-    sp_meta: *Word,\n-    fn_meta: *Word,\n-}\n-\n-// Returns the safe point metadata for the given program counter, if\n-// any.\n-unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n-    let module_meta = rustrt::rust_gc_metadata();\n-    let num_safe_points = *module_meta;\n-    let safe_points: *Word = bump(module_meta, 1);\n-\n-    if ptr::is_null(pc) {\n-        return None;\n-    }\n-\n-    // FIXME (#2997): Use binary rather than linear search.\n-    let mut spi = 0;\n-    while spi < num_safe_points {\n-        let sp: **Word = bump(safe_points, spi*3);\n-        let sp_loc = *sp;\n-        if sp_loc == pc {\n-            return Some(SafePoint {\n-                sp_meta: *bump(sp, 1),\n-                fn_meta: *bump(sp, 2),\n-            });\n-        }\n-        spi += 1;\n-    }\n-    return None;\n-}\n-\n-type Visitor<'self> = &'self fn(root: **Word, tydesc: *TyDesc);\n-\n-// Walks the list of roots for the given safe point, and calls visitor\n-// on each root.\n-unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    let fp_bytes = fp as *u8;\n-    let sp_meta = sp.sp_meta as *u32;\n-\n-    let num_stack_roots = *sp_meta as uint;\n-    let num_reg_roots = *ptr::offset(sp_meta, 1) as uint;\n-\n-    let stack_roots: *u32 = bump(sp_meta, 2);\n-    let reg_roots: *u8 = bump(stack_roots, num_stack_roots);\n-    let addrspaces: *Word = align_to_pointer(bump(reg_roots, num_reg_roots));\n-    let tydescs: ***TyDesc = bump(addrspaces, num_stack_roots);\n-\n-    // Stack roots\n-    let mut sri = 0;\n-    while sri < num_stack_roots {\n-        if *ptr::offset(addrspaces, sri as int) >= 1 {\n-            let root =\n-                ptr::offset(fp_bytes, *ptr::offset(stack_roots, sri as int) as int)\n-                as **Word;\n-            let tydescpp = ptr::offset(tydescs, sri as int);\n-            let tydesc = if ptr::is_not_null(tydescpp) &&\n-                ptr::is_not_null(*tydescpp) {\n-                **tydescpp\n-            } else {\n-                ptr::null()\n-            };\n-            visitor(root, tydesc);\n-        }\n-        sri += 1;\n-    }\n-\n-    // Register roots\n-    let mut rri = 0;\n-    while rri < num_reg_roots {\n-        if *ptr::offset(addrspaces, (num_stack_roots + rri) as int) == 1 {\n-            // FIXME(#2997): Need to find callee saved registers on the stack.\n-        }\n-        rri += 1;\n-    }\n-}\n-\n-unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    _walk_safe_point(fp, sp, visitor)\n-}\n-\n-// Is fp contained in segment?\n-unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n-    let begin = segment as Word;\n-    let end = (*segment).end as Word;\n-    let frame = fp as Word;\n-\n-    return begin <= frame && frame <= end;\n-}\n-\n-struct Segment { segment: *StackSegment, boundary: bool }\n-\n-// Find and return the segment containing the given frame pointer. At\n-// stack segment boundaries, returns true for boundary, so that the\n-// caller can do any special handling to identify where the correct\n-// return address is in the stack frame.\n-unsafe fn find_segment_for_frame(fp: *Word, segment: *StackSegment)\n-    -> Segment {\n-    // Check if frame is in either current frame or previous frame.\n-    let in_segment = is_frame_in_segment(fp, segment);\n-    let in_prev_segment = ptr::is_not_null((*segment).prev) &&\n-        is_frame_in_segment(fp, (*segment).prev);\n-\n-    // If frame is not in either segment, walk down segment list until\n-    // we find the segment containing this frame.\n-    if !in_segment && !in_prev_segment {\n-        let mut segment = segment;\n-        while ptr::is_not_null((*segment).next) &&\n-            is_frame_in_segment(fp, (*segment).next) {\n-            segment = (*segment).next;\n-        }\n-        return Segment {segment: segment, boundary: false};\n-    }\n-\n-    // If frame is in previous frame, then we're at a boundary.\n-    if !in_segment && in_prev_segment {\n-        return Segment {segment: (*segment).prev, boundary: true};\n-    }\n-\n-    // Otherwise, we're somewhere on the inside of the frame.\n-    return Segment {segment: segment, boundary: false};\n-}\n-\n-type Memory = uint;\n-\n-static task_local_heap: Memory = 1;\n-static exchange_heap:   Memory = 2;\n-static stack:           Memory = 4;\n-\n-static need_cleanup:    Memory = exchange_heap | stack;\n-\n-// Walks stack, searching for roots of the requested type, and passes\n-// each root to the visitor.\n-unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n-    let mut segment = rustrt::rust_get_stack_segment();\n-    let mut last_ret: *Word = ptr::null();\n-    // To avoid collecting memory used by the GC itself, skip stack\n-    // frames until past the root GC stack frame. The root GC stack\n-    // frame is marked by a sentinel, which is a box pointer stored on\n-    // the stack.\n-    let mut reached_sentinel = ptr::is_null(sentinel);\n-    do walk_stack |frame| {\n-        let pc = last_ret;\n-        let Segment {segment: next_segment, boundary: boundary} =\n-            find_segment_for_frame(frame.fp, segment);\n-        segment = next_segment;\n-        // Each stack segment is bounded by a morestack frame. The\n-        // morestack frame includes two return addresses, one for\n-        // morestack itself, at the normal offset from the frame\n-        // pointer, and then a second return address for the\n-        // function prologue (which called morestack after\n-        // determining that it had hit the end of the stack).\n-        // Since morestack itself takes two parameters, the offset\n-        // for this second return address is 3 greater than the\n-        // return address for morestack.\n-        let ret_offset = if boundary { 4 } else { 1 };\n-        last_ret = *ptr::offset(frame.fp, ret_offset as int) as *Word;\n-\n-        if !ptr::is_null(pc) {\n-\n-            let mut delay_reached_sentinel = reached_sentinel;\n-            let sp = is_safe_point(pc);\n-            match sp {\n-                Some(sp_info) => {\n-                    do walk_safe_point(frame.fp, sp_info) |root, tydesc| {\n-                        // Skip roots until we see the sentinel.\n-                        if !reached_sentinel && root == sentinel {\n-                            delay_reached_sentinel = true;\n-                        }\n-\n-                        // Skip null pointers, which can occur when a\n-                        // unique pointer has already been freed.\n-                        if reached_sentinel && !ptr::is_null(*root) {\n-                            if ptr::is_null(tydesc) {\n-                                // Root is a generic box.\n-                                let refcount = **root;\n-                                if mem | task_local_heap != 0 && refcount != -1 {\n-                                    visitor(root, tydesc);\n-                                } else if mem | exchange_heap != 0 && refcount == -1 {\n-                                    visitor(root, tydesc);\n-                                }\n-                            } else {\n-                                // Root is a non-immediate.\n-                                if mem | stack != 0 {\n-                                    visitor(root, tydesc);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                None => ()\n-            }\n-            reached_sentinel = delay_reached_sentinel;\n-        }\n-    }\n-}\n-\n-unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n-    _walk_gc_roots(mem, sentinel, visitor)\n-}\n-pub fn gc() {\n-    unsafe {\n-        // Abort when GC is disabled.\n-        if get_safe_point_count() == 0 {\n-            return;\n-        }\n-\n-        do walk_gc_roots(task_local_heap, ptr::null()) |_root, _tydesc| {\n-            // FIXME(#2997): Walk roots and mark them.\n-            io::stdout().write([46]); // .\n-        }\n-    }\n-}\n-\n-#[cfg(gc)]\n-fn expect_sentinel() -> bool { true }\n-\n-#[cfg(nogc)]\n-fn expect_sentinel() -> bool { false }\n-\n-// Entry point for GC-based cleanup. Walks stack looking for exchange\n-// heap and stack allocations requiring drop, and runs all\n-// destructors.\n-//\n-// This should only be called from fail!, as it will drop the roots\n-// which are *live* on the stack, rather than dropping those that are\n-// dead.\n-pub fn cleanup_stack_for_failure() {\n-    unsafe {\n-        // Abort when GC is disabled.\n-        if get_safe_point_count() == 0 {\n-            return;\n-        }\n-\n-        // Leave a sentinel on the stack to mark the current frame. The\n-        // stack walker will ignore any frames above the sentinel, thus\n-        // avoiding collecting any memory being used by the stack walker\n-        // itself.\n-        //\n-        // However, when core itself is not compiled with GC, then none of\n-        // the functions in core will have GC metadata, which means we\n-        // won't be able to find the sentinel root on the stack. In this\n-        // case, we can safely skip the sentinel since we won't find our\n-        // own stack roots on the stack anyway.\n-        let sentinel_box = ~0;\n-        let sentinel: **Word = if expect_sentinel() {\n-            cast::transmute(&sentinel_box)\n-        } else {\n-            ptr::null()\n-        };\n-\n-        let mut roots = HashSet::new();\n-        do walk_gc_roots(need_cleanup, sentinel) |root, tydesc| {\n-            // Track roots to avoid double frees.\n-            if !roots.contains(&*root) {\n-                roots.insert(*root);\n-\n-                if ptr::is_null(tydesc) {\n-                    // FIXME #4420: Destroy this box\n-                    // FIXME #4330: Destroy this box\n-                } else {\n-                    ((*tydesc).drop_glue)(*root as *i8);\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "cc516fb559ea8babc701a824cdee94641073ef8f", "filename": "src/libstd/stackwalk.rs", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d6f2364076ff0589463d88b14ac1c2b9e655998c/src%2Flibstd%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f2364076ff0589463d88b14ac1c2b9e655998c/src%2Flibstd%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstackwalk.rs?ref=d6f2364076ff0589463d88b14ac1c2b9e655998c", "patch": "@@ -1,80 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use cast::transmute;\n-use unstable::intrinsics;\n-\n-pub type Word = uint;\n-\n-pub struct Frame {\n-    fp: *Word\n-}\n-\n-pub fn Frame(fp: *Word) -> Frame {\n-    Frame {\n-        fp: fp\n-    }\n-}\n-\n-pub fn walk_stack(visit: &fn(Frame)) {\n-\n-    debug!(\"beginning stack walk\");\n-\n-    do frame_address |frame_pointer| {\n-        let mut frame_address: *Word = unsafe {\n-            transmute(frame_pointer)\n-        };\n-        loop {\n-            let fr = Frame(frame_address);\n-\n-            debug!(\"frame: %x\", unsafe { transmute(fr.fp) });\n-            visit(fr);\n-\n-            unsafe {\n-                let next_fp: **Word = transmute(frame_address);\n-                frame_address = *next_fp;\n-                if *frame_address == 0u {\n-                    debug!(\"encountered task_start_wrapper. ending walk\");\n-                    // This is the task_start_wrapper_frame. There is\n-                    // no stack beneath it and it is a foreign frame.\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_simple() {\n-    do walk_stack |_frame| {\n-    }\n-}\n-\n-#[test]\n-fn test_simple_deep() {\n-    fn run(i: int) {\n-        if i == 0 { return }\n-\n-        do walk_stack |_frame| {\n-            // Would be nice to test something here...\n-        }\n-        run(i - 1);\n-    }\n-\n-    run(10);\n-}\n-\n-fn frame_address(f: &fn(x: *u8)) {\n-    unsafe {\n-        intrinsics::frame_address(f)\n-    }\n-}"}, {"sha": "568709c89da73d73039ac9eb042b346803382671", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=77bc6c59556cd13f88e18a53387b780bb1b6182d", "patch": "@@ -170,7 +170,6 @@ pub mod local_data;\n \n /* Runtime and platform support */\n \n-pub mod gc;\n pub mod libc;\n pub mod os;\n pub mod path;\n@@ -196,7 +195,6 @@ pub mod unstable;\n mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n-mod stackwalk;\n \n // XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub."}, {"sha": "9d853087123e831618df134020fe20fba4a118b9", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77bc6c59556cd13f88e18a53387b780bb1b6182d/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=77bc6c59556cd13f88e18a53387b780bb1b6182d", "patch": "@@ -13,7 +13,6 @@\n #[allow(missing_doc)];\n \n use cast;\n-use gc;\n use io;\n use libc;\n use libc::{c_char, size_t};\n@@ -147,7 +146,6 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     match context {\n         OldTaskContext => {\n             unsafe {\n-                gc::cleanup_stack_for_failure();\n                 rustrt::rust_upcall_fail(msg, file, line);\n                 cast::transmute(())\n             }\n@@ -180,8 +178,6 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                              msg, file, line as int);\n                 }\n \n-                gc::cleanup_stack_for_failure();\n-\n                 let task = Local::unsafe_borrow::<Task>();\n                 if (*task).unwinder.unwinding {\n                     rtabort!(\"unwinding again\");"}]}