{"sha": "402d946868c4d775eebd29b4e13d3897f5cc2d47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMmQ5NDY4NjhjNGQ3NzVlZWJkMjliNGUxM2QzODk3ZjVjYzJkNDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-11T15:03:10Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-11T15:03:10Z"}, "message": "rustc: fix fallout from removing ast::Sigil and use ty::TraitStore in ty::ClosureTy.", "tree": {"sha": "643790e7b2b4df64ec6e87da03b35606f2a3515e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/643790e7b2b4df64ec6e87da03b35606f2a3515e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/402d946868c4d775eebd29b4e13d3897f5cc2d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/402d946868c4d775eebd29b4e13d3897f5cc2d47", "html_url": "https://github.com/rust-lang/rust/commit/402d946868c4d775eebd29b4e13d3897f5cc2d47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/402d946868c4d775eebd29b4e13d3897f5cc2d47/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9351c01b3576f32206b80b32a03b66be66f18b39", "url": "https://api.github.com/repos/rust-lang/rust/commits/9351c01b3576f32206b80b32a03b66be66f18b39", "html_url": "https://github.com/rust-lang/rust/commit/9351c01b3576f32206b80b32a03b66be66f18b39"}], "stats": {"total": 599, "additions": 249, "deletions": 350}, "files": [{"sha": "dd604af40ec52dd6d57902643282b2de93a834db", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -260,8 +260,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n         match t.node {\n-            ast::TyClosure(closure) if closure.onceness == ast::Once &&\n-                    closure.sigil != ast::OwnedSigil => {\n+            ast::TyClosure(closure, _) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");"}, {"sha": "5df5b718f3e76b163d44d714a605b9cc4f5500ee", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -137,15 +137,6 @@ pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx:\n     parse_substs(&mut st, conv)\n }\n \n-fn parse_sigil(st: &mut PState) -> ast::Sigil {\n-    match next(st) {\n-        '@' => ast::ManagedSigil,\n-        '~' => ast::OwnedSigil,\n-        '&' => ast::BorrowedSigil,\n-        c => st.tcx.sess.bug(format!(\"parse_sigil(): bad input '{}'\", c))\n-    }\n-}\n-\n fn parse_vstore<M>(st: &mut PState, conv: conv_did,\n                    parse_mut: |&mut PState| -> M) -> ty::Vstore<M> {\n     assert_eq!(next(st), '/');\n@@ -476,17 +467,15 @@ fn parse_onceness(c: char) -> ast::Onceness {\n }\n \n fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n-    let sigil = parse_sigil(st);\n     let fn_style = parse_fn_style(next(st));\n     let onceness = parse_onceness(next(st));\n-    let region = parse_region(st, |x,y| conv(x,y));\n+    let store = parse_trait_store(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n         fn_style: fn_style,\n-        sigil: sigil,\n         onceness: onceness,\n-        region: region,\n+        store: store,\n         bounds: bounds.builtin_bounds,\n         sig: sig\n     }"}, {"sha": "53fe1c19d8ff948c60bc359ad29a5aff20f029a3", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -327,14 +327,6 @@ fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n     }\n }\n \n-fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n-    match sigil {\n-        ManagedSigil => mywrite!(w, \"@\"),\n-        OwnedSigil => mywrite!(w, \"~\"),\n-        BorrowedSigil => mywrite!(w, \"&\"),\n-    }\n-}\n-\n fn enc_fn_style(w: &mut MemWriter, p: FnStyle) {\n     match p {\n         NormalFn => mywrite!(w, \"n\"),\n@@ -363,10 +355,9 @@ pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n }\n \n fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n-    enc_sigil(w, ft.sigil);\n     enc_fn_style(w, ft.fn_style);\n     enc_onceness(w, ft.onceness);\n-    enc_region(w, cx, ft.region);\n+    enc_trait_store(w, cx, ft.store);\n     let bounds = ty::ParamBounds {builtin_bounds: ft.bounds,\n                                   trait_bounds: Vec::new()};\n     enc_bounds(w, cx, &bounds);"}, {"sha": "858e873f7ed3592e83d2c3a68d13f8dc6394dfd9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -897,10 +897,9 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AutoAddEnv(region, sigil) => {\n-                    this.emit_enum_variant(\"AutoAddEnv\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| region.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| sigil.encode(this))\n+                ty::AutoAddEnv(store) => {\n+                    this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n+                        this.emit_enum_variant_arg(0, |this| store.encode(this))\n                     })\n                 }\n \n@@ -1270,12 +1269,10 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let region: ty::Region =\n+                        let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n-                        let sigil: ast::Sigil =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n-                        ty:: AutoAddEnv(region.tr(xcx), sigil)\n+                        ty:: AutoAddEnv(store.tr(xcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef ="}, {"sha": "21e68e2724fc327d4f54c1fffd79982d4b09374a", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -620,7 +620,7 @@ impl<'a> BorrowckCtxt<'a> {\n         fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msg: &'static str)\n                           -> &'static str {\n             match ty::get(ty).sty {\n-                ty::ty_closure(ref cty) if cty.sigil == ast::BorrowedSigil =>\n+                ty::ty_closure(~ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) =>\n                     \"a non-copyable stack closure (capture it in a new closure, \\\n                      e.g. `|x| f(x)`, to override)\",\n                 _ if ty::type_moves_by_default(tcx, ty) =>"}, {"sha": "a152e06eb06aafd2cf193dedebb9286b8e9c4ff0", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -197,27 +197,13 @@ fn with_appropriate_checker(cx: &Context,\n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_closure(~ty::ClosureTy {\n-            sigil: OwnedSigil,\n-            bounds: bounds,\n-            ..\n-        }) => {\n-            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n-        }\n-        ty::ty_closure(~ty::ClosureTy {\n-            sigil: ManagedSigil,\n-            ..\n-        }) => {\n-            // can't happen\n-            fail!(\"internal error: saw closure with managed sigil (@fn)\");\n-        }\n+            store: ty::UniqTraitStore, bounds, ..\n+        }) => b(|cx, fv| check_for_uniq(cx, fv, bounds)),\n+\n         ty::ty_closure(~ty::ClosureTy {\n-            sigil: BorrowedSigil,\n-            bounds: bounds,\n-            region: region,\n-            ..\n-        }) => {\n-            b(|cx, fv| check_for_block(cx, fv, bounds, region))\n-        }\n+            store: ty::RegionTraitStore(region, _), bounds, ..\n+        }) => b(|cx, fv| check_for_block(cx, fv, bounds, region)),\n+\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n         }"}, {"sha": "e376f85ff6db030934292ae3fa46568749e2218e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -919,10 +919,8 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n                 }\n                 ty::ty_uniq(_) | ty::ty_str(ty::VstoreUniq) |\n                 ty::ty_vec(_, ty::VstoreUniq) |\n-                ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) => {\n-                    n_uniq += 1;\n-                }\n-                ty::ty_closure(ref c) if c.sigil == ast::OwnedSigil => {\n+                ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n+                ty::ty_closure(~ty::ClosureTy { store: ty::UniqTraitStore, .. }) => {\n                     n_uniq += 1;\n                 }\n "}, {"sha": "dcab1d9a0da1a4296466f7bdc0861237d4d6e4fc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -172,7 +172,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_trait(~ty::TyTrait { store: ty::UniqTraitStore, .. }) |\n         ty::ty_vec(_, ty::VstoreUniq) |\n         ty::ty_str(ty::VstoreUniq) |\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n             Some(deref_ptr(OwnedPtr))\n         }\n \n@@ -187,8 +187,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         }\n \n         ty::ty_str(ty::VstoreSlice(r, ())) |\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                      region: r, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(r, _), ..}) => {\n             Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n@@ -540,15 +539,14 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n                       // Decide whether to use implicit reference or by copy/move\n                       // capture for the upvar. This, combined with the onceness,\n                       // determines whether the closure can move out of it.\n-                      let var_is_refd = match (closure_ty.sigil, closure_ty.onceness) {\n+                      let var_is_refd = match (closure_ty.store, closure_ty.onceness) {\n                           // Many-shot stack closures can never move out.\n-                          (ast::BorrowedSigil, ast::Many) => true,\n+                          (ty::RegionTraitStore(..), ast::Many) => true,\n                           // 1-shot stack closures can move out.\n-                          (ast::BorrowedSigil, ast::Once) => false,\n+                          (ty::RegionTraitStore(..), ast::Once) => false,\n                           // Heap closures always capture by copy/move, and can\n                           // move out if they are once.\n-                          (ast::OwnedSigil, _) |\n-                          (ast::ManagedSigil, _) => false,\n+                          (ty::UniqTraitStore, _) => false,\n \n                       };\n                       if var_is_refd {"}, {"sha": "2029df38b10015e17c2d9bd96624f0e93aed4385", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -650,30 +650,30 @@ impl<'a> VisitContext<'a> {\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        let v = if sigil == BorrowedSigil {\n-            // || captures everything by ref\n-            freevars.iter()\n-                    .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n-                    .collect()\n-        } else {\n-            // @fn() and ~fn() capture by copy or by move depending on type\n-            freevars.iter()\n-                    .map(|fvar| {\n-                let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n-                let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n-                debug!(\"fvar_def_id={:?} fvar_ty={}\",\n-                       fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n-                let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n-                    CapMove\n-                } else {\n-                    CapCopy\n-                };\n-                CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n-\n+        Rc::new(match ty::ty_closure_store(fn_ty) {\n+            ty::RegionTraitStore(..) => {\n+                // || captures everything by ref\n+                freevars.iter()\n+                        .map(|fvar| CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef})\n+                        .collect()\n+            }\n+            ty::UniqTraitStore => {\n+                // proc captures by copy or by move depending on type\n+                freevars.iter()\n+                        .map(|fvar| {\n+                    let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n+                    let fvar_ty = ty::node_id_to_type(self.tcx, fvar_def_id);\n+                    debug!(\"fvar_def_id={:?} fvar_ty={}\",\n+                        fvar_def_id, ppaux::ty_to_str(self.tcx, fvar_ty));\n+                    let mode = if ty::type_moves_by_default(self.tcx, fvar_ty) {\n+                        CapMove\n+                    } else {\n+                        CapCopy\n+                    };\n+                    CaptureVar {def: fvar.def, span: fvar.span, mode:mode}\n                 }).collect()\n-        };\n-        Rc::new(v)\n+            }\n+        })\n     }\n }"}, {"sha": "e5b13adb4d0dc9d827f1753b47677f605f74db0a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -4274,7 +4274,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            TyClosure(c) => {\n+            TyClosure(c, _) | TyProc(c) => {\n                 c.bounds.as_ref().map(|bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);"}, {"sha": "130c93ac51e91e8c4152cf63c583525720878021", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -112,7 +112,9 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n \n     fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n         match ty.node {\n-            ast::TyClosure(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n+            ast::TyClosure(c, _) | ast::TyProc(c) => {\n+                push_fn_scope(self, ty, scope, &c.lifetimes);\n+            }\n             ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n             _ => visit::walk_ty(self, ty, scope),\n         }"}, {"sha": "60d6e6850f7ead745dbc1917bc1c0f61bb7164a5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -260,7 +260,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, has_env: bool,\n             // noalias because the actual object pointer is nested.\n             ty::ty_uniq(..) | // ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n             ty::ty_vec(_, ty::VstoreUniq) | ty::ty_str(ty::VstoreUniq) |\n-            ty::ty_closure(~ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n+            ty::ty_closure(~ty::ClosureTy {store: ty::UniqTraitStore, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n                 }"}, {"sha": "9cdc98bab5c96ab7e6fe21fedb48c197a900c5eb", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -158,24 +158,21 @@ fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n }\n \n fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n-                     sigil: ast::Sigil,\n+                     store: ty::TraitStore,\n                      cdata_ty: ty::t)\n                      -> Result<'a> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n     let tcx = bcx.tcx();\n \n     // Allocate and initialize the box:\n-    match sigil {\n-        ast::ManagedSigil => {\n-            tcx.sess.bug(\"trying to trans allocation of @fn\")\n-        }\n-        ast::OwnedSigil => {\n+    match store {\n+        ty::UniqTraitStore => {\n             let ty = type_of(bcx.ccx(), cdata_ty);\n             let size = llsize_of(bcx.ccx(), ty);\n             // we treat proc as @ here, which isn't ideal\n             malloc_raw_dyn_managed(bcx, cdata_ty, ClosureExchangeMallocFnLangItem, size)\n         }\n-        ast::BorrowedSigil => {\n+        ty::RegionTraitStore(..) => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n             let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n             rslt(bcx, llbox)\n@@ -196,7 +193,7 @@ pub struct ClosureResult<'a> {\n pub fn store_environment<'a>(\n                          bcx: &'a Block<'a>,\n                          bound_values: Vec<EnvValue> ,\n-                         sigil: ast::Sigil)\n+                         store: ty::TraitStore)\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n@@ -220,7 +217,7 @@ pub fn store_environment<'a>(\n     }\n \n     // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, store, cdata_ty);\n \n     let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n     debug!(\"tuplify_box_ty = {}\", ty_to_str(tcx, cbox_ty));\n@@ -254,7 +251,7 @@ pub fn store_environment<'a>(\n // collects the upvars and packages them up for store_environment.\n fn build_closure<'a>(bcx0: &'a Block<'a>,\n                      cap_vars: &[moves::CaptureVar],\n-                     sigil: ast::Sigil)\n+                     store: ty::TraitStore)\n                      -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::build_closure\");\n \n@@ -268,7 +265,11 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert_eq!(sigil, ast::BorrowedSigil);\n+                let is_region_closure = match store {\n+                    ty::RegionTraitStore(..) => true,\n+                    ty::UniqTraitStore => false\n+                };\n+                assert!(is_region_closure);\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n@@ -283,15 +284,15 @@ fn build_closure<'a>(bcx0: &'a Block<'a>,\n         }\n     }\n \n-    return store_environment(bcx, env_vals, sigil);\n+    store_environment(bcx, env_vals, store)\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n-                        sigil: ast::Sigil) -> &'a Block<'a> {\n+                        store: ty::TraitStore) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"closure::load_environment\");\n \n     // Don't bother to create the block if there's nothing to load\n@@ -316,9 +317,9 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n     let mut i = 0u;\n     for cap_var in cap_vars.iter() {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-        match sigil {\n-            ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }\n-            ast::ManagedSigil | ast::OwnedSigil => {}\n+        match store {\n+            ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n+            ty::UniqTraitStore => {}\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n \n@@ -331,7 +332,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n                 cdata_ty,\n                 env_pointer_alloca,\n                 i,\n-                sigil,\n+                store,\n                 cap_var.span);\n         }\n \n@@ -349,7 +350,7 @@ fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef)\n \n pub fn trans_expr_fn<'a>(\n                      bcx: &'a Block<'a>,\n-                     sigil: ast::Sigil,\n+                     store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      id: ast::NodeId,\n@@ -359,7 +360,7 @@ pub fn trans_expr_fn<'a>(\n      *\n      * Translates the body of a closure expression.\n      *\n-     * - `sigil`\n+     * - `store`\n      * - `decl`\n      * - `body`\n      * - `id`: The id of the closure expression.\n@@ -399,11 +400,11 @@ pub fn trans_expr_fn<'a>(\n \n     let cap_vars = ccx.maps.capture_map.borrow().get_copy(&id);\n     let ClosureResult {llbox, cdata_ty, bcx} =\n-        build_closure(bcx, cap_vars.as_slice(), sigil);\n+        build_closure(bcx, cap_vars.as_slice(), store);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, cap_vars.as_slice(), sigil));\n+                  |bcx| load_environment(bcx, cdata_ty, cap_vars.as_slice(), store));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx"}, {"sha": "e0a54234fca7e0fedba76f903cb396e3a1ea556b", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -191,7 +191,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         None => { }\n         Some(adj) => {\n             match *adj {\n-                ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n+                ty::AutoAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n@@ -200,13 +200,11 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    is_local);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AutoAddEnv(ref r, ref s) => {\n+                ty::AutoAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n-                                format!(\"unexpected static function: region \\\n-                                         {:?} sigil {:?}\",\n-                                        *r,\n-                                        *s))\n+                                format!(\"unexpected static function: {:?}\",\n+                                        store))\n                 }\n                 ty::AutoObject(..) => {\n                     cx.sess()"}, {"sha": "ae58e153258ef467d9726aab94a31858b37c623e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -394,7 +394,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n                                     env_data_type: ty::t,\n                                     env_pointer: ValueRef,\n                                     env_index: uint,\n-                                    closure_sigil: ast::Sigil,\n+                                    closure_store: ty::TraitStore,\n                                     span: Span) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n@@ -443,11 +443,11 @@ pub fn create_captured_var_metadata(bcx: &Block,\n          llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref())]\n     };\n \n-    let address_op_count = match closure_sigil {\n-        ast::BorrowedSigil => {\n+    let address_op_count = match closure_store {\n+        ty::RegionTraitStore(..) => {\n             address_operations.len()\n         }\n-        ast::ManagedSigil | ast::OwnedSigil => {\n+        ty::UniqTraitStore => {\n             address_operations.len() - 1\n         }\n     };"}, {"sha": "03540aaee5681d1f6d1fd626f4ce46bbdbb05fca", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -731,10 +731,10 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         ast::ExprFnBlock(decl, body) |\n         ast::ExprProc(decl, body) => {\n             let expr_ty = expr_ty(bcx, expr);\n-            let sigil = ty::ty_closure_sigil(expr_ty);\n+            let store = ty::ty_closure_store(expr_ty);\n             debug!(\"translating block function {} with type {}\",\n                    expr_to_str(expr), expr_ty.repr(tcx));\n-            closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n+            closure::trans_expr_fn(bcx, store, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n             callee::trans_call(bcx, expr, f, callee::ArgExprs(args.as_slice()), dest)"}, {"sha": "98e135c27c4862fdd0935873dd7f2db7fe6696fe", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -323,7 +323,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 bcx\n             })\n         }\n-        ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => {\n+        ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n             let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();"}, {"sha": "3fe494ad41b0eca83ddc9d5bab76670bb1982d81", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -218,7 +218,10 @@ impl<'a> Reflector<'a> {\n           // FIXME (#4809): visitor should break out bare fns from other fns\n           ty::ty_closure(ref fty) => {\n             let pureval = ast_fn_style_constant(fty.fn_style);\n-            let sigilval = ast_sigil_constant(fty.sigil);\n+            let sigilval = match fty.store {\n+                ty::UniqTraitStore => 2u,\n+                ty::RegionTraitStore(..) => 4u,\n+            };\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = vec!(self.c_uint(pureval),\n                           self.c_uint(sigilval),\n@@ -397,14 +400,6 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n     return final;\n }\n \n-pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n-    match sigil {\n-        ast::OwnedSigil => 2u,\n-        ast::ManagedSigil => 3u,\n-        ast::BorrowedSigil => 4u,\n-    }\n-}\n-\n pub fn ast_fn_style_constant(fn_style: ast::FnStyle) -> uint {\n     match fn_style {\n         ast::UnsafeFn => 1u,"}, {"sha": "a59be10af53359e917c92d4069e68eb5250b45f9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -214,7 +214,7 @@ pub enum Variance {\n }\n \n pub enum AutoAdjustment {\n-    AutoAddEnv(ty::Region, ast::Sigil),\n+    AutoAddEnv(ty::TraitStore),\n     AutoDerefRef(AutoDerefRef),\n     AutoObject(ty::TraitStore,\n                ty::BuiltinBounds,\n@@ -430,9 +430,8 @@ pub struct BareFnTy {\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct ClosureTy {\n     pub fn_style: ast::FnStyle,\n-    pub sigil: ast::Sigil,\n     pub onceness: ast::Onceness,\n-    pub region: Region,\n+    pub store: TraitStore,\n     pub bounds: BuiltinBounds,\n     pub sig: FnSig,\n }\n@@ -801,7 +800,7 @@ pub enum type_err {\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n-    terr_sigil_mismatch(expected_found<ast::Sigil>),\n+    terr_sigil_mismatch(expected_found<TraitStore>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1204,11 +1203,13 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_param(_) => flags |= has_params as uint,\n       &ty_infer(_) => flags |= needs_infer as uint,\n       &ty_self(_) => flags |= has_self as uint,\n-      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n-      &ty_trait(~ty::TyTrait { ref substs, .. }) => {\n+      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n+          flags |= sflags(substs);\n+      }\n+      &ty_trait(~ty::TyTrait { ref substs, store, .. }) => {\n           flags |= sflags(substs);\n-          match st {\n-              ty_trait(~ty::TyTrait { store: RegionTraitStore(r, _), .. }) => {\n+          match store {\n+              RegionTraitStore(r, _) => {\n                     flags |= rflags(r);\n                 }\n               _ => {}\n@@ -1232,7 +1233,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         flags &= !(has_ty_bot as uint);\n       }\n       &ty_closure(ref f) => {\n-        flags |= rflags(f.region);\n+        match f.store {\n+            RegionTraitStore(r, _) => {\n+                flags |= rflags(r);\n+            }\n+            _ => {}\n+        }\n         for a in f.sig.inputs.iter() { flags |= get(*a).flags; }\n         flags |= get(f.sig.output).flags;\n         // T -> _|_ is *not* _|_ !\n@@ -2217,17 +2223,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = match cty.sigil {\n-            ast::BorrowedSigil =>\n-                object_contents(cx, RegionTraitStore(cty.region, MutMutable), cty.bounds),\n-            ast::OwnedSigil => object_contents(cx, UniqTraitStore, cty.bounds),\n-            ast::ManagedSigil => unreachable!()\n-        };\n-\n-        // FIXME(#3569): This borrowed_contents call should be taken care of in\n-        // object_contents, after ~Traits and @Traits can have region bounds too.\n-        // This one here is redundant for &fns but important for ~fns and @fns.\n-        let rt = borrowed_contents(cty.region, ast::MutImmutable);\n+        let st = object_contents(cx, cty.store, cty.bounds);\n \n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n@@ -2236,7 +2232,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             ast::Many => TC::None,\n         };\n \n-        st | rt | ot\n+        st | ot\n     }\n \n     fn object_contents(cx: &ctxt,\n@@ -2696,11 +2692,11 @@ pub fn ty_fn_args(fty: t) -> Vec<t> {\n     }\n }\n \n-pub fn ty_closure_sigil(fty: t) -> Sigil {\n+pub fn ty_closure_store(fty: t) -> TraitStore {\n     match get(fty).sty {\n-        ty_closure(ref f) => f.sigil,\n+        ty_closure(ref f) => f.store,\n         ref s => {\n-            fail!(\"ty_closure_sigil() called on non-closure type: {:?}\", s)\n+            fail!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n         }\n     }\n }\n@@ -2838,15 +2834,14 @@ pub fn adjust_ty(cx: &ctxt,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoAddEnv(r, s) => {\n+                AutoAddEnv(store) => {\n                     match ty::get(unadjusted_ty).sty {\n                         ty::ty_bare_fn(ref b) => {\n                             ty::mk_closure(\n                                 cx,\n                                 ty::ClosureTy {fn_style: b.fn_style,\n-                                               sigil: s,\n                                                onceness: ast::Many,\n-                                               region: r,\n+                                               store: store,\n                                                bounds: ty::AllBuiltinBounds(),\n                                                sig: b.sig.clone()})\n                         }\n@@ -2960,8 +2955,7 @@ pub fn adjust_ty(cx: &ctxt,\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n-                    sigil: BorrowedSigil,\n-                    region: r,\n+                    store: RegionTraitStore(r, ast::MutMutable),\n                     ..(**fty).clone()\n                 })\n             }\n@@ -4278,20 +4272,6 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n     }\n }\n \n-// Determine what the style to check a nested function under\n-pub fn determine_inherited_style(parent: (ast::FnStyle, ast::NodeId),\n-                                  child: (ast::FnStyle, ast::NodeId),\n-                                  child_sigil: ast::Sigil)\n-                                    -> (ast::FnStyle, ast::NodeId) {\n-    // If the closure is a stack closure and hasn't had some non-standard\n-    // style inferred for it, then check it under its parent's style.\n-    // Otherwise, use its own\n-    match child_sigil {\n-        ast::BorrowedSigil if child.val0() == ast::NormalFn => parent,\n-        _ => child\n-    }\n-}\n-\n // Iterate over a type parameter's bounded traits and any supertraits\n // of those traits, ignoring kinds.\n // Here, the supertraits are the transitive closure of the supertrait\n@@ -4640,10 +4620,16 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_closure(ref c) => {\n                 byte!(15);\n                 hash!(c.fn_style);\n-                hash!(c.sigil);\n                 hash!(c.onceness);\n                 hash!(c.bounds);\n-                region(&mut state, c.region);\n+                match c.store {\n+                    UniqTraitStore => byte!(0),\n+                    RegionTraitStore(r, m) => {\n+                        byte!(1)\n+                        region(&mut state, r);\n+                        assert_eq!(m, ast::MutMutable);\n+                    }\n+                }\n             }\n             ty_trait(~ty::TyTrait { def_id: d, store, bounds, .. }) => {\n                 byte!(17);"}, {"sha": "840f741badb7a9576b5efddac83681c9cd9d573c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -56,10 +56,9 @@ pub trait TypeFolder {\n                        fty: &ty::ClosureTy)\n                        -> ty::ClosureTy {\n         ty::ClosureTy {\n-            region: self.fold_region(fty.region),\n+            store: self.fold_trait_store(fty.store),\n             sig: self.fold_sig(&fty.sig),\n             fn_style: fty.fn_style,\n-            sigil: fty.sigil,\n             onceness: fty.onceness,\n             bounds: fty.bounds,\n         }"}, {"sha": "99f10395437a5ee0bbd9f62e5caf254adcebb5ff", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -112,7 +112,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n+pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     default_span: Span,\n@@ -516,33 +516,42 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n                                                   bf.abi, bf.decl))\n             }\n-            ast::TyClosure(ref f) => {\n-                if f.sigil == ast::ManagedSigil {\n-                    tcx.sess.span_err(ast_ty.span,\n-                                      \"managed closures are not supported\");\n-                }\n+            ast::TyClosure(ref f, ref region) => {\n+\n+                // resolve the function bound region in the original region\n+                // scope `rscope`, not the scope of the function parameters\n+                let bound_region = opt_ast_region_to_region(this, rscope,\n+                                                            ast_ty.span, region);\n+\n+                let store = ty::RegionTraitStore(bound_region, ast::MutMutable);\n+\n+                // Use corresponding trait store to figure out default bounds\n+                // if none were specified.\n+                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, store);\n \n-                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, match f.sigil {\n-                        // Use corresponding trait store to figure out default bounds\n-                        // if none were specified.\n-                        ast::BorrowedSigil => {\n-                            // dummy region\n-                            ty::RegionTraitStore(ty::ReEmpty, ast::MutMutable)\n-                        }\n-                        ast::OwnedSigil    => ty::UniqTraitStore,\n-                        ast::ManagedSigil  => return ty::mk_err()\n-                    });\n                 let fn_decl = ty_of_closure(this,\n-                                            rscope,\n                                             ast_ty.id,\n-                                            f.sigil,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n-                                            &f.region,\n+                                            store,\n                                             f.decl,\n-                                            None,\n-                                            ast_ty.span);\n+                                            None);\n+                ty::mk_closure(tcx, fn_decl)\n+            }\n+            ast::TyProc(ref f) => {\n+                // Use corresponding trait store to figure out default bounds\n+                // if none were specified.\n+                let bounds = conv_builtin_bounds(this.tcx(), &f.bounds, ty::UniqTraitStore);\n+\n+                let fn_decl = ty_of_closure(this,\n+                                            ast_ty.id,\n+                                            f.fn_style,\n+                                            f.onceness,\n+                                            bounds,\n+                                            ty::UniqTraitStore,\n+                                            f.decl,\n+                                            None);\n                 ty::mk_closure(tcx, fn_decl)\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n@@ -728,43 +737,19 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n     };\n }\n \n-pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n+pub fn ty_of_closure<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n     id: ast::NodeId,\n-    sigil: ast::Sigil,\n     fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n-    opt_lifetime: &Option<ast::Lifetime>,\n+    store: ty::TraitStore,\n     decl: &ast::FnDecl,\n-    expected_sig: Option<ty::FnSig>,\n-    span: Span)\n+    expected_sig: Option<ty::FnSig>)\n     -> ty::ClosureTy\n {\n     debug!(\"ty_of_fn_decl\");\n \n-    // resolve the function bound region in the original region\n-    // scope `rscope`, not the scope of the function parameters\n-    let bound_region = match opt_lifetime {\n-        &Some(ref lifetime) => {\n-            ast_region_to_region(this.tcx(), lifetime)\n-        }\n-        &None => {\n-            match sigil {\n-                ast::OwnedSigil | ast::ManagedSigil => {\n-                    // @fn(), ~fn() default to static as the bound\n-                    // on their upvars:\n-                    ty::ReStatic\n-                }\n-                ast::BorrowedSigil => {\n-                    // || defaults as normal for an omitted lifetime:\n-                    opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n-                }\n-            }\n-        }\n-    };\n-\n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n     let rb = rscope::BindingRscope::new(id);\n@@ -791,9 +776,8 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n \n     ty::ClosureTy {\n         fn_style: fn_style,\n-        sigil: sigil,\n         onceness: onceness,\n-        region: bound_region,\n+        store: store,\n         bounds: bounds,\n         sig: ty::FnSig {binder_id: id,\n                         inputs: input_tys,"}, {"sha": "d9f4527e9d1e99014d0f1362794b060f6e5ccaf0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -2116,7 +2116,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n-                     ast_sigil_opt: Option<ast::Sigil>,\n+                     store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n                      body: ast::P<ast::Block>,\n                      fn_kind: FnKind,\n@@ -2126,18 +2126,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Find the expected input/output types (if any). Substitute\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n-        //\n-        // Also try to pick up inferred style and sigil, defaulting\n-        // to impure and block. Note that we only will use those for\n-        // block syntax lambdas; that is, lambdas without explicit\n-        // sigils.\n         let expected_sty = unpack_expected(fcx,\n                                            expected,\n                                            |x| Some((*x).clone()));\n         let error_happened = false;\n         let (expected_sig,\n-             expected_style,\n-             expected_sigil,\n              expected_onceness,\n              expected_bounds) = {\n             match expected_sty {\n@@ -2146,47 +2139,32 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         replace_late_bound_regions_in_fn_sig(\n                             tcx, &cenv.sig,\n                             |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n-                    (Some(sig), cenv.fn_style, cenv.sigil,\n-                     cenv.onceness, cenv.bounds)\n+                    (Some(sig), cenv.onceness, cenv.bounds)\n                 }\n                 _ => {\n                     // Not an error! Means we're inferring the closure type\n-                    let mut sigil = ast::BorrowedSigil;\n-                    let mut onceness = ast::Many;\n                     let mut bounds = ty::EmptyBuiltinBounds();\n-                    match expr.node {\n+                    let onceness = match expr.node {\n                         ast::ExprProc(..) => {\n-                            sigil = ast::OwnedSigil;\n-                            onceness = ast::Once;\n                             bounds.add(ty::BoundSend);\n+                            ast::Once\n                         }\n-                        _ => ()\n-                    }\n-                    (None, ast::NormalFn, sigil,\n-                     onceness, bounds)\n+                        _ => ast::Many\n+                    };\n+                    (None, onceness, bounds)\n                 }\n             }\n         };\n \n-        // If the proto is specified, use that, otherwise select a\n-        // proto based on inference.\n-        let (sigil, fn_style) = match ast_sigil_opt {\n-            Some(p) => (p, ast::NormalFn),\n-            None => (expected_sigil, expected_style)\n-        };\n-\n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           fcx.infcx(),\n                                            expr.id,\n-                                           sigil,\n-                                           fn_style,\n+                                           ast::NormalFn,\n                                            expected_onceness,\n                                            expected_bounds,\n-                                           &None,\n+                                           store,\n                                            decl,\n-                                           expected_sig,\n-                                           expr.span);\n+                                           expected_sig);\n \n         let fty_sig;\n         let fty = if error_happened {\n@@ -2198,21 +2176,23 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             };\n             ty::mk_err()\n         } else {\n-            let fn_ty_copy = fn_ty.clone();\n             fty_sig = fn_ty.sig.clone();\n-            ty::mk_closure(tcx, fn_ty_copy)\n+            ty::mk_closure(tcx, fn_ty.clone())\n         };\n \n         debug!(\"check_expr_fn_with_unifier fty={}\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n-        let (inherited_style, id) =\n-            ty::determine_inherited_style((fcx.ps.borrow().fn_style,\n-                                            fcx.ps.borrow().def),\n-                                           (fn_style, expr.id),\n-                                           sigil);\n+        // If the closure is a stack closure and hasn't had some non-standard\n+        // style inferred for it, then check it under its parent's style.\n+        // Otherwise, use its own\n+        let (inherited_style, id) = match store {\n+            ty::RegionTraitStore(..) => (fcx.ps.borrow().fn_style,\n+                                         fcx.ps.borrow().def),\n+            ty::UniqTraitStore => (ast::NormalFn, expr.id)\n+        };\n \n         check_fn(fcx.ccx, inherited_style, &fty_sig,\n                  decl, id, body, fn_kind, fcx.inh);\n@@ -2856,9 +2836,13 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         _match::check_match(fcx, expr, discrim, arms.as_slice());\n       }\n       ast::ExprFnBlock(decl, body) => {\n+        let region = astconv::opt_ast_region_to_region(fcx,\n+                                                       fcx.infcx(),\n+                                                       expr.span,\n+                                                       &None);\n         check_expr_fn(fcx,\n                       expr,\n-                      Some(ast::BorrowedSigil),\n+                      ty::RegionTraitStore(region, ast::MutMutable),\n                       decl,\n                       body,\n                       Vanilla,\n@@ -2867,7 +2851,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprProc(decl, body) => {\n         check_expr_fn(fcx,\n                       expr,\n-                      Some(ast::OwnedSigil),\n+                      ty::UniqTraitStore,\n                       decl,\n                       body,\n                       Vanilla,"}, {"sha": "6a42f6485df111b38bac07d5a36cb7a052be50e2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -133,7 +133,6 @@ use middle::typeck::MethodCall;\n use middle::pat_util;\n use util::ppaux::{ty_to_str, region_to_str, Repr};\n \n-use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n use syntax::ast_util;\n@@ -175,9 +174,9 @@ fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n             tcx.region_maps.var_region(node_id)\n         }\n         DefUpvar(_, subdef, closure_id, body_id) => {\n-            match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n-                BorrowedSigil => region_of_def(fcx, *subdef),\n-                ManagedSigil | OwnedSigil => ReScope(body_id)\n+            match ty::ty_closure_store(fcx.node_ty(closure_id)) {\n+                ty::RegionTraitStore(..) => region_of_def(fcx, *subdef),\n+                ty::UniqTraitStore => ReScope(body_id)\n             }\n         }\n         _ => {\n@@ -611,7 +610,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     let function_type = rcx.resolve_node_type(expr.id);\n     match ty::get(function_type).sty {\n         ty::ty_closure(~ty::ClosureTy {\n-                sigil: ast::BorrowedSigil, region: region, ..}) => {\n+                store: ty::RegionTraitStore(region, _), ..}) => {\n             let freevars = freevars::get_freevars(tcx, expr.id);\n             if freevars.is_empty() {\n                 // No free variables means that the environment\n@@ -635,7 +634,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match ty::get(function_type).sty {\n-        ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+        ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n             let freevars = freevars::get_freevars(tcx, expr.id);\n             propagate_upupvar_borrow_kind(rcx, expr, freevars);\n         }\n@@ -749,8 +748,12 @@ fn constrain_callee(rcx: &mut Rcx,\n     match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n+            let region = match closure_ty.store {\n+                ty::RegionTraitStore(r, _) => r,\n+                ty::UniqTraitStore => ty::ReStatic\n+            };\n             rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n-                            call_region, closure_ty.region);\n+                            call_region, region);\n         }\n         _ => {\n             // this should not happen, but it does if the program is"}, {"sha": "6ad3d380b286b7266ba8575066cee6067ec90b8c", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -141,7 +141,11 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n \n         Some(adjustment) => {\n             match *adjustment {\n-                ty::AutoAddEnv(r, s) => {\n+                ty::AutoAddEnv(store) => {\n+                    let r = match store {\n+                        ty::RegionTraitStore(r, _) => r,\n+                        ty::UniqTraitStore => ty::ReStatic\n+                    };\n                     match resolve_region(fcx.infcx(),\n                                          r,\n                                          resolve_all | force_all) {\n@@ -166,7 +170,12 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                                         \"cannot coerce non-statically resolved bare fn\")\n                             }\n \n-                            let resolved_adj = @ty::AutoAddEnv(r1, s);\n+                            let resolved_adj = @ty::AutoAddEnv(match store {\n+                                ty::RegionTraitStore(..) => {\n+                                    ty::RegionTraitStore(r1, ast::MutMutable)\n+                                }\n+                                ty::UniqTraitStore => ty::UniqTraitStore\n+                            });\n                             debug!(\"Adjustments for node {}: {:?}\",\n                                    id, resolved_adj);\n                             tcx.adjustments.borrow_mut().insert(id, resolved_adj);"}, {"sha": "ee3c58aeedd0d20be895a866559b5193e996d030", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -120,7 +120,7 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_closure(~ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+            ty::ty_closure(~ty::ClosureTy {store: ty::RegionTraitStore(..), ..}) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 });\n@@ -343,8 +343,7 @@ impl<'f> Coerce<'f> {\n                b.inf_str(self.get_ref().infcx));\n \n         let fn_ty = match *sty_a {\n-            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil ||\n-                                     f.sigil == ast::OwnedSigil => {\n+            ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n                 (*f).clone()\n             }\n             ty::ty_bare_fn(ref f) => {\n@@ -359,8 +358,7 @@ impl<'f> Coerce<'f> {\n         let a_borrowed = ty::mk_closure(\n             self.get_ref().infcx.tcx,\n             ty::ClosureTy {\n-                sigil: ast::BorrowedSigil,\n-                region: r_borrow,\n+                store: ty::RegionTraitStore(r_borrow, ast::MutMutable),\n                 .. *fn_ty\n             });\n \n@@ -393,7 +391,7 @@ impl<'f> Coerce<'f> {\n                 _ => return self.subtype(a, b)\n             };\n \n-            let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n+            let adj = @ty::AutoAddEnv(fn_ty_b.store);\n             let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                            ty::ClosureTy {\n                                                 sig: fn_ty_a.sig.clone(),"}, {"sha": "8c449a8f118f481e921e5e7c1f923c49c42a2052", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -205,18 +205,32 @@ pub trait Combine {\n     fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n \n-        let p = if_ok!(self.sigils(a.sigil, b.sigil));\n-        let r = if_ok!(self.contraregions(a.region, b.region));\n+        let store = match (a.store, b.store) {\n+            (ty::RegionTraitStore(a_r, a_m),\n+             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n+                let r = if_ok!(self.contraregions(a_r, b_r));\n+                ty::RegionTraitStore(r, a_m)\n+            }\n+\n+            _ if a.store == b.store => {\n+                a.store\n+            }\n+\n+            _ => {\n+                return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n+            }\n+        };\n         let fn_style = if_ok!(self.fn_styles(a.fn_style, b.fn_style));\n         let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n-        Ok(ty::ClosureTy {fn_style: fn_style,\n-                sigil: p,\n-                onceness: onceness,\n-                region: r,\n-                bounds: bounds,\n-                sig: sig})\n+        Ok(ty::ClosureTy {\n+            fn_style: fn_style,\n+            onceness: onceness,\n+            store: store,\n+            bounds: bounds,\n+            sig: sig\n+        })\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n@@ -238,14 +252,6 @@ pub trait Combine {\n         self.contratys(a, b).and_then(|t| Ok(t))\n     }\n \n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        if p1 == p2 {\n-            Ok(p1)\n-        } else {\n-            Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n-        }\n-    }\n-\n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle>;\n \n     fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {"}, {"sha": "c6c79608f6c316fc4f270e7e254550a94dcea9e9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -704,11 +704,13 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraint(index, variance);\n             }\n \n-            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, .. }) => {\n+            ty::ty_bare_fn(ty::BareFnTy { ref sig, .. }) |\n+            ty::ty_closure(~ty::ClosureTy { ref sig, store: ty::UniqTraitStore, .. }) => {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_closure(~ty::ClosureTy { sig: ref sig, region, .. }) => {\n+            ty::ty_closure(~ty::ClosureTy { ref sig,\n+                    store: ty::RegionTraitStore(region, _), .. }) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(region, contra);\n                 self.add_constraints_from_sig(sig, variance);"}, {"sha": "63ea1a5ec86441be5f35e6c4a6126e49dce20aab", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 44, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/402d946868c4d775eebd29b4e13d3897f5cc2d47/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=402d946868c4d775eebd29b4e13d3897f5cc2d47", "patch": "@@ -266,21 +266,11 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n     }\n \n     fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n-        let is_proc =\n-            (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n-        let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n+        let mut s = StrBuf::new();\n \n-        let mut s = if is_proc || is_borrowed_closure {\n-            StrBuf::new()\n-        } else {\n-            StrBuf::from_owned_str(cty.sigil.to_str())\n-        };\n-\n-        match (cty.sigil, cty.region) {\n-            (ast::ManagedSigil, ty::ReStatic) |\n-            (ast::OwnedSigil, ty::ReStatic) => {}\n-\n-            (_, region) => {\n+        match cty.store {\n+            ty::UniqTraitStore => {}\n+            ty::RegionTraitStore(region, _) => {\n                 s.push_str(region_to_str(cx, \"\", true, region));\n             }\n         }\n@@ -293,40 +283,24 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             }\n         };\n \n-        if is_proc {\n-            s.push_str(\"proc\");\n-        } else {\n-            match cty.onceness {\n-                ast::Many => {}\n-                ast::Once => {\n-                    s.push_str(cty.onceness.to_str());\n-                    s.push_char(' ');\n+        match cty.store {\n+            ty::UniqTraitStore => {\n+                assert_eq!(cty.onceness, ast::Once);\n+                s.push_str(\"proc\");\n+                push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n+            }\n+            ty::RegionTraitStore(..) => {\n+                match cty.onceness {\n+                    ast::Many => {}\n+                    ast::Once => s.push_str(\"once \")\n                 }\n-            };\n-\n-            if !is_borrowed_closure {\n-                s.push_str(\"fn\");\n+                push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n             }\n         }\n \n-        if !is_borrowed_closure {\n-            // Print bounds before `fn` if this is not a borrowed closure.\n-            if !cty.bounds.is_empty() {\n-                s.push_str(\":\");\n-                s.push_str(cty.bounds.repr(cx));\n-            }\n-\n-            push_sig_to_str(cx, &mut s, '(', ')', &cty.sig);\n-        } else {\n-            // Print bounds after the signature if this is a borrowed closure.\n-            push_sig_to_str(cx, &mut s, '|', '|', &cty.sig);\n-\n-            if is_borrowed_closure {\n-                if !cty.bounds.is_empty() {\n-                    s.push_str(\":\");\n-                    s.push_str(cty.bounds.repr(cx));\n-                }\n-            }\n+        if !cty.bounds.is_empty() {\n+            s.push_str(\":\");\n+            s.push_str(cty.bounds.repr(cx));\n         }\n \n         s.into_owned()"}]}