{"sha": "1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYmUyMWE1NDUxMDRlODVhYTVmOWQwZDhhNDVlYzEwNDAzOTZjYjk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-22T14:41:10Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:16Z"}, "message": "Make remaining item data queries use item tree", "tree": {"sha": "02b1811fb5cebde9e0c839b4e658cd023a9bcd8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b1811fb5cebde9e0c839b4e658cd023a9bcd8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "html_url": "https://github.com/rust-lang/rust/commit/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "html_url": "https://github.com/rust-lang/rust/commit/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac"}], "stats": {"total": 242, "additions": 90, "deletions": 152}, "files": [{"sha": "921253c42d601edd3a889e5ab1a24be61895d178", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 42, "deletions": 122, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "patch": "@@ -2,23 +2,16 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{name, AsName, Name},\n-    InFile,\n-};\n+use hir_expand::{name::Name, InFile};\n use ra_prof::profile;\n-use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, TypeBoundsOwner, VisibilityOwner};\n+use ra_syntax::ast;\n \n use crate::{\n     attr::Attrs,\n     body::Expander,\n-    body::LowerCtx,\n     db::DefDatabase,\n     item_tree::{AssocItem, ItemTreeId, ModItem},\n-    path::{path, AssociatedTypeBinding, GenericArgs, Path},\n-    src::HasSource,\n-    type_ref::{Mutability, TypeBound, TypeRef},\n+    type_ref::{TypeBound, TypeRef},\n     visibility::RawVisibility,\n     AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n     Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n@@ -40,82 +33,27 @@ pub struct FunctionData {\n impl FunctionData {\n     pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n-        let src = loc.source(db);\n-        let ctx = LowerCtx::new(db, src.file_id);\n-        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = src.value.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(&ctx, type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name![Self].into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n-\n-        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(&ctx, type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let ret_type = if src.value.async_token().is_some() {\n-            let future_impl = desugar_future_path(ret_type);\n-            let ty_bound = TypeBound::Path(future_impl);\n-            TypeRef::ImplTrait(vec![ty_bound])\n-        } else {\n-            ret_type\n-        };\n-\n-        let is_unsafe = src.value.unsafe_token().is_some();\n-\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n-\n-        let sig =\n-            FunctionData { name, params, ret_type, has_self_param, is_unsafe, visibility, attrs };\n-        Arc::new(sig)\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let func = &item_tree[loc.id.value];\n+\n+        Arc::new(FunctionData {\n+            name: func.name.clone(),\n+            params: func.params.clone(),\n+            ret_type: func.ret_type.clone(),\n+            attrs: func.attrs.clone(),\n+            has_self_param: func.has_self_param,\n+            is_unsafe: func.is_unsafe,\n+            visibility: func.visibility.clone(),\n+        })\n     }\n }\n \n-fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![core::future::Future];\n-    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n-    last.bindings.push(AssociatedTypeBinding {\n-        name: name![Output],\n-        type_ref: Some(orig),\n-        bounds: Vec::new(),\n-    });\n-    generic_args.push(Some(Arc::new(last)));\n-\n-    Path::from_known_path(path, generic_args)\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n     pub visibility: RawVisibility,\n+    /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<TypeBound>,\n }\n \n@@ -125,22 +63,15 @@ impl TypeAliasData {\n         typ: TypeAliasId,\n     ) -> Arc<TypeAliasData> {\n         let loc = typ.lookup(db);\n-        let node = loc.source(db);\n-        let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let lower_ctx = LowerCtx::new(db, node.file_id);\n-        let type_ref = node.value.type_ref().map(|it| TypeRef::from_ast(&lower_ctx, it));\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility = RawVisibility::from_ast_with_default(\n-            db,\n-            vis_default,\n-            node.as_ref().map(|n| n.visibility()),\n-        );\n-        let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n-            bound_list.bounds().map(|it| TypeBound::from_ast(&lower_ctx, it)).collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TypeAliasData { name, type_ref, visibility, bounds })\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let typ = &item_tree[loc.id.value];\n+\n+        Arc::new(TypeAliasData {\n+            name: typ.name.clone(),\n+            type_ref: typ.type_ref.clone(),\n+            visibility: typ.visibility.clone(),\n+            bounds: typ.bounds.clone(),\n+        })\n     }\n }\n \n@@ -238,22 +169,14 @@ pub struct ConstData {\n impl ConstData {\n     pub(crate) fn const_data_query(db: &dyn DefDatabase, konst: ConstId) -> Arc<ConstData> {\n         let loc = konst.lookup(db);\n-        let node = loc.source(db);\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        Arc::new(ConstData::new(db, vis_default, node))\n-    }\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let konst = &item_tree[loc.id.value];\n \n-    fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n-        db: &dyn DefDatabase,\n-        vis_default: RawVisibility,\n-        node: InFile<N>,\n-    ) -> ConstData {\n-        let ctx = LowerCtx::new(db, node.file_id);\n-        let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n-        ConstData { name, type_ref, visibility }\n+        Arc::new(ConstData {\n+            name: konst.name.clone(),\n+            type_ref: konst.type_ref.clone(),\n+            visibility: konst.visibility.clone(),\n+        })\n     }\n }\n \n@@ -267,19 +190,16 @@ pub struct StaticData {\n \n impl StaticData {\n     pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<StaticData> {\n-        let node = konst.lookup(db).source(db);\n-        let ctx = LowerCtx::new(db, node.file_id);\n-\n-        let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n-        let mutable = node.value.mut_token().is_some();\n-        let visibility = RawVisibility::from_ast_with_default(\n-            db,\n-            RawVisibility::private(),\n-            node.map(|n| n.visibility()),\n-        );\n-\n-        Arc::new(StaticData { name, type_ref, visibility, mutable })\n+        let node = konst.lookup(db);\n+        let item_tree = db.item_tree(node.id.file_id);\n+        let statik = &item_tree[node.id.value];\n+\n+        Arc::new(StaticData {\n+            name: Some(statik.name.clone()),\n+            type_ref: statik.type_ref.clone(),\n+            visibility: statik.visibility.clone(),\n+            mutable: statik.mutable,\n+        })\n     }\n }\n "}, {"sha": "c35d6329521b9e76b56eff50ae551a9998229999", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "patch": "@@ -349,6 +349,7 @@ pub struct Function {\n     pub visibility: RawVisibility,\n     pub generic_params: GenericParams,\n     pub has_self_param: bool,\n+    pub is_unsafe: bool,\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n     pub ast_id: FileAstId<ast::FnDef>,\n@@ -408,6 +409,7 @@ pub struct Const {\n pub struct Static {\n     pub name: Name,\n     pub visibility: RawVisibility,\n+    pub mutable: bool,\n     pub type_ref: TypeRef,\n     pub ast_id: FileAstId<ast::StaticDef>,\n }\n@@ -436,6 +438,8 @@ pub struct Impl {\n pub struct TypeAlias {\n     pub name: Name,\n     pub visibility: RawVisibility,\n+    /// Bounds on the type alias itself. Only valid in trait declarations, eg. `type Assoc: Copy;`.\n+    pub bounds: Vec<TypeBound>,\n     pub generic_params: GenericParams,\n     pub type_ref: Option<TypeRef>,\n     pub ast_id: FileAstId<ast::TypeAliasDef>,"}, {"sha": "42af8bb5e5ca96d08da2d46bfa83835871210ecf", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "patch": "@@ -36,6 +36,7 @@ pub(super) struct Ctx {\n     source_ast_id_map: Arc<AstIdMap>,\n     body_ctx: crate::body::LowerCtx,\n     inner_items: Vec<ModItem>,\n+    forced_visibility: Option<RawVisibility>,\n }\n \n impl Ctx {\n@@ -47,6 +48,7 @@ impl Ctx {\n             source_ast_id_map: db.ast_id_map(file),\n             body_ctx: crate::body::LowerCtx::new(db, file),\n             inner_items: Vec::new(),\n+            forced_visibility: None,\n         }\n     }\n \n@@ -117,6 +119,7 @@ impl Ctx {\n     }\n \n     fn collect_inner_items(&mut self, container: &SyntaxNode) {\n+        let forced_vis = self.forced_visibility.take();\n         let mut inner_items = mem::replace(&mut self.tree.inner_items, FxHashMap::default());\n         inner_items.extend(\n             container.descendants().skip(1).filter_map(ast::ModuleItem::cast).filter_map(|item| {\n@@ -125,6 +128,7 @@ impl Ctx {\n             }),\n         );\n         self.tree.inner_items = inner_items;\n+        self.forced_visibility = forced_vis;\n     }\n \n     fn lower_assoc_item(&mut self, item: &ast::ModuleItem) -> Option<AssocItem> {\n@@ -304,6 +308,7 @@ impl Ctx {\n             visibility,\n             generic_params: GenericParams::default(),\n             has_self_param,\n+            is_unsafe: func.unsafe_token().is_some(),\n             params,\n             ret_type,\n             ast_id,\n@@ -320,18 +325,20 @@ impl Ctx {\n         let name = type_alias.name()?.as_name();\n         let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n+        let bounds = self.lower_type_bounds(type_alias);\n         let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n         let ast_id = self.source_ast_id_map.ast_id(type_alias);\n-        let res = TypeAlias { name, visibility, generic_params, type_ref, ast_id };\n+        let res = TypeAlias { name, visibility, bounds, generic_params, type_ref, ast_id };\n         Some(id(self.tree.type_aliases.alloc(res)))\n     }\n \n     fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<FileItemTreeId<Static>> {\n         let name = static_.name()?.as_name();\n         let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n         let visibility = self.lower_visibility(static_);\n+        let mutable = static_.mut_token().is_some();\n         let ast_id = self.source_ast_id_map.ast_id(static_);\n-        let res = Static { name, visibility, type_ref, ast_id };\n+        let res = Static { name, visibility, mutable, type_ref, ast_id };\n         Some(id(self.tree.statics.alloc(res)))\n     }\n \n@@ -376,12 +383,14 @@ impl Ctx {\n         let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n         let auto = trait_def.auto_token().is_some();\n         let items = trait_def.item_list().map(|list| {\n-            list.items()\n-                .flat_map(|item| {\n-                    self.collect_inner_items(item.syntax());\n-                    self.lower_assoc_item(&item)\n-                })\n-                .collect()\n+            self.with_inherited_visibility(visibility.clone(), |this| {\n+                list.items()\n+                    .flat_map(|item| {\n+                        this.collect_inner_items(item.syntax());\n+                        this.lower_assoc_item(&item)\n+                    })\n+                    .collect()\n+            })\n         });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n         let res = Trait {\n@@ -549,11 +558,23 @@ impl Ctx {\n         generics\n     }\n \n+    fn lower_type_bounds(&mut self, node: &impl ast::TypeBoundsOwner) -> Vec<TypeBound> {\n+        if let Some(bound_list) = node.type_bound_list() {\n+            bound_list.bounds().map(|it| TypeBound::from_ast(&self.body_ctx, it)).collect()\n+        } else {\n+            Vec::new()\n+        }\n+    }\n+\n     fn lower_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n         Attrs::new(item, &self.hygiene)\n     }\n     fn lower_visibility(&self, item: &impl ast::VisibilityOwner) -> RawVisibility {\n-        RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene)\n+        if let Some(vis) = self.forced_visibility.as_ref() {\n+            vis.clone()\n+        } else {\n+            RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene)\n+        }\n     }\n     fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n         TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n@@ -562,6 +583,18 @@ impl Ctx {\n         TypeRef::from_ast_opt(&self.body_ctx, type_ref)\n     }\n \n+    /// Forces the visibility `vis` to be used for all items lowered during execution of `f`.\n+    fn with_inherited_visibility<R>(\n+        &mut self,\n+        vis: RawVisibility,\n+        f: impl FnOnce(&mut Self) -> R,\n+    ) -> R {\n+        let old = mem::replace(&mut self.forced_visibility, Some(vis));\n+        let res = f(self);\n+        self.forced_visibility = old;\n+        res\n+    }\n+\n     fn next_field_idx(&self) -> Idx<Field> {\n         Idx::from_raw(RawId::from(self.tree.fields.len() as u32))\n     }"}, {"sha": "1db1ce7a9aeed90353bd8d3ccc139e72f6dba77a", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "patch": "@@ -204,7 +204,7 @@ Impl { generic_params: GenericParams { types: Arena { len: 0, data: [] }, where_\n \n inner items:\n FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(2):\n-- Function { name: Name(Text(\"end\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"W\"))), default: None, provenance: TypeParamList }] }, where_predicates: [WherePredicate { target: TypeRef(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"W\"))] }, generic_args: [None] })), bound: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Write\"))] }, generic_args: [None] }) }] }, has_self_param: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+- Function { name: Name(Text(\"end\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"W\"))), default: None, provenance: TypeParamList }] }, where_predicates: [WherePredicate { target: TypeRef(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"W\"))] }, generic_args: [None] })), bound: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Write\"))] }, generic_args: [None] }) }] }, has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n     \"###);\n }\n "}, {"sha": "8136cb50ccfefa35f7b05cba88ddb966668ac47f", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbe21a545104e85aa5f9d0d8a45ec1040396cb9/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=1fbe21a545104e85aa5f9d0d8a45ec1040396cb9", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::ast;\n use crate::{\n     db::DefDatabase,\n     path::{ModPath, PathKind},\n-    AssocContainerId, ModuleId,\n+    ModuleId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -25,25 +25,6 @@ impl RawVisibility {\n         RawVisibility::Module(path)\n     }\n \n-    pub(crate) fn default_for_container(container_id: AssocContainerId) -> Self {\n-        match container_id {\n-            AssocContainerId::TraitId(_) => RawVisibility::Public,\n-            _ => RawVisibility::private(),\n-        }\n-    }\n-\n-    pub(crate) fn from_ast_with_default(\n-        db: &dyn DefDatabase,\n-        default: RawVisibility,\n-        node: InFile<Option<ast::Visibility>>,\n-    ) -> RawVisibility {\n-        Self::from_ast_with_hygiene_and_default(\n-            node.value,\n-            default,\n-            &Hygiene::new(db.upcast(), node.file_id),\n-        )\n-    }\n-\n     pub(crate) fn from_ast(\n         db: &dyn DefDatabase,\n         node: InFile<Option<ast::Visibility>>,"}]}