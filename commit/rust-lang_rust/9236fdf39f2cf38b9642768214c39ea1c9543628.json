{"sha": "9236fdf39f2cf38b9642768214c39ea1c9543628", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMzZmZGYzOWYyY2YzOGI5NjQyNzY4MjE0YzM5ZWExYzk1NDM2Mjg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-28T17:11:33Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-28T20:18:16Z"}, "message": "Move the kind datatype to middle::ty\n\nThe AST no longer references it.", "tree": {"sha": "7855ec128b51d8b4fc6b106047180e82f893a077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7855ec128b51d8b4fc6b106047180e82f893a077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9236fdf39f2cf38b9642768214c39ea1c9543628", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9236fdf39f2cf38b9642768214c39ea1c9543628", "html_url": "https://github.com/rust-lang/rust/commit/9236fdf39f2cf38b9642768214c39ea1c9543628", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9236fdf39f2cf38b9642768214c39ea1c9543628/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ed6a275487607b71716a4d8ec4cac58cd803c1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed6a275487607b71716a4d8ec4cac58cd803c1f", "html_url": "https://github.com/rust-lang/rust/commit/1ed6a275487607b71716a4d8ec4cac58cd803c1f"}], "stats": {"total": 105, "additions": 53, "deletions": 52}, "files": [{"sha": "e9b157294507484c25f20c5503df881a7e15b44f", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=9236fdf39f2cf38b9642768214c39ea1c9543628", "patch": "@@ -2,6 +2,7 @@ import option::{some, none};\n import syntax::{visit, ast_util};\n import syntax::ast::*;\n import syntax::codemap::span;\n+import ty::{kind, kind_copyable, kind_sendable, kind_noncopyable};\n \n // Kind analysis pass. There are three kinds:\n //\n@@ -135,7 +136,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let ty_fields = alt ty::struct(cx.tcx, t) { ty::ty_rec(f) { f } };\n             for tf in ty_fields {\n                 if !vec::any(fields, {|f| f.node.ident == tf.ident}) &&\n-                    !kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n+                    !ty::kind_can_be_copied(ty::type_kind(cx.tcx, tf.mt.ty)) {\n                     cx.tcx.sess.span_err(ex.span,\n                                          \"copying a noncopyable value\");\n                 }\n@@ -221,13 +222,13 @@ fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n }\n \n fn check_copy(cx: ctx, ty: ty::t, sp: span) {\n-    if !kind_can_be_copied(ty::type_kind(cx.tcx, ty)) {\n+    if !ty::kind_can_be_copied(ty::type_kind(cx.tcx, ty)) {\n         cx.tcx.sess.span_err(sp, \"copying a noncopyable value\");\n     }\n }\n \n fn check_send(cx: ctx, ty: ty::t, sp: span) {\n-    if !kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n+    if !ty::kind_can_be_sent(ty::type_kind(cx.tcx, ty)) {\n         cx.tcx.sess.span_err(sp, \"not a sendable value\");\n     }\n }"}, {"sha": "bb6d74f232ef27d3f7802d85092c52bc1efc4319", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=9236fdf39f2cf38b9642768214c39ea1c9543628", "patch": "@@ -145,8 +145,8 @@ export ty_fn_args;\n export type_constr;\n export type_contains_params;\n export type_contains_vars;\n-export kind_lteq;\n-export type_kind;\n+export kind, kind_sendable, kind_copyable, kind_noncopyable;\n+export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n@@ -216,7 +216,7 @@ type ctxt =\n       rcache: creader_cache,\n       short_names_cache: hashmap<t, @str>,\n       needs_drop_cache: hashmap<t, bool>,\n-      kind_cache: hashmap<t, ast::kind>,\n+      kind_cache: hashmap<t, kind>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n       tag_var_cache: hashmap<ast::def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n@@ -308,14 +308,14 @@ tag param_bound {\n     bound_iface(t);\n }\n \n-fn param_bounds_to_kind(bounds: @[param_bound]) -> ast::kind {\n-    let kind = ast::kind_noncopyable;\n+fn param_bounds_to_kind(bounds: @[param_bound]) -> kind {\n+    let kind = kind_noncopyable;\n     for bound in *bounds {\n         alt bound {\n           bound_copy. {\n-            if kind != ast::kind_sendable { kind = ast::kind_copyable; }\n+            if kind != kind_sendable { kind = kind_copyable; }\n           }\n-          bound_send. { kind = ast::kind_sendable; }\n+          bound_send. { kind = kind_sendable; }\n           _ {}\n         }\n     }\n@@ -847,7 +847,7 @@ fn type_is_structural(cx: ctxt, ty: t) -> bool {\n }\n \n fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n-    ret ast::kind_can_be_copied(type_kind(cx, ty));\n+    ret kind_can_be_copied(type_kind(cx, ty));\n }\n \n fn type_is_sequence(cx: ctxt, ty: t) -> bool {\n@@ -989,6 +989,36 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n+tag kind { kind_sendable; kind_copyable; kind_noncopyable; }\n+\n+// Using these query functons is preferable to direct comparison or matching\n+// against the kind constants, as we may modify the kind hierarchy in the\n+// future.\n+pure fn kind_can_be_copied(k: kind) -> bool {\n+    ret alt k {\n+      kind_sendable. { true }\n+      kind_copyable. { true }\n+      kind_noncopyable. { false }\n+    };\n+}\n+\n+pure fn kind_can_be_sent(k: kind) -> bool {\n+    ret alt k {\n+      kind_sendable. { true }\n+      kind_copyable. { false }\n+      kind_noncopyable. { false }\n+    };\n+}\n+\n+fn proto_kind(p: proto) -> kind {\n+    alt p {\n+      ast::proto_block. { kind_noncopyable }\n+      ast::proto_shared(_) { kind_copyable }\n+      ast::proto_send. { kind_sendable }\n+      ast::proto_bare. { kind_sendable }\n+    }\n+}\n+\n fn kind_lteq(a: kind, b: kind) -> bool {\n     alt a {\n       kind_noncopyable. { true }\n@@ -1001,58 +1031,58 @@ fn lower_kind(a: kind, b: kind) -> kind {\n     if ty::kind_lteq(a, b) { a } else { b }\n }\n \n-fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n+fn type_kind(cx: ctxt, ty: t) -> kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n     }\n \n     // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, ast::kind_sendable);\n+    cx.kind_cache.insert(ty, kind_sendable);\n \n     let result = alt struct(cx, ty) {\n       // Scalar and unique types are sendable\n       ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_native(_) | ty_ptr(_) |\n-      ty_send_type. | ty_str. | ty_native_fn(_, _) { ast::kind_sendable }\n+      ty_send_type. | ty_str. | ty_native_fn(_, _) { kind_sendable }\n       ty_type. { kind_copyable }\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n-      ty_fn(f) { ast::proto_kind(f.proto) }\n+      ty_fn(f) { proto_kind(f.proto) }\n       ty_opaque_closure. { kind_noncopyable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n-      ty_box(_) | ty_iface(_, _) { ast::kind_copyable }\n+      ty_box(_) | ty_iface(_, _) { kind_copyable }\n       // Boxes and unique pointers raise pinned to shared.\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        let lowest = ast::kind_sendable;\n+        let lowest = kind_sendable;\n         for f in flds { lowest = lower_kind(lowest, type_kind(cx, f.mt.ty)); }\n         lowest\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n-        let lowest = ast::kind_sendable;\n+        let lowest = kind_sendable;\n         for ty in tys { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n-        let lowest = ast::kind_sendable;\n+        let lowest = kind_sendable;\n         for variant in *tag_variants(cx, did) {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n                 let arg_ty = substitute_type_params(cx, tps, aty);\n                 lowest = lower_kind(lowest, type_kind(cx, arg_ty));\n-                if lowest == ast::kind_noncopyable { break; }\n+                if lowest == kind_noncopyable { break; }\n             }\n         }\n         lowest\n       }\n       // Resources are always noncopyable.\n-      ty_res(did, inner, tps) { ast::kind_noncopyable }\n+      ty_res(did, inner, tps) { kind_noncopyable }\n       ty_param(_, bounds) { param_bounds_to_kind(bounds) }\n       ty_constr(t, _) { type_kind(cx, t) }\n     };\n@@ -1143,7 +1173,7 @@ fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n           }\n           _ { false }\n         };\n-    }) && type_kind(cx, ty) != ast::kind_noncopyable;\n+    }) && type_kind(cx, ty) != kind_noncopyable;\n }\n \n fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {"}, {"sha": "04516826ba7043be6d7e0d4d25b6bf2dbd6d3303", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9236fdf39f2cf38b9642768214c39ea1c9543628/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=9236fdf39f2cf38b9642768214c39ea1c9543628", "patch": "@@ -110,27 +110,6 @@ tag pat_ {\n \n tag mutability { mut; imm; maybe_mut; }\n \n-tag kind { kind_sendable; kind_copyable; kind_noncopyable; }\n-\n-// Using these query functons is preferable to direct comparison or matching\n-// against the kind constants, as we may modify the kind hierarchy in the\n-// future.\n-pure fn kind_can_be_copied(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable. { true }\n-      kind_copyable. { true }\n-      kind_noncopyable. { false }\n-    };\n-}\n-\n-pure fn kind_can_be_sent(k: kind) -> bool {\n-    ret alt k {\n-      kind_sendable. { true }\n-      kind_copyable. { false }\n-      kind_noncopyable. { false }\n-    };\n-}\n-\n tag proto_sugar {\n     sugar_normal;\n     sugar_sexy;\n@@ -143,15 +122,6 @@ tag proto {\n     proto_block;\n }\n \n-fn proto_kind(p: proto) -> kind {\n-    alt p {\n-      ast::proto_block. { ast::kind_noncopyable }\n-      ast::proto_shared(_) { ast::kind_copyable }\n-      ast::proto_send. { ast::kind_sendable }\n-      ast::proto_bare. { ast::kind_sendable }\n-    }\n-}\n-\n tag binop {\n     add;\n     sub;"}]}