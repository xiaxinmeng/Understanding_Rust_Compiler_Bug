{"sha": "f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZDVmOTBhZGVlNWU0M2VjZjRjZDBlMTkxMDg2ZjhiZDQ1ZTEyODU=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T02:16:16Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-09T23:07:27Z"}, "message": "Move Drop to module.", "tree": {"sha": "1e9f98f55d7dc0b32a29f61268c4a1a7b51b249f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e9f98f55d7dc0b32a29f61268c4a1a7b51b249f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "html_url": "https://github.com/rust-lang/rust/commit/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b099e0e7867b7c2269c48f44892abf6e348ebda3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b099e0e7867b7c2269c48f44892abf6e348ebda3", "html_url": "https://github.com/rust-lang/rust/commit/b099e0e7867b7c2269c48f44892abf6e348ebda3"}], "stats": {"total": 193, "additions": 103, "deletions": 90}, "files": [{"sha": "92f3cb256c8335f42ea4b233dcf54de9dcc84bd3", "filename": "src/libcore/ops/drop.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// This is sometimes called a 'destructor'.\n+///\n+/// When a value goes out of scope, if it implements this trait, it will have\n+/// its `drop` method called. Then any fields the value contains will also\n+/// be dropped recursively.\n+///\n+/// Because of the recursive dropping, you do not need to implement this trait\n+/// unless your type needs its own destructor logic.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n+/// goes out of scope, and therefore `main` prints `Dropping!`.\n+///\n+/// ```\n+/// struct HasDrop;\n+///\n+/// impl Drop for HasDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = HasDrop;\n+/// }\n+/// ```\n+///\n+/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n+/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n+/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n+///\n+/// ```\n+/// struct Inner;\n+/// struct Outer(Inner);\n+///\n+/// impl Drop for Inner {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Inner!\");\n+///     }\n+/// }\n+///\n+/// impl Drop for Outer {\n+///     fn drop(&mut self) {\n+///         println!(\"Dropping Outer!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let _x = Outer(Inner);\n+/// }\n+/// ```\n+///\n+/// Because variables are dropped in the reverse order they are declared,\n+/// `main` will print `Declared second!` and then `Declared first!`.\n+///\n+/// ```\n+/// struct PrintOnDrop(&'static str);\n+///\n+/// fn main() {\n+///     let _first = PrintOnDrop(\"Declared first!\");\n+///     let _second = PrintOnDrop(\"Declared second!\");\n+/// }\n+/// ```\n+#[lang = \"drop\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Drop {\n+    /// A method called when the value goes out of scope.\n+    ///\n+    /// When this method has been called, `self` has not yet been deallocated.\n+    /// If it were, `self` would be a dangling reference.\n+    ///\n+    /// After this function is over, the memory of `self` will be deallocated.\n+    ///\n+    /// This function cannot be called explicitly. This is compiler error\n+    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n+    /// used to call the argument's `Drop` implementation.\n+    ///\n+    /// [E0040]: ../../error-index.html#E0040\n+    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n+    /// a `drop()` implementation will likely abort.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn drop(&mut self);\n+}"}, {"sha": "4e0389e5de4eb24157a74afe4dfaab0cba30a03d", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 90, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d5f90adee5e43ecf4cd0e191086f8bd45e1285/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=f8d5f90adee5e43ecf4cd0e191086f8bd45e1285", "patch": "@@ -150,6 +150,7 @@\n mod arith;\n mod bit;\n mod deref;\n+mod drop;\n mod function;\n mod index;\n mod place;\n@@ -170,6 +171,9 @@ pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssig\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::deref::{Deref, DerefMut};\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::drop::Drop;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::function::{Fn, FnMut, FnOnce};\n \n@@ -193,93 +197,3 @@ pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;\n-\n-/// The `Drop` trait is used to run some code when a value goes out of scope.\n-/// This is sometimes called a 'destructor'.\n-///\n-/// When a value goes out of scope, if it implements this trait, it will have\n-/// its `drop` method called. Then any fields the value contains will also\n-/// be dropped recursively.\n-///\n-/// Because of the recursive dropping, you do not need to implement this trait\n-/// unless your type needs its own destructor logic.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n-/// goes out of scope, and therefore `main` prints `Dropping!`.\n-///\n-/// ```\n-/// struct HasDrop;\n-///\n-/// impl Drop for HasDrop {\n-///     fn drop(&mut self) {\n-///         println!(\"Dropping!\");\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let _x = HasDrop;\n-/// }\n-/// ```\n-///\n-/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n-/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n-/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n-///\n-/// ```\n-/// struct Inner;\n-/// struct Outer(Inner);\n-///\n-/// impl Drop for Inner {\n-///     fn drop(&mut self) {\n-///         println!(\"Dropping Inner!\");\n-///     }\n-/// }\n-///\n-/// impl Drop for Outer {\n-///     fn drop(&mut self) {\n-///         println!(\"Dropping Outer!\");\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     let _x = Outer(Inner);\n-/// }\n-/// ```\n-///\n-/// Because variables are dropped in the reverse order they are declared,\n-/// `main` will print `Declared second!` and then `Declared first!`.\n-///\n-/// ```\n-/// struct PrintOnDrop(&'static str);\n-///\n-/// fn main() {\n-///     let _first = PrintOnDrop(\"Declared first!\");\n-///     let _second = PrintOnDrop(\"Declared second!\");\n-/// }\n-/// ```\n-#[lang = \"drop\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Drop {\n-    /// A method called when the value goes out of scope.\n-    ///\n-    /// When this method has been called, `self` has not yet been deallocated.\n-    /// If it were, `self` would be a dangling reference.\n-    ///\n-    /// After this function is over, the memory of `self` will be deallocated.\n-    ///\n-    /// This function cannot be called explicitly. This is compiler error\n-    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n-    /// used to call the argument's `Drop` implementation.\n-    ///\n-    /// [E0040]: ../../error-index.html#E0040\n-    /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n-    ///\n-    /// # Panics\n-    ///\n-    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n-    /// a `drop()` implementation will likely abort.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn drop(&mut self);\n-}"}]}