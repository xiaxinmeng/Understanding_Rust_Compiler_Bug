{"sha": "a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ODQwZjAyYjBlYjNkNDI0N2M2NmU1MTY5ZjdmNTBlMTllNzBkNmQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-21T18:13:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-10-21T18:14:38Z"}, "message": "Use \"friendly\" type names when reporting a \"mismatched type-params\" error", "tree": {"sha": "700e1bb1db0c4db7d7f1508ee8259ac04641f030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/700e1bb1db0c4db7d7f1508ee8259ac04641f030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "html_url": "https://github.com/rust-lang/rust/commit/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "852c0d6631536a56c25bf712f89aac34b58c0d91", "url": "https://api.github.com/repos/rust-lang/rust/commits/852c0d6631536a56c25bf712f89aac34b58c0d91", "html_url": "https://github.com/rust-lang/rust/commit/852c0d6631536a56c25bf712f89aac34b58c0d91"}], "stats": {"total": 167, "additions": 79, "deletions": 88}, "files": [{"sha": "4fafa05f1d15811d997b6b1312caf0c9da2e4e0c", "filename": "src/boot/me/resolve.ml", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "patch": "@@ -423,7 +423,10 @@ let type_resolving_visitor\n                 log cx \"resolved item %s, defining type %a\"\n                   id Ast.sprintf_ty ty;\n                 htab_put cx.ctxt_all_type_items item.id ty;\n-                htab_put cx.ctxt_all_item_types item.id Ast.TY_type\n+                htab_put cx.ctxt_all_item_types item.id Ast.TY_type;\n+                if Hashtbl.mem cx.ctxt_all_item_names item.id then\n+                  Hashtbl.add cx.ctxt_user_type_names ty\n+                    (Hashtbl.find cx.ctxt_all_item_names item.id)\n \n           (* \n            * Don't resolve the \"type\" of a mod item; just resolve its\n@@ -880,19 +883,7 @@ let process_crate\n       end;\n     (* Post-resolve, we can establish a tag cache. *)\n     cx.ctxt_tag_cache <- Some (Hashtbl.create 0);\n-    cx.ctxt_rebuild_cache <- Some (Hashtbl.create 0);\n-\n-    (* Also index all the type names for future error messages. *)\n-    Hashtbl.iter\n-      begin\n-        fun item_id ty ->\n-          let item_names = cx.Semant.ctxt_all_item_names in\n-            if Hashtbl.mem item_names item_id then\n-              Hashtbl.add cx.Semant.ctxt_user_type_names ty\n-                (Hashtbl.find item_names item_id)\n-      end\n-      cx.Semant.ctxt_all_type_items;\n-\n+    cx.ctxt_rebuild_cache <- Some (Hashtbl.create 0)\n ;;\n \n (*"}, {"sha": "0bb6a8bbeab724058944d8cf044efd1b4ad0ec0e", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/a7840f02b0eb3d4247c66e5169f7f50e19e70d6d/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=a7840f02b0eb3d4247c66e5169f7f50e19e70d6d", "patch": "@@ -969,6 +969,79 @@ let ty_fold_rebuild (id:Ast.ty -> Ast.ty)\n                              id (Ast.TY_constrained (t, constrs))) }\n ;;\n \n+let rec pretty_ty_str (cx:ctxt) (fallback:(Ast.ty -> string)) (ty:Ast.ty) =\n+  let cache = cx.ctxt_user_type_names in\n+  if Hashtbl.mem cache ty then\n+    let names = List.map (Ast.sprintf_name ()) (Hashtbl.find_all cache ty) in\n+    String.concat \" = \" names\n+  else\n+    match ty with\n+        Ast.TY_vec ty' -> \"vec[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_chan ty' ->\n+          \"chan[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_port ty' ->\n+          \"port[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n+      | Ast.TY_box ty' -> \"@\" ^ (pretty_ty_str cx fallback ty')\n+      | Ast.TY_mutable ty' ->\n+          \"(mutable \" ^ (pretty_ty_str cx fallback ty') ^ \")\"\n+      | Ast.TY_constrained (ty', _) ->\n+          \"(\" ^ (pretty_ty_str cx fallback ty') ^ \" : <constrained>)\"\n+      | Ast.TY_tup tys ->\n+          let tys_str = Array.map (pretty_ty_str cx fallback) tys in\n+          \"tup(\" ^ (String.concat \", \" (Array.to_list tys_str)) ^ \")\"\n+      | Ast.TY_rec fields ->\n+          let format_field (ident, ty') =\n+            ident ^ \"=\" ^ (pretty_ty_str cx fallback ty')\n+          in\n+          let fields = Array.to_list (Array.map format_field fields) in\n+          \"rec(\" ^ (String.concat \", \" fields) ^ \")\"\n+      | Ast.TY_fn (fnsig, _) ->\n+          let format_slot slot =\n+            match slot.Ast.slot_ty with\n+                None -> Common.bug () \"no ty in slot\"\n+              | Some ty' -> pretty_ty_str cx fallback ty'\n+          in\n+          let fn_args = Array.map format_slot fnsig.Ast.sig_input_slots in\n+          let fn_args_str = String.concat \", \" (Array.to_list fn_args) in\n+          let fn_rv_str = format_slot fnsig.Ast.sig_output_slot in\n+          Printf.sprintf \"fn(%s) -> %s\" fn_args_str fn_rv_str\n+      | Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = args } ->\n+          let tag_info = Hashtbl.find cx.ctxt_all_tag_info tag_id in\n+          let tag_idents = tag_info.tag_idents in\n+          let item_id = ref None in\n+          (* Ugly hack ahead... *)\n+          begin\n+            try\n+              Hashtbl.iter\n+                begin\n+                  fun _ (_, item_id', _) ->\n+                    item_id := Some item_id'; raise Exit\n+                end\n+                tag_idents\n+            with Exit -> ();\n+          end;\n+          begin\n+            match !item_id with\n+                None -> fallback ty\n+              | Some item_id ->\n+                  let item_types = cx.ctxt_all_item_types in\n+                  let ty = Hashtbl.find item_types item_id in\n+                  let args_suffix =\n+                    if Array.length args == 0 then \"\"\n+                    else\n+                      Printf.sprintf \"[%s]\"\n+                        (String.concat \",\"\n+                          (Array.to_list\n+                            (Array.map\n+                              (pretty_ty_str cx fallback)\n+                              args)))\n+                  in\n+                  (pretty_ty_str cx fallback ty) ^ args_suffix\n+          end\n+\n+      | _ -> fallback ty (* TODO: we can do better for objects *)\n+;;\n+\n let rec rebuild_ty_under_params\n     (cx:ctxt)\n     (src_tag:Ast.ty_tag option)\n@@ -981,7 +1054,7 @@ let rec rebuild_ty_under_params\n   then\n     err None\n       \"mismatched type-params: %s has %d param(s) but %d given\"\n-      (Ast.sprintf_ty () ty)\n+      (pretty_ty_str cx (Ast.sprintf_ty ()) ty)\n       (Array.length params)\n       (Array.length args)\n   else\n@@ -2679,79 +2752,6 @@ let glue_str (cx:ctxt) (g:glue) : string =\n     | GLUE_vec_grow -> \"glue$vec_grow\"\n ;;\n \n-let rec pretty_ty_str (cx:ctxt) (fallback:(Ast.ty -> string)) (ty:Ast.ty) =\n-  let cache = cx.ctxt_user_type_names in\n-  if Hashtbl.mem cache ty then\n-    let names = List.map (Ast.sprintf_name ()) (Hashtbl.find_all cache ty) in\n-    String.concat \" = \" names\n-  else\n-    match ty with\n-        Ast.TY_vec ty' -> \"vec[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n-      | Ast.TY_chan ty' ->\n-          \"chan[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n-      | Ast.TY_port ty' ->\n-          \"port[\" ^ (pretty_ty_str cx fallback ty') ^ \"]\"\n-      | Ast.TY_box ty' -> \"@\" ^ (pretty_ty_str cx fallback ty')\n-      | Ast.TY_mutable ty' ->\n-          \"(mutable \" ^ (pretty_ty_str cx fallback ty') ^ \")\"\n-      | Ast.TY_constrained (ty', _) ->\n-          \"(\" ^ (pretty_ty_str cx fallback ty') ^ \" : <constrained>)\"\n-      | Ast.TY_tup tys ->\n-          let tys_str = Array.map (pretty_ty_str cx fallback) tys in\n-          \"tup(\" ^ (String.concat \", \" (Array.to_list tys_str)) ^ \")\"\n-      | Ast.TY_rec fields ->\n-          let format_field (ident, ty') =\n-            ident ^ \"=\" ^ (pretty_ty_str cx fallback ty')\n-          in\n-          let fields = Array.to_list (Array.map format_field fields) in\n-          \"rec(\" ^ (String.concat \", \" fields) ^ \")\"\n-      | Ast.TY_fn (fnsig, _) ->\n-          let format_slot slot =\n-            match slot.Ast.slot_ty with\n-                None -> Common.bug () \"no ty in slot\"\n-              | Some ty' -> pretty_ty_str cx fallback ty'\n-          in\n-          let fn_args = Array.map format_slot fnsig.Ast.sig_input_slots in\n-          let fn_args_str = String.concat \", \" (Array.to_list fn_args) in\n-          let fn_rv_str = format_slot fnsig.Ast.sig_output_slot in\n-          Printf.sprintf \"fn(%s) -> %s\" fn_args_str fn_rv_str\n-      | Ast.TY_tag { Ast.tag_id = tag_id; Ast.tag_args = args } ->\n-          let tag_info = Hashtbl.find cx.ctxt_all_tag_info tag_id in\n-          let tag_idents = tag_info.tag_idents in\n-          let item_id = ref None in\n-          (* Ugly hack ahead... *)\n-          begin\n-            try\n-              Hashtbl.iter\n-                begin\n-                  fun _ (_, item_id', _) ->\n-                    item_id := Some item_id'; raise Exit\n-                end\n-                tag_idents\n-            with Exit -> ();\n-          end;\n-          begin\n-            match !item_id with\n-                None -> fallback ty\n-              | Some item_id ->\n-                  let item_types = cx.ctxt_all_item_types in\n-                  let ty = Hashtbl.find item_types item_id in\n-                  let args_suffix =\n-                    if Array.length args == 0 then \"\"\n-                    else\n-                      Printf.sprintf \"[%s]\"\n-                        (String.concat \",\"\n-                          (Array.to_list\n-                            (Array.map\n-                              (pretty_ty_str cx fallback)\n-                              args)))\n-                  in\n-                  (pretty_ty_str cx fallback ty) ^ args_suffix\n-          end\n-\n-      | _ -> fallback ty (* TODO: we can do better for objects *)\n-;;\n-\n (*\n  * Local Variables:\n  * fill-column: 78;"}]}