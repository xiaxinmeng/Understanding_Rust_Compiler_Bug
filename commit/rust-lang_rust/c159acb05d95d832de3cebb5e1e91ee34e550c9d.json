{"sha": "c159acb05d95d832de3cebb5e1e91ee34e550c9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNTlhY2IwNWQ5NWQ4MzJkZTNjZWJiNWUxZTkxZWUzNGU1NTBjOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T21:31:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T21:31:19Z"}, "message": "auto merge of #10568 : pcwalton/rust/more-bars, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "5663e1c00b8b8a4aad67b706807900f43a2ea600", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5663e1c00b8b8a4aad67b706807900f43a2ea600"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c159acb05d95d832de3cebb5e1e91ee34e550c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c159acb05d95d832de3cebb5e1e91ee34e550c9d", "html_url": "https://github.com/rust-lang/rust/commit/c159acb05d95d832de3cebb5e1e91ee34e550c9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c159acb05d95d832de3cebb5e1e91ee34e550c9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eef913b290f668b4f131ead5be65a1615616426b", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef913b290f668b4f131ead5be65a1615616426b", "html_url": "https://github.com/rust-lang/rust/commit/eef913b290f668b4f131ead5be65a1615616426b"}, {"sha": "7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "html_url": "https://github.com/rust-lang/rust/commit/7e3f20133a0f38e4f18dce9992d1b4c13215f91f"}], "stats": {"total": 1802, "additions": 931, "deletions": 871}, "files": [{"sha": "4660036a774e093ff7839b58b51de68f720bff60", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -220,7 +220,7 @@ impl<T:Send> MutexArc<T> {\n      * blocked on the mutex) will also fail immediately.\n      */\n     #[inline]\n-    pub unsafe fn unsafe_access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn unsafe_access<U>(&self, blk: |x: &mut T| -> U) -> U {\n         let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n@@ -234,8 +234,7 @@ impl<T:Send> MutexArc<T> {\n     /// As unsafe_access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline]\n     pub unsafe fn unsafe_access_cond<U>(&self,\n-                                        blk: &fn(x: &mut T,\n-                                                 c: &Condvar) -> U)\n+                                        blk: |x: &mut T, c: &Condvar| -> U)\n                                         -> U {\n         let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n@@ -284,15 +283,14 @@ impl<T:Freeze + Send> MutexArc<T> {\n      * unsafe_access_cond.\n      */\n     #[inline]\n-    pub fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn access<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe { self.unsafe_access(blk) }\n     }\n \n     /// As unsafe_access_cond but safe and Freeze.\n     #[inline]\n     pub fn access_cond<U>(&self,\n-                          blk: &fn(x: &mut T,\n-                                   c: &Condvar) -> U)\n+                          blk: |x: &mut T, c: &Condvar| -> U)\n                           -> U {\n         unsafe { self.unsafe_access_cond(blk) }\n     }\n@@ -389,7 +387,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * poison the Arc, so subsequent readers and writers will both also fail.\n      */\n     #[inline]\n-    pub fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&self, blk: |x: &mut T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n@@ -403,7 +401,7 @@ impl<T:Freeze + Send> RWArc<T> {\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline]\n     pub fn write_cond<U>(&self,\n-                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         blk: |x: &mut T, c: &Condvar| -> U)\n                          -> U {\n         unsafe {\n             let state = self.x.get();\n@@ -427,7 +425,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * Failing will unlock the Arc while unwinding. However, unlike all other\n      * access modes, this will not poison the Arc.\n      */\n-    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*state).lock.read {\n@@ -457,7 +455,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      * }\n      * ```\n      */\n-    pub fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {\n         unsafe {\n             let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n@@ -539,7 +537,7 @@ pub struct RWReadMode<'self, T> {\n \n impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWArc in write mode.\n-    pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n+    pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n         match *self {\n             RWWriteMode {\n                 data: &ref mut data,\n@@ -555,7 +553,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n \n     /// Access the pre-downgrade RWArc in write mode with a condvar.\n     pub fn write_cond<U>(&mut self,\n-                         blk: &fn(x: &mut T, c: &Condvar) -> U)\n+                         blk: |x: &mut T, c: &Condvar| -> U)\n                          -> U {\n         match *self {\n             RWWriteMode {\n@@ -580,7 +578,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n \n impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n+    pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         match *self {\n             RWReadMode {\n                 data: data,"}, {"sha": "2bb36e25fcb04afba523f382f6797b5c90a809a9", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -184,7 +184,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_pod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_pod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -241,7 +241,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_nonpod<'a, T>(&'a mut self, op: &fn() -> T) -> &'a T {\n+    fn alloc_nonpod<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n@@ -263,7 +263,7 @@ impl Arena {\n \n     // The external interface\n     #[inline]\n-    pub fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+    pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n             // XXX: Borrow check\n             let this = transmute_mut(self);"}, {"sha": "c68133dac10106e361885b9430561957828b3584", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -40,7 +40,7 @@ impl SmallBitv {\n     pub fn bits_op(&mut self,\n                    right_bits: uint,\n                    nbits: uint,\n-                   f: &fn(uint, uint) -> uint)\n+                   f: |uint, uint| -> uint)\n                    -> bool {\n         let mask = small_mask(nbits);\n         let old_b: uint = self.bits;\n@@ -140,7 +140,7 @@ impl BigBitv {\n     pub fn process(&mut self,\n                    b: &BigBitv,\n                    nbits: uint,\n-                   op: &fn(uint, uint) -> uint)\n+                   op: |uint, uint| -> uint)\n                    -> bool {\n         let len = b.storage.len();\n         assert_eq!(self.storage.len(), len);\n@@ -161,7 +161,7 @@ impl BigBitv {\n     }\n \n     #[inline]\n-    pub fn each_storage(&mut self, op: &fn(v: &mut uint) -> bool) -> bool {\n+    pub fn each_storage(&mut self, op: |v: &mut uint| -> bool) -> bool {\n         self.storage.mut_iter().advance(|elt| op(elt))\n     }\n \n@@ -512,7 +512,7 @@ impl Bitv {\n         true\n     }\n \n-    pub fn ones(&self, f: &fn(uint) -> bool) -> bool {\n+    pub fn ones(&self, f: |uint| -> bool) -> bool {\n         range(0u, self.nbits).advance(|i| !self.get(i) || f(i))\n     }\n \n@@ -542,7 +542,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * Create a `Bitv` of the specified length where the value at each\n  * index is `f(index)`.\n  */\n-pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n+pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n     for i in range(0u, len) {\n         bitv.set(i, f(i));\n@@ -557,7 +557,7 @@ impl ops::Index<uint,bool> for Bitv {\n }\n \n #[inline]\n-fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n+fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -675,7 +675,7 @@ impl BitvSet {\n     }\n \n     #[inline]\n-    fn other_op(&mut self, other: &BitvSet, f: &fn(uint, uint) -> uint) {\n+    fn other_op(&mut self, other: &BitvSet, f: |uint, uint| -> uint) {\n         fn nbits(mut w: uint) -> uint {\n             let mut bits = 0;\n             for _ in range(0u, uint::bits) {\n@@ -722,7 +722,7 @@ impl BitvSet {\n         BitvSetIterator {set: self, next_idx: 0}\n     }\n \n-    pub fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn difference(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return false\n@@ -734,8 +734,8 @@ impl BitvSet {\n         )\n     }\n \n-    pub fn symmetric_difference(&self, other: &BitvSet,\n-                            f: &fn(&uint) -> bool) -> bool {\n+    pub fn symmetric_difference(&self, other: &BitvSet, f: |&uint| -> bool)\n+                                -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n                 return false\n@@ -744,11 +744,11 @@ impl BitvSet {\n         self.outlier_iter(other).advance(|(_, i, w)| iterate_bits(i, w, |b| f(&b)))\n     }\n \n-    pub fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn intersection(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         self.common_iter(other).advance(|(i, w1, w2)| iterate_bits(i, w1 & w2, |b| f(&b)))\n     }\n \n-    pub fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) -> bool {\n+    pub fn union(&self, other: &BitvSet, f: |&uint| -> bool) -> bool {\n         for (i, w1, w2) in self.common_iter(other) {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return false"}, {"sha": "418b8256189f940178413acd2921272bf4ea5253", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -320,7 +320,7 @@ impl<T> DList<T> {\n     /// or at the end.\n     ///\n     /// O(N)\n-    pub fn insert_when(&mut self, elt: T, f: &fn(&T, &T) -> bool) {\n+    pub fn insert_when(&mut self, elt: T, f: |&T, &T| -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {\n@@ -339,7 +339,7 @@ impl<T> DList<T> {\n     /// put `a` in the result if `f(a, b)` is true, else `b`.\n     ///\n     /// O(max(N, M))\n-    pub fn merge(&mut self, mut other: DList<T>, f: &fn(&T, &T) -> bool) {\n+    pub fn merge(&mut self, mut other: DList<T>, f: |&T, &T| -> bool) {\n         {\n             let mut it = self.mut_iter();\n             loop {"}, {"sha": "c82ee733a4cbe90f43be6cf588e7ef51f6391878", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -216,7 +216,7 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs(d: Doc, it: &fn(uint, Doc) -> bool) -> bool {\n+    pub fn docs(d: Doc, it: |uint, Doc| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -230,7 +230,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs(d: Doc, tg: uint, it: &fn(Doc) -> bool) -> bool {\n+    pub fn tagged_docs(d: Doc, tg: uint, it: |Doc| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = vuint_at(*d.data, pos);\n@@ -247,7 +247,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn with_doc_data<T>(d: Doc, f: &fn(x: &[u8]) -> T) -> T {\n+    pub fn with_doc_data<T>(d: Doc, f: |x: &[u8]| -> T) -> T {\n         f(d.data.slice(d.start, d.end))\n     }\n \n@@ -332,7 +332,7 @@ pub mod reader {\n         }\n \n         fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: &fn(&mut Decoder) -> T) -> T {\n+                       f: |&mut Decoder| -> T) -> T {\n             let d = self.next_doc(exp_tag);\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -352,8 +352,7 @@ pub mod reader {\n     }\n \n     impl Decoder {\n-        pub fn read_opaque<R>(&mut self, op: &fn(&mut Decoder, Doc) -> R)\n-                              -> R {\n+        pub fn read_opaque<R>(&mut self, op: |&mut Decoder, Doc| -> R) -> R {\n             let doc = self.next_doc(EsOpaque);\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -424,10 +423,7 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self,\n-                        name: &str,\n-                        f: &fn(&mut Decoder) -> T)\n-                        -> T {\n+        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n             debug!(\"read_enum({})\", name);\n             self._check_label(name);\n \n@@ -446,7 +442,7 @@ pub mod reader {\n \n         fn read_enum_variant<T>(&mut self,\n                                 _: &[&str],\n-                                f: &fn(&mut Decoder, uint) -> T)\n+                                f: |&mut Decoder, uint| -> T)\n                                 -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -467,14 +463,14 @@ pub mod reader {\n \n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: &fn(&mut Decoder) -> T) -> T {\n+                                    f: |&mut Decoder| -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n-                                       f: &fn(&mut Decoder, uint) -> T)\n+                                       f: |&mut Decoder, uint| -> T)\n                                        -> T {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -496,7 +492,7 @@ pub mod reader {\n         fn read_enum_struct_variant_field<T>(&mut self,\n                                              name: &str,\n                                              idx: uint,\n-                                             f: &fn(&mut Decoder) -> T)\n+                                             f: |&mut Decoder| -> T)\n                                              -> T {\n             debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n@@ -505,7 +501,7 @@ pub mod reader {\n         fn read_struct<T>(&mut self,\n                           name: &str,\n                           _: uint,\n-                          f: &fn(&mut Decoder) -> T)\n+                          f: |&mut Decoder| -> T)\n                           -> T {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n@@ -514,41 +510,41 @@ pub mod reader {\n         fn read_struct_field<T>(&mut self,\n                                 name: &str,\n                                 idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+                                f: |&mut Decoder| -> T)\n                                 -> T {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                              -> T {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n-                                f: &fn(&mut Decoder, uint) -> T)\n+                                f: |&mut Decoder, uint| -> T)\n                                 -> T {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: &fn(&mut Decoder) -> T)\n+                                    f: |&mut Decoder| -> T)\n                                     -> T {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+        fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n             debug!(\"read_option()\");\n             do self.read_enum(\"Option\") |this| {\n                 do this.read_enum_variant([\"None\", \"Some\"]) |this, idx| {\n@@ -561,7 +557,7 @@ pub mod reader {\n             }\n         }\n \n-        fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_seq()\");\n             do self.push_doc(EsVec) |d| {\n                 let len = d._next_uint(EsVecLen);\n@@ -570,13 +566,13 @@ pub mod reader {\n             }\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+        fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n             debug!(\"read_map()\");\n             do self.push_doc(EsMap) |d| {\n                 let len = d._next_uint(EsMapLen);\n@@ -585,17 +581,13 @@ pub mod reader {\n             }\n         }\n \n-        fn read_map_elt_key<T>(&mut self,\n-                               idx: uint,\n-                               f: &fn(&mut Decoder) -> T)\n+        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                -> T {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self,\n-                               idx: uint,\n-                               f: &fn(&mut Decoder) -> T)\n+        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                -> T {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n@@ -682,7 +674,7 @@ pub mod writer {\n             debug!(\"End tag (size = {})\", size);\n         }\n \n-        pub fn wr_tag(&mut self, tag_id: uint, blk: &fn()) {\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: ||) {\n             self.start_tag(tag_id);\n             blk();\n             self.end_tag();\n@@ -779,7 +771,7 @@ pub mod writer {\n     }\n \n     impl Encoder {\n-        pub fn emit_opaque(&mut self, f: &fn(&mut Encoder)) {\n+        pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n             self.start_tag(EsOpaque as uint);\n             f(self);\n             self.end_tag();\n@@ -841,7 +833,7 @@ pub mod writer {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self, name: &str, f: &fn(&mut Encoder)) {\n+        fn emit_enum(&mut self, name: &str, f: |&mut Encoder|) {\n             self._emit_label(name);\n             self.start_tag(EsEnum as uint);\n             f(self);\n@@ -852,98 +844,98 @@ pub mod writer {\n                              _: &str,\n                              v_id: uint,\n                              _: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.start_tag(EsEnumBody as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_enum_variant_arg(&mut self, _: uint, f: &fn(&mut Encoder)) {\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder|) {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant(&mut self,\n                                     v_name: &str,\n                                     v_id: uint,\n                                     cnt: uint,\n-                                    f: &fn(&mut Encoder)) {\n+                                    f: |&mut Encoder|) {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n         fn emit_enum_struct_variant_field(&mut self,\n                                           _: &str,\n                                           idx: uint,\n-                                          f: &fn(&mut Encoder)) {\n+                                          f: |&mut Encoder|) {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct(&mut self, _: &str, _len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_struct(&mut self, _: &str, _len: uint, f: |&mut Encoder|) {\n             f(self)\n         }\n \n         fn emit_struct_field(&mut self,\n                              name: &str,\n                              _: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self._emit_label(name);\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct(&mut self,\n                              _: &str,\n                              len: uint,\n-                             f: &fn(&mut Encoder)) {\n+                             f: |&mut Encoder|) {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self, f: &fn(&mut Encoder)) {\n+        fn emit_option(&mut self, f: |&mut Encoder|) {\n             self.emit_enum(\"Option\", f);\n         }\n         fn emit_option_none(&mut self) {\n             self.emit_enum_variant(\"None\", 0, 0, |_| ())\n         }\n-        fn emit_option_some(&mut self, f: &fn(&mut Encoder)) {\n+        fn emit_option_some(&mut self, f: |&mut Encoder|) {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_seq(&mut self, len: uint, f: |&mut Encoder|) {\n             self.start_tag(EsVec as uint);\n             self._emit_tagged_uint(EsVecLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsVecElt as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map(&mut self, len: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMap as uint);\n             self._emit_tagged_uint(EsMapLen, len);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMapKey as uint);\n             f(self);\n             self.end_tag();\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n             self.start_tag(EsMapVal as uint);\n             f(self);\n             self.end_tag();"}, {"sha": "d0df9dbe8383221f3f1932d46e2fc2939a88f1dd", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -768,9 +768,8 @@ pub mod groups {\n     ///\n     /// Fails during iteration if the string contains a non-whitespace\n     /// sequence longer than the limit.\n-    fn each_split_within<'a>(ss: &'a str,\n-                             lim: uint,\n-                             it: &fn(&'a str) -> bool) -> bool {\n+    fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n+                         -> bool {\n         // Just for fun, let's write this as a state machine:\n \n         enum SplitWithinState {\n@@ -795,14 +794,14 @@ pub mod groups {\n         let mut lim = lim;\n \n         let mut cont = true;\n-        let slice: &fn() = || { cont = it(ss.slice(slice_start, last_end)) };\n+        let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n \n         // if the limit is larger than the string, lower it to save cycles\n         if (lim >= fake_i) {\n             lim = fake_i;\n         }\n \n-        let machine: &fn((uint, char)) -> bool = |(i, c)| {\n+        let machine: |(uint, char)| -> bool = |(i, c)| {\n             let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n             let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n "}, {"sha": "64655ca2b70f87c02b90e9e86d883f79f4ef0da4", "filename": "src/libextra/json.rs", "status": "modified", "additions": 54, "deletions": 61, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -129,13 +129,13 @@ impl serialize::Encoder for Encoder {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: &fn(&mut Encoder)) { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder|) { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -150,7 +150,7 @@ impl serialize::Encoder for Encoder {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n@@ -161,18 +161,18 @@ impl serialize::Encoder for Encoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: &fn(&mut Encoder)) {\n+                                f: |&mut Encoder|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: &fn(&mut Encoder)) {\n+                                      f: |&mut Encoder|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: &fn(&mut Encoder)) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n@@ -181,58 +181,58 @@ impl serialize::Encoder for Encoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: &fn(&mut Encoder)) {\n+                         f: |&mut Encoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: &fn(&mut Encoder)) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder|) { f(self); }\n \n-    fn emit_seq(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder|) {\n         write!(self.wr, \"[\");\n         f(self);\n         write!(self.wr, \"]\");\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut Encoder)) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder|) {\n         write!(self.wr, \":\");\n         f(self)\n     }\n@@ -284,15 +284,15 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n-    fn emit_enum(&mut self, _name: &str, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder|) {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         if cnt == 0 {\n             write!(self.wr, \"{}\", escape_str(name));\n         } else {\n@@ -306,7 +306,7 @@ impl serialize::Encoder for PrettyEncoder {\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: &fn(&mut PrettyEncoder)) {\n+                             f: |&mut PrettyEncoder|) {\n         if idx != 0 {\n             write!(self.wr, \",\\n\");\n         }\n@@ -318,22 +318,22 @@ impl serialize::Encoder for PrettyEncoder {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: &fn(&mut PrettyEncoder)) {\n+                                f: |&mut PrettyEncoder|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: &fn(&mut PrettyEncoder)) {\n+                                      f: |&mut PrettyEncoder|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: &fn(&mut PrettyEncoder)) {\n+                   f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -348,7 +348,7 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -358,30 +358,30 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: &fn(&mut PrettyEncoder)) {\n+                         f: |&mut PrettyEncoder|) {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: &fn(&mut PrettyEncoder)) {\n+                             f: |&mut PrettyEncoder|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: &fn(&mut PrettyEncoder)) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder|) { f(self); }\n \n-    fn emit_seq(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"[]\");\n         } else {\n@@ -393,7 +393,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -403,7 +403,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -415,7 +415,7 @@ impl serialize::Encoder for PrettyEncoder {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -425,7 +425,7 @@ impl serialize::Encoder for PrettyEncoder {\n         f(self);\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut PrettyEncoder)) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder|) {\n         write!(self.wr, \": \");\n         f(self);\n     }\n@@ -921,14 +921,14 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Decoder) -> T) -> T {\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: &fn(&mut Decoder, uint) -> T)\n+                            f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n@@ -957,17 +957,15 @@ impl serialize::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&mut self,\n-                                idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                                 -> T {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: &fn(&mut Decoder, uint) -> T)\n+                                   f: |&mut Decoder, uint| -> T)\n                                    -> T {\n         debug!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n@@ -977,7 +975,7 @@ impl serialize::Decoder for Decoder {\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          name: &str,\n                                          idx: uint,\n-                                         f: &fn(&mut Decoder) -> T)\n+                                         f: |&mut Decoder| -> T)\n                                          -> T {\n         debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n@@ -986,7 +984,7 @@ impl serialize::Decoder for Decoder {\n     fn read_struct<T>(&mut self,\n                       name: &str,\n                       len: uint,\n-                      f: &fn(&mut Decoder) -> T)\n+                      f: |&mut Decoder| -> T)\n                       -> T {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n@@ -997,7 +995,7 @@ impl serialize::Decoder for Decoder {\n     fn read_struct_field<T>(&mut self,\n                             name: &str,\n                             idx: uint,\n-                            f: &fn(&mut Decoder) -> T)\n+                            f: |&mut Decoder| -> T)\n                             -> T {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n@@ -1017,43 +1015,40 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n-    fn read_tuple<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n-    fn read_tuple_arg<T>(&mut self,\n-                         idx: uint,\n-                         f: &fn(&mut Decoder) -> T)\n-                         -> T {\n+    fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n-                            f: &fn(&mut Decoder, uint) -> T)\n+                            f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n-                                f: &fn(&mut Decoder) -> T)\n+                                f: |&mut Decoder| -> T)\n                                 -> T {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&mut self, f: &fn(&mut Decoder, bool) -> T) -> T {\n+    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n         match self.stack.pop() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_seq()\");\n         let len = match self.stack.pop() {\n             List(list) => {\n@@ -1068,12 +1063,12 @@ impl serialize::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T) -> T {\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map<T>(&mut self, f: &fn(&mut Decoder, uint) -> T) -> T {\n+    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_map()\");\n         let len = match self.stack.pop() {\n             Object(obj) => {\n@@ -1089,15 +1084,13 @@ impl serialize::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&mut self,\n-                           idx: uint,\n-                           f: &fn(&mut Decoder) -> T)\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Decoder) -> T)\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n                            -> T {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n@@ -1482,7 +1475,7 @@ mod tests {\n         assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n     }\n \n-    fn with_str_writer(f: &fn(@mut io::Writer)) -> ~str {\n+    fn with_str_writer(f: |@mut io::Writer|) -> ~str {\n         use std::io::mem::MemWriter;\n         use std::io::Decorator;\n         use std::str;"}, {"sha": "22d273e5747cd7d972ca05db6e693a54935fa36d", "filename": "src/libextra/list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -44,7 +44,7 @@ pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n+pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -57,7 +57,7 @@ pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub fn find<T:Clone>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n+pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -131,7 +131,7 @@ fn push<T:Clone>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n+pub fn iter<T>(l: @List<T>, f: |&T|) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -145,7 +145,7 @@ pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n-pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n+pub fn each<T>(l: @List<T>, f: |&T| -> bool) -> bool {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -160,7 +160,7 @@ pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) -> bool {\n \n impl<T> MutList<T> {\n     /// Iterate over a mutable list\n-    pub fn each(@mut self, f: &fn(&mut T) -> bool) -> bool {\n+    pub fn each(@mut self, f: |&mut T| -> bool) -> bool {\n         let mut cur = self;\n         loop {\n             let borrowed = &mut *cur;"}, {"sha": "3de71c83c49bed706554c321cc1004a5981033bc", "filename": "src/libextra/semver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsemver.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -145,8 +145,8 @@ condition! {\n     bad_parse: () -> ();\n }\n \n-fn take_nonempty_prefix<T: Iterator<char>>(rdr: &mut T,\n-                        pred: &fn(char) -> bool) -> (~str, Option<char>) {\n+fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n+                        -> (~str, Option<char>) {\n     let mut buf = ~\"\";\n     let mut ch = rdr.next();\n     loop {"}, {"sha": "8e75be651cfa604ce4cb12b6440514eea619a5c7", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -47,48 +47,48 @@ pub trait Encoder {\n     fn emit_str(&mut self, v: &str);\n \n     // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: &fn(&mut Self));\n+    fn emit_enum(&mut self, name: &str, f: |&mut Self|);\n \n     fn emit_enum_variant(&mut self,\n                          v_name: &str,\n                          v_id: uint,\n                          len: uint,\n-                         f: &fn(&mut Self));\n-    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: &fn(&mut Self));\n+                         f: |&mut Self|);\n+    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: |&mut Self|);\n \n     fn emit_enum_struct_variant(&mut self,\n                                 v_name: &str,\n                                 v_id: uint,\n                                 len: uint,\n-                                f: &fn(&mut Self));\n+                                f: |&mut Self|);\n     fn emit_enum_struct_variant_field(&mut self,\n                                       f_name: &str,\n                                       f_idx: uint,\n-                                      f: &fn(&mut Self));\n+                                      f: |&mut Self|);\n \n-    fn emit_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n+    fn emit_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n     fn emit_struct_field(&mut self,\n                          f_name: &str,\n                          f_idx: uint,\n-                         f: &fn(&mut Self));\n+                         f: |&mut Self|);\n \n-    fn emit_tuple(&mut self, len: uint, f: &fn(&mut Self));\n-    fn emit_tuple_arg(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self|);\n \n-    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: &fn(&mut Self));\n-    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: &fn(&mut Self));\n+    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n+    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: |&mut Self|);\n \n     // Specialized types:\n-    fn emit_option(&mut self, f: &fn(&mut Self));\n+    fn emit_option(&mut self, f: |&mut Self|);\n     fn emit_option_none(&mut self);\n-    fn emit_option_some(&mut self, f: &fn(&mut Self));\n+    fn emit_option_some(&mut self, f: |&mut Self|);\n \n-    fn emit_seq(&mut self, len: uint, f: &fn(this: &mut Self));\n-    fn emit_seq_elt(&mut self, idx: uint, f: &fn(this: &mut Self));\n+    fn emit_seq(&mut self, len: uint, f: |this: &mut Self|);\n+    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self|);\n \n-    fn emit_map(&mut self, len: uint, f: &fn(&mut Self));\n-    fn emit_map_elt_key(&mut self, idx: uint, f: &fn(&mut Self));\n-    fn emit_map_elt_val(&mut self, idx: uint, f: &fn(&mut Self));\n+    fn emit_map(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self|);\n+    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self|);\n }\n \n pub trait Decoder {\n@@ -111,59 +111,56 @@ pub trait Decoder {\n     fn read_str(&mut self) -> ~str;\n \n     // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: &fn(&mut Self) -> T) -> T;\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> T) -> T;\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: &fn(&mut Self, uint) -> T)\n+                            f: |&mut Self, uint| -> T)\n                             -> T;\n     fn read_enum_variant_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: &fn(&mut Self) -> T)\n+                                f: |&mut Self| -> T)\n                                 -> T;\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: &fn(&mut Self, uint) -> T)\n+                                   f: |&mut Self, uint| -> T)\n                                    -> T;\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          &f_name: &str,\n                                          f_idx: uint,\n-                                         f: &fn(&mut Self) -> T)\n+                                         f: |&mut Self| -> T)\n                                          -> T;\n \n-    fn read_struct<T>(&mut self,\n-                      s_name: &str,\n-                      len: uint,\n-                      f: &fn(&mut Self) -> T)\n+    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> T)\n                       -> T;\n     fn read_struct_field<T>(&mut self,\n                             f_name: &str,\n                             f_idx: uint,\n-                            f: &fn(&mut Self) -> T)\n+                            f: |&mut Self| -> T)\n                             -> T;\n \n-    fn read_tuple<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> T) -> T;\n \n     fn read_tuple_struct<T>(&mut self,\n                             s_name: &str,\n-                            f: &fn(&mut Self, uint) -> T)\n+                            f: |&mut Self, uint| -> T)\n                             -> T;\n     fn read_tuple_struct_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: &fn(&mut Self) -> T)\n+                                f: |&mut Self| -> T)\n                                 -> T;\n \n     // Specialized types:\n-    fn read_option<T>(&mut self, f: &fn(&mut Self, bool) -> T) -> T;\n+    fn read_option<T>(&mut self, f: |&mut Self, bool| -> T) -> T;\n \n-    fn read_seq<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n \n-    fn read_map<T>(&mut self, f: &fn(&mut Self, uint) -> T) -> T;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: &fn(&mut Self) -> T) -> T;\n+    fn read_map<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n }\n \n pub trait Encodable<S:Encoder> {\n@@ -892,11 +889,11 @@ impl<\n // In some cases, these should eventually be coded as traits.\n \n pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut Self, v: &T));\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut Self, v: &T|);\n }\n \n impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n         do self.emit_seq(v.len()) |this| {\n             for (i, e) in v.iter().enumerate() {\n                 do this.emit_seq_elt(i) |this| {\n@@ -908,11 +905,11 @@ impl<S:Encoder> EncoderHelpers for S {\n }\n \n pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&mut self, f: &fn(&mut Self) -> T) -> ~[T];\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> T) -> ~[T];\n }\n \n impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&mut self, f: &fn(&mut D) -> T) -> ~[T] {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n         do self.read_seq |this, len| {\n             do vec::from_fn(len) |i| {\n                 this.read_seq_elt(i, |this| f(this))"}, {"sha": "119988735a75e07314303f2e1d6cc4746fcb47f4", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -164,17 +164,19 @@ impl<V> SmallIntMap<V> {\n }\n \n impl<V:Clone> SmallIntMap<V> {\n-    pub fn update_with_key(&mut self, key: uint, val: V,\n-                           ff: &fn(uint, V, V) -> V) -> bool {\n+    pub fn update_with_key(&mut self,\n+                           key: uint,\n+                           val: V,\n+                           ff: |uint, V, V| -> V)\n+                           -> bool {\n         let new_val = match self.find(&key) {\n             None => val,\n             Some(orig) => ff(key, (*orig).clone(), val)\n         };\n         self.insert(key, new_val)\n     }\n \n-    pub fn update(&mut self, key: uint, newval: V, ff: &fn(V, V) -> V)\n-                  -> bool {\n+    pub fn update(&mut self, key: uint, newval: V, ff: |V, V| -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }\n }"}, {"sha": "f01eb7ef2afe9267089cf6f034abe4e26f517ef5", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -133,7 +133,7 @@ impl<Q:Send> Sem<Q> {\n         }\n     }\n \n-    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn access<U>(&self, blk: || -> U) -> U {\n         do task::unkillable {\n             do (|| {\n                 self.acquire();\n@@ -305,8 +305,12 @@ impl<'self> Condvar<'self> {\n // something else next on success.\n #[inline]\n #[doc(hidden)]\n-fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n-                        blk: &fn() -> U) -> U {\n+fn check_cvar_bounds<U>(\n+                     out_of_bounds: Option<uint>,\n+                     id: uint,\n+                     act: &str,\n+                     blk: || -> U)\n+                     -> U {\n     match out_of_bounds {\n         Some(0) =>\n             fail!(\"{} with illegal ID {} - this lock has no condvars!\", act, id),\n@@ -320,7 +324,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n impl Sem<~[WaitQueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n-    pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn access_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         do self.access {\n             blk(&Condvar { sem: self, order: Nothing, token: NonCopyable::new() })\n         }\n@@ -361,7 +365,7 @@ impl Semaphore {\n     pub fn release(&self) { (&self.sem).release() }\n \n     /// Run a function with ownership of one of the semaphore's resources.\n-    pub fn access<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn access<U>(&self, blk: || -> U) -> U { (&self.sem).access(blk) }\n }\n \n /****************************************************************************\n@@ -399,12 +403,12 @@ impl Mutex {\n \n \n     /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn lock<U>(&self, blk: || -> U) -> U {\n         (&self.sem).access(blk)\n     }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn lock_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -478,7 +482,7 @@ impl RWLock {\n      * Run a function with the rwlock in read mode. Calls to 'read' from other\n      * tasks may run concurrently with this one.\n      */\n-    pub fn read<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn read<U>(&self, blk: || -> U) -> U {\n         unsafe {\n             do task::unkillable {\n                 do (&self.order_lock).access {\n@@ -513,7 +517,7 @@ impl RWLock {\n      * Run a function with the rwlock in write mode. No calls to 'read' or\n      * 'write' from other tasks will run concurrently with this one.\n      */\n-    pub fn write<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn write<U>(&self, blk: || -> U) -> U {\n         do task::unkillable {\n             (&self.order_lock).acquire();\n             do (&self.access_lock).access {\n@@ -531,7 +535,7 @@ impl RWLock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // It's important to thread our order lock into the condvar, so that\n         // when a cond.wait() wakes up, it uses it while reacquiring the\n         // access lock. If we permitted a waking-up writer to \"cut in line\",\n@@ -592,7 +596,7 @@ impl RWLock {\n      * }\n      * ```\n      */\n-    pub fn write_downgrade<U>(&self, blk: &fn(v: RWLockWriteMode) -> U) -> U {\n+    pub fn write_downgrade<U>(&self, blk: |v: RWLockWriteMode| -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         do task::unkillable {\n@@ -671,9 +675,9 @@ pub struct RWLockReadMode<'self> { priv lock: &'self RWLock,\n \n impl<'self> RWLockWriteMode<'self> {\n     /// Access the pre-downgrade rwlock in write mode.\n-    pub fn write<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn write<U>(&self, blk: || -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    pub fn write_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n+    pub fn write_cond<U>(&self, blk: |c: &Condvar| -> U) -> U {\n         // Need to make the condvar use the order lock when reacquiring the\n         // access lock. See comment in RWLock::write_cond for why.\n         blk(&Condvar { sem:        &self.lock.access_lock,\n@@ -684,7 +688,7 @@ impl<'self> RWLockWriteMode<'self> {\n \n impl<'self> RWLockReadMode<'self> {\n     /// Access the post-downgrade rwlock in read mode.\n-    pub fn read<U>(&self, blk: &fn() -> U) -> U { blk() }\n+    pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n }\n \n /****************************************************************************\n@@ -1060,7 +1064,7 @@ mod tests {\n     #[cfg(test)]\n     pub enum RWLockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: &fn()) {\n+    fn lock_rwlock_in_mode(x: &RWLock, mode: RWLockMode, blk: ||) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1221,7 +1225,7 @@ mod tests {\n                                              dg1: bool,\n                                              dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &RWLock, downgrade: bool, blk: &fn(c: &Condvar)) {\n+        fn lock_cond(x: &RWLock, downgrade: bool, blk: |c: &Condvar|) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     do mode.write_cond |c| { blk(c) }"}, {"sha": "37deba43e3a15afb388401786ac158be05fabb0b", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -49,7 +49,7 @@ impl<T> TaskPool<T> {\n     /// local data to be kept around in that task.\n     pub fn new(n_tasks: uint,\n                opt_sched_mode: Option<SchedMode>,\n-               init_fn_factory: &fn() -> proc(uint) -> T)\n+               init_fn_factory: || -> proc(uint) -> T)\n                -> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n@@ -97,7 +97,7 @@ impl<T> TaskPool<T> {\n \n #[test]\n fn test_task_pool() {\n-    let f: &fn() -> proc(uint) -> uint = || {\n+    let f: || -> proc(uint) -> uint = || {\n         let g: proc(uint) -> uint = |i| i;\n         g\n     };"}, {"sha": "e9f38471d48629db0d0a632e47816e626cb21da9", "filename": "src/libextra/test.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -715,8 +715,7 @@ type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n              tests: ~[TestDescAndFn],\n-             callback: &fn(e: TestEvent)) {\n-\n+             callback: |e: TestEvent|) {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.map(|t| t.desc.clone());\n \n@@ -1058,7 +1057,7 @@ impl MetricMap {\n \n impl BenchHarness {\n     /// Callback for benchmark functions to run in their body.\n-    pub fn iter(&mut self, inner:&fn()) {\n+    pub fn iter(&mut self, inner: ||) {\n         self.ns_start = precise_time_ns();\n         let k = self.iterations;\n         for _ in range(0u64, k) {\n@@ -1083,15 +1082,15 @@ impl BenchHarness {\n         }\n     }\n \n-    pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+    pub fn bench_n(&mut self, n: u64, f: |&mut BenchHarness|) {\n         self.iterations = n;\n         debug!(\"running benchmark for {} iterations\",\n                n as uint);\n         f(self);\n     }\n \n     // This is a more statistics-driven benchmark algorithm\n-    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> stats::Summary {\n+    pub fn auto_bench(&mut self, f: |&mut BenchHarness|) -> stats::Summary {\n \n         // Initial bench run to get ballpark figure.\n         let mut n = 1_u64;\n@@ -1161,8 +1160,7 @@ impl BenchHarness {\n pub mod bench {\n     use test::{BenchHarness, BenchSamples};\n \n-    pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n-\n+    pub fn benchmark(f: |&mut BenchHarness|) -> BenchSamples {\n         let mut bs = BenchHarness {\n             iterations: 0,\n             ns_start: 0,"}, {"sha": "a19f501010e896d40488c69b06b2b7218a672715", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -136,7 +136,7 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Iterate over the map and mutate the contained values\n-    pub fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) -> bool {\n+    pub fn mutate_values(&mut self, f: |&K, &mut V| -> bool) -> bool {\n         mutate_values(&mut self.root, f)\n     }\n \n@@ -678,9 +678,12 @@ impl<K: TotalOrd, V> TreeNode<K, V> {\n     }\n }\n \n-fn mutate_values<'r, K: TotalOrd, V>(node: &'r mut Option<~TreeNode<K, V>>,\n-                                     f: &fn(&'r K, &'r mut V) -> bool)\n-                                  -> bool {\n+fn mutate_values<'r,\n+                 K:TotalOrd,\n+                 V>(\n+                 node: &'r mut Option<~TreeNode<K,V>>,\n+                 f: |&'r K, &'r mut V| -> bool)\n+                 -> bool {\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n                      right: ref mut right, _}) => {\n@@ -1400,8 +1403,10 @@ mod test_set {\n         }\n     }\n \n-    fn check(a: &[int], b: &[int], expected: &[int],\n-             f: &fn(&TreeSet<int>, &TreeSet<int>, f: &fn(&int) -> bool) -> bool) {\n+    fn check(a: &[int],\n+             b: &[int],\n+             expected: &[int],\n+             f: |&TreeSet<int>, &TreeSet<int>, f: |&int| -> bool| -> bool) {\n         let mut set_a = TreeSet::new();\n         let mut set_b = TreeSet::new();\n "}, {"sha": "09f95800b3dc1f71979366e0f5384279b313971a", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -295,7 +295,12 @@ impl Context {\n         Prep::new(self, fn_name)\n     }\n \n-    pub fn with_prep<'a, T>(&'a self, fn_name: &'a str, blk: &fn(p: &mut Prep) -> T) -> T {\n+    pub fn with_prep<'a,\n+                     T>(\n+                     &'a self,\n+                     fn_name: &'a str,\n+                     blk: |p: &mut Prep| -> T)\n+                     -> T {\n         let mut p = self.prep(fn_name);\n         blk(&mut p)\n     }"}, {"sha": "f752b68fea5fe53386b7aa3a04a98c7faf51da2f", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -386,8 +386,7 @@ pub fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: &fn() -> ~str)\n-                       -> T {\n+pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "296e8578cbe7c9bd215b7790b1a02a1f94c6ab78", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -42,7 +42,7 @@ impl<'self> fold::ast_fold for Context<'self> {\n }\n \n pub fn strip_items(crate: ast::Crate,\n-                   in_cfg: &fn(attrs: &[ast::Attribute]) -> bool)\n+                   in_cfg: |attrs: &[ast::Attribute]| -> bool)\n                    -> ast::Crate {\n     let ctxt = Context {\n         in_cfg: in_cfg,"}, {"sha": "9c9dba524534bb64a26c4d37ba8fdb28298dd2d7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -44,16 +44,18 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::CrateNum,\n-                      f: &fn(ast::NodeId, uint) -> bool) -> bool {\n+                      f: |ast::NodeId, uint| -> bool)\n+                      -> bool {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           def_id: ast::DefId,\n-                          callback: &fn(decoder::DefLike, ast::Ident,\n-                                        ast::visibility)) {\n+                          callback: |decoder::DefLike,\n+                                     ast::Ident,\n+                                     ast::visibility|) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -68,9 +70,9 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n /// Iterates over each top-level crate item.\n pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     cnum: ast::CrateNum,\n-                                    callback: &fn(decoder::DefLike,\n-                                                  ast::Ident,\n-                                                  ast::visibility)) {\n+                                    callback: |decoder::DefLike,\n+                                               ast::Ident,\n+                                               ast::visibility|) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -178,7 +180,7 @@ pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: &fn(~[@ast::MetaItem])) {\n+                      f: |~[@ast::MetaItem]|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n@@ -262,21 +264,21 @@ pub fn get_item_visibility(cstore: @mut cstore::CStore,\n \n pub fn each_impl(cstore: @mut cstore::CStore,\n                  crate_num: ast::CrateNum,\n-                 callback: &fn(ast::DefId)) {\n+                 callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n                                     def_id: ast::DefId,\n-                                    callback: &fn(ast::DefId)) {\n+                                    callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n                                      def_id: ast::DefId,\n-                                     callback: &fn(ast::DefId)) {\n+                                     callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n }"}, {"sha": "135d1ac8ac047d5b517f123763864d840cbd0b46", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -82,8 +82,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::CrateNum) -> bool {\n     cstore.metas.contains_key(&cnum)\n }\n \n-pub fn iter_crate_data(cstore: &CStore,\n-                       i: &fn(ast::CrateNum, @crate_metadata)) {\n+pub fn iter_crate_data(cstore: &CStore, i: |ast::CrateNum, @crate_metadata|) {\n     for (&k, &v) in cstore.metas.iter() {\n         i(k, v);\n     }"}, {"sha": "fbe3d7bbe9eea5c2f39940a4f1fa9bd47321007c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -51,7 +51,7 @@ type Cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n@@ -205,7 +205,7 @@ fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     }\n }\n \n-fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n+fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n@@ -509,7 +509,7 @@ pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n }\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: Cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n+pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n@@ -733,8 +733,9 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n-                               callback: &fn(DefLike, ast::Ident,\n-                                             ast::visibility)) {\n+                               callback: |DefLike,\n+                                          ast::Ident,\n+                                          ast::visibility|) {\n     // Iterate over all children.\n     let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -861,7 +862,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: &fn(DefLike, ast::Ident, ast::visibility)) {\n+                          callback: |DefLike, ast::Ident, ast::visibility|) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data);\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -881,8 +882,9 @@ pub fn each_child_of_item(intr: @ident_interner,\n pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n-                                    callback: &fn(DefLike, ast::Ident,\n-                                                  ast::visibility)) {\n+                                    callback: |DefLike,\n+                                               ast::Ident,\n+                                               ast::visibility|) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -1201,8 +1203,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n-                      f: &fn(~[@ast::MetaItem])) {\n-\n+                      f: |~[@ast::MetaItem]|) {\n     let item = lookup_item(node_id, cdata.data);\n     do reader::tagged_docs(item, tag_attributes) |attributes| {\n         do reader::tagged_docs(attributes, tag_attribute) |attribute| {\n@@ -1474,7 +1475,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl(cdata: Cmd, callback: &fn(ast::DefId)) {\n+pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n     let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n@@ -1484,7 +1485,7 @@ pub fn each_impl(cdata: Cmd, callback: &fn(ast::DefId)) {\n \n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n-                                    callback: &fn(ast::DefId)) {\n+                                    callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n             |impl_doc| {\n@@ -1496,7 +1497,7 @@ pub fn each_implementation_for_type(cdata: Cmd,\n \n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n-                                     callback: &fn(ast::DefId)) {\n+                                     callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n \n     let _ = do reader::tagged_docs(item_doc,"}, {"sha": "340a4241da23bded7c4047468892d5bcb235a4b1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -535,8 +535,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @item, callback: &fn(NodeId) -> bool)\n-                          -> bool {\n+fn each_auxiliary_node_id(item: @item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         item_enum(ref enum_def, _) => {\n@@ -912,7 +911,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                      index: @mut ~[entry<i64>]) {\n         index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n     }\n-    let add_to_index: &fn() = || add_to_index(item, ebml_w, index);\n+    let add_to_index: || = || add_to_index(item, ebml_w, index);\n \n     debug!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n@@ -1412,7 +1411,7 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: &fn(@mut MemWriter, &T)) {\n+                write_fn: |@mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);"}, {"sha": "32beb4bbaf375aa2be7b1a634b4e4d98e88e6abe", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -35,7 +35,7 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n-    fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch);\n+    fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch);\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n@@ -51,7 +51,8 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n-        fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch) {\n+\n+        fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n "}, {"sha": "281998b08114674ef8cdd18bec24b6f17f366984", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -79,9 +79,7 @@ fn next_byte(st: &mut PState) -> u8 {\n     return b;\n }\n \n-fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n-           op: &fn(&[u8]) -> R) -> R\n-{\n+fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     let start_pos = st.pos;\n     debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n@@ -98,7 +96,7 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: &mut PState, is_last: &fn(char) -> bool) -> ast::Ident {\n+fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     let rslt = scan(st, is_last, str::from_utf8);\n     return st.tcx.sess.ident_of(rslt);\n }\n@@ -292,7 +290,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n+fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),"}, {"sha": "f1207b07ada8992350f505efefca92e9d36c5d47", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -120,7 +120,7 @@ fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: &fn(T)) {\n+fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {"}, {"sha": "7f8816bd6137dd6e4dcb810d831b85cfa709f94a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -845,14 +845,12 @@ impl ebml_writer_helpers for writer::Encoder {\n }\n \n trait write_tag_and_id {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut Self|);\n     fn id(&mut self, id: ast::NodeId);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(&mut self,\n-           tag_id: c::astencode_tag,\n-           f: &fn(&mut writer::Encoder)) {\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut writer::Encoder|) {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();"}, {"sha": "d6aec7738a16160f48e521acc417851b1b71d9ac", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -124,9 +124,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self,\n-                            scope_id: ast::NodeId,\n-                            op: &fn(&Loan) -> bool)\n+    pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope_id`, regardless of whether it is\n@@ -142,7 +140,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     pub fn each_in_scope_loan(&self,\n                               scope_id: ast::NodeId,\n-                              op: &fn(&Loan) -> bool)\n+                              op: |&Loan| -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n@@ -160,7 +158,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn each_in_scope_restriction(&self,\n                                      scope_id: ast::NodeId,\n                                      loan_path: @LoanPath,\n-                                     op: &fn(&Loan, &Restriction) -> bool)\n+                                     op: |&Loan, &Restriction| -> bool)\n                                      -> bool {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`"}, {"sha": "ef2c172acdf225ee1c780430e464cbfeefa53812", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -533,7 +533,7 @@ impl BorrowckCtxt {\n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n                        pat: @ast::Pat,\n-                       op: &fn(mc::cmt, @ast::Pat)) {\n+                       op: |mc::cmt, @ast::Pat|) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }"}, {"sha": "a0a9ba11db2f0ca303401a4184f49b8576a4fa4b", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -412,9 +412,7 @@ impl MoveData {\n         }\n     }\n \n-    fn each_base_path(&self,\n-                      index: MovePathIndex,\n-                      f: &fn(MovePathIndex) -> bool)\n+    fn each_base_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool)\n                       -> bool {\n         let mut p = index;\n         while p != InvalidMovePathIndex {\n@@ -428,7 +426,8 @@ impl MoveData {\n \n     fn each_extending_path(&self,\n                            index: MovePathIndex,\n-                           f: &fn(MovePathIndex) -> bool) -> bool {\n+                           f: |MovePathIndex| -> bool)\n+                           -> bool {\n         if !f(index) {\n             return false;\n         }\n@@ -446,7 +445,8 @@ impl MoveData {\n \n     fn each_applicable_move(&self,\n                             index0: MovePathIndex,\n-                            f: &fn(MoveIndex) -> bool) -> bool {\n+                            f: |MoveIndex| -> bool)\n+                            -> bool {\n         let mut ret = true;\n         do self.each_extending_path(index0) |index| {\n             let mut p = self.path(index).first_move;\n@@ -505,7 +505,7 @@ impl FlowedMoveData {\n \n     pub fn each_path_moved_by(&self,\n                               id: ast::NodeId,\n-                              f: &fn(&Move, @LoanPath) -> bool)\n+                              f: |&Move, @LoanPath| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through each path moved by `id`\n@@ -521,7 +521,7 @@ impl FlowedMoveData {\n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n                         loan_path: @LoanPath,\n-                        f: &fn(&Move, @LoanPath) -> bool)\n+                        f: |&Move, @LoanPath| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -587,7 +587,7 @@ impl FlowedMoveData {\n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n                               loan_path: @LoanPath,\n-                              f: &fn(&Assignment) -> bool)\n+                              f: |&Assignment| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through every assignment to `loan_path` that"}, {"sha": "04d6266d405f072bdb246a1708a3c30df0f855b4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -121,7 +121,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n         for pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n-            let pat_matches_nan: &fn(&Pat) -> bool = |p| {\n+            let pat_matches_nan: |&Pat| -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n                     Some(&DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -900,7 +900,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     }\n \n-    let check_move: &fn(&Pat, Option<@Pat>) = |p, sub| {\n+    let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(*) is legal, but x @ Foo(y) isn't."}, {"sha": "96970e13fcbc34bc2fe323f512f5f9b42bf9fbb3", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -234,7 +234,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n     pub fn each_bit_on_entry_frozen(&self,\n                                     id: ast::NodeId,\n-                                    f: &fn(uint) -> bool) -> bool {\n+                                    f: |uint| -> bool)\n+                                    -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.nodeid_to_bitset.contains_key(&id) {\n@@ -249,7 +250,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n     pub fn each_bit_on_entry(&mut self,\n                              id: ast::NodeId,\n-                             f: &fn(uint) -> bool) -> bool {\n+                             f: |uint| -> bool)\n+                             -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n \n@@ -260,9 +262,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    pub fn each_gen_bit(&mut self,\n-                        id: ast::NodeId,\n-                        f: &fn(uint) -> bool) -> bool {\n+    pub fn each_gen_bit(&mut self, id: ast::NodeId, f: |uint| -> bool)\n+                        -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n \n         let (start, end) = self.compute_id_range(id);\n@@ -272,9 +273,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n-    pub fn each_gen_bit_frozen(&self,\n-                               id: ast::NodeId,\n-                               f: &fn(uint) -> bool) -> bool {\n+    pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n+                               -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.nodeid_to_bitset.contains_key(&id) {\n             return true;\n@@ -286,9 +286,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n-    fn each_bit(&self,\n-                words: &[uint],\n-                f: &fn(uint) -> bool) -> bool {\n+    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n         for (word_index, &word) in words.iter().enumerate() {\n@@ -978,9 +976,8 @@ fn join_bits<O:DataFlowOperator>(oper: &O,\n }\n \n #[inline]\n-fn bitwise(out_vec: &mut [uint],\n-           in_vec: &[uint],\n-           op: &fn(uint, uint) -> uint) -> bool {\n+fn bitwise(out_vec: &mut [uint], in_vec: &[uint], op: |uint, uint| -> uint)\n+           -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {"}, {"sha": "7a842364d1e3386f7d7e3173875093cf35a52a47", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -185,27 +185,29 @@ impl<N,E> Graph<N,E> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Iterating over nodes, edges\n \n-    pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n+    pub fn each_node(&self, f: |NodeIndex, &Node<N>| -> bool) -> bool {\n         //! Iterates over all edges defined in the graph.\n         self.nodes.iter().enumerate().advance(|(i, node)| f(NodeIndex(i), node))\n     }\n \n-    pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+    pub fn each_edge(&self, f: |EdgeIndex, &Edge<E>| -> bool) -> bool {\n         //! Iterates over all edges defined in the graph\n         self.edges.iter().enumerate().advance(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n     pub fn each_outgoing_edge(&self,\n                               source: NodeIndex,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all outgoing edges from the node `from`\n \n         self.each_adjacent_edge(source, Outgoing, f)\n     }\n \n     pub fn each_incoming_edge(&self,\n                               target: NodeIndex,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all incoming edges to the node `target`\n \n         self.each_adjacent_edge(target, Incoming, f)\n@@ -214,7 +216,8 @@ impl<N,E> Graph<N,E> {\n     pub fn each_adjacent_edge(&self,\n                               node: NodeIndex,\n                               dir: Direction,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all edges adjacent to the node `node`\n         //! in the direction `dir` (either `Outgoing` or `Incoming)\n \n@@ -239,9 +242,10 @@ impl<N,E> Graph<N,E> {\n     // computation.\n \n     pub fn iterate_until_fixed_point(&self,\n-                                     op: &fn(iter_index: uint,\n-                                             edge_index: EdgeIndex,\n-                                             edge: &Edge<E>) -> bool) {\n+                                     op: |iter_index: uint,\n+                                          edge_index: EdgeIndex,\n+                                          edge: &Edge<E>|\n+                                          -> bool) {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n@@ -254,7 +258,7 @@ impl<N,E> Graph<N,E> {\n     }\n }\n \n-pub fn each_edge_index(max_edge_index: EdgeIndex, f: &fn(EdgeIndex) -> bool) {\n+pub fn each_edge_index(max_edge_index: EdgeIndex, f: |EdgeIndex| -> bool) {\n     let mut i = 0;\n     let n = *max_edge_index;\n     while i < n {"}, {"sha": "b6b1516d05a02d10285221340d5b6acf4568779a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -167,8 +167,9 @@ fn check_item(cx: &mut Context, item: @item) {\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: &Context, id: NodeId,\n-                            b: &fn(checker: &fn(&Context, @freevar_entry))) {\n+fn with_appropriate_checker(cx: &Context,\n+                            id: NodeId,\n+                            b: |checker: |&Context, @freevar_entry||) {\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -351,9 +352,10 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n }\n \n // Calls \"any_missing\" if any bounds were missing.\n-pub fn check_builtin_bounds(cx: &Context, ty: ty::t, bounds: ty::BuiltinBounds,\n-                            any_missing: &fn(ty::BuiltinBounds))\n-{\n+pub fn check_builtin_bounds(cx: &Context,\n+                            ty: ty::t,\n+                            bounds: ty::BuiltinBounds,\n+                            any_missing: |ty::BuiltinBounds|) {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n     for bound in bounds.iter() {"}, {"sha": "24e76709ff50dc58ccc939c8e1948a2766229566", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -417,8 +417,9 @@ impl<'self> Context<'self> {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(&mut self, attrs: &[ast::Attribute],\n-                       f: &fn(&mut Context)) {\n+    fn with_lint_attrs(&mut self,\n+                       attrs: &[ast::Attribute],\n+                       f: |&mut Context|) {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -468,7 +469,7 @@ impl<'self> Context<'self> {\n         }\n     }\n \n-    fn visit_ids(&self, f: &fn(&mut ast_util::IdVisitor<Context>)) {\n+    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,\n@@ -480,7 +481,8 @@ impl<'self> Context<'self> {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: &fn(@ast::MetaItem, level, @str) -> bool) -> bool {\n+                 f: |@ast::MetaItem, level, @str| -> bool)\n+                 -> bool {\n     let xs = [allow, warn, deny, forbid];\n     for &level in xs.iter() {\n         let level_name = level_to_str(level);"}, {"sha": "3220ab08ede44720f183ac3a9eff14fc86f7f35d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -657,7 +657,7 @@ impl Liveness {\n \n     pub fn pat_bindings(&self,\n                         pat: @Pat,\n-                        f: &fn(LiveNode, Variable, Span, NodeId)) {\n+                        f: |LiveNode, Variable, Span, NodeId|) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -668,7 +668,7 @@ impl Liveness {\n \n     pub fn arm_pats_bindings(&self,\n                              pats: &[@Pat],\n-                             f: &fn(LiveNode, Variable, Span, NodeId)) {\n+                             f: |LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -729,7 +729,7 @@ impl Liveness {\n         self.assigned_on_entry(self.successors[*ln], var)\n     }\n \n-    pub fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n+    pub fn indices(&self, ln: LiveNode, op: |uint|) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             op(node_base_idx + var_idx)\n@@ -739,7 +739,7 @@ impl Liveness {\n     pub fn indices2(&self,\n                     ln: LiveNode,\n                     succ_ln: LiveNode,\n-                    op: &fn(uint, uint)) {\n+                    op: |uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n@@ -750,7 +750,7 @@ impl Liveness {\n     pub fn write_vars(&self,\n                       wr: &mut io::Writer,\n                       ln: LiveNode,\n-                      test: &fn(uint) -> LiveNode) {\n+                      test: |uint| -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n@@ -1406,12 +1406,13 @@ impl Liveness {\n         cond_ln\n     }\n \n-    pub fn with_loop_nodes<R>(&self,\n-                              loop_node_id: NodeId,\n-                              break_ln: LiveNode,\n-                              cont_ln: LiveNode,\n-                              f: &fn() -> R)\n-                              -> R {\n+    pub fn with_loop_nodes<R>(\n+                           &self,\n+                           loop_node_id: NodeId,\n+                           break_ln: LiveNode,\n+                           cont_ln: LiveNode,\n+                           f: || -> R)\n+                           -> R {\n       debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "89e19631dae8a5c514e3658b85d4aa130c06d30c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -63,7 +63,7 @@ pub enum categorization {\n     cat_rvalue(ast::NodeId),           // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n-    cat_stack_upvar(cmt),              // by ref upvar from &fn\n+    cat_stack_upvar(cmt),              // by ref upvar from ||\n     cat_local(ast::NodeId),            // local variable\n     cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n@@ -822,7 +822,7 @@ impl mem_categorization_ctxt {\n     pub fn cat_pattern(&self,\n                        cmt: cmt,\n                        pat: @ast::Pat,\n-                       op: &fn(cmt, @ast::Pat)) {\n+                       op: |cmt, @ast::Pat|) {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //"}, {"sha": "8493a7e00ddbeb916ea5528004cc528458f86a20", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -148,7 +148,7 @@ use syntax::codemap::Span;\n pub enum CaptureMode {\n     CapCopy, // Copy the value into the closure.\n     CapMove, // Move the value into the closure.\n-    CapRef,  // Reference directly from parent stack frame (used by `&fn()`).\n+    CapRef,  // Reference directly from parent stack frame (used by `||`).\n }\n \n #[deriving(Encodable, Decodable)]\n@@ -686,7 +686,7 @@ impl VisitContext {\n         let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n         if sigil == BorrowedSigil {\n-            // &fn() captures everything by ref\n+            // || captures everything by ref\n             at_vec::from_fn(freevars.len(), |i| {\n                 let fvar = &freevars[i];\n                 CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef}"}, {"sha": "6e5cd2e0bf2d8ea9afb9c97345f60cc585344792", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -70,8 +70,9 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @Pat) -> bool {\n     }\n }\n \n-pub fn pat_bindings(dm: resolve::DefMap, pat: @Pat,\n-                    it: &fn(BindingMode, NodeId, Span, &Path)) {\n+pub fn pat_bindings(dm: resolve::DefMap,\n+                    pat: @Pat,\n+                    it: |BindingMode, NodeId, Span, &Path|) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "fdf2e170e32562c19f34d0d808d6a8444cc3658c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -1538,10 +1538,10 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n-                                                foreign_item: @foreign_item,\n-                                                parent: ReducedGraphParent,\n-                                                f: &fn(&mut Resolver,\n-                                                       ReducedGraphParent)) {\n+                                            foreign_item: @foreign_item,\n+                                            parent: ReducedGraphParent,\n+                                            f: |&mut Resolver,\n+                                                ReducedGraphParent|) {\n         let name = foreign_item.ident;\n         let is_public = foreign_item.vis == ast::public;\n         let (name_bindings, new_parent) =\n@@ -3331,7 +3331,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(&mut self, name: Option<Ident>, f: &fn(&mut Resolver)) {\n+    fn with_scope(&mut self, name: Option<Ident>, f: |&mut Resolver|) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3692,8 +3692,8 @@ impl Resolver {\n     }\n \n     fn with_type_parameter_rib(&mut self,\n-                                   type_parameters: TypeParameters,\n-                                   f: &fn(&mut Resolver)) {\n+                               type_parameters: TypeParameters,\n+                               f: |&mut Resolver|) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3735,13 +3735,13 @@ impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_label_rib(&mut self, f: |&mut Resolver|) {\n         self.label_ribs.push(@Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n         self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(@Rib::new(ConstantItemRibKind));\n         f(self);\n@@ -4888,7 +4888,7 @@ impl Resolver {\n         }\n     }\n \n-    fn with_no_errors<T>(&mut self, f: &fn(&mut Resolver) -> T) -> T {\n+    fn with_no_errors<T>(&mut self, f: |&mut Resolver| -> T) -> T {\n         self.emit_errors = false;\n         let rs = f(self);\n         self.emit_errors = true;\n@@ -4901,10 +4901,8 @@ impl Resolver {\n         }\n     }\n \n-    fn find_best_match_for_name(&mut self,\n-                                    name: &str,\n-                                    max_distance: uint)\n-                                    -> Option<@str> {\n+    fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n+                                -> Option<@str> {\n         let this = &mut *self;\n \n         let mut maybes: ~[@str] = ~[];"}, {"sha": "92913983d865977c0bf1741835d5e19e5ead147a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -2066,7 +2066,8 @@ fn mk_binding_alloca(mut bcx: @mut Block,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: &fn(@mut Block, ty::t, ValueRef) -> @mut Block) -> @mut Block {\n+                     populate: |@mut Block, ty::t, ValueRef| -> @mut Block)\n+                     -> @mut Block {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));"}, {"sha": "80b3455e9fa76ada8b04b312f8576900b39da55c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -93,7 +93,7 @@ pub use middle::trans::context::task_llcx;\n \n local_data_key!(task_local_insn_key: ~[&'static str])\n \n-pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n+pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n     do local_data::get(task_local_insn_key) |c| {\n         match c {\n             Some(ctx) => blk(*ctx),\n@@ -787,10 +787,11 @@ pub fn cast_shift_const_rhs(op: ast::BinOp,\n }\n \n pub fn cast_shift_rhs(op: ast::BinOp,\n-                      lhs: ValueRef, rhs: ValueRef,\n-                      trunc: &fn(ValueRef, Type) -> ValueRef,\n-                      zext: &fn(ValueRef, Type) -> ValueRef)\n-                   -> ValueRef {\n+                      lhs: ValueRef,\n+                      rhs: ValueRef,\n+                      trunc: |ValueRef, Type| -> ValueRef,\n+                      zext: |ValueRef, Type| -> ValueRef)\n+                      -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n@@ -966,7 +967,7 @@ pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: @mut Block, f: &fn(si: &mut ScopeInfo)) {\n+pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n     let mut bcx = bcx;\n     let mut cur_scope = bcx.scope;\n     loop {\n@@ -1430,7 +1431,8 @@ pub fn leave_block(bcx: @mut Block, out_of: @mut Block) -> @mut Block {\n pub fn with_scope(bcx: @mut Block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n+                  f: |@mut Block| -> @mut Block)\n+                  -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n@@ -1448,7 +1450,8 @@ pub fn with_scope(bcx: @mut Block,\n pub fn with_scope_result(bcx: @mut Block,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: &fn(@mut Block) -> Result) -> Result {\n+                         f: |@mut Block| -> Result)\n+                         -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n     let scope = simple_block_scope(bcx.scope, opt_node_info);\n@@ -1462,9 +1465,11 @@ pub fn with_scope_result(bcx: @mut Block,\n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n-                             name: &str, f: &fn(@mut Block) -> datum::DatumBlock)\n-                          -> datum::DatumBlock {\n+pub fn with_scope_datumblock(bcx: @mut Block,\n+                             opt_node_info: Option<NodeInfo>,\n+                             name: &str,\n+                             f: |@mut Block| -> datum::DatumBlock)\n+                             -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n     let _icx = push_ctxt(\"with_scope_result\");\n@@ -1474,7 +1479,7 @@ pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n+pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n     for s in b.stmts.iter() {\n         match s.node {\n           ast::StmtDecl(d, _) => {\n@@ -1488,7 +1493,10 @@ pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n     }\n }\n \n-pub fn with_cond(bcx: @mut Block, val: ValueRef, f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n+pub fn with_cond(bcx: @mut Block,\n+                 val: ValueRef,\n+                 f: |@mut Block| -> @mut Block)\n+                 -> @mut Block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n@@ -1885,7 +1893,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n-                     maybe_load_env: &fn(@mut FunctionContext)) {\n+                     maybe_load_env: |@mut FunctionContext|) {\n     ccx.stats.n_closures += 1;\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);"}, {"sha": "ebd7bb6937ef41284b84422d0adfdd3af5f4b125", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -337,9 +337,9 @@ pub fn compute_abi_info(_ccx: &mut CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     fn x86_64_ty(ty: Type,\n-                 is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n-                 attr: Attribute) -> ArgType {\n-\n+                 is_mem_cls: |cls: &[RegClass]| -> bool,\n+                 attr: Attribute)\n+                 -> ArgType {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {"}, {"sha": "d78311c8a398a2dd1a9c5ec3c0cb77b013bcb941", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -600,7 +600,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: &fn(@mut Block) -> Callee,\n+                        get_callee: |@mut Block| -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)"}, {"sha": "baccd9c7028e33b185be6dc366fe94219110931d", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -51,7 +51,7 @@ use syntax::parse::token::special_idents;\n // };\n //\n // Note that the closure is itself a rust_opaque_box.  This is true\n-// even for ~fn and &fn, because we wish to keep binary compatibility\n+// even for ~fn and ||, because we wish to keep binary compatibility\n // between all kinds of closures.  The allocation strategy for this\n // closure depends on the closure type.  For a sendfn, the closure\n // (and the referenced type descriptors) will be allocated in the\n@@ -422,11 +422,12 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn make_closure_glue(\n-        cx: @mut Block,\n-        v: ValueRef,\n-        t: ty::t,\n-        glue_fn: &fn(@mut Block, v: ValueRef, t: ty::t) -> @mut Block) -> @mut Block {\n+pub fn make_closure_glue(cx: @mut Block,\n+                         v: ValueRef,\n+                         t: ty::t,\n+                         glue_fn: |@mut Block, v: ValueRef, t: ty::t|\n+                                   -> @mut Block)\n+                         -> @mut Block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();"}, {"sha": "48602534a3d89e35c0736f3c2730f376e5aadc5b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -769,7 +769,9 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mut ScopeInfo)) {\n+pub fn in_scope_cx(cx: @mut Block,\n+                   scope_id: Option<ast::NodeId>,\n+                   f: |si: &mut ScopeInfo|) {\n     let mut cur = cx;\n     let mut cur_scope = cur.scope;\n     loop {"}, {"sha": "1806dee6c8f2097eb6cbcb278af15dae53097aa9", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -524,7 +524,7 @@ impl Datum {\n                        bcx: @mut Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n-                       gep: &fn(ValueRef) -> ValueRef)\n+                       gep: |ValueRef| -> ValueRef)\n                        -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {"}, {"sha": "676af30b2eeba6b764974edd74c4ebf5c8dbca13", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -2274,9 +2274,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n-                      inner_walk: &fn(&mut CrateContext,\n-                                      &mut ~[ScopeStackEntry],\n-                                      &mut HashMap<ast::NodeId, DIScope>)) {\n+                      inner_walk: |&mut CrateContext,\n+                                   &mut ~[ScopeStackEntry],\n+                                   &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);"}, {"sha": "9d8b539bac83bb453ddbb2c9f727f8ae04b5d5fb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -1151,10 +1151,12 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n // The optional node ID here is the node ID of the path identifying the enum\n // variant in use. If none, this cannot possibly an enum variant (so, if it\n // is and `node_id_opt` is none, this function fails).\n-pub fn with_field_tys<R>(tcx: ty::ctxt,\n-                         ty: ty::t,\n-                         node_id_opt: Option<ast::NodeId>,\n-                         op: &fn(ty::Disr, (&[ty::field])) -> R) -> R {\n+pub fn with_field_tys<R>(\n+                      tcx: ty::ctxt,\n+                      ty: ty::t,\n+                      node_id_opt: Option<ast::NodeId>,\n+                      op: |ty::Disr, (&[ty::field])| -> R)\n+                      -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))"}, {"sha": "33036aab65be10153669c9f058781581c2b83b87", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -510,11 +510,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         // Array for the arguments we will pass to the rust function.\n         let mut llrust_args = ~[];\n         let mut next_foreign_arg_counter: c_uint = 0;\n-        let next_foreign_arg: &fn(pad: bool) -> c_uint = {\n-            |pad: bool| {\n-                next_foreign_arg_counter += if pad { 2 } else { 1 };\n-                next_foreign_arg_counter - 1\n-            }\n+        let next_foreign_arg: |pad: bool| -> c_uint = |pad: bool| {\n+            next_foreign_arg_counter += if pad {\n+                2\n+            } else {\n+                1\n+            };\n+            next_foreign_arg_counter - 1\n         };\n \n         // If there is an out pointer on the foreign function"}, {"sha": "b1dc17a12399851b1fcc4c9a6390d8077cdbcca6", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -121,7 +121,7 @@ impl Reflector {\n     pub fn bracketed(&mut self,\n                      bracket_name: &str,\n                      extra: &[ValueRef],\n-                     inner: &fn(&mut Reflector)) {\n+                     inner: |&mut Reflector|) {\n         self.visit(\"enter_\" + bracket_name, extra);\n         inner(self);\n         self.visit(\"leave_\" + bracket_name, extra);"}, {"sha": "2a8db56eec6498d9666586903d4d302d6c99958e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -247,7 +247,7 @@ pub enum AutoRef {\n     /// Convert from @[]/~[]/&[] to &&[] (or str)\n     AutoBorrowVecRef(Region, ast::Mutability),\n \n-    /// Convert from @fn()/~fn()/&fn() to &fn()\n+    /// Convert from @fn()/~fn()/|| to ||\n     AutoBorrowFn(Region),\n \n     /// Convert from T to *T\n@@ -651,7 +651,7 @@ pub enum sty {\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(Sigil), // ptr to env for &fn, @fn, ~fn\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for ||, @fn, ~fn\n     ty_unboxed_vec(mt),\n }\n \n@@ -1348,11 +1348,11 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-pub fn walk_ty(ty: t, f: &fn(t)) {\n+pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n-pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n+pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     if !f(ty) {\n         return;\n     }\n@@ -1382,25 +1382,19 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: |t| -> t) -> t {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: ctxt,\n-                           ty: t,\n-                           fldr: &fn(r: Region),\n-                           fldt: &fn(t: t))\n+pub fn walk_regions_and_ty(cx: ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                            -> t {\n     ty_fold::RegionFolder::general(cx,\n                                    |r| { fldr(r); r },\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: ctxt,\n-                    ty: t,\n-                    fldr: &fn(r: Region) -> Region)\n-                    -> t {\n+pub fn fold_regions(cx: ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n     ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n@@ -1886,7 +1880,7 @@ impl TypeContents {\n             *self & TC::ReachesAll)\n     }\n \n-    pub fn union<T>(v: &[T], f: &fn(&T) -> TypeContents) -> TypeContents {\n+    pub fn union<T>(v: &[T], f: |&T| -> TypeContents) -> TypeContents {\n         v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n@@ -2223,7 +2217,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         fn each_inherited_builtin_bound(cx: ctxt,\n                                         bounds: BuiltinBounds,\n                                         traits: &[@TraitRef],\n-                                        f: &fn(BuiltinBound)) {\n+                                        f: |BuiltinBound|) {\n             for bound in bounds.iter() {\n                 f(bound);\n             }\n@@ -2351,10 +2345,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     !subtypes_require(cx, &mut seen, r_ty, r_ty)\n }\n \n-pub fn type_structurally_contains(cx: ctxt,\n-                                  ty: t,\n-                                  test: &fn(x: &sty) -> bool)\n-                               -> bool {\n+pub fn type_structurally_contains(cx: ctxt, ty: t, test: |x: &sty| -> bool)\n+                                  -> bool {\n     let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: {}\",\n            ::util::ppaux::ty_to_str(cx, ty));\n@@ -2969,7 +2961,7 @@ pub fn adjust_ty(cx: ctxt,\n }\n \n impl AutoRef {\n-    pub fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n+    pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {\n             ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n             ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n@@ -3525,11 +3517,10 @@ pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef]\n }\n \n fn lookup_locally_or_in_crate_store<V:Clone>(\n-    descr: &str,\n-    def_id: ast::DefId,\n-    map: &mut HashMap<ast::DefId, V>,\n-    load_external: &fn() -> V) -> V\n-{\n+                                    descr: &str,\n+                                    def_id: ast::DefId,\n+                                    map: &mut HashMap<ast::DefId, V>,\n+                                    load_external: || -> V) -> V {\n     /*!\n      * Helper for looking things up in the various maps\n      * that are populated during typeck::collect (e.g.,\n@@ -3961,7 +3952,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: ctxt, did: DefId, f: &fn(@MetaItem) -> bool) -> bool {\n+pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n             Some(&ast_map::node_item(@ast::item {attrs: ref attrs, _}, _)) =>\n@@ -4341,7 +4332,8 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &[@TraitRef],\n-                                        f: &fn(@TraitRef) -> bool) -> bool {\n+                                        f: |@TraitRef| -> bool)\n+                                        -> bool {\n     for &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];"}, {"sha": "7feb82788fc449e41699430e3e23da9d33f5c772", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -33,7 +33,7 @@\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n  *\n- *   type foo = { x: &a.int, y: &fn(&a.int) }\n+ *   type foo = { x: &a.int, y: |&a.int| }\n  *\n  * The type of `x` is an error because there is no region `a` in scope.\n  * In the type of `y`, however, region `a` is considered a bound region\n@@ -290,13 +290,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,RS:RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        a_seq_ty: &ast::mt,\n-        vst: ty::vstore,\n-        constr: &fn(ty::mt) -> ty::t) -> ty::t\n-    {\n+    fn mk_pointer<AC:AstConv,\n+                  RS:RegionScope>(\n+                  this: &AC,\n+                  rscope: &RS,\n+                  a_seq_ty: &ast::mt,\n+                  vst: ty::vstore,\n+                  constr: |ty::mt| -> ty::t)\n+                  -> ty::t {\n         let tcx = this.tcx();\n         debug!(\"mk_pointer(vst={:?})\", vst);\n \n@@ -715,7 +716,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n                     ty::ReStatic\n                 }\n                 ast::BorrowedSigil => {\n-                    // &fn() defaults as normal for an omitted lifetime:\n+                    // || defaults as normal for an omitted lifetime:\n                     opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n                 }\n             }"}, {"sha": "0785ba002aacbc59d021f966bb9ce48b84919136", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -655,7 +655,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          span: Span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;\n-    let check_inner: &fn(ty::mt) = |e_inner| {\n+    let check_inner: |ty::mt| = |e_inner| {\n         check_pat(pcx, inner, e_inner.ty);\n         fcx.write_ty(pat_id, expected);\n     };"}, {"sha": "5973d791f525cb4131319d27ac9c0606be0a982a", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -31,9 +31,11 @@ pub fn subtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n pub fn suptype_with_fn(fcx: @mut FnCtxt,\n-                       sp: Span, b_is_expected: bool,\n-                       ty_a: ty::t, ty_b: ty::t,\n-                       handle_err: &fn(Span, ty::t, ty::t, &ty::type_err)) {\n+                       sp: Span,\n+                       b_is_expected: bool,\n+                       ty_a: ty::t,\n+                       ty_b: ty::t,\n+                       handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {"}, {"sha": "8eaf3824ff40804c4c86c8d33f31c9ef5152a39a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -483,12 +483,13 @@ impl<'self> LookupContext<'self> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(\n-        &self,\n-        bounds: &[@TraitRef],\n-        mk_cand: &fn(trait_ref: @TraitRef, m: @ty::Method, method_num: uint,\n-                     bound_num: uint) -> Candidate) {\n-\n+    fn push_inherent_candidates_from_bounds_inner(&self,\n+                                                  bounds: &[@TraitRef],\n+                                                  mk_cand: |tr: @TraitRef,\n+                                                            m: @ty::Method,\n+                                                            method_num: uint,\n+                                                            bound_num: uint|\n+                                                            -> Candidate) {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -783,12 +784,12 @@ impl<'self> LookupContext<'self> {\n     }\n \n     fn search_for_some_kind_of_autorefd_method(\n-        &self,\n-        kind: &fn(Region, ast::Mutability) -> ty::AutoRef,\n-        autoderefs: uint,\n-        mutbls: &[ast::Mutability],\n-        mk_autoref_ty: &fn(ast::Mutability, ty::Region) -> ty::t)\n-        -> Option<method_map_entry> {\n+            &self,\n+            kind: |Region, ast::Mutability| -> ty::AutoRef,\n+            autoderefs: uint,\n+            mutbls: &[ast::Mutability],\n+            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+            -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region ="}, {"sha": "8d643ef220042866f839223f7127d0bc67ea64e5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -1194,7 +1194,7 @@ impl FnCtxt {\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: &fn(&ty::substs) -> bool)\n+                              f: |&ty::substs| -> bool)\n                               -> bool {\n         match self.inh.node_type_substs.find(&id) {\n             Some(s) => f(s),\n@@ -1257,8 +1257,7 @@ impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: &fn() -> R)\n-                             -> R {\n+    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: || -> R) -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n         let v = f();\n@@ -1268,7 +1267,7 @@ impl FnCtxt {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: &fn(~str) -> ~str,\n+                              mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1629,7 +1628,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n-                               unifier: &fn()) {\n+                               unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n@@ -2014,7 +2013,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         args: ~[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: &fn(),\n+                        unbound_method: ||,\n                         _expected_result: Option<ty::t>\n                        )\n                      -> ty::t {\n@@ -2198,10 +2197,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // through the `unpack` function.  It there is no expected type or\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n-    fn unpack_expected<O>(fcx: @mut FnCtxt,\n-                          expected: Option<ty::t>,\n-                          unpack: &fn(&ty::sty) -> Option<O>)\n-                          -> Option<O> {\n+    fn unpack_expected<O>(\n+                       fcx: @mut FnCtxt,\n+                       expected: Option<ty::t>,\n+                       unpack: |&ty::sty| -> Option<O>)\n+                       -> Option<O> {\n         match expected {\n             Some(t) => {\n                 match resolve_type(fcx.infcx(), t, force_tvar) {"}, {"sha": "ebdd4b5f48c2fef426b1d5d33eeb76c8eb77a109", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -20,12 +20,11 @@ use util::ppaux;\n // Helper functions related to manipulating region types.\n \n pub fn replace_bound_regions_in_fn_sig(\n-    tcx: ty::ctxt,\n-    opt_self_ty: Option<ty::t>,\n-    fn_sig: &ty::FnSig,\n-    mapf: &fn(ty::BoundRegion) -> ty::Region)\n-    -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig)\n-{\n+        tcx: ty::ctxt,\n+        opt_self_ty: Option<ty::t>,\n+        fn_sig: &ty::FnSig,\n+        mapf: |ty::BoundRegion| -> ty::Region)\n+        -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig) {\n     debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n             opt_self_ty.repr(tcx),\n             fn_sig.repr(tcx));\n@@ -47,12 +46,10 @@ pub fn replace_bound_regions_in_fn_sig(\n     (map, opt_self_ty, fn_sig)\n }\n \n-pub fn relate_nested_regions(\n-    tcx: ty::ctxt,\n-    opt_region: Option<ty::Region>,\n-    ty: ty::t,\n-    relate_op: &fn(ty::Region, ty::Region))\n-{\n+pub fn relate_nested_regions(tcx: ty::ctxt,\n+                             opt_region: Option<ty::Region>,\n+                             ty: ty::t,\n+                             relate_op: |ty::Region, ty::Region|) {\n     /*!\n      * This rather specialized function walks each region `r` that appear\n      * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`"}, {"sha": "78aa3f8fe40777a2a4ca50b1d5fb0eb055a9c5bf", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -451,7 +451,7 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: &fn(@Impl)) {\n+    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n         match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n                 for &im in impls.iter() {"}, {"sha": "e2ea08244006dbe9fc4c8a0a72d01f181737ff97", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -161,9 +161,7 @@ impl Coerce {\n         }\n     }\n \n-    pub fn unpack_actual_value(&self,\n-                               a: ty::t,\n-                               f: &fn(&ty::sty) -> CoerceResult)\n+    pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n                                -> CoerceResult {\n         match resolve_type(self.infcx, a, try_resolve_tvar_shallow) {\n             Ok(t) => {"}, {"sha": "af7a23a4dfcdcac94d6e33eed6b60a40b639b21d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -196,7 +196,7 @@ impl Combine for Glb {\n             // NB---I do not believe this algorithm computes\n             // (necessarily) the GLB.  As written it can\n             // spuriously fail.  In particular, if there is a case\n-            // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n+            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n             // free, it will return fn(&c) where c = GLB(a,b).  If\n             // however this GLB is not defined, then the result is\n             // an error, even though something like"}, {"sha": "cde9dd135b3116db09958baecfb41929a5ef1e03", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -442,12 +442,12 @@ pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n }\n \n trait then {\n-    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.and_then(|_i| f())\n     }\n@@ -467,11 +467,11 @@ impl<T> ToUres for cres<T> {\n }\n \n trait CresCompare<T> {\n-    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T>;\n+    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T>;\n }\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n         do (*self).clone().and_then |s| {\n             if s == t {\n                 (*self).clone()\n@@ -549,7 +549,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -564,7 +564,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -579,7 +579,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -721,17 +721,17 @@ impl InferCtxt {\n     // errors.\n     pub fn type_error_message_str(@mut self,\n                                   sp: Span,\n-                                  mk_msg: &fn(Option<~str>, ~str) -> ~str,\n+                                  mk_msg: |Option<~str>, ~str| -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n     pub fn type_error_message_str_with_expected(@mut self,\n                                                 sp: Span,\n-                                                mk_msg:\n-                                                &fn(Option<~str>, ~str) ->\n-                                                ~str,\n+                                                mk_msg: |Option<~str>,\n+                                                         ~str|\n+                                                         -> ~str,\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: ~str,\n                                                 err: Option<&ty::type_err>) {\n@@ -760,7 +760,7 @@ impl InferCtxt {\n \n     pub fn type_error_message(@mut self,\n                               sp: Span,\n-                              mk_msg: &fn(~str) -> ~str,\n+                              mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n@@ -813,11 +813,10 @@ impl InferCtxt {\n     }\n }\n \n-pub fn fold_regions_in_sig(\n-    tcx: ty::ctxt,\n-    fn_sig: &ty::FnSig,\n-    fldr: &fn(r: ty::Region) -> ty::Region) -> ty::FnSig\n-{\n+pub fn fold_regions_in_sig(tcx: ty::ctxt,\n+                           fn_sig: &ty::FnSig,\n+                           fldr: |r: ty::Region| -> ty::Region)\n+                           -> ty::FnSig {\n     ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n }\n "}, {"sha": "2b99a0a4f0ef45e8d18b9bf99a70a06599b113e2", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -389,7 +389,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters.  Consider, for\n example, whether the following relation holds:\n \n-    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n+    fn(&'a int) <: |&'b int|? (Yes, a => b)\n \n The answer is that of course it does.  These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -406,7 +406,7 @@ Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n+    fn<a>(&'a int) <: |&'self int|? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -423,7 +423,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'self int) <: &fn<a>(&'a int)? (No)\n+    fn(&'self int) <: <a>|&'a int|? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -432,8 +432,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n-    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n+    fn<a,b>(&'a int, &'b int) <: <a>|&'a int, &'a int|? (Yes)\n+    fn<a>(&'a int, &'a int) <: <a,b>|&'a int, &'b int|? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with\n@@ -457,12 +457,12 @@ Let's walk through some examples and see how this algorithm plays out.\n \n We'll start with the first example, which was:\n \n-    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n+    1. fn<a>(&'a T) <: <b>|&'b T|?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    1. fn(&'A T) <: &fn(&'x T)?\n+    1. fn(&'A T) <: |&'x T|?\n \n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system.  I also replaced\n@@ -491,12 +491,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n+    3. fn(&'self T)    <: <b>|&'b T|?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&'self T) <: &fn(&'x T)?\n+    3. fn(&'self T) <: |&'x T|?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with\n@@ -511,7 +511,7 @@ You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant.  The purpose of that last step is to\n catch something like *this*:\n \n-    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n+    fn<a>() -> fn(&'a T) <: || -> fn<b>(&'b T)?   No.\n \n Here the function types are the same but for where the binding occurs.\n The subtype returns a function that expects a value in precisely one\n@@ -525,15 +525,15 @@ So let's step through what happens when we perform this subtype check.\n We first replace the bound regions in the subtype (the supertype has\n no bound regions).  This gives us:\n \n-    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n+    fn() -> fn(&'A T) <: || -> fn<b>(&'b T)?\n \n Now we compare the return types, which are covariant, and hence we have:\n \n-    fn(&'A T) <: &fn<b>(&'b T)?\n+    fn(&'A T) <: <b>|&'b T|?\n \n Here we skolemize the bound region in the supertype to yield:\n \n-    fn(&'A T) <: &fn(&'x T)?\n+    fn(&'A T) <: |&'x T|?\n \n And then proceed to compare the argument types:\n \n@@ -550,7 +550,7 @@ The difference between this example and the first one is that the variable\n `A` already existed at the point where the skolemization occurred.  In\n the first example, you had two functions:\n \n-    fn<a>(&'a T) <: &fn<b>(&'b T)\n+    fn<a>(&'a T) <: <b>|&'b T|\n \n and hence `&A` and `&x` were created \"together\".  In general, the\n intention of the skolemized names is that they are supposed to be"}, {"sha": "ff4b20d369b6f5bea46cfb44bcd96ec45f568ded", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -359,9 +359,9 @@ impl RegionVarBindings {\n                         a: Region,\n                         b: Region,\n                         origin: SubregionOrigin,\n-                        relate: &fn(this: &mut RegionVarBindings,\n-                                    old_r: Region,\n-                                    new_r: Region))\n+                        relate: |this: &mut RegionVarBindings,\n+                                 old_r: Region,\n+                                 new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).find(&vars) {\n@@ -1254,7 +1254,7 @@ impl RegionVarBindings {\n \n     fn iterate_until_fixed_point(&self,\n                                  tag: &str,\n-                                 body: &fn(constraint: &Constraint) -> bool) {\n+                                 body: |constraint: &Constraint| -> bool) {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {"}, {"sha": "ed2b1d1db4b5a69f33547e6f4acec69c9032b650", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -282,15 +282,14 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     }\n }\n \n-pub fn require_same_types(\n-    tcx: ty::ctxt,\n-    maybe_infcx: Option<@mut infer::InferCtxt>,\n-    t1_is_expected: bool,\n-    span: Span,\n-    t1: ty::t,\n-    t2: ty::t,\n-    msg: &fn() -> ~str) -> bool {\n-\n+pub fn require_same_types(tcx: ty::ctxt,\n+                          maybe_infcx: Option<@mut infer::InferCtxt>,\n+                          t1_is_expected: bool,\n+                          span: Span,\n+                          t1: ty::t,\n+                          t2: ty::t,\n+                          msg: || -> ~str)\n+                          -> bool {\n     let l_tcx;\n     let l_infcx;\n     match maybe_infcx {"}, {"sha": "985bcaf96d17e93f5448c161240a39d806beed48", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -150,8 +150,8 @@ constraints will be satisfied.\n As a simple example, consider:\n \n     enum Option<A> { Some(A), None }\n-    enum OptionalFn<B> { Some(&fn(B)), None }\n-    enum OptionalMap<C> { Some(&fn(C) -> C), None }\n+    enum OptionalFn<B> { Some(|B|), None }\n+    enum OptionalMap<C> { Some(|C| -> C), None }\n \n Here, we will generate the constraints:\n "}, {"sha": "ffbea94c4774bfa5381d6d4b47ee13aee56b2c75", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -17,7 +17,7 @@ use syntax::visit::Visitor;\n use std::hashmap::HashSet;\n use extra;\n \n-pub fn time<T, U>(do_it: bool, what: &str, u: U, f: &fn(U) -> T) -> T {\n+pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     if !do_it { return f(u); }\n     let start = extra::time::precise_time_s();\n     let rv = f(u);\n@@ -26,7 +26,7 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: &fn(U) -> T) -> T {\n     rv\n }\n \n-pub fn indent<R>(op: &fn() -> R) -> R {\n+pub fn indent<R>(op: || -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n@@ -79,7 +79,7 @@ impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: &fn(&ast::Expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -102,7 +102,7 @@ impl<'self> Visitor<()> for BlockQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: &fn(@ast::Expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: |@ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "0364eb890fbb9876a129f686cbfadec1e1c31ede", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -286,7 +286,7 @@ pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     }\n }\n \n-pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n+pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n     let tstrs = ts.map(f);\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }"}, {"sha": "c4641eff572699627fd7e850d5bcc032016c7a82", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -235,7 +235,7 @@ impl ToStrConsume for ~[Ascii] {\n \n impl IterBytes for Ascii {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, _lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         f([self.to_byte()])\n     }\n }"}, {"sha": "a052ae87a41c590e5527a26963f0db9d8829a0c1", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -43,7 +43,7 @@ pub fn capacity<T>(v: @[T]) -> uint {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n+pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n     let mut vec = @[];\n     unsafe { raw::reserve(&mut vec, size.unwrap_or(4)); }\n     builder(|x| unsafe { raw::push(&mut vec, x) });\n@@ -68,7 +68,7 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n \n \n /// Apply a function to each element of a vector and return the results\n-pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n+pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n     do build(Some(v.len())) |push| {\n         for elem in v.iter() {\n             push(f(elem));\n@@ -82,7 +82,7 @@ pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * Creates an immutable vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n+pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n     do build(Some(n_elts)) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }"}, {"sha": "ce0a66965962369c14a2c143e14da5eb4e7a95d0", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -58,7 +58,7 @@ use num::FromPrimitive;\n /// }\n /// ```\n #[inline]\n-pub fn all_values(blk: &fn(v: bool)) {\n+pub fn all_values(blk: |v: bool|) {\n     blk(true);\n     blk(false);\n }"}, {"sha": "a9c4d2cacde2ccb0af467f5dc57519bb17593858", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -117,7 +117,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n-    pub fn with_ref<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    pub fn with_ref<T>(&self, f: |*libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(self.buf)\n     }\n@@ -127,7 +127,7 @@ impl CString {\n     /// # Failure\n     ///\n     /// Fails if the CString is null.\n-    pub fn with_mut_ref<T>(&mut self, f: &fn(*mut libc::c_char) -> T) -> T {\n+    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         f(unsafe { cast::transmute_mut_unsafe(self.buf) })\n     }\n@@ -223,13 +223,13 @@ pub trait ToCStr {\n     ///\n     /// Raises the `null_byte` condition if the receiver has an interior null.\n     #[inline]\n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.to_c_str().with_ref(f)\n     }\n \n     /// Unsafe variant of `with_c_str()` that doesn't check for nulls.\n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.to_c_str_unchecked().with_ref(f)\n     }\n }\n@@ -246,12 +246,12 @@ impl<'self> ToCStr for &'self str {\n     }\n \n     #[inline]\n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str(f)\n     }\n \n     #[inline]\n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         self.as_bytes().with_c_str_unchecked(f)\n     }\n }\n@@ -282,17 +282,17 @@ impl<'self> ToCStr for &'self [u8] {\n         }\n     }\n \n-    fn with_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n         unsafe { with_c_str(*self, true, f) }\n     }\n \n-    unsafe fn with_c_str_unchecked<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n+    unsafe fn with_c_str_unchecked<T>(&self, f: |*libc::c_char| -> T) -> T {\n         with_c_str(*self, false, f)\n     }\n }\n \n // Unsafe function that handles possibly copying the &[u8] into a stack array.\n-unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: &fn(*libc::c_char) -> T) -> T {\n+unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n         vec::bytes::copy_memory(buf, v, v.len());\n@@ -357,7 +357,7 @@ impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n /// is found, and the number of strings found is returned.\n pub unsafe fn from_c_multistring(buf: *libc::c_char,\n                                  count: Option<uint>,\n-                                 f: &fn(&CString)) -> uint {\n+                                 f: |&CString|) -> uint {\n \n     let mut curr_ptr: uint = buf as uint;\n     let mut ctr = 0;"}, {"sha": "54849a44f6d3b96cdbb3249e8bd47a5b4f7e0570", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -71,12 +71,12 @@ impl<T> Cell<T> {\n     }\n \n     /// Calls a closure with a reference to the value.\n-    pub fn with_ref<R>(&self, op: &fn(v: &T) -> R) -> R {\n+    pub fn with_ref<R>(&self, op: |v: &T| -> R) -> R {\n         do self.with_mut_ref |ptr| { op(ptr) }\n     }\n \n     /// Calls a closure with a mutable reference to the value.\n-    pub fn with_mut_ref<R>(&self, op: &fn(v: &mut T) -> R) -> R {\n+    pub fn with_mut_ref<R>(&self, op: |v: &mut T| -> R) -> R {\n         let mut v = Some(self.take());\n         do (|| {\n             op(v.get_mut_ref())"}, {"sha": "c5a4dd1631df99b6b40dc7868992634c0cb2d260", "filename": "src/libstd/char.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -241,7 +241,7 @@ static N_COUNT: uint = (V_COUNT * T_COUNT);\n static S_COUNT: uint = (L_COUNT * N_COUNT);\n \n // Decompose a precomposed Hangul syllable\n-fn decompose_hangul(s: char, f: &fn(char)) {\n+fn decompose_hangul(s: char, f: |char|) {\n     let si = s as uint - S_BASE;\n \n     let li = si / N_COUNT;\n@@ -259,7 +259,7 @@ fn decompose_hangul(s: char, f: &fn(char)) {\n }\n \n /// Returns the canonical decompostion of a character\n-pub fn decompose_canonical(c: char, f: &fn(char)) {\n+pub fn decompose_canonical(c: char, f: |char|) {\n     if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n         decompose::canonical(c, f);\n     } else {\n@@ -268,7 +268,7 @@ pub fn decompose_canonical(c: char, f: &fn(char)) {\n }\n \n /// Returns the compatibility decompostion of a character\n-pub fn decompose_compatible(c: char, f: &fn(char)) {\n+pub fn decompose_compatible(c: char, f: |char|) {\n     if (c as uint) < S_BASE || (c as uint) >= (S_BASE + S_COUNT) {\n         decompose::compatibility(c, f);\n     } else {\n@@ -285,7 +285,7 @@ pub fn decompose_compatible(c: char, f: &fn(char)) {\n /// - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n /// - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n ///\n-pub fn escape_unicode(c: char, f: &fn(char)) {\n+pub fn escape_unicode(c: char, f: |char|) {\n     // avoid calling str::to_str_radix because we don't really need to allocate\n     // here.\n     f('\\\\');\n@@ -316,7 +316,7 @@ pub fn escape_unicode(c: char, f: &fn(char)) {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex unicode escapes; see `escape_unicode`.\n ///\n-pub fn escape_default(c: char, f: &fn(char)) {\n+pub fn escape_default(c: char, f: |char|) {\n     match c {\n         '\\t' => { f('\\\\'); f('t'); }\n         '\\r' => { f('\\\\'); f('r'); }\n@@ -367,8 +367,8 @@ pub trait Char {\n     fn is_digit_radix(&self, radix: uint) -> bool;\n     fn to_digit(&self, radix: uint) -> Option<uint>;\n     fn from_digit(num: uint, radix: uint) -> Option<char>;\n-    fn escape_unicode(&self, f: &fn(char));\n-    fn escape_default(&self, f: &fn(char));\n+    fn escape_unicode(&self, f: |char|);\n+    fn escape_default(&self, f: |char|);\n     fn len_utf8_bytes(&self) -> uint;\n \n     /// Encodes this character as utf-8 into the provided byte-buffer. The\n@@ -403,9 +403,9 @@ impl Char for char {\n \n     fn from_digit(num: uint, radix: uint) -> Option<char> { from_digit(num, radix) }\n \n-    fn escape_unicode(&self, f: &fn(char)) { escape_unicode(*self, f) }\n+    fn escape_unicode(&self, f: |char|) { escape_unicode(*self, f) }\n \n-    fn escape_default(&self, f: &fn(char)) { escape_default(*self, f) }\n+    fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n \n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n "}, {"sha": "a1f850978656260a481c16423a3130981f433dc2", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -30,7 +30,8 @@ struct AnnihilateStats {\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: &fn(box: *mut raw::Box<()>, uniq: bool) -> bool) -> bool {\n+                          f: |box: *mut raw::Box<()>, uniq: bool| -> bool)\n+                          -> bool {\n     //! Walks the internal list of allocations\n \n     use managed;"}, {"sha": "56d5a8594012fd1b118a5cabe45f6b16fec2a51c", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -133,7 +133,7 @@ impl<T, U> Condition<T, U> {\n \n     /// Performs the same functionality as `raise`, except that when no handler\n     /// is found the `default` argument is called instead of failing the task.\n-    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n+    pub fn raise_default(&self, t: T, default: || -> U) -> U {\n         match local_data::pop(self.key) {\n             None => {\n                 debug!(\"Condition.raise: found no handler\");\n@@ -145,7 +145,7 @@ impl<T, U> Condition<T, U> {\n                     None => {}\n                     Some(hp) => local_data::set(self.key, hp)\n                 }\n-                let handle : &fn(T) -> U = unsafe {\n+                let handle : |T| -> U = unsafe {\n                     ::cast::transmute(handler.handle)\n                 };\n                 let u = handle(t);"}, {"sha": "d2874a6f7f578ea0fd06eeed5b4eaa083a7e0d7c", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -38,7 +38,7 @@ impl<L, R> Either<L, R> {\n     /// `value` is `Right(R)` then `f_right` is applied to its contents, and the\n     /// result is returned.\n     #[inline]\n-    pub fn either<T>(&self, f_left: &fn(&L) -> T, f_right: &fn(&R) -> T) -> T {\n+    pub fn either<T>(&self, f_left: |&L| -> T, f_right: |&R| -> T) -> T {\n         match *self {\n             Left(ref l) => f_left(l),\n             Right(ref r) => f_right(r)"}, {"sha": "427690a4aa5899de8aeab2cae5288556334e37ea", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -931,8 +931,10 @@ impl<'self> Formatter<'self> {\n         }\n     }\n \n-    fn with_padding(&mut self, padding: uint,\n-                    default: parse::Alignment, f: &fn(&mut Formatter)) {\n+    fn with_padding(&mut self,\n+                    padding: uint,\n+                    default: parse::Alignment,\n+                    f: |&mut Formatter|) {\n         let align = match self.align {\n             parse::AlignUnknown => default,\n             parse::AlignLeft | parse::AlignRight => self.align"}, {"sha": "f15abff8316903c71ef86b071df199abae77cd0e", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -408,7 +408,7 @@ mod tests {\n     // Hash just the bytes of the slice, without length prefix\n     struct Bytes<'self>(&'self [u8]);\n     impl<'self> IterBytes for Bytes<'self> {\n-        fn iter_bytes(&self, _lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+        fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n             f(**self)\n         }\n     }"}, {"sha": "2d3e6431b0cd7761ad5a5194059bf1655be40ae0", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -80,8 +80,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline]\n-    fn bucket_sequence(&self, hash: uint,\n-                       op: &fn(uint) -> bool) -> bool {\n+    fn bucket_sequence(&self, hash: uint, op: |uint| -> bool) -> bool {\n         let start_idx = self.to_bucket(hash);\n         let len_buckets = self.buckets.len();\n         let mut idx = start_idx;\n@@ -360,8 +359,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Modify and return the value corresponding to the key in the map, or\n     /// insert and return a new value if it doesn't exist.\n-    pub fn mangle<'a,A>(&'a mut self, k: K, a: A, not_found: &fn(&K, A) -> V,\n-                        found: &fn(&K, &mut V, A)) -> &'a mut V {\n+    pub fn mangle<'a,\n+                  A>(\n+                  &'a mut self,\n+                  k: K,\n+                  a: A,\n+                  not_found: |&K, A| -> V,\n+                  found: |&K, &mut V, A|)\n+                  -> &'a mut V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n             // that we do not resize if this call to insert is\n@@ -395,16 +400,20 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n-    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V)\n+    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n         self.mangle(k, (), |k,_a| f(k), |_k,_v,_a| ())\n     }\n \n     /// Insert a key-value pair into the map if the key is not already present.\n     /// Otherwise, modify the existing value for the key.\n     /// Returns the new or modified value for the key.\n-    pub fn insert_or_update_with<'a>(&'a mut self, k: K, v: V,\n-                                     f: &fn(&K, &mut V)) -> &'a mut V {\n+    pub fn insert_or_update_with<'a>(\n+                                 &'a mut self,\n+                                 k: K,\n+                                 v: V,\n+                                 f: |&K, &mut V|)\n+                                 -> &'a mut V {\n         self.mangle(k, v, |_k,a| a, |k,v,_a| f(k,v))\n     }\n \n@@ -446,12 +455,12 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     }\n \n     /// Visit all keys\n-    pub fn each_key(&self, blk: &fn(k: &K) -> bool) -> bool {\n+    pub fn each_key(&self, blk: |k: &K| -> bool) -> bool {\n         self.iter().advance(|(k, _)| blk(k))\n     }\n \n     /// Visit all values\n-    pub fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) -> bool {\n+    pub fn each_value<'a>(&'a self, blk: |v: &'a V| -> bool) -> bool {\n         self.iter().advance(|(_, v)| blk(v))\n     }\n "}, {"sha": "5eb2e72e96b21efc03965f7191fae965a13f31e3", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -54,8 +54,7 @@ impl<'self, R: Reader> Iterator<u8> for ByteIterator<R> {\n     }\n }\n \n-pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: &fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n@@ -88,8 +87,7 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n     }\n }\n \n-pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: &fn(v: &[u8]) -> T) -> T {\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),"}, {"sha": "930f58ef33f2759b7c0636ea5319630e3141aafc", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -75,7 +75,7 @@ pub struct File {\n     priv last_nread: int,\n }\n \n-fn io_raise<T>(f: &fn(io: &mut IoFactory) -> Result<T, IoError>) -> Option<T> {\n+fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n     do with_local_io |io| {\n         match f(io) {\n             Ok(t) => Some(t),\n@@ -499,7 +499,7 @@ pub fn rmdir(path: &Path) {\n ///     use std::io::fs;\n ///\n ///     // one possible implementation of fs::walk_dir only visiting files\n-///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///     fn visit_dirs(dir: &Path, cb: |&Path|) {\n ///         if dir.is_dir() {\n ///             let contents = fs::readdir(dir).unwrap();\n ///             for entry in contents.iter() {"}, {"sha": "decdfb60bfbe51f40883bdfefda279d0694ea0e8", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -240,7 +240,7 @@ impl<'self> Buffer for BufReader<'self> {\n \n ///Calls a function with a MemWriter and returns\n ///the writer's stored vector.\n-pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {\n+pub fn with_mem_writer(writeFn: |&mut MemWriter|) -> ~[u8] {\n     let mut writer = MemWriter::new();\n     writeFn(&mut writer);\n     writer.inner()"}, {"sha": "1d0fef48890714b178ff82f1669df95dad4624a6", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -394,7 +394,7 @@ condition! {\n \n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n-pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n+pub fn ignore_io_error<T>(cb: || -> T) -> T {\n     do io_error::cond.trap(|_| {\n         // just swallow the error.. downstream users\n         // who can make a decision based on a None result\n@@ -407,7 +407,7 @@ pub fn ignore_io_error<T>(cb: &fn() -> T) -> T {\n /// Helper for catching an I/O error and wrapping it in a Result object. The\n /// return result will be the last I/O error that happened or the result of the\n /// closure if no error occurred.\n-pub fn result<T>(cb: &fn() -> T) -> Result<T, IoError> {\n+pub fn result<T>(cb: || -> T) -> Result<T, IoError> {\n     let mut err = None;\n     let ret = io_error::cond.trap(|e| {\n         if err.is_none() {"}, {"sha": "abaeab609aaa02dc989eb9ad741d116e20b53e50", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -33,7 +33,7 @@ use vec;\n #[cfg(windows)] use ptr;\n #[cfg(windows)] use str;\n \n-fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n+fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n "}, {"sha": "6aa3ae65fc9852a6dfc20fa8c4ad2619d7695e0f", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -432,7 +432,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n+fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n     use vec;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n@@ -460,7 +460,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n     use vec;\n \n     // On posixy systems we can pass a char** for envp, which is a\n@@ -490,7 +490,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n }\n \n #[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n     // On win32 we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n     // \\0 to terminate.\n@@ -514,7 +514,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n     }\n }\n \n-fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n+fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n     match d {\n       Some(dir) => dir.with_c_str(|buf| cb(buf)),\n       None => cb(ptr::null())"}, {"sha": "9c63108beef3e5fec3da42865b83c6e8f2de82ef", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -81,7 +81,8 @@ impl<'self> Parser<'self> {\n     }\n \n     // Commit only if parser returns Some\n-    fn read_atomically<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+    fn read_atomically<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n+                       -> Option<T> {\n         let pos = self.pos;\n         let r = cb(self);\n         if r.is_none() {\n@@ -91,14 +92,16 @@ impl<'self> Parser<'self> {\n     }\n \n     // Commit only if parser read till EOF\n-    fn read_till_eof<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+    fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n+                     -> Option<T> {\n         do self.read_atomically |p| {\n             cb(p).filtered(|_| p.is_eof())\n         }\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &[&fn(&mut Parser) -> Option<T>]) -> Option<T> {\n+    fn read_or<T>(&mut self, parsers: &[|&mut Parser| -> Option<T>])\n+               -> Option<T> {\n         for pf in parsers.iter() {\n             match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n                 Some(r) => return Some(r),\n@@ -109,12 +112,14 @@ impl<'self> Parser<'self> {\n     }\n \n     // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C>(&mut self,\n-            pa: &fn(&mut Parser) -> Option<A>,\n-            pb: &fn(&mut Parser) -> Option<B>,\n-            pc: &fn(&mut Parser) -> Option<C>\n-        ) -> Option<(A, B, C)>\n-    {\n+    fn read_seq_3<A,\n+                  B,\n+                  C>(\n+                  &mut self,\n+                  pa: |&mut Parser| -> Option<A>,\n+                  pb: |&mut Parser| -> Option<B>,\n+                  pc: |&mut Parser| -> Option<C>)\n+                  -> Option<(A, B, C)> {\n         do self.read_atomically |p| {\n             let a = pa(p);\n             let b = if a.is_some() { pb(p) } else { None };"}, {"sha": "b8cdbfc25cb4cfb21f01107bb533e2ee92a4749a", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -74,7 +74,9 @@ pub struct UdpStream {\n }\n \n impl UdpStream {\n-    pub fn as_socket<T>(&mut self, f: &fn(&mut UdpSocket) -> T) -> T { f(&mut self.socket) }\n+    pub fn as_socket<T>(&mut self, f: |&mut UdpSocket| -> T) -> T {\n+        f(&mut self.socket)\n+    }\n \n     pub fn disconnect(self) -> UdpSocket { self.socket }\n }"}, {"sha": "1362d702f1c3a9c53454deae7214f34dd6229dfc", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -69,7 +69,7 @@ enum StdSource {\n     File(~RtioFileStream),\n }\n \n-fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n+fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n     do with_local_io |io| {\n         let fd = unsafe { libc::dup(fd) };\n         match io.tty_open(fd, readable) {\n@@ -121,7 +121,7 @@ pub fn stderr() -> StdWriter {\n //          // io1 aliases io2\n //      }\n //  }\n-fn with_task_stdout(f: &fn(&mut Writer)) {\n+fn with_task_stdout(f: |&mut Writer|) {\n     use rt::local::Local;\n     use rt::task::Task;\n "}, {"sha": "f736b10cc4fc58d493c5d9b730444a50db731805", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -433,7 +433,7 @@ pub trait Iterator<A> {\n     /// range(0, 5).advance(|x| {print!(\"{} \", x); true});\n     /// ```\n     #[inline]\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn advance(&mut self, f: |A| -> bool) -> bool {\n         loop {\n             match self.next() {\n                 Some(x) => {\n@@ -522,7 +522,7 @@ pub trait Iterator<A> {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n+    fn fold<B>(&mut self, init: B, f: |B, A| -> B) -> B {\n         let mut accum = init;\n         loop {\n             match self.next() {\n@@ -558,7 +558,7 @@ pub trait Iterator<A> {\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ```\n     #[inline]\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn all(&mut self, f: |A| -> bool) -> bool {\n         for x in *self { if !f(x) { return false; } }\n         true\n     }\n@@ -575,14 +575,14 @@ pub trait Iterator<A> {\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ```\n     #[inline]\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n+    fn any(&mut self, f: |A| -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n \n     /// Return the first element satisfying the specified predicate\n     #[inline]\n-    fn find(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n+    fn find(&mut self, predicate: |&A| -> bool) -> Option<A> {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -591,7 +591,7 @@ pub trait Iterator<A> {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn position(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) {\n@@ -604,7 +604,7 @@ pub trait Iterator<A> {\n \n     /// Count the number of elements satisfying the specified predicate\n     #[inline]\n-    fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n+    fn count(&mut self, predicate: |A| -> bool) -> uint {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) { i += 1 }\n@@ -622,7 +622,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n+    fn max_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match max {\n@@ -646,7 +646,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n+    fn min_by<B: Ord>(&mut self, f: |&A| -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n             let x_val = f(&x);\n             match min {\n@@ -729,7 +729,7 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    fn rposition(&mut self, predicate: &fn(A) -> bool) -> Option<uint> {\n+    fn rposition(&mut self, predicate: |A| -> bool) -> Option<uint> {\n         let (lower, upper) = self.size_hint();\n         assert!(upper == Some(lower));\n         let mut i = lower;"}, {"sha": "083de15008a27f23c0d995f9680b4698567d43cd", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -177,7 +177,7 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n ///\n /// It is considered a runtime error to attempt to get a value which is already\n /// on loan via the `get_mut` method provided.\n-pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n     get_with(key, ImmLoan, f)\n }\n \n@@ -188,7 +188,7 @@ pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n /// It is considered a runtime error to attempt to get a value which is already\n /// on loan via this or the `get` methods. This is similar to how it's a runtime\n /// error to take two mutable loans on an `@mut` box.\n-pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n+pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n     do get_with(key, MutLoan) |x| {\n         match x {\n             None => f(None),\n@@ -202,9 +202,12 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: &fn(Option<&mut T>) -> U) -> U {\n     }\n }\n \n-fn get_with<T: 'static, U>(key: Key<T>,\n-                           state: LoanState,\n-                           f: &fn(Option<&T>) -> U) -> U {\n+fn get_with<T:'static,\n+            U>(\n+            key: Key<T>,\n+            state: LoanState,\n+            f: |Option<&T>| -> U)\n+            -> U {\n     // This function must be extremely careful. Because TLS can store owned\n     // values, and we must have some form of `get` function other than `pop`,\n     // this function has to give a `&` reference back to the caller.\n@@ -335,7 +338,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n ///\n /// This function will have the same runtime errors as generated from `pop` and\n /// `set` (the key must not currently be on loan\n-pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n+pub fn modify<T: 'static>(key: Key<T>, f: |Option<T>| -> Option<T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}"}, {"sha": "9141e87bd722d20bac35218bae14fba6aa0e735c", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -415,7 +415,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];"}, {"sha": "aeda3fa1cd193f71d62c6662c1a64a6be5443edc", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -108,7 +108,7 @@ pub trait Unsigned: Num {}\n /// ```\n ///\n pub trait Times {\n-    fn times(&self, it: &fn());\n+    fn times(&self, it: ||);\n }\n \n pub trait Integer: Num"}, {"sha": "5d713f1a622cc7e51179e7266f3ba14637ef5b9d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -132,9 +132,19 @@ static NAN_BUF:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-pub fn int_to_str_bytes_common<T:NumCast+Zero+Eq+Ord+Integer+\n-                                 Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n-        num: T, radix: uint, sign: SignFormat, f: &fn(u8)) {\n+pub fn int_to_str_bytes_common<T:NumCast\n+                                +Zero\n+                                +Eq\n+                                +Ord\n+                                +Integer\n+                                +Div<T,T>\n+                                +Neg<T>\n+                                +Rem<T,T>\n+                                +Mul<T,T>>(\n+                                num: T,\n+                                radix: uint,\n+                                sign: SignFormat,\n+                                f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();"}, {"sha": "1cc0c19150137caf7f6b48fee8dcbe6f2b5e23ca", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -85,7 +85,7 @@ impl num::Times for uint {\n     /// use with integer literals of inferred integer-type as\n     /// the self-value (eg. `do 100.times { ... }`).\n     ///\n-    fn times(&self, it: &fn()) {\n+    fn times(&self, it: ||) {\n         let mut i = *self;\n         while i > 0 {\n             it();"}, {"sha": "49f270369f72cbdff0a550ac59b4a57f09d32b9e", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -266,7 +266,7 @@ impl FromStrRadix for $T {\n \n /// Convert to a string as a byte slice in a given base.\n #[inline]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: &fn(v: &[u8]) -> U) -> U {\n+pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // The radix can be as low as 2, so we need at least 64 characters for a\n     // base 2 number.\n     let mut buf = [0u8, ..64];"}, {"sha": "c5a10c75640ec364f327b0367db471d50f87987d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -147,7 +147,7 @@ impl<T> Option<T> {\n \n     /// Returns the contained value or computes it from a closure\n     #[inline]\n-    pub fn unwrap_or_else(self, f: &fn() -> T) -> T {\n+    pub fn unwrap_or_else(self, f: || -> T) -> T {\n         match self {\n             Some(x) => x,\n             None => f()\n@@ -160,19 +160,19 @@ impl<T> Option<T> {\n \n     /// Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n     #[inline]\n-    pub fn map<U>(self, f: &fn(T) -> U) -> Option<U> {\n+    pub fn map<U>(self, f: |T| -> U) -> Option<U> {\n         match self { Some(x) => Some(f(x)), None => None }\n     }\n \n     /// Applies a function to the contained value or returns a default.\n     #[inline]\n-    pub fn map_default<U>(self, def: U, f: &fn(T) -> U) -> U {\n+    pub fn map_default<U>(self, def: U, f: |T| -> U) -> U {\n         match self { None => def, Some(t) => f(t) }\n     }\n \n     /// Apply a function to the contained value or do nothing.\n     /// Returns true if the contained value was mutated.\n-    pub fn mutate(&mut self, f: &fn(T) -> T) -> bool {\n+    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n             true\n@@ -181,7 +181,7 @@ impl<T> Option<T> {\n \n     /// Apply a function to the contained value or set it to a default.\n     /// Returns true if the contained value was mutated, or false if set to the default.\n-    pub fn mutate_default(&mut self, def: T, f: &fn(T) -> T) -> bool {\n+    pub fn mutate_default(&mut self, def: T, f: |T| -> T) -> bool {\n         if self.is_some() {\n             *self = Some(f(self.take_unwrap()));\n             true\n@@ -235,7 +235,7 @@ impl<T> Option<T> {\n     /// Returns `None` if the option is `None`, otherwise calls `f` with the\n     /// wrapped value and returns the result.\n     #[inline]\n-    pub fn and_then<U>(self, f: &fn(T) -> Option<U>) -> Option<U> {\n+    pub fn and_then<U>(self, f: |T| -> Option<U>) -> Option<U> {\n         match self {\n             Some(x) => f(x),\n             None => None,\n@@ -254,7 +254,7 @@ impl<T> Option<T> {\n     /// Returns the option if it contains a value, otherwise calls `f` and\n     /// returns the result.\n     #[inline]\n-    pub fn or_else(self, f: &fn() -> Option<T>) -> Option<T> {\n+    pub fn or_else(self, f: || -> Option<T>) -> Option<T> {\n         match self {\n             Some(_) => self,\n             None => f(),\n@@ -273,7 +273,7 @@ impl<T> Option<T> {\n \n     /// Filters an optional value using a given function.\n     #[inline(always)]\n-    pub fn filtered(self, f: &fn(t: &T) -> bool) -> Option<T> {\n+    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n         match self {\n             Some(x) => if(f(&x)) {Some(x)} else {None},\n             None => None\n@@ -282,7 +282,7 @@ impl<T> Option<T> {\n \n     /// Applies a function zero or more times until the result is `None`.\n     #[inline]\n-    pub fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n+    pub fn while_some(self, blk: |v: T| -> Option<T>) {\n         let mut opt = self;\n         while opt.is_some() {\n             opt = blk(opt.unwrap());"}, {"sha": "3692bc303fb616bd747ddcaafaaddf2c506c6b72", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -94,7 +94,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use libc::types::os::arch::extra::DWORD;\n \n-    pub fn fill_utf16_buf_and_decode(f: &fn(*mut u16, DWORD) -> DWORD)\n+    pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD)\n         -> Option<~str> {\n \n         unsafe {\n@@ -125,7 +125,7 @@ pub mod win32 {\n         }\n     }\n \n-    pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n+    pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n         t.push(0u16);\n@@ -137,7 +137,7 @@ pub mod win32 {\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n-fn with_env_lock<T>(f: &fn() -> T) -> T {\n+fn with_env_lock<T>(f: || -> T) -> T {\n     use unstable::mutex::{Mutex, MUTEX_INIT};\n     use unstable::finally::Finally;\n "}, {"sha": "6f152fa2a411559ed0464b6052095dc5dc108d44", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -559,7 +559,7 @@ impl<'self, P: GenericPath> Display<'self, P> {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn with_str<T>(&self, f: &fn(&str) -> T) -> T {\n+    pub fn with_str<T>(&self, f: |&str| -> T) -> T {\n         let opt = if self.filename { self.path.filename_str() }\n                   else { self.path.as_str() };\n         match opt {"}, {"sha": "86f1e7f6e86ae42547da9f579b1262802c2c99f6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -87,7 +87,7 @@ impl ToCStr for Path {\n \n impl IterBytes for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "d5bc6b85424f0893bf583b4975790664d018d45e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -112,7 +112,7 @@ impl ToCStr for Path {\n \n impl IterBytes for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(&[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |&[u8]| -> bool) -> bool {\n         self.repr.iter_bytes(lsb0, f)\n     }\n }\n@@ -970,7 +970,8 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     }\n     return None;\n \n-    fn parse_two_comps<'a>(mut path: &'a str, f: &fn(char)->bool) -> Option<(uint, uint)> {\n+    fn parse_two_comps<'a>(mut path: &'a str, f: |char| -> bool)\n+                       -> Option<(uint, uint)> {\n         let idx_a = match path.find(|x| f(x)) {\n             None => return None,\n             Some(x) => x"}, {"sha": "887f7f2e9a6310ea4743c691235c11478d0df664", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -56,7 +56,7 @@ impl<T> Clone for *mut T {\n \n /// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline]\n-pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n+pub unsafe fn position<T>(buf: *T, f: |&T| -> bool) -> uint {\n     let mut i = 0;\n     loop {\n         if f(&(*offset(buf, i as int))) { return i; }\n@@ -195,7 +195,7 @@ pub fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n \n   SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n */\n-pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n+pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: |*T|) {\n     debug!(\"array_each_with_len: before iterate\");\n     if (arr as uint == 0) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n@@ -217,7 +217,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n   pointer array. Barely less-dodgy Pointer Arithmetic.\n   Dragons be here.\n */\n-pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n+pub unsafe fn array_each<T>(arr: **T, cb: |*T|) {\n     if (arr as uint == 0) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }"}, {"sha": "9e83afa819c18571a3fbdbd8a63fc1d54c6930fc", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -203,7 +203,7 @@ impl<T> RcMut<T> {\n impl<T> RcMut<T> {\n     /// Fails if there is already a mutable borrow of the box\n     #[inline]\n-    pub fn with_borrow<U>(&self, f: &fn(&T) -> U) -> U {\n+    pub fn with_borrow<U>(&self, f: |&T| -> U) -> U {\n         unsafe {\n             assert!((*self.ptr).borrow != Mutable);\n             let previous = (*self.ptr).borrow;\n@@ -216,7 +216,7 @@ impl<T> RcMut<T> {\n \n     /// Fails if there is already a mutable or immutable borrow of the box\n     #[inline]\n-    pub fn with_mut_borrow<U>(&self, f: &fn(&mut T) -> U) -> U {\n+    pub fn with_mut_borrow<U>(&self, f: |&mut T| -> U) -> U {\n         unsafe {\n             assert_eq!((*self.ptr).borrow, Nothing);\n             (*self.ptr).borrow = Mutable;"}, {"sha": "d0a696491761460fdd35399c7aa248f000f5d825", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -28,7 +28,7 @@ use unstable::raw;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void);\n+    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void);\n     fn push_ptr(&mut self);\n     fn pop_ptr(&mut self);\n }"}, {"sha": "33e80d7fcaeec4d843999731bad20b6a30cb78a5", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -116,7 +116,7 @@ pub fn ReprVisitor<'a>(ptr: *c_void,\n \n impl<'self> MovePtr for ReprVisitor<'self> {\n     #[inline]\n-    fn move_ptr(&mut self, adjustment: &fn(*c_void) -> *c_void) {\n+    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&mut self) {\n@@ -131,7 +131,7 @@ impl<'self> ReprVisitor<'self> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n-    pub fn get<T>(&mut self, f: &fn(&mut ReprVisitor, &T)) -> bool {\n+    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T|) -> bool {\n         unsafe {\n             f(self, transmute::<*c_void,&T>(self.ptr));\n         }"}, {"sha": "97daf8d7e60df5dca24ad7cdd1f9df56bbaaa1db", "filename": "src/libstd/result.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -143,7 +143,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///         parse_bytes(buf)\n     ///     }\n     #[inline]\n-    pub fn map<U>(self, op: &fn(T) -> U) -> Result<U,E> {\n+    pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {\n         match self {\n           Ok(t) => Ok(op(t)),\n           Err(e) => Err(e)\n@@ -156,7 +156,7 @@ impl<T, E: ToStr> Result<T, E> {\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     #[inline]\n-    pub fn map_err<F>(self, op: &fn(E) -> F) -> Result<T,F> {\n+    pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n         match self {\n           Ok(t) => Ok(t),\n           Err(e) => Err(op(e))\n@@ -208,7 +208,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n-    pub fn and_then<U>(self, op: &fn(T) -> Result<U, E>) -> Result<U, E> {\n+    pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n         match self {\n             Ok(t) => op(t),\n             Err(e) => Err(e),\n@@ -228,7 +228,7 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// This function can be used for control flow based on result values\n     #[inline]\n-    pub fn or_else<F>(self, op: &fn(E) -> Result<T, F>) -> Result<T, F> {\n+    pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n         match self {\n             Ok(t) => Ok(t),\n             Err(e) => op(e),\n@@ -378,12 +378,14 @@ pub fn collect<T, E, Iter: Iterator<Result<T, E>>>(mut iterator: Iter)\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-pub fn fold<T, V, E,\n+pub fn fold<T,\n+            V,\n+            E,\n             Iter: Iterator<Result<T, E>>>(\n             mut iterator: Iter,\n             mut init: V,\n-            f: &fn(V, T) -> V)\n-         -> Result<V, E> {\n+            f: |V, T| -> V)\n+            -> Result<V, E> {\n     for t in iterator {\n         match t {\n             Ok(v) => init = f(init, v),\n@@ -399,9 +401,7 @@ pub fn fold<T, V, E,\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, a simple `Ok(())` is returned.\n #[inline]\n-pub fn fold_<T, E, Iter: Iterator<Result<T, E>>>(\n-             iterator: Iter)\n-          -> Result<(), E> {\n+pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }\n "}, {"sha": "a173be64356702b00290d14392a6bb4d740805c4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -107,9 +107,8 @@ mod imp {\n         })\n     }\n \n-    fn with_lock<T>(f: &fn() -> T) -> T {\n+    fn with_lock<T>(f: || -> T) -> T {\n         static mut lock: Mutex = MUTEX_INIT;\n-\n         do (|| {\n             unsafe {\n                 lock.lock();"}, {"sha": "2c1c5d84be15469d7d2ee4ea5bfe253bb10d8291", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -170,7 +170,7 @@ impl EventLoop for BasicLoop {\n         ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n     }\n \n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|) {\n         f(self.io)\n     }\n }"}, {"sha": "d1f69ada301cb9255a56586dba2a326bdc38b911", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -40,7 +40,7 @@ fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n     }\n }\n \n-fn swap_task_borrow_list(f: &fn(~[BorrowRecord]) -> ~[BorrowRecord]) {\n+fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n     let borrows = match try_take_task_borrow_list() {\n         Some(l) => l,\n         None => ~[]"}, {"sha": "987b32c084674653cfff00c8403d576c982c398e", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -79,8 +79,10 @@ fn version(crate_map: &CrateMap) -> i32 {\n     }\n }\n \n-fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n-                            visited: &mut HashSet<*CrateMap<'a>>) {\n+fn do_iter_crate_map<'a>(\n+                     crate_map: &'a CrateMap<'a>,\n+                     f: |&ModEntry|,\n+                     visited: &mut HashSet<*CrateMap<'a>>) {\n     if visited.insert(crate_map as *CrateMap) {\n         match version(crate_map) {\n             2 => {\n@@ -98,7 +100,7 @@ fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n }\n \n /// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n+pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: |&ModEntry|) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n     //        way to do this\n     let mut v: HashSet<*CrateMap<'a>> = HashSet::with_capacity_and_keys(0, 0, 32);"}, {"sha": "fa4746a6bb77f6088e5afc6c00758c796ffe5d0e", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -369,7 +369,7 @@ impl BlockedTask {\n \n // So that KillHandle can be hashed in the taskgroup bookkeeping code.\n impl IterBytes for KillHandle {\n-    fn iter_bytes(&self, lsb0: bool, f: &fn(buf: &[u8]) -> bool) -> bool {\n+    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n         self.data.iter_bytes(lsb0, f)\n     }\n }\n@@ -525,9 +525,8 @@ impl KillHandle {\n         // NB: Takes a pthread mutex -- 'blk' not allowed to reschedule.\n         #[inline]\n         fn add_lazy_tombstone(parent: &mut KillHandle,\n-                              blk: &fn(Option<proc() -> bool>)\n-                              -> proc() -> bool) {\n-\n+                              blk: |Option<proc() -> bool>| -> proc() -> bool)\n+                              {\n             let inner: &mut KillHandleInner = unsafe { &mut *parent.get() };\n             unsafe {\n                 do inner.graveyard_lock.lock {"}, {"sha": "d47dae96283a6fbfa1ea52a378713371bce69dc7", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -18,7 +18,7 @@ pub trait Local {\n     fn put(value: ~Self);\n     fn take() -> ~Self;\n     fn exists(unused_value: Option<Self>) -> bool;\n-    fn borrow<T>(f: &fn(&mut Self) -> T) -> T;\n+    fn borrow<T>(f: |&mut Self| -> T) -> T;\n     unsafe fn unsafe_take() -> ~Self;\n     unsafe fn unsafe_borrow() -> *mut Self;\n     unsafe fn try_unsafe_borrow() -> Option<*mut Self>;\n@@ -30,7 +30,7 @@ impl Local for Task {\n     #[inline]\n     fn take() -> ~Task { unsafe { local_ptr::take() } }\n     fn exists(_: Option<Task>) -> bool { local_ptr::exists() }\n-    fn borrow<T>(f: &fn(&mut Task) -> T) -> T {\n+    fn borrow<T>(f: |&mut Task| -> T) -> T {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n         unsafe {\n@@ -78,7 +78,7 @@ impl Local for Scheduler {\n             }\n         }\n     }\n-    fn borrow<T>(f: &fn(&mut Scheduler) -> T) -> T {\n+    fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n         do Local::borrow |task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {"}, {"sha": "862ecd6499a5011bcc7546905b6b480d5352cbd1", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -103,7 +103,7 @@ pub fn exists() -> bool {\n /// # Safety note\n ///\n /// Does not validate the pointer type.\n-pub unsafe fn borrow<T>(f: &fn(&mut T)) {\n+pub unsafe fn borrow<T>(f: |&mut T|) {\n     let mut value = take();\n \n     // XXX: Need a different abstraction from 'finally' here to avoid unsafety"}, {"sha": "f83932f9ffa28ed571108a347e0bb74c5d3fd50c", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -36,7 +36,7 @@ pub trait EventLoop {\n \n     /// The asynchronous I/O services. Not all event loops may provide one\n     // FIXME(#9382) this is an awful interface\n-    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory));\n+    fn io<'a>(&'a mut self, f: |&'a mut IoFactory|);\n }\n \n pub trait RemoteCallback {\n@@ -75,7 +75,7 @@ pub enum CloseBehavior {\n     CloseAsynchronously,\n }\n \n-pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n+pub fn with_local_io<T>(f: |&mut IoFactory| -> Option<T>) -> Option<T> {\n     use rt::sched::Scheduler;\n     use rt::local::Local;\n     use io::native;"}, {"sha": "e317b76b24d0e2d9bf96aebd649695aee35abc2b", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -556,7 +556,7 @@ impl Scheduler {\n \n     pub fn change_task_context(mut ~self,\n                                next_task: ~Task,\n-                               f: &fn(&mut Scheduler, ~Task)) {\n+                               f: |&mut Scheduler, ~Task|) {\n         // The current task is grabbed from TLS, not taken as an input.\n         // Doing an unsafe_take to avoid writing back a null pointer -\n         // We're going to call `put` later to do that.\n@@ -568,8 +568,8 @@ impl Scheduler {\n \n         // These transmutes do something fishy with a closure.\n         let f_fake_region = unsafe {\n-            transmute::<&fn(&mut Scheduler, ~Task),\n-                        &fn(&mut Scheduler, ~Task)>(f)\n+            transmute::<|&mut Scheduler, ~Task|,\n+                        |&mut Scheduler, ~Task|>(f)\n         };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n \n@@ -678,7 +678,7 @@ impl Scheduler {\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n     pub fn deschedule_running_task_and_then(mut ~self,\n-                                            f: &fn(&mut Scheduler, BlockedTask)) {\n+                                            f: |&mut Scheduler, BlockedTask|) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n         let stask = self.sched_task.take_unwrap();\n@@ -687,7 +687,7 @@ impl Scheduler {\n     }\n \n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n-                                         f: &fn(&mut Scheduler, BlockedTask)) {\n+                                         f: |&mut Scheduler, BlockedTask|) {\n         // This is where we convert the BlockedTask-taking closure into one\n         // that takes just a Task, and is aware of the block-or-killed protocol.\n         do self.change_task_context(next_task) |sched, task| {\n@@ -829,18 +829,18 @@ impl CleanupJob {\n     }\n }\n \n-// XXX: Some hacks to put a &fn in Scheduler without borrowck\n+// XXX: Some hacks to put a || closure in Scheduler without borrowck\n // complaining\n type UnsafeTaskReceiver = raw::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(&mut Scheduler, ~Task)) -> Self;\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task);\n+    fn from_fn(|&mut Scheduler, ~Task|) -> Self;\n+    fn to_fn(self) -> |&mut Scheduler, ~Task|;\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(&mut Scheduler, ~Task)) -> UnsafeTaskReceiver {\n+    fn from_fn(f: |&mut Scheduler, ~Task|) -> UnsafeTaskReceiver {\n         unsafe { transmute(f) }\n     }\n-    fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n+    fn to_fn(self) -> |&mut Scheduler, ~Task| { unsafe { transmute(self) } }\n }\n \n // On unix, we read randomness straight from /dev/urandom, but the"}, {"sha": "3fe555de56c9e2c8c750182f04a279274ed24ac0", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -282,7 +282,7 @@ impl Task {\n         }\n     }\n \n-    pub fn run(&mut self, f: &fn()) {\n+    pub fn run(&mut self, f: ||) {\n         rtdebug!(\"run called on task: {}\", borrow::to_uint(self));\n \n         // The only try/catch block in the world. Attempt to run the task's\n@@ -494,7 +494,7 @@ impl Coroutine {\n static UNWIND_TOKEN: uintptr_t = 839147;\n \n impl Unwinder {\n-    pub fn try(&mut self, f: &fn()) {\n+    pub fn try(&mut self, f: ||) {\n         use unstable::raw::Closure;\n \n         unsafe {\n@@ -512,7 +512,7 @@ impl Unwinder {\n                     code: transmute(code),\n                     env: transmute(env),\n                 };\n-                let closure: &fn() = transmute(closure);\n+                let closure: || = transmute(closure);\n                 closure();\n             }\n         }"}, {"sha": "c567fd0a8b312307af65cb07be6c3e3a6864a445", "filename": "src/libstd/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -925,7 +925,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n /// # Failures\n ///\n /// * Fails on invalid utf-16 data\n-pub fn utf16_chars(v: &[u16], f: &fn(char)) {\n+pub fn utf16_chars(v: &[u16], f: |char|) {\n     let len = v.len();\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1762,7 +1762,7 @@ pub trait StrSlice<'self> {\n     /// Work with the byte buffer and length of a slice.\n     ///\n     /// The buffer does not have a null terminator.\n-    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T;\n }\n \n impl<'self> StrSlice<'self> for &'self str {\n@@ -2268,7 +2268,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n+    fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T {\n         let v: &[u8] = unsafe { cast::transmute(*self) };\n         v.as_imm_buf(f)\n     }\n@@ -2355,7 +2355,7 @@ pub trait OwnedStr {\n     ///\n     /// The caller must make sure any mutations to this buffer keep the string\n     /// valid UTF-8!\n-    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T;\n+    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T;\n }\n \n impl OwnedStr for ~str {\n@@ -2456,7 +2456,7 @@ impl OwnedStr for ~str {\n     }\n \n     #[inline]\n-    fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n+    fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T {\n         unsafe {\n             raw::as_owned_vec(self).as_mut_buf(f)\n         }"}, {"sha": "f9b918d6d1215544df7dec43e9eeaea7abfb9b9b", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -554,7 +554,7 @@ pub fn try<T:Send>(f: proc() -> T) -> Result<T, ~Any> {\n /* Lifecycle functions */\n \n /// Read the name of the current task.\n-pub fn with_task_name<U>(blk: &fn(Option<&str>) -> U) -> U {\n+pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n@@ -605,7 +605,7 @@ pub fn failing() -> bool {\n  * }\n  * ```\n  */\n-pub fn unkillable<U>(f: &fn() -> U) -> U {\n+pub fn unkillable<U>(f: || -> U) -> U {\n     use rt::task::Task;\n \n     unsafe {\n@@ -640,7 +640,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n  *    // Task is unkillable again\n  * }\n  */\n-pub fn rekillable<U>(f: &fn() -> U) -> U {\n+pub fn rekillable<U>(f: || -> U) -> U {\n     use rt::task::Task;\n \n     unsafe {\n@@ -1201,7 +1201,7 @@ fn test_spawn_sched_blocking() {\n }\n \n #[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: &fn(v: proc())) {\n+fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;"}, {"sha": "66a2e8cc5e0d449265bd46dfc93fc3784086d428", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -164,15 +164,17 @@ struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline]\n-fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n+fn access_group<U>(x: &TaskGroupArc, blk: |TaskGroupInner| -> U) -> U {\n     unsafe {\n         x.with(blk)\n     }\n }\n \n #[inline]\n-fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n-                       blk: &fn(x: &mut AncestorNode) -> U) -> U {\n+fn access_ancestors<U>(\n+                    x: &Exclusive<AncestorNode>,\n+                    blk: |x: &mut AncestorNode| -> U)\n+                    -> U {\n     unsafe {\n         x.with(blk)\n     }\n@@ -197,17 +199,17 @@ fn incr_generation(_ancestors: &AncestorList) -> uint { 0 }\n //     is NOT called on the block that forward_blk broke on!).\n // (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n fn each_ancestor(list:        &mut AncestorList,\n-                 bail_blk:    &fn(TaskGroupInner),\n-                 forward_blk: &fn(TaskGroupInner) -> bool)\n-              -> bool {\n+                 bail_blk:    |TaskGroupInner|,\n+                 forward_blk: |TaskGroupInner| -> bool)\n+                 -> bool {\n     // \"Kickoff\" call - there was no last generation.\n     return !coalesce(list, bail_blk, forward_blk, uint::max_value);\n \n     // Recursively iterates, and coalesces afterwards if needed. Returns\n     // whether or not unwinding is needed (i.e., !successful iteration).\n     fn coalesce(list:            &mut AncestorList,\n-                bail_blk:        &fn(TaskGroupInner),\n-                forward_blk:     &fn(TaskGroupInner) -> bool,\n+                bail_blk:        |TaskGroupInner|,\n+                forward_blk:     |TaskGroupInner| -> bool,\n                 last_generation: uint) -> bool {\n         let (coalesce_this, early_break) =\n             iterate(list, bail_blk, forward_blk, last_generation);\n@@ -229,8 +231,8 @@ fn each_ancestor(list:        &mut AncestorList,\n     //     True if the supplied block did 'break', here or in any recursive\n     //     calls. If so, must call the unwinder on all previous nodes.\n     fn iterate(ancestors:       &mut AncestorList,\n-               bail_blk:        &fn(TaskGroupInner),\n-               forward_blk:     &fn(TaskGroupInner) -> bool,\n+               bail_blk:        |TaskGroupInner|,\n+               forward_blk:     |TaskGroupInner| -> bool,\n                last_generation: uint)\n             -> (Option<AncestorList>, bool) {\n         // At each step of iteration, three booleans are at play which govern\n@@ -457,7 +459,7 @@ impl RuntimeGlue {\n         };\n     }\n \n-    fn with_task_handle_and_failing(blk: &fn(&KillHandle, bool)) {\n+    fn with_task_handle_and_failing(blk: |&KillHandle, bool|) {\n         assert!(in_green_task_context());\n         unsafe {\n             // Can't use safe borrow, because the taskgroup destructor needs to\n@@ -467,7 +469,7 @@ impl RuntimeGlue {\n         }\n     }\n \n-    fn with_my_taskgroup<U>(blk: &fn(&Taskgroup) -> U) -> U {\n+    fn with_my_taskgroup<U>(blk: |&Taskgroup| -> U) -> U {\n         assert!(in_green_task_context());\n         unsafe {\n             // Can't use safe borrow, because creating new hashmaps for the\n@@ -545,7 +547,7 @@ fn enlist_many(child: &KillHandle, child_arc: &TaskGroupArc,\n     };\n     if result {\n         // Unwinding function in case any ancestral enlisting fails\n-        let bail: &fn(TaskGroupInner) = |tg| { leave_taskgroup(tg, child, false) };\n+        let bail: |TaskGroupInner| = |tg| { leave_taskgroup(tg, child, false) };\n         // Attempt to join every ancestor group.\n         result = do each_ancestor(ancestors, bail) |ancestor_tg| {\n             // Enlist as a descendant, not as an actual member."}, {"sha": "f60d8641aca12716c2d60e22bfd6f664396a6052", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -107,43 +107,43 @@ impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline]\n-    pub fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    pub fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each_reverse(f)\n     }\n \n     /// Visit all key-value pairs in order\n     #[inline]\n-    pub fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    pub fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         self.root.each(f)\n     }\n \n     /// Visit all keys in order\n     #[inline]\n-    pub fn each_key(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_key(&self, f: |&uint| -> bool) -> bool {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n     #[inline]\n-    pub fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) -> bool {\n+    pub fn each_value<'a>(&'a self, f: |&'a T| -> bool) -> bool {\n         self.each(|_, v| f(v))\n     }\n \n     /// Iterate over the map and mutate the contained values\n     #[inline]\n-    pub fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    pub fn mutate_values(&mut self, f: |&uint, &mut T| -> bool) -> bool {\n         self.root.mutate_values(f)\n     }\n \n     /// Visit all keys in reverse order\n     #[inline]\n-    pub fn each_key_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_key_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.each_reverse(|k, _| f(k))\n     }\n \n     /// Visit all values in reverse order\n     #[inline]\n-    pub fn each_value_reverse(&self, f: &fn(&T) -> bool) -> bool {\n+    pub fn each_value_reverse(&self, f: |&T| -> bool) -> bool {\n         self.each_reverse(|_, v| f(v))\n     }\n \n@@ -266,11 +266,11 @@ impl TrieSet {\n \n     /// Visit all values in order\n     #[inline]\n-    pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n+    pub fn each(&self, f: |&uint| -> bool) -> bool { self.map.each_key(f) }\n \n     /// Visit all values in reverse order\n     #[inline]\n-    pub fn each_reverse(&self, f: &fn(&uint) -> bool) -> bool {\n+    pub fn each_reverse(&self, f: |&uint| -> bool) -> bool {\n         self.map.each_key_reverse(f)\n     }\n \n@@ -328,7 +328,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n-    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    fn each<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.iter() {\n             match *elt {\n                 Internal(ref x) => if !x.each(|i,t| f(i,t)) { return false },\n@@ -339,7 +339,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+    fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n         for elt in self.children.rev_iter() {\n             match *elt {\n                 Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n@@ -350,7 +350,7 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    fn mutate_values<'a>(&'a mut self, f: |&uint, &mut T| -> bool) -> bool {\n         for child in self.children.mut_iter() {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(|i,t| f(i,t)) {"}, {"sha": "a8f56228dcb69060212980df284f54e7aa180313", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -3619,15 +3619,15 @@ pub mod decompose {\n         ('\\U0001d185', '\\U0001d189', 230), ('\\U0001d18a', '\\U0001d18b', 220),\n         ('\\U0001d1aa', '\\U0001d1ad', 230), ('\\U0001d242', '\\U0001d244', 230)\n     ];\n-    pub fn canonical(c: char, i: &fn(char)) { d(c, i, false); }\n+    pub fn canonical(c: char, i: |char|) { d(c, i, false); }\n \n-    pub fn compatibility(c: char, i: &fn(char)) { d(c, i, true); }\n+    pub fn compatibility(c: char, i: |char|) { d(c, i, true); }\n \n     pub fn canonical_combining_class(c: char) -> u8 {\n         bsearch_range_value_table(c, combining_class_table)\n     }\n \n-    fn d(c: char, i: &fn(char), k: bool) {\n+    fn d(c: char, i: |char|, k: bool) {\n         use iter::Iterator;\n         if c <= '\\x7f' { i(c); return; }\n "}, {"sha": "cdfbf8c0049911cc2d6d2ff9f0f66ee71c620821", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -153,10 +153,9 @@ pub mod dl {\n         dlopen(ptr::null(), Lazy as libc::c_int)\n     }\n \n-    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         use unstable::mutex::{Mutex, MUTEX_INIT};\n         static mut lock: Mutex = MUTEX_INIT;\n-\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence. `atomically` asserts that we don't do anything that\n@@ -225,7 +224,7 @@ pub mod dl {\n         handle\n     }\n \n-    pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+    pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n             do atomically {\n                 SetLastError(0);"}, {"sha": "78f1c3655ad6e779bd5889ed160ae6885896c5dc", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -28,13 +28,13 @@ use ops::Drop;\n #[cfg(test)] use task::{failing, spawn};\n \n pub trait Finally<T> {\n-    fn finally(&self, dtor: &fn()) -> T;\n+    fn finally(&self, dtor: ||) -> T;\n }\n \n macro_rules! finally_fn {\n     ($fnty:ty) => {\n         impl<T> Finally<T> for $fnty {\n-            fn finally(&self, dtor: &fn()) -> T {\n+            fn finally(&self, dtor: ||) -> T {\n                 let _d = Finallyalizer {\n                     dtor: dtor\n                 };\n@@ -45,7 +45,7 @@ macro_rules! finally_fn {\n }\n \n impl<'self,T> Finally<T> for &'self fn() -> T {\n-    fn finally(&self, dtor: &fn()) -> T {\n+    fn finally(&self, dtor: ||) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n         };\n@@ -95,7 +95,7 @@ fn test_fail() {\n \n #[test]\n fn test_retval() {\n-    let closure: &fn() -> int = || 10;\n+    let closure: || -> int = || 10;\n     let i = do closure.finally { };\n     assert_eq!(i, 10);\n }"}, {"sha": "4ad4656af7bf2a418d9ffbd12f803abe95678cf8", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -73,7 +73,7 @@ mod tests {\n     fn synthesize_closure() {\n         unsafe {\n             let x = 10;\n-            let f: &fn(int) -> int = |y| x + y;\n+            let f: |int| -> int = |y| x + y;\n \n             assert_eq!(f(20), 30);\n \n@@ -87,7 +87,7 @@ mod tests {\n                 env: environment\n             };\n \n-            let new_f: &fn(int) -> int = cast::transmute(new_closure);\n+            let new_f: |int| -> int = cast::transmute(new_closure);\n             assert_eq!(new_f(20), 30);\n         }\n     }"}, {"sha": "ae4b5d4c6aa37d433705b81a183c44832e90f555", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -296,7 +296,7 @@ impl<T> Drop for UnsafeArc<T>{\n  * synchronization whatsoever. It only makes sense to use for CPU-local issues.\n  */\n // FIXME(#8140) should not be pub\n-pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n+pub unsafe fn atomically<U>(f: || -> U) -> U {\n     use rt::task::{Task, GreenTask, SchedTask};\n     use rt::local::Local;\n \n@@ -340,7 +340,7 @@ impl LittleLock {\n         }\n     }\n \n-    pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+    pub unsafe fn lock<T>(&self, f: || -> T) -> T {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             this.l.lock();\n@@ -352,7 +352,7 @@ impl LittleLock {\n         }\n     }\n \n-    pub unsafe fn try_lock<T>(&self, f: &fn() -> T) -> Option<T> {\n+    pub unsafe fn try_lock<T>(&self, f: || -> T) -> Option<T> {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             if this.l.trylock() {\n@@ -372,7 +372,7 @@ impl LittleLock {\n         this.l.signal();\n     }\n \n-    pub unsafe fn lock_and_wait(&self, f: &fn() -> bool) {\n+    pub unsafe fn lock_and_wait(&self, f: || -> bool) {\n         let this = cast::transmute_mut(self);\n         do atomically {\n             this.l.lock();\n@@ -433,7 +433,7 @@ impl<T:Send> Exclusive<T> {\n     // accessing the provided condition variable) are prohibited while inside\n     // the Exclusive. Supporting that is a work in progress.\n     #[inline]\n-    pub unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n+    pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n@@ -447,14 +447,14 @@ impl<T:Send> Exclusive<T> {\n     }\n \n     #[inline]\n-    pub unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n+    pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n         do self.with |x| {\n             f(cast::transmute_immut(x))\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn hold_and_signal(&self, f: &fn(x: &mut T)) {\n+    pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n         do (*rec).lock.lock {\n             if (*rec).failed {\n@@ -468,7 +468,7 @@ impl<T:Send> Exclusive<T> {\n     }\n \n     #[inline]\n-    pub unsafe fn hold_and_wait(&self, f: &fn(x: &T) -> bool) {\n+    pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n         do (*rec).lock.lock_and_wait {\n             if (*rec).failed {"}, {"sha": "2bd6a00ed4a0e3e7c9aa9013173a4d110d2017a6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -132,7 +132,7 @@ use util;\n  * Creates an owned vector of size `n_elts` and initializes the elements\n  * to the value returned by the function `op`.\n  */\n-pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n+pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         let p = raw::to_mut_ptr(v);\n@@ -211,7 +211,7 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n+pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n     let mut vec = with_capacity(size.unwrap_or(4));\n     builder(|x| vec.push(x));\n     vec\n@@ -338,7 +338,7 @@ pub fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n  * Apply a function to each element of a vector and return a concatenation\n  * of each result vector\n  */\n-pub fn flat_map<T, U>(v: &[T], f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+pub fn flat_map<T, U>(v: &[T], f: |t: &T| -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for elem in v.iter() { result.push_all_move(f(elem)); }\n     result\n@@ -946,7 +946,7 @@ pub trait ImmutableVector<'self, T> {\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n      */\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U];\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n@@ -961,20 +961,20 @@ pub trait ImmutableVector<'self, T> {\n      * Returns the index where the comparator returned `Equal`, or `None` if\n      * not found.\n      */\n-    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint>;\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n     /// Deprecated, use iterators where possible\n     /// (`self.iter().map(f)`). Apply a function to each element\n     /// of a vector and return the results.\n-    fn map<U>(&self, &fn(t: &T) -> U) -> ~[U];\n+    fn map<U>(&self, |t: &T| -> U) -> ~[U];\n \n     /**\n      * Work with the buffer of a vector.\n      *\n      * Allows for unsafe manipulation of vector contents, which is useful for\n      * foreign interop.\n      */\n-    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U;\n+    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U;\n }\n \n impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n@@ -1104,7 +1104,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+    fn flat_map<U>(&self, f: |t: &T| -> ~[U]) -> ~[U] {\n         flat_map(*self, f)\n     }\n \n@@ -1113,7 +1113,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         self.repr().data.offset(index as int)\n     }\n \n-    fn bsearch(&self, f: &fn(&T) -> Ordering) -> Option<uint> {\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n \n@@ -1132,12 +1132,12 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         return None;\n     }\n \n-    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n+    fn map<U>(&self, f: |t: &T| -> U) -> ~[U] {\n         self.iter().map(f).collect()\n     }\n \n     #[inline]\n-    fn as_imm_buf<U>(&self, f: &fn(*T, uint) -> U) -> U {\n+    fn as_imm_buf<U>(&self, f: |*T, uint| -> U) -> U {\n         let s = self.repr();\n         f(s.data, s.len)\n     }\n@@ -1212,7 +1212,7 @@ pub trait ImmutableCopyableVector<T> {\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n      */\n-    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n     /// Returns the element at the given index, without doing bounds checking.\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n \n@@ -1223,7 +1223,7 @@ pub trait ImmutableCopyableVector<T> {\n \n impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n     #[inline]\n-    fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n@@ -1370,12 +1370,12 @@ pub trait OwnedVector<T> {\n     /**\n      * Like `filter()`, but in place.  Preserves order of `v`.  Linear time.\n      */\n-    fn retain(&mut self, f: &fn(t: &T) -> bool);\n+    fn retain(&mut self, f: |t: &T| -> bool);\n     /**\n      * Partitions the vector into those that satisfies the predicate, and\n      * those that do not.\n      */\n-    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n \n     /**\n      * Expands a vector in place, initializing the new elements to the result of\n@@ -1389,7 +1389,7 @@ pub trait OwnedVector<T> {\n      * * init_op - A function to call to retreive each appended element's\n      *             value\n      */\n-    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T);\n+    fn grow_fn(&mut self, n: uint, op: |uint| -> T);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -1646,7 +1646,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe { raw::set_len(self, newlen); }\n     }\n \n-    fn retain(&mut self, f: &fn(t: &T) -> bool) {\n+    fn retain(&mut self, f: |t: &T| -> bool) {\n         let len = self.len();\n         let mut deleted: uint = 0;\n \n@@ -1664,7 +1664,7 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn partition(self, f: &fn(&T) -> bool) -> (~[T], ~[T]) {\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]) {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n@@ -1678,7 +1678,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n         (lefts, rights)\n     }\n-    fn grow_fn(&mut self, n: uint, op: &fn(uint) -> T) {\n+    fn grow_fn(&mut self, n: uint, op: |uint| -> T) {\n         let new_len = self.len() + n;\n         self.reserve_at_least(new_len);\n         let mut i: uint = 0u;\n@@ -1919,7 +1919,7 @@ pub trait MutableVector<'self, T> {\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n     /// Similar to `as_imm_buf` but passing a `*mut T`\n-    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U;\n+    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n \n impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n@@ -2016,7 +2016,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn as_mut_buf<U>(self, f: &fn(*mut T, uint) -> U) -> U {\n+    fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U {\n         let Slice{ data, len } = self.repr();\n         f(data as *mut T, len)\n     }\n@@ -2107,9 +2107,8 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T,\n-                                    len: uint,\n-                                    f: &fn(v: &[T]) -> U) -> U {\n+    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+                               -> U {\n         f(cast::transmute(Slice {\n             data: p,\n             len: len\n@@ -2121,9 +2120,12 @@ pub mod raw {\n      * not bytes).\n      */\n     #[inline]\n-    pub unsafe fn mut_buf_as_slice<T,U>(p: *mut T,\n-                                        len: uint,\n-                                        f: &fn(v: &mut [T]) -> U) -> U {\n+    pub unsafe fn mut_buf_as_slice<T,\n+                                   U>(\n+                                   p: *mut T,\n+                                   len: uint,\n+                                   f: |v: &mut [T]| -> U)\n+                                   -> U {\n         f(cast::transmute(Slice {\n             data: p as *T,\n             len: len"}, {"sha": "c2283bf1227ed7faf6f6d6418247c1593f00d362", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -84,7 +84,7 @@ static AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n ];\n \n-fn each_abi(op: &fn(abi: Abi) -> bool) -> bool {\n+fn each_abi(op: |abi: Abi| -> bool) -> bool {\n     /*!\n      *\n      * Iterates through each of the defined ABIs.\n@@ -201,7 +201,7 @@ impl AbiSet {\n         self.bits |= (1 << abi.index());\n     }\n \n-    pub fn each(&self, op: &fn(abi: Abi) -> bool) -> bool {\n+    pub fn each(&self, op: |abi: Abi| -> bool) -> bool {\n         each_abi(|abi| !self.contains(abi) || op(abi))\n     }\n "}, {"sha": "c5ad371491757488aa0ef1387e6266627b094cee", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -122,7 +122,7 @@ pub enum ast_node {\n }\n \n impl ast_node {\n-    pub fn with_attrs<T>(&self, f: &fn(Option<&[Attribute]>) -> T) -> T {\n+    pub fn with_attrs<T>(&self, f: |Option<&[Attribute]>| -> T) -> T {\n         let attrs = match *self {\n             node_item(i, _) => Some(i.attrs.as_slice()),\n             node_foreign_item(fi, _, _, _) => Some(fi.attrs.as_slice()),\n@@ -480,9 +480,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n     }\n }\n \n-pub fn node_item_query<Result>(items: map, id: NodeId,\n-                               query: &fn(@item) -> Result,\n-                               error_msg: ~str) -> Result {\n+pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result, error_msg: ~str)\n+                       -> Result {\n     match items.find(&id) {\n         Some(&node_item(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)"}, {"sha": "a49109911de423cd3de4c1ff396aafcbf64b8e50", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -636,7 +636,7 @@ pub fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n+pub fn walk_pat(pat: @Pat, it: |@Pat| -> bool) -> bool {\n     if !it(pat) {\n         return false;\n     }\n@@ -665,7 +665,7 @@ pub fn walk_pat(pat: @Pat, it: &fn(@Pat) -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool;\n+    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool;\n }\n \n struct EachViewItemData<'self> {\n@@ -679,7 +679,7 @@ impl<'self> Visitor<()> for EachViewItemData<'self> {\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: &fn(&ast::view_item) -> bool) -> bool {\n+    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };"}, {"sha": "15b827306294980ea1d60cb63ae2416cadad4524", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -347,9 +347,11 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: Span) {\n     }\n }\n \n-pub fn expect<T:Clone>(diag: @mut span_handler,\n-                       opt: Option<T>,\n-                       msg: &fn() -> ~str) -> T {\n+pub fn expect<T:Clone>(\n+              diag: @mut span_handler,\n+              opt: Option<T>,\n+              msg: || -> ~str)\n+              -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),\n        None => diag.handler().bug(msg()),"}, {"sha": "448f8ee88f90a33f67634d24b5b136c25ac0ab9e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -559,11 +559,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // should each_key and each_value operate on shadowed\n     // names? I think not.\n     // delaying implementing this....\n-    pub fn each_key (&self, _f: &fn (&K)->bool) {\n+    pub fn each_key (&self, _f: |&K| -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:01\");\n     }\n \n-    pub fn each_value (&self, _f: &fn (&V) -> bool) {\n+    pub fn each_value (&self, _f: |&V| -> bool) {\n         fail!(\"unimplemented 2013-02-15T10:02\");\n     }\n \n@@ -601,7 +601,11 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n     // ... there are definitely some opportunities for abstraction\n     // here that I'm ignoring. (e.g., manufacturing a predicate on\n     // the maps in the chain, and using an abstract \"find\".\n-    pub fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+    pub fn insert_into_frame(&mut self,\n+                             key: K,\n+                             ext: @V,\n+                             n: K,\n+                             pred: |&@V| -> bool) {\n         match *self {\n             BaseMapChain (~ref mut map) => {\n                 if satisfies_pred(map,&n,pred) {\n@@ -622,10 +626,12 @@ impl <K: Eq + Hash + IterBytes + 'static, V: 'static> MapChain<K,V>{\n }\n \n // returns true if the binding for 'n' satisfies 'pred' in 'map'\n-fn satisfies_pred<K : Eq + Hash + IterBytes,V>(map : &mut HashMap<K,V>,\n-                                               n: &K,\n-                                               pred: &fn(&V)->bool)\n-    -> bool {\n+fn satisfies_pred<K:Eq + Hash + IterBytes,\n+                  V>(\n+                  map: &mut HashMap<K,V>,\n+                  n: &K,\n+                  pred: |&V| -> bool)\n+                  -> bool {\n     match map.find(n) {\n         Some(ref v) => (pred(*v)),\n         None => false\n@@ -637,7 +643,8 @@ mod test {\n     use super::MapChain;\n     use std::hashmap::HashMap;\n \n-    #[test] fn testenv () {\n+    #[test]\n+    fn testenv() {\n         let mut a = HashMap::new();\n         a.insert (@\"abc\",@15);\n         let m = MapChain::new(~a);"}, {"sha": "2f9222ccb56f63e7b1daacd7c2dcd25c06dac5ff", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -124,9 +124,12 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n-fn decode_static_fields(cx: @ExtCtxt, outer_span: Span, outer_pat_ident: Ident,\n+fn decode_static_fields(cx: @ExtCtxt,\n+                        outer_span: Span,\n+                        outer_pat_ident: Ident,\n                         fields: &StaticFields,\n-                        getarg: &fn(Span, @str, uint) -> @Expr) -> @Expr {\n+                        getarg: |Span, @str, uint| -> @Expr)\n+                        -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {"}, {"sha": "23dc38fdc31e579414bb154bf36f7698562af9a5", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -1064,14 +1064,13 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: &fn(@ExtCtxt, Span,\n-                      old: @Expr,\n-                      self_f: @Expr,\n-                      other_fs: &[@Expr]) -> @Expr,\n+               f: |@ExtCtxt, Span, @Expr, @Expr, &[@Expr]| -> @Expr,\n                base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ExtCtxt, trait_span: Span,\n-               substructure: &Substructure) -> @Expr {\n+               cx: @ExtCtxt,\n+               trait_span: Span,\n+               substructure: &Substructure)\n+               -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n@@ -1104,10 +1103,12 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline]\n-pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@Expr]) -> @Expr,\n+pub fn cs_same_method(f: |@ExtCtxt, Span, ~[@Expr]| -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ExtCtxt, trait_span: Span,\n-                      substructure: &Substructure) -> @Expr {\n+                      cx: @ExtCtxt,\n+                      trait_span: Span,\n+                      substructure: &Substructure)\n+                      -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n@@ -1136,11 +1137,13 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ExtCtxt, Span, @Expr, @Expr) -> @Expr,\n+                           f: |@ExtCtxt, Span, @Expr, @Expr| -> @Expr,\n                            base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ExtCtxt, trait_span: Span,\n-                           substructure: &Substructure) -> @Expr {\n+                           cx: @ExtCtxt,\n+                           trait_span: Span,\n+                           substructure: &Substructure)\n+                           -> @Expr {\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {"}, {"sha": "1877a6eb85bef277ed89211fa16a05ac9343376f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -128,10 +128,12 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ExtCtxt, span: Span,\n+    fn rand_thing(cx: @ExtCtxt,\n+                  span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: &fn(Span) -> @Expr) -> @Expr {\n+                  rand_call: |Span| -> @Expr)\n+                  -> @Expr {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {"}, {"sha": "62592650416dafa3360afe9bf96e2570a67e6854", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -381,7 +381,7 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn map_exprs(&self, f: &fn(@Expr) -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n+    fn map_exprs(&self, f: |@Expr| -> @Expr, es: &[@Expr]) -> ~[@Expr] {\n         es.map(|x| f(*x))\n     }\n "}, {"sha": "3a0b7c6adc44f44bd9a40b65aa185109394d721a", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -50,14 +50,14 @@ impl<T> OptVec<T> {\n         *self = Vec(~[t]);\n     }\n \n-    pub fn map<U>(&self, op: &fn(&T) -> U) -> OptVec<U> {\n+    pub fn map<U>(&self, op: |&T| -> U) -> OptVec<U> {\n         match *self {\n             Empty => Empty,\n             Vec(ref v) => Vec(v.map(op))\n         }\n     }\n \n-    pub fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+    pub fn map_move<U>(self, op: |T| -> U) -> OptVec<U> {\n         match self {\n             Empty => Empty,\n             Vec(v) => Vec(v.move_iter().map(op).collect())\n@@ -91,11 +91,11 @@ impl<T> OptVec<T> {\n     }\n \n     #[inline]\n-    pub fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n+    pub fn map_to_vec<B>(&self, op: |&T| -> B) -> ~[B] {\n         self.iter().map(op).collect()\n     }\n \n-    pub fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {\n+    pub fn mapi_to_vec<B>(&self, op: |uint, &T| -> B) -> ~[B] {\n         let mut index = 0;\n         self.map_to_vec(|a| {\n             let i = index;"}, {"sha": "26de9215dbfdbf15849a2d903a2de48447a3c8a1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -216,16 +216,22 @@ fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n /// Calls `f` with a string slice of the source text spanning from `start`\n /// up to but excluding `rdr.last_pos`, meaning the slice does not include\n /// the character `rdr.curr`.\n-pub fn with_str_from<T>(rdr: @mut StringReader, start: BytePos, f: &fn(s: &str) -> T) -> T {\n+pub fn with_str_from<T>(\n+                     rdr: @mut StringReader,\n+                     start: BytePos,\n+                     f: |s: &str| -> T)\n+                     -> T {\n     with_str_from_to(rdr, start, rdr.last_pos, f)\n }\n \n /// Calls `f` with astring slice of the source text spanning from `start`\n /// up to but excluding `end`.\n-fn with_str_from_to<T>(rdr: @mut StringReader,\n-                       start: BytePos,\n-                       end: BytePos,\n-                       f: &fn(s: &str) -> T) -> T {\n+fn with_str_from_to<T>(\n+                    rdr: @mut StringReader,\n+                    start: BytePos,\n+                    end: BytePos,\n+                    f: |s: &str| -> T)\n+                    -> T {\n     f(rdr.src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))"}, {"sha": "947f7a7fc29a8c1e4be782b182bb83c4c6203cb5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -177,19 +177,14 @@ pub fn parse_tts_from_source_str(\n // consumed all of the input before returning the function's\n // result.\n pub fn parse_from_source_str<T>(\n-    f: &fn(&Parser) -> T,\n-    name: @str, ss: codemap::FileSubstr,\n-    source: @str,\n-    cfg: ast::CrateConfig,\n-    sess: @mut ParseSess\n-) -> T {\n-    let p = new_parser_from_source_substr(\n-        sess,\n-        cfg,\n-        name,\n-        ss,\n-        source\n-    );\n+                             f: |&Parser| -> T,\n+                             name: @str,\n+                             ss: codemap::FileSubstr,\n+                             source: @str,\n+                             cfg: ast::CrateConfig,\n+                             sess: @mut ParseSess)\n+                             -> T {\n+    let p = new_parser_from_source_substr(sess, cfg, name, ss, source);\n     let r = f(&p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");"}, {"sha": "3adedf76eb840cfa97547c364483a6e06e96b967", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -82,7 +82,7 @@ impl ParserObsoleteMethods for Parser {\n             ),\n             ObsoleteBareFnType => (\n                 \"bare function type\",\n-                \"use `&fn` or `extern fn` instead\"\n+                \"use `|A| -> B` or `extern fn(A) -> B` instead\"\n             ),\n             ObsoleteNamedExternModule => (\n                 \"named external module\","}, {"sha": "6c2df4ad3142a202d7714e34d5666c887bb75fce", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -581,10 +581,8 @@ impl Parser {\n     }\n \n     // Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T>(&self,\n-                                 sep: &token::Token,\n-                                 f: &fn(&Parser) -> T)\n-                                 -> ~[T] {\n+    fn parse_seq_to_before_or<T>(&self, sep: &token::Token, f: |&Parser| -> T)\n+                              -> ~[T] {\n         let mut first = true;\n         let mut vector = ~[];\n         while *self.token != token::BINOP(token::OR) &&\n@@ -619,10 +617,11 @@ impl Parser {\n \n     // parse a sequence bracketed by '<' and '>', stopping\n     // before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(&self,\n-                                     sep: Option<token::Token>,\n-                                     f: &fn(&Parser) -> T)\n-                                     -> OptVec<T> {\n+    pub fn parse_seq_to_before_gt<T>(\n+                                  &self,\n+                                  sep: Option<token::Token>,\n+                                  f: |&Parser| -> T)\n+                                  -> OptVec<T> {\n         let mut first = true;\n         let mut v = opt_vec::Empty;\n         while *self.token != token::GT\n@@ -639,10 +638,11 @@ impl Parser {\n         return v;\n     }\n \n-    pub fn parse_seq_to_gt<T>(&self,\n-                              sep: Option<token::Token>,\n-                              f: &fn(&Parser) -> T)\n-                              -> OptVec<T> {\n+    pub fn parse_seq_to_gt<T>(\n+                           &self,\n+                           sep: Option<token::Token>,\n+                           f: |&Parser| -> T)\n+                           -> OptVec<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n@@ -651,11 +651,12 @@ impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_seq_to_end<T>(&self,\n-                               ket: &token::Token,\n-                               sep: SeqSep,\n-                               f: &fn(&Parser) -> T)\n-                               -> ~[T] {\n+    pub fn parse_seq_to_end<T>(\n+                            &self,\n+                            ket: &token::Token,\n+                            sep: SeqSep,\n+                            f: |&Parser| -> T)\n+                            -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         val\n@@ -664,11 +665,12 @@ impl Parser {\n     // parse a sequence, not including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_seq_to_before_end<T>(&self,\n-                                      ket: &token::Token,\n-                                      sep: SeqSep,\n-                                      f: &fn(&Parser) -> T)\n-                                      -> ~[T] {\n+    pub fn parse_seq_to_before_end<T>(\n+                                   &self,\n+                                   ket: &token::Token,\n+                                   sep: SeqSep,\n+                                   f: |&Parser| -> T)\n+                                   -> ~[T] {\n         let mut first: bool = true;\n         let mut v: ~[T] = ~[];\n         while *self.token != *ket {\n@@ -688,12 +690,13 @@ impl Parser {\n     // parse a sequence, including the closing delimiter. The function\n     // f must consume tokens until reaching the next separator or\n     // closing bracket.\n-    pub fn parse_unspanned_seq<T>(&self,\n-                                  bra: &token::Token,\n-                                  ket: &token::Token,\n-                                  sep: SeqSep,\n-                                  f: &fn(&Parser) -> T)\n-                                  -> ~[T] {\n+    pub fn parse_unspanned_seq<T>(\n+                               &self,\n+                               bra: &token::Token,\n+                               ket: &token::Token,\n+                               sep: SeqSep,\n+                               f: |&Parser| -> T)\n+                               -> ~[T] {\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n@@ -702,12 +705,13 @@ impl Parser {\n \n     // NB: Do not use this function unless you actually plan to place the\n     // spanned list in the AST.\n-    pub fn parse_seq<T>(&self,\n-                        bra: &token::Token,\n-                        ket: &token::Token,\n-                        sep: SeqSep,\n-                        f: &fn(&Parser) -> T)\n-                        -> Spanned<~[T]> {\n+    pub fn parse_seq<T>(\n+                     &self,\n+                     bra: &token::Token,\n+                     ket: &token::Token,\n+                     sep: SeqSep,\n+                     f: |&Parser| -> T)\n+                     -> Spanned<~[T]> {\n         let lo = self.span.lo;\n         self.expect(bra);\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n@@ -765,8 +769,8 @@ impl Parser {\n         }\n         return (4 - *self.buffer_start) + *self.buffer_end;\n     }\n-    pub fn look_ahead<R>(&self, distance: uint, f: &fn(&token::Token) -> R)\n-                         -> R {\n+    pub fn look_ahead<R>(&self, distance: uint, f: |&token::Token| -> R)\n+                      -> R {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n             self.buffer[*self.buffer_end] = self.reader.next_token();\n@@ -1272,7 +1276,8 @@ impl Parser {\n     // parse the type following a @ or a ~\n     pub fn parse_box_or_uniq_pointee(&self,\n                                      sigil: ast::Sigil,\n-                                     ctor: &fn(v: mt) -> ty_) -> ty_ {\n+                                     ctor: |v: mt| -> ty_)\n+                                     -> ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n@@ -2467,8 +2472,8 @@ impl Parser {\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&self,\n-                              parse_decl: &fn() -> fn_decl,\n-                              parse_body: &fn() -> @Expr)\n+                              parse_decl: || -> fn_decl,\n+                              parse_body: || -> @Expr)\n                               -> @Expr {\n         let lo = self.last_span.lo;\n         let decl = parse_decl();\n@@ -2513,10 +2518,11 @@ impl Parser {\n     // parse a 'for' or 'do'.\n     // the 'for' and 'do' expressions parse as calls, but look like\n     // function calls followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&self, lo: BytePos,\n+    pub fn parse_sugary_call_expr(&self,\n+                                  lo: BytePos,\n                                   keyword: ~str,\n                                   sugar: CallSugar,\n-                                  ctor: &fn(v: @Expr) -> Expr_)\n+                                  ctor: |v: @Expr| -> Expr_)\n                                   -> @Expr {\n         // Parse the callee `foo` in\n         //    for foo || {\n@@ -3611,11 +3617,12 @@ impl Parser {\n \n     // parse the argument list and result type of a function\n     // that may have a self type.\n-    fn parse_fn_decl_with_self(&self, parse_arg_fn: &fn(&Parser) -> arg)\n-        -> (explicit_self, fn_decl) {\n-\n-        fn maybe_parse_explicit_self(cnstr: &fn(v: Mutability) -> ast::explicit_self_,\n-                                     p: &Parser) -> ast::explicit_self_ {\n+    fn parse_fn_decl_with_self(&self, parse_arg_fn: |&Parser| -> arg)\n+                               -> (explicit_self, fn_decl) {\n+        fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n+                                        ast::explicit_self_,\n+                                     p: &Parser)\n+                                     -> ast::explicit_self_ {\n             // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n                 ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||"}, {"sha": "8d31133e9e24a8fa69f465477b21ee773d02ce38", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -331,7 +331,7 @@ pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, \"*/\");\n }\n \n-pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n+pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: |@ps, &T|) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elt in elts.iter() {\n@@ -342,8 +342,12 @@ pub fn commasep<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T)) {\n }\n \n \n-pub fn commasep_cmnt<T>(s: @ps, b: breaks, elts: &[T], op: &fn(@ps, &T),\n-                               get_span: &fn(&T) -> codemap::Span) {\n+pub fn commasep_cmnt<T>(\n+                     s: @ps,\n+                     b: breaks,\n+                     elts: &[T],\n+                     op: |@ps, &T|,\n+                     get_span: |&T| -> codemap::Span) {\n     box(s, 0u, b);\n     let len = elts.len();\n     let mut i = 0u;\n@@ -2289,7 +2293,7 @@ pub fn print_string(s: @ps, st: &str, style: ast::StrStyle) {\n     word(s.s, st);\n }\n \n-pub fn to_str<T>(t: &T, f: &fn(@ps, &T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: &T, f: |@ps, &T|, intr: @ident_interner) -> ~str {\n     let wr = @mut MemWriter::new();\n     let s = rust_printer(wr as @mut io::Writer, intr);\n     f(s, t);"}, {"sha": "3a2a8b10c9666c6276ddd37505d8983e9a352fc2", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c159acb05d95d832de3cebb5e1e91ee34e550c9d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=c159acb05d95d832de3cebb5e1e91ee34e550c9d", "patch": "@@ -39,7 +39,7 @@ pub fn string_to_parser(source_str: @str) -> Parser {\n     p\n }\n \n-fn with_error_checking_parse<T>(s: @str, f: &fn(&mut Parser) -> T) -> T {\n+fn with_error_checking_parse<T>(s: @str, f: |&mut Parser| -> T) -> T {\n     let mut p = string_to_parser(s);\n     let x = f(&mut p);\n     p.abort_if_errors();"}]}