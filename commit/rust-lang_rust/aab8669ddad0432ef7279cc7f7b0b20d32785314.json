{"sha": "aab8669ddad0432ef7279cc7f7b0b20d32785314", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYjg2NjlkZGFkMDQzMmVmNzI3OWNjN2Y3YjBiMjBkMzI3ODUzMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-06T19:20:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-06T19:20:39Z"}, "message": "Auto merge of #23655 - gereeter:rustc-remove-ident, r=sanxiyn\n\n...of #6993.\r\n\r\ncc @pcwalton", "tree": {"sha": "919eb7d36e298fa4505fda9dd2add7360099a889", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/919eb7d36e298fa4505fda9dd2add7360099a889"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aab8669ddad0432ef7279cc7f7b0b20d32785314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aab8669ddad0432ef7279cc7f7b0b20d32785314", "html_url": "https://github.com/rust-lang/rust/commit/aab8669ddad0432ef7279cc7f7b0b20d32785314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aab8669ddad0432ef7279cc7f7b0b20d32785314/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c07835e10d003b5926bd32de1f4ed4f51109a88", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c07835e10d003b5926bd32de1f4ed4f51109a88", "html_url": "https://github.com/rust-lang/rust/commit/3c07835e10d003b5926bd32de1f4ed4f51109a88"}, {"sha": "3cbc345cf7eed9cd4bb6633505d23f29bad67b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cbc345cf7eed9cd4bb6633505d23f29bad67b3c", "html_url": "https://github.com/rust-lang/rust/commit/3cbc345cf7eed9cd4bb6633505d23f29bad67b3c"}], "stats": {"total": 238, "additions": 117, "deletions": 121}, "files": [{"sha": "a659a93aef308736feef66a9e369b920d898f409", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -763,7 +763,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                 let arg_tys = get_struct_fields(intr.clone(), cdata, did.node)\n                     .iter()\n                     .map(|field_ty| {\n-                        arg_names.push(ast::Ident::new(field_ty.name));\n+                        arg_names.push(field_ty.name);\n                         get_type(cdata, field_ty.id.node, tcx).ty\n                     })\n                     .collect();"}, {"sha": "b9559abbdf4c2a2794e66456b25c992af3eead4a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -87,8 +87,8 @@ fn encode_name(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, &token::get_name(name));\n }\n \n-fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n-    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_ident(name));\n+fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n+    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_name(name));\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n@@ -519,12 +519,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        path: PathElems,\n-                       name: ast::Ident,\n+                       name: ast::Name,\n                        vis: ast::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id(rbml_w, local_def(id));\n     encode_family(rbml_w, 'm');\n-    encode_name(rbml_w, name.name);\n+    encode_name(rbml_w, name);\n     debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n     // Encode info about all the module children.\n@@ -666,7 +666,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                rbml_w: &mut Encoder,\n-                               name: ast::Ident,\n+                               name: ast::Name,\n                                ctor_id: NodeId,\n                                index: &mut Vec<entry<i64>>,\n                                struct_id: NodeId) {\n@@ -679,7 +679,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     encode_def_id(rbml_w, local_def(ctor_id));\n     encode_family(rbml_w, 'o');\n     encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n-    encode_name(rbml_w, name.name);\n+    encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, local_def(struct_id));\n \n@@ -886,7 +886,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n-            let name = token::get_ident(path1.node);\n+            let name = token::get_name(path1.node.name);\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {\n             rbml_w.wr_tagged_bytes(tag, &[]);\n@@ -1044,7 +1044,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             &item.attrs,\n                             item.id,\n                             path,\n-                            item.ident,\n+                            item.ident.name,\n                             item.vis);\n       }\n       ast::ItemForeignMod(ref fm) => {\n@@ -1152,7 +1152,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // If this is a tuple-like struct, encode the type of the constructor.\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, rbml_w, item.ident,\n+                encode_info_for_struct_ctor(ecx, rbml_w, item.ident.name,\n                                             ctor_id, index, def_id.node);\n             }\n             None => {}\n@@ -1187,8 +1187,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n             ast::TyPath(None, ref path) if path.segments.len() == 1 => {\n-                let ident = path.segments.last().unwrap().identifier;\n-                encode_impl_type_basename(rbml_w, ident);\n+                let name = path.segments.last().unwrap().identifier.name;\n+                encode_impl_type_basename(rbml_w, name);\n             }\n             _ => {}\n         }\n@@ -1513,7 +1513,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         &[],\n                         ast::CRATE_NODE_ID,\n                         [].iter().cloned().chain(LinkedPath::empty()),\n-                        syntax::parse::token::special_idents::invalid,\n+                        syntax::parse::token::special_idents::invalid.name,\n                         ast::Public);\n \n     visit::walk_crate(&mut EncodeVisitor {"}, {"sha": "9836f8d7991df37b4387f2b711e84311b367c2b1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -101,10 +101,6 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     return op(&st.data[start_pos..end_pos]);\n }\n \n-pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n-    ast::Ident::new(parse_name(st, last))\n-}\n-\n pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     parse_name_(st, |a| is_last(last, a) )"}, {"sha": "426540ce156cb5fc33596f5eead69e032495fa26", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -133,12 +133,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &ast::Expr, name: &ast::Ident) {\n+    fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n         match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);\n                 let field_id = fields.iter()\n-                    .find(|field| field.name == name.name).unwrap().id;\n+                    .find(|field| field.name == name).unwrap().id;\n                 self.live_symbols.insert(field_id.node);\n             },\n             _ => ()\n@@ -267,7 +267,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n             ast::ExprField(ref lhs, ref ident) => {\n-                self.handle_field_access(&**lhs, &ident.node);\n+                self.handle_field_access(&**lhs, ident.node.name);\n             }\n             ast::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&**lhs, idx.node);\n@@ -511,9 +511,9 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn warn_dead_code(&mut self,\n                       id: ast::NodeId,\n                       span: codemap::Span,\n-                      ident: ast::Ident,\n+                      name: ast::Name,\n                       node_type: &str) {\n-        let name = ident.as_str();\n+        let name = name.as_str();\n         if !name.starts_with(\"_\") {\n             self.tcx\n                 .sess\n@@ -528,14 +528,19 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if self.should_warn_about_item(item) {\n-            self.warn_dead_code(item.id, item.span, item.ident, item.node.descriptive_variant());\n+            self.warn_dead_code(\n+                item.id,\n+                item.span,\n+                item.ident.name,\n+                item.node.descriptive_variant()\n+            );\n         } else {\n             match item.node {\n                 ast::ItemEnum(ref enum_def, _) => {\n                     for variant in &enum_def.variants {\n                         if self.should_warn_about_variant(&variant.node) {\n                             self.warn_dead_code(variant.node.id, variant.span,\n-                                                variant.node.name, \"variant\");\n+                                                variant.node.name.name, \"variant\");\n                         }\n                     }\n                 },\n@@ -547,7 +552,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n-            self.warn_dead_code(fi.id, fi.span, fi.ident, fi.node.descriptive_variant());\n+            self.warn_dead_code(fi.id, fi.span, fi.ident.name, fi.node.descriptive_variant());\n         }\n         visit::walk_foreign_item(self, fi);\n     }\n@@ -559,7 +564,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n         match fk {\n             visit::FkMethod(name, _) => {\n                 if !self.symbol_is_live(id, None) {\n-                    self.warn_dead_code(id, span, name, \"method\");\n+                    self.warn_dead_code(id, span, name.name, \"method\");\n                 }\n             }\n             _ => ()\n@@ -570,7 +575,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     fn visit_struct_field(&mut self, field: &ast::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span,\n-                                field.node.ident().unwrap(), \"struct field\");\n+                                field.node.ident().unwrap().name, \"struct field\");\n         }\n \n         visit::walk_struct_field(self, field);"}, {"sha": "786cd902c53c0c36197a7b768e741d945ff70d78", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -248,12 +248,12 @@ struct CaptureInfo {\n #[derive(Copy, Clone, Debug)]\n struct LocalInfo {\n     id: NodeId,\n-    ident: ast::Ident\n+    name: ast::Name\n }\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(NodeId, ast::Ident),\n+    Arg(NodeId, ast::Name),\n     Local(LocalInfo),\n     ImplicitRet,\n     CleanExit\n@@ -334,8 +334,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n-                token::get_ident(nm).to_string()\n+            Local(LocalInfo { name, .. }) | Arg(_, name) => {\n+                token::get_name(name).to_string()\n             },\n             ImplicitRet => \"<implicit-ret>\".to_string(),\n             CleanExit => \"<clean-exit>\".to_string()\n@@ -385,8 +385,8 @@ fn visit_fn(ir: &mut IrMaps,\n                                &*arg.pat,\n                                |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n-            let ident = path1.node;\n-            fn_maps.add_variable(Arg(arg_id, ident));\n+            let name = path1.node.name;\n+            fn_maps.add_variable(Arg(arg_id, name));\n         })\n     };\n \n@@ -418,11 +418,11 @@ fn visit_fn(ir: &mut IrMaps,\n fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n-        let name = path1.node;\n+        let name = path1.node.name;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         ir.add_variable(Local(LocalInfo {\n           id: p_id,\n-          ident: name\n+          name: name\n         }));\n     });\n     visit::walk_local(ir, local);\n@@ -433,11 +433,11 @@ fn visit_arm(ir: &mut IrMaps, arm: &ast::Arm) {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n-            let name = path1.node;\n+            let name = path1.node.name;\n             ir.add_live_node_for_node(p_id, VarDefNode(sp));\n             ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n-                ident: name\n+                name: name\n             }));\n         })\n     }"}, {"sha": "9c8f30902baad22de48b012bc5a6d5864c2baa1c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -80,7 +80,7 @@ use std::vec::IntoIter;\n use collections::enum_set::{EnumSet, CLike};\n use std::collections::{HashMap, HashSet};\n use syntax::abi;\n-use syntax::ast::{CrateNum, DefId, Ident, ItemTrait, LOCAL_CRATE};\n+use syntax::ast::{CrateNum, DefId, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{StmtExpr, StmtSemi, StructField, UnnamedField, Visibility};\n use syntax::ast_util::{self, is_local, lit_is_str, local_def};\n@@ -4361,8 +4361,8 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n             variant_info.arg_names.as_ref()\n                 .expect(\"must have struct enum variant if accessing a named fields\")\n                 .iter().zip(variant_info.args.iter())\n-                .find(|&(ident, _)| ident.name == n)\n-                .map(|(_ident, arg_t)| arg_t.subst(cx, substs))\n+                .find(|&(&name, _)| name == n)\n+                .map(|(_name, arg_t)| arg_t.subst(cx, substs))\n         }\n         _ => None\n     }\n@@ -5341,7 +5341,7 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n #[derive(Clone)]\n pub struct VariantInfo<'tcx> {\n     pub args: Vec<Ty<'tcx>>,\n-    pub arg_names: Option<Vec<ast::Ident>>,\n+    pub arg_names: Option<Vec<ast::Name>>,\n     pub ctor_ty: Option<Ty<'tcx>>,\n     pub name: ast::Name,\n     pub id: ast::DefId,\n@@ -5388,7 +5388,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                     .map(|field| node_id_to_type(cx, field.node.id)).collect();\n                 let arg_names = fields.iter().map(|field| {\n                     match field.node.kind {\n-                        NamedField(ident, _) => ident,\n+                        NamedField(ident, _) => ident.name,\n                         UnnamedField(..) => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }"}, {"sha": "fa2ff43ecfe9371d356bb32608da490d82c6276a", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -396,11 +396,11 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n                     let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n-                    for variant_arg_ident in variant_arg_names {\n-                        if variant_arg_ident.name == ast_name {\n+                    for &variant_arg_name in variant_arg_names {\n+                        if variant_arg_name == ast_name {\n                             continue;\n                         }\n-                        let field_name = mc::NamedField(variant_arg_ident.name);\n+                        let field_name = mc::NamedField(variant_arg_name);\n                         add_fragment_sibling_local(field_name, Some(variant_info.id));\n                     }\n                 }"}, {"sha": "1acc121078e4ffae2499eb246bb1eb3e861aba2f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -686,7 +686,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn check_static_method(&mut self,\n                            span: Span,\n                            method_id: ast::DefId,\n-                           name: ast::Ident) {\n+                           name: ast::Name) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         let method_id = match ty::impl_or_trait_item(self.tcx, method_id) {\n@@ -696,7 +696,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::TypeTraitItem(_) => method_id,\n         };\n \n-        let string = token::get_ident(name);\n+        let string = token::get_name(name);\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,\n@@ -705,13 +705,13 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a path is in scope.\n-    fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n+    fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Name) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n         let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n-                let name = token::get_ident(last);\n+                let name = token::get_name(last);\n                 let origdid = path_res.def_id();\n                 self.ensure_public(span,\n                                    def,\n@@ -800,10 +800,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a method is in scope.\n     fn check_method(&mut self, span: Span, origin: &MethodOrigin,\n-                    ident: ast::Ident) {\n+                    name: ast::Name) {\n         match *origin {\n             MethodStatic(method_id) => {\n-                self.check_static_method(span, method_id, ident)\n+                self.check_static_method(span, method_id, name)\n             }\n             MethodStaticClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n@@ -825,11 +825,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     match pid.node {\n                         ast::PathListIdent { id, name } => {\n                             debug!(\"privacy - ident item {}\", id);\n-                            self.check_path(pid.span, id, name);\n+                            self.check_path(pid.span, id, name.name);\n                         }\n                         ast::PathListMod { id } => {\n                             debug!(\"privacy - mod item {}\", id);\n-                            let name = prefix.segments.last().unwrap().identifier;\n+                            let name = prefix.segments.last().unwrap().identifier.name;\n                             self.check_path(pid.span, id, name);\n                         }\n                     }\n@@ -863,7 +863,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                     Some(method) => {\n                         debug!(\"(privacy checking) checking impl method\");\n-                        self.check_method(expr.span, &method.origin, ident.node);\n+                        self.check_method(expr.span, &method.origin, ident.node.name);\n                     }\n                 }\n             }\n@@ -1005,7 +1005,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n-        self.check_path(path.span, id, path.segments.last().unwrap().identifier);\n+        self.check_path(path.span, id, path.segments.last().unwrap().identifier.name);\n         visit::walk_path(self, path);\n     }\n }"}, {"sha": "ba279dea5a280870dcb4e5e23fe7379631190096", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -288,7 +288,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_method(&mut self, sig: &ast::MethodSig,\n                       body: Option<&ast::Block>,\n-                      id: ast::NodeId, ident: ast::Ident,\n+                      id: ast::NodeId, name: ast::Name,\n                       span: Span) {\n         if generated_code(span) {\n             return;\n@@ -354,7 +354,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             },\n         };\n \n-        let qualname = &format!(\"{}::{}\", qualname, &get_ident(ident));\n+        let qualname = &format!(\"{}::{}\", qualname, &token::get_name(name));\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -1238,7 +1238,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         match trait_item.node {\n             ast::MethodTraitItem(ref sig, ref body) => {\n                 self.process_method(sig, body.as_ref().map(|x| &**x),\n-                                    trait_item.id, trait_item.ident, trait_item.span);\n+                                    trait_item.id, trait_item.ident.name, trait_item.span);\n             }\n             ast::TypeTraitItem(..) => {}\n         }\n@@ -1248,7 +1248,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         match impl_item.node {\n             ast::MethodImplItem(ref sig, ref body) => {\n                 self.process_method(sig, Some(body), impl_item.id,\n-                                    impl_item.ident, impl_item.span);\n+                                    impl_item.ident.name, impl_item.span);\n             }\n             ast::TypeImplItem(_) |\n             ast::MacImplItem(_) => {}"}, {"sha": "1142f15ace96a2418f60297c6766d338b02ba7db", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -223,7 +223,7 @@ use std::cmp::Ordering;\n use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::{DUMMY_NODE_ID, Ident, NodeId};\n+use syntax::ast::{DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n@@ -349,7 +349,7 @@ pub struct BindingInfo<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-type BindingsMap<'tcx> = FnvHashMap<Ident, BindingInfo<'tcx>>;\n+type BindingsMap<'tcx> = FnvHashMap<ast::Ident, BindingInfo<'tcx>>;\n \n struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n@@ -364,7 +364,7 @@ struct ArmData<'p, 'blk, 'tcx: 'blk> {\n struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n     pats: Vec<&'p ast::Pat>,\n     data: &'a ArmData<'p, 'blk, 'tcx>,\n-    bound_ptrs: Vec<(Ident, ValueRef)>,\n+    bound_ptrs: Vec<(ast::Ident, ValueRef)>,\n     // Thread along renamings done by the check_match::StaticInliner, so we can\n     // map back to original NodeIds\n     pat_renaming_map: Option<&'a FnvHashMap<(NodeId, Span), NodeId>>\n@@ -923,7 +923,7 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         debug!(\"binding {} to {}\", binding_info.id, bcx.val_to_string(llval));\n         bcx.fcx.lllocals.borrow_mut().insert(binding_info.id, datum);\n-        debuginfo::create_match_binding_metadata(bcx, ident, binding_info);\n+        debuginfo::create_match_binding_metadata(bcx, ident.name, binding_info);\n     }\n     bcx\n }\n@@ -1380,6 +1380,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n     let mut bindings_map = FnvHashMap();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n         let ident = path1.node;\n+        let name = ident.name;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n         let tcx = bcx.tcx();\n@@ -1396,21 +1397,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         &bcx.ident(ident)));\n+                                         &bcx.name(name)));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 &bcx.ident(ident));\n+                                 &bcx.name(name));\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 &bcx.ident(ident));\n+                                 &bcx.name(name));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1527,7 +1528,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n             let scope = cleanup::var_scope(tcx, p_id);\n             bcx = mk_binding_alloca(\n-                bcx, p_id, &path1.node, scope, (),\n+                bcx, p_id, path1.node.name, scope, (),\n                 |(), bcx, llval, ty| { drop_done_fill_mem(bcx, llval, ty); bcx });\n         });\n         bcx\n@@ -1549,7 +1550,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(ident) => {\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n-                        bcx, pat.id, ident, var_scope, (),\n+                        bcx, pat.id, ident.name, var_scope, (),\n                         |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n@@ -1605,7 +1606,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx\n             } else {\n                 mk_binding_alloca(\n-                    bcx, pat.id, ident, arg_scope, arg,\n+                    bcx, pat.id, ident.name, arg_scope, arg,\n                     |arg, bcx, llval, _| arg.store_to(bcx, llval))\n             }\n         }\n@@ -1622,7 +1623,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n-                                       ident: &ast::Ident,\n+                                       name: ast::Name,\n                                        cleanup_scope: cleanup::ScopeId,\n                                        arg: A,\n                                        populate: F)\n@@ -1632,7 +1633,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident));\n+    let llval = alloc_ty(bcx, var_ty, &bcx.name(name));\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1686,7 +1687,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // binding will live and place it into the appropriate\n                 // map.\n                 bcx = mk_binding_alloca(\n-                    bcx, pat.id, &path1.node, cleanup_scope, (),\n+                    bcx, pat.id, path1.node.name, cleanup_scope, (),\n                     |(), bcx, llval, ty| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {"}, {"sha": "2c8da2dc31c5df353887b97bf80a0c73318af71c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -48,7 +48,6 @@ use std::ffi::CString;\n use std::cell::{Cell, RefCell};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n-use syntax::ast::Ident;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathName};\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -622,8 +621,8 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n \n-    pub fn ident(&self, ident: Ident) -> String {\n-        token::get_ident(ident).to_string()\n+    pub fn name(&self, name: ast::Name) -> String {\n+        token::get_name(name).to_string()\n     }\n \n     pub fn node_id_to_string(&self, id: ast::NodeId) -> String {"}, {"sha": "d1ecc1d6ddfb6913e9c44515afc4a8f4432c7c42", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -27,7 +27,6 @@ use middle::ty;\n use util::ppaux::Repr;\n \n use syntax::ast;\n-use syntax::ast::Ident;\n use syntax::ast_util;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -321,7 +320,7 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     expr: &ast::Expr,\n-                                    opt_label: Option<Ident>,\n+                                    opt_label: Option<ast::Ident>,\n                                     exit: usize)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n@@ -354,14 +353,14 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n-                               label_opt: Option<Ident>)\n+                               label_opt: Option<ast::Ident>)\n                                -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n }\n \n pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n-                              label_opt: Option<Ident>)\n+                              label_opt: Option<ast::Ident>)\n                               -> Block<'blk, 'tcx> {\n     return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n }"}, {"sha": "9efb91e0c1d736f5c7fb50864e0b06f775e794b6", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -773,11 +773,11 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n \n     let var_item = cx.tcx().map.get(node_id);\n \n-    let (ident, span) = match var_item {\n+    let (name, span) = match var_item {\n         ast_map::NodeItem(item) => {\n             match item.node {\n-                ast::ItemStatic(..) => (item.ident, item.span),\n-                ast::ItemConst(..) => (item.ident, item.span),\n+                ast::ItemStatic(..) => (item.ident.name, item.span),\n+                ast::ItemConst(..) => (item.ident.name, item.span),\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,\n@@ -806,7 +806,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let variable_type = ty::node_id_to_type(cx.tcx(), node_id);\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n-    let var_name = token::get_ident(ident).to_string();\n+    let var_name = token::get_name(name).to_string();\n     let linkage_name =\n         namespace_node.mangled_name_of_contained_item(&var_name[..]);\n     let var_scope = namespace_node.scope;\n@@ -861,7 +861,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n         let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n         declare_local(bcx,\n-                      var_ident.node,\n+                      var_ident.node.name,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -889,14 +889,14 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let ast_item = cx.tcx().map.find(node_id);\n \n-    let variable_ident = match ast_item {\n+    let variable_name = match ast_item {\n         None => {\n             cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n         }\n         Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n                 ast::PatIdent(_, ref path1, _) => {\n-                    path1.node\n+                    path1.node.name\n                 }\n                 _ => {\n                     cx.sess()\n@@ -950,7 +950,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     declare_local(bcx,\n-                  variable_ident,\n+                  variable_name,\n                   variable_type,\n                   scope_metadata,\n                   variable_access,\n@@ -963,7 +963,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                                 variable_ident: ast::Ident,\n+                                                 variable_name: ast::Name,\n                                                  binding: BindingInfo<'tcx>) {\n     if bcx.unreachable.get() ||\n        fn_should_be_ignored(bcx.fcx) ||\n@@ -993,7 +993,7 @@ pub fn create_match_binding_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     declare_local(bcx,\n-                  variable_ident,\n+                  variable_name,\n                   binding.ty,\n                   scope_metadata,\n                   var_access,\n@@ -1048,7 +1048,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n         };\n \n         declare_local(bcx,\n-                      var_ident.node,\n+                      var_ident.node.name,\n                       datum.ty,\n                       scope_metadata,\n                       DirectVariable { alloca: datum.val },\n@@ -1283,15 +1283,15 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let fnitem = cx.tcx().map.get(fn_ast_id);\n \n-    let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n+    let (name, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n         ast_map::NodeItem(ref item) => {\n             if contains_nodebug_attribute(&item.attrs) {\n                 return FunctionDebugContext::FunctionWithoutDebugInfo;\n             }\n \n             match item.node {\n                 ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n-                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n+                    (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -1306,7 +1306,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (impl_item.ident,\n+                    (impl_item.ident.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,\n@@ -1329,7 +1329,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(&name[..]);\n+                    let name = token::intern(&name[..]);\n                     (name, fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1350,7 +1350,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         return FunctionDebugContext::FunctionWithoutDebugInfo;\n                     }\n \n-                    (trait_item.ident,\n+                    (trait_item.ident.name,\n                      &sig.decl,\n                      &sig.generics,\n                      body,\n@@ -1394,7 +1394,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Get_template_parameters() will append a `<...>` clause to the function\n     // name if necessary.\n-    let mut function_name = String::from_str(&token::get_ident(ident));\n+    let mut function_name = String::from_str(&token::get_name(name));\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -1541,10 +1541,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                               actual_self_type,\n                                                               codemap::DUMMY_SP);\n \n-                let ident = special_idents::type_self;\n+                let name = token::get_name(special_idents::type_self.name);\n \n-                let ident = token::get_ident(ident);\n-                let name = CString::new(ident.as_bytes()).unwrap();\n+                let name = CString::new(name.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1673,7 +1672,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n }\n \n fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             variable_ident: ast::Ident,\n+                             variable_name: ast::Name,\n                              variable_type: Ty<'tcx>,\n                              scope_metadata: DIScope,\n                              variable_access: VariableAccess,\n@@ -1684,7 +1683,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = span_start(cx, span).file.name.clone();\n     let file_metadata = file_metadata(cx, &filename[..]);\n \n-    let name = token::get_ident(variable_ident);\n+    let name = token::get_name(variable_name);\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n \n@@ -2261,7 +2260,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_ident(names[0]).to_string(),\n+                        Some(ref names) => token::get_name(names[0]).to_string(),\n                         None => \"\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -2429,9 +2428,8 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let mut arg_names: Vec<_> = match variant_info.arg_names {\n         Some(ref names) => {\n             names.iter()\n-                 .map(|ident| {\n-                     token::get_ident(*ident).to_string()\n-                 }).collect()\n+                 .map(|&name| token::get_name(name).to_string())\n+                 .collect()\n         }\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n     };\n@@ -3245,19 +3243,18 @@ fn create_scope_map(cx: &CrateContext,\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n-        ident: Option<ast::Ident>\n+        name: Option<ast::Name>\n     }\n \n-    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                                 ident: None });\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, name: None });\n     scope_map.insert(fn_ast_id, fn_metadata);\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n         pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n-                                               ident: Some(path1.node) });\n+                                               name: Some(path1.node.name) });\n             scope_map.insert(node_id, fn_metadata);\n         })\n     }\n@@ -3296,13 +3293,12 @@ fn create_scope_map(cx: &CrateContext,\n                 loc.col.to_usize() as c_uint)\n         };\n \n-        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata,\n-                                           ident: None });\n+        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, name: None });\n \n         inner_walk(cx, scope_stack, scope_map);\n \n         // pop artificial scopes\n-        while scope_stack.last().unwrap().ident.is_some() {\n+        while scope_stack.last().unwrap().name.is_some() {\n             scope_stack.pop();\n         }\n \n@@ -3374,7 +3370,7 @@ fn create_scope_map(cx: &CrateContext,\n                 // scope stack and maybe introduce an artificial scope\n                 if pat_util::pat_is_binding(def_map, &*pat) {\n \n-                    let ident = path1.node;\n+                    let name = path1.node.name;\n \n                     // LLVM does not properly generate 'DW_AT_start_scope' fields\n                     // for variable DIEs. For this reason we have to introduce\n@@ -3401,7 +3397,7 @@ fn create_scope_map(cx: &CrateContext,\n                     // variables with the same name will cause the problem.\n                     let need_new_scope = scope_stack\n                         .iter()\n-                        .any(|entry| entry.ident.iter().any(|i| i.name == ident.name));\n+                        .any(|entry| entry.name == Some(name));\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n@@ -3420,15 +3416,15 @@ fn create_scope_map(cx: &CrateContext,\n \n                         scope_stack.push(ScopeStackEntry {\n                             scope_metadata: scope_metadata,\n-                            ident: Some(ident)\n+                            name: Some(name)\n                         });\n \n                     } else {\n                         // Push a new entry anyway so the name can be found\n                         let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n                         scope_stack.push(ScopeStackEntry {\n                             scope_metadata: prev_metadata,\n-                            ident: Some(ident)\n+                            name: Some(name)\n                         });\n                     }\n                 }\n@@ -3970,8 +3966,8 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n     ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n-            let crate_namespace_ident = token::str_to_ident(crate_root_namespace(cx));\n-            Some(ast_map::PathMod(crate_namespace_ident.name))\n+            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n+            Some(ast_map::PathMod(crate_namespace_name))\n         } else {\n             None\n         };"}, {"sha": "757f3dc1db426bfb9c615fe1eb351332d163fd51", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aab8669ddad0432ef7279cc7f7b0b20d32785314/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=aab8669ddad0432ef7279cc7f7b0b20d32785314", "patch": "@@ -678,7 +678,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         ast::ExprField(ref base, ident) => {\n-            trans_rec_field(bcx, &**base, ident.node)\n+            trans_rec_field(bcx, &**base, ident.node.name)\n         }\n         ast::ExprTupField(ref base, idx) => {\n             trans_rec_tup_field(bcx, &**base, idx.node)\n@@ -777,9 +777,9 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n /// Translates `base.field`.\n fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                base: &ast::Expr,\n-                               field: ast::Ident)\n+                               field: ast::Name)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |tcx, field_tys| ty::field_idx_strict(tcx, field.name, field_tys))\n+    trans_field(bcx, base, |tcx, field_tys| ty::field_idx_strict(tcx, field, field_tys))\n }\n \n /// Translates `base.<idx>`."}]}