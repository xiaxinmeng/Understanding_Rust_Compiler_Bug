{"sha": "c21b1f742ec403a24acc39f1c8623e1354da85c7", "node_id": "C_kwDOAAsO6NoAKGMyMWIxZjc0MmVjNDAzYTI0YWNjMzlmMWM4NjIzZTEzNTRkYTg1Yzc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-14T06:47:49Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:20Z"}, "message": "Self review suggestions\n\n- add back accidentally removed new lines\n- try to deref in patterns, rather than in expressions\n  (maybe this was the reason of perf regression?...)", "tree": {"sha": "9348cb1e20998b7c18e167523b860960d13d44b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9348cb1e20998b7c18e167523b860960d13d44b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c21b1f742ec403a24acc39f1c8623e1354da85c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c21b1f742ec403a24acc39f1c8623e1354da85c7", "html_url": "https://github.com/rust-lang/rust/commit/c21b1f742ec403a24acc39f1c8623e1354da85c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c21b1f742ec403a24acc39f1c8623e1354da85c7/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d3c90ae13fa5dbad9e312a7c73b334ac2d8c1d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d3c90ae13fa5dbad9e312a7c73b334ac2d8c1d7", "html_url": "https://github.com/rust-lang/rust/commit/8d3c90ae13fa5dbad9e312a7c73b334ac2d8c1d7"}], "stats": {"total": 65, "additions": 36, "deletions": 29}, "files": [{"sha": "fad4cb06cd6fe4805f2f9dacfb3feac0bf075e22", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=c21b1f742ec403a24acc39f1c8623e1354da85c7", "patch": "@@ -151,50 +151,50 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Also see https://github.com/rust-lang/rust/issues/68364.\n \n         use rustc_middle::mir::Rvalue::*;\n-        match rvalue {\n+        match *rvalue {\n             ThreadLocalRef(did) => {\n-                let ptr = M::thread_local_static_base_pointer(self, *did)?;\n+                let ptr = M::thread_local_static_base_pointer(self, did)?;\n                 self.write_pointer(ptr, &dest)?;\n             }\n \n-            Use(operand) => {\n+            Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /*allow_transmute*/ false)?;\n             }\n \n             CopyForDeref(place) => {\n-                let op = self.eval_place_to_op(*place, Some(dest.layout))?;\n+                let op = self.eval_place_to_op(place, Some(dest.layout))?;\n                 self.copy_op(&op, &dest, /* allow_transmute*/ false)?;\n             }\n \n-            BinaryOp(bin_op, box (left, right)) => {\n-                let layout = binop_left_homogeneous(*bin_op).then_some(dest.layout);\n+            BinaryOp(bin_op, box (ref left, ref right)) => {\n+                let layout = binop_left_homogeneous(bin_op).then_some(dest.layout);\n                 let left = self.read_immediate(&self.eval_operand(left, layout)?)?;\n-                let layout = binop_right_homogeneous(*bin_op).then_some(left.layout);\n+                let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_ignore_overflow(*bin_op, &left, &right, &dest)?;\n+                self.binop_ignore_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n-            CheckedBinaryOp(bin_op, box (left, right)) => {\n+            CheckedBinaryOp(bin_op, box (ref left, ref right)) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n                 let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n-                let layout = binop_right_homogeneous(*bin_op).then_some(left.layout);\n+                let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n                 self.binop_with_overflow(\n-                    *bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n+                    bin_op, /*force_overflow_checks*/ false, &left, &right, &dest,\n                 )?;\n             }\n \n-            UnaryOp(un_op, operand) => {\n+            UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(&self.eval_operand(operand, Some(dest.layout))?)?;\n-                let val = self.unary_op(*un_op, &val)?;\n+                let val = self.unary_op(un_op, &val)?;\n                 assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n                 self.write_immediate(*val, &dest)?;\n             }\n \n-            Aggregate(box kind, operands) => {\n+            Aggregate(box ref kind, ref operands) => {\n                 assert!(matches!(kind, mir::AggregateKind::Array(..)));\n \n                 for (field_index, operand) in operands.iter().enumerate() {\n@@ -204,7 +204,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Repeat(operand, _) => {\n+            Repeat(ref operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n                 assert!(src.layout.is_sized());\n                 let dest = self.force_allocation(&dest)?;\n@@ -241,14 +241,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Len(place) => {\n-                let src = self.eval_place(*place)?;\n+                let src = self.eval_place(place)?;\n                 let op = self.place_to_op(&src)?;\n                 let len = op.len(self)?;\n                 self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n             Ref(_, borrow_kind, place) => {\n-                let src = self.eval_place(*place)?;\n+                let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n                 let val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n                 // A fresh reference was created, make sure it gets retagged.\n@@ -274,7 +274,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     false\n                 };\n \n-                let src = self.eval_place(*place)?;\n+                let src = self.eval_place(place)?;\n                 let place = self.force_allocation(&src)?;\n                 let mut val = ImmTy::from_immediate(place.to_ref(self), dest.layout);\n                 if !place_base_raw {\n@@ -285,7 +285,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             NullaryOp(null_op, ty) => {\n-                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(*ty)?;\n+                let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty)?;\n                 let layout = self.layout_of(ty)?;\n                 if layout.is_unsized() {\n                     // FIXME: This should be a span_bug (#80742)\n@@ -302,21 +302,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(Scalar::from_machine_usize(val, self), &dest)?;\n             }\n \n-            ShallowInitBox(operand, _) => {\n+            ShallowInitBox(ref operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let v = self.read_immediate(&src)?;\n                 self.write_immediate(*v, &dest)?;\n             }\n \n-            Cast(cast_kind, operand, cast_ty) => {\n+            Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let cast_ty =\n-                    self.subst_from_current_frame_and_normalize_erasing_regions(*cast_ty)?;\n-                self.cast(&src, *cast_kind, cast_ty, &dest)?;\n+                    self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty)?;\n+                self.cast(&src, cast_kind, cast_ty, &dest)?;\n             }\n \n             Discriminant(place) => {\n-                let op = self.eval_place_to_op(*place, None)?;\n+                let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(&op)?.0;\n                 self.write_scalar(discr_val, &dest)?;\n             }"}, {"sha": "550c7a44c4199e6cf7043d4dd60f6e49c7f4b436", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=c21b1f742ec403a24acc39f1c8623e1354da85c7", "patch": "@@ -35,6 +35,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets.otherwise();\n+\n                 for (const_int, target) in targets.iter() {\n                     // Compare using MIR BinOp::Eq, to also support pointer values.\n                     // (Avoiding `self.binary_op` as that does some redundant layout computation.)\n@@ -50,6 +51,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         break;\n                     }\n                 }\n+\n                 self.go_to_block(target_block);\n             }\n \n@@ -66,11 +68,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n                 let args = self.eval_operands(args)?;\n+\n                 let fn_sig_binder = func.layout.ty.fn_sig(*self.tcx);\n                 let fn_sig =\n                     self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig_binder);\n                 let extra_args = &args[fn_sig.inputs().len()..];\n                 let extra_args = self.tcx.mk_type_list(extra_args.iter().map(|arg| arg.layout.ty));\n+\n                 let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n                     ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n@@ -144,6 +148,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abort => {\n                 M::abort(self, \"the program aborted execution\".to_owned())?;\n             }\n+\n             // When we encounter Resume, we've finished unwinding\n             // cleanup for the current stack frame. We pop it in order\n             // to continue unwinding the next frame\n@@ -154,8 +159,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.pop_stack_frame(/* unwinding */ true)?;\n                 return Ok(());\n             }\n+\n             // It is UB to ever encounter this.\n             Unreachable => throw_ub!(Unreachable),\n+\n             // These should never occur for MIR we actually run.\n             DropAndReplace { .. }\n             | FalseEdge { .. }"}, {"sha": "f9efc2418dbbcd0ed5ccb8919da86b8bec11a391", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=c21b1f742ec403a24acc39f1c8623e1354da85c7", "patch": "@@ -483,8 +483,8 @@ macro_rules! make_value_visitor {\n                 // Visit the fields of this value.\n                 match &v.layout().fields {\n                     FieldsShape::Primitive => {}\n-                    FieldsShape::Union(fields) => {\n-                        self.visit_union(v, *fields)?;\n+                    &FieldsShape::Union(fields) => {\n+                        self.visit_union(v, fields)?;\n                     }\n                     FieldsShape::Arbitrary { offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime"}, {"sha": "42c3dbfd9a357de8684a6e909271fc46da1354ea", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c21b1f742ec403a24acc39f1c8623e1354da85c7/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=c21b1f742ec403a24acc39f1c8623e1354da85c7", "patch": "@@ -2881,13 +2881,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n-                let opaque_ty = tcx.hir().item(*item_id);\n+            &hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n+                let opaque_ty = tcx.hir().item(item_id);\n                 let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n-                        self.impl_trait_ty_to_ty(def_id, lifetimes, origin, *in_trait)\n+                        self.impl_trait_ty_to_ty(def_id, lifetimes, origin, in_trait)\n                     }\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 }"}]}