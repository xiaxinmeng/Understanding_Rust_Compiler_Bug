{"sha": "aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNGJkMGVjMGVhMGU0ZWRkMmE0NTA3Yzc3NmY5OTc5YTA1MDA1ZDE=", "commit": {"author": {"name": "Nathan Stocks", "email": "nathan.stocks@gmail.com", "date": "2017-04-01T21:48:03Z"}, "committer": {"name": "Nathan Stocks", "email": "nathan.stocks@gmail.com", "date": "2017-04-02T18:57:08Z"}, "message": "Finish the improvements I planned.\n\n- No more manual args manipulation -- getopts used for everything.\n  As a result, options can be in any position, now, even before the\n  subcommand.\n- The additional options for test, bench, and dist now appear in the\n  help output.\n- No more single-letter variable bindings used internally for large\n  scopes.\n- Don't output the time measurement when just invoking 'x.py'\n- Logic is now much more linear.  We build strings up, and then print\n  them.", "tree": {"sha": "dae081f71cc0cef171f9dcf111a784e0a691697b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dae081f71cc0cef171f9dcf111a784e0a691697b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "html_url": "https://github.com/rust-lang/rust/commit/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "5ba579e7f43e607315737899a779d8bd0f378f53", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ba579e7f43e607315737899a779d8bd0f378f53", "html_url": "https://github.com/rust-lang/rust/commit/5ba579e7f43e607315737899a779d8bd0f378f53"}], "stats": {"total": 238, "additions": 113, "deletions": 125}, "files": [{"sha": "0e5991a51bc8092ff7b25730247775cf0561475a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "patch": "@@ -591,17 +591,18 @@ def bootstrap():\n \n def main():\n     start_time = time()\n+    help_triggered = ('-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n         bootstrap()\n-        if ('-h' not in sys.argv) and ('--help' not in sys.argv):\n+        if not help_triggered:\n             print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n     except (SystemExit, KeyboardInterrupt) as e:\n         if hasattr(e, 'code') and isinstance(e.code, int):\n             exit_code = e.code\n         else:\n             exit_code = 1\n             print(e)\n-        if ('-h' not in sys.argv) and ('--help' not in sys.argv):\n+        if not help_triggered:\n             print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n         sys.exit(exit_code)\n "}, {"sha": "e60e279876c375503d17bd06ce060775f6787d01", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 105, "deletions": 117, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "patch": "@@ -18,7 +18,7 @@ use std::fs;\n use std::path::PathBuf;\n use std::process;\n \n-use getopts::{Matches, Options};\n+use getopts::{Options};\n \n use Build;\n use config::Config;\n@@ -75,7 +75,22 @@ pub enum Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n+        let mut extra_help = String::new();\n+        let mut subcommand_help = format!(\"\\\n+Usage: x.py <subcommand> [options] [<paths>...]\n+\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    bench       Build and run some benchmarks\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+\n         let mut opts = Options::new();\n+        // Options common to all subcommands\n         opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n         opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n@@ -89,26 +104,38 @@ impl Flags {\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |exit_code, opts: &Options| -> ! {\n-            let subcommand_help = format!(\"\\\n-Usage: x.py <subcommand> [options] [<paths>...]\n-\n-Subcommands:\n-    build       Compile either the compiler or libraries\n-    test        Build and run some test suites\n-    bench       Build and run some benchmarks\n-    doc         Build documentation\n-    clean       Clean out build directories\n-    dist        Build and/or install distribution artifacts\n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n \n-To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+        // Get subcommand\n+        let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n+            // Invalid argument/option format\n+            println!(\"\\n{}\\n\", e);\n+            usage(1, &opts, &subcommand_help, &extra_help);\n+        });\n+        let subcommand = match matches.free.get(0) {\n+            Some(s) => { s },\n+            None  => {\n+                // No subcommand -- lets only show the general usage and subcommand help in this case.\n+                println!(\"{}\\n\", subcommand_help);\n+                process::exit(0);\n+            }\n+        };\n \n-            println!(\"{}\", opts.usage(&subcommand_help));\n+        // Get any optional paths which occur after the subcommand\n+        let cwd = t!(env::current_dir());\n+        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n \n-            let subcommand = args.get(0).map(|s| &**s);\n-            match subcommand {\n-                Some(\"build\") => {\n-                    println!(\"\\\n+        // Some subcommands have specific arguments help text\n+        match subcommand.as_str() {\n+            \"build\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates \n     and/or artifacts to compile. For example:\n@@ -125,12 +152,11 @@ Arguments:\n \n     For a quick build with a usable compile, you can pass:\n \n-        ./x.py build --stage 1 src/libtest\n-\");\n-                }\n-\n-                Some(\"test\") => {\n-                    println!(\"\\\n+        ./x.py build --stage 1 src/libtest\");\n+            }\n+            \"test\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                subcommand_help.push_str(\"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n@@ -143,12 +169,13 @@ Arguments:\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\n-\");\n-                }\n-\n-                Some(\"doc\") => {\n-                    println!(\"\\\n+        ./x.py test --stage 1\");\n+            }\n+            \"bench\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+            }\n+            \"doc\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories of documentation\n     to build. For example:\n@@ -160,143 +187,104 @@ Arguments:\n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\n-\");\n-                }\n-\n-                _ => {}\n+        ./x.py doc --stage 1\");\n             }\n-\n-\n-            if let Some(subcommand) = subcommand {\n-                if subcommand == \"build\" ||\n-                   subcommand == \"test\" ||\n-                   subcommand == \"bench\" ||\n-                   subcommand == \"doc\" ||\n-                   subcommand == \"clean\" ||\n-                   subcommand == \"dist\"  {\n-                    if args.iter().any(|a| a == \"-v\") {\n-                        let flags = Flags::parse(&[\"build\".to_string()]);\n-                        let mut config = Config::default();\n-                        config.build = flags.build.clone();\n-                        let mut build = Build::new(flags, config);\n-                        metadata::build(&mut build);\n-                        step::build_rules(&build).print_help(subcommand);\n-                    } else {\n-                        println!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                                 subcommand);\n-                    }\n-\n-                    println!(\"\");\n-                }\n+            \"dist\" => {\n+                opts.optflag(\"\", \"install\", \"run installer as well\");\n             }\n-\n-            process::exit(exit_code);\n+            _ => { }\n         };\n-        if args.len() == 0 {\n-            println!(\"a subcommand must be passed\");\n-            usage(1, &opts);\n-        }\n-        let parse = |opts: &Options| {\n-            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n-                println!(\"failed to parse options: {}\", e);\n-                usage(1, opts);\n-            });\n-            if m.opt_present(\"h\") {\n-                usage(0, opts);\n+\n+        // All subcommands can have an optional \"Available paths\" section\n+        if matches.opt_present(\"verbose\") {\n+            let flags = Flags::parse(&[\"build\".to_string()]);\n+            let mut config = Config::default();\n+            config.build = flags.build.clone();\n+            let mut build = Build::new(flags, config);\n+            metadata::build(&mut build);\n+            let maybe_rules_help = step::build_rules(&build).get_help(subcommand);\n+            if maybe_rules_help.is_some() {\n+                extra_help.push_str(maybe_rules_help.unwrap().as_str());\n             }\n-            return m\n-        };\n+        } else {\n+            extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                     subcommand).as_str());\n+        }\n \n-        let cwd = t!(env::current_dir());\n-        let remaining_as_path = |m: &Matches| {\n-            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n-        };\n-        // TODO: Parse subcommand nicely up at top, so options can occur before the subcommand.\n-        // TODO: Get the subcommand-specific options below into the help output\n+        // User passed in -h/--help?\n+        if matches.opt_present(\"help\") {\n+            usage(0, &opts, &subcommand_help, &extra_help);\n+        }\n \n-        let m: Matches;\n-        let cmd = match &args[0][..] {\n+        let cmd = match subcommand.as_str() {\n             \"build\" => {\n-                m = parse(&opts);\n-                Subcommand::Build { paths: remaining_as_path(&m) }\n+                Subcommand::Build { paths: paths }\n             }\n             \"test\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Test {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n             \"bench\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Bench {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n             \"doc\" => {\n-                m = parse(&opts);\n-                Subcommand::Doc { paths: remaining_as_path(&m) }\n+                Subcommand::Doc { paths: paths }\n             }\n             \"clean\" => {\n-                m = parse(&opts);\n-                if m.free.len() > 0 {\n-                    println!(\"clean takes no arguments\");\n-                    usage(1, &opts);\n+                if matches.free.len() > 0 {\n+                    println!(\"\\nclean takes no arguments\\n\");\n+                    usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n                 Subcommand::Clean\n             }\n             \"dist\" => {\n-                opts.optflag(\"\", \"install\", \"run installer as well\");\n-                m = parse(&opts);\n                 Subcommand::Dist {\n-                    paths: remaining_as_path(&m),\n-                    install: m.opt_present(\"install\"),\n+                    paths: paths,\n+                    install: matches.opt_present(\"install\"),\n                 }\n             }\n-            \"--help\" => usage(0, &opts),\n             _ => {\n-                usage(1, &opts);\n+                usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n \n-        let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n                 Some(PathBuf::from(\"config.toml\"))\n             } else {\n                 None\n             }\n         });\n \n-        let mut stage = m.opt_str(\"stage\").map(|j| j.parse().unwrap());\n-\n-        let incremental = m.opt_present(\"i\");\n+        let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n-        if incremental {\n+        if matches.opt_present(\"incremental\") {\n             if stage.is_none() {\n                 stage = Some(1);\n             }\n         }\n \n         Flags {\n-            verbose: m.opt_count(\"v\"),\n+            verbose: matches.opt_count(\"verbose\"),\n             stage: stage,\n-            on_fail: m.opt_str(\"on-fail\"),\n-            keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+            on_fail: matches.opt_str(\"on-fail\"),\n+            keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n+            build: matches.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()\n             }),\n-            host: split(m.opt_strs(\"host\")),\n-            target: split(m.opt_strs(\"target\")),\n+            host: split(matches.opt_strs(\"host\")),\n+            target: split(matches.opt_strs(\"target\")),\n             config: cfg_file,\n-            src: m.opt_str(\"src\").map(PathBuf::from),\n-            jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            src: matches.opt_str(\"src\").map(PathBuf::from),\n+            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n-            incremental: incremental,\n+            incremental: matches.opt_present(\"incremental\"),\n         }\n     }\n }"}, {"sha": "5560b5b0333c862b3c7b64bb23c00e7fcfb5f6c5", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=aa4bd0ec0ea0e4edd2a4507c776f9979a05005d1", "patch": "@@ -978,26 +978,25 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n-    pub fn print_help(&self, command: &str) {\n+    pub fn get_help(&self, command: &str) -> Option<String> {\n         let kind = match command {\n             \"build\" => Kind::Build,\n             \"doc\" => Kind::Doc,\n             \"test\" => Kind::Test,\n             \"bench\" => Kind::Bench,\n             \"dist\" => Kind::Dist,\n-            _ => return,\n+            _ => return None,\n         };\n         let rules = self.rules.values().filter(|r| r.kind == kind);\n         let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n         let mut rules = rules.collect::<Vec<_>>();\n         rules.sort_by_key(|r| r.path);\n \n-        println!(\"Available paths:\\n\");\n+        let mut help_string = String::from(\"Available paths:\\n\");\n         for rule in rules {\n-            print!(\"    ./x.py {} {}\", command, rule.path);\n-\n-            println!(\"\");\n+            help_string.push_str(format!(\"    ./x.py {} {}\\n\", command, rule.path).as_str());\n         }\n+        Some(help_string)\n     }\n \n     /// Construct the top-level build steps that we're going to be executing,"}]}