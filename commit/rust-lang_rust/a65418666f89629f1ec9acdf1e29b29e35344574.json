{"sha": "a65418666f89629f1ec9acdf1e29b29e35344574", "node_id": "C_kwDOAAsO6NoAKGE2NTQxODY2NmY4OTYyOWYxZWM5YWNkZjFlMjliMjllMzUzNDQ1NzQ", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-01T16:39:47Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-03T21:47:46Z"}, "message": "Implement simd_select_bitmask", "tree": {"sha": "94f22d719e198a99df3d366aa4789b8e6f000fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f22d719e198a99df3d366aa4789b8e6f000fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65418666f89629f1ec9acdf1e29b29e35344574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65418666f89629f1ec9acdf1e29b29e35344574", "html_url": "https://github.com/rust-lang/rust/commit/a65418666f89629f1ec9acdf1e29b29e35344574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65418666f89629f1ec9acdf1e29b29e35344574/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc152b04d202123270d7cbfb3f821a392297685", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc152b04d202123270d7cbfb3f821a392297685", "html_url": "https://github.com/rust-lang/rust/commit/ddc152b04d202123270d7cbfb3f821a392297685"}], "stats": {"total": 65, "additions": 57, "deletions": 8}, "files": [{"sha": "71738b52eff494bfe36453fa922496710b802cdf", "filename": "src/builder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a65418666f89629f1ec9acdf1e29b29e35344574/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65418666f89629f1ec9acdf1e29b29e35344574/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=a65418666f89629f1ec9acdf1e29b29e35344574", "patch": "@@ -1438,17 +1438,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n         // cond is a vector of integers, not of bools.\n-        let vector_type = cond.get_type().dyncast_vector().expect(\"vector type\");\n+        let cond_type = cond.get_type();\n+        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n         let num_units = vector_type.get_num_units();\n-        let vector_type = self.context.new_vector_type(self.int_type, num_units as u64);\n-        let zeros = vec![self.context.new_rvalue_zero(self.int_type); num_units];\n-        let zeros = self.context.new_rvalue_from_vector(None, vector_type, &zeros);\n+        let element_type = vector_type.get_element_type();\n+        let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n+        let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n         let then_vals = masks & then_val;\n \n-        let ones = vec![self.context.new_rvalue_one(self.int_type); num_units];\n-        let ones = self.context.new_rvalue_from_vector(None, vector_type, &ones);\n+        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n+        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n         let inverted_masks = masks + ones;\n         let else_vals = inverted_masks & else_val;\n "}, {"sha": "6e14f6d021e1b27a2c6e55abfdde3fe261fff61e", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a65418666f89629f1ec9acdf1e29b29e35344574/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65418666f89629f1ec9acdf1e29b29e35344574/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=a65418666f89629f1ec9acdf1e29b29e35344574", "patch": "@@ -4,12 +4,14 @@ use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n use rustc_hir as hir;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::HasTyCtxt;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::{Span, Symbol, sym};\n+use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n use crate::intrinsic;\n@@ -55,7 +57,53 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     let sig =\n         tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n-    let name_str = name.as_str();\n+\n+    if name == sym::simd_select_bitmask {\n+        require_simd!(arg_tys[1], \"argument\");\n+        let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+\n+        let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n+        let expected_bytes = len / 8 + ((len % 8 > 0) as u64);\n+\n+        let mask_ty = arg_tys[0];\n+        let mut mask = match mask_ty.kind() {\n+            ty::Int(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                let place = PlaceRef::alloca(bx, args[0].layout);\n+                args[0].val.store(bx, place);\n+                let int_ty = bx.type_ix(expected_bytes * 8);\n+                let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n+                bx.load(int_ty, ptr, Align::ONE)\n+            }\n+            _ => return_error!(\n+                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+                mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        };\n+\n+        let arg1 = args[1].immediate();\n+        let arg1_type = arg1.get_type();\n+        let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let arg1_element_type = arg1_vector_type.get_element_type();\n+\n+        let mut elements = vec![];\n+        let one = bx.context.new_rvalue_one(mask.get_type());\n+        for _ in 0..len {\n+            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            elements.push(element);\n+            mask = mask >> one;\n+        }\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+\n+        return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n+    }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n@@ -102,7 +150,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         ));\n     }\n \n-    if let Some(stripped) = name_str.strip_prefix(\"simd_shuffle\") {\n+    if let Some(stripped) = name.as_str().strip_prefix(\"simd_shuffle\") {\n         let n: u64 =\n             if stripped.is_empty() {\n                 // Make sure this is actually an array, since typeck only checks the length-suffixed"}]}