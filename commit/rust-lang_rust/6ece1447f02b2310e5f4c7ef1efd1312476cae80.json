{"sha": "6ece1447f02b2310e5f4c7ef1efd1312476cae80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlY2UxNDQ3ZjAyYjIzMTBlNWY0YzdlZjFlZmQxMzEyNDc2Y2FlODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-20T14:27:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-20T14:27:59Z"}, "message": "Auto merge of #32939 - eddyb:layout, r=nikomatsakis\n\nCompute LLVM-agnostic type layouts in rustc.\n\nLayout for monomorphic types, and some polymorphic ones (e.g. `&T` where `T: Sized`),\ncan now be computed by rustc without involving LLVM in the actual process.\n\nThis gives rustc the ability to evaluate `size_of` or `align_of`, as well as obtain field offsets.\nMIR-based CTFE will eventually make use of these layouts, as will MIR trans, shortly.\n\nLayout computation also comes with a `[breaking-change]`, or two:\n* `\"data-layout\"` is now mandatory in custom target specifications, reverting the decision from #27076.\nThis string is needed because it describes endianness, pointer size and alignments for various types.\nWe have the first two and we could allow tweaking alignments in target specifications.\nOr we could also extract the data layout from LLVM and feed it back into rustc.\nHowever, that can vary with the LLVM version, which is fragile and undermines stability.\nFor built-in targets, I've added a check that the hardcoded data-layout matches LLVM defaults.\n* `transmute` calls are checked in a stricter fashion, which fixes #32377\n\nTo expand on `transmute`, there are only 2 allowed patterns: between types with statically known sizes and between pointers with the same potentially-unsized \"tail\" (which determines the type of unsized metadata they use, if any).\nIf you're affected, my suggestions are:\n* try to use casts (and raw pointer deref) instead of transmutes\n* *really* try to avoid `transmute` where possible\n* if you have a structure, try working on individual fields and unpack/repack the structure instead of transmuting it whole, e.g. `transmute::<RefCell<Box<T>>, RefCell<*mut T>>(x)` doesn't work, but `RefCell::new(Box::into_raw(x.into_inner()))` does (and `Box::into_raw` is just a `transmute`)", "tree": {"sha": "e2fc7e887c386f7524d50282c9ef575821aff120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2fc7e887c386f7524d50282c9ef575821aff120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ece1447f02b2310e5f4c7ef1efd1312476cae80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ece1447f02b2310e5f4c7ef1efd1312476cae80", "html_url": "https://github.com/rust-lang/rust/commit/6ece1447f02b2310e5f4c7ef1efd1312476cae80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ece1447f02b2310e5f4c7ef1efd1312476cae80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "133f60f82012ad92c40693bf1ae28419b60146a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/133f60f82012ad92c40693bf1ae28419b60146a7", "html_url": "https://github.com/rust-lang/rust/commit/133f60f82012ad92c40693bf1ae28419b60146a7"}, {"sha": "c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d564d8c96bf538cc64a3eeca1fcc3c99569625", "html_url": "https://github.com/rust-lang/rust/commit/c7d564d8c96bf538cc64a3eeca1fcc3c99569625"}], "stats": {"total": 2091, "additions": 1698, "deletions": 393}, "files": [{"sha": "536c739bf1615053f75cba0c7e9175518a529074", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -71,7 +71,6 @@ pub enum DepNode<D: Clone + Debug> {\n     DeadCheck,\n     StabilityCheck,\n     LateLintCheck,\n-    IntrinsicUseCheck,\n     TransCrate,\n     TransCrateItem(D),\n     TransInlinedItem(D),\n@@ -169,7 +168,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             DeadCheck => Some(DeadCheck),\n             StabilityCheck => Some(StabilityCheck),\n             LateLintCheck => Some(LateLintCheck),\n-            IntrinsicUseCheck => Some(IntrinsicUseCheck),\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n             Hir(ref d) => op(d).map(Hir),"}, {"sha": "e230836ef451510a3646119490524b31dee0f44b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -1410,6 +1410,32 @@ It is not possible to use stability attributes outside of the standard library.\n Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n+E0512: r##\"\n+Transmute with two differently sized types was attempted. Erroneous code\n+example:\n+\n+```compile_fail\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n+    // error: transmute called with differently sized types\n+}\n+```\n+\n+Please use types with same size or use the expected type directly. Example:\n+\n+```\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n+    // or:\n+    unsafe { takes_u8(0u8); } // ok!\n+}\n+```\n+\"##,\n+\n E0517: r##\"\n This error indicates that a `#[repr(..)]` attribute was placed on an\n unsupported item."}, {"sha": "e84be7e45606b0c77f0f7a55a2d4be4e713e619d", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 103, "deletions": 186, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -11,11 +11,10 @@\n use dep_graph::DepNode;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use ty::subst::{Subst, Substs, EnumeratedItems};\n-use ty::{TransmuteRestriction, TyCtxt};\n-use ty::{self, Ty, TypeFoldable};\n-\n-use std::fmt;\n+use infer::{InferCtxt, new_infer_ctxt};\n+use traits::ProjectionMode;\n+use ty::{self, Ty, TyCtxt};\n+use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n@@ -24,219 +23,148 @@ use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n \n pub fn check_crate(tcx: &TyCtxt) {\n-    let mut visitor = IntrinsicCheckingVisitor {\n-        tcx: tcx,\n-        param_envs: Vec::new(),\n-        dummy_sized_ty: tcx.types.isize,\n-        dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n+    let mut visitor = ItemVisitor {\n+        tcx: tcx\n     };\n     tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n-struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct ItemVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a TyCtxt<'tcx>\n+}\n \n-    // As we traverse the AST, we keep a stack of the parameter\n-    // environments for each function we encounter. When we find a\n-    // call to `transmute`, we can check it in the context of the top\n-    // of the stack (which ought not to be empty).\n-    param_envs: Vec<ty::ParameterEnvironment<'a,'tcx>>,\n+impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n+    fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n+        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                   Some(param_env),\n+                                   ProjectionMode::Any);\n+        let mut visitor = ExprVisitor {\n+            infcx: &infcx\n+        };\n+        visitor.visit_expr(expr);\n+    }\n+}\n \n-    // Dummy sized/unsized types that use to substitute for type\n-    // parameters in order to estimate how big a type will be for any\n-    // possible instantiation of the type parameters in scope.  See\n-    // `check_transmute` for more details.\n-    dummy_sized_ty: Ty<'tcx>,\n-    dummy_unsized_ty: Ty<'tcx>,\n+struct ExprVisitor<'a, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n-        let intrinsic = match self.tcx.lookup_item_type(def_id).ty.sty {\n+        let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.tcx.item_name(def_id).as_str() == \"transmute\"\n+        intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n-        // Find the parameter environment for the most recent function that\n-        // we entered.\n+        let sk_from = SizeSkeleton::compute(from, self.infcx);\n+        let sk_to = SizeSkeleton::compute(to, self.infcx);\n \n-        let param_env = match self.param_envs.last() {\n-            Some(p) => p,\n-            None => {\n-                span_bug!(\n-                    span,\n-                    \"transmute encountered outside of any fn\");\n+        // Check for same size using the skeletons.\n+        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n+            if sk_from.same_size(sk_to) {\n+                return;\n             }\n-        };\n-\n-        // Simple case: no type parameters involved.\n-        if\n-            !from.has_param_types() && !from.has_self_ty() &&\n-            !to.has_param_types() && !to.has_self_ty()\n-        {\n-            let restriction = TransmuteRestriction {\n-                span: span,\n-                original_from: from,\n-                original_to: to,\n-                substituted_from: from,\n-                substituted_to: to,\n-                id: id,\n-            };\n-            self.push_transmute_restriction(restriction);\n-            return;\n-        }\n \n-        // The rules around type parameters are a bit subtle. We are\n-        // checking these rules before monomorphization, so there may\n-        // be unsubstituted type parameters present in the\n-        // types. Obviously we cannot create LLVM types for those.\n-        // However, if a type parameter appears only indirectly (i.e.,\n-        // through a pointer), it does not necessarily affect the\n-        // size, so that should be allowed. The only catch is that we\n-        // DO want to be careful around unsized type parameters, since\n-        // fat pointers have a different size than a thin pointer, and\n-        // hence `&T` and `&U` have different sizes if `T : Sized` but\n-        // `U : Sized` does not hold.\n-        //\n-        // However, it's not as simple as checking whether `T :\n-        // Sized`, because even if `T : Sized` does not hold, that\n-        // just means that `T` *may* not be sized.  After all, even a\n-        // type parameter `T: ?Sized` could be bound to a sized\n-        // type. (Issue #20116)\n-        //\n-        // To handle this, we first check for \"interior\" type\n-        // parameters, which are always illegal. If there are none of\n-        // those, then we know that the only way that all type\n-        // parameters `T` are referenced indirectly, e.g. via a\n-        // pointer type like `&T`. In that case, we only care whether\n-        // `T` is sized or not, because that influences whether `&T`\n-        // is a thin or fat pointer.\n-        //\n-        // One could imagine establishing a sophisticated constraint\n-        // system to ensure that the transmute is legal, but instead\n-        // we do something brutally dumb. We just substitute dummy\n-        // sized or unsized types for every type parameter in scope,\n-        // exhaustively checking all possible combinations. Here are some examples:\n-        //\n-        // ```\n-        // fn foo<T, U>() {\n-        //     // T=int, U=int\n-        // }\n-        //\n-        // fn bar<T: ?Sized, U>() {\n-        //     // T=int, U=int\n-        //     // T=[int], U=int\n-        // }\n-        //\n-        // fn baz<T: ?Sized, U: ?Sized>() {\n-        //     // T=int, U=int\n-        //     // T=[int], U=int\n-        //     // T=int, U=[int]\n-        //     // T=[int], U=[int]\n-        // }\n-        // ```\n-        //\n-        // In all cases, we keep the original unsubstituted types\n-        // around for error reporting.\n-\n-        let from_tc = from.type_contents(self.tcx);\n-        let to_tc = to.type_contents(self.tcx);\n-        if from_tc.interior_param() || to_tc.interior_param() {\n-            span_err!(self.tcx.sess, span, E0139,\n-                      \"cannot transmute to or from a type that contains \\\n-                       unsubstituted type parameters\");\n-            return;\n+            match (&from.sty, sk_to) {\n+                (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n+                        if size_to == Pointer.size(&self.infcx.tcx.data_layout) => {\n+                    // FIXME #19925 Remove this warning after a release cycle.\n+                    let msg = format!(\"`{}` is now zero-sized and has to be cast \\\n+                                       to a pointer before transmuting to `{}`\",\n+                                      from, to);\n+                    self.infcx.tcx.sess.add_lint(\n+                        ::lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES, id, span, msg);\n+                    return;\n+                }\n+                _ => {}\n+            }\n         }\n \n-        let mut substs = param_env.free_substs.clone();\n-        self.with_each_combination(\n-            span,\n-            param_env,\n-            param_env.free_substs.types.iter_enumerated(),\n-            &mut substs,\n-            &mut |substs| {\n-                let restriction = TransmuteRestriction {\n-                    span: span,\n-                    original_from: from,\n-                    original_to: to,\n-                    substituted_from: from.subst(self.tcx, substs),\n-                    substituted_to: to.subst(self.tcx, substs),\n-                    id: id,\n-                };\n-                self.push_transmute_restriction(restriction);\n-            });\n-    }\n-\n-    fn with_each_combination(&self,\n-                             span: Span,\n-                             param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                             mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n-                             substs: &mut Substs<'tcx>,\n-                             callback: &mut FnMut(&Substs<'tcx>))\n-    {\n-        // This parameter invokes `callback` many times with different\n-        // substitutions that replace all the parameters in scope with\n-        // either `int` or `[int]`, depending on whether the type\n-        // parameter is known to be sized. See big comment above for\n-        // an explanation of why this is a reasonable thing to do.\n-\n-        match types_in_scope.next() {\n-            None => {\n-                debug!(\"with_each_combination(substs={:?})\",\n-                       substs);\n-\n-                callback(substs);\n+        // Try to display a sensible error with as much information as possible.\n+        let skeleton_string = |ty: Ty<'tcx>, sk| {\n+            match sk {\n+                Ok(SizeSkeleton::Known(size)) => {\n+                    format!(\"{} bits\", size.bits())\n+                }\n+                Ok(SizeSkeleton::Pointer { tail, .. }) => {\n+                    format!(\"pointer to {}\", tail)\n+                }\n+                Err(LayoutError::Unknown(bad)) => {\n+                    if bad == ty {\n+                        format!(\"size can vary\")\n+                    } else {\n+                        format!(\"size can vary because of {}\", bad)\n+                    }\n+                }\n+                Err(err) => err.to_string()\n             }\n+        };\n \n-            Some((space, index, &param_ty)) => {\n-                debug!(\"with_each_combination: space={:?}, index={}, param_ty={:?}\",\n-                       space, index, param_ty);\n-\n-                if !param_ty.is_sized(param_env, span) {\n-                    debug!(\"with_each_combination: param_ty is not known to be sized\");\n+        span_err!(self.infcx.tcx.sess, span, E0512,\n+                  \"transmute called with differently sized types: \\\n+                   {} ({}) to {} ({})\",\n+                  from, skeleton_string(from, sk_from),\n+                  to, skeleton_string(to, sk_to));\n+    }\n+}\n \n-                    substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n-                    self.with_each_combination(span, param_env, types_in_scope.clone(),\n-                                               substs, callback);\n-                }\n+impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n+    // const, static and N in [T; N].\n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                   None, ProjectionMode::Any);\n+        let mut visitor = ExprVisitor {\n+            infcx: &infcx\n+        };\n+        visitor.visit_expr(expr);\n+    }\n \n-                substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n-                self.with_each_combination(span, param_env, types_in_scope,\n-                                           substs, callback);\n-            }\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n+            self.visit_const(item.id, expr);\n+        } else {\n+            intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n-        debug!(\"Pushing transmute restriction: {:?}\", restriction);\n-        self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+            self.visit_const(item.id, expr);\n+        } else {\n+            intravisit::walk_impl_item(self, item);\n+        }\n     }\n-}\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) | FnKind::Method(..) => {\n                 let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-                self.param_envs.push(param_env);\n-                intravisit::walk_fn(self, fk, fd, b, s);\n-                self.param_envs.pop();\n+                let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n+                                           Some(param_env),\n+                                           ProjectionMode::Any);\n+                let mut visitor = ExprVisitor {\n+                    infcx: &infcx\n+                };\n+                visitor.visit_fn(fk, fd, b, s, id);\n             }\n             FnKind::Closure(..) => {\n-                intravisit::walk_fn(self, fk, fd, b, s);\n+                span_bug!(s, \"intrinsicck: closure outside of function\")\n             }\n         }\n     }\n+}\n \n+impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n-            match self.tcx.resolve_expr(expr) {\n+            match self.infcx.tcx.resolve_expr(expr) {\n                 Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.tcx.node_id_to_type(expr.id);\n+                    let typ = self.infcx.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         ty::TyFnDef(_, _, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n                             if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n@@ -256,14 +184,3 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n }\n-\n-impl<'tcx> fmt::Debug for TransmuteRestriction<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TransmuteRestriction(id={}, original=({:?},{:?}), substituted=({:?},{:?}))\",\n-               self.id,\n-               self.original_from,\n-               self.original_to,\n-               self.substituted_from,\n-               self.substituted_to)\n-    }\n-}"}, {"sha": "10000607b540907a2a1a5bb434b4161f56b219b7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -31,6 +31,7 @@ use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n+use ty::layout::{Layout, TargetDataLayout};\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -55,6 +56,7 @@ pub struct CtxtArenas<'tcx> {\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n+    layout: TypedArena<Layout>,\n \n     // references\n     trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n@@ -69,6 +71,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n+            layout: TypedArena::new(),\n \n             trait_defs: TypedArena::new(),\n             adt_defs: TypedArena::new()\n@@ -229,6 +232,7 @@ pub struct TyCtxt<'tcx> {\n     bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n     region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n     stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n+    layout_interner: RefCell<FnvHashMap<&'tcx Layout, &'tcx Layout>>,\n \n     pub dep_graph: DepGraph,\n \n@@ -353,11 +357,6 @@ pub struct TyCtxt<'tcx> {\n     pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n                                               lint::LevelSource>>,\n \n-    /// The types that must be asserted to be the same size for `transmute`\n-    /// to be valid. We gather up these restrictions in the intrinsicck pass\n-    /// and check them in trans.\n-    pub transmute_restrictions: RefCell<Vec<ty::TransmuteRestriction<'tcx>>>,\n-\n     /// Maps any item's def-id to its stability index.\n     pub stability: RefCell<stability::Index<'tcx>>,\n \n@@ -419,6 +418,12 @@ pub struct TyCtxt<'tcx> {\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: token::InternedString,\n+\n+    /// Data layout specification for the current target.\n+    pub data_layout: TargetDataLayout,\n+\n+    /// Cache for layouts computed from types.\n+    pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -500,6 +505,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         interned\n     }\n \n+    pub fn intern_layout(&self, layout: Layout) -> &'tcx Layout {\n+        if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n+            return layout;\n+        }\n+\n+        let interned = self.arenas.layout.alloc(layout);\n+        if let Some(prev) = self.layout_interner\n+                                .borrow_mut()\n+                                .insert(interned, interned) {\n+            bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n+        }\n+        interned\n+    }\n+\n     pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n         if self.free_region_maps.borrow_mut().insert(id, map).is_some() {\n             bug!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\", id)\n@@ -531,6 +550,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  f: F) -> R\n                                  where F: FnOnce(&TyCtxt<'tcx>) -> R\n     {\n+        let data_layout = TargetDataLayout::parse(s);\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n         let dep_graph = map.dep_graph.clone();\n@@ -542,6 +562,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             bare_fn_interner: RefCell::new(FnvHashMap()),\n             region_interner: RefCell::new(FnvHashMap()),\n             stability_interner: RefCell::new(FnvHashMap()),\n+            layout_interner: RefCell::new(FnvHashMap()),\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n@@ -579,7 +600,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             extern_const_statics: RefCell::new(DefIdMap()),\n             extern_const_fns: RefCell::new(DefIdMap()),\n             node_lint_levels: RefCell::new(FnvHashMap()),\n-            transmute_restrictions: RefCell::new(Vec::new()),\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n@@ -589,6 +609,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: token::intern_and_get_ident(crate_name),\n+            data_layout: data_layout,\n+            layout_cache: RefCell::new(FnvHashMap()),\n        }, f)\n     }\n }\n@@ -762,6 +784,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n         println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n         println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n+        println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n     }\n }\n "}, {"sha": "3ea691b4dc76649d0b7d0fa9c281507e6f924106", "filename": "src/librustc/ty/layout.rs", "status": "added", "additions": 1336, "deletions": 0, "changes": 1336, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -0,0 +1,1336 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::Integer::*;\n+pub use self::Layout::*;\n+pub use self::Primitive::*;\n+\n+use infer::{InferCtxt, drain_fulfillment_cx_or_panic};\n+use session::Session;\n+use traits;\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+\n+use syntax::ast::{FloatTy, IntTy, UintTy};\n+use syntax::attr;\n+use syntax::codemap::DUMMY_SP;\n+\n+use std::cmp;\n+use std::fmt;\n+use std::i64;\n+\n+/// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n+/// for a target, which contains everything needed to compute layouts.\n+pub struct TargetDataLayout {\n+    pub endian: Endian,\n+    pub i1_align: Align,\n+    pub i8_align: Align,\n+    pub i16_align: Align,\n+    pub i32_align: Align,\n+    pub i64_align: Align,\n+    pub f32_align: Align,\n+    pub f64_align: Align,\n+    pub pointer_size: Size,\n+    pub pointer_align: Align,\n+    pub aggregate_align: Align,\n+\n+    /// Alignments for vector types.\n+    pub vector_align: Vec<(Size, Align)>\n+}\n+\n+impl Default for TargetDataLayout {\n+    fn default() -> TargetDataLayout {\n+        TargetDataLayout {\n+            endian: Endian::Big,\n+            i1_align: Align::from_bits(8, 8).unwrap(),\n+            i8_align: Align::from_bits(8, 8).unwrap(),\n+            i16_align: Align::from_bits(16, 16).unwrap(),\n+            i32_align: Align::from_bits(32, 32).unwrap(),\n+            i64_align: Align::from_bits(32, 64).unwrap(),\n+            f32_align: Align::from_bits(32, 32).unwrap(),\n+            f64_align: Align::from_bits(64, 64).unwrap(),\n+            pointer_size: Size::from_bits(64),\n+            pointer_align: Align::from_bits(64, 64).unwrap(),\n+            aggregate_align: Align::from_bits(0, 64).unwrap(),\n+            vector_align: vec![\n+                (Size::from_bits(64), Align::from_bits(64, 64).unwrap()),\n+                (Size::from_bits(128), Align::from_bits(128, 128).unwrap())\n+            ]\n+        }\n+    }\n+}\n+\n+impl TargetDataLayout {\n+    pub fn parse(sess: &Session) -> TargetDataLayout {\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &str, kind: &str, cause: &str| {\n+            s.parse::<u64>().unwrap_or_else(|err| {\n+                sess.err(&format!(\"invalid {} `{}` for `{}` in \\\"data-layout\\\": {}\",\n+                                  kind, s, cause, err));\n+                0\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &str, cause: &str| {\n+            Size::from_bits(parse_bits(s, \"size\", cause))\n+        };\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&str], cause: &str| {\n+            if s.is_empty() {\n+                sess.err(&format!(\"missing alignment for `{}` in \\\"data-layout\\\"\", cause));\n+            }\n+            let abi = parse_bits(s[0], \"alignment\", cause);\n+            let pref = s.get(1).map_or(abi, |pref| parse_bits(pref, \"alignment\", cause));\n+            Align::from_bits(abi, pref).unwrap_or_else(|err| {\n+                sess.err(&format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\",\n+                                  cause, err));\n+                Align::from_bits(8, 8).unwrap()\n+            })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        for spec in sess.target.target.data_layout.split(\"-\") {\n+            match &spec.split(\":\").collect::<Vec<_>>()[..] {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [\"a\", a..] => dl.aggregate_align = align(a, \"a\"),\n+                [\"f32\", a..] => dl.f32_align = align(a, \"f32\"),\n+                [\"f64\", a..] => dl.f64_align = align(a, \"f64\"),\n+                [p @ \"p\", s, a..] | [p @ \"p0\", s, a..] => {\n+                    dl.pointer_size = size(s, p);\n+                    dl.pointer_align = align(a, p);\n+                }\n+                [s, a..] if s.starts_with(\"i\") => {\n+                    let ty_align = match s[1..].parse::<u64>() {\n+                        Ok(1) => &mut dl.i8_align,\n+                        Ok(8) => &mut dl.i8_align,\n+                        Ok(16) => &mut dl.i16_align,\n+                        Ok(32) => &mut dl.i32_align,\n+                        Ok(64) => &mut dl.i64_align,\n+                        Ok(_) => continue,\n+                        Err(_) => {\n+                            size(&s[1..], \"i\"); // For the user error.\n+                            continue;\n+                        }\n+                    };\n+                    *ty_align = align(a, s);\n+                }\n+                [s, a..] if s.starts_with(\"v\") => {\n+                    let v_size = size(&s[1..], \"v\");\n+                    let a = align(a, s);\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+\n+        // Perform consistency checks against the Target information.\n+        let endian_str = match dl.endian {\n+            Endian::Little => \"little\",\n+            Endian::Big => \"big\"\n+        };\n+        if endian_str != sess.target.target.target_endian {\n+            sess.err(&format!(\"inconsistent target specification: \\\"data-layout\\\" claims \\\n+                               architecture is {}-endian, while \\\"target-endian\\\" is `{}`\",\n+                              endian_str, sess.target.target.target_endian));\n+        }\n+\n+        if dl.pointer_size.bits().to_string() != sess.target.target.target_pointer_width {\n+            sess.err(&format!(\"inconsistent target specification: \\\"data-layout\\\" claims \\\n+                               pointers are {}-bit, while \\\"target-pointer-width\\\" is `{}`\",\n+                              dl.pointer_size.bits(), sess.target.target.target_pointer_width));\n+        }\n+\n+        dl\n+    }\n+\n+    /// Return exclusive upper bound on object size.\n+    ///\n+    /// The theoretical maximum object size is defined as the maximum positive `isize` value.\n+    /// This ensures that the `offset` semantics remain well-defined by allowing it to correctly\n+    /// index every address within an object along with one byte past the end, along with allowing\n+    /// `isize` to store the difference between any two pointers into an object.\n+    ///\n+    /// The upper bound on 64-bit currently needs to be lower because LLVM uses a 64-bit integer\n+    /// to represent object size in bits. It would need to be 1 << 61 to account for this, but is\n+    /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n+    /// address space on 64-bit ARMv8 and x86_64.\n+    pub fn obj_size_bound(&self) -> u64 {\n+        match self.pointer_size.bits() {\n+            32 => 1 << 31,\n+            64 => 1 << 47,\n+            bits => bug!(\"obj_size_bound: unknown pointer bit size {}\", bits)\n+        }\n+    }\n+\n+    pub fn ptr_sized_integer(&self) -> Integer {\n+        match self.pointer_size.bits() {\n+            32 => I32,\n+            64 => I64,\n+            bits => bug!(\"ptr_sized_integer: unknown pointer bit size {}\", bits)\n+        }\n+    }\n+}\n+\n+/// Endianness of the target, which must match cfg(target-endian).\n+#[derive(Copy, Clone)]\n+pub enum Endian {\n+    Little,\n+    Big\n+}\n+\n+/// Size of a type in bytes.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct Size {\n+    raw: u64\n+}\n+\n+impl Size {\n+    pub fn from_bits(bits: u64) -> Size {\n+        Size::from_bytes((bits + 7) / 8)\n+    }\n+\n+    pub fn from_bytes(bytes: u64) -> Size {\n+        if bytes >= (1 << 61) {\n+            bug!(\"Size::from_bytes: {} bytes in bits doesn't fit in u64\", bytes)\n+        }\n+        Size {\n+            raw: bytes\n+        }\n+    }\n+\n+    pub fn bytes(self) -> u64 {\n+        self.raw\n+    }\n+\n+    pub fn bits(self) -> u64 {\n+        self.bytes() * 8\n+    }\n+\n+    pub fn abi_align(self, align: Align) -> Size {\n+        let mask = align.abi() - 1;\n+        Size::from_bytes((self.bytes() + mask) & !mask)\n+    }\n+\n+    pub fn checked_add(self, offset: Size, dl: &TargetDataLayout) -> Option<Size> {\n+        // Each Size is less than dl.obj_size_bound(), so the sum is\n+        // also less than 1 << 62 (and therefore can't overflow).\n+        let bytes = self.bytes() + offset.bytes();\n+\n+        if bytes < dl.obj_size_bound() {\n+            Some(Size::from_bytes(bytes))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn checked_mul(self, count: u64, dl: &TargetDataLayout) -> Option<Size> {\n+        // Each Size is less than dl.obj_size_bound(), so the sum is\n+        // also less than 1 << 62 (and therefore can't overflow).\n+        match self.bytes().checked_mul(count) {\n+            Some(bytes) if bytes < dl.obj_size_bound() => {\n+                Some(Size::from_bytes(bytes))\n+            }\n+            _ => None\n+        }\n+    }\n+}\n+\n+/// Alignment of a type in bytes, both ABI-mandated and preferred.\n+/// Since alignments are always powers of 2, we can pack both in one byte,\n+/// giving each a nibble (4 bits) for a maximum alignment of 2^15 = 32768.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Align {\n+    raw: u8\n+}\n+\n+impl Align {\n+    pub fn from_bits(abi: u64, pref: u64) -> Result<Align, String> {\n+        Align::from_bytes((abi + 7) / 8, (pref + 7) / 8)\n+    }\n+\n+    pub fn from_bytes(abi: u64, pref: u64) -> Result<Align, String> {\n+        let pack = |align: u64| {\n+            // Treat an alignment of 0 bytes like 1-byte alignment.\n+            if align == 0 {\n+                return Ok(0);\n+            }\n+\n+            let mut bytes = align;\n+            let mut pow: u8 = 0;\n+            while (bytes & 1) == 0 {\n+                pow += 1;\n+                bytes >>= 1;\n+            }\n+            if bytes != 1 {\n+                Err(format!(\"`{}` is not a power of 2\", align))\n+            } else if pow > 0x0f {\n+                Err(format!(\"`{}` is too large\", align))\n+            } else {\n+                Ok(pow)\n+            }\n+        };\n+\n+        Ok(Align {\n+            raw: pack(abi)? | (pack(pref)? << 4)\n+        })\n+    }\n+\n+    pub fn abi(self) -> u64 {\n+        1 << (self.raw & 0xf)\n+    }\n+\n+    pub fn pref(self) -> u64 {\n+        1 << (self.raw >> 4)\n+    }\n+\n+    pub fn min(self, other: Align) -> Align {\n+        let abi = cmp::min(self.raw & 0x0f, other.raw & 0x0f);\n+        let pref = cmp::min(self.raw & 0xf0, other.raw & 0xf0);\n+        Align {\n+            raw: abi | pref\n+        }\n+    }\n+\n+    pub fn max(self, other: Align) -> Align {\n+        let abi = cmp::max(self.raw & 0x0f, other.raw & 0x0f);\n+        let pref = cmp::max(self.raw & 0xf0, other.raw & 0xf0);\n+        Align {\n+            raw: abi | pref\n+        }\n+    }\n+}\n+\n+/// Integers, also used for enum discriminants.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Integer {\n+    I1,\n+    I8,\n+    I16,\n+    I32,\n+    I64\n+}\n+\n+impl Integer {\n+    /// Find the smallest Integer type which can represent the signed value.\n+    pub fn fit_signed(x: i64) -> Integer {\n+        match x {\n+            -0x0000_0001...0x0000_0000 => I1,\n+            -0x0000_0080...0x0000_007f => I8,\n+            -0x0000_8000...0x0000_7fff => I16,\n+            -0x8000_0000...0x7fff_ffff => I32,\n+            _ => I64\n+        }\n+    }\n+\n+    /// Find the smallest Integer type which can represent the unsigned value.\n+    pub fn fit_unsigned(x: u64) -> Integer {\n+        match x {\n+            0...0x0000_0001 => I1,\n+            0...0x0000_00ff => I8,\n+            0...0x0000_ffff => I16,\n+            0...0xffff_ffff => I32,\n+            _ => I64\n+        }\n+    }\n+\n+    /// Get the Integer type from an attr::IntType.\n+    pub fn from_attr(dl: &TargetDataLayout, ity: attr::IntType) -> Integer {\n+        match ity {\n+            attr::SignedInt(IntTy::I8) | attr::UnsignedInt(UintTy::U8) => I8,\n+            attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n+            attr::SignedInt(IntTy::I32) | attr::UnsignedInt(UintTy::U32) => I32,\n+            attr::SignedInt(IntTy::I64) | attr::UnsignedInt(UintTy::U64) => I64,\n+            attr::SignedInt(IntTy::Is) | attr::UnsignedInt(UintTy::Us) => {\n+                dl.ptr_sized_integer()\n+            }\n+        }\n+    }\n+\n+    /// Find the appropriate Integer type and signedness for the given\n+    /// signed discriminant range and #[repr] attribute.\n+    /// N.B.: u64 values above i64::MAX will be treated as signed, but\n+    /// that shouldn't affect anything, other than maybe debuginfo.\n+    pub fn repr_discr(tcx: &TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+                      -> (Integer, bool) {\n+        // Theoretically, negative values could be larger in unsigned representation\n+        // than the unsigned representation of the signed minimum. However, if there\n+        // are any negative values, the only valid unsigned representation is u64\n+        // which can fit all i64 values, so the result remains unaffected.\n+        let unsigned_fit = Integer::fit_unsigned(cmp::max(min as u64, max as u64));\n+        let signed_fit = cmp::max(Integer::fit_signed(min), Integer::fit_signed(max));\n+\n+        let at_least = match hint {\n+            attr::ReprInt(span, ity) => {\n+                let discr = Integer::from_attr(&tcx.data_layout, ity);\n+                let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+                if discr < fit {\n+                    span_bug!(span, \"representation hint insufficient for discriminant range\")\n+                }\n+                return (discr, ity.is_signed());\n+            }\n+            attr::ReprExtern => {\n+                match &tcx.sess.target.target.arch[..] {\n+                    // WARNING: the ARM EABI has two variants; the one corresponding\n+                    // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                    // but some systems may use the variant corresponding to no\n+                    // lower bound.  However, we don't run on those yet...?\n+                    \"arm\" => I32,\n+                    _ => I32,\n+                }\n+            }\n+            attr::ReprAny => I8,\n+            attr::ReprPacked => {\n+                bug!(\"Integer::repr_discr: found #[repr(packed)] on an enum\");\n+            }\n+            attr::ReprSimd => {\n+                bug!(\"Integer::repr_discr: found #[repr(simd)] on an enum\");\n+            }\n+        };\n+\n+        // If there are no negative values, we can use the unsigned fit.\n+        if min >= 0 {\n+            (cmp::max(unsigned_fit, at_least), false)\n+        } else {\n+            (cmp::max(signed_fit, at_least), true)\n+        }\n+    }\n+}\n+\n+/// Fundamental unit of memory access and layout.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Primitive {\n+    Int(Integer),\n+    F32,\n+    F64,\n+    Pointer\n+}\n+\n+impl Primitive {\n+    pub fn size(self, dl: &TargetDataLayout) -> Size {\n+        match self {\n+            Int(I1) | Int(I8) => Size::from_bits(8),\n+            Int(I16) => Size::from_bits(16),\n+            Int(I32) | F32 => Size::from_bits(32),\n+            Int(I64) | F64 => Size::from_bits(64),\n+            Pointer => dl.pointer_size\n+        }\n+    }\n+\n+    pub fn align(self, dl: &TargetDataLayout) -> Align {\n+        match self {\n+            Int(I1) => dl.i1_align,\n+            Int(I8) => dl.i8_align,\n+            Int(I16) => dl.i16_align,\n+            Int(I32) => dl.i32_align,\n+            Int(I64) => dl.i64_align,\n+            F32 => dl.f32_align,\n+            F64 => dl.f64_align,\n+            Pointer => dl.pointer_align\n+        }\n+    }\n+}\n+\n+/// Path through fields of nested structures.\n+// FIXME(eddyb) use small vector optimization for the common case.\n+pub type FieldPath = Vec<u32>;\n+\n+/// A structure, a product type in ADT terms.\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct Struct {\n+    pub align: Align,\n+\n+    /// If true, no alignment padding is used.\n+    pub packed: bool,\n+\n+    /// If true, the size is exact, otherwise it's only a lower bound.\n+    pub sized: bool,\n+\n+    /// Offsets for the first byte after each field.\n+    /// That is, field_offset(i) = offset_after_field[i - 1] and the\n+    /// whole structure's size is the last offset, excluding padding.\n+    // FIXME(eddyb) use small vector optimization for the common case.\n+    pub offset_after_field: Vec<Size>\n+}\n+\n+impl Struct {\n+    pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n+        Struct {\n+            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            packed: packed,\n+            sized: true,\n+            offset_after_field: vec![]\n+        }\n+    }\n+\n+    /// Extend the Struct with more fields.\n+    pub fn extend<'a, 'tcx, I>(&mut self, dl: &TargetDataLayout,\n+                               fields: I,\n+                               scapegoat: Ty<'tcx>)\n+                               -> Result<(), LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+        self.offset_after_field.reserve(fields.size_hint().0);\n+\n+        for field in fields {\n+            if !self.sized {\n+                bug!(\"Struct::compute: field #{} of `{}` comes after unsized field\",\n+                     self.offset_after_field.len(), scapegoat);\n+            }\n+\n+            let field = field?;\n+            if field.is_unsized() {\n+                self.sized = false;\n+            }\n+\n+            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+            let mut offset = if !self.packed {\n+                let align = field.align(dl);\n+                self.align = self.align.max(align);\n+                self.offset_after_field.last_mut().map_or(Size::from_bytes(0), |last| {\n+                    *last = last.abi_align(align);\n+                    *last\n+                })\n+            } else {\n+                self.offset_after_field.last().map_or(Size::from_bytes(0), |&last| last)\n+            };\n+\n+            offset = offset.checked_add(field.size(dl), dl)\n+                           .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n+\n+            self.offset_after_field.push(offset);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Get the size without trailing alignment padding.\n+    pub fn min_size(&self) -> Size {\n+        self.offset_after_field.last().map_or(Size::from_bytes(0), |&last| last)\n+    }\n+\n+    /// Get the size with trailing aligment padding.\n+    pub fn stride(&self) -> Size {\n+        self.min_size().abi_align(self.align)\n+    }\n+\n+    /// Determine whether a structure would be zero-sized, given its fields.\n+    pub fn would_be_zero_sized<'a, 'tcx, I>(dl: &TargetDataLayout, fields: I)\n+                                            -> Result<bool, LayoutError<'tcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+        for field in fields {\n+            let field = field?;\n+            if field.is_unsized() || field.size(dl).bytes() > 0 {\n+                return Ok(false);\n+            }\n+        }\n+        Ok(true)\n+    }\n+\n+    /// Find the path leading to a non-zero leaf field, starting from\n+    /// the given type and recursing through aggregates.\n+    // FIXME(eddyb) track value ranges and traverse already optimized enums.\n+    pub fn non_zero_field_in_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                            ty: Ty<'tcx>)\n+                                            -> Result<Option<FieldPath>, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx;\n+        match (ty.layout(infcx)?, &ty.sty) {\n+            (&Scalar { non_zero: true, .. }, _) => Ok(Some(vec![])),\n+            (&FatPointer { non_zero: true, .. }, _) => {\n+                Ok(Some(vec![FAT_PTR_ADDR as u32]))\n+            }\n+\n+            // Is this the NonZero lang item wrapping a pointer or integer type?\n+            (&Univariant { non_zero: true, .. }, &ty::TyStruct(def, substs)) => {\n+                let fields = &def.struct_variant().fields;\n+                assert_eq!(fields.len(), 1);\n+                let ty = normalize_associated_type(infcx, fields[0].ty(tcx, substs));\n+                match *ty.layout(infcx)? {\n+                    // FIXME(eddyb) also allow floating-point types here.\n+                    Scalar { value: Int(_), non_zero: false } |\n+                    Scalar { value: Pointer, non_zero: false } => {\n+                        Ok(Some(vec![0]))\n+                    }\n+                    FatPointer { non_zero: false, .. } => {\n+                        Ok(Some(vec![FAT_PTR_ADDR as u32, 0]))\n+                    }\n+                    _ => Ok(None)\n+                }\n+            }\n+\n+            // Perhaps one of the fields of this struct is non-zero\n+            // let's recurse and find out\n+            (_, &ty::TyStruct(def, substs)) => {\n+                Struct::non_zero_field_path(infcx, def.struct_variant().fields\n+                                                      .iter().map(|field| {\n+                    normalize_associated_type(infcx, field.ty(tcx, substs))\n+                }))\n+            }\n+\n+            // Perhaps one of the upvars of this closure is non-zero\n+            // Let's recurse and find out!\n+            (_, &ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. })) |\n+            // Can we use one of the fields in this tuple?\n+            (_, &ty::TyTuple(ref tys)) => {\n+                Struct::non_zero_field_path(infcx, tys.iter().cloned())\n+            }\n+\n+            // Is this a fixed-size array of something non-zero\n+            // with at least one element?\n+            (_, &ty::TyArray(ety, d)) if d > 0 => {\n+                Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n+            }\n+\n+            // Anything else is not a non-zero type.\n+            _ => Ok(None)\n+        }\n+    }\n+\n+    /// Find the path leading to a non-zero leaf field, starting from\n+    /// the given set of fields and recursing through aggregates.\n+    pub fn non_zero_field_path<'a, 'tcx, I>(infcx: &InferCtxt<'a, 'tcx>,\n+                                            fields: I)\n+                                            -> Result<Option<FieldPath>, LayoutError<'tcx>>\n+    where I: Iterator<Item=Ty<'tcx>> {\n+        for (i, ty) in fields.enumerate() {\n+            if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n+                path.push(i as u32);\n+                return Ok(Some(path));\n+            }\n+        }\n+        Ok(None)\n+    }\n+}\n+\n+/// The first half of a fat pointer.\n+/// - For a trait object, this is the address of the box.\n+/// - For a slice, this is the base address.\n+pub const FAT_PTR_ADDR: usize = 0;\n+\n+/// The second half of a fat pointer.\n+/// - For a trait object, this is the address of the vtable.\n+/// - For a slice, this is the length.\n+pub const FAT_PTR_EXTRA: usize = 1;\n+\n+/// Type layout, from which size and alignment can be cheaply computed.\n+/// For ADTs, it also includes field placement and enum optimizations.\n+/// NOTE: Because Layout is interned, redundant information should be\n+/// kept to a minimum, e.g. it includes no sub-component Ty or Layout.\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub enum Layout {\n+    /// TyBool, TyChar, TyInt, TyUint, TyFloat, TyRawPtr, TyRef or TyFnPtr.\n+    Scalar {\n+        value: Primitive,\n+        // If true, the value cannot represent a bit pattern of all zeroes.\n+        non_zero: bool\n+    },\n+\n+    /// SIMD vectors, from TyStruct marked with #[repr(simd)].\n+    Vector {\n+        element: Primitive,\n+        count: u64\n+    },\n+\n+    /// TyArray, TySlice or TyStr.\n+    Array {\n+        /// If true, the size is exact, otherwise it's only a lower bound.\n+        sized: bool,\n+        align: Align,\n+        size: Size\n+    },\n+\n+    /// TyRawPtr or TyRef with a !Sized pointee.\n+    FatPointer {\n+        metadata: Primitive,\n+        // If true, the pointer cannot be null.\n+        non_zero: bool\n+    },\n+\n+    // Remaining variants are all ADTs such as TyStruct, TyEnum or TyTuple.\n+\n+    /// C-like enums; basically an integer.\n+    CEnum {\n+        discr: Integer,\n+        signed: bool,\n+        // Inclusive discriminant range.\n+        // If min > max, it represents min...u64::MAX followed by 0...max.\n+        // FIXME(eddyb) always use the shortest range, e.g. by finding\n+        // the largest space between two consecutive discriminants and\n+        // taking everything else as the (shortest) discriminant range.\n+        min: u64,\n+        max: u64\n+    },\n+\n+    /// Single-case enums, and structs/tuples.\n+    Univariant {\n+        variant: Struct,\n+        // If true, the structure is NonZero.\n+        // FIXME(eddyb) use a newtype Layout kind for this.\n+        non_zero: bool\n+    },\n+\n+    /// General-case enums: for each case there is a struct, and they\n+    /// all start with a field for the discriminant.\n+    General {\n+        discr: Integer,\n+        variants: Vec<Struct>,\n+        size: Size,\n+        align: Align\n+    },\n+\n+    /// Two cases distinguished by a nullable pointer: the case with discriminant\n+    /// `nndiscr` must have single field which is known to be nonnull due to its type.\n+    /// The other case is known to be zero sized. Hence we represent the enum\n+    /// as simply a nullable pointer: if not null it indicates the `nndiscr` variant,\n+    /// otherwise it indicates the other case.\n+    ///\n+    /// For example, `std::option::Option` instantiated at a safe pointer type\n+    /// is represented such that `None` is a null pointer and `Some` is the\n+    /// identity function.\n+    RawNullablePointer {\n+        nndiscr: u64,\n+        value: Primitive\n+    },\n+\n+    /// Two cases distinguished by a nullable pointer: the case with discriminant\n+    /// `nndiscr` is represented by the struct `nonnull`, where the `discrfield`th\n+    /// field is known to be nonnull due to its type; if that field is null, then\n+    /// it represents the other case, which is known to be zero sized.\n+    StructWrappedNullablePointer {\n+        nndiscr: u64,\n+        nonnull: Struct,\n+        // N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n+        discrfield: FieldPath\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum LayoutError<'tcx> {\n+    Unknown(Ty<'tcx>),\n+    SizeOverflow(Ty<'tcx>)\n+}\n+\n+impl<'tcx> fmt::Display for LayoutError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            LayoutError::Unknown(ty) => {\n+                write!(f, \"the type `{:?}` has an unknown layout\", ty)\n+            }\n+            LayoutError::SizeOverflow(ty) => {\n+                write!(f, \"the type `{:?}` is too big for the current architecture\", ty)\n+            }\n+        }\n+    }\n+}\n+\n+/// Helper function for normalizing associated types in an inference context.\n+fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       ty: Ty<'tcx>)\n+                                       -> Ty<'tcx> {\n+    if !ty.has_projection_types() {\n+        return ty;\n+    }\n+\n+    let mut selcx = traits::SelectionContext::new(infcx);\n+    let cause = traits::ObligationCause::dummy();\n+    let traits::Normalized { value: result, obligations } =\n+        traits::normalize(&mut selcx, cause, &ty);\n+\n+    let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(infcx, obligation);\n+    }\n+\n+    drain_fulfillment_cx_or_panic(DUMMY_SP, infcx, &mut fulfill_cx, &result)\n+}\n+\n+impl Layout {\n+    pub fn compute_uncached<'a, 'tcx>(ty: Ty<'tcx>,\n+                                      infcx: &InferCtxt<'a, 'tcx>)\n+                                      -> Result<Layout, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx;\n+        let dl = &tcx.data_layout;\n+        assert!(!ty.has_infer_types());\n+\n+        let layout = match ty.sty {\n+            // Basic scalars.\n+            ty::TyBool => Scalar { value: Int(I1), non_zero: false },\n+            ty::TyChar => Scalar { value: Int(I32), non_zero: false },\n+            ty::TyInt(ity) => {\n+                Scalar {\n+                    value: Int(Integer::from_attr(dl, attr::SignedInt(ity))),\n+                    non_zero: false\n+                }\n+            }\n+            ty::TyUint(ity) => {\n+                Scalar {\n+                    value: Int(Integer::from_attr(dl, attr::UnsignedInt(ity))),\n+                    non_zero: false\n+                }\n+            }\n+            ty::TyFloat(FloatTy::F32) => Scalar { value: F32, non_zero: false },\n+            ty::TyFloat(FloatTy::F64) => Scalar { value: F64, non_zero: false },\n+            ty::TyFnPtr(_) => Scalar { value: Pointer, non_zero: true },\n+\n+            // Potentially-fat pointers.\n+            ty::TyBox(pointee) |\n+            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                let non_zero = !ty.is_unsafe_ptr();\n+                if pointee.is_sized(&infcx.parameter_environment, DUMMY_SP) {\n+                    Scalar { value: Pointer, non_zero: non_zero }\n+                } else {\n+                    let unsized_part = tcx.struct_tail(pointee);\n+                    let meta = match unsized_part.sty {\n+                        ty::TySlice(_) | ty::TyStr => {\n+                            Int(dl.ptr_sized_integer())\n+                        }\n+                        ty::TyTrait(_) => Pointer,\n+                        _ => return Err(LayoutError::Unknown(unsized_part))\n+                    };\n+                    FatPointer { metadata: meta, non_zero: non_zero }\n+                }\n+            }\n+\n+            // Arrays and slices.\n+            ty::TyArray(element, count) => {\n+                let element = element.layout(infcx)?;\n+                Array {\n+                    sized: true,\n+                    align: element.align(dl),\n+                    size: element.size(dl).checked_mul(count as u64, dl)\n+                                 .map_or(Err(LayoutError::SizeOverflow(ty)), Ok)?\n+                }\n+            }\n+            ty::TySlice(element) => {\n+                Array {\n+                    sized: false,\n+                    align: element.layout(infcx)?.align(dl),\n+                    size: Size::from_bytes(0)\n+                }\n+            }\n+            ty::TyStr => {\n+                Array {\n+                    sized: false,\n+                    align: dl.i8_align,\n+                    size: Size::from_bytes(0)\n+                }\n+            }\n+\n+            // Odd unit types.\n+            ty::TyFnDef(..) => {\n+                Univariant {\n+                    variant: Struct::new(dl, false),\n+                    non_zero: false\n+                }\n+            }\n+            ty::TyTrait(_) => {\n+                let mut unit = Struct::new(dl, false);\n+                unit.sized = false;\n+                Univariant { variant: unit, non_zero: false }\n+            }\n+\n+            // Tuples.\n+            ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) |\n+            ty::TyTuple(ref tys) => {\n+                let mut st = Struct::new(dl, false);\n+                st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;\n+                Univariant { variant: st, non_zero: false }\n+            }\n+\n+            // ADTs.\n+            ty::TyStruct(def, substs) => {\n+                if ty.is_simd() {\n+                    // SIMD vector types.\n+                    let element = ty.simd_type(tcx);\n+                    match *element.layout(infcx)? {\n+                        Scalar { value, .. } => {\n+                            return Ok(Vector {\n+                                element: value,\n+                                count: ty.simd_size(tcx) as u64\n+                            });\n+                        }\n+                        _ => {\n+                            tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                                     a non-machine element type `{}`\",\n+                                                    ty, element));\n+                        }\n+                    }\n+                }\n+                let fields = def.struct_variant().fields.iter().map(|field| {\n+                    normalize_associated_type(infcx, field.ty(tcx, substs))\n+                        .layout(infcx)\n+                });\n+                let packed = tcx.lookup_packed(def.did);\n+                let mut st = Struct::new(dl, packed);\n+                st.extend(dl, fields, ty)?;\n+\n+                // FIXME(16758) don't add a drop flag to unsized structs, as it\n+                // won't actually be in the location we say it is because it'll be after\n+                // the unsized field. Several other pieces of code assume that the unsized\n+                // field is definitely the last one.\n+                if def.dtor_kind().has_drop_flag() &&\n+                   ty.is_sized(&infcx.parameter_environment, DUMMY_SP) {\n+                    st.extend(dl, Some(Ok(&Scalar {\n+                        value: Int(I8),\n+                        non_zero: false\n+                    })).into_iter(), ty)?;\n+                }\n+                Univariant {\n+                    variant: st,\n+                    non_zero: Some(def.did) == tcx.lang_items.non_zero()\n+                }\n+            }\n+            ty::TyEnum(def, substs) => {\n+                let hint = *tcx.lookup_repr_hints(def.did).get(0)\n+                    .unwrap_or(&attr::ReprAny);\n+\n+                let dtor = def.dtor_kind().has_drop_flag();\n+                let drop_flag = if dtor {\n+                    Some(Scalar { value: Int(I8), non_zero: false })\n+                } else {\n+                    None\n+                };\n+\n+                if def.variants.is_empty() {\n+                    // Uninhabitable; represent as unit\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert_eq!(hint, attr::ReprAny);\n+\n+                    let mut st = Struct::new(dl, false);\n+                    st.extend(dl, drop_flag.iter().map(Ok), ty)?;\n+                    return Ok(Univariant { variant: st, non_zero: false });\n+                }\n+\n+                if !dtor && def.variants.iter().all(|v| v.fields.is_empty()) {\n+                    // All bodies empty -> intlike\n+                    let (mut min, mut max) = (i64::MAX, i64::MIN);\n+                    for v in &def.variants {\n+                        let x = v.disr_val.to_u64_unchecked() as i64;\n+                        if x < min { min = x; }\n+                        if x > max { max = x; }\n+                    }\n+\n+                    let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n+                    return Ok(CEnum {\n+                        discr: discr,\n+                        signed: signed,\n+                        min: min as u64,\n+                        max: max as u64\n+                    });\n+                }\n+\n+                // Since there's at least one\n+                // non-empty body, explicit discriminants should have\n+                // been rejected by a checker before this point.\n+                for (i, v) in def.variants.iter().enumerate() {\n+                    if i as u64 != v.disr_val.to_u64_unchecked() {\n+                        bug!(\"non-C-like enum {} with specified discriminants\",\n+                             tcx.item_path_str(def.did));\n+                    }\n+                }\n+\n+                if def.variants.len() == 1 {\n+                    // Equivalent to a struct/tuple/newtype.\n+                    // (Typechecking will reject discriminant-sizing attrs.)\n+                    assert_eq!(hint, attr::ReprAny);\n+                    let fields = def.variants[0].fields.iter().map(|field| {\n+                        normalize_associated_type(infcx, field.ty(tcx, substs))\n+                            .layout(infcx)\n+                    });\n+                    let mut st = Struct::new(dl, false);\n+                    st.extend(dl, fields.chain(drop_flag.iter().map(Ok)), ty)?;\n+                    return Ok(Univariant { variant: st, non_zero: false });\n+                }\n+\n+                // Cache the substituted and normalized variant field types.\n+                let variants = def.variants.iter().map(|v| {\n+                    v.fields.iter().map(|field| {\n+                        normalize_associated_type(infcx, field.ty(tcx, substs))\n+                    }).collect::<Vec<_>>()\n+                }).collect::<Vec<_>>();\n+\n+                if !dtor && variants.len() == 2 && hint == attr::ReprAny {\n+                    // Nullable pointer optimization\n+                    for discr in 0..2 {\n+                        let other_fields = variants[1 - discr].iter().map(|ty| {\n+                            ty.layout(infcx)\n+                        });\n+                        if !Struct::would_be_zero_sized(dl, other_fields)? {\n+                            continue;\n+                        }\n+                        let path = Struct::non_zero_field_path(infcx,\n+                            variants[discr].iter().cloned())?;\n+                        let mut path = if let Some(p) = path { p } else { continue };\n+\n+                        // FIXME(eddyb) should take advantage of a newtype.\n+                        if path == &[0] && variants[discr].len() == 1 {\n+                            match *variants[discr][0].layout(infcx)? {\n+                                Scalar { value, .. } => {\n+                                    return Ok(RawNullablePointer {\n+                                        nndiscr: discr as u64,\n+                                        value: value\n+                                    });\n+                                }\n+                                _ => {\n+                                    bug!(\"Layout::compute: `{}`'s non-zero \\\n+                                          `{}` field not scalar?!\",\n+                                         ty, variants[discr][0])\n+                                }\n+                            }\n+                        }\n+\n+                        path.push(0); // For GEP through a pointer.\n+                        path.reverse();\n+                        let mut st = Struct::new(dl, false);\n+                        st.extend(dl, variants[discr].iter().map(|ty| {\n+                            ty.layout(infcx)\n+                        }), ty)?;\n+                        return Ok(StructWrappedNullablePointer {\n+                            nndiscr: discr as u64,\n+                            nonnull: st,\n+                            discrfield: path\n+                        });\n+                    }\n+                }\n+\n+                // The general case.\n+                let discr_max = (variants.len() - 1) as i64;\n+                assert!(discr_max >= 0);\n+                let (min_ity, _) = Integer::repr_discr(tcx, hint, 0, discr_max);\n+\n+                let mut align = dl.aggregate_align;\n+                let mut size = Size::from_bytes(0);\n+\n+                // We're interested in the smallest alignment, so start large.\n+                let mut start_align = Align::from_bytes(256, 256).unwrap();\n+\n+                // Create the set of structs that represent each variant\n+                // Use the minimum integer type we figured out above\n+                let discr = Some(Scalar { value: Int(min_ity), non_zero: false });\n+                let mut variants = variants.into_iter().map(|fields| {\n+                    let mut found_start = false;\n+                    let fields = fields.into_iter().map(|field| {\n+                        let field = field.layout(infcx)?;\n+                        if !found_start {\n+                            // Find the first field we can't move later\n+                            // to make room for a larger discriminant.\n+                            let field_align = field.align(dl);\n+                            if field.size(dl).bytes() != 0 || field_align.abi() != 1 {\n+                                start_align = start_align.min(field_align);\n+                                found_start = true;\n+                            }\n+                        }\n+                        Ok(field)\n+                    });\n+                    let mut st = Struct::new(dl, false);\n+                    st.extend(dl, discr.iter().map(Ok).chain(fields)\n+                                              .chain(drop_flag.iter().map(Ok)), ty)?;\n+                    size = cmp::max(size, st.min_size());\n+                    align = align.max(st.align);\n+                    Ok(st)\n+                }).collect::<Result<Vec<_>, _>>()?;\n+\n+                // Align the maximum variant size to the largest alignment.\n+                size = size.abi_align(align);\n+\n+                if size.bytes() >= dl.obj_size_bound() {\n+                    return Err(LayoutError::SizeOverflow(ty));\n+                }\n+\n+                // Check to see if we should use a different type for the\n+                // discriminant. We can safely use a type with the same size\n+                // as the alignment of the first field of each variant.\n+                // We increase the size of the discriminant to avoid LLVM copying\n+                // padding when it doesn't need to. This normally causes unaligned\n+                // load/stores and excessive memcpy/memset operations. By using a\n+                // bigger integer size, LLVM can be sure about it's contents and\n+                // won't be so conservative.\n+\n+                // Use the initial field alignment\n+                let wanted = start_align.abi();\n+                let mut ity = min_ity;\n+                for &candidate in &[I16, I32, I64] {\n+                    let ty = Int(candidate);\n+                    if wanted == ty.align(dl).abi() && wanted == ty.size(dl).bytes() {\n+                        ity = candidate;\n+                        break;\n+                    }\n+                }\n+\n+                // FIXME(eddyb) conservative only to avoid diverging from trans::adt.\n+                if align.abi() != start_align.abi() {\n+                    ity = min_ity;\n+                }\n+\n+                // If the alignment is not larger than the chosen discriminant size,\n+                // don't use the alignment as the final size.\n+                if ity <= min_ity {\n+                    ity = min_ity;\n+                } else {\n+                    // Patch up the variants' first few fields.\n+                    let old_ity_size = Int(min_ity).size(dl);\n+                    let new_ity_size = Int(ity).size(dl);\n+                    for variant in &mut variants {\n+                        for offset in &mut variant.offset_after_field {\n+                            if *offset > old_ity_size {\n+                                break;\n+                            }\n+                            *offset = new_ity_size;\n+                        }\n+                    }\n+                }\n+\n+                General {\n+                    discr: ity,\n+                    variants: variants,\n+                    size: size,\n+                    align: align\n+                }\n+            }\n+\n+            // Types with no meaningful known layout.\n+            ty::TyProjection(_) | ty::TyParam(_) => {\n+                return Err(LayoutError::Unknown(ty));\n+            }\n+            ty::TyInfer(_) | ty::TyError => {\n+                bug!(\"Layout::compute: unexpected type `{}`\", ty)\n+            }\n+        };\n+\n+        Ok(layout)\n+    }\n+\n+    /// Returns true if the layout corresponds to an unsized type.\n+    pub fn is_unsized(&self) -> bool {\n+        match *self {\n+            Scalar {..} | Vector {..} | FatPointer {..} |\n+            CEnum {..} | General {..} |\n+            RawNullablePointer {..} |\n+            StructWrappedNullablePointer {..} => false,\n+\n+            Array { sized, .. } |\n+            Univariant { variant: Struct { sized, .. }, .. } => !sized\n+        }\n+    }\n+\n+    pub fn size(&self, dl: &TargetDataLayout) -> Size {\n+        match *self {\n+            Scalar { value, .. } | RawNullablePointer { value, .. } => {\n+                value.size(dl)\n+            }\n+\n+            Vector { element, count } => {\n+                let elem_size = element.size(dl);\n+                let vec_size = match elem_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n+                                 self, elem_size.bytes(), count)\n+                };\n+                vec_size.abi_align(self.align(dl))\n+            }\n+\n+            FatPointer { metadata, .. } => {\n+                // Effectively a (ptr, meta) tuple.\n+                Pointer.size(dl).abi_align(metadata.align(dl))\n+                       .checked_add(metadata.size(dl), dl).unwrap()\n+                       .abi_align(self.align(dl))\n+            }\n+\n+            CEnum { discr, .. } => Int(discr).size(dl),\n+            Array { size, .. } | General { size, .. } => size,\n+\n+            Univariant { ref variant, .. } |\n+            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+                variant.stride()\n+            }\n+        }\n+    }\n+\n+    pub fn align(&self, dl: &TargetDataLayout) -> Align {\n+        match *self {\n+            Scalar { value, .. } | RawNullablePointer { value, .. } => {\n+                value.align(dl)\n+            }\n+\n+            Vector { element, count } => {\n+                let elem_size = element.size(dl);\n+                let vec_size = match elem_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::align({:?}): {} * {} overflowed\",\n+                                 self, elem_size.bytes(), count)\n+                };\n+                for &(size, align) in &dl.vector_align {\n+                    if size == vec_size {\n+                        return align;\n+                    }\n+                }\n+                // Default to natural alignment, which is what LLVM does.\n+                // That is, use the size, rounded up to a power of 2.\n+                let align = vec_size.bytes().next_power_of_two();\n+                Align::from_bytes(align, align).unwrap()\n+            }\n+\n+            FatPointer { metadata, .. } => {\n+                // Effectively a (ptr, meta) tuple.\n+                Pointer.align(dl).max(metadata.align(dl))\n+            }\n+\n+            CEnum { discr, .. } => Int(discr).align(dl),\n+            Array { align, .. } | General { align, .. } => align,\n+\n+            Univariant { ref variant, .. } |\n+            StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n+                variant.align\n+            }\n+        }\n+    }\n+}\n+\n+/// Type size \"skeleton\", i.e. the only information determining a type's size.\n+/// While this is conservative, (aside from constant sizes, only pointers,\n+/// newtypes thereof and null pointer optimized enums are allowed), it is\n+/// enough to statically check common usecases of transmute.\n+#[derive(Copy, Clone, Debug)]\n+pub enum SizeSkeleton<'tcx> {\n+    /// Any statically computable Layout.\n+    Known(Size),\n+\n+    /// A potentially-fat pointer.\n+    Pointer {\n+        // If true, this pointer is never null.\n+        non_zero: bool,\n+        // The type which determines the unsized metadata, if any,\n+        // of this pointer. Either a type parameter or a projection\n+        // depending on one, with regions erased.\n+        tail: Ty<'tcx>\n+    }\n+}\n+\n+impl<'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute<'a>(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n+                       -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx;\n+        assert!(!ty.has_infer_types());\n+\n+        // First try computing a static layout.\n+        let err = match ty.layout(infcx) {\n+            Ok(layout) => {\n+                return Ok(SizeSkeleton::Known(layout.size(&tcx.data_layout)));\n+            }\n+            Err(err) => err\n+        };\n+\n+        match ty.sty {\n+            ty::TyBox(pointee) |\n+            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                let non_zero = !ty.is_unsafe_ptr();\n+                let tail = tcx.struct_tail(pointee);\n+                match tail.sty {\n+                    ty::TyParam(_) | ty::TyProjection(_) => {\n+                        assert!(tail.has_param_types() || tail.has_self_ty());\n+                        Ok(SizeSkeleton::Pointer {\n+                            non_zero: non_zero,\n+                            tail: tcx.erase_regions(&tail)\n+                        })\n+                    }\n+                    _ => {\n+                        bug!(\"SizeSkeleton::compute({}): layout errored ({}), yet \\\n+                              tail `{}` is not a type parameter or a projection\",\n+                             ty, err, tail)\n+                    }\n+                }\n+            }\n+\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                // Only newtypes and enums w/ nullable pointer optimization.\n+                if def.variants.is_empty() || def.variants.len() > 2 {\n+                    return Err(err);\n+                }\n+\n+                // If there's a drop flag, it can't be just a pointer.\n+                if def.dtor_kind().has_drop_flag() {\n+                    return Err(err);\n+                }\n+\n+                // Get a zero-sized variant or a pointer newtype.\n+                let zero_or_ptr_variant = |i: usize| {\n+                    let fields = def.variants[i].fields.iter().map(|field| {\n+                        let ty = normalize_associated_type(infcx, &field.ty(tcx, substs));\n+                        SizeSkeleton::compute(ty, infcx)\n+                    });\n+                    let mut ptr = None;\n+                    for field in fields {\n+                        let field = field?;\n+                        match field {\n+                            SizeSkeleton::Known(size) => {\n+                                if size.bytes() > 0 {\n+                                    return Err(err);\n+                                }\n+                            }\n+                            SizeSkeleton::Pointer {..} => {\n+                                if ptr.is_some() {\n+                                    return Err(err);\n+                                }\n+                                ptr = Some(field);\n+                            }\n+                        }\n+                    }\n+                    Ok(ptr)\n+                };\n+\n+                let v0 = zero_or_ptr_variant(0)?;\n+                // Newtype.\n+                if def.variants.len() == 1 {\n+                    if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n+                        return Ok(SizeSkeleton::Pointer {\n+                            non_zero: non_zero ||\n+                                Some(def.did) == tcx.lang_items.non_zero(),\n+                            tail: tail\n+                        });\n+                    } else {\n+                        return Err(err);\n+                    }\n+                }\n+\n+                let v1 = zero_or_ptr_variant(1)?;\n+                // Nullable pointer enum optimization.\n+                match (v0, v1) {\n+                    (Some(SizeSkeleton::Pointer { non_zero: true, tail }), None) |\n+                    (None, Some(SizeSkeleton::Pointer { non_zero: true, tail })) => {\n+                        Ok(SizeSkeleton::Pointer {\n+                            non_zero: false,\n+                            tail: tail\n+                        })\n+                    }\n+                    _ => Err(err)\n+                }\n+            }\n+\n+            _ => Err(err)\n+        }\n+    }\n+\n+    pub fn same_size(self, other: SizeSkeleton) -> bool {\n+        match (self, other) {\n+            (SizeSkeleton::Known(a), SizeSkeleton::Known(b)) => a == b,\n+            (SizeSkeleton::Pointer { tail: a, .. },\n+             SizeSkeleton::Pointer { tail: b, .. }) => a == b,\n+            _ => false\n+        }\n+    }\n+}"}, {"sha": "238856197feedf9b07e7f7c20091cc780cad9f8e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -84,6 +84,7 @@ pub mod error;\n pub mod fast_reject;\n pub mod fold;\n pub mod item_path;\n+pub mod layout;\n pub mod _match;\n pub mod maps;\n pub mod outlives;\n@@ -479,37 +480,6 @@ pub struct CReaderCacheKey {\n     pub pos: usize,\n }\n \n-/// A restriction that certain types must be the same size. The use of\n-/// `transmute` gives rise to these restrictions. These generally\n-/// cannot be checked until trans; therefore, each call to `transmute`\n-/// will push one or more such restriction into the\n-/// `transmute_restrictions` vector during `intrinsicck`. They are\n-/// then checked during `trans` by the fn `check_intrinsics`.\n-#[derive(Copy, Clone)]\n-pub struct TransmuteRestriction<'tcx> {\n-    /// The span whence the restriction comes.\n-    pub span: Span,\n-\n-    /// The type being transmuted from.\n-    pub original_from: Ty<'tcx>,\n-\n-    /// The type being transmuted to.\n-    pub original_to: Ty<'tcx>,\n-\n-    /// The type being transmuted from, with all type parameters\n-    /// substituted for an arbitrary representative. Not to be shown\n-    /// to the end user.\n-    pub substituted_from: Ty<'tcx>,\n-\n-    /// The type being transmuted to, with all type parameters\n-    /// substituted for an arbitrary representative. Not to be shown\n-    /// to the end user.\n-    pub substituted_to: Ty<'tcx>,\n-\n-    /// NodeId of the transmute intrinsic.\n-    pub id: NodeId,\n-}\n-\n /// Describes the fragment-state associated with a NodeId.\n ///\n /// Currently only unfragmented paths have entries in the table,"}, {"sha": "2e4f37f1cc1d46901fa49fc38f957fad24dc8d83", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ use hir::pat_util;\n use traits::{self, ProjectionMode};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n+use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n@@ -597,6 +598,24 @@ impl<'tcx> ty::TyS<'tcx> {\n         result\n     }\n \n+    #[inline]\n+    pub fn layout<'a>(&'tcx self, infcx: &infer::InferCtxt<'a, 'tcx>)\n+                      -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+        let can_cache = !self.has_param_types() && !self.has_self_ty();\n+        if can_cache {\n+            if let Some(&cached) = infcx.tcx.layout_cache.borrow().get(&self) {\n+                return Ok(cached);\n+            }\n+        }\n+\n+        let layout = Layout::compute_uncached(self, infcx)?;\n+        let layout = infcx.tcx.intern_layout(layout);\n+        if can_cache {\n+            infcx.tcx.layout_cache.borrow_mut().insert(self, layout);\n+        }\n+        Ok(layout)\n+    }\n+\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums."}, {"sha": "2f0a043f9a7de907158e28a1bb7a617659b94ef2", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"arm64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "c4212e702129cb93fe36c9dc8393722f90823855", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n         llvm_target: \"aarch64-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "3bf4e92fb6aab134e4a71fee62f1005cddd22878", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -17,6 +17,7 @@ pub fn target() -> Target {\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_env: \"gnu\".to_string(),\n+        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_vendor: \"unknown\".to_string(),"}, {"sha": "0a61b14763476f72f5389c8b300338a211fa5fb1", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "0cb0949d4622fa7066adc8f3820fdbac4c6bdf9d", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnueabi\".to_string(),"}, {"sha": "05b9401a0635c99d1337c8092b6f45924bd2e1e3", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnueabihf\".to_string(),"}, {"sha": "d131f8b2ef002b9e405ba7555e1b530f271058f4", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"armv7-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-p:32:32-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "9c9bb72f76cfdecfd43c6d1536e7ecde98a3052e", "filename": "src/librustc_back/target/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"armv7-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnueabihf\".to_string(),"}, {"sha": "d317589bf3680fc2075b8960daaef5d54eb76df0", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"armv7s-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-p:32:32-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "546f9df605b30f49ab82ccc56a6bc869d3eb27da", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -31,6 +31,7 @@ pub fn target() -> Target {\n         target_os: \"emscripten\".to_string(),\n         target_env: \"\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n+        data_layout: \"e-p:32:32-i64:64-v128:32:128-n32-S128\".to_string(),\n         arch: \"asmjs\".to_string(),\n         options: opts,\n     }"}, {"sha": "d149d4bbdc2d6e51e045923703eeb975970303bf", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-p:32:32-f64:32:64-f80:128-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "b6e2f4d8e8ac9bf2f2b7f1d548e42e2f5dde27d1", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:o-p:32:32-f64:32:64-f80:128-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"macos\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "b338a971ff74cb730645e9fe54dff480ceee30b1", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "48203cc74d6a1df74673d1cf94c6ef61b4032129", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"windows\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "501219ad607cf6be9bf7533e19335bab1d442fbe", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -27,6 +27,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:x-p:32:32-i64:64-f80:32-n8:16:32-a:0:32-S32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"windows\".to_string(),\n         target_env: \"msvc\".to_string(),"}, {"sha": "cdbbd5eafddbb7239c67cf3541d4e6fec797be2b", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "fadedc24149c7cf73dacd5a692989d358c149afe", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"freebsd\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "a1f3ab769070f99600bbbad2ee7c21126b753ecc", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "cce023b843016474deb4999c3a1b2a0e08747bfc", "filename": "src/librustc_back/target/i686_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -37,6 +37,7 @@ pub fn target() -> Target {\n         llvm_target: \"i686-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"musl\".to_string(),"}, {"sha": "472b73302a358e15dc75a35a821bd1b7650cecbf", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -34,6 +34,7 @@ pub fn target() -> Target {\n         target_os: \"nacl\".to_string(),\n         target_env: \"newlib\".to_string(),\n         target_vendor: \"unknown\".to_string(),\n+        data_layout: \"e-i64:64:64-p:32:32:32-v128:32:32\".to_string(),\n         arch: \"le32\".to_string(),\n         options: opts,\n     }"}, {"sha": "863f5ceab0ae09c8a4e5146e230eccb58c578364", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n         llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "ac0fde5449ff4eb889d55f883918e64d836b8417", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n         llvm_target: \"mips-unknown-linux-musl\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"musl\".to_string(),"}, {"sha": "ff33effa3e79b708fe9db77025d0494d6fde351a", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n         llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "d9fb14050365de27860e83759321d4417036f69d", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,6 +15,7 @@ pub fn target() -> Target {\n         llvm_target: \"mipsel-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"musl\".to_string(),"}, {"sha": "3f75201aad2cc1422e67910f93faabea63ed508c", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -39,10 +39,10 @@\n //! this module defines the format the JSON file should take, though each\n //! underscore in the field names should be replaced with a hyphen (`-`) in the\n //! JSON file. Some fields are required in every target specification, such as\n-//! `llvm-target`, `target-endian`, `target-pointer-width`, `arch`, and\n-//! `os`. In general, options passed to rustc with `-C` override the target's\n-//! settings, though `target-feature` and `link-args` will *add* to the list\n-//! specified by the target, rather than replace.\n+//! `llvm-target`, `target-endian`, `target-pointer-width`, `data-layout`,\n+//! `arch`, and `os`. In general, options passed to rustc with `-C` override\n+//! the target's settings, though `target-feature` and `link-args` will *add*\n+//! to the list specified by the target, rather than replace.\n \n use serialize::json::Json;\n use std::default::Default;\n@@ -75,7 +75,8 @@ macro_rules! supported_targets {\n             if false { }\n             $(\n                 else if target == stringify!($module) {\n-                    let t = $module::target();\n+                    let mut t = $module::target();\n+                    t.options.is_builtin = true;\n                     debug!(\"Got builtin target: {:?}\", t);\n                     return Some(t);\n                 }\n@@ -161,6 +162,8 @@ pub struct Target {\n     /// Architecture to use for ABI considerations. Valid options: \"x86\",\n     /// \"x86_64\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", and \"powerpc64\".\n     pub arch: String,\n+    /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.\n+    pub data_layout: String,\n     /// Optional settings with defaults.\n     pub options: TargetOptions,\n }\n@@ -171,8 +174,9 @@ pub struct Target {\n /// these try to take \"minimal defaults\" that don't assume anything about the runtime they run in.\n #[derive(Clone, Debug)]\n pub struct TargetOptions {\n-    /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.\n-    pub data_layout: Option<String>,\n+    /// Whether the target is built-in or loaded from a custom target specification.\n+    pub is_builtin: bool,\n+\n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,\n     /// Archive utility to use when managing archives. Defaults to \"ar\".\n@@ -293,7 +297,7 @@ impl Default for TargetOptions {\n     /// incomplete, and if used for compilation, will certainly not work.\n     fn default() -> TargetOptions {\n         TargetOptions {\n-            data_layout: None,\n+            is_builtin: false,\n             linker: option_env!(\"CFG_DEFAULT_LINKER\").unwrap_or(\"cc\").to_string(),\n             ar: option_env!(\"CFG_DEFAULT_AR\").unwrap_or(\"ar\").to_string(),\n             pre_link_args: Vec::new(),\n@@ -378,6 +382,7 @@ impl Target {\n             llvm_target: get_req_field(\"llvm-target\"),\n             target_endian: get_req_field(\"target-endian\"),\n             target_pointer_width: get_req_field(\"target-pointer-width\"),\n+            data_layout: get_req_field(\"data-layout\"),\n             arch: get_req_field(\"arch\"),\n             target_os: get_req_field(\"os\"),\n             target_env: get_opt_field(\"env\", \"\"),\n@@ -426,7 +431,6 @@ impl Target {\n         key!(staticlib_prefix);\n         key!(staticlib_suffix);\n         key!(features);\n-        key!(data_layout, optional);\n         key!(dynamic_linking, bool);\n         key!(executables, bool);\n         key!(disable_redzone, bool);"}, {"sha": "fe7daaec1cdebac8445e54865832263b6cb9bfad", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"powerpc64-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "4aab2b1802c9871fef58a8b3ecfe1ded2aba8a80", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"powerpc64le-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-n32:64\".to_string(),\n         arch: \"powerpc64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "1df36442c06884bf205311b2965fb619bcb72325", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"powerpc-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-p:32:32-i64:64-n32\".to_string(),\n         arch: \"powerpc\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "c8b5dd0eccc5cfe19741bc6eccbcf1d8f1c90a73", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -20,6 +20,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"macos\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "d038e88f2b4fd780fb7a1064c8e697e3823cfe13", "filename": "src/librustc_back/target/x86_64_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_ios.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -16,6 +16,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"ios\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "f0a09ae71efeb7c3b02d67666473b080479b76f4", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"windows\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "b3fbd6ef05170a04c5810fa841940c7c8aabd299", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:w-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"windows\".to_string(),\n         target_env: \"msvc\".to_string(),"}, {"sha": "652159d10fda2edf6e2cdcfe894389ec99ca2803", "filename": "src/librustc_back/target/x86_64_rumprun_netbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_rumprun_netbsd.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -27,6 +27,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-rumprun-netbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"netbsd\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "5aa08ea9c8ca9fa3a067727f062bca3b845395b8", "filename": "src/librustc_back/target/x86_64_sun_solaris.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_sun_solaris.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-pc-solaris\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"solaris\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "e8b95ed80d9e65d2f74c404db81b56ee0c0e8769", "filename": "src/librustc_back/target/x86_64_unknown_bitrig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_bitrig.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-bitrig\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"bitrig\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "3fa46c31a5eb19ed618a6a613fefe8865e0e2e97", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "d345a32179423e691feb9c824cbc96b4a2400035", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"freebsd\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "69e333a135002239b2ee85c472dc4ff39033696e", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "622a1fe8baf14b242d5abf551c65c451aad219a9", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -73,6 +73,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"musl\".to_string(),"}, {"sha": "74bf71891199a4da9d33748f31323233ce9ca100", "filename": "src/librustc_back/target/x86_64_unknown_netbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_netbsd.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -18,6 +18,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-netbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"netbsd\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "521de5373d0b16267ad135153df159e7d62a1d75", "filename": "src/librustc_back/target/x86_64_unknown_openbsd.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_openbsd.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -19,6 +19,7 @@ pub fn target() -> Target {\n         llvm_target: \"x86_64-unknown-openbsd\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"openbsd\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "9bbe0cb5f69572cc81be487e638ed919d99e18c4", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -32,18 +32,7 @@ use rustc::ty::{self, Ty};\n use libc::c_uint;\n \n pub use syntax::abi::Abi;\n-\n-/// The first half of a fat pointer.\n-/// - For a closure, this is the code address.\n-/// - For an object or trait instance, this is the address of the box.\n-/// - For a slice, this is the base address.\n-pub const FAT_PTR_ADDR: usize = 0;\n-\n-/// The second half of a fat pointer.\n-/// - For a closure, this is the address of the environment.\n-/// - For an object or trait instance, this is the address of the vtable.\n-/// - For a slice, this is the length.\n-pub const FAT_PTR_EXTRA: usize = 1;\n+pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum ArgKind {"}, {"sha": "8052fc21cc70506bea3e7bc5336e2c430e3aa848", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -78,7 +78,6 @@ use declare;\n use expr;\n use glue;\n use inline;\n-use intrinsic;\n use machine;\n use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n@@ -2750,13 +2749,9 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     {\n         let ccx = shared_ccx.get_ccx(0);\n-\n-        // First, verify intrinsics.\n-        intrinsic::check_intrinsics(&ccx);\n-\n         collect_translation_items(&ccx);\n \n-        // Next, translate all items. See `TransModVisitor` for\n+        // Translate all items. See `TransModVisitor` for\n         // details on why we walk in this particular way.\n         {\n             let _icx = push_ctxt(\"text\");"}, {"sha": "1217b2b5a1b17fbddfce4e6405cdc71617db0490", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -36,11 +36,12 @@ use session::Session;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n-use std::ffi::CString;\n+use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n use std::ptr;\n use std::rc::Rc;\n+use std::str;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n@@ -255,15 +256,28 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    if let Some(ref custom_data_layout) = sess.target.target.options.data_layout {\n-        let data_layout = CString::new(&custom_data_layout[..]).unwrap();\n-        llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n-    } else {\n+    // Ensure the data-layout values hardcoded remain the defaults.\n+    if sess.target.target.options.is_builtin {\n         let tm = ::back::write::create_target_machine(sess);\n         llvm::LLVMRustSetDataLayoutFromTargetMachine(llmod, tm);\n         llvm::LLVMRustDisposeTargetMachine(tm);\n+\n+        let data_layout = llvm::LLVMGetDataLayout(llmod);\n+        let data_layout = str::from_utf8(CStr::from_ptr(data_layout).to_bytes())\n+            .ok().expect(\"got a non-UTF8 data-layout from LLVM\");\n+\n+        if sess.target.target.data_layout != data_layout {\n+            bug!(\"data-layout for builtin `{}` target, `{}`, \\\n+                  differs from LLVM default, `{}`\",\n+                 sess.target.target.llvm_target,\n+                 sess.target.target.data_layout,\n+                 data_layout);\n+        }\n     }\n \n+    let data_layout = CString::new(&sess.target.target.data_layout[..]).unwrap();\n+    llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n+\n     let llvm_target = sess.target.target.llvm_target.as_bytes();\n     let llvm_target = CString::new(llvm_target).unwrap();\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n@@ -770,23 +784,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.trait_cache\n     }\n \n-    /// Return exclusive upper bound on object size.\n-    ///\n-    /// The theoretical maximum object size is defined as the maximum positive `int` value. This\n-    /// ensures that the `offset` semantics remain well-defined by allowing it to correctly index\n-    /// every address within an object along with one byte past the end, along with allowing `int`\n-    /// to store the difference between any two pointers into an object.\n-    ///\n-    /// The upper bound on 64-bit currently needs to be lower because LLVM uses a 64-bit integer to\n-    /// represent object size in bits. It would need to be 1 << 61 to account for this, but is\n-    /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n-    /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match &self.sess().target.target.target_pointer_width[..] {\n-            \"32\" => 1 << 31,\n-            \"64\" => 1 << 47,\n-            _ => bug!() // error handled by config::build_target_config\n-        }\n+        self.tcx().data_layout.obj_size_bound()\n     }\n \n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {"}, {"sha": "5e4902cf3caf24108ad1eed7c68b544dd4e4ab2f", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -83,32 +83,6 @@ unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n ```\n \"##,\n \n-E0512: r##\"\n-Transmute with two differently sized types was attempted. Erroneous code\n-example:\n-\n-```compile_fail\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n-    // error: transmute called with differently sized types\n-}\n-```\n-\n-Please use types with same size or use the expected type directly. Example:\n-\n-```\n-fn takes_u8(_: u8) {}\n-\n-fn main() {\n-    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n-    // or:\n-    unsafe { takes_u8(0u8); } // ok!\n-}\n-```\n-\"##,\n-\n E0515: r##\"\n A constant index expression was out of bounds. Erroneous code example:\n "}, {"sha": "1220fbafa29c9ddb6831538f0481affca251f4bb", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -36,16 +36,14 @@ use glue;\n use type_of;\n use machine;\n use type_::Type;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty};\n use Disr;\n use rustc::ty::subst::Substs;\n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::parse::token;\n \n-use rustc::lint;\n use rustc::session::Session;\n use syntax::codemap::{Span, DUMMY_SP};\n \n@@ -97,76 +95,6 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n     Some(ccx.get_intrinsic(&llvm_name))\n }\n \n-pub fn span_transmute_size_error(a: &Session, b: Span, msg: &str) {\n-    span_err!(a, b, E0512, \"{}\", msg);\n-}\n-\n-/// Performs late verification that intrinsics are used correctly. At present,\n-/// the only intrinsic that needs such verification is `transmute`.\n-pub fn check_intrinsics(ccx: &CrateContext) {\n-    let _task = ccx.tcx().dep_graph.in_task(DepNode::IntrinsicUseCheck);\n-    let mut last_failing_id = None;\n-    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n-        // Sometimes, a single call to transmute will push multiple\n-        // type pairs to test in order to exhaustively test the\n-        // possibility around a type parameter. If one of those fails,\n-        // there is no sense reporting errors on the others.\n-        if last_failing_id == Some(transmute_restriction.id) {\n-            continue;\n-        }\n-\n-        debug!(\"transmute_restriction: {:?}\", transmute_restriction);\n-\n-        assert!(!transmute_restriction.substituted_from.has_param_types());\n-        assert!(!transmute_restriction.substituted_to.has_param_types());\n-\n-        let llfromtype = type_of::sizing_type_of(ccx,\n-                                                 transmute_restriction.substituted_from);\n-        let lltotype = type_of::sizing_type_of(ccx,\n-                                               transmute_restriction.substituted_to);\n-        let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n-        let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n-\n-        if let ty::TyFnDef(..) = transmute_restriction.substituted_from.sty {\n-            if to_type_size == machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-                // FIXME #19925 Remove this warning after a release cycle.\n-                lint::raw_emit_lint(&ccx.tcx().sess,\n-                                    &ccx.tcx().sess.lint_store.borrow(),\n-                                    lint::builtin::TRANSMUTE_FROM_FN_ITEM_TYPES,\n-                                    (lint::Warn, lint::LintSource::Default),\n-                                    Some(transmute_restriction.span),\n-                                    &format!(\"`{}` is now zero-sized and has to be cast \\\n-                                              to a pointer before transmuting to `{}`\",\n-                                             transmute_restriction.substituted_from,\n-                                             transmute_restriction.substituted_to));\n-                continue;\n-            }\n-        }\n-        if from_type_size != to_type_size {\n-            last_failing_id = Some(transmute_restriction.id);\n-\n-            if transmute_restriction.original_from != transmute_restriction.substituted_from {\n-                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n-                    &format!(\"transmute called with differently sized types: \\\n-                              {} (could be {} bits) to {} (could be {} bits)\",\n-                             transmute_restriction.original_from,\n-                             from_type_size,\n-                             transmute_restriction.original_to,\n-                             to_type_size));\n-            } else {\n-                span_transmute_size_error(ccx.sess(), transmute_restriction.span,\n-                    &format!(\"transmute called with differently sized types: \\\n-                              {} ({} bits) to {} ({} bits)\",\n-                             transmute_restriction.original_from,\n-                             from_type_size,\n-                             transmute_restriction.original_to,\n-                             to_type_size));\n-            }\n-        }\n-    }\n-    ccx.sess().abort_if_errors();\n-}\n-\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs"}, {"sha": "863ae3f942e937ab5db37f059aedd80e4387cd9c", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -17,6 +17,7 @@ use abi::FnType;\n use adt;\n use common::*;\n use machine;\n+use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TypeFoldable};\n \n use type_::Type;\n@@ -121,6 +122,37 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n \n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n+\n+    // FIXME(eddyb) Temporary sanity check for ty::layout.\n+    let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables, ProjectionMode::Any);\n+    match t.layout(&infcx) {\n+        Ok(layout) => {\n+            if !type_is_sized(cx.tcx(), t) {\n+                if !layout.is_unsized() {\n+                    bug!(\"layout should be unsized for type `{}` / {:#?}\",\n+                         t, layout);\n+                }\n+\n+                // Unsized types get turned into a fat pointer for LLVM.\n+                return llsizingty;\n+            }\n+            let r = layout.size(&cx.tcx().data_layout).bytes();\n+            let l = machine::llsize_of_alloc(cx, llsizingty);\n+            if r != l {\n+                bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+                     r, l, t, layout);\n+            }\n+            let r = layout.align(&cx.tcx().data_layout).abi();\n+            let l = machine::llalign_of_min(cx, llsizingty) as u64;\n+            if r != l {\n+                bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n+                     r, l, t, layout);\n+            }\n+        }\n+        Err(e) => {\n+            bug!(\"failed to get layout for `{}`: {}\", t, e);\n+        }\n+    }\n     llsizingty\n }\n "}, {"sha": "c92a404b71a6fbf38ad9afc5af0a6402985d585b", "filename": "src/test/compile-fail/issue-21174.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21174.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -15,7 +15,7 @@ trait Trait<'a> {\n \n fn foo<'a, T: Trait<'a>>(value: T::A) {\n     let new: T::B = unsafe { std::mem::transmute(value) };\n-//~^ ERROR: cannot transmute to or from a type that contains unsubstituted type parameters [E0139]\n+//~^ ERROR: transmute called with differently sized types\n }\n \n fn main() { }"}, {"sha": "6e8126348da69c6a0e2fe2040b00ba9afeb448fa", "filename": "src/test/compile-fail/issue-32377.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32377.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use std::marker::PhantomData;\n+\n+trait Foo {\n+    type Error;\n+}\n+\n+struct Bar<U: Foo> {\n+    stream: PhantomData<U::Error>,\n+}\n+\n+fn foo<U: Foo>(x: [usize; 2]) -> Bar<U> {\n+    unsafe { mem::transmute(x) }\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n+fn main() {}"}, {"sha": "50bcd53ecb82c55e6777dfc7471ddf535354848b", "filename": "src/test/compile-fail/transmute-from-fn-item-types-error.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-error.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+\n+unsafe fn bar() {\n+    // Error, still, if the resulting type is not pointer-sized.\n+    mem::transmute::<_, u8>(main);\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n+fn main() {\n+    unsafe {\n+        bar();\n+    }\n+}"}, {"sha": "42c3cb7f181319b2badacdb429b49995f693ff09", "filename": "src/test/compile-fail/transmute-from-fn-item-types-lint.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-from-fn-item-types-lint.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -8,39 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(transmute_from_fn_item_types)]\n+\n use std::mem;\n \n unsafe fn foo() -> (isize, *const (), Option<fn()>) {\n     let i = mem::transmute(bar);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     let p = mem::transmute(foo);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     let of = mem::transmute(main);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     (i, p, of)\n }\n \n unsafe fn bar() {\n     mem::transmute::<_, *mut ()>(foo);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     mem::transmute::<_, fn()>(bar);\n-    //~^ WARN is now zero-sized and has to be cast to a pointer before transmuting\n-    //~^^ WARN was previously accepted\n+    //~^ ERROR is now zero-sized and has to be cast to a pointer before transmuting\n+    //~^^ ERROR was previously accepted\n \n     // No error if a coercion would otherwise occur.\n     mem::transmute::<fn(), usize>(main);\n-\n-    // Error, still, if the resulting type is not pointer-sized.\n-    mem::transmute::<_, u8>(main);\n-    //~^ ERROR transmute called with differently sized types\n }\n \n fn main() {"}, {"sha": "b6e7e32663ec122669b3bd2e50cf257f9903afe7", "filename": "src/test/compile-fail/transmute-type-parameters.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -13,23 +13,27 @@\n use std::mem::transmute;\n \n unsafe fn f<T>(x: T) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: T (size can vary) to isize\n }\n \n unsafe fn g<T>(x: (T, isize)) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: (T, isize) (size can vary because of T) to isize\n }\n \n unsafe fn h<T>(x: [T; 10]) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: [T; 10] (size can vary because of T) to isize\n }\n \n struct Bad<T> {\n     f: T,\n }\n \n unsafe fn i<T>(x: Bad<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: Bad<T> (size can vary because of T) to isize\n }\n \n enum Worse<T> {\n@@ -38,11 +42,13 @@ enum Worse<T> {\n }\n \n unsafe fn j<T>(x: Worse<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: Worse<T> (size can vary because of T) to isize\n }\n \n unsafe fn k<T>(x: Option<T>) {\n-    let _: isize = transmute(x);  //~ ERROR cannot transmute\n+    let _: isize = transmute(x);\n+//~^ ERROR differently sized types: std::option::Option<T> (size can vary because of T) to isize\n }\n \n fn main() {}"}, {"sha": "b7083c2776aeccd3f5575be4e55c25dc7222d0f9", "filename": "src/test/run-make/target-specs/my-awesome-platform.json", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/6ece1447f02b2310e5f4c7ef1efd1312476cae80/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftarget-specs%2Fmy-awesome-platform.json?ref=6ece1447f02b2310e5f4c7ef1efd1312476cae80", "patch": "@@ -1,4 +1,5 @@\n {\n+    \"data-layout\": \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\",\n     \"llvm-target\": \"i686-unknown-linux-gnu\",\n     \"target-endian\": \"little\",\n     \"target-pointer-width\": \"32\","}]}