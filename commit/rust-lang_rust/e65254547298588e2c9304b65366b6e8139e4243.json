{"sha": "e65254547298588e2c9304b65366b6e8139e4243", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NTI1NDU0NzI5ODU4OGUyYzkzMDRiNjUzNjZiNmU4MTM5ZTQyNDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-10T10:27:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-10T10:27:55Z"}, "message": "Merge #9830\n\n9830: Enable more assists to generate default trait body impls r=Veykril a=yoshuawuyts\n\nEnable more assists to benefit from trait body generation. Follow-up to #9825 and #9814.\r\n\r\n__edit:__ I'd like to move the existing tests to this new file too, but I'll do that in a follow-up PR.\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "63a26aa7e541bc5d67184163435988eba9e278aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63a26aa7e541bc5d67184163435988eba9e278aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e65254547298588e2c9304b65366b6e8139e4243", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhElSrCRBK7hj4Ov3rIwAABncIAKGDfgJU15qZYZYZxwv+hdnX\nNnpWMExpkhsDKjW/AEHMrr6NyQYwOilBd5jqvGoVFUlj9tZwPLEdwZhUVGsivF64\n0ONSshehEgO3B5DICaM1qlXnO2lOeUJ0OLN7OjVYWt/DMCgWsagpe5HvkBHM70iL\nHsfSVT49k7krkgIDg8z26N6oHgJeEdhCvQeCm0kRr97sLqHVGyS+mgEEM+iS2BSF\nTQOVviti2BYfVqbltR7W8d+cVBb94onlMDFA45tWRNez9NTkHvGwVuzYF89WNNgq\nXJ4pRI30w616yiufZqoB3FTEOtcqrHMB1UYd6oaKHRYLzNe4rVcF3p6cNWXXf6U=\n=S596\n-----END PGP SIGNATURE-----\n", "payload": "tree 63a26aa7e541bc5d67184163435988eba9e278aa\nparent 2bd28c6cd73f5ca48edf932afc4177e845166fa3\nparent 326890753cd146d09d45a330016624c020abdd9e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628591275 +0000\ncommitter GitHub <noreply@github.com> 1628591275 +0000\n\nMerge #9830\n\n9830: Enable more assists to generate default trait body impls r=Veykril a=yoshuawuyts\n\nEnable more assists to benefit from trait body generation. Follow-up to #9825 and #9814.\r\n\r\n__edit:__ I'd like to move the existing tests to this new file too, but I'll do that in a follow-up PR.\n\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e65254547298588e2c9304b65366b6e8139e4243", "html_url": "https://github.com/rust-lang/rust/commit/e65254547298588e2c9304b65366b6e8139e4243", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e65254547298588e2c9304b65366b6e8139e4243/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd28c6cd73f5ca48edf932afc4177e845166fa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd28c6cd73f5ca48edf932afc4177e845166fa3", "html_url": "https://github.com/rust-lang/rust/commit/2bd28c6cd73f5ca48edf932afc4177e845166fa3"}, {"sha": "326890753cd146d09d45a330016624c020abdd9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/326890753cd146d09d45a330016624c020abdd9e", "html_url": "https://github.com/rust-lang/rust/commit/326890753cd146d09d45a330016624c020abdd9e"}], "stats": {"total": 387, "additions": 226, "deletions": 161}, "files": [{"sha": "3a014545138b6b95084db84af60b201ce2ccb813", "filename": "crates/hir/src/has_source.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -10,8 +10,8 @@ use hir_expand::InFile;\n use syntax::ast;\n \n use crate::{\n-    db::HirDatabase, Const, ConstParam, Enum, Field, FieldSource, Function, Impl, LifetimeParam,\n-    MacroDef, Module, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    db::HirDatabase, Adt, Const, ConstParam, Enum, Field, FieldSource, Function, Impl,\n+    LifetimeParam, MacroDef, Module, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n };\n \n pub trait HasSource {\n@@ -56,6 +56,16 @@ impl HasSource for Field {\n         Some(field_source)\n     }\n }\n+impl HasSource for Adt {\n+    type Ast = ast::Adt;\n+    fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {\n+        match self {\n+            Adt::Struct(s) => Some(s.source(db)?.map(|s| ast::Adt::Struct(s))),\n+            Adt::Union(u) => Some(u.source(db)?.map(|u| ast::Adt::Union(u))),\n+            Adt::Enum(e) => Some(e.source(db)?.map(|e| ast::Adt::Enum(e))),\n+        }\n+    }\n+}\n impl HasSource for Struct {\n     type Ast = ast::Struct;\n     fn source(self, db: &dyn HirDatabase) -> Option<InFile<Self::Ast>> {"}, {"sha": "a145598c791df3dffa727db7b5433dc56cdcf59d", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -1,10 +1,12 @@\n+use hir::HasSource;\n use ide_db::traits::resolve_target_trait;\n-use syntax::ast::{self, AstNode};\n+use syntax::ast::{self, make, AstNode};\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n     utils::{\n-        add_trait_assoc_items_to_impl, filter_assoc_items, render_snippet, Cursor, DefaultMethods,\n+        add_trait_assoc_items_to_impl, filter_assoc_items, gen_trait_fn_body, render_snippet,\n+        Cursor, DefaultMethods,\n     },\n     AssistId, AssistKind,\n };\n@@ -115,18 +117,26 @@ fn add_missing_impl_members_inner(\n     let target = impl_def.syntax().text_range();\n     acc.add(AssistId(assist_id, AssistKind::QuickFix), label, target, |builder| {\n         let target_scope = ctx.sema.scope(impl_def.syntax());\n-        let (new_impl_def, first_new_item) =\n-            add_trait_assoc_items_to_impl(&ctx.sema, missing_items, trait_, impl_def, target_scope);\n+        let (new_impl_def, first_new_item) = add_trait_assoc_items_to_impl(\n+            &ctx.sema,\n+            missing_items,\n+            trait_,\n+            impl_def.clone(),\n+            target_scope,\n+        );\n         match ctx.config.snippet_cap {\n             None => builder.replace(target, new_impl_def.to_string()),\n             Some(cap) => {\n                 let mut cursor = Cursor::Before(first_new_item.syntax());\n                 let placeholder;\n                 if let ast::AssocItem::Fn(func) = &first_new_item {\n-                    if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast) {\n-                        if m.syntax().text() == \"todo!()\" {\n-                            placeholder = m;\n-                            cursor = Cursor::Replace(placeholder.syntax());\n+                    if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n+                        if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)\n+                        {\n+                            if m.syntax().text() == \"todo!()\" {\n+                                placeholder = m;\n+                                cursor = Cursor::Replace(placeholder.syntax());\n+                            }\n                         }\n                     }\n                 }\n@@ -140,6 +150,18 @@ fn add_missing_impl_members_inner(\n     })\n }\n \n+fn try_gen_trait_body(\n+    ctx: &AssistContext,\n+    func: &ast::Fn,\n+    trait_: &hir::Trait,\n+    impl_def: &ast::Impl,\n+) -> Option<()> {\n+    let trait_path = make::ext::ident_path(&trait_.name(ctx.db()).to_string());\n+    let hir_ty = ctx.sema.resolve_type(&impl_def.self_ty()?)?;\n+    let adt = hir_ty.as_adt()?.source(ctx.db())?;\n+    gen_trait_fn_body(func, &trait_path, &adt.value)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -847,4 +869,28 @@ impl T for () {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn test_default_body_generation() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: default\n+struct Foo(usize);\n+\n+impl Default for Foo {\n+    $0\n+}\n+\"#,\n+            r#\"\n+struct Foo(usize);\n+\n+impl Default for Foo {\n+    $0fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "2add705db2e8417a7796efddb2f255edf0c630db", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 3, "deletions": 151, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -2,8 +2,6 @@ use hir::ModuleDef;\n use ide_db::helpers::{import_assets::NameToImport, mod_path_to_ast};\n use ide_db::items_locator;\n use itertools::Itertools;\n-use syntax::ast::edit::AstNodeEdit;\n-use syntax::ted;\n use syntax::{\n     ast::{self, make, AstNode, NameOwner},\n     SyntaxKind::{IDENT, WHITESPACE},\n@@ -12,8 +10,8 @@ use syntax::{\n use crate::{\n     assist_context::{AssistBuilder, AssistContext, Assists},\n     utils::{\n-        add_trait_assoc_items_to_impl, filter_assoc_items, generate_trait_impl_text,\n-        render_snippet, Cursor, DefaultMethods,\n+        add_trait_assoc_items_to_impl, filter_assoc_items, gen_trait_fn_body,\n+        generate_trait_impl_text, render_snippet, Cursor, DefaultMethods,\n     },\n     AssistId, AssistKind,\n };\n@@ -169,158 +167,12 @@ fn impl_def_from_trait(\n \n     // Generate a default `impl` function body for the derived trait.\n     if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-        let _ = gen_trait_body_impl(func, trait_path, adt, annotated_name);\n+        let _ = gen_trait_fn_body(func, trait_path, adt);\n     };\n \n     Some((impl_def, first_assoc_item))\n }\n \n-/// Generate custom trait bodies where possible.\n-///\n-/// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n-/// `None` means that generating a custom trait body failed, and the body will remain\n-/// as `todo!` instead.\n-fn gen_trait_body_impl(\n-    func: &ast::Fn,\n-    trait_path: &ast::Path,\n-    adt: &ast::Adt,\n-    annotated_name: &ast::Name,\n-) -> Option<()> {\n-    match trait_path.segment()?.name_ref()?.text().as_str() {\n-        \"Debug\" => gen_debug_impl(adt, func, annotated_name),\n-        \"Default\" => gen_default_impl(adt, func),\n-        _ => None,\n-    }\n-}\n-\n-/// Generate a `Debug` impl based on the fields and members of the target type.\n-fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) -> Option<()> {\n-    match adt {\n-        // `Debug` cannot be derived for unions, so no default impl can be provided.\n-        ast::Adt::Union(_) => None,\n-\n-        // => match self { Self::Variant => write!(f, \"Variant\") }\n-        ast::Adt::Enum(enum_) => {\n-            let list = enum_.variant_list()?;\n-            let mut arms = vec![];\n-            for variant in list.variants() {\n-                let name = variant.name()?;\n-                let left = make::ext::ident_path(\"Self\");\n-                let right = make::ext::ident_path(&format!(\"{}\", name));\n-                let variant_name = make::path_pat(make::path_concat(left, right));\n-\n-                let target = make::expr_path(make::ext::ident_path(\"f\").into());\n-                let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n-                let args = make::arg_list(vec![target, fmt_string]);\n-                let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n-                let macro_call = make::expr_macro_call(macro_name, args);\n-\n-                arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n-            }\n-\n-            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n-            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n-            let match_expr = make::expr_match(match_target, list);\n-\n-            let body = make::block_expr(None, Some(match_expr));\n-            let body = body.indent(ast::edit::IndentLevel(1));\n-            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n-            Some(())\n-        }\n-\n-        ast::Adt::Struct(strukt) => {\n-            let name = format!(\"\\\"{}\\\"\", annotated_name);\n-            let args = make::arg_list(Some(make::expr_literal(&name).into()));\n-            let target = make::expr_path(make::ext::ident_path(\"f\"));\n-\n-            let expr = match strukt.field_list() {\n-                // => f.debug_struct(\"Name\").finish()\n-                None => make::expr_method_call(target, make::name_ref(\"debug_struct\"), args),\n-\n-                // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n-                Some(ast::FieldList::RecordFieldList(field_list)) => {\n-                    let method = make::name_ref(\"debug_struct\");\n-                    let mut expr = make::expr_method_call(target, method, args);\n-                    for field in field_list.fields() {\n-                        let name = field.name()?;\n-                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n-                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                        let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n-                        let args = make::arg_list(vec![f_name, f_path]);\n-                        expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n-                    }\n-                    expr\n-                }\n-\n-                // => f.debug_tuple(\"Name\").field(self.0).finish()\n-                Some(ast::FieldList::TupleFieldList(field_list)) => {\n-                    let method = make::name_ref(\"debug_tuple\");\n-                    let mut expr = make::expr_method_call(target, method, args);\n-                    for (idx, _) in field_list.fields().enumerate() {\n-                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                        let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n-                        let method = make::name_ref(\"field\");\n-                        expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n-                    }\n-                    expr\n-                }\n-            };\n-\n-            let method = make::name_ref(\"finish\");\n-            let expr = make::expr_method_call(expr, method, make::arg_list(None));\n-            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n-            Some(())\n-        }\n-    }\n-}\n-\n-/// Generate a `Debug` impl based on the fields and members of the target type.\n-fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    fn gen_default_call() -> ast::Expr {\n-        let trait_name = make::ext::ident_path(\"Default\");\n-        let method_name = make::ext::ident_path(\"default\");\n-        let fn_name = make::expr_path(make::path_concat(trait_name, method_name));\n-        make::expr_call(fn_name, make::arg_list(None))\n-    }\n-    match adt {\n-        // `Debug` cannot be derived for unions, so no default impl can be provided.\n-        ast::Adt::Union(_) => None,\n-        // Deriving `Debug` for enums is not stable yet.\n-        ast::Adt::Enum(_) => None,\n-        ast::Adt::Struct(strukt) => {\n-            let expr = match strukt.field_list() {\n-                Some(ast::FieldList::RecordFieldList(field_list)) => {\n-                    let mut fields = vec![];\n-                    for field in field_list.fields() {\n-                        let method_call = gen_default_call();\n-                        let name_ref = make::name_ref(&field.name()?.to_string());\n-                        let field = make::record_expr_field(name_ref, Some(method_call));\n-                        fields.push(field);\n-                    }\n-                    let struct_name = make::ext::ident_path(\"Self\");\n-                    let fields = make::record_expr_field_list(fields);\n-                    make::record_expr(struct_name, fields).into()\n-                }\n-                Some(ast::FieldList::TupleFieldList(field_list)) => {\n-                    let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n-                    let fields = field_list.fields().map(|_| gen_default_call());\n-                    make::expr_call(struct_name, make::arg_list(fields))\n-                }\n-                None => {\n-                    let struct_name = make::ext::ident_path(\"Self\");\n-                    let fields = make::record_expr_field_list(None);\n-                    make::record_expr(struct_name, fields).into()\n-                }\n-            };\n-            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n-            Some(())\n-        }\n-    }\n-}\n fn update_attribute(\n     builder: &mut AssistBuilder,\n     input: &ast::TokenTree,"}, {"sha": "b4b9b6af80d04d79421eb007206c04b08de58c7c", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -1,6 +1,7 @@\n //! Assorted functions shared by several assists.\n \n pub(crate) mod suggest_name;\n+mod gen_trait_fn_body;\n \n use std::ops;\n \n@@ -25,6 +26,8 @@ use syntax::{\n \n use crate::assist_context::{AssistBuilder, AssistContext};\n \n+pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n+\n pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n     extract_trivial_expression(&block)\n         .filter(|expr| !expr.syntax().text().contains_char('\\n'))"}, {"sha": "17e006a7553f33a6a67ffc6714c987aeb34b39bb", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -0,0 +1,153 @@\n+//! This module contains functions to generate default trait impl function bodies where possible.\n+\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit, make, AstNode, NameOwner},\n+    ted,\n+};\n+\n+/// Generate custom trait bodies where possible.\n+///\n+/// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n+/// `None` means that generating a custom trait body failed, and the body will remain\n+/// as `todo!` instead.\n+pub(crate) fn gen_trait_fn_body(\n+    func: &ast::Fn,\n+    trait_path: &ast::Path,\n+    adt: &ast::Adt,\n+) -> Option<()> {\n+    match trait_path.segment()?.name_ref()?.text().as_str() {\n+        \"Debug\" => gen_debug_impl(adt, func),\n+        \"Default\" => gen_default_impl(adt, func),\n+        _ => None,\n+    }\n+}\n+\n+/// Generate a `Debug` impl based on the fields and members of the target type.\n+fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    let annotated_name = adt.name()?;\n+    match adt {\n+        // `Debug` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => None,\n+\n+        // => match self { Self::Variant => write!(f, \"Variant\") }\n+        ast::Adt::Enum(enum_) => {\n+            let list = enum_.variant_list()?;\n+            let mut arms = vec![];\n+            for variant in list.variants() {\n+                let name = variant.name()?;\n+                let left = make::ext::ident_path(\"Self\");\n+                let right = make::ext::ident_path(&format!(\"{}\", name));\n+                let variant_name = make::path_pat(make::path_concat(left, right));\n+\n+                let target = make::expr_path(make::ext::ident_path(\"f\").into());\n+                let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                let args = make::arg_list(vec![target, fmt_string]);\n+                let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n+                let macro_call = make::expr_macro_call(macro_name, args);\n+\n+                arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n+            }\n+\n+            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n+            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+            let match_expr = make::expr_match(match_target, list);\n+\n+            let body = make::block_expr(None, Some(match_expr));\n+            let body = body.indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n+        }\n+\n+        ast::Adt::Struct(strukt) => {\n+            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let args = make::arg_list(Some(make::expr_literal(&name).into()));\n+            let target = make::expr_path(make::ext::ident_path(\"f\"));\n+\n+            let expr = match strukt.field_list() {\n+                // => f.debug_struct(\"Name\").finish()\n+                None => make::expr_method_call(target, make::name_ref(\"debug_struct\"), args),\n+\n+                // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let method = make::name_ref(\"debug_struct\");\n+                    let mut expr = make::expr_method_call(target, method, args);\n+                    for field in field_list.fields() {\n+                        let name = field.name()?;\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let f_path = make::expr_ref(f_path, false);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n+                        let args = make::arg_list(vec![f_name, f_path]);\n+                        expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n+                    }\n+                    expr\n+                }\n+\n+                // => f.debug_tuple(\"Name\").field(self.0).finish()\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let method = make::name_ref(\"debug_tuple\");\n+                    let mut expr = make::expr_method_call(target, method, args);\n+                    for (idx, _) in field_list.fields().enumerate() {\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let f_path = make::expr_ref(f_path, false);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n+                        let method = make::name_ref(\"field\");\n+                        expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n+                    }\n+                    expr\n+                }\n+            };\n+\n+            let method = make::name_ref(\"finish\");\n+            let expr = make::expr_method_call(expr, method, make::arg_list(None));\n+            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n+        }\n+    }\n+}\n+\n+/// Generate a `Debug` impl based on the fields and members of the target type.\n+fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    fn gen_default_call() -> ast::Expr {\n+        let trait_name = make::ext::ident_path(\"Default\");\n+        let method_name = make::ext::ident_path(\"default\");\n+        let fn_name = make::expr_path(make::path_concat(trait_name, method_name));\n+        make::expr_call(fn_name, make::arg_list(None))\n+    }\n+    match adt {\n+        // `Debug` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => None,\n+        // Deriving `Debug` for enums is not stable yet.\n+        ast::Adt::Enum(_) => None,\n+        ast::Adt::Struct(strukt) => {\n+            let expr = match strukt.field_list() {\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let mut fields = vec![];\n+                    for field in field_list.fields() {\n+                        let method_call = gen_default_call();\n+                        let name_ref = make::name_ref(&field.name()?.to_string());\n+                        let field = make::record_expr_field(name_ref, Some(method_call));\n+                        fields.push(field);\n+                    }\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(fields);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n+                    let fields = field_list.fields().map(|_| gen_default_call());\n+                    make::expr_call(struct_name, make::arg_list(fields))\n+                }\n+                None => {\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(None);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+            };\n+            let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n+        }\n+    }\n+}"}, {"sha": "4e99ae67d85cd06fc7f6a05d853acc1661aaf50f", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e65254547298588e2c9304b65366b6e8139e4243/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e65254547298588e2c9304b65366b6e8139e4243/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=e65254547298588e2c9304b65366b6e8139e4243", "patch": "@@ -280,6 +280,7 @@ fn check_todo(path: &Path, text: &str) {\n         \"ast/make.rs\",\n         // The documentation in string literals may contain anything for its own purposes\n         \"ide_db/src/helpers/generated_lints.rs\",\n+        \"ide_assists/src/utils/gen_trait_fn_body.rs\",\n         \"ide_assists/src/tests/generated.rs\",\n     ];\n     if need_todo.iter().any(|p| path.ends_with(p)) {"}]}