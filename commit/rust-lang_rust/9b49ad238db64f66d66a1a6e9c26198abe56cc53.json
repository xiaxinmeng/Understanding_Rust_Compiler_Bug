{"sha": "9b49ad238db64f66d66a1a6e9c26198abe56cc53", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDlhZDIzOGRiNjRmNjZkNjZhMWE2ZTljMjYxOThhYmU1NmNjNTM=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-16T11:27:34Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-17T09:28:22Z"}, "message": "doc: Cleanup.\n\nRemove ~~~ for code block specification. Use /// Over /** */ for doc\nblocks.", "tree": {"sha": "4728e31c58e362395652f201208083e81ccf7cfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4728e31c58e362395652f201208083e81ccf7cfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b49ad238db64f66d66a1a6e9c26198abe56cc53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b49ad238db64f66d66a1a6e9c26198abe56cc53", "html_url": "https://github.com/rust-lang/rust/commit/9b49ad238db64f66d66a1a6e9c26198abe56cc53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b49ad238db64f66d66a1a6e9c26198abe56cc53/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88cb454b91b16fdf8395bc4859b65aff8303acb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/88cb454b91b16fdf8395bc4859b65aff8303acb5", "html_url": "https://github.com/rust-lang/rust/commit/88cb454b91b16fdf8395bc4859b65aff8303acb5"}], "stats": {"total": 399, "additions": 186, "deletions": 213}, "files": [{"sha": "eb8d684fe50fdf5ade87ac4073ab11768da3474e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -138,10 +138,10 @@ pub struct RadixFmt<T, R>(T, R);\n ///\n /// # Example\n ///\n-/// ~~~\n+/// ```\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n-/// ~~~\n+/// ```\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }"}, {"sha": "99d9d1df522203737227de9db2c4862e4c696986", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -61,10 +61,10 @@ pub trait Zero: Add<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~text\n+    /// ```{.text}\n     /// a + 0 = a       \u2200 a \u2208 Self\n     /// 0 + a = a       \u2200 a \u2208 Self\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Purity\n     ///\n@@ -114,10 +114,10 @@ pub trait One: Mul<Self, Self> {\n     ///\n     /// # Laws\n     ///\n-    /// ~~~text\n+    /// ```{.text}\n     /// a * 1 = a       \u2200 a \u2208 Self\n     /// 1 * a = a       \u2200 a \u2208 Self\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Purity\n     ///"}, {"sha": "9b533a72ad7a88742a549741b4e91f708c5364bf", "filename": "src/libcore/result.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -15,12 +15,12 @@\n //! success and containing a value, and `Err(E)`, representing error\n //! and containing an error value.\n //!\n-//! ~~~\n+//! ```\n //! enum Result<T, E> {\n //!    Ok(T),\n //!    Err(E)\n //! }\n-//! ~~~\n+//! ```\n //!\n //! Functions return `Result` whenever errors are expected and\n //! recoverable. In the `std` crate `Result` is most prominently used\n@@ -29,7 +29,7 @@\n //! A simple function returning `Result` might be\n //! defined and used like so:\n //!\n-//! ~~~\n+//! ```\n //! #[deriving(Show)]\n //! enum Version { Version1, Version2 }\n //!\n@@ -53,13 +53,13 @@\n //!         println!(\"error parsing header: {}\", e);\n //!     }\n //! }\n-//! ~~~\n+//! ```\n //!\n //! Pattern matching on `Result`s is clear and straightforward for\n //! simple cases, but `Result` comes with some convenience methods\n //! that make working it more succinct.\n //!\n-//! ~~~\n+//! ```\n //! let good_result: Result<int, int> = Ok(10);\n //! let bad_result: Result<int, int> = Err(10);\n //!\n@@ -79,7 +79,7 @@\n //!\n //! // Consume the result and return the contents with `unwrap`.\n //! let final_awesome_result = good_result.ok().unwrap();\n-//! ~~~\n+//! ```\n //!\n //! # Results must be used\n //!\n@@ -94,13 +94,13 @@\n //! Consider the `write_line` method defined for I/O types\n //! by the [`Writer`](../io/trait.Writer.html) trait:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::IoError;\n //!\n //! trait Writer {\n //!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n //! }\n-//! ~~~\n+//! ```\n //!\n //! *Note: The actual definition of `Writer` uses `IoResult`, which\n //! is just a synonym for `Result<T, IoError>`.*\n@@ -109,15 +109,15 @@\n //! fail. It's crucial to handle the error case, and *not* write\n //! something like this:\n //!\n-//! ~~~ignore\n+//! ```{.ignore}\n //! use std::io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! // If `write_line` errors, then we'll never know, because the return\n //! // value is ignored.\n //! file.write_line(\"important message\");\n //! drop(file);\n-//! ~~~\n+//! ```\n //!\n //! If you *do* write that in Rust, the compiler will by give you a\n //! warning (by default, controlled by the `unused_must_use` lint).\n@@ -127,35 +127,35 @@\n //! success with `expect`. This will fail if the write fails, proving\n //! a marginally useful message indicating why:\n //!\n-//! ~~~no_run\n+//! ```{.no_run}\n //! use std::io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n //! drop(file);\n-//! ~~~\n+//! ```\n //!\n //! You might also simply assert success:\n //!\n-//! ~~~no_run\n+//! ```{.no_run}\n //! # use std::io::{File, Open, Write};\n //!\n //! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! assert!(file.write_line(\"important message\").is_ok());\n //! # drop(file);\n-//! ~~~\n+//! ```\n //!\n //! Or propagate the error up the call stack with `try!`:\n //!\n-//! ~~~\n+//! ```\n //! # use std::io::{File, Open, Write, IoError};\n //! fn write_message() -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //!     try!(file.write_line(\"important message\"));\n //!     drop(file);\n //!     return Ok(());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! # The `try!` macro\n //!\n@@ -166,7 +166,7 @@\n //!\n //! It replaces this:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n@@ -188,11 +188,11 @@\n //!     }\n //!     return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! With this:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n@@ -209,7 +209,7 @@\n //!     try!(file.write_line(format!(\"rating: {}\", info.rating).as_slice()));\n //!     return Ok(());\n //! }\n-//! ~~~\n+//! ```\n //!\n //! *It's much nicer!*\n //!\n@@ -218,13 +218,13 @@\n //! `Err` is returned early from the enclosing function. Its simple definition\n //! makes it clear:\n //!\n-//! ~~~\n+//! ```\n //! # #![feature(macro_rules)]\n //! macro_rules! try(\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n //! )\n //! # fn main() { }\n-//! ~~~\n+//! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n //!\n@@ -245,10 +245,10 @@\n //!\n //! Converting to an `Option` with `ok()` to handle an error:\n //!\n-//! ~~~\n+//! ```\n //! use std::io::Timer;\n //! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ~~~\n+//! ```\n //!\n //! # `Result` vs. `fail!`\n //!\n@@ -440,12 +440,12 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used to compose the results of two functions.\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n     /// Sum the lines of a buffer by mapping strings to numbers,\n     /// ignoring I/O and parse errors:\n     ///\n-    /// ~~~\n+    /// ```\n     /// use std::io::{BufReader, IoResult};\n     ///\n     /// let buffer = \"1\\n2\\n3\\n4\\n\";\n@@ -464,7 +464,7 @@ impl<T, E> Result<T, E> {\n     /// }\n     ///\n     /// assert!(sum == 10);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map<U>(self, op: |T| -> U) -> Result<U,E> {"}, {"sha": "f95ecb412d177ea8bd53454e9ee1ab029468dcc3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -31,7 +31,7 @@\n //! that requires an input file to be specified, accepts an optional output\n //! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n //!\n-//! ~~~{.rust}\n+//! ```{.rust}\n //! extern crate getopts;\n //! use getopts::{optopt,optflag,getopts,OptGroup};\n //! use std::os;\n@@ -76,7 +76,7 @@\n //!     };\n //!     do_work(input.as_slice(), output);\n //! }\n-//! ~~~\n+//! ```\n \n #![crate_name = \"getopts\"]\n #![experimental]"}, {"sha": "f5ac5831ea5e32c182fb59a8859634e9ee363970", "filename": "src/libnum/integer.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -17,7 +17,7 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert!(( 8i).div_floor(& 3) ==  2);\n     /// assert!(( 8i).div_floor(&-3) == -3);\n@@ -28,20 +28,20 @@ pub trait Integer: Num + PartialOrd\n     /// assert!(( 1i).div_floor(&-2) == -1);\n     /// assert!((-1i).div_floor(& 2) == -1);\n     /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ~~~\n+    /// ```\n     fn div_floor(&self, other: &Self) -> Self;\n \n     /// Floored integer modulo, satisfying:\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// # let n = 1i; let d = 1i;\n     /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert!(( 8i).mod_floor(& 3) ==  2);\n     /// assert!(( 8i).mod_floor(&-3) == -1);\n@@ -52,29 +52,29 @@ pub trait Integer: Num + PartialOrd\n     /// assert!(( 1i).mod_floor(&-2) == -1);\n     /// assert!((-1i).mod_floor(& 2) ==  1);\n     /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ~~~\n+    /// ```\n     fn mod_floor(&self, other: &Self) -> Self;\n \n     /// Greatest Common Divisor (GCD).\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(6i.gcd(&8), 2);\n     /// assert_eq!(7i.gcd(&3), 1);\n-    /// ~~~\n+    /// ```\n     fn gcd(&self, other: &Self) -> Self;\n \n     /// Lowest Common Multiple (LCM).\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(7i.lcm(&3), 21);\n     /// assert_eq!(2i.lcm(&4), 4);\n-    /// ~~~\n+    /// ```\n     fn lcm(&self, other: &Self) -> Self;\n \n     /// Deprecated, use `is_multiple_of` instead.\n@@ -85,41 +85,41 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(9i.is_multiple_of(&3), true);\n     /// assert_eq!(3i.is_multiple_of(&9), false);\n-    /// ~~~\n+    /// ```\n     fn is_multiple_of(&self, other: &Self) -> bool;\n \n     /// Returns `true` if the number is even.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_even(), false);\n     /// assert_eq!(4i.is_even(), true);\n-    /// ~~~\n+    /// ```\n     fn is_even(&self) -> bool;\n \n     /// Returns `true` if the number is odd.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(3i.is_odd(), true);\n     /// assert_eq!(4i.is_odd(), false);\n-    /// ~~~\n+    /// ```\n     fn is_odd(&self) -> bool;\n \n     /// Simultaneous truncated integer division and modulus.\n     /// Returns `(quotient, remainder)`.\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_rem( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_rem(&-3), (-2,  2));\n@@ -130,7 +130,7 @@ pub trait Integer: Num + PartialOrd\n     /// assert_eq!(( 1i).div_rem(&-2), ( 0,  1));\n     /// assert_eq!((-1i).div_rem( &2), ( 0, -1));\n     /// assert_eq!((-1i).div_rem(&-2), ( 0, -1));\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn div_rem(&self, other: &Self) -> (Self, Self) {\n         (*self / *other, *self % *other)\n@@ -141,7 +141,7 @@ pub trait Integer: Num + PartialOrd\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// # use num::Integer;\n     /// assert_eq!(( 8i).div_mod_floor( &3), ( 2,  2));\n     /// assert_eq!(( 8i).div_mod_floor(&-3), (-3, -1));\n@@ -152,7 +152,7 @@ pub trait Integer: Num + PartialOrd\n     /// assert_eq!(( 1i).div_mod_floor(&-2), (-1, -1));\n     /// assert_eq!((-1i).div_mod_floor( &2), (-1,  1));\n     /// assert_eq!((-1i).div_mod_floor(&-2), ( 0, -1));\n-    /// ~~~\n+    /// ```\n     fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n         (self.div_floor(other), self.mod_floor(other))\n     }"}, {"sha": "7a7c340c8c557ed57e362c25cdaa97426abd09a8", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -21,7 +21,7 @@\n ///\n /// # Example\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// bitflags! {\n ///     flags Flags: u32 {\n ///         static FlagA       = 0x00000001,\n@@ -41,11 +41,11 @@\n ///     assert!((e1 - e2) == FlagA);     // set difference\n ///     assert!(!e2 == FlagA);           // set complement\n /// }\n-/// ~~~\n+/// ```\n ///\n /// The generated `struct`s can also be extended with type and trait implementations:\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// use std::fmt;\n ///\n /// bitflags! {\n@@ -74,7 +74,7 @@\n ///     assert!(flags.is_empty());\n ///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n /// }\n-/// ~~~\n+/// ```\n ///\n /// # Attributes\n ///"}, {"sha": "c11350ea3aca989451c5ef273f8dd8cd7ffa1be8", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -192,7 +192,7 @@ macro_rules! debug_assert_eq(\n ///\n /// # Example\n ///\n-/// ~~~rust\n+/// ```{.rust}\n /// struct Item { weight: uint }\n ///\n /// fn choose_weighted_item(v: &[Item]) -> Item {\n@@ -208,7 +208,7 @@ macro_rules! debug_assert_eq(\n ///     // type checker that it isn't possible to get down here\n ///     unreachable!();\n /// }\n-/// ~~~\n+/// ```\n #[macro_export]\n macro_rules! unreachable(\n     () => (fail!(\"internal error: entered unreachable code\"))"}, {"sha": "31b242da27b5ea03fcbbdda1428a04e68760cab0", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 123, "deletions": 149, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -101,61 +101,61 @@\n //!\n //! When generating the `expr` for the `A` impl, the `SubstructureFields` is\n //!\n-//! ~~~text\n+//! ```{.text}\n //! Struct(~[FieldInfo {\n //!            span: <span of x>\n //!            name: Some(<ident of x>),\n //!            self_: <expr for &self.x>,\n //!            other: ~[<expr for &other.x]\n //!          }])\n-//! ~~~\n+//! ```\n //!\n //! For the `B` impl, called with `B(a)` and `B(b)`,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! Struct(~[FieldInfo {\n //!           span: <span of `int`>,\n //!           name: None,\n //!           <expr for &a>\n //!           ~[<expr for &b>]\n //!          }])\n-//! ~~~\n+//! ```\n //!\n //! ## Enums\n //!\n //! When generating the `expr` for a call with `self == C0(a)` and `other\n //! == C0(b)`, the SubstructureFields is\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n //!              ~[FieldInfo {\n //!                 span: <span of int>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n //!                 other: ~[<expr for &b>]\n //!               }])\n-//! ~~~\n+//! ```\n //!\n //! For `C1 {x}` and `C1 {x}`,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumMatching(1, <ast::Variant for C1>,\n //!              ~[FieldInfo {\n //!                 span: <span of x>\n //!                 name: Some(<ident of x>),\n //!                 self_: <expr for &self.x>,\n //!                 other: ~[<expr for &other.x>]\n //!                }])\n-//! ~~~\n+//! ```\n //!\n //! For `C0(a)` and `C1 {x}` ,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! EnumNonMatchingCollapsed(\n //!     ~[<ident of self>, <ident of __arg_1>],\n //!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n //!     &[<ident for self index value>, <ident of __arg_1 index value>])\n-//! ~~~\n+//! ```\n //!\n //! It is the same for when the arguments are flipped to `C1 {x}` and\n //! `C0(a)`; the only difference is what the values of the identifiers\n@@ -170,15 +170,15 @@\n //!\n //! A static method on the above would result in,\n //!\n-//! ~~~text\n+//! ```{.text}\n //! StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n //!\n //! StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n //!\n //! StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n //!                                   (<ident of C1>, <span of C1>,\n //!                                    Named(~[(<ident of x>, <span of x>)]))])\n-//! ~~~\n+//! ```\n \n use std::cell::RefCell;\n use std::gc::GC;\n@@ -286,21 +286,17 @@ pub enum StaticFields {\n /// and examples\n pub enum SubstructureFields<'a> {\n     Struct(Vec<FieldInfo>),\n-    /**\n-    Matching variants of the enum: variant index, ast::Variant,\n-    fields: the field name is only non-`None` in the case of a struct\n-    variant.\n-    */\n+    /// Matching variants of the enum: variant index, ast::Variant,\n+    /// fields: the field name is only non-`None` in the case of a struct\n+    /// variant.\n     EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n-    /**\n-    non-matching variants of the enum, but with all state hidden from\n-    the consequent code.  The first component holds Idents for all of\n-    the Self arguments; the second component is a slice of all of the\n-    variants for the enum itself, and the third component is a list of\n-    Idents bound to the variant index values for each of the actual\n-    input Self arguments.\n-    */\n+    /// non-matching variants of the enum, but with all state hidden from\n+    /// the consequent code.  The first component holds Idents for all of\n+    /// the Self arguments; the second component is a slice of all of the\n+    /// variants for the enum itself, and the third component is a list of\n+    /// Idents bound to the variant index values for each of the actual\n+    /// input Self arguments.\n     EnumNonMatchingCollapsed(Vec<Ident>, &'a [P<ast::Variant>], &'a [Ident]),\n \n     /// A static method where Self is a struct.\n@@ -311,20 +307,16 @@ pub enum SubstructureFields<'a> {\n \n \n \n-/**\n-Combine the values of all the fields together. The last argument is\n-all the fields of all the structures, see above for details.\n-*/\n+/// Combine the values of all the fields together. The last argument is\n+/// all the fields of all the structures, see above for details.\n pub type CombineSubstructureFunc<'a> =\n     |&mut ExtCtxt, Span, &Substructure|: 'a -> P<Expr>;\n \n-/**\n-Deal with non-matching enum variants.  The tuple is a list of\n-identifiers (one for each Self argument, which could be any of the\n-variants since they have been collapsed together) and the identifiers\n-holding the variant index value for each of the Self arguments.  The\n-last argument is all the non-Self args of the method being derived.\n-*/\n+/// Deal with non-matching enum variants.  The tuple is a list of\n+/// identifiers (one for each Self argument, which could be any of the\n+/// variants since they have been collapsed together) and the identifiers\n+/// holding the variant index value for each of the Self arguments.  The\n+/// last argument is all the non-Self args of the method being derived.\n pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n      Span,\n@@ -374,18 +366,14 @@ impl<'a> TraitDef<'a> {\n         }))\n     }\n \n-    /**\n-     *\n-     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     * ```ignore\n-     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n-     * ```\n-     *\n-     * where B1, B2, ... are the bounds given by `bounds_paths`.'\n-     *\n-     */\n+    /// Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+    /// 'z, A, ..., Z>`, creates an impl like:\n+    ///\n+    /// ```ignore\n+    ///      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+    /// ```\n+    ///\n+    /// where B1, B2, ... are the bounds given by `bounds_paths`.'\n     fn create_derived_impl(&self,\n                            cx: &mut ExtCtxt,\n                            type_ident: Ident,\n@@ -694,27 +682,25 @@ impl<'a> MethodDef<'a> {\n         })\n     }\n \n-    /**\n-   ~~~\n-    #[deriving(PartialEq)]\n-    struct A { x: int, y: int }\n-\n-    // equivalent to:\n-    impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) -> bool {\n-            match *self {\n-                A {x: ref __self_0_0, y: ref __self_0_1} => {\n-                    match *__arg_1 {\n-                        A {x: ref __self_1_0, y: ref __self_1_1} => {\n-                            __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-   ~~~\n-    */\n+    /// ```\n+    /// #[deriving(PartialEq)]\n+    /// struct A { x: int, y: int }\n+    ///\n+    /// // equivalent to:\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, __arg_1: &A) -> bool {\n+    ///         match *self {\n+    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n+    ///                 match *__arg_1 {\n+    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n+    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n+    ///                     }\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     fn expand_struct_method_body(&self,\n                                  cx: &mut ExtCtxt,\n                                  trait_: &TraitDef,\n@@ -799,37 +785,35 @@ impl<'a> MethodDef<'a> {\n                                       &StaticStruct(struct_def, summary))\n     }\n \n-    /**\n-   ~~~\n-    #[deriving(PartialEq)]\n-    enum A {\n-        A1,\n-        A2(int)\n-    }\n-\n-    // is equivalent to\n-\n-    impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) -> ::bool {\n-            match (&*self, &*__arg_1) {\n-                (&A1, &A1) => true,\n-                (&A2(ref __self_0),\n-                 &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n-                _ => {\n-                    let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n-                    let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n-                    false\n-                }\n-            }\n-        }\n-    }\n-   ~~~\n-\n-    (Of course `__self_vi` and `__arg_1_vi` are unused for\n-     `PartialEq`, and those subcomputations will hopefully be removed\n-     as their results are unused.  The point of `__self_vi` and\n-     `__arg_1_vi` is for `PartialOrd`; see #15503.)\n-    */\n+    /// ```\n+    /// #[deriving(PartialEq)]\n+    /// enum A {\n+    ///     A1,\n+    ///     A2(int)\n+    /// }\n+    ///\n+    /// // is equivalent to\n+    ///\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, __arg_1: &A) -> ::bool {\n+    ///         match (&*self, &*__arg_1) {\n+    ///             (&A1, &A1) => true,\n+    ///             (&A2(ref __self_0),\n+    ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+    ///             _ => {\n+    ///                 let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+    ///                 false\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n+    /// `PartialEq`, and those subcomputations will hopefully be removed\n+    /// as their results are unused.  The point of `__self_vi` and\n+    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body(&self,\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef,\n@@ -843,33 +827,31 @@ impl<'a> MethodDef<'a> {\n     }\n \n \n-    /**\n-    Creates a match for a tuple of all `self_args`, where either all\n-    variants match, or it falls into a catch-all for when one variant\n-    does not match.\n-\n-    There are N + 1 cases because is a case for each of the N\n-    variants where all of the variants match, and one catch-all for\n-    when one does not match.\n-\n-    The catch-all handler is provided access the variant index values\n-    for each of the self-args, carried in precomputed variables. (Nota\n-    bene: the variant index values are not necessarily the\n-    discriminant values.  See issue #15523.)\n-\n-    ~~~text\n-    match (this, that, ...) {\n-      (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n-      (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n-      ...\n-      _ => {\n-        let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n-        let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n-        ... // catch-all remainder can inspect above variant index values.\n-      }\n-    }\n-    ~~~\n-    */\n+    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// variants match, or it falls into a catch-all for when one variant\n+    /// does not match.\n+\n+    /// There are N + 1 cases because is a case for each of the N\n+    /// variants where all of the variants match, and one catch-all for\n+    /// when one does not match.\n+\n+    /// The catch-all handler is provided access the variant index values\n+    /// for each of the self-args, carried in precomputed variables. (Nota\n+    /// bene: the variant index values are not necessarily the\n+    /// discriminant values.  See issue #15523.)\n+\n+    /// ```{.text}\n+    /// match (this, that, ...) {\n+    ///   (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n+    ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n+    ///   ...\n+    ///   _ => {\n+    ///     let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     ... // catch-all remainder can inspect above variant index values.\n+    ///   }\n+    /// }\n+    /// ```\n     fn build_enum_match_tuple(\n         &self,\n         cx: &mut ExtCtxt,\n@@ -1320,10 +1302,8 @@ impl<'a> TraitDef<'a> {\n \n /* helpful premade recipes */\n \n-/**\n-Fold the fields. `use_foldl` controls whether this is done\n-left-to-right (`true`) or right-to-left (`false`).\n-*/\n+/// Fold the fields. `use_foldl` controls whether this is done\n+/// left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]| -> P<Expr>,\n                base: P<Expr>,\n@@ -1362,15 +1342,13 @@ pub fn cs_fold(use_foldl: bool,\n }\n \n \n-/**\n-Call the method that is being derived on all the fields, and then\n-process the collected results. i.e.\n-\n-~~~\n-f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n-              self_2.method(__arg_1_2, __arg_2_2)])\n-~~~\n-*/\n+/// Call the method that is being derived on all the fields, and then\n+/// process the collected results. i.e.\n+///\n+/// ```\n+/// f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n+///              self_2.method(__arg_1_2, __arg_2_2)])\n+/// ```\n #[inline]\n pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n                       enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n@@ -1401,11 +1379,9 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<P<Expr>>| -> P<Expr>,\n     }\n }\n \n-/**\n-Fold together the results of calling the derived method on all the\n-fields. `use_foldl` controls whether this is done left-to-right\n-(`true`) or right-to-left (`false`).\n-*/\n+/// Fold together the results of calling the derived method on all the\n+/// fields. `use_foldl` controls whether this is done left-to-right\n+/// (`true`) or right-to-left (`false`).\n #[inline]\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: |&mut ExtCtxt, Span, P<Expr>, P<Expr>| -> P<Expr>,\n@@ -1431,10 +1407,8 @@ pub fn cs_same_method_fold(use_foldl: bool,\n         cx, trait_span, substructure)\n }\n \n-/**\n-Use a given binop to combine the result of calling the derived method\n-on all the fields.\n-*/\n+/// Use a given binop to combine the result of calling the derived method\n+/// on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,"}, {"sha": "93c5e00b6ea3ec72cd0b0139f5a0060ca531d531", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b49ad238db64f66d66a1a6e9c26198abe56cc53/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9b49ad238db64f66d66a1a6e9c26198abe56cc53", "patch": "@@ -352,10 +352,9 @@ pub fn write_5_number_summary<T: Float + Show>(w: &mut io::Writer,\n /// As an example, the summary with 5-number-summary `(min=15, q1=17, med=20, q3=24, max=31)` might\n /// display as:\n ///\n-/// ~~~~ignore\n+/// ```{.ignore}\n ///   10 |        [--****#******----------]          | 40\n-/// ~~~~\n-\n+/// ```\n pub fn write_boxplot<T: Float + Show + FromPrimitive>(\n                      w: &mut io::Writer,\n                      s: &Summary<T>,"}]}