{"sha": "d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzJhNzBiZjQyYTZlYTliYjVkYTM1MmRmZTMzZjM3OWU3NWMzZjU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-09-22T15:45:47Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-10-01T13:50:11Z"}, "message": "BTreeSet intersection, difference & is_subnet optimizations", "tree": {"sha": "2038ef2a2d1be76a9a298604bd43b1f3ee6be08f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2038ef2a2d1be76a9a298604bd43b1f3ee6be08f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "html_url": "https://github.com/rust-lang/rust/commit/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702b45e409495a41afcccbe87a251a692b0cefab", "url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab", "html_url": "https://github.com/rust-lang/rust/commit/702b45e409495a41afcccbe87a251a692b0cefab"}], "stats": {"total": 340, "additions": 247, "deletions": 93}, "files": [{"sha": "8250fc38ccd1c7a0b4d556294b128d5d8d699714", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 155, "deletions": 75, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "patch": "@@ -122,13 +122,16 @@ pub struct Difference<'a, T: 'a> {\n }\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n+        // iterate all of self and some of other, spotting matches along the way\n         self_iter: Iter<'a, T>,\n         other_iter: Peekable<Iter<'a, T>>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         self_iter: Iter<'a, T>,\n         other_set: &'a BTreeSet<T>,\n     },\n+    Iterate(Iter<'a, T>), // simply stream self's elements\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -147,6 +150,7 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n                 self_iter,\n                 other_set: _,\n             } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n+            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n         }\n     }\n }\n@@ -187,13 +191,16 @@ pub struct Intersection<'a, T: 'a> {\n }\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n+        // iterate similarly sized sets jointly, spotting matches along the way\n         a: Iter<'a, T>,\n         b: Iter<'a, T>,\n     },\n     Search {\n+        // iterate a small set, look up in the large set\n         small_iter: Iter<'a, T>,\n         large_set: &'a BTreeSet<T>,\n     },\n+    Answer(Option<&'a T>), // return a specific value or emptiness\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n@@ -212,6 +219,9 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n                 small_iter,\n                 large_set: _,\n             } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n+            IntersectionInner::Answer(answer) => {\n+                f.debug_tuple(\"Intersection\").field(&answer).finish()\n+            }\n         }\n     }\n }\n@@ -314,24 +324,51 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is bigger than or not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Difference {\n-                inner: DifferenceInner::Stitch {\n-                    self_iter: self.iter(),\n-                    other_iter: other.iter().peekable(),\n-                },\n-            }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n         } else {\n-            // Self is much smaller than other set, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Difference {\n-                inner: DifferenceInner::Search {\n-                    self_iter: self.iter(),\n-                    other_set: other,\n-                },\n-            }\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n+        } else {\n+            return Difference {\n+                inner: DifferenceInner::Iterate(self.iter()),\n+            };\n+        };\n+        Difference {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),\n+                (Equal, _) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                (_, Equal) => {\n+                    let mut self_iter = self.iter();\n+                    self_iter.next_back();\n+                    DifferenceInner::Iterate(self_iter)\n+                }\n+                _ => {\n+                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        DifferenceInner::Search {\n+                            self_iter: self.iter(),\n+                            other_set: other,\n+                        }\n+                    } else {\n+                        DifferenceInner::Stitch {\n+                            self_iter: self.iter(),\n+                            other_iter: other.iter().peekable(),\n+                        }\n+                    }\n+                }\n+            },\n         }\n     }\n \n@@ -387,29 +424,48 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        let (small, other) = if self.len() <= other.len() {\n-            (self, other)\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n         } else {\n-            (other, self)\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n         };\n-        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Small set is not much smaller than other set.\n-            // Iterate both sets jointly, spotting matches along the way.\n-            Intersection {\n-                inner: IntersectionInner::Stitch {\n-                    a: small.iter(),\n-                    b: other.iter(),\n-                },\n-            }\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            Intersection {\n-                inner: IntersectionInner::Search {\n-                    small_iter: small.iter(),\n-                    large_set: other,\n-                },\n-            }\n+            return Intersection {\n+                inner: IntersectionInner::Answer(None),\n+            };\n+        };\n+        Intersection {\n+            inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {\n+                (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n+                (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n+                (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n+                _ => {\n+                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        IntersectionInner::Search {\n+                            small_iter: self.iter(),\n+                            large_set: other,\n+                        }\n+                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+                        IntersectionInner::Search {\n+                            small_iter: other.iter(),\n+                            large_set: self,\n+                        }\n+                    } else {\n+                        IntersectionInner::Stitch {\n+                            a: self.iter(),\n+                            b: other.iter(),\n+                        }\n+                    }\n+                }\n+            },\n         }\n     }\n \n@@ -544,43 +600,61 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n         // Same result as self.difference(other).next().is_none()\n-        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n-            false\n-        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-            // Self is not much smaller than other set.\n-            // Stolen from TreeMap\n-            let mut x = self.iter();\n-            let mut y = other.iter();\n-            let mut a = x.next();\n-            let mut b = y.next();\n-            while a.is_some() {\n-                if b.is_none() {\n+            return false;\n+        }\n+        let (self_min, self_max) = if let (Some(self_min), Some(self_max)) =\n+            (self.iter().next(), self.iter().next_back())\n+        {\n+            (self_min, self_max)\n+        } else {\n+            return true; // self is empty\n+        };\n+        let (other_min, other_max) = if let (Some(other_min), Some(other_max)) =\n+            (other.iter().next(), other.iter().next_back())\n+        {\n+            (other_min, other_max)\n+        } else {\n+            return false; // other is empty\n+        };\n+        let mut self_iter = self.iter();\n+        match self_min.cmp(other_min) {\n+            Less => return false,\n+            Equal => {\n+                self_iter.next();\n+            }\n+            Greater => (),\n+        }\n+        match self_max.cmp(other_max) {\n+            Greater => return false,\n+            Equal => {\n+                self_iter.next_back();\n+            }\n+            Less => (),\n+        }\n+        if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Big difference in number of elements.\n+            for next in self_iter {\n+                if !other.contains(next) {\n                     return false;\n                 }\n-\n-                let a1 = a.unwrap();\n-                let b1 = b.unwrap();\n-\n-                match b1.cmp(a1) {\n-                    Less => (),\n-                    Greater => return false,\n-                    Equal => a = x.next(),\n-                }\n-\n-                b = y.next();\n             }\n-            true\n         } else {\n-            // Big difference in number of elements, or both sets are empty.\n-            // Iterate the small set, searching for matches in the large set.\n-            for next in self {\n-                if !other.contains(next) {\n-                    return false;\n+            // Self is not much smaller than other set.\n+            let mut other_iter = other.iter();\n+            other_iter.next();\n+            other_iter.next_back();\n+            let mut self_next = self_iter.next();\n+            while let Some(self1) = self_next {\n+                match other_iter.next().map_or(Less, |other1| self1.cmp(other1)) {\n+                    Less => return false,\n+                    Equal => self_next = self_iter.next(),\n+                    Greater => (),\n                 }\n             }\n-            true\n         }\n+        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -1120,6 +1194,7 @@ impl<T> Clone for Difference<'_, T> {\n                     self_iter: self_iter.clone(),\n                     other_set,\n                 },\n+                DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),\n             },\n         }\n     }\n@@ -1138,7 +1213,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                 loop {\n                     match other_iter\n                         .peek()\n-                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                        .map_or(Less, |other_next| self_next.cmp(other_next))\n                     {\n                         Less => return Some(self_next),\n                         Equal => {\n@@ -1160,19 +1235,21 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n                     return Some(self_next);\n                 }\n             },\n+            DifferenceInner::Iterate(iter) => iter.next(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (self_len, other_len) = match &self.inner {\n             DifferenceInner::Stitch {\n                 self_iter,\n-                other_iter\n+                other_iter,\n             } => (self_iter.len(), other_iter.len()),\n             DifferenceInner::Search {\n                 self_iter,\n-                other_set\n+                other_set,\n             } => (self_iter.len(), other_set.len()),\n+            DifferenceInner::Iterate(iter) => (iter.len(), 0),\n         };\n         (self_len.saturating_sub(other_len), Some(self_len))\n     }\n@@ -1234,6 +1311,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n             },\n         }\n     }\n@@ -1251,7 +1329,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                 let mut a_next = a.next()?;\n                 let mut b_next = b.next()?;\n                 loop {\n-                    match Ord::cmp(a_next, b_next) {\n+                    match a_next.cmp(b_next) {\n                         Less => a_next = a.next()?,\n                         Greater => b_next = b.next()?,\n                         Equal => return Some(a_next),\n@@ -1267,15 +1345,17 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n                     return Some(small_next);\n                 }\n             },\n+            IntersectionInner::Answer(answer) => answer.take(),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let min_len = match &self.inner {\n-            IntersectionInner::Stitch { a, b } => min(a.len(), b.len()),\n-            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n-        };\n-        (0, Some(min_len))\n+        match &self.inner {\n+            IntersectionInner::Stitch { a, b } => (0, Some(min(a.len(), b.len()))),\n+            IntersectionInner::Search { small_iter, .. } => (0, Some(small_iter.len())),\n+            IntersectionInner::Answer(None) => (0, Some(0)),\n+            IntersectionInner::Answer(Some(_)) => (1, Some(1)),\n+        }\n     }\n }\n "}, {"sha": "5c611fd21d21bedf9584bca4119adf662ecd17f6", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 92, "deletions": 18, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d132a70bf42a6ea9bb5da352dfe33f379e75c3f5/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=d132a70bf42a6ea9bb5da352dfe33f379e75c3f5", "patch": "@@ -48,7 +48,9 @@ fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n     f(&set_a,\n       &set_b,\n       &mut |&x| {\n-          assert_eq!(x, expected[i]);\n+          if i < expected.len() {\n+              assert_eq!(x, expected[i]);\n+          }\n           i += 1;\n           true\n       });\n@@ -74,31 +76,36 @@ fn test_intersection() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n     check_intersection(&[-1], &large, &[]);\n     check_intersection(&large, &[-1], &[]);\n     check_intersection(&[0], &large, &[0]);\n     check_intersection(&large, &[0], &[0]);\n-    check_intersection(&[999], &large, &[999]);\n-    check_intersection(&large, &[999], &[999]);\n-    check_intersection(&[1000], &large, &[]);\n-    check_intersection(&large, &[1000], &[]);\n-    check_intersection(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_intersection(&[99], &large, &[99]);\n+    check_intersection(&large, &[99], &[99]);\n+    check_intersection(&[100], &large, &[]);\n+    check_intersection(&large, &[100], &[]);\n+    check_intersection(&[11, 5000, 1, 3, 77, 8924],\n                        &large,\n-                       &[1, 3, 11, 77, 103]);\n+                       &[1, 3, 11, 77]);\n }\n \n #[test]\n fn test_intersection_size_hint() {\n     let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n     let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n     let mut iter = x.intersection(&y);\n-    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n     assert_eq!(iter.next(), Some(&3));\n     assert_eq!(iter.size_hint(), (0, Some(0)));\n     assert_eq!(iter.next(), None);\n+\n+    iter = y.intersection(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n }\n \n #[test]\n@@ -111,6 +118,9 @@ fn test_difference() {\n     check_difference(&[1, 12], &[], &[1, 12]);\n     check_difference(&[], &[1, 2, 3, 9], &[]);\n     check_difference(&[1, 3, 5, 9, 11], &[3, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[3, 6, 9], &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[0, 1], &[3, 5, 9, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[11, 12], &[1, 3, 5, 9]);\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n@@ -119,18 +129,82 @@ fn test_difference() {\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n     check_difference(&[0], &large, &[]);\n-    check_difference(&[999], &large, &[]);\n-    check_difference(&[1000], &large, &[1000]);\n-    check_difference(&[11, 5000, 1, 3, 77, 8924, 103],\n+    check_difference(&[99], &large, &[]);\n+    check_difference(&[100], &large, &[100]);\n+    check_difference(&[11, 5000, 1, 3, 77, 8924],\n                      &large,\n                      &[5000, 8924]);\n     check_difference(&large, &[], &large);\n     check_difference(&large, &[-1], &large);\n-    check_difference(&large, &[1000], &large);\n+    check_difference(&large, &[100], &large);\n+}\n+\n+#[test]\n+fn test_difference_size_hint() {\n+    let s246: BTreeSet<i32> = [2, 4, 6].iter().copied().collect();\n+    let s23456: BTreeSet<i32> = (2..=6).collect();\n+    let mut iter = s246.difference(&s23456);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s12345: BTreeSet<i32> = (1..=5).collect();\n+    iter = s246.difference(&s12345);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s34567: BTreeSet<i32> = (3..=7).collect();\n+    iter = s246.difference(&s34567);\n+    assert_eq!(iter.size_hint(), (0, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s1: BTreeSet<i32> = (-9..=1).collect();\n+    iter = s246.difference(&s1);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n+\n+    let s2: BTreeSet<i32> = (-9..=2).collect();\n+    iter = s246.difference(&s2);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s23: BTreeSet<i32> = (2..=3).collect();\n+    iter = s246.difference(&s23);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&4));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s4: BTreeSet<i32> = (4..=4).collect();\n+    iter = s246.difference(&s4);\n+    assert_eq!(iter.size_hint(), (2, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+    assert_eq!(iter.next(), Some(&6));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+\n+    let s56: BTreeSet<i32> = (5..=6).collect();\n+    iter = s246.difference(&s56);\n+    assert_eq!(iter.size_hint(), (1, Some(3)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+\n+    let s6: BTreeSet<i32> = (6..=19).collect();\n+    iter = s246.difference(&s6);\n+    assert_eq!(iter.size_hint(), (2, Some(2)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(1)));\n+\n+    let s7: BTreeSet<i32> = (7..=19).collect();\n+    iter = s246.difference(&s7);\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n }\n \n #[test]\n@@ -188,23 +262,23 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 11, 34, 22, 38, 33, 42, 39, 40]),\n+                         &[-12, -5, 11, 14, 22, 23, 33, 34, 38, 39, 40, 42]),\n                true);\n     assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n-                         &[-12, -5, 14, 23, 34, 38, 22, 11]),\n+                         &[-12, -5, 11, 14, 22, 23, 34, 38]),\n                false);\n \n     if cfg!(miri) { // Miri is too slow\n         return;\n     }\n \n-    let large = (0..1000).collect::<Vec<_>>();\n+    let large = (0..100).collect::<Vec<_>>();\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n     assert_eq!(is_subset(&[-1], &large), false);\n     assert_eq!(is_subset(&[0], &large), true);\n     assert_eq!(is_subset(&[1, 2], &large), true);\n-    assert_eq!(is_subset(&[999, 1000], &large), false);\n+    assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n #[test]"}]}