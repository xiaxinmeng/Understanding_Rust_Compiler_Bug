{"sha": "9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "node_id": "C_kwDOAAsO6NoAKDlhNzlhYjZjMGI1MGU5OTM0MDhlMGFmZDMzYTVjNTA4NWUxZmZmYzE", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-01-10T14:59:52Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-01-17T15:43:23Z"}, "message": "rustc_codegen_llvm: Remove (almost) unused span parameter from many functions in metadata.rs.", "tree": {"sha": "b667feb656b018469ae83019abe6664a8a97c9b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b667feb656b018469ae83019abe6664a8a97c9b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "html_url": "https://github.com/rust-lang/rust/commit/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a34c0797528172ede89480e3033f7a5e71ea4735", "url": "https://api.github.com/repos/rust-lang/rust/commits/a34c0797528172ede89480e3033f7a5e71ea4735", "html_url": "https://github.com/rust-lang/rust/commit/a34c0797528172ede89480e3033f7a5e71ea4735"}], "stats": {"total": 181, "additions": 51, "deletions": 130}, "files": [{"sha": "3d5fd2f354e55980a11a2b6f11d6ebbf4941df40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 44, "deletions": 118, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "patch": "@@ -27,18 +27,18 @@ use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::bug;\n use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{self, IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, AdtKind, GeneratorSubsts, Instance, ParamEnv, Ty, TyCtxt, COMMON_VTABLE_ENTRIES,\n };\n-use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::NodeIdHashingMode;\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileNameDisplayPreference;\n-use rustc_span::{self, SourceFile, SourceFileHash, Span};\n+use rustc_span::{self, SourceFile, SourceFileHash};\n use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n@@ -381,9 +381,8 @@ fn fixed_vec_metadata<'ll, 'tcx>(\n     unique_type_id: UniqueTypeId,\n     array_or_slice_type: Ty<'tcx>,\n     element_type: Ty<'tcx>,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n-    let element_type_metadata = type_metadata(cx, element_type, span);\n+    let element_type_metadata = type_metadata(cx, element_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -416,11 +415,10 @@ fn vec_slice_metadata<'ll, 'tcx>(\n     slice_ptr_type: Ty<'tcx>,\n     element_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n     let data_ptr_type = cx.tcx.mk_imm_ptr(element_type);\n \n-    let data_ptr_metadata = type_metadata(cx, data_ptr_type, span);\n+    let data_ptr_metadata = type_metadata(cx, data_ptr_type);\n \n     return_if_metadata_created_in_meantime!(cx, unique_type_id);\n \n@@ -442,7 +440,7 @@ fn vec_slice_metadata<'ll, 'tcx>(\n         },\n         MemberDescription {\n             name: \"length\".to_owned(),\n-            type_metadata: type_metadata(cx, cx.tcx.types.usize, span),\n+            type_metadata: type_metadata(cx, cx.tcx.types.usize),\n             offset: pointer_size,\n             size: usize_size,\n             align: usize_align,\n@@ -452,17 +450,13 @@ fn vec_slice_metadata<'ll, 'tcx>(\n         },\n     ];\n \n-    let file_metadata = unknown_file_metadata(cx);\n-\n     let metadata = composite_type_metadata(\n         cx,\n         slice_ptr_type,\n         &slice_type_name,\n         unique_type_id,\n         member_descriptions,\n         NO_SCOPE_METADATA,\n-        file_metadata,\n-        span,\n     );\n     MetadataCreationResult::new(metadata, false)\n }\n@@ -471,7 +465,6 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId,\n     signature: ty::PolyFnSig<'tcx>,\n-    span: Span,\n ) -> MetadataCreationResult<'ll> {\n     let signature =\n         cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), signature);\n@@ -480,12 +473,12 @@ fn subroutine_type_metadata<'ll, 'tcx>(\n         // return type\n         match signature.output().kind() {\n             ty::Tuple(tys) if tys.is_empty() => None,\n-            _ => Some(type_metadata(cx, signature.output(), span)),\n+            _ => Some(type_metadata(cx, signature.output())),\n         },\n     )\n     .chain(\n         // regular arguments\n-        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type, span))),\n+        signature.inputs().iter().map(|argument_type| Some(type_metadata(cx, argument_type))),\n     )\n     .collect();\n \n@@ -541,8 +534,6 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         None => (NO_SCOPE_METADATA, compute_debuginfo_type_name(cx.tcx, trait_type, true)),\n     };\n \n-    let file_metadata = unknown_file_metadata(cx);\n-\n     let layout = cx.layout_of(cx.tcx.mk_mut_ptr(trait_type));\n \n     assert_eq!(abi::FAT_PTR_ADDR, 0);\n@@ -553,11 +544,7 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n     let member_descriptions = vec![\n         MemberDescription {\n             name: \"pointer\".to_owned(),\n-            type_metadata: type_metadata(\n-                cx,\n-                cx.tcx.mk_mut_ptr(cx.tcx.types.u8),\n-                rustc_span::DUMMY_SP,\n-            ),\n+            type_metadata: type_metadata(cx, cx.tcx.mk_mut_ptr(cx.tcx.types.u8)),\n             offset: layout.fields.offset(0),\n             size: data_ptr_field.size,\n             align: data_ptr_field.align.abi,\n@@ -567,7 +554,7 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         },\n         MemberDescription {\n             name: \"vtable\".to_owned(),\n-            type_metadata: type_metadata(cx, vtable_field.ty, rustc_span::DUMMY_SP),\n+            type_metadata: type_metadata(cx, vtable_field.ty),\n             offset: layout.fields.offset(1),\n             size: vtable_field.size,\n             align: vtable_field.align.abi,\n@@ -584,16 +571,10 @@ fn trait_pointer_metadata<'ll, 'tcx>(\n         unique_type_id,\n         member_descriptions,\n         containing_scope,\n-        file_metadata,\n-        rustc_span::DUMMY_SP,\n     )\n }\n \n-pub fn type_metadata<'ll, 'tcx>(\n-    cx: &CodegenCx<'ll, 'tcx>,\n-    t: Ty<'tcx>,\n-    usage_site_span: Span,\n-) -> &'ll DIType {\n+pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     // Get the unique type ID of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n@@ -630,14 +611,14 @@ pub fn type_metadata<'ll, 'tcx>(\n     debug!(\"type_metadata: {:?}\", t);\n \n     let ptr_metadata = |ty: Ty<'tcx>| match *ty.kind() {\n-        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)),\n-        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span)),\n+        ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id)),\n+        ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id)),\n         ty::Dynamic(..) => Ok(MetadataCreationResult::new(\n             trait_pointer_metadata(cx, ty, Some(t), unique_type_id),\n             false,\n         )),\n         _ => {\n-            let pointee_metadata = type_metadata(cx, ty, usage_site_span);\n+            let pointee_metadata = type_metadata(cx, ty);\n \n             if let Some(metadata) =\n                 debug_context(cx).type_map.borrow().find_metadata_for_unique_id(unique_type_id)\n@@ -656,10 +637,8 @@ pub fn type_metadata<'ll, 'tcx>(\n         ty::Tuple(elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::Array(typ, _) | ty::Slice(typ) => {\n-            fixed_vec_metadata(cx, unique_type_id, t, typ, usage_site_span)\n-        }\n-        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8, usage_site_span),\n+        ty::Array(typ, _) | ty::Slice(typ) => fixed_vec_metadata(cx, unique_type_id, t, typ),\n+        ty::Str => fixed_vec_metadata(cx, unique_type_id, t, cx.tcx.types.i8),\n         ty::Dynamic(..) => {\n             MetadataCreationResult::new(trait_pointer_metadata(cx, t, None, unique_type_id), false)\n         }\n@@ -710,8 +689,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             type_map.borrow_mut().register_type_with_metadata(t, temp_type);\n \n             let fn_metadata =\n-                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx), usage_site_span)\n-                    .metadata;\n+                subroutine_type_metadata(cx, unique_type_id, t.fn_sig(cx.tcx)).metadata;\n \n             type_map.borrow_mut().remove_type(t);\n \n@@ -721,41 +699,27 @@ pub fn type_metadata<'ll, 'tcx>(\n         ty::Closure(def_id, substs) => {\n             let upvar_tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n             let containing_scope = get_namespace_for_item(cx, def_id);\n-            prepare_tuple_metadata(\n-                cx,\n-                t,\n-                &upvar_tys,\n-                unique_type_id,\n-                usage_site_span,\n-                Some(containing_scope),\n-            )\n-            .finalize(cx)\n+            prepare_tuple_metadata(cx, t, &upvar_tys, unique_type_id, Some(containing_scope))\n+                .finalize(cx)\n         }\n         ty::Generator(def_id, substs, _) => {\n             let upvar_tys: Vec<_> = substs\n                 .as_generator()\n                 .prefix_tys()\n                 .map(|t| cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n                 .collect();\n-            prepare_enum_metadata(cx, t, def_id, unique_type_id, usage_site_span, upvar_tys)\n-                .finalize(cx)\n+            prepare_enum_metadata(cx, t, def_id, unique_type_id, upvar_tys).finalize(cx)\n         }\n         ty::Adt(def, ..) => match def.adt_kind() {\n-            AdtKind::Struct => {\n-                prepare_struct_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n-            }\n-            AdtKind::Union => {\n-                prepare_union_metadata(cx, t, unique_type_id, usage_site_span).finalize(cx)\n-            }\n+            AdtKind::Struct => prepare_struct_metadata(cx, t, unique_type_id).finalize(cx),\n+            AdtKind::Union => prepare_union_metadata(cx, t, unique_type_id).finalize(cx),\n             AdtKind::Enum => {\n-                prepare_enum_metadata(cx, t, def.did, unique_type_id, usage_site_span, vec![])\n-                    .finalize(cx)\n+                prepare_enum_metadata(cx, t, def.did, unique_type_id, vec![]).finalize(cx)\n             }\n         },\n         ty::Tuple(elements) => {\n             let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n-            prepare_tuple_metadata(cx, t, &tys, unique_type_id, usage_site_span, NO_SCOPE_METADATA)\n-                .finalize(cx)\n+            prepare_tuple_metadata(cx, t, &tys, unique_type_id, NO_SCOPE_METADATA).finalize(cx)\n         }\n         // Type parameters from polymorphized functions.\n         ty::Param(_) => MetadataCreationResult::new(param_type_metadata(cx, t), false),\n@@ -770,8 +734,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    span_bug!(\n-                        usage_site_span,\n+                    bug!(\n                         \"expected type metadata for unique \\\n                                type ID '{}' to already be in \\\n                                the `debuginfo::TypeMap` but it \\\n@@ -785,8 +748,7 @@ pub fn type_metadata<'ll, 'tcx>(\n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        span_bug!(\n-                            usage_site_span,\n+                        bug!(\n                             \"mismatch between `Ty` and \\\n                                    `UniqueTypeId` maps in \\\n                                    `debuginfo::TypeMap`. \\\n@@ -1283,7 +1245,6 @@ impl<'ll, 'tcx> MemberDescriptionFactory<'ll, 'tcx> {\n struct StructMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n@@ -1305,7 +1266,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 let field = layout.field(cx, i);\n                 MemberDescription {\n                     name,\n-                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    type_metadata: type_metadata(cx, field.ty),\n                     offset: layout.fields.offset(i),\n                     size: field.size,\n                     align: field.align.abi,\n@@ -1322,7 +1283,6 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     struct_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n@@ -1348,7 +1308,7 @@ fn prepare_struct_metadata<'ll, 'tcx>(\n         unique_type_id,\n         struct_metadata_stub,\n         struct_metadata_stub,\n-        StructMDF(StructMemberDescriptionFactory { ty: struct_type, variant, span }),\n+        StructMDF(StructMemberDescriptionFactory { ty: struct_type, variant }),\n     )\n }\n \n@@ -1385,7 +1345,6 @@ fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) ->\n struct TupleMemberDescriptionFactory<'tcx> {\n     ty: Ty<'tcx>,\n     component_types: Vec<Ty<'tcx>>,\n-    span: Span,\n }\n \n impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n@@ -1412,7 +1371,7 @@ impl<'tcx> TupleMemberDescriptionFactory<'tcx> {\n                 };\n                 MemberDescription {\n                     name,\n-                    type_metadata: type_metadata(cx, component_type, self.span),\n+                    type_metadata: type_metadata(cx, component_type),\n                     offset: layout.fields.offset(i),\n                     size,\n                     align,\n@@ -1430,7 +1389,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n     tuple_type: Ty<'tcx>,\n     component_types: &[Ty<'tcx>],\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n     containing_scope: Option<&'ll DIScope>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tuple_name = compute_debuginfo_type_name(cx.tcx, tuple_type, false);\n@@ -1453,7 +1411,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n         TupleMDF(TupleMemberDescriptionFactory {\n             ty: tuple_type,\n             component_types: component_types.to_vec(),\n-            span,\n         }),\n     )\n }\n@@ -1465,7 +1422,6 @@ fn prepare_tuple_metadata<'ll, 'tcx>(\n struct UnionMemberDescriptionFactory<'tcx> {\n     layout: TyAndLayout<'tcx>,\n     variant: &'tcx ty::VariantDef,\n-    span: Span,\n }\n \n impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n@@ -1481,7 +1437,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                 let field = self.layout.field(cx, i);\n                 MemberDescription {\n                     name: f.name.to_string(),\n-                    type_metadata: type_metadata(cx, field.ty, self.span),\n+                    type_metadata: type_metadata(cx, field.ty),\n                     offset: Size::ZERO,\n                     size: field.size,\n                     align: field.align.abi,\n@@ -1498,7 +1454,6 @@ fn prepare_union_metadata<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     union_type: Ty<'tcx>,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n@@ -1518,7 +1473,7 @@ fn prepare_union_metadata<'ll, 'tcx>(\n         unique_type_id,\n         union_metadata_stub,\n         union_metadata_stub,\n-        UnionMDF(UnionMemberDescriptionFactory { layout: cx.layout_of(union_type), variant, span }),\n+        UnionMDF(UnionMemberDescriptionFactory { layout: cx.layout_of(union_type), variant }),\n     )\n }\n \n@@ -1573,7 +1528,6 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     layout: TyAndLayout<'tcx>,\n     tag_type_metadata: Option<&'ll DIType>,\n     common_members: Vec<Option<&'ll DIType>>,\n-    span: Span,\n }\n \n impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n@@ -1605,7 +1559,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n         // msvc, then we need to use a different, fallback encoding of the debuginfo.\n         let fallback = cpp_like_debuginfo(cx.tcx);\n         // This will always find the metadata in the type map.\n-        let self_metadata = type_metadata(cx, self.enum_type, self.span);\n+        let self_metadata = type_metadata(cx, self.enum_type);\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1617,7 +1571,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                 let variant_info = variant_info_for(index);\n                 let (variant_type_metadata, member_description_factory) =\n-                    describe_enum_variant(cx, self.layout, variant_info, self_metadata, self.span);\n+                    describe_enum_variant(cx, self.layout, variant_info, self_metadata);\n \n                 let member_descriptions = member_description_factory.create_member_descriptions(cx);\n \n@@ -1682,13 +1636,8 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     .map(|(i, _)| {\n                         let variant = self.layout.for_variant(cx, i);\n                         let variant_info = variant_info_for(i);\n-                        let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n-                            cx,\n-                            variant,\n-                            variant_info,\n-                            self_metadata,\n-                            self.span,\n-                        );\n+                        let (variant_type_metadata, member_desc_factory) =\n+                            describe_enum_variant(cx, variant, variant_info, self_metadata);\n \n                         let member_descriptions =\n                             member_desc_factory.create_member_descriptions(cx);\n@@ -1807,7 +1756,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             tag.value.size(cx).bits(),\n                             tag.value.align(cx).abi.bits() as u32,\n                             create_DIArray(DIB(cx), &tags),\n-                            type_metadata(cx, discr_enum_ty, self.span),\n+                            type_metadata(cx, discr_enum_ty),\n                             true,\n                         )\n                     };\n@@ -1818,7 +1767,6 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         dataful_variant_layout,\n                         variant_info,\n                         self_metadata,\n-                        self.span,\n                     );\n \n                     let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n@@ -1864,13 +1812,7 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             let variant = self.layout.for_variant(cx, i);\n                             let variant_info = variant_info_for(i);\n                             let (variant_type_metadata, member_desc_factory) =\n-                                describe_enum_variant(\n-                                    cx,\n-                                    variant,\n-                                    variant_info,\n-                                    self_metadata,\n-                                    self.span,\n-                                );\n+                                describe_enum_variant(cx, variant, variant_info, self_metadata);\n \n                             let member_descriptions =\n                                 member_desc_factory.create_member_descriptions(cx);\n@@ -1908,7 +1850,6 @@ struct VariantMemberDescriptionFactory<'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    span: Span,\n }\n \n impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n@@ -1923,7 +1864,7 @@ impl<'tcx> VariantMemberDescriptionFactory<'tcx> {\n                 let (size, align) = cx.size_and_align_of(ty);\n                 MemberDescription {\n                     name: name.to_string(),\n-                    type_metadata: type_metadata(cx, ty, self.span),\n+                    type_metadata: type_metadata(cx, ty),\n                     offset: self.offsets[i],\n                     size,\n                     align,\n@@ -2011,7 +1952,6 @@ fn describe_enum_variant<'ll, 'tcx>(\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n     containing_scope: &'ll DIScope,\n-    span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n     let metadata_stub = variant.map_struct_name(|variant_name| {\n         let unique_type_id = debug_context(cx)\n@@ -2033,8 +1973,7 @@ fn describe_enum_variant<'ll, 'tcx>(\n         .map(|i| (variant.field_name(i), layout.field(cx, i).ty))\n         .collect();\n \n-    let member_description_factory =\n-        VariantMDF(VariantMemberDescriptionFactory { offsets, args, span });\n+    let member_description_factory = VariantMDF(VariantMemberDescriptionFactory { offsets, args });\n \n     (metadata_stub, member_description_factory)\n }\n@@ -2044,7 +1983,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n     enum_type: Ty<'tcx>,\n     enum_def_id: DefId,\n     unique_type_id: UniqueTypeId,\n-    span: Span,\n     outer_field_tys: Vec<Ty<'tcx>>,\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let tcx = cx.tcx;\n@@ -2109,8 +2047,7 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n                 let (discriminant_size, discriminant_align) = (discr.size(cx), discr.align(cx));\n-                let discriminant_base_type_metadata =\n-                    type_metadata(cx, discr.to_ty(tcx), rustc_span::DUMMY_SP);\n+                let discriminant_base_type_metadata = type_metadata(cx, discr.to_ty(tcx));\n \n                 let item_name;\n                 let discriminant_name = match enum_type.kind() {\n@@ -2202,7 +2139,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n                 layout,\n                 tag_type_metadata: discriminant_type_metadata,\n                 common_members: vec![],\n-                span,\n             }),\n         );\n     }\n@@ -2272,11 +2208,8 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n     let outer_fields = match layout.variants {\n         Variants::Single { .. } => vec![],\n         Variants::Multiple { .. } => {\n-            let tuple_mdf = TupleMemberDescriptionFactory {\n-                ty: enum_type,\n-                component_types: outer_field_tys,\n-                span,\n-            };\n+            let tuple_mdf =\n+                TupleMemberDescriptionFactory { ty: enum_type, component_types: outer_field_tys };\n             tuple_mdf\n                 .create_member_descriptions(cx)\n                 .into_iter()\n@@ -2352,7 +2285,6 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n             layout,\n             tag_type_metadata: None,\n             common_members: outer_fields,\n-            span,\n         }),\n     )\n }\n@@ -2368,11 +2300,6 @@ fn composite_type_metadata<'ll, 'tcx>(\n     composite_type_unique_id: UniqueTypeId,\n     member_descriptions: Vec<MemberDescription<'ll>>,\n     containing_scope: Option<&'ll DIScope>,\n-\n-    // Ignore source location information as long as it\n-    // can't be reconstructed for non-local crates.\n-    _file_metadata: &'ll DIFile,\n-    _definition_span: Span,\n ) -> &'ll DICompositeType {\n     // Create the (empty) struct metadata node ...\n     let composite_type_metadata = create_struct_stub(\n@@ -2450,8 +2377,7 @@ fn compute_type_parameters<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -\n                     if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type =\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                        let actual_type_metadata =\n-                            type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n+                        let actual_type_metadata = type_metadata(cx, actual_type);\n                         let name = name.as_str();\n                         Some(unsafe {\n                             Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -2593,7 +2519,7 @@ pub fn create_global_var_metadata<'ll>(cx: &CodegenCx<'ll, '_>, def_id: DefId, g\n \n     let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n     let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx, ty::ParamEnv::reveal_all());\n-    let type_metadata = type_metadata(cx, variable_type, span);\n+    let type_metadata = type_metadata(cx, variable_type);\n     let var_name = tcx.item_name(def_id);\n     let var_name = var_name.as_str();\n     let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id)).name;\n@@ -2648,7 +2574,7 @@ fn vtable_type_metadata<'ll, 'tcx>(\n     //        things simple instead of adding some ad-hoc disambiguation scheme.\n     let vtable_type = tcx.mk_array(tcx.mk_imm_ptr(tcx.types.unit), vtable_entries.len() as u64);\n \n-    type_metadata(cx, vtable_type, rustc_span::DUMMY_SP)\n+    type_metadata(cx, vtable_type)\n }\n \n /// Creates debug information for the given vtable, which is for the"}, {"sha": "61e49fab6ff8876e7cf9b3c058c8e871b7a2f962", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a79ab6c0b50e993408e0afd33a5c5085e1fffc1/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=9a79ab6c0b50e993408e0afd33a5c5085e1fffc1", "patch": "@@ -390,7 +390,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             signature.push(if fn_abi.ret.is_ignore() {\n                 None\n             } else {\n-                Some(type_metadata(cx, fn_abi.ret.layout.ty, rustc_span::DUMMY_SP))\n+                Some(type_metadata(cx, fn_abi.ret.layout.ty))\n             });\n \n             // Arguments types\n@@ -415,15 +415,11 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         }\n                         _ => t,\n                     };\n-                    Some(type_metadata(cx, t, rustc_span::DUMMY_SP))\n+                    Some(type_metadata(cx, t))\n                 }));\n             } else {\n-                signature.extend(\n-                    fn_abi\n-                        .args\n-                        .iter()\n-                        .map(|arg| Some(type_metadata(cx, arg.layout.ty, rustc_span::DUMMY_SP))),\n-                );\n+                signature\n+                    .extend(fn_abi.args.iter().map(|arg| Some(type_metadata(cx, arg.layout.ty))));\n             }\n \n             create_DIArray(DIB(cx), &signature[..])\n@@ -453,8 +449,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if let GenericArgKind::Type(ty) = kind.unpack() {\n                             let actual_type =\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n-                            let actual_type_metadata =\n-                                type_metadata(cx, actual_type, rustc_span::DUMMY_SP);\n+                            let actual_type_metadata = type_metadata(cx, actual_type);\n                             let name = name.as_str();\n                             Some(unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n@@ -509,7 +504,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n                                 && !impl_self_ty.needs_subst()\n                             {\n-                                Some(type_metadata(cx, impl_self_ty, rustc_span::DUMMY_SP))\n+                                Some(type_metadata(cx, impl_self_ty))\n                             } else {\n                                 Some(namespace::item_namespace(cx, def.did))\n                             }\n@@ -584,7 +579,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n \n-        let type_metadata = type_metadata(self, variable_type, span);\n+        let type_metadata = type_metadata(self, variable_type);\n \n         let (argument_index, dwarf_tag) = match variable_kind {\n             ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),"}]}