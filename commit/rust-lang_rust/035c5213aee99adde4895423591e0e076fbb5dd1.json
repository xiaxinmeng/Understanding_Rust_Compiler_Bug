{"sha": "035c5213aee99adde4895423591e0e076fbb5dd1", "node_id": "C_kwDOAAsO6NoAKDAzNWM1MjEzYWVlOTlhZGRlNDg5NTQyMzU5MWUwZTA3NmZiYjVkZDE", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:00:05Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:05:52Z"}, "message": "Use usize for slice arity", "tree": {"sha": "cf22e96b60cc080f9025229f6a048e5725c8d031", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf22e96b60cc080f9025229f6a048e5725c8d031"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/035c5213aee99adde4895423591e0e076fbb5dd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/035c5213aee99adde4895423591e0e076fbb5dd1", "html_url": "https://github.com/rust-lang/rust/commit/035c5213aee99adde4895423591e0e076fbb5dd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/035c5213aee99adde4895423591e0e076fbb5dd1/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3175409682e8c2e66b04ed25169a36ab716e71d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3175409682e8c2e66b04ed25169a36ab716e71d9", "html_url": "https://github.com/rust-lang/rust/commit/3175409682e8c2e66b04ed25169a36ab716e71d9"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "46bd29e7a3f991eb11d71590ffd771319f944b47", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/035c5213aee99adde4895423591e0e076fbb5dd1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035c5213aee99adde4895423591e0e076fbb5dd1/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=035c5213aee99adde4895423591e0e076fbb5dd1", "patch": "@@ -389,25 +389,25 @@ impl SplitIntRange {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`).\n-    FixedLen(u64),\n+    FixedLen(usize),\n     /// Patterns using the `..` notation (`[x, .., y]`).\n     /// Captures any array constructor of `length >= i + j`.\n     /// In the case where `array_len` is `Some(_)`,\n     /// this indicates that we only care about the first `i` and the last `j` values of the array,\n     /// and everything in between is a wildcard `_`.\n-    VarLen(u64, u64),\n+    VarLen(usize, usize),\n }\n \n impl SliceKind {\n-    fn arity(self) -> u64 {\n+    fn arity(self) -> usize {\n         match self {\n             FixedLen(length) => length,\n             VarLen(prefix, suffix) => prefix + suffix,\n         }\n     }\n \n     /// Whether this pattern includes patterns of length `other_len`.\n-    fn covers_length(self, other_len: u64) -> bool {\n+    fn covers_length(self, other_len: usize) -> bool {\n         match self {\n             FixedLen(len) => len == other_len,\n             VarLen(prefix, suffix) => prefix + suffix <= other_len,\n@@ -419,13 +419,13 @@ impl SliceKind {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) struct Slice {\n     /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n-    array_len: Option<u64>,\n+    array_len: Option<usize>,\n     /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n     kind: SliceKind,\n }\n \n impl Slice {\n-    fn new(array_len: Option<u64>, kind: SliceKind) -> Self {\n+    fn new(array_len: Option<usize>, kind: SliceKind) -> Self {\n         let kind = match (array_len, kind) {\n             // If the middle `..` is empty, we effectively have a fixed-length pattern.\n             (Some(len), VarLen(prefix, suffix)) if prefix + suffix >= len => FixedLen(len),\n@@ -434,7 +434,7 @@ impl Slice {\n         Slice { array_len, kind }\n     }\n \n-    fn arity(self) -> u64 {\n+    fn arity(self) -> usize {\n         self.kind.arity()\n     }\n \n@@ -508,16 +508,16 @@ impl Slice {\n #[derive(Debug)]\n struct SplitVarLenSlice {\n     /// If the type is an array, this is its size.\n-    array_len: Option<u64>,\n+    array_len: Option<usize>,\n     /// The arity of the input slice.\n-    arity: u64,\n+    arity: usize,\n     /// The smallest slice bigger than any slice seen. `max_slice.arity()` is the length `L`\n     /// described above.\n     max_slice: SliceKind,\n }\n \n impl SplitVarLenSlice {\n-    fn new(prefix: u64, suffix: u64, array_len: Option<u64>) -> Self {\n+    fn new(prefix: usize, suffix: usize, array_len: Option<usize>) -> Self {\n         SplitVarLenSlice { array_len, arity: prefix + suffix, max_slice: VarLen(prefix, suffix) }\n     }\n \n@@ -687,12 +687,12 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n                 let array_len = match pat.ty.kind() {\n-                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n+                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env) as usize),\n                     ty::Slice(_) => None,\n                     _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n                 };\n-                let prefix = prefix.len() as u64;\n-                let suffix = suffix.len() as u64;\n+                let prefix = prefix.len();\n+                let suffix = suffix.len();\n                 let kind = if slice.is_some() {\n                     VarLen(prefix, suffix)\n                 } else {\n@@ -885,7 +885,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n         let all_ctors = match pcx.ty.kind() {\n             ty::Bool => smallvec![make_range(0, 1)],\n             ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n-                let len = len.eval_usize(cx.tcx, cx.param_env);\n+                let len = len.eval_usize(cx.tcx, cx.param_env) as usize;\n                 if len != 0 && cx.is_uninhabited(sub_ty) {\n                     smallvec![]\n                 } else {\n@@ -1273,7 +1273,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                     PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n                 }\n                 VarLen(prefix, _) => {\n-                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix as usize).collect();\n+                    let mut prefix: Vec<_> = subpatterns.by_ref().take(prefix).collect();\n                     if slice.array_len.is_some() {\n                         // Improves diagnostics a bit: if the type is a known-size array, instead\n                         // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`."}]}