{"sha": "02b85d722050d61b40ae9746b3bac54ab55b1056", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYjg1ZDcyMjA1MGQ2MWI0MGFlOTc0NmIzYmFjNTRhYjU1YjEwNTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-01T16:30:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-01T16:30:22Z"}, "message": "Auto merge of #81625 - jonas-schievink:rollup-mshpp2n, r=jonas-schievink\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #78641 (Let io::copy reuse BufWriter buffers)\n - #79291 (Add error message for private fn)\n - #81364 (Improve `rustc_mir_build::matches` docs)\n - #81387 (Move some tests to more reasonable directories - 3)\n - #81463 (Rename NLL* to Nll* accordingly to C-CASE)\n - #81504 (Suggest accessing field when appropriate)\n - #81529 (Fix invalid camel case suggestion involving unicode idents)\n - #81536 (Indicate both start and end of pass RSS in time-passes output)\n - #81592 (Rustdoc UI fixes)\n - #81594 (Avoid building LLVM just for llvm-dwp)\n - #81598 (Fix calling convention for CRT startup)\n - #81618 (Sync rustc_codegen_cranelift)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "250983ce89c6c4ed41b5468c4640f589ce666be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/250983ce89c6c4ed41b5468c4640f589ce666be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02b85d722050d61b40ae9746b3bac54ab55b1056", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02b85d722050d61b40ae9746b3bac54ab55b1056", "html_url": "https://github.com/rust-lang/rust/commit/02b85d722050d61b40ae9746b3bac54ab55b1056", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02b85d722050d61b40ae9746b3bac54ab55b1056/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70b18bc2cbac4712020019f5bf57c00905373205", "url": "https://api.github.com/repos/rust-lang/rust/commits/70b18bc2cbac4712020019f5bf57c00905373205", "html_url": "https://github.com/rust-lang/rust/commit/70b18bc2cbac4712020019f5bf57c00905373205"}, {"sha": "b3339ab8283d173ffd4bcbacaf799b50d3dbcdff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3339ab8283d173ffd4bcbacaf799b50d3dbcdff", "html_url": "https://github.com/rust-lang/rust/commit/b3339ab8283d173ffd4bcbacaf799b50d3dbcdff"}], "stats": {"total": 2598, "additions": 1679, "deletions": 919}, "files": [{"sha": "8bfdf23a30bf43face4b01258179a5fcac6c722a", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -4133,6 +4133,7 @@ dependencies = [\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_trait_selection\",\n  \"rustc_typeck\",\n  \"tracing\",\n ]"}, {"sha": "20c58423a0c502c7386799638a300d3f06edbbe3", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -12,6 +12,9 @@ jobs:\n       fail-fast: false\n       matrix:\n         os: [ubuntu-latest, macos-latest]\n+        env:\n+          - BACKEND: \"\"\n+          - BACKEND: --oldbe\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -51,7 +54,7 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh\n+        ./test.sh $BACKEND\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build"}, {"sha": "b241bef9d1e7ff6c03aa98ee03abe04252823a6c", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -8,6 +8,7 @@ perf.data.old\n *.string*\n /build\n /build_sysroot/sysroot_src\n+/build_sysroot/compiler-builtins\n /rust\n /rand\n /regex"}, {"sha": "19ea41563dfd6790dfc320acb280c38ebee9b9d8", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,7 +1,7 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n     \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\"],\n-    \"rust-analyzer.assist.importMergeBehaviour\": \"last\",\n+    \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.loadOutDirsFromCheck\": true,\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\","}, {"sha": "5495cfa5eaa0dc9ca414764805b45b0d288c893e", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -2,9 +2,9 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"anyhow\"\n-version = \"1.0.34\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf8dcb5b4bbaa28653b647d8c77bd4ed40183b48882e130c1f1ffb73de069fd7\"\n+checksum = \"afddf7f520a80dbf76e6f50a35bca42a2331ef227a28b3b6dc5c2e2338d114b1\"\n \n [[package]]\n name = \"ar\"\n@@ -25,15 +25,15 @@ checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n \n [[package]]\n name = \"byteorder\"\n-version = \"1.3.4\"\n+version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de\"\n+checksum = \"ae44d1a3d5a19df61dd0c8beb138458ac2a53a7ac09eba97d55592540004306b\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.62\"\n+version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1770ced377336a88a67c473594ccc14eca6f4559217c34f64aac8f83d641b40\"\n+checksum = \"4c0496836a84f8d0495758516b8621a622beb77c0fed418570e50764093ced48\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -49,16 +49,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -75,27 +75,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -105,8 +105,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,8 +123,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -135,8 +135,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"raw-cpuid\",\n@@ -145,8 +145,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.68.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8f7f8ee0b4c5007ace6de29b45505c360450b1bb\"\n+version = \"0.69.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#986b5768f9e68f1564b43f32b8a4080a6582c8ca\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -209,35 +209,35 @@ checksum = \"d7afe4a420e3fe79967a00898cc1f4db7c8a49a9333a29f8a4bd76a253d5cd04\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.6.0\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"55e2e4c765aa53a0424761bf9f41aa7a6ac1efa87238f59560640e27fca028f2\"\n+checksum = \"4fb1fa934250de4de8aef298d81c729a7d33d8c239daa3a7575e6b92bfc7313b\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.80\"\n+version = \"0.2.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d58d1b70b004888f764dfbf6a26a3b0342a1632d33968e4a179d8011c760614\"\n+checksum = \"89203f3fba0a3795506acaad8ebce3c80c0af93f994d5a1d7a0b1eeb23271929\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.5\"\n+version = \"0.6.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1090080fe06ec2648d0da3881d9453d97e71a45f00eb179af7fdd7e3f686fdb0\"\n+checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"winapi\",\n ]\n \n [[package]]\n name = \"log\"\n-version = \"0.4.11\"\n+version = \"0.4.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4fabed175da42fed1fa0746b0ea71f412aa9d35e76e95e59b192c64b9dc2bf8b\"\n+checksum = \"fcf3805d4480bb5b86070dcfeb9e2cb2ebc148adb753c5cca5f884d1d65a42b2\"\n dependencies = [\n  \"cfg-if 0.1.10\",\n ]\n@@ -272,9 +272,9 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.7\"\n+version = \"1.0.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n+checksum = \"991431c3519a3f36861882da93630ce66b52918dcf1b8e2fd66b397fc96f28df\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -333,6 +333,7 @@ dependencies = [\n  \"indexmap\",\n  \"libloading\",\n  \"object\",\n+ \"smallvec\",\n  \"target-lexicon\",\n ]\n \n@@ -362,15 +363,15 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.4.2\"\n+version = \"1.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252\"\n+checksum = \"fe0f37c9e8f3c5a4a66ad655a93c74daac4ad00c441533bf5c6e7990bb42604e\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.48\"\n+version = \"1.0.58\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc371affeffc477f42a221a1e4297aedcea33d47d19b61455588bd9d8f6b19ac\"\n+checksum = \"cc60a3d73ea6594cd712d830cc1f0390fd71542d8c8cd24e70cc54cdfd5e05d5\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -385,18 +386,18 @@ checksum = \"4ee5a98e506fb7231a304c3a1bd7c132a55016cf65001e0282480665870dfcb9\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.22\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0e9ae34b84616eedaaf1e9dd6026dbe00dcafa92aa0c8077cb69df1fcfe5e53e\"\n+checksum = \"76cc616c6abf8c8928e2fdcc0dbfab37175edd8fb49a4641066ad1364fdab146\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.22\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9ba20f23e85b10754cd195504aebf6a27e2e6cbe28c17778a0c930724628dd56\"\n+checksum = \"9be73a2caec27583d0046ef3796c3794f868a5bc813db689eed00c7631275cd1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\","}, {"sha": "3820fce6d1e0df69ff647f91965a2ac81741e230", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -9,7 +9,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n@@ -21,6 +21,7 @@ object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"rea\n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n libloading = { version = \"0.6.0\", optional = true }\n+smallvec = \"1.6.1\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/bytecodealliance/wasmtime/\"]\n@@ -37,6 +38,7 @@ libloading = { version = \"0.6.0\", optional = true }\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n+oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster."}, {"sha": "6fa5eebdc2f3deec6436b6af11067604cb380450", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,6 +1,4 @@\n-# WIP Cranelift codegen backend for rust\n-\n-> \u26a0\u26a0\u26a0 Certain kinds of FFI don't work yet. \u26a0\u26a0\u26a0\n+# Cranelift codegen backend for rust\n \n The goal of this project is to create an alternative codegen backend for the rust compiler based on [Cranelift](https://github.com/bytecodealliance/wasmtime/blob/main/cranelift).\n This has the potential to improve compilation times in debug mode.\n@@ -103,8 +101,7 @@ function jit_calc() {\n \n ## Not yet supported\n \n-* Good non-rust abi support ([several problems](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n-* Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041)\n+* Inline assembly ([no cranelift support](https://github.com/bytecodealliance/wasmtime/issues/1041))\n     * On Linux there is support for invoking an external assembler for `global_asm!` and `asm!`.\n       `llvm_asm!` will remain unimplemented forever. `asm!` doesn't yet support reg classes. You\n       have to specify specific registers instead."}, {"sha": "598ce35eceaac6dbe21bba8c9a87b9a1bce913f5", "filename": "compiler/rustc_codegen_cranelift/build.sh", "status": "modified", "additions": 40, "deletions": 14, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -3,58 +3,84 @@ set -e\n \n # Settings\n export CHANNEL=\"release\"\n-build_sysroot=1\n+build_sysroot=\"clif\"\n target_dir='build'\n+oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n             export CHANNEL=\"debug\"\n             ;;\n-        \"--without-sysroot\")\n-            build_sysroot=0\n+        \"--sysroot\")\n+            build_sysroot=$2\n+            shift\n             ;;\n         \"--target-dir\")\n             target_dir=$2\n             shift\n             ;;\n+        \"--oldbe\")\n+            oldbe='--features oldbe'\n+            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--without-sysroot] [--target-dir DIR]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            exit 1\n             ;;\n     esac\n     shift\n done\n \n # Build cg_clif\n unset CARGO_TARGET_DIR\n-export RUSTFLAGS=\"-Zrun_dsymutil=no\"\n unamestr=$(uname)\n if [[ \"$unamestr\" == 'Linux' ]]; then\n    export RUSTFLAGS='-Clink-arg=-Wl,-rpath=$ORIGIN/../lib '$RUSTFLAGS\n elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   export RUSTFLAGS='-Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n+   export RUSTFLAGS='-Csplit-debuginfo=unpacked -Clink-arg=-Wl,-rpath,@loader_path/../lib -Zosx-rpath-install-name '$RUSTFLAGS\n    dylib_ext='dylib'\n else\n    echo \"Unsupported os\"\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build --release\n+    cargo build $oldbe --release\n else\n-    cargo build\n+    cargo build $oldbe\n fi\n \n+source scripts/ext_config.sh\n+\n rm -rf \"$target_dir\"\n mkdir \"$target_dir\"\n mkdir \"$target_dir\"/bin \"$target_dir\"/lib\n ln target/$CHANNEL/cg_clif{,_build_sysroot} \"$target_dir\"/bin\n ln target/$CHANNEL/*rustc_codegen_cranelift* \"$target_dir\"/lib\n ln rust-toolchain scripts/config.sh scripts/cargo.sh \"$target_dir\"\n \n-if [[ \"$build_sysroot\" == \"1\" ]]; then\n-    echo \"[BUILD] sysroot\"\n-    export CG_CLIF_INCR_CACHE_DISABLED=1\n-    dir=$(pwd)\n-    cd \"$target_dir\"\n-    time \"$dir/build_sysroot/build_sysroot.sh\"\n+mkdir -p \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n+if [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n+    cp $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib/*.o \"$target_dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n fi\n+\n+case \"$build_sysroot\" in\n+    \"none\")\n+        ;;\n+    \"llvm\")\n+        cp -r $(rustc --print sysroot)/lib/rustlib/$TARGET_TRIPLE/lib \"$target_dir/lib/rustlib/$TARGET_TRIPLE/\"\n+        ;;\n+    \"clif\")\n+        echo \"[BUILD] sysroot\"\n+        dir=$(pwd)\n+        cd \"$target_dir\"\n+        time \"$dir/build_sysroot/build_sysroot.sh\"\n+        cp lib/rustlib/*/lib/libstd-* lib/\n+        ;;\n+    *)\n+        echo \"Unknown sysroot kind \\`$build_sysroot\\`.\"\n+        echo \"The allowed values are:\"\n+        echo \"    none A sysroot that doesn't contain the standard library\"\n+        echo \"    llvm Copy the sysroot from rustc compiled by cg_llvm\"\n+        echo \"    clif Build a new sysroot using cg_clif\"\n+        exit 1\n+esac"}, {"sha": "0da9999c172853a1fd988d5f3cb16fcb6f2ca0fc", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -2,9 +2,9 @@\n # It is not intended for manual editing.\n [[package]]\n name = \"addr2line\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7c0929d69e78dd9bf5408269919fcbcaeb2e35e5d43e5815517cdc6a8e11a423\"\n+checksum = \"a55f82cfe485775d02112886f4169bde0c5894d75e79ead7eafe7e40a25e45f7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -63,9 +63,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.36\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7cd0782e0a7da7598164153173e5a5d4d9b1da094473c98dce0ff91406112369\"\n+version = \"0.1.39\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -130,9 +128,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.17\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n+checksum = \"322f4de77956e22ed0e5032c359a0f1273f1f7f0d79bfa3b8ffbc730d7fbcc5c\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -141,9 +139,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.81\"\n+version = \"0.2.84\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1482821306169ec4d07f6aca392a4681f66c75c9918aa49641a2595db64053cb\"\n+checksum = \"1cca32fa0182e8c0989459524dc356b8f2b5c10f1b9eb521b7d182c03cf8c5ff\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "82516c98af2a2c9501ec695a40c27c1777985267", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -11,12 +11,13 @@ test = { path = \"./sysroot_src/library/test\" }\n \n alloc_system = { path = \"./alloc_system\" }\n \n-compiler_builtins = { version = \"=0.1.36\", default-features = false }\n+compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }\n rustc-std-workspace-alloc = { path = \"./sysroot_src/library/rustc-std-workspace-alloc\" }\n rustc-std-workspace-std = { path = \"./sysroot_src/library/rustc-std-workspace-std\" }\n+compiler_builtins = { path = \"./compiler-builtins\" }\n \n [profile.dev]\n lto = \"off\""}, {"sha": "282ce4a582c4b6eb2a37fb0ad6b19a7b9f07eabd", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -24,17 +24,16 @@ export CARGO_TARGET_DIR=target\n \n # Build libs\n export RUSTFLAGS=\"$RUSTFLAGS -Zforce-unstable-if-unmarked -Cpanic=abort\"\n+export __CARGO_DEFAULT_LIB_METADATA=\"cg_clif\"\n if [[ \"$1\" != \"--debug\" ]]; then\n     sysroot_channel='release'\n     # FIXME Enable incremental again once rust-lang/rust#74946 is fixed\n-    # FIXME Enable -Zmir-opt-level=2 again once it doesn't ice anymore\n-    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS\" cargo build --target \"$TARGET_TRIPLE\" --release\n+    CARGO_INCREMENTAL=0 RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=2\" cargo build --target \"$TARGET_TRIPLE\" --release\n else\n     sysroot_channel='debug'\n     cargo build --target \"$TARGET_TRIPLE\"\n fi\n \n # Copy files to sysroot\n-mkdir -p \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n ln \"target/$TARGET_TRIPLE/$sysroot_channel/deps/\"* \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"\n rm \"$dir/lib/rustlib/$TARGET_TRIPLE/lib/\"*.{rmeta,d}"}, {"sha": "d3b87e02ba8913997bb5a600f77deb8301a8edeb", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -29,4 +29,11 @@ git commit --no-gpg-sign -m \"Patch $file\"\n done\n popd\n \n-echo \"Successfully prepared libcore for building\"\n+git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/compiler-builtins has already been cloned\"\n+pushd compiler-builtins\n+git checkout -- .\n+git checkout 0.1.39\n+git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+popd\n+\n+echo \"Successfully prepared sysroot source for building\""}, {"sha": "b47efe72bce0320592bcf20a62e6d67b2e8b723f", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,5 +1,5 @@\n #!/bin/bash --verbose\n set -e\n \n-rm -rf target/ build/ build_sysroot/{sysroot_src/,target/} perf.data{,.old}\n+rm -rf target/ build/ build_sysroot/{sysroot_src/,target/,compiler-builtins/} perf.data{,.old}\n rm -rf rand/ regex/ simple-raytracer/"}, {"sha": "e14768910a9ac49d3ffb144994e67e2f5367daa9", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,35 @@\n+From 7078cca3cb614e1e82da428380b4e16fc3afef46 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 21 Jan 2021 14:46:36 +0100\n+Subject: [PATCH] Remove rotate_left from Int\n+\n+---\n+ src/int/mod.rs | 5 -----\n+ 1 file changed, 5 deletions(-)\n+\n+diff --git a/src/int/mod.rs b/src/int/mod.rs\n+index 06054c8..3bea17b 100644\n+--- a/src/int/mod.rs\n++++ b/src/int/mod.rs\n+@@ -85,7 +85,6 @@ pub trait Int:\n+     fn wrapping_sub(self, other: Self) -> Self;\n+     fn wrapping_shl(self, other: u32) -> Self;\n+     fn wrapping_shr(self, other: u32) -> Self;\n+-    fn rotate_left(self, other: u32) -> Self;\n+     fn overflowing_add(self, other: Self) -> (Self, bool);\n+     fn aborting_div(self, other: Self) -> Self;\n+     fn aborting_rem(self, other: Self) -> Self;\n+@@ -209,10 +208,6 @@ macro_rules! int_impl_common {\n+             <Self>::wrapping_shr(self, other)\n+         }\n+ \n+-        fn rotate_left(self, other: u32) -> Self {\n+-            <Self>::rotate_left(self, other)\n+-        }\n+-\n+         fn overflowing_add(self, other: Self) -> (Self, bool) {\n+             <Self>::overflowing_add(self, other)\n+         }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "f59600ebb330cc9e8a3a40444e7199667e928e1a", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -11,7 +11,8 @@ use alloc_system::System;\n #[global_allocator]\n static ALLOC: System = System;\n \n-#[link(name = \"c\")]\n+#[cfg_attr(unix, link(name = \"c\"))]\n+#[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n extern \"C\" {\n     fn puts(s: *const u8) -> i32;\n }"}, {"sha": "002ec7e2e3d7a6e3be28ffad8750d12e1b10e52c", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -532,8 +532,8 @@ pub mod intrinsics {\n }\n \n pub mod libc {\n-    #[cfg_attr(not(windows), link(name = \"c\"))]\n-    #[cfg_attr(windows, link(name = \"msvcrt\"))]\n+    #[cfg_attr(unix, link(name = \"c\"))]\n+    #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n     extern \"C\" {\n         pub fn puts(s: *const i8) -> i32;\n         pub fn printf(format: *const i8, ...) -> i32;"}, {"sha": "152041aa9ed0b90f0002be2033f16d2c73e1e4a2", "filename": "compiler/rustc_codegen_cranelift/example/mod_bench.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,7 +1,8 @@\n #![feature(start, box_syntax, core_intrinsics, lang_items)]\n #![no_std]\n \n-#[link(name = \"c\")]\n+#[cfg_attr(unix, link(name = \"c\"))]\n+#[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n extern {}\n \n #[panic_handler]"}, {"sha": "3eb10069adad61f24da73215a2b5c62b108de3ea", "filename": "compiler/rustc_codegen_cranelift/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -119,5 +119,21 @@ index 6609bc3..241b497 100644\n  \n  #[test]\n  #[should_panic(expected = \"index 0 greater than length of slice\")]\n+diff --git a/library/core/tests/num/ops.rs b/library/core/tests/num/ops.rs\n+index 9979cc8..d5d1d83 100644\n+--- a/library/core/tests/num/ops.rs\n++++ b/library/core/tests/num/ops.rs\n+@@ -238,7 +238,7 @@ macro_rules! test_shift_assign {\n+         }\n+     };\n+ }\n+-test_shift!(test_shl_defined, Shl::shl);\n+-test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n+-test_shift!(test_shr_defined, Shr::shr);\n+-test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n++//test_shift!(test_shl_defined, Shl::shl);\n++//test_shift_assign!(test_shl_assign_defined, ShlAssign::shl_assign);\n++//test_shift!(test_shr_defined, Shr::shr);\n++//test_shift_assign!(test_shr_assign_defined, ShrAssign::shr_assign);\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "a08f00d19c20fa1348bc138d4e779060b23a6e50", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1 +1 @@\n-nightly-2020-12-23\n+nightly-2021-01-30"}, {"sha": "834708aa9a6fbb3c697a2b407d4aa9caaa5ea5c0", "filename": "compiler/rustc_codegen_cranelift/scripts/config.sh", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fconfig.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -12,28 +12,6 @@ else\n    exit 1\n fi\n \n-HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n-TARGET_TRIPLE=$HOST_TRIPLE\n-#TARGET_TRIPLE=\"x86_64-pc-windows-gnu\"\n-#TARGET_TRIPLE=\"aarch64-unknown-linux-gnu\"\n-\n-linker=''\n-RUN_WRAPPER=''\n-export JIT_SUPPORTED=1\n-if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   export JIT_SUPPORTED=0\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n-      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-      linker='-Clinker=aarch64-linux-gnu-gcc'\n-      RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n-   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n-      # We are cross-compiling for Windows. Run tests in wine.\n-      RUN_WRAPPER='wine'\n-   else\n-      echo \"Unknown non-native platform\"\n-   fi\n-fi\n-\n if echo \"$RUSTC_WRAPPER\" | grep sccache; then\n echo\n echo -e \"\\x1b[1;93m=== Warning: Unset RUSTC_WRAPPER to prevent interference with sccache ===\\x1b[0m\"\n@@ -44,16 +22,14 @@ fi\n dir=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"; pwd)\n \n export RUSTC=$dir\"/bin/cg_clif\"\n-export RUSTFLAGS=$linker\" \"$RUSTFLAGS\n+\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n # FIXME remove once the atomic shim is gone\n-if [[ $(uname) == 'Darwin' ]]; then\n+if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi\n \n-export LD_LIBRARY_PATH=\"$(rustc --print sysroot)/lib\"\n+export LD_LIBRARY_PATH=\"$(rustc --print sysroot)/lib:\"$dir\"/lib\"\n export DYLD_LIBRARY_PATH=$LD_LIBRARY_PATH\n-\n-export CG_CLIF_DISPLAY_CG_TIME=1"}, {"sha": "7971f620df14b36918ac37906419e9e87236808f", "filename": "compiler/rustc_codegen_cranelift/scripts/ext_config.sh", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,27 @@\n+# Note to people running shellcheck: this file should only be sourced, not executed directly.\n+\n+# Various env vars that should only be set for the build system but not for cargo.sh\n+\n+set -e\n+\n+export CG_CLIF_DISPLAY_CG_TIME=1\n+export CG_CLIF_INCR_CACHE_DISABLED=1\n+\n+export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}\n+\n+export RUN_WRAPPER=''\n+export JIT_SUPPORTED=1\n+if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n+   export JIT_SUPPORTED=0\n+   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n+      # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n+      export RUSTFLAGS='-Clinker=aarch64-linux-gnu-gcc '$RUSTFLAGS\n+      export RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n+   elif [[ \"$TARGET_TRIPLE\" == \"x86_64-pc-windows-gnu\" ]]; then\n+      # We are cross-compiling for Windows. Run tests in wine.\n+      export RUN_WRAPPER='wine'\n+   else\n+      echo \"Unknown non-native platform\"\n+   fi\n+fi"}, {"sha": "d37b57babe612ed3ec1c4d1c9d29823414b0e845", "filename": "compiler/rustc_codegen_cranelift/scripts/tests.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftests.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -3,7 +3,7 @@\n set -e\n \n source build/config.sh\n-export CG_CLIF_INCR_CACHE_DISABLED=1\n+source scripts/ext_config.sh\n MY_RUSTC=\"$RUSTC $RUSTFLAGS -L crate=target/out --out-dir target/out -Cdebuginfo=2\"\n \n function no_sysroot_tests() {"}, {"sha": "9aab45b62e2115f3cb6d4790ad333cc0a77d71a4", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -4,10 +4,10 @@\n use std::borrow::Cow;\n \n use rustc_middle::mir;\n+use rustc_target::abi::call::PassMode;\n \n use cranelift_codegen::entity::EntityRef;\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n@@ -21,9 +21,9 @@ pub(super) fn add_arg_comment<'tcx>(\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n-    params: EmptySinglePair<Value>,\n-    pass_mode: PassMode,\n-    ty: Ty<'tcx>,\n+    params: &[Value],\n+    arg_abi_mode: PassMode,\n+    arg_layout: TyAndLayout<'tcx>,\n ) {\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n@@ -37,20 +37,28 @@ pub(super) fn add_arg_comment<'tcx>(\n     };\n \n     let params = match params {\n-        Empty => Cow::Borrowed(\"-\"),\n-        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n-        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n+        [] => Cow::Borrowed(\"-\"),\n+        [param] => Cow::Owned(format!(\"= {:?}\", param)),\n+        [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n+        params => Cow::Owned(format!(\n+            \"= {}\",\n+            params\n+                .iter()\n+                .map(ToString::to_string)\n+                .collect::<Vec<_>>()\n+                .join(\",\")\n+        )),\n     };\n \n-    let pass_mode = format!(\"{:?}\", pass_mode);\n+    let pass_mode = format!(\"{:?}\", arg_abi_mode);\n     fx.add_global_comment(format!(\n         \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n         kind = kind,\n         local = local,\n         local_field = local_field,\n         params = params,\n         pass_mode = pass_mode,\n-        ty = ty,\n+        ty = arg_layout.ty,\n     ));\n }\n "}, {"sha": "6a025f2e88ae3f8b4c022663739fca48bcc9323b", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 136, "deletions": 261, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -6,199 +6,50 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n-use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n+use cranelift_codegen::ir::AbiParam;\n+use smallvec::smallvec;\n \n use self::pass_mode::*;\n use crate::prelude::*;\n \n pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n \n-// Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n-#[rustfmt::skip]\n-pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n-    use rustc_middle::ty::subst::Subst;\n-\n-    // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n-    let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-    match *ty.kind() {\n-        ty::FnDef(..) => {\n-            // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n-            // parameters unused if they show up in the signature, but not in the `mir::Body`\n-            // (i.e. due to being inside a projection that got normalized, see\n-            // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n-            // track of a polymorphization `ParamEnv` to allow normalizing later.\n-            let mut sig = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => tcx\n-                    .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n-                    .subst(tcx, substs),\n-                _ => unreachable!(),\n-            };\n-\n-            if let ty::InstanceDef::VtableShim(..) = instance.def {\n-                // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n-                sig = sig.map_bound(|mut sig| {\n-                    let mut inputs_and_output = sig.inputs_and_output.to_vec();\n-                    inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n-                    sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n-                    sig\n-                });\n-            }\n-            sig\n-        }\n-        ty::Closure(def_id, substs) => {\n-            let sig = substs.as_closure().sig();\n-\n-            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-            sig.map_bound(|sig| {\n-                tcx.mk_fn_sig(\n-                    std::iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                    sig.output(),\n-                    sig.c_variadic,\n-                    sig.unsafety,\n-                    sig.abi,\n-                )\n-            })\n-        }\n-        ty::Generator(_, substs, _) => {\n-            let sig = substs.as_generator().poly_sig();\n-\n-            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv });\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);\n-            let pin_adt_ref = tcx.adt_def(pin_did);\n-            let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n-            let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n-\n-            sig.map_bound(|sig| {\n-                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorState, None);\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs =\n-                    tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                tcx.mk_fn_sig(\n-                    [env_ty, sig.resume_ty].iter(),\n-                    &ret_ty,\n-                    false,\n-                    rustc_hir::Unsafety::Normal,\n-                    rustc_target::spec::abi::Abi::Rust,\n-                )\n-            })\n-        }\n-        _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n-    }\n-}\n-\n-fn clif_sig_from_fn_sig<'tcx>(\n+fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n-    sig: FnSig<'tcx>,\n-    span: Span,\n-    is_vtable_fn: bool,\n-    requires_caller_location: bool,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let abi = match sig.abi {\n-        Abi::System => Abi::C,\n-        abi => abi,\n-    };\n-    let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n-        Abi::Rust => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::C | Abi::Unadjusted => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n-        Abi::RustCall => {\n-            assert_eq!(sig.inputs().len(), 2);\n-            let extra_args = match sig.inputs().last().unwrap().kind() {\n-                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n-                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-            };\n-            let mut inputs: Vec<Ty<'tcx>> = vec![sig.inputs()[0]];\n-            inputs.extend(extra_args.types());\n-            (CallConv::triple_default(triple), inputs, sig.output())\n+    let call_conv = match fn_abi.conv {\n+        Conv::Rust | Conv::C => CallConv::triple_default(triple),\n+        Conv::X86_64SysV => CallConv::SystemV,\n+        Conv::X86_64Win64 => CallConv::WindowsFastcall,\n+        Conv::ArmAapcs\n+        | Conv::Msp430Intr\n+        | Conv::PtxKernel\n+        | Conv::X86Fastcall\n+        | Conv::X86Intr\n+        | Conv::X86Stdcall\n+        | Conv::X86ThisCall\n+        | Conv::X86VectorCall\n+        | Conv::AmdGpuKernel\n+        | Conv::AvrInterrupt\n+        | Conv::AvrNonBlockingInterrupt => {\n+            todo!(\"{:?}\", fn_abi.conv)\n         }\n-        Abi::System => unreachable!(),\n-        Abi::RustIntrinsic => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n-\n-    let inputs = inputs\n-        .into_iter()\n-        .enumerate()\n-        .map(|(i, ty)| {\n-            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-            if i == 0 && is_vtable_fn {\n-                // Virtual calls turn their self param into a thin pointer.\n-                // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n-                layout = tcx\n-                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n-                    .unwrap();\n-            }\n-            let pass_mode = get_pass_mode(tcx, layout);\n-            if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n-                match pass_mode {\n-                    PassMode::NoPass | PassMode::ByVal(_) => {}\n-                    PassMode::ByRef { size: Some(size) } => {\n-                        let purpose = ArgumentPurpose::StructArgument(u32::try_from(size.bytes()).expect(\"struct too big to pass on stack\"));\n-                        return EmptySinglePair::Single(AbiParam::special(pointer_ty(tcx), purpose)).into_iter();\n-                    }\n-                    PassMode::ByValPair(_, _) | PassMode::ByRef { size: None } => {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            &format!(\n-                                \"Argument of type `{:?}` with pass mode `{:?}` is not yet supported \\\n-                                for non-rust abi `{}`. Calling this function may result in a crash.\",\n-                                layout.ty,\n-                                pass_mode,\n-                                abi,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-            pass_mode.get_param_ty(tcx).map(AbiParam::new).into_iter()\n-        })\n+    let inputs = fn_abi\n+        .args\n+        .iter()\n+        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n         .flatten();\n \n-    let (mut params, returns): (Vec<_>, Vec<_>) = match get_pass_mode(\n-        tcx,\n-        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n-    ) {\n-        PassMode::NoPass => (inputs.collect(), vec![]),\n-        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n-        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n-            inputs.collect(),\n-            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n-        ),\n-        PassMode::ByRef { size: Some(_) } => {\n-            (\n-                Some(pointer_ty(tcx)) // First param is place to put return val\n-                    .into_iter()\n-                    .map(|ty| AbiParam::special(ty, ArgumentPurpose::StructReturn))\n-                    .chain(inputs)\n-                    .collect(),\n-                vec![],\n-            )\n-        }\n-        PassMode::ByRef { size: None } => todo!(),\n-    };\n-\n-    if requires_caller_location {\n-        params.push(AbiParam::new(pointer_ty(tcx)));\n-    }\n+    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n+    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n+    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n     Signature {\n         params,\n@@ -207,30 +58,17 @@ fn clif_sig_from_fn_sig<'tcx>(\n     }\n }\n \n-pub(crate) fn get_function_name_and_sig<'tcx>(\n+pub(crate) fn get_function_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n     inst: Instance<'tcx>,\n-    support_vararg: bool,\n-) -> (String, Signature) {\n+) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    let fn_sig = tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_sig_for_fn_abi(tcx, inst));\n-    if fn_sig.c_variadic && !support_vararg {\n-        tcx.sess.span_fatal(\n-            tcx.def_span(inst.def_id()),\n-            \"Variadic function definitions are not yet supported\",\n-        );\n-    }\n-    let sig = clif_sig_from_fn_sig(\n+    clif_sig_from_fn_abi(\n         tcx,\n         triple,\n-        fn_sig,\n-        tcx.def_span(inst.def_id()),\n-        false,\n-        inst.def.requires_caller_location(tcx),\n-    );\n-    (tcx.symbol_name(inst).name.to_string(), sig)\n+        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n+    )\n }\n \n /// Instance must be monomorphized\n@@ -239,7 +77,8 @@ pub(crate) fn import_function<'tcx>(\n     module: &mut impl Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n-    let (name, sig) = get_function_name_and_sig(tcx, module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = get_function_sig(tcx, module.isa().triple(), inst);\n     module\n         .declare_function(&name, Linkage::Import, &sig)\n         .unwrap()\n@@ -263,13 +102,13 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n     pub(crate) fn lib_call(\n         &mut self,\n         name: &str,\n-        input_tys: Vec<types::Type>,\n-        output_tys: Vec<types::Type>,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature {\n-            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n+            params,\n+            returns,\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n@@ -301,16 +140,18 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n             .iter()\n             .map(|arg| {\n                 (\n-                    self.clif_type(arg.layout().ty).unwrap(),\n+                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n                     arg.load_scalar(self),\n                 )\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n+            tup.types()\n+                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n+                .collect()\n         } else {\n-            vec![self.clif_type(return_ty).unwrap()]\n+            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n         let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n         match *ret_vals {\n@@ -352,12 +193,25 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     start_block: Block,\n ) {\n+    fx.bcx.append_block_params_for_function_params(start_block);\n+\n+    fx.bcx.switch_to_block(start_block);\n+    fx.bcx.ins().nop();\n+\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, start_block);\n+    let mut block_params_iter = fx\n+        .bcx\n+        .func\n+        .dfg\n+        .block_params(start_block)\n+        .to_vec()\n+        .into_iter();\n+    let ret_place =\n+        self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n \n     // None means pass_mode == NoPass\n@@ -366,6 +220,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         Spread(Vec<Option<CValue<'tcx>>>),\n     }\n \n+    let fn_abi = fx.fn_abi.take().unwrap();\n+    let mut arg_abis_iter = fn_abi.args.iter();\n+\n     let func_params = fx\n         .mir\n         .args_iter()\n@@ -385,14 +242,18 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 };\n \n                 let mut params = Vec::new();\n-                for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n-                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_ty);\n+                for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n+                    let arg_abi = arg_abis_iter.next().unwrap();\n+                    let param =\n+                        cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_ty);\n+                let arg_abi = arg_abis_iter.next().unwrap();\n+                let param =\n+                    cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -401,13 +262,14 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     assert!(fx.caller_location.is_none());\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(\n-            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n-        );\n+        let arg_abi = arg_abis_iter.next().unwrap();\n+        fx.caller_location =\n+            Some(cvalue_for_param(fx, None, None, arg_abi, &mut block_params_iter).unwrap());\n     }\n \n-    fx.bcx.switch_to_block(start_block);\n-    fx.bcx.ins().nop();\n+    assert!(arg_abis_iter.next().is_none(), \"ArgAbi left behind\");\n+    fx.fn_abi = Some(fn_abi);\n+    assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n     #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n@@ -533,6 +395,21 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+\n     let is_cold = instance\n         .map(|inst| {\n             fx.tcx\n@@ -570,8 +447,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n-    //   v         v          v virtual calls are special cased below\n-    let (func_ref, first_arg, is_virtual_call) = match instance {\n+    //   v         v\n+    let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance {\n             def: InstanceDef::Virtual(_, idx),\n@@ -582,23 +459,19 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\n-                        \"virtual call; self arg pass mode: {:?}\",\n-                        get_pass_mode(fx.tcx, args[0].layout())\n-                    ),\n+                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0],),\n                 );\n             }\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), Single(ptr), true)\n+            (Some(method), smallvec![ptr])\n         }\n \n         // Normal call\n         Some(_) => (\n             None,\n             args.get(0)\n-                .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                .unwrap_or(Empty),\n-            false,\n+                .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                .unwrap_or(smallvec![]),\n         ),\n \n         // Indirect call\n@@ -612,23 +485,27 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             (\n                 Some(func),\n                 args.get(0)\n-                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                    .unwrap_or(Empty),\n-                false,\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                    .unwrap_or(smallvec![]),\n             )\n         }\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) =\n-        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n+        fx,\n+        &fn_abi.ret,\n+        ret_place,\n+        |fx, return_ptr| {\n+            let regular_args_count = args.len();\n             let mut call_args: Vec<Value> = return_ptr\n                 .into_iter()\n                 .chain(first_arg.into_iter())\n                 .chain(\n                     args.into_iter()\n+                        .enumerate()\n                         .skip(1)\n-                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n                         .flatten(),\n                 )\n                 .collect::<Vec<_>>();\n@@ -639,18 +516,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n-                call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                call_args.extend(\n+                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n+                        .into_iter(),\n+                );\n+                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n+            } else {\n+                assert_eq!(fn_abi.args.len(), regular_args_count);\n             }\n \n             let call_inst = if let Some(func_ref) = func_ref {\n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    is_virtual_call,\n-                    false, // calls through function pointers never pass the caller location\n-                );\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n             } else {\n@@ -660,7 +536,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             };\n \n             (call_inst, call_args)\n-        });\n+        },\n+    );\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -701,37 +578,33 @@ pub(crate) fn codegen_drop<'tcx>(\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n-    let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n+    let drop_instance = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n \n-    if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+    if let ty::InstanceDef::DropGlue(_, None) = drop_instance.def {\n         // we don't actually need to drop anything\n     } else {\n-        let drop_fn_ty = drop_fn.ty(fx.tcx, ParamEnv::reveal_all());\n-        let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-            ParamEnv::reveal_all(),\n-            drop_fn_ty.fn_sig(fx.tcx),\n-        );\n-        assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n-\n         match ty.kind() {\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    true,\n-                    false, // `drop_in_place` is never `#[track_caller]`\n-                );\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), virtual_drop, &[]);\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n             _ => {\n-                assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n+                assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n+\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), drop_instance, &[]);\n \n                 let arg_value = drop_place.place_ref(\n                     fx,\n@@ -743,17 +616,19 @@ pub(crate) fn codegen_drop<'tcx>(\n                         },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n-                if drop_fn.def.requires_caller_location(fx.tcx) {\n+                if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n-                    call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                    call_args.extend(\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                    );\n                 }\n \n-                let func_ref = fx.get_function_ref(drop_fn);\n+                let func_ref = fx.get_function_ref(drop_instance);\n                 fx.bcx.ins().call(func_ref, &call_args);\n             }\n         }"}, {"sha": "1202c23dbe7b3ba77bb3da86b85bbf0976960c14", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 294, "deletions": 127, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,140 +1,281 @@\n //! Argument passing\n \n use crate::prelude::*;\n+use crate::value_and_place::assert_assignable;\n \n-pub(super) use EmptySinglePair::*;\n+use cranelift_codegen::ir::{ArgumentExtension, ArgumentPurpose};\n+use rustc_target::abi::call::{\n+    ArgAbi, ArgAttributes, ArgExtension as RustcArgExtension, CastTarget, PassMode, Reg, RegKind,\n+};\n+use smallvec::{smallvec, SmallVec};\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef { size: Option<Size> },\n+pub(super) trait ArgAbiExt<'tcx> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]>;\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>);\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum EmptySinglePair<T> {\n-    Empty,\n-    Single(T),\n-    Pair(T, T),\n+fn reg_to_abi_param(reg: Reg) -> AbiParam {\n+    let clif_ty = match (reg.kind, reg.size.bytes()) {\n+        (RegKind::Integer, 1) => types::I8,\n+        (RegKind::Integer, 2) => types::I16,\n+        (RegKind::Integer, 4) => types::I32,\n+        (RegKind::Integer, 8) => types::I64,\n+        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Float, 4) => types::F32,\n+        (RegKind::Float, 8) => types::F64,\n+        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        _ => unreachable!(\"{:?}\", reg),\n+    };\n+    AbiParam::new(clif_ty)\n }\n \n-impl<T> EmptySinglePair<T> {\n-    pub(super) fn into_iter(self) -> EmptySinglePairIter<T> {\n-        EmptySinglePairIter(self)\n-    }\n-\n-    pub(super) fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n-        match self {\n-            Empty => Empty,\n-            Single(v) => Single(f(v)),\n-            Pair(a, b) => Pair(f(a), f(b)),\n-        }\n+fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -> AbiParam {\n+    match arg_attrs.arg_ext {\n+        RustcArgExtension::None => {}\n+        RustcArgExtension::Zext => param.extension = ArgumentExtension::Uext,\n+        RustcArgExtension::Sext => param.extension = ArgumentExtension::Sext,\n     }\n+    param\n }\n \n-pub(super) struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n-\n-impl<T> Iterator for EmptySinglePairIter<T> {\n-    type Item = T;\n+fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+    let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n+        (0, 0)\n+    } else {\n+        (\n+            cast.rest.total.bytes() / cast.rest.unit.size.bytes(),\n+            cast.rest.total.bytes() % cast.rest.unit.size.bytes(),\n+        )\n+    };\n \n-    fn next(&mut self) -> Option<T> {\n-        match std::mem::replace(&mut self.0, Empty) {\n-            Empty => None,\n-            Single(v) => Some(v),\n-            Pair(a, b) => {\n-                self.0 = Single(b);\n-                Some(a)\n-            }\n+    if cast.prefix.iter().all(|x| x.is_none()) {\n+        // Simplify to a single unit when there is no prefix and size <= unit size\n+        if cast.rest.total <= cast.rest.unit.size {\n+            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n+                (RegKind::Integer, 1) => types::I8,\n+                (RegKind::Integer, 2) => types::I16,\n+                (RegKind::Integer, 3..=4) => types::I32,\n+                (RegKind::Integer, 5..=8) => types::I64,\n+                (RegKind::Integer, 9..=16) => types::I128,\n+                (RegKind::Float, 4) => types::F32,\n+                (RegKind::Float, 8) => types::F64,\n+                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+                _ => unreachable!(\"{:?}\", cast.rest.unit),\n+            };\n+            return smallvec![AbiParam::new(clif_ty)];\n         }\n     }\n-}\n \n-impl<T: std::fmt::Debug> EmptySinglePair<T> {\n-    pub(super) fn assert_single(self) -> T {\n-        match self {\n-            Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self),\n-        }\n-    }\n+    // Create list of fields in the main structure\n+    let mut args = cast\n+        .prefix\n+        .iter()\n+        .flatten()\n+        .map(|&kind| {\n+            reg_to_abi_param(Reg {\n+                kind,\n+                size: cast.prefix_chunk_size,\n+            })\n+        })\n+        .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n+        .collect::<SmallVec<_>>();\n \n-    pub(super) fn assert_pair(self) -> (T, T) {\n-        match self {\n-            Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self),\n-        }\n+    // Append final integer\n+    if rem_bytes != 0 {\n+        // Only integers can be really split further.\n+        assert_eq!(cast.rest.unit.kind, RegKind::Integer);\n+        args.push(reg_to_abi_param(Reg {\n+            kind: RegKind::Integer,\n+            size: Size::from_bytes(rem_bytes),\n+        }));\n     }\n-}\n \n-impl PassMode {\n-    pub(super) fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef { size: Some(_) } => Single(pointer_ty(tcx)),\n-            PassMode::ByRef { size: None } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n-        }\n-    }\n+    args\n }\n \n-pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> PassMode {\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        PassMode::NoPass\n-    } else {\n-        match &layout.abi {\n-            Abi::Uninhabited => PassMode::NoPass,\n-            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n-            Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n-                    // available on x86_64. Cranelift gets confused when too many return params\n-                    // are used.\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n-                } else {\n-                    PassMode::ByValPair(a, b)\n+impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]> {\n+        match self.mode {\n+            PassMode::Ignore => smallvec![],\n+            PassMode::Direct(attrs) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => {\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                        attrs\n+                    )]\n                 }\n-            }\n-\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            Abi::Vector { .. } => {\n-                if let Some(vector_ty) = crate::intrinsics::clif_vector_type(tcx, layout) {\n-                    PassMode::ByVal(vector_ty)\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    smallvec![AbiParam::new(vector_ty)]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(attrs_a, attrs_b) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    smallvec![\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(a), attrs_a),\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(b), attrs_b),\n+                    ]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                if on_stack {\n+                    let size = u32::try_from(self.layout.size.bytes()).unwrap();\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n+                        attrs\n+                    )]\n                 } else {\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(pointer_ty(tcx)),\n+                        attrs\n+                    )]\n                 }\n             }\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: Some(extra_attrs),\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                smallvec![\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), extra_attrs),\n+                ]\n+            }\n+        }\n+    }\n \n-            Abi::Aggregate { sized: true } => PassMode::ByRef {\n-                size: Some(layout.size),\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n+        match self.mode {\n+            PassMode::Ignore => (None, vec![]),\n+            PassMode::Direct(_) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => (\n+                    None,\n+                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n+                ),\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    (None, vec![AbiParam::new(vector_ty)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(_, _) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    (None, vec![AbiParam::new(a), AbiParam::new(b)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            Abi::Aggregate { sized: false } => PassMode::ByRef { size: None },\n+            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                (\n+                    Some(AbiParam::special(\n+                        pointer_ty(tcx),\n+                        ArgumentPurpose::StructReturn,\n+                    )),\n+                    vec![],\n+                )\n+            }\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: Some(_),\n+                on_stack: _,\n+            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n+pub(super) fn to_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+    cast: CastTarget,\n+) -> SmallVec<[Value; 2]> {\n+    let (ptr, meta) = arg.force_stack(fx);\n+    assert!(meta.is_none());\n+    let mut offset = 0;\n+    cast_target_to_abi_params(cast)\n+        .into_iter()\n+        .map(|param| {\n+            let val = ptr\n+                .offset_i64(fx, offset)\n+                .load(fx, param.value_type, MemFlags::new());\n+            offset += i64::from(param.value_type.bytes());\n+            val\n+        })\n+        .collect()\n+}\n+\n+pub(super) fn from_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    block_params: &[Value],\n+    layout: TyAndLayout<'tcx>,\n+    cast: CastTarget,\n+) -> CValue<'tcx> {\n+    let abi_params = cast_target_to_abi_params(cast);\n+    let abi_param_size: u32 = abi_params\n+        .iter()\n+        .map(|param| param.value_type.bytes())\n+        .sum();\n+    let layout_size = u32::try_from(layout.size.bytes()).unwrap();\n+    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+        // specify stack slot alignment.\n+        // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+        // It may also be smaller for example when the type is a wrapper around an integer with a\n+        // larger alignment than the integer.\n+        size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,\n+        offset: None,\n+    });\n+    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let mut offset = 0;\n+    let mut block_params_iter = block_params.into_iter().copied();\n+    for param in abi_params {\n+        let val = ptr.offset_i64(fx, offset).store(\n+            fx,\n+            block_params_iter.next().unwrap(),\n+            MemFlags::new(),\n+        );\n+        offset += i64::from(param.value_type.bytes());\n+        val\n+    }\n+    assert_eq!(block_params_iter.next(), None, \"Leftover block param\");\n+    CValue::by_ref(ptr, layout)\n+}\n+\n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     arg: CValue<'tcx>,\n-) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+) -> SmallVec<[Value; 2]> {\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    match arg_abi.mode {\n+        PassMode::Ignore => smallvec![],\n+        PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],\n+        PassMode::Pair(_, _) => {\n             let (a, b) = arg.load_scalar_pair(fx);\n-            Pair(a, b)\n+            smallvec![a, b]\n         }\n-        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n-            (ptr, None) => Single(ptr.get_addr(fx)),\n-            (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n+            (ptr, None) => smallvec![ptr.get_addr(fx)],\n+            (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n         },\n     }\n }\n@@ -143,46 +284,72 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, layout);\n-\n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx.tcx);\n-    let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n+    let block_params = arg_abi\n+        .get_abi_param(fx.tcx)\n+        .into_iter()\n+        .map(|abi_param| {\n+            let block_param = block_params_iter.next().unwrap();\n+            assert_eq!(\n+                fx.bcx.func.dfg.value_type(block_param),\n+                abi_param.value_type\n+            );\n+            block_param\n+        })\n+        .collect::<SmallVec<[_; 2]>>();\n \n     #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\",\n         local,\n         local_field,\n-        block_params,\n-        pass_mode,\n-        arg_ty,\n+        &block_params,\n+        arg_abi.mode,\n+        arg_abi.layout,\n     );\n \n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = block_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n+    match arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Direct(_) => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_val(block_params[0], arg_abi.layout))\n+        }\n+        PassMode::Pair(_, _) => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_val_pair(\n+                block_params[0],\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n+        }\n+        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_ref(\n+                Pointer::new(block_params[0]),\n+                arg_abi.layout,\n+            ))\n         }\n-        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n-            Pointer::new(block_params.assert_single()),\n-            layout,\n-        )),\n-        PassMode::ByRef { size: None } => {\n-            let (ptr, meta) = block_params.assert_pair();\n-            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_ref_unsized(\n+                Pointer::new(block_params[0]),\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n         }\n     }\n }"}, {"sha": "a382963bf1ed743b0963690b2fb3800c3da3ef40", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 146, "deletions": 48, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,21 +1,57 @@\n //! Return value handling\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n-fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n-    fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n-}\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    func: &mir::Operand<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n ) -> bool {\n-    match get_pass_mode(tcx, dest_layout) {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => true,\n-        // FIXME Make it possible to return ByRef to an ssa var.\n-        PassMode::ByRef { size: _ } => false,\n+    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+\n+    // Handle special calls like instrinsics and empty drop glue.\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            .unwrap()\n+            .unwrap()\n+            .polymorphize(fx.tcx);\n+\n+        match instance.def {\n+            InstanceDef::Intrinsic(_) | InstanceDef::DropGlue(_, _) => {\n+                return true;\n+            }\n+            _ => Some(instance),\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+    match fn_abi.ret.mode {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n+        // FIXME Make it possible to return Cast and Indirect to an ssa var.\n+        PassMode::Cast(_) | PassMode::Indirect { .. } => false,\n     }\n }\n \n@@ -24,27 +60,45 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n pub(super) fn codegen_return_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n-    start_block: Block,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n-    let ret_layout = return_layout(fx);\n-    let ret_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let (ret_place, ret_param) = match ret_pass_mode {\n-        PassMode::NoPass => (CPlace::no_place(ret_layout), Empty),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+    let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore => (\n+            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n+            smallvec![],\n+        ),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n-                super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n-                Empty,\n+                super::make_local_place(\n+                    fx,\n+                    RETURN_PLACE,\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                    is_ssa,\n+                ),\n+                smallvec![],\n             )\n         }\n-        PassMode::ByRef { size: Some(_) } => {\n-            let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            let ret_param = block_params_iter.next().unwrap();\n+            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n-                Single(ret_param),\n+                CPlace::for_ptr(\n+                    Pointer::new(ret_param),\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                ),\n+                smallvec![ret_param],\n             )\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -56,9 +110,9 @@ pub(super) fn codegen_return_param<'tcx>(\n         \"ret\",\n         Some(RETURN_PLACE),\n         None,\n-        ret_param,\n-        ret_pass_mode,\n-        ret_layout.ty,\n+        &ret_param,\n+        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n     ret_place\n@@ -68,63 +122,107 @@ pub(super) fn codegen_return_param<'tcx>(\n /// returns the call return value(s) if any are written to the correct place.\n pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n     fx: &mut FunctionCx<'_, 'tcx, M>,\n-    fn_sig: FnSig<'tcx>,\n+    ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n     f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef { size: Some(_) } => match ret_place {\n+    let return_ptr = match ret_arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n+    match ret_arg_abi.mode {\n+        PassMode::Ignore => {}\n+        PassMode::Direct(_) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n             }\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n                 let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+                ret_place.write_cvalue(\n+                    fx,\n+                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n+                );\n             }\n         }\n-        PassMode::ByRef { size: Some(_) } => {}\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Cast(cast) => {\n+            if let Some(ret_place) = ret_place {\n+                let results = fx\n+                    .bcx\n+                    .inst_results(call_inst)\n+                    .into_iter()\n+                    .copied()\n+                    .collect::<SmallVec<[Value; 2]>>();\n+                let result =\n+                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+                ret_place.write_cvalue(fx, result);\n+            }\n+        }\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {}\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    match get_pass_mode(fx.tcx, return_layout(fx)) {\n-        PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n+    match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore\n+        | PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) => {\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n+        PassMode::Cast(cast) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx);\n+            let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);\n+            fx.bcx.ins().return_(&ret_vals);\n+        }\n     }\n }"}, {"sha": "62fbcfe3f7a5df6bda3f4c7b4093b6aa4ba875e7", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -40,11 +40,14 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call { destination, .. } => {\n+            TerminatorKind::Call {\n+                destination,\n+                func,\n+                args,\n+                ..\n+            } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx\n-                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n-                    if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n+                    if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }"}, {"sha": "4842628a99da7d391cc6371617961290705180f2", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -2,6 +2,8 @@\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -19,7 +21,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let (name, sig) = get_function_name_and_sig(tcx, cx.module.isa().triple(), instance, false);\n+    let name = tcx.symbol_name(instance).name.to_string();\n+    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n \n     cx.cached_context.clear();\n@@ -50,6 +53,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n         instance,\n         mir,\n+        fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,\n@@ -117,6 +121,9 @@ pub(crate) fn codegen_fn<'tcx>(\n     context.compute_domtree();\n     context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n     context.dce(cx.module.isa()).unwrap();\n+    // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n+    // invalidate it when it would change.\n+    context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n@@ -1053,7 +1060,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+        ],\n         vec![],\n         args,\n     );"}, {"sha": "be369b07fddfe35f3c41bcd4c56dc97c46ef1dce", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -6,7 +6,7 @@ extern crate rustc_interface;\n extern crate rustc_session;\n extern crate rustc_target;\n \n-use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_interface::interface;\n use rustc_session::config::ErrorOutputType;\n use rustc_session::early_error;\n@@ -39,7 +39,8 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n }\n \n fn main() {\n-    let start = std::time::Instant::now();\n+    let start_time = std::time::Instant::now();\n+    let start_rss = get_resident_set_size();\n     rustc_driver::init_rustc_env_logger();\n     let mut callbacks = CraneliftPassesCallbacks::default();\n     rustc_driver::install_ice_hook();\n@@ -61,7 +62,11 @@ fn main() {\n         })));\n         run_compiler.run()\n     });\n-    // The extra `\\t` is necessary to align this label with the others.\n-    print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n+\n+    if callbacks.time_passes {\n+        let end_rss = get_resident_set_size();\n+        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n+    }\n+\n     std::process::exit(exit_code)\n }"}, {"sha": "83e5dc6e6724d683d9db19c87b2247a5ee41ead5", "filename": "compiler/rustc_codegen_cranelift/src/bin/cg_clif_build_sysroot.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbin%2Fcg_clif_build_sysroot.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -53,10 +53,7 @@ impl rustc_driver::Callbacks for CraneliftPassesCallbacks {\n                 .unwrap()\n                 .parent()\n                 .unwrap()\n-                .parent()\n-                .unwrap()\n-                .join(\"build_sysroot\")\n-                .join(\"sysroot\"),\n+                .to_owned(),\n         );\n     }\n }"}, {"sha": "866ba90e4ae4ba5d9a73e67216f2ed7bf21872d5", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,5 +1,7 @@\n //! Replaces 128-bit operators with lang item calls where necessary\n \n+use cranelift_codegen::ir::ArgumentPurpose;\n+\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n@@ -24,41 +26,41 @@ pub(crate) fn maybe_codegen<'tcx>(\n             None\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Add => {\n-            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+        BinOp::Mul if !checked => {\n+            let val_ty = if is_signed {\n+                fx.tcx.types.i128\n             } else {\n-                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n-            });\n+                fx.tcx.types.u128\n+            };\n+            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n-        BinOp::Sub => {\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n-            } else {\n-                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n-            });\n-        }\n-        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Mul => {\n-            let res = if checked {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                if is_signed {\n-                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n-                } else {\n-                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n-                }\n-            } else {\n-                let val_ty = if is_signed {\n-                    fx.tcx.types.i128\n-                } else {\n-                    fx.tcx.types.u128\n-                };\n-                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [\n+                out_place.to_ptr().get_addr(fx),\n+                lhs.load_scalar(fx),\n+                rhs.load_scalar(fx),\n+            ];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                (BinOp::Mul, true) => \"__rust_i128_mulo\",\n+                _ => unreachable!(),\n             };\n-            Some(res)\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n         }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div => {\n             assert!(!checked);\n             if is_signed {"}, {"sha": "fbee84e09f7a6e40625dc9728b3eb4dc73e6d20c", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,4 +1,5 @@\n use rustc_index::vec::IndexVec;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -294,6 +295,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n \n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n+    pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n     pub(crate) bcx: FunctionBuilder<'clif>,\n     pub(crate) block_map: IndexVec<BasicBlock, Block>,\n@@ -319,16 +321,7 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-        assert!(!ty.still_further_specializable());\n-        self.tcx\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.tcx.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        RevealAllLayoutCx(self.tcx).layout_of(ty)\n     }\n }\n \n@@ -442,3 +435,47 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n     }\n }\n+\n+pub(crate) struct RevealAllLayoutCx<'tcx>(pub(crate) TyCtxt<'tcx>);\n+\n+impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n+        assert!(!ty.still_further_specializable());\n+        self.0\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.0.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+    }\n+}\n+\n+impl<'tcx> layout::HasTyCtxt<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+}\n+\n+impl<'tcx> rustc_target::abi::HasDataLayout for RevealAllLayoutCx<'tcx> {\n+    fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n+        &self.0.data_layout\n+    }\n+}\n+\n+impl<'tcx> layout::HasParamEnv<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'tcx> HasTargetSpec for RevealAllLayoutCx<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.0.sess.target\n+    }\n+}"}, {"sha": "df89883f0bbb7418df249bbba4a8f04e3e191171", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -281,9 +281,6 @@ pub(super) fn run_aot(\n         None\n     };\n \n-    rustc_incremental::assert_dep_graph(tcx);\n-    rustc_incremental::save_dep_graph(tcx);\n-\n     let metadata_module = if need_metadata_module {\n         let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n         let (metadata_cgu_name, tmp_file) = tcx.sess.time(\"write compressed metadata\", || {\n@@ -322,10 +319,6 @@ pub(super) fn run_aot(\n         None\n     };\n \n-    if tcx.sess.opts.output_types.should_codegen() {\n-        rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n-    }\n-\n     Box::new((\n         CodegenResults {\n             crate_name: tcx.crate_name(LOCAL_CRATE),"}, {"sha": "2d14ff2c0221d19c868dea6be771dd18106ff136", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -156,12 +156,8 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let jit_module = jit_module.as_mut().unwrap();\n             let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-            let (name, sig) = crate::abi::get_function_name_and_sig(\n-                tcx,\n-                cx.module.isa().triple(),\n-                instance,\n-                true,\n-            );\n+            let name = tcx.symbol_name(instance).name.to_string();\n+            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n             let func_id = cx\n                 .module\n                 .declare_function(&name, Linkage::Export, &sig)\n@@ -246,8 +242,8 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n-    let (name, sig) =\n-        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n     let func_id = cx\n         .module\n         .declare_function(&name, Linkage::Export, &sig)"}, {"sha": "2497f9dfdfbcf0d9ba8cc80972cce666549cd81b", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -50,12 +50,9 @@ fn predefine_mono_items<'tcx>(\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let (name, sig) = get_function_name_and_sig(\n-                        cx.tcx,\n-                        cx.module.isa().triple(),\n-                        instance,\n-                        false,\n-                    );\n+                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n+                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }"}, {"sha": "170750461cace0a60c10e8f98e0d3f848a7831ea", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -27,7 +27,6 @@ extern crate rustc_incremental;\n extern crate rustc_index;\n extern crate rustc_session;\n extern crate rustc_span;\n-extern crate rustc_symbol_mangling;\n extern crate rustc_target;\n \n // This prevents duplicating functions and statics that are already part of the host rustc process.\n@@ -90,7 +89,8 @@ mod prelude {\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n-        self, FloatTy, FnSig, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable, UintTy,\n+        self, FloatTy, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut,\n+        TypeFoldable, UintTy,\n     };\n     pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n \n@@ -256,8 +256,6 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         };\n         let res = driver::codegen_crate(tcx, metadata, need_metadata_module, config);\n \n-        rustc_symbol_mangling::test::report_symbol_names(tcx);\n-\n         res\n     }\n \n@@ -279,18 +277,14 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     ) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n \n-        let _timer = sess.prof.generic_activity(\"link_crate\");\n-\n-        sess.time(\"linking\", || {\n-            let target_cpu = crate::target_triple(sess).to_string();\n-            link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n-                sess,\n-                &codegen_results,\n-                outputs,\n-                &codegen_results.crate_name.as_str(),\n-                &target_cpu,\n-            );\n-        });\n+        let target_cpu = crate::target_triple(sess).to_string();\n+        link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n+            sess,\n+            &codegen_results,\n+            outputs,\n+            &codegen_results.crate_name.as_str(),\n+            &target_cpu,\n+        );\n \n         Ok(())\n     }\n@@ -345,7 +339,12 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let mut isa_builder = cranelift_codegen::isa::lookup(target_triple).unwrap();\n+    let variant = if cfg!(feature = \"oldbe\") {\n+        cranelift_codegen::isa::BackendVariant::Legacy\n+    } else {\n+        cranelift_codegen::isa::BackendVariant::MachInst\n+    };\n+    let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`.\n     isa_builder.enable(\"nehalem\").unwrap();"}, {"sha": "b193cea877dad493996c9bbee8cf1a1011345bc3", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -69,8 +69,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n-        let (main_name, main_sig) =\n-            get_function_name_and_sig(tcx, m.isa().triple(), instance, false);\n+        let main_name = tcx.symbol_name(instance).name.to_string();\n+        let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n         let main_func_id = m\n             .declare_function(&main_name, Linkage::Import, &main_sig)\n             .unwrap();"}, {"sha": "d1d2b3b872a4b10002163eafe76e6eb664c88151", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -280,7 +280,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                     (val, fx.bcx.ins().bor(has_underflow, has_overflow))\n                 }\n                 types::I64 => {\n-                    //let val = fx.easy_call(\"__mulodi4\", &[lhs, rhs, overflow_ptr], types::I64);\n                     let val = fx.bcx.ins().imul(lhs, rhs);\n                     let has_overflow = if !signed {\n                         let val_hi = fx.bcx.ins().umulhi(lhs, rhs);"}, {"sha": "f4a15ab12d5112fbc8b9c324f65ca2c7adf19e4e", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -61,7 +61,9 @@ use cranelift_codegen::{\n     write::{FuncWriter, PlainWriter},\n };\n \n+use rustc_middle::ty::layout::FnAbiExt;\n use rustc_session::config::OutputType;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -78,11 +80,8 @@ impl CommentWriter {\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n                 format!(\n-                    \"sig {:?}\",\n-                    tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        crate::abi::fn_sig_for_fn_abi(tcx, instance)\n-                    )\n+                    \"abi {:?}\",\n+                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n                 ),\n                 String::new(),\n             ]"}, {"sha": "765604e0f984ec343bba1fd8398a3b6b6008fc83", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -334,7 +334,9 @@ impl<'tcx> CPlace<'tcx> {\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n-            size: u32::try_from(layout.size.bytes()).unwrap(),\n+            // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+            // specify stack slot alignment.\n+            size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n         CPlace {\n@@ -450,64 +452,6 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n         from: CValue<'tcx>,\n     ) {\n-        fn assert_assignable<'tcx>(\n-            fx: &FunctionCx<'_, 'tcx, impl Module>,\n-            from_ty: Ty<'tcx>,\n-            to_ty: Ty<'tcx>,\n-        ) {\n-            match (from_ty.kind(), to_ty.kind()) {\n-                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n-                | (\n-                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n-                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n-                ) => {\n-                    assert_assignable(fx, a, b);\n-                }\n-                (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_ty.fn_sig(fx.tcx),\n-                    );\n-                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_ty.fn_sig(fx.tcx),\n-                    );\n-                    assert_eq!(\n-                        from_sig, to_sig,\n-                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                        from_sig, to_sig, fx,\n-                    );\n-                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n-                }\n-                (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n-                    for (from, to) in from_traits.iter().zip(to_traits) {\n-                        let from = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                        let to = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n-                        assert_eq!(\n-                            from, to,\n-                            \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                            from_traits, to_traits, fx,\n-                        );\n-                    }\n-                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n-                }\n-                _ => {\n-                    assert_eq!(\n-                        from_ty,\n-                        to_ty,\n-                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                        from_ty,\n-                        to_ty,\n-                        fx,\n-                    );\n-                }\n-            }\n-        }\n-\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n@@ -556,7 +500,9 @@ impl<'tcx> CPlace<'tcx> {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n-                        size: src_ty.bytes(),\n+                        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+                        // specify stack slot alignment.\n+                        size: (src_ty.bytes() + 15) / 16 * 16,\n                         offset: None,\n                     });\n                     let ptr = Pointer::stack_slot(stack_slot);\n@@ -794,3 +740,62 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n }\n+\n+#[track_caller]\n+pub(crate) fn assert_assignable<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) {\n+    match (from_ty.kind(), to_ty.kind()) {\n+        (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+        | (\n+            ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+            ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+        ) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n+        | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::FnPtr(_), ty::FnPtr(_)) => {\n+            let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                ParamEnv::reveal_all(),\n+                from_ty.fn_sig(fx.tcx),\n+            );\n+            let to_sig = fx\n+                .tcx\n+                .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_ty.fn_sig(fx.tcx));\n+            assert_eq!(\n+                from_sig, to_sig,\n+                \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                from_sig, to_sig, fx,\n+            );\n+            // fn(&T) -> for<'l> fn(&'l T) is allowed\n+        }\n+        (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n+            for (from, to) in from_traits.iter().zip(to_traits) {\n+                let from = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                assert_eq!(\n+                    from, to,\n+                    \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                    from_traits, to_traits, fx,\n+                );\n+            }\n+            // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+        }\n+        _ => {\n+            assert_eq!(\n+                from_ty, to_ty,\n+                \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                from_ty, to_ty, fx,\n+            );\n+        }\n+    }\n+}"}, {"sha": "5ab10e0e905c7b9ce3fb60fbe37bd7f443642706", "filename": "compiler/rustc_codegen_cranelift/test.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_cranelift%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Ftest.sh?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,9 +1,7 @@\n #!/bin/bash\n set -e\n \n-export RUSTFLAGS=\"-Zrun_dsymutil=no\"\n-\n-./build.sh --without-sysroot \"$@\"\n+./build.sh --sysroot none \"$@\"\n \n rm -r target/out || true\n "}, {"sha": "0fc11c286f89979a03fc3e33bcf114c8282209f7", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -12,7 +12,7 @@ use crate::{CachedModuleCodegen, CrateInfo, MemFlags, ModuleCodegen, ModuleKind}\n \n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::{par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n@@ -595,6 +595,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let mut cgu_reuse = Vec::new();\n     let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n     let mut total_codegen_time = Duration::new(0, 0);\n+    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n \n     for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n@@ -669,7 +670,16 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n+    if tcx.sess.time_passes() {\n+        let end_rss = get_resident_set_size();\n+\n+        print_time_passes_entry(\n+            \"codegen_to_LLVM_IR\",\n+            total_codegen_time,\n+            start_rss.unwrap(),\n+            end_rss,\n+        );\n+    }\n \n     ongoing_codegen.check_for_errors(tcx.sess);\n "}, {"sha": "9a85b9d02c9953893949d1f0419d1acdbb82fa26", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -555,13 +555,16 @@ impl<'a> TimingGuard<'a> {\n \n #[must_use]\n pub struct VerboseTimingGuard<'a> {\n-    start_and_message: Option<(Instant, String)>,\n+    start_and_message: Option<(Instant, Option<usize>, String)>,\n     _guard: TimingGuard<'a>,\n }\n \n impl<'a> VerboseTimingGuard<'a> {\n     pub fn start(message: Option<String>, _guard: TimingGuard<'a>) -> Self {\n-        VerboseTimingGuard { _guard, start_and_message: message.map(|msg| (Instant::now(), msg)) }\n+        VerboseTimingGuard {\n+            _guard,\n+            start_and_message: message.map(|msg| (Instant::now(), get_resident_set_size(), msg)),\n+        }\n     }\n \n     #[inline(always)]\n@@ -573,25 +576,42 @@ impl<'a> VerboseTimingGuard<'a> {\n \n impl Drop for VerboseTimingGuard<'_> {\n     fn drop(&mut self) {\n-        if let Some((start, ref message)) = self.start_and_message {\n-            print_time_passes_entry(true, &message[..], start.elapsed());\n+        if let Some((start_time, start_rss, ref message)) = self.start_and_message {\n+            let end_rss = get_resident_set_size();\n+            print_time_passes_entry(&message[..], start_time.elapsed(), start_rss, end_rss);\n         }\n     }\n }\n \n-pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n-    if !do_it {\n-        return;\n-    }\n-\n-    let mem_string = match get_resident() {\n-        Some(n) => {\n-            let mb = n as f64 / 1_000_000.0;\n-            format!(\"; rss: {}MB\", mb.round() as usize)\n+pub fn print_time_passes_entry(\n+    what: &str,\n+    dur: Duration,\n+    start_rss: Option<usize>,\n+    end_rss: Option<usize>,\n+) {\n+    let rss_to_mb = |rss| (rss as f64 / 1_000_000.0).round() as usize;\n+\n+    let mem_string = match (start_rss, end_rss) {\n+        (Some(start_rss), Some(end_rss)) => {\n+            // It's tempting to add the change in RSS from start to end, but its somewhat confusing\n+            // and misleading when looking at time-passes output. Consider two adjacent entries:\n+            //\n+            // time:  10.000; rss start:  1000MB, end:  1000MB, change:     0MB     pass1\n+            // time:   5.000; rss start:  2000MB, end:  2000MB, change:     0MB     pass2\n+            //\n+            // If you're looking for jumps in RSS based on the change column, you miss the fact\n+            // that a 1GB jump happened between pass1 and pass2 (supposing pass1 and pass2 actually\n+            // occur sequentially and pass1 isn't just nested within pass2). It's easy to imagine\n+            // someone missing this or being confused by the fact that the change is zero.\n+\n+            format!(\"; rss: {:>5}MB -> {:>5}MB\", rss_to_mb(start_rss), rss_to_mb(end_rss))\n         }\n-        None => String::new(),\n+        (Some(start_rss), None) => format!(\"; rss start: {:>5}MB\", rss_to_mb(start_rss)),\n+        (None, Some(end_rss)) => format!(\"; rss end: {:5>}MB\", rss_to_mb(end_rss)),\n+        (None, None) => String::new(),\n     };\n-    println!(\"time: {}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n+\n+    println!(\"time: {:>7}{}\\t{}\", duration_to_secs_str(dur), mem_string, what);\n }\n \n // Hack up our own formatting for the duration to make it easier for scripts\n@@ -603,7 +623,7 @@ pub fn duration_to_secs_str(dur: std::time::Duration) -> String {\n // Memory reporting\n cfg_if! {\n     if #[cfg(windows)] {\n-        fn get_resident() -> Option<usize> {\n+        pub fn get_resident_set_size() -> Option<usize> {\n             use std::mem::{self, MaybeUninit};\n             use winapi::shared::minwindef::DWORD;\n             use winapi::um::processthreadsapi::GetCurrentProcess;\n@@ -621,7 +641,7 @@ cfg_if! {\n             }\n         }\n     } else if #[cfg(unix)] {\n-        fn get_resident() -> Option<usize> {\n+        pub fn get_resident_set_size() -> Option<usize> {\n             let field = 1;\n             let contents = fs::read(\"/proc/self/statm\").ok()?;\n             let contents = String::from_utf8(contents).ok()?;\n@@ -630,7 +650,7 @@ cfg_if! {\n             Some(npages * 4096)\n         }\n     } else {\n-        fn get_resident() -> Option<usize> {\n+        pub fn get_resident_set_size() -> Option<usize> {\n             None\n         }\n     }"}, {"sha": "8295e88f75ac70779d3d3c763f0ebecc5a129c19", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -16,7 +16,7 @@ pub extern crate rustc_plugin_impl as plugin;\n \n use rustc_ast as ast;\n use rustc_codegen_ssa::{traits::CodegenBackend, CodegenResults};\n-use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorReported, PResult};\n@@ -1312,7 +1312,8 @@ pub fn init_env_logger(env: &str) {\n }\n \n pub fn main() -> ! {\n-    let start = Instant::now();\n+    let start_time = Instant::now();\n+    let start_rss = get_resident_set_size();\n     init_rustc_env_logger();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();\n@@ -1330,7 +1331,11 @@ pub fn main() -> ! {\n             .collect::<Vec<_>>();\n         RunCompiler::new(&args, &mut callbacks).run()\n     });\n-    // The extra `\\t` is necessary to align this label with the others.\n-    print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n+\n+    if callbacks.time_passes {\n+        let end_rss = get_resident_set_size();\n+        print_time_passes_entry(\"total\", start_time.elapsed(), start_rss, end_rss);\n+    }\n+\n     process::exit(exit_code)\n }"}, {"sha": "1546c1e559f5765ece48462a571be4f77f4e7d55", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferOk, InferResult, NLLRegionVariableOrigin};\n+use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n@@ -644,7 +644,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n     }\n \n     fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n-        let origin = NLLRegionVariableOrigin::Existential { from_forall };\n+        let origin = NllRegionVariableOrigin::Existential { from_forall };\n         self.infcx.next_nll_region_var(origin)\n     }\n \n@@ -654,7 +654,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n         self.infcx.next_nll_region_var_in_universe(\n-            NLLRegionVariableOrigin::Existential { from_forall: false },\n+            NllRegionVariableOrigin::Existential { from_forall: false },\n             universe,\n         )\n     }"}, {"sha": "2abb1c725b914dceeb1dba72e7ea3f5d64a442a9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1661,6 +1661,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"exp_found {:?} terr {:?}\", exp_found, terr);\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n+            self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n             self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n         }\n \n@@ -1819,6 +1820,53 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_accessing_field_where_appropriate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        debug!(\n+            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n+            cause, exp_found\n+        );\n+        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n+            if expected_def.is_enum() {\n+                return;\n+            }\n+\n+            if let Some((name, ty)) = expected_def\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n+                .map(|field| (field.ident.name, field.ty(self.tcx, expected_substs)))\n+                .find(|(_, ty)| ty::TyS::same_type(ty, exp_found.found))\n+            {\n+                if let ObligationCauseCode::Pattern { span: Some(span), .. } = cause.code {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        let suggestion = if expected_def.is_struct() {\n+                            format!(\"{}.{}\", snippet, name)\n+                        } else if expected_def.is_union() {\n+                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                        } else {\n+                            return;\n+                        };\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"you might have meant to use field `{}` of type `{}`\",\n+                                name, ty\n+                            ),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n     /// suggests it.\n     fn suggest_as_ref_where_appropriate(\n@@ -2342,7 +2390,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 format!(\" for capture of `{}` by closure\", var_name)\n             }\n-            infer::NLL(..) => bug!(\"NLL variable found in lexical phase\"),\n+            infer::Nll(..) => bug!(\"NLL variable found in lexical phase\"),\n         };\n \n         struct_span_err!("}, {"sha": "09eecd715f03b3809d1741cf6a84a70fc0aa2b50", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -458,11 +458,11 @@ pub enum RegionVariableOrigin {\n \n     /// This origin is used for the inference variables that we create\n     /// during NLL region processing.\n-    NLL(NLLRegionVariableOrigin),\n+    Nll(NllRegionVariableOrigin),\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum NLLRegionVariableOrigin {\n+pub enum NllRegionVariableOrigin {\n     /// During NLL region processing, we create variables for free\n     /// regions that we encounter in the function signature and\n     /// elsewhere. This origin indices we've got one of those.\n@@ -1078,17 +1078,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n-        self.next_region_var(RegionVariableOrigin::NLL(origin))\n+    pub fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.next_region_var(RegionVariableOrigin::Nll(origin))\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n     pub fn next_nll_region_var_in_universe(\n         &self,\n-        origin: NLLRegionVariableOrigin,\n+        origin: NllRegionVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> ty::Region<'tcx> {\n-        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n+        self.next_region_var_in_universe(RegionVariableOrigin::Nll(origin), universe)\n     }\n \n     pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n@@ -1770,7 +1770,7 @@ impl RegionVariableOrigin {\n             | LateBoundRegion(a, ..)\n             | UpvarRegion(_, a) => a,\n             BoundRegionInCoherence(_) => rustc_span::DUMMY_SP,\n-            NLL(..) => bug!(\"NLL variable used with `span`\"),\n+            Nll(..) => bug!(\"NLL variable used with `span`\"),\n         }\n     }\n }"}, {"sha": "121dde325f74bafe5ee079e6964038c807e8996d", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -56,8 +56,19 @@ declare_lint! {\n \n declare_lint_pass!(NonCamelCaseTypes => [NON_CAMEL_CASE_TYPES]);\n \n+/// Some unicode characters *have* case, are considered upper case or lower case, but they *can't*\n+/// be upper cased or lower cased. For the purposes of the lint suggestion, we care about being able\n+/// to change the char's case.\n fn char_has_case(c: char) -> bool {\n-    c.is_lowercase() || c.is_uppercase()\n+    let mut l = c.to_lowercase();\n+    let mut u = c.to_uppercase();\n+    while let Some(l) = l.next() {\n+        match u.next() {\n+            Some(u) if l != u => return true,\n+            _ => {}\n+        }\n+    }\n+    u.next().is_some()\n }\n \n fn is_camel_case(name: &str) -> bool {\n@@ -138,6 +149,8 @@ impl NonCamelCaseTypes {\n                         to_camel_case(name),\n                         Applicability::MaybeIncorrect,\n                     );\n+                } else {\n+                    err.span_label(ident.span, \"should have an UpperCamelCase name\");\n                 }\n \n                 err.emit();\n@@ -299,6 +312,8 @@ impl NonSnakeCase {\n                     } else {\n                         err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n                     }\n+                } else {\n+                    err.span_label(ident.span, \"should have a snake_case name\");\n                 }\n \n                 err.emit();\n@@ -477,6 +492,8 @@ impl NonUpperCaseGlobals {\n                         uc,\n                         Applicability::MaybeIncorrect,\n                     );\n+                } else {\n+                    err.span_label(ident.span, \"should have an UPPER_CASE name\");\n                 }\n \n                 err.emit();"}, {"sha": "06e3f4b91f61facac2bb585cf37f34e8cf84ae33", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -5,7 +5,7 @@ use std::collections::VecDeque;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::NLLRegionVariableOrigin;\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n     Statement, StatementKind, TerminatorKind,\n@@ -258,7 +258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n             &self.body,\n             borrow_region,\n-            NLLRegionVariableOrigin::FreeRegion,\n+            NllRegionVariableOrigin::FreeRegion,\n             |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n         );\n "}, {"sha": "058986593a41b9759c4c7f8c3e66a60cf2700361", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -3,7 +3,7 @@\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n-    error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n+    error_reporting::unexpected_hidden_region_diagnostic, NllRegionVariableOrigin,\n };\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::Subst;\n@@ -75,13 +75,13 @@ crate enum RegionErrorKind<'tcx> {\n         /// The region element that erroneously must be outlived by `longer_fr`.\n         error_element: RegionElement,\n         /// The origin of the placeholder region.\n-        fr_origin: NLLRegionVariableOrigin,\n+        fr_origin: NllRegionVariableOrigin,\n     },\n \n     /// Any other lifetime error.\n     RegionError {\n         /// The origin of the region.\n-        fr_origin: NLLRegionVariableOrigin,\n+        fr_origin: NllRegionVariableOrigin,\n         /// The region that should outlive `shorter_fr`.\n         longer_fr: RegionVid,\n         /// The region that should be shorter, but we can't prove it.\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     pub(in crate::borrow_check) fn report_region_error(\n         &mut self,\n         fr: RegionVid,\n-        fr_origin: NLLRegionVariableOrigin,\n+        fr_origin: NllRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         outlives_suggestion: &mut OutlivesSuggestionBuilder,\n     ) {"}, {"sha": "86d9db294bf713d52e3b9a16eaa825e3eda1afba", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -5,7 +5,7 @@\n \n use super::{OutlivesConstraint, RegionInferenceContext};\n use crate::borrow_check::type_check::Locations;\n-use rustc_infer::infer::NLLRegionVariableOrigin;\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::TyCtxt;\n use std::io::{self, Write};\n \n@@ -20,7 +20,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         writeln!(out, \"| Free Region Mapping\")?;\n \n         for region in self.regions() {\n-            if let NLLRegionVariableOrigin::FreeRegion = self.definitions[region].origin {\n+            if let NllRegionVariableOrigin::FreeRegion = self.definitions[region].origin {\n                 let classification = self.universal_regions.region_classification(region).unwrap();\n                 let outlived_by = self.universal_region_relations.regions_outlived_by(region);\n                 writeln!("}, {"sha": "bbd512fd36050aebcd2d7fafff603deaa4734124", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n-use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n+use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n     ConstraintCategory, Local, Location, ReturnConstraint,\n@@ -143,9 +143,9 @@ pub(crate) struct AppliedMemberConstraint {\n \n pub(crate) struct RegionDefinition<'tcx> {\n     /// What kind of variable is this -- a free region? existential\n-    /// variable? etc. (See the `NLLRegionVariableOrigin` for more\n+    /// variable? etc. (See the `NllRegionVariableOrigin` for more\n     /// info.)\n-    pub(in crate::borrow_check) origin: NLLRegionVariableOrigin,\n+    pub(in crate::borrow_check) origin: NllRegionVariableOrigin,\n \n     /// Which universe is this region variable defined in? This is\n     /// most often `ty::UniverseIndex::ROOT`, but when we encounter\n@@ -451,7 +451,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let scc = self.constraint_sccs.scc(variable);\n \n             match self.definitions[variable].origin {\n-                NLLRegionVariableOrigin::FreeRegion => {\n+                NllRegionVariableOrigin::FreeRegion => {\n                     // For each free, universally quantified region X:\n \n                     // Add all nodes in the CFG to liveness constraints\n@@ -462,7 +462,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.scc_values.add_element(scc, variable);\n                 }\n \n-                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                NllRegionVariableOrigin::Placeholder(placeholder) => {\n                     // Each placeholder region is only visible from\n                     // its universe `ui` and its extensions. So we\n                     // can't just add it into `scc` unless the\n@@ -480,8 +480,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NLLRegionVariableOrigin::RootEmptyRegion\n-                | NLLRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::RootEmptyRegion\n+                | NllRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1348,7 +1348,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n-                NLLRegionVariableOrigin::FreeRegion => {\n+                NllRegionVariableOrigin::FreeRegion => {\n                     // Go through each of the universal regions `fr` and check that\n                     // they did not grow too large, accumulating any requirements\n                     // for our caller into the `outlives_requirements` vector.\n@@ -1360,12 +1360,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     );\n                 }\n \n-                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                NllRegionVariableOrigin::Placeholder(placeholder) => {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::RootEmptyRegion\n-                | NLLRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::RootEmptyRegion\n+                | NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1449,7 +1449,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 errors_buffer.push(RegionErrorKind::RegionError {\n                     longer_fr: *longer_fr,\n                     shorter_fr: *shorter_fr,\n-                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    fr_origin: NllRegionVariableOrigin::FreeRegion,\n                     is_reported: true,\n                 });\n             }\n@@ -1459,16 +1459,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // a more complete picture on how to separate this responsibility.\n         for (fr, fr_definition) in self.definitions.iter_enumerated() {\n             match fr_definition.origin {\n-                NLLRegionVariableOrigin::FreeRegion => {\n+                NllRegionVariableOrigin::FreeRegion => {\n                     // handled by polonius above\n                 }\n \n-                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                NllRegionVariableOrigin::Placeholder(placeholder) => {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::RootEmptyRegion\n-                | NLLRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::RootEmptyRegion\n+                | NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1516,7 +1516,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 errors_buffer.push(RegionErrorKind::RegionError {\n                     longer_fr,\n                     shorter_fr: representative,\n-                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    fr_origin: NllRegionVariableOrigin::FreeRegion,\n                     is_reported: true,\n                 });\n             }\n@@ -1539,7 +1539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 errors_buffer.push(RegionErrorKind::RegionError {\n                     longer_fr,\n                     shorter_fr,\n-                    fr_origin: NLLRegionVariableOrigin::FreeRegion,\n+                    fr_origin: NllRegionVariableOrigin::FreeRegion,\n                     is_reported: !error_reported,\n                 });\n \n@@ -1597,7 +1597,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let blame_span_category = self.find_outlives_blame_span(\n                     body,\n                     longer_fr,\n-                    NLLRegionVariableOrigin::FreeRegion,\n+                    NllRegionVariableOrigin::FreeRegion,\n                     shorter_fr,\n                 );\n \n@@ -1656,7 +1656,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n             error_element,\n-            fr_origin: NLLRegionVariableOrigin::Placeholder(placeholder),\n+            fr_origin: NllRegionVariableOrigin::Placeholder(placeholder),\n         });\n     }\n \n@@ -1732,7 +1732,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n \n         match self.definitions[r2].origin {\n-            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+            NllRegionVariableOrigin::Placeholder(placeholder) => {\n                 let universe1 = self.definitions[r1].universe;\n                 debug!(\n                     \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n@@ -1741,9 +1741,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NLLRegionVariableOrigin::RootEmptyRegion\n-            | NLLRegionVariableOrigin::FreeRegion\n-            | NLLRegionVariableOrigin::Existential { .. } => false,\n+            NllRegionVariableOrigin::RootEmptyRegion\n+            | NllRegionVariableOrigin::FreeRegion\n+            | NllRegionVariableOrigin::Existential { .. } => false,\n         }\n     }\n \n@@ -1771,7 +1771,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n-        fr1_origin: NLLRegionVariableOrigin,\n+        fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n         let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n@@ -1933,7 +1933,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .definitions\n                 .iter_enumerated()\n                 .find_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n+                    NllRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n                     _ => None,\n                 })\n                 .unwrap(),\n@@ -1965,7 +1965,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n-        from_region_origin: NLLRegionVariableOrigin,\n+        from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, bool, Span) {\n         debug!(\n@@ -2059,11 +2059,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // and here we prefer to blame the source (the y = x statement).\n         let blame_source = match from_region_origin {\n-            NLLRegionVariableOrigin::FreeRegion\n-            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::RootEmptyRegion\n-            | NLLRegionVariableOrigin::Placeholder(_)\n-            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n+            NllRegionVariableOrigin::FreeRegion\n+            | NllRegionVariableOrigin::Existential { from_forall: false } => true,\n+            NllRegionVariableOrigin::RootEmptyRegion\n+            | NllRegionVariableOrigin::Placeholder(_)\n+            | NllRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n \n         let find_region = |i: &usize| {\n@@ -2144,8 +2144,8 @@ impl<'tcx> RegionDefinition<'tcx> {\n         // `init_universal_regions`.\n \n         let origin = match rv_origin {\n-            RegionVariableOrigin::NLL(origin) => origin,\n-            _ => NLLRegionVariableOrigin::Existential { from_forall: false },\n+            RegionVariableOrigin::Nll(origin) => origin,\n+            _ => NllRegionVariableOrigin::Existential { from_forall: false },\n         };\n \n         Self { origin, universe, external_name: None }"}, {"sha": "9377473befe32c011b7c92d8374972222ae3c666", "filename": "compiler/rustc_mir/src/borrow_check/renumber.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Frenumber.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::{Body, Location, PlaceElem, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n@@ -15,7 +15,7 @@ pub fn renumber_mir<'tcx>(\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n-    let mut visitor = NLLVisitor { infcx };\n+    let mut visitor = NllVisitor { infcx };\n \n     for body in promoted.iter_mut() {\n         visitor.visit_body(body);\n@@ -33,16 +33,16 @@ where\n     debug!(\"renumber_regions(value={:?})\", value);\n \n     infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n-        let origin = NLLRegionVariableOrigin::Existential { from_forall: false };\n+        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n         infcx.next_nll_region_var(origin)\n     })\n }\n \n-struct NLLVisitor<'a, 'tcx> {\n+struct NllVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n     fn renumber_regions<T>(&mut self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }"}, {"sha": "3ba06bdd6e05f9b97a06d5199634cb9354e48ffc", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -16,7 +16,7 @@ use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n-    InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin,\n+    InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n };\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n@@ -872,7 +872,7 @@ impl MirTypeckRegionConstraints<'tcx> {\n         match self.placeholder_index_to_region.get(placeholder_index) {\n             Some(&v) => v,\n             None => {\n-                let origin = NLLRegionVariableOrigin::Placeholder(placeholder);\n+                let origin = NllRegionVariableOrigin::Placeholder(placeholder);\n                 let region = infcx.next_nll_region_var_in_universe(origin, placeholder.universe);\n                 self.placeholder_index_to_region.push(region);\n                 region"}, {"sha": "6665eb5ad5fffcc21d2200ba9fe6caba1a360e88", "filename": "compiler/rustc_mir/src/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,5 +1,5 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Const, Ty};\n@@ -64,7 +64,7 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n \n     fn next_existential_region_var(&mut self, from_forall: bool) -> ty::Region<'tcx> {\n         if self.borrowck_context.is_some() {\n-            let origin = NLLRegionVariableOrigin::Existential { from_forall };\n+            let origin = NllRegionVariableOrigin::Existential { from_forall };\n             self.infcx.next_nll_region_var(origin)\n         } else {\n             self.infcx.tcx.lifetimes.re_erased\n@@ -81,7 +81,7 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n         self.infcx.next_nll_region_var_in_universe(\n-            NLLRegionVariableOrigin::Existential { from_forall: false },\n+            NllRegionVariableOrigin::Existential { from_forall: false },\n             universe,\n         )\n     }"}, {"sha": "4b1acc1cd105e5efdedcf488cdb2d8767ed27cb7", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n@@ -393,7 +393,7 @@ struct UniversalRegionsBuilder<'cx, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n+const FR: NllRegionVariableOrigin = NllRegionVariableOrigin::FreeRegion;\n \n impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     fn build(self) -> UniversalRegions<'tcx> {\n@@ -486,7 +486,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let root_empty = self\n             .infcx\n-            .next_nll_region_var(NLLRegionVariableOrigin::RootEmptyRegion)\n+            .next_nll_region_var(NllRegionVariableOrigin::RootEmptyRegion)\n             .to_region_vid();\n \n         UniversalRegions {\n@@ -647,15 +647,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n trait InferCtxtExt<'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n-        origin: NLLRegionVariableOrigin,\n+        origin: NllRegionVariableOrigin,\n         value: T,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>;\n \n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n-        origin: NLLRegionVariableOrigin,\n+        origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n         value: ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n@@ -673,7 +673,7 @@ trait InferCtxtExt<'tcx> {\n impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n-        origin: NLLRegionVariableOrigin,\n+        origin: NllRegionVariableOrigin,\n         value: T,\n     ) -> T\n     where\n@@ -684,7 +684,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n \n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n-        origin: NLLRegionVariableOrigin,\n+        origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n         value: ty::Binder<T>,\n         indices: &mut UniversalRegionIndices<'tcx>,"}, {"sha": "90fcee075b5ac47e06b25209d5ef59c1c8f7c326", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// visible through borrow checking. False edges ensure that the CFG as\n     /// seen by borrow checking doesn't encode this. False edges are added:\n     ///\n-    /// * From each prebinding block to the next prebinding block.\n-    /// * From each otherwise block to the next prebinding block.\n+    /// * From each pre-binding block to the next pre-binding block.\n+    /// * From each otherwise block to the next pre-binding block.\n     crate fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n@@ -630,10 +630,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n #[derive(Debug)]\n pub(super) struct Candidate<'pat, 'tcx> {\n-    /// `Span` of the original pattern that gave rise to this candidate\n+    /// [`Span`] of the original pattern that gave rise to this candidate.\n     span: Span,\n \n-    /// This `Candidate` has a guard.\n+    /// Whether this `Candidate` has a guard.\n     has_guard: bool,\n \n     /// All of these must be satisfied...\n@@ -645,14 +645,15 @@ pub(super) struct Candidate<'pat, 'tcx> {\n     /// ...and these types asserted...\n     ascriptions: Vec<Ascription<'tcx>>,\n \n-    /// ... and if this is non-empty, one of these subcandidates also has to match ...\n+    /// ...and if this is non-empty, one of these subcandidates also has to match...\n     subcandidates: Vec<Candidate<'pat, 'tcx>>,\n \n-    /// ...and the guard must be evaluated, if false branch to Block...\n+    /// ...and the guard must be evaluated; if it's `false` then branch to `otherwise_block`.\n     otherwise_block: Option<BasicBlock>,\n \n-    /// ...and the blocks for add false edges between candidates\n+    /// The block before the `bindings` have been established.\n     pre_binding_block: Option<BasicBlock>,\n+    /// The pre-binding block of the next candidate.\n     next_candidate_pre_binding_block: Option<BasicBlock>,\n }\n \n@@ -737,26 +738,27 @@ crate struct MatchPair<'pat, 'tcx> {\n     pattern: &'pat Pat<'tcx>,\n }\n \n+/// See [`Test`] for more.\n #[derive(Clone, Debug, PartialEq)]\n enum TestKind<'tcx> {\n-    /// Test the branches of enum.\n+    /// Test what enum variant a value is.\n     Switch {\n-        /// The enum being tested\n+        /// The enum type being tested.\n         adt_def: &'tcx ty::AdtDef,\n         /// The set of variants that we should create a branch for. We also\n         /// create an additional \"otherwise\" case.\n         variants: BitSet<VariantIdx>,\n     },\n \n-    /// Test what value an `integer`, `bool` or `char` has.\n+    /// Test what value an integer, `bool`, or `char` has.\n     SwitchInt {\n         /// The type of the value that we're testing.\n         switch_ty: Ty<'tcx>,\n         /// The (ordered) set of values that we test for.\n         ///\n         /// For integers and `char`s we create a branch to each of the values in\n         /// `options`, as well as an \"otherwise\" branch for all other values, even\n-        /// in the (rare) case that options is exhaustive.\n+        /// in the (rare) case that `options` is exhaustive.\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n@@ -776,17 +778,21 @@ enum TestKind<'tcx> {\n     /// Test whether the value falls within an inclusive or exclusive range\n     Range(PatRange<'tcx>),\n \n-    /// Test length of the slice is equal to len\n+    /// Test that the length of the slice is equal to `len`.\n     Len { len: u64, op: BinOp },\n }\n \n+/// A test to perform to determine which [`Candidate`] matches a value.\n+///\n+/// [`Test`] is just the test to perform; it does not include the value\n+/// to be tested.\n #[derive(Debug)]\n crate struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n-/// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n+/// `ArmHasGuard` is a wrapper around a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n crate struct ArmHasGuard(crate bool);\n@@ -801,27 +807,27 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// candidates are sorted such that the first item in the list\n     /// has the highest priority. When a candidate is found to match\n     /// the value, we will set and generate a branch to the appropriate\n-    /// prebinding block.\n+    /// pre-binding block.\n     ///\n     /// If we find that *NONE* of the candidates apply, we branch to the\n     /// `otherwise_block`, setting it to `Some` if required. In principle, this\n     /// means that the input list was not exhaustive, though at present we\n     /// sometimes are not smart enough to recognize all exhaustive inputs.\n     ///\n-    /// It might be surprising that the input can be inexhaustive.\n+    /// It might be surprising that the input can be non-exhaustive.\n     /// Indeed, initially, it is not, because all matches are\n     /// exhaustive in Rust. But during processing we sometimes divide\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n-    /// under control. See `test_candidates` for more details.\n+    /// under control. See [`Builder::test_candidates`] for more details.\n     ///\n-    /// If `fake_borrows` is Some, then places which need fake borrows\n+    /// If `fake_borrows` is `Some`, then places which need fake borrows\n     /// will be added to it.\n     ///\n     /// For an example of a case where we set `otherwise_block`, even for an\n-    /// exhaustive match consider:\n+    /// exhaustive match, consider:\n     ///\n-    /// ```rust\n+    /// ```\n     /// match x {\n     ///     (true, true) => (),\n     ///     (_, false) => (),\n@@ -830,8 +836,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// ```\n     ///\n     /// For this match, we check if `x.0` matches `true` (for the first\n-    /// arm). If that's false, we check `x.1`. If it's `true` we check if\n-    /// `x.0` matches `false` (for the third arm). In the (impossible at\n+    /// arm). If it doesn't match, we check `x.1`. If `x.1` is `true` we check\n+    /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n     fn match_candidates<'pat>(\n@@ -938,26 +944,31 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n     }\n \n-    /// Link up matched candidates. For example, if we have something like\n-    /// this:\n+    /// Link up matched candidates.\n+    ///\n+    /// For example, if we have something like this:\n     ///\n     /// ```rust\n     /// ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond1 => ...\n     /// Some(x) => ...\n-    /// Some(x) if cond => ...\n+    /// Some(x) if cond2 => ...\n     /// ...\n     /// ```\n     ///\n     /// We generate real edges from:\n-    /// * `start_block` to the `prebinding_block` of the first pattern,\n-    /// * the otherwise block of the first pattern to the second pattern,\n-    /// * the otherwise block of the third pattern to the a block with an\n-    ///   Unreachable terminator.\n     ///\n-    /// As well as that we add fake edges from the otherwise blocks to the\n-    /// prebinding block of the next candidate in the original set of\n+    /// * `start_block` to the [pre-binding block] of the first pattern,\n+    /// * the [otherwise block] of the first pattern to the second pattern,\n+    /// * the [otherwise block] of the third pattern to a block with an\n+    ///   [`Unreachable` terminator](TerminatorKind::Unreachable).\n+    ///\n+    /// In addition, we add fake edges from the otherwise blocks to the\n+    /// pre-binding block of the next candidate in the original set of\n     /// candidates.\n+    ///\n+    /// [pre-binding block]: Candidate::pre_binding_block\n+    /// [otherwise block]: Candidate::otherwise_block\n     fn select_matched_candidates(\n         &mut self,\n         matched_candidates: &mut [&mut Candidate<'_, 'tcx>],\n@@ -1044,7 +1055,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// forwards to [Builder::test_candidates].\n     ///\n     /// Given a pattern `(P | Q, R | S)` we (in principle) generate a CFG like\n-    /// so\n+    /// so:\n     ///\n     /// ```text\n     /// [ start ]\n@@ -1214,31 +1225,35 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// This is the most subtle part of the matching algorithm. At\n     /// this point, the input candidates have been fully simplified,\n     /// and so we know that all remaining match-pairs require some\n-    /// sort of test. To decide what test to do, we take the highest\n-    /// priority candidate (last one in the list) and extract the\n-    /// first match-pair from the list. From this we decide what kind\n-    /// of test is needed using `test`, defined in the `test` module.\n+    /// sort of test. To decide what test to perform, we take the highest\n+    /// priority candidate (the first one in the list, as of January 2021)\n+    /// and extract the first match-pair from the list. From this we decide\n+    /// what kind of test is needed using [`Builder::test`], defined in the\n+    /// [`test` module](mod@test).\n     ///\n     /// *Note:* taking the first match pair is somewhat arbitrary, and\n     /// we might do better here by choosing more carefully what to\n     /// test.\n     ///\n     /// For example, consider the following possible match-pairs:\n     ///\n-    /// 1. `x @ Some(P)` -- we will do a `Switch` to decide what variant `x` has\n-    /// 2. `x @ 22` -- we will do a `SwitchInt`\n-    /// 3. `x @ 3..5` -- we will do a range test\n+    /// 1. `x @ Some(P)` -- we will do a [`Switch`] to decide what variant `x` has\n+    /// 2. `x @ 22` -- we will do a [`SwitchInt`] to decide what value `x` has\n+    /// 3. `x @ 3..5` -- we will do a [`Range`] test to decide what range `x` falls in\n     /// 4. etc.\n     ///\n+    /// [`Switch`]: TestKind::Switch\n+    /// [`SwitchInt`]: TestKind::SwitchInt\n+    /// [`Range`]: TestKind::Range\n+    ///\n     /// Once we know what sort of test we are going to perform, this\n-    /// Tests may also help us with other candidates. So we walk over\n+    /// test may also help us winnow down our candidates. So we walk over\n     /// the candidates (from high to low priority) and check. This\n     /// gives us, for each outcome of the test, a transformed list of\n-    /// candidates. For example, if we are testing the current\n-    /// variant of `x.0`, and we have a candidate `{x.0 @ Some(v), x.1\n-    /// @ 22}`, then we would have a resulting candidate of `{(x.0 as\n-    /// Some).0 @ v, x.1 @ 22}`. Note that the first match-pair is now\n-    /// simpler (and, in fact, irrefutable).\n+    /// candidates. For example, if we are testing `x.0`'s variant,\n+    /// and we have a candidate `(x.0 @ Some(v), x.1 @ 22)`,\n+    /// then we would have a resulting candidate of `((x.0 as Some).0 @ v, x.1 @ 22)`.\n+    /// Note that the first match-pair is now simpler (and, in fact, irrefutable).\n     ///\n     /// But there may also be candidates that the test just doesn't\n     /// apply to. The classical example involves wildcards:\n@@ -1268,7 +1283,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// is trivially NP-complete:\n     ///\n     /// ```rust\n-    ///     match (var0, var1, var2, var3, ..) {\n+    ///     match (var0, var1, var2, var3, ...) {\n     ///         (true, _, _, false, true, ...) => false,\n     ///         (_, true, true, false, _, ...) => false,\n     ///         (false, _, false, false, _, ...) => false,\n@@ -1283,7 +1298,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// That kind of exponential worst-case might not occur in practice, but\n     /// our simplistic treatment of constants and guards would make it occur\n-    /// in very common situations - for example #29740:\n+    /// in very common situations - for example [#29740]:\n     ///\n     /// ```rust\n     /// match x {\n@@ -1294,13 +1309,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// }\n     /// ```\n     ///\n-    /// Here we first test the match-pair `x @ \"foo\"`, which is an `Eq` test.\n+    /// [#29740]: https://github.com/rust-lang/rust/issues/29740\n+    ///\n+    /// Here we first test the match-pair `x @ \"foo\"`, which is an [`Eq` test].\n+    ///\n+    /// [`Eq` test]: TestKind::Eq\n     ///\n     /// It might seem that we would end up with 2 disjoint candidate\n-    /// sets, consisting of the first candidate or the other 3, but our\n-    /// algorithm doesn't reason about \"foo\" being distinct from the other\n+    /// sets, consisting of the first candidate or the other two, but our\n+    /// algorithm doesn't reason about `\"foo\"` being distinct from the other\n     /// constants; it considers the latter arms to potentially match after\n-    /// both outcomes, which obviously leads to an exponential amount\n+    /// both outcomes, which obviously leads to an exponential number\n     /// of tests.\n     ///\n     /// To avoid these kinds of problems, our algorithm tries to ensure\n@@ -1312,16 +1331,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// After we perform our test, we branch into the appropriate candidate\n     /// set and recurse with `match_candidates`. These sub-matches are\n-    /// obviously inexhaustive - as we discarded our otherwise set - so\n+    /// obviously non-exhaustive - as we discarded our otherwise set - so\n     /// we set their continuation to do `match_candidates` on the\n-    /// \"unmatched\" set (which is again inexhaustive).\n+    /// \"unmatched\" set (which is again non-exhaustive).\n     ///\n     /// If you apply this to the above test, you basically wind up\n     /// with an if-else-if chain, testing each candidate in turn,\n     /// which is precisely what we want.\n     ///\n     /// In addition to avoiding exponential-time blowups, this algorithm\n-    /// also has nice property that each guard and arm is only generated\n+    /// also has the nice property that each guard and arm is only generated\n     /// once.\n     fn test_candidates<'pat, 'b, 'c>(\n         &mut self,"}, {"sha": "126fb957a6a9945e2c5ff0c00b7e5cf005fa32cf", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -23,7 +23,7 @@ use std::cmp::Ordering;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n-    /// It is a bug to call this with a simplifiable pattern.\n+    /// It is a bug to call this with a not-fully-simplified pattern.\n     pub(super) fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {"}, {"sha": "85e584d5435076cdd7d19edb804b20f929acc9fe", "filename": "compiler/rustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2FCargo.toml?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -13,4 +13,5 @@ rustc_typeck = { path = \"../rustc_typeck\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n tracing = \"0.1\""}, {"sha": "3fade2c4437263ca0634b7bdea556f125cd01578", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -18,15 +18,17 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::mir::abstract_const::Node as ACNode;\n use rustc_middle::span_bug;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::{self, Const, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n+use rustc_trait_selection::traits::const_evaluatable::{self, AbstractConst};\n \n use std::marker::PhantomData;\n use std::ops::ControlFlow;\n@@ -112,19 +114,35 @@ where\n                 ty.visit_with(self)\n             }\n             ty::PredicateKind::RegionOutlives(..) => ControlFlow::CONTINUE,\n-            ty::PredicateKind::ConstEvaluatable(..)\n+            ty::PredicateKind::ConstEvaluatable(defs, substs)\n                 if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n             {\n-                // FIXME(const_evaluatable_checked): If the constant used here depends on a\n-                // private function we may have to do something here...\n-                //\n-                // For now, let's just pretend that everything is fine.\n+                let tcx = self.def_id_visitor.tcx();\n+                if let Ok(Some(ct)) = AbstractConst::new(tcx, defs, substs) {\n+                    self.visit_abstract_const_expr(tcx, ct)?;\n+                }\n                 ControlFlow::CONTINUE\n             }\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n \n+    fn visit_abstract_const_expr(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+    ) -> ControlFlow<V::BreakTy> {\n+        const_evaluatable::walk_abstract_const(tcx, ct, |node| match node {\n+            ACNode::Leaf(leaf) => {\n+                let leaf = leaf.subst(tcx, ct.substs);\n+                self.visit_const(leaf)\n+            }\n+            ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n+                ControlFlow::CONTINUE\n+            }\n+        })\n+    }\n+\n     fn visit_predicates(\n         &mut self,\n         predicates: ty::GenericPredicates<'tcx>,\n@@ -241,6 +259,15 @@ where\n             ty.super_visit_with(self)\n         }\n     }\n+\n+    fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        self.visit_ty(c.ty)?;\n+        let tcx = self.def_id_visitor.tcx();\n+        if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n+            self.visit_abstract_const_expr(tcx, ct)?;\n+        }\n+        ControlFlow::CONTINUE\n+    }\n }\n \n fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {"}, {"sha": "f7c0bafff05b4c8ba416709edebf5ad3d29c5d82", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -6,7 +6,7 @@ pub mod auto_trait;\n mod chalk_fulfill;\n pub mod codegen;\n mod coherence;\n-mod const_evaluatable;\n+pub mod const_evaluatable;\n mod engine;\n pub mod error_reporting;\n mod fulfill;"}, {"sha": "65bc2fcf00ae02dc9f8ff23f5cdf7f213e79c401", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -117,7 +117,7 @@ impl<W: Write> BufWriter<W> {\n     /// \"successfully written\" (by returning nonzero success values from\n     /// `write`), any 0-length writes from `inner` must be reported as i/o\n     /// errors from this method.\n-    pub(super) fn flush_buf(&mut self) -> io::Result<()> {\n+    pub(in crate::io) fn flush_buf(&mut self) -> io::Result<()> {\n         /// Helper struct to ensure the buffer is updated after all the writes\n         /// are complete. It tracks the number of written bytes and drains them\n         /// all from the front of the buffer when dropped.\n@@ -243,6 +243,18 @@ impl<W: Write> BufWriter<W> {\n         &self.buf\n     }\n \n+    /// Returns a mutable reference to the internal buffer.\n+    ///\n+    /// This can be used to write data directly into the buffer without triggering writers\n+    /// to the underlying writer.\n+    ///\n+    /// That the buffer is a `Vec` is an implementation detail.\n+    /// Callers should not modify the capacity as there currently is no public API to do so\n+    /// and thus any capacity changes would be unexpected by the user.\n+    pub(in crate::io) fn buffer_mut(&mut self) -> &mut Vec<u8> {\n+        &mut self.buf\n+    }\n+\n     /// Returns the number of bytes the internal buffer can hold without flushing.\n     ///\n     /// # Examples"}, {"sha": "3780f2044cb9039659c0d0262a78e4b6c9210e12", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,4 +1,4 @@\n-use crate::io::{self, ErrorKind, Read, Write};\n+use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -40,7 +40,7 @@ use crate::mem::MaybeUninit;\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+pub fn copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n@@ -54,14 +54,82 @@ where\n     }\n }\n \n-/// The general read-write-loop implementation of\n-/// `io::copy` that is used when specializations are not available or not applicable.\n-pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> io::Result<u64>\n+/// The userspace read-write-loop implementation of `io::copy` that is used when\n+/// OS-specific specializations for copy offloading are not available or not applicable.\n+pub(crate) fn generic_copy<R: ?Sized, W: ?Sized>(reader: &mut R, writer: &mut W) -> Result<u64>\n where\n     R: Read,\n     W: Write,\n {\n-    let mut buf = MaybeUninit::<[u8; super::DEFAULT_BUF_SIZE]>::uninit();\n+    BufferedCopySpec::copy_to(reader, writer)\n+}\n+\n+/// Specialization of the read-write loop that either uses a stack buffer\n+/// or reuses the internal buffer of a BufWriter\n+trait BufferedCopySpec: Write {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n+}\n+\n+impl<W: Write + ?Sized> BufferedCopySpec for W {\n+    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        stack_buffer_copy(reader, writer)\n+    }\n+}\n+\n+impl<I: Write> BufferedCopySpec for BufWriter<I> {\n+    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n+        if writer.capacity() < DEFAULT_BUF_SIZE {\n+            return stack_buffer_copy(reader, writer);\n+        }\n+\n+        // FIXME: #42788\n+        //\n+        //   - This creates a (mut) reference to a slice of\n+        //     _uninitialized_ integers, which is **undefined behavior**\n+        //\n+        //   - Only the standard library gets to soundly \"ignore\" this,\n+        //     based on its privileged knowledge of unstable rustc\n+        //     internals;\n+        unsafe {\n+            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n+            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n+        }\n+\n+        let mut len = 0;\n+\n+        loop {\n+            let buf = writer.buffer_mut();\n+            let spare_cap = buf.spare_capacity_mut();\n+\n+            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n+                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n+                    Ok(0) => return Ok(len), // EOF reached\n+                    Ok(bytes_read) => {\n+                        assert!(bytes_read <= spare_cap.len());\n+                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // will have initialized these bytes. And we just checked that the number\n+                        // of bytes is within the buffer capacity.\n+                        unsafe { buf.set_len(buf.len() + bytes_read) };\n+                        len += bytes_read as u64;\n+                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n+                        // This will occur if the reader returns short reads\n+                        continue;\n+                    }\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n+            writer.flush_buf()?;\n+        }\n+    }\n+}\n+\n+fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n+    reader: &mut R,\n+    writer: &mut W,\n+) -> Result<u64> {\n+    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n     // FIXME: #42788\n     //\n     //   - This creates a (mut) reference to a slice of"}, {"sha": "7632eaf872a5b01e67a7c55e37e01b0eca9d9f9b", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1,5 +1,8 @@\n+use crate::cmp::{max, min};\n use crate::io::prelude::*;\n-use crate::io::{copy, empty, repeat, sink, Empty, Repeat, SeekFrom, Sink};\n+use crate::io::{\n+    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n+};\n \n #[test]\n fn copy_copies() {\n@@ -11,6 +14,51 @@ fn copy_copies() {\n     assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n }\n \n+struct ShortReader {\n+    cap: usize,\n+    read_size: usize,\n+    observed_buffer: usize,\n+}\n+\n+impl Read for ShortReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let bytes = min(self.cap, self.read_size);\n+        self.cap -= bytes;\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(bytes)\n+    }\n+}\n+\n+struct WriteObserver {\n+    observed_buffer: usize,\n+}\n+\n+impl Write for WriteObserver {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn copy_specializes_bufwriter() {\n+    let cap = 117 * 1024;\n+    let buf_sz = 16 * 1024;\n+    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n+    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n+    assert_eq!(\n+        copy(&mut r, &mut w).unwrap(),\n+        cap as u64,\n+        \"expected the whole capacity to be copied\"\n+    );\n+    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n+    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n+}\n+\n #[test]\n fn sink_sinks() {\n     let mut s = sink();"}, {"sha": "b6929f59395764f18e6e958e06246ec004249c34", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -284,6 +284,7 @@\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n+#![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n@@ -327,6 +328,7 @@\n #![feature(unsafe_cell_raw_get)]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]\n+#![feature(vec_spare_capacity)]\n #![feature(wake_trait)]\n // NB: the above list is sorted to minimize merge conflicts.\n #![default_lib_allocator]"}, {"sha": "cbd3366b189ed890a09e6647c5a0d3e5de0aef04", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -74,26 +74,24 @@ macro_rules! compat_fn {\n             /// used, and would remove it.\n             #[used]\n             #[link_section = \".CRT$XCU\"]\n-            static INIT_TABLE_ENTRY: fn() = init;\n+            static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n \n-            fn init() {\n+            unsafe extern \"C\" fn init() {\n                 // There is no locking here. This code is executed before main() is entered, and\n                 // is guaranteed to be single-threaded.\n                 //\n                 // DO NOT do anything interesting or complicated in this function! DO NOT call\n                 // any Rust functions or CRT functions, if those functions touch any global state,\n                 // because this function runs during global initialization. For example, DO NOT\n                 // do any dynamic allocation, don't call LoadLibrary, etc.\n-                unsafe {\n-                    let module_name: *const u8 = concat!($module, \"\\0\").as_ptr();\n-                    let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n-                    let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n-                    if !module_handle.is_null() {\n-                        match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n-                            0 => {}\n-                            n => {\n-                                PTR = Some(mem::transmute::<usize, F>(n));\n-                            }\n+                let module_name: *const u8 = concat!($module, \"\\0\").as_ptr();\n+                let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n+                let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n+                if !module_handle.is_null() {\n+                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n+                        0 => {}\n+                        n => {\n+                            PTR = Some(mem::transmute::<usize, F>(n));\n                         }\n                     }\n                 }"}, {"sha": "34002019a6f1ec3e5ccdf85354882ea1b384507f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1050,8 +1050,10 @@ impl Step for Assemble {\n             builder.copy(&lld_install.join(\"bin\").join(&src_exe), &libdir_bin.join(&dst_exe));\n         }\n \n-        // Similarly, copy `llvm-dwp` into libdir for Split DWARF.\n-        {\n+        // Similarly, copy `llvm-dwp` into libdir for Split DWARF. Only copy it when the LLVM\n+        // backend is used to avoid unnecessarily building LLVM and because LLVM is not checked\n+        // out by default when the LLVM backend is not enabled.\n+        if builder.config.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\")) {\n             let src_exe = exe(\"llvm-dwp\", target_compiler.host);\n             let dst_exe = exe(\"rust-llvm-dwp\", target_compiler.host);\n             let llvm_config_bin = builder.ensure(native::Llvm { target: target_compiler.host });"}, {"sha": "4dbe7a37fcdc8f4c052830aef99288c122d3ef43", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1695,15 +1695,6 @@ function defocusSearchBar() {\n \n             search.innerHTML = output;\n             showSearchResults(search);\n-            var tds = search.getElementsByTagName(\"td\");\n-            var td_width = 0;\n-            if (tds.length > 0) {\n-                td_width = tds[0].offsetWidth;\n-            }\n-            var width = search.offsetWidth - 40 - td_width;\n-            onEachLazy(search.getElementsByClassName(\"desc\"), function(e) {\n-                e.style.width = width + \"px\";\n-            });\n             initSearchNav();\n             var elems = document.getElementById(\"titles\").childNodes;\n             elems[0].onclick = function() { printTab(0); };"}, {"sha": "d50fda278bd7cda0fffe5f98bd92aed1c312b745", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -1425,7 +1425,7 @@ h4 > .notable-traits {\n \t\tmargin-left: 0px;\n \t}\n \n-\t#main {\n+\t#main, #search {\n \t\tmargin-top: 45px;\n \t\tpadding: 0;\n \t}\n@@ -1579,7 +1579,7 @@ h4 > .notable-traits {\n \t}\n }\n \n-@media (max-width: 416px) {\n+@media (max-width: 464px) {\n \t#titles, #titles > button {\n \t\theight: 73px;\n \t}"}, {"sha": "354c14a756aafde3c8eeca97aeea4653dd0d8f66", "filename": "src/test/ui/array-slice-vec/issue-18425.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-18425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-18425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fissue-18425.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-18425.rs"}, {"sha": "3d18542acdcb2f9dccc5663de9b5d28d852d31f2", "filename": "src/test/ui/associated-types/issue-18655.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-18655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-18655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-18655.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-18655.rs"}, {"sha": "b9eb41b6ea6e58735ba4b72a824bde6ab86af357", "filename": "src/test/ui/associated-types/issue-22037.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-22037.rs"}, {"sha": "615628558f08bce45cc63662a94b11c07afd96d2", "filename": "src/test/ui/associated-types/issue-22037.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-22037.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-22037.stderr"}, {"sha": "70b4ab2537626dc3dae0833bc5009ef53500294a", "filename": "src/test/ui/async-await/issue-73541-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-73541-2.rs"}, {"sha": "75d769c4e154565d3d4177d7f54fb69e9e5a26e5", "filename": "src/test/ui/async-await/issue-73541-2.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-73541-2.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-73541-2.stderr"}, {"sha": "b73e85974a8e1b70495cada40bebd081e2d9c52e", "filename": "src/test/ui/borrowck/issue-33819.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-33819.rs"}, {"sha": "8bc2d82cd3f14ed5fbbeda988dbfabd5add48419", "filename": "src/test/ui/borrowck/issue-33819.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-33819.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-33819.stderr"}, {"sha": "9f457fbd346cd56252a76b30d88d75b98df13672", "filename": "src/test/ui/const-generics/const_evaluatable_checked/eval-privacy.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,31 @@\n+#![crate_type = \"lib\"]\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+pub struct Const<const U: u8>;\n+\n+pub trait Trait {\n+    type AssocTy;\n+    fn assoc_fn() -> Self::AssocTy;\n+}\n+\n+impl<const U: u8> Trait for Const<U>\n+//~^ WARN private type\n+//~| WARN this was previously\n+//~| WARN private type\n+//~| WARN this was previously\n+\n+where\n+    Const<{ my_const_fn(U) }>: ,\n+{\n+    type AssocTy = Const<{ my_const_fn(U) }>;\n+    //~^ ERROR private type\n+    fn assoc_fn() -> Self::AssocTy {\n+        Const\n+    }\n+}\n+\n+const fn my_const_fn(val: u8) -> u8 {\n+    // body of this function doesn't matter\n+    val\n+}"}, {"sha": "842c22c5c677535791c0acef791decbc1d72448a", "filename": "src/test/ui/const-generics/const_evaluatable_checked/eval-privacy.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Feval-privacy.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,43 @@\n+warning: private type `fn(u8) -> u8 {my_const_fn}` in public interface (error E0446)\n+  --> $DIR/eval-privacy.rs:12:1\n+   |\n+LL | / impl<const U: u8> Trait for Const<U>\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = note: `#[warn(private_in_public)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+warning: private type `fn(u8) -> u8 {my_const_fn}` in public interface (error E0446)\n+  --> $DIR/eval-privacy.rs:12:1\n+   |\n+LL | / impl<const U: u8> Trait for Const<U>\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error[E0446]: private type `fn(u8) -> u8 {my_const_fn}` in public interface\n+  --> $DIR/eval-privacy.rs:21:5\n+   |\n+LL |     type AssocTy = Const<{ my_const_fn(U) }>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+...\n+LL | const fn my_const_fn(val: u8) -> u8 {\n+   | ----------------------------------- `fn(u8) -> u8 {my_const_fn}` declared as private\n+\n+error: aborting due to previous error; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0446`."}, {"sha": "d56ffebad7d5aeb339713ebdd6845c376702050d", "filename": "src/test/ui/consts/issue-17458.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-17458.rs"}, {"sha": "68e86ea21bd963435501cf3df97b5083b236f530", "filename": "src/test/ui/consts/issue-17458.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-17458.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-17458.stderr"}, {"sha": "d1093c205798a0b8875111e57d65d23625d0e74b", "filename": "src/test/ui/consts/issue-25826.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-25826.rs"}, {"sha": "67d1b3ab9bed60589b671ed483f99bf91666f6ff", "filename": "src/test/ui/consts/issue-25826.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-25826.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-25826.stderr"}, {"sha": "0a1e835672de9db26f312254c9c7e608db2d126f", "filename": "src/test/ui/consts/issue-46553.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-46553.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-46553.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-46553.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-46553.rs"}, {"sha": "5c38d7c42f6b2797b2f1cf1c2532facea982a4f7", "filename": "src/test/ui/consts/issue-54348.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-54348.rs"}, {"sha": "eb85f349843c42a16f8c3abeb7c55816c42e0ad4", "filename": "src/test/ui/consts/issue-54348.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-54348.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-54348.stderr"}, {"sha": "fb0a270f18befb66d03425b1a3725661b4d5a76a", "filename": "src/test/ui/consts/issue-56762.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-56762.rs"}, {"sha": "f26ef280b20b78e76742335f7a92029b1e0d1413", "filename": "src/test/ui/consts/issue-56762.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56762.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-56762.stderr"}, {"sha": "627a8c2384ca9c22e7c196f1a7faaf909bf0b11e", "filename": "src/test/ui/extern/issue-10763.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fextern%2Fissue-10763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fextern%2Fissue-10763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-10763.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-10763.rs"}, {"sha": "42ed1ae93b551f219afa5756ad1928be45d25e42", "filename": "src/test/ui/extern/issue-10764-rpass.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fextern%2Fissue-10764-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fextern%2Fissue-10764-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-10764-rpass.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-10764-rpass.rs"}, {"sha": "ad54107423d6cdc573ec73f69e3dc6b55dfcd8d5", "filename": "src/test/ui/for-loop-while/issue-2216.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-2216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-2216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-2216.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-2216.rs"}, {"sha": "1aca16ca80451327a2db4f2d2cb17b0ff2a0c7e0", "filename": "src/test/ui/for-loop-while/issue-69841.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-69841.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-69841.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor-loop-while%2Fissue-69841.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-69841.rs"}, {"sha": "328a4c982b81e6bb1839bda5e9d8c49c7eb8fc7b", "filename": "src/test/ui/lint/issue-14309.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fissue-14309.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fissue-14309.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-14309.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-14309.rs"}, {"sha": "799991f7ee4baeaabac128e5ec1298ce9ad48986", "filename": "src/test/ui/lint/issue-14309.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fissue-14309.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fissue-14309.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-14309.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-14309.stderr"}, {"sha": "e3b451a15a2cc4a50508507b2aac80602489eb8b", "filename": "src/test/ui/lint/special-upper-lower-cases.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fspecial-upper-lower-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Flint%2Fspecial-upper-lower-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fspecial-upper-lower-cases.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -2,29 +2,29 @@ warning: type `\ud835\udd5f\ud835\udd60\ud835\udd65\ud835\udd52\ud835\udd54\ud835\udd52\ud835\udd5e\ud835\udd56\ud835\udd5d` should have an upper camel\n   --> $DIR/special-upper-lower-cases.rs:11:8\n    |\n LL | struct \ud835\udd5f\ud835\udd60\ud835\udd65\ud835\udd52\ud835\udd54\ud835\udd52\ud835\udd5e\ud835\udd56\ud835\udd5d;\n-   |        ^^^^^^^^^\n+   |        ^^^^^^^^^ should have an UpperCamelCase name\n    |\n    = note: `#[warn(non_camel_case_types)]` on by default\n \n warning: type `\ud835\udd5f\ud835\udd60\ud835\udd65_\ud835\udd52_\ud835\udd54\ud835\udd52\ud835\udd5e\ud835\udd56\ud835\udd5d` should have an upper camel case name\n   --> $DIR/special-upper-lower-cases.rs:15:8\n    |\n LL | struct \ud835\udd5f\ud835\udd60\ud835\udd65_\ud835\udd52_\ud835\udd54\ud835\udd52\ud835\udd5e\ud835\udd56\ud835\udd5d;\n-   |        ^^^^^^^^^^^ help: convert the identifier to upper camel case: `\ud835\udd5f\ud835\udd60\ud835\udd65\ud835\udd52\ud835\udd54\ud835\udd52\ud835\udd5e\ud835\udd56\ud835\udd5d`\n+   |        ^^^^^^^^^^^ should have an UpperCamelCase name\n \n warning: static variable `\ud835\uddfb\ud835\uddfc\ud835\uddfb\ud835\ude02\ud835\uddfd\ud835\uddfd\ud835\uddf2\ud835\uddff\ud835\uddf0\ud835\uddee\ud835\ude00\ud835\uddf2` should have an upper case name\n   --> $DIR/special-upper-lower-cases.rs:18:8\n    |\n LL | static \ud835\uddfb\ud835\uddfc\ud835\uddfb\ud835\ude02\ud835\uddfd\ud835\uddfd\ud835\uddf2\ud835\uddff\ud835\uddf0\ud835\uddee\ud835\ude00\ud835\uddf2: i32 = 1;\n-   |        ^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^ should have an UPPER_CASE name\n    |\n    = note: `#[warn(non_upper_case_globals)]` on by default\n \n warning: variable `\ud835\udce2\ud835\udcdd\ud835\udcd0\ud835\udcd0\ud835\udcd0\ud835\udcd0\ud835\udcda\ud835\udcd4\ud835\udce2` should have a snake case name\n   --> $DIR/special-upper-lower-cases.rs:22:9\n    |\n LL |     let \ud835\udce2\ud835\udcdd\ud835\udcd0\ud835\udcd0\ud835\udcd0\ud835\udcd0\ud835\udcda\ud835\udcd4\ud835\udce2 = 1;\n-   |         ^^^^^^^^^\n+   |         ^^^^^^^^^ should have a snake_case name\n    |\n    = note: `#[warn(non_snake_case)]` on by default\n "}, {"sha": "32a36e44aa1aee7791dcfff6e684361f1110d21c", "filename": "src/test/ui/llvm-asm/issue-33264.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-33264.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-33264.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fllvm-asm%2Fissue-33264.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-33264.rs"}, {"sha": "ea7525d4477de99b71f3ee599f72a8cff6a4da50", "filename": "src/test/ui/macros/issue-8709.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fmacros%2Fissue-8709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fmacros%2Fissue-8709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-8709.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-8709.rs"}, {"sha": "637cf278f840832dbe9a2348fac256cb7f519b3f", "filename": "src/test/ui/nll/issue-45696-scribble-on-boxed-borrow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.rs"}, {"sha": "db0a1719922c8425f46e8be964ef9557981368d5", "filename": "src/test/ui/nll/issue-45696-scribble-on-boxed-borrow.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-45696-scribble-on-boxed-borrow.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-45696-scribble-on-boxed-borrow.stderr"}, {"sha": "18af33c1821c0d6c7dfa4ba27422643a8eb4b3ff", "filename": "src/test/ui/nll/issue-46036.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-46036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-46036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46036.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-46036.rs"}, {"sha": "49dd0e267b8ea8f187ad806f0cf1a23f4c34bf59", "filename": "src/test/ui/nll/issue-46036.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-46036.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fnll%2Fissue-46036.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-46036.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-46036.stderr"}, {"sha": "3ceb58d1252d315c67e63d44b318aace5d719b31", "filename": "src/test/ui/parser/issue-20616-8.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-20616-8.rs"}, {"sha": "e9f37e50fffec7e02ce674346c82b42f5f932c45", "filename": "src/test/ui/parser/issue-20616-8.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20616-8.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-20616-8.stderr"}, {"sha": "7f84284481e2f02e07fc82788163d6e01bf1d98d", "filename": "src/test/ui/parser/issue-20616-9.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-20616-9.rs"}, {"sha": "dc309d1bce1586c12e35eb3fae926ca6a246edf8", "filename": "src/test/ui/parser/issue-20616-9.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-20616-9.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-20616-9.stderr"}, {"sha": "714a46cbc9f481e7e05ab1a09f3cf23be44ef52a", "filename": "src/test/ui/parser/issue-57198.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57198.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57198.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57198.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57198.rs"}, {"sha": "197c4cc967d4da1ea32c3dfa373caf45552cf6af", "filename": "src/test/ui/parser/issue-57198.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57198.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57198.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57198.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57198.stderr"}, {"sha": "4a432206d51e1488275e52a8ce1ac1fa1b80550d", "filename": "src/test/ui/parser/issue-57684.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57684.fixed?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57684.fixed"}, {"sha": "7a62785e32f1c045583ca276283bca8cfaa2bc6a", "filename": "src/test/ui/parser/issue-57684.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57684.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57684.rs"}, {"sha": "514bbffde6b1e957b68ad94042b1bef77d322a48", "filename": "src/test/ui/parser/issue-57684.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57684.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57684.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57684.stderr"}, {"sha": "3fab21db2d06e42035df10025f16c6902264bf50", "filename": "src/test/ui/parser/issue-57819.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57819.fixed?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57819.fixed"}, {"sha": "5cafbf439be2dba4ee1bc4a5a72e6d9ac4b27376", "filename": "src/test/ui/parser/issue-57819.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57819.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57819.rs"}, {"sha": "493e9835b1ca9d6b6c22b3b4394d0126e8f96512", "filename": "src/test/ui/parser/issue-57819.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-57819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-57819.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-57819.stderr"}, {"sha": "332a3014416b57569985af36858c5b3b54f185a0", "filename": "src/test/ui/parser/issue-58856-1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-58856-1.rs"}, {"sha": "f1abb40ed7a739a4dde60dfa33edb4f330f0879d", "filename": "src/test/ui/parser/issue-58856-1.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-58856-1.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-58856-1.stderr"}, {"sha": "2db51ea6042aa533d2caaa6cb5b6978094bb4072", "filename": "src/test/ui/parser/issue-64732.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-64732.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-64732.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-64732.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-64732.rs"}, {"sha": "3b00ffc8f6c8dedd3121df958223b0004cdc3e0e", "filename": "src/test/ui/parser/issue-64732.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-64732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-64732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-64732.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-64732.stderr"}, {"sha": "1c4abce39598c20882893c1723169a08a3b1169c", "filename": "src/test/ui/parser/issue-7970b.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-7970b.rs"}, {"sha": "a62226a8a4de24f99594689ae888e055ef34adec", "filename": "src/test/ui/parser/issue-7970b.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-7970b.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-7970b.stderr"}, {"sha": "00588735b9a5932c78fdfb9b3d3b9057d8492541", "filename": "src/test/ui/resolve/issue-50599.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-50599.rs"}, {"sha": "7ec567a06f09dcf3694ddffca05188b708db21fe", "filename": "src/test/ui/resolve/issue-50599.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-50599.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-50599.stderr"}, {"sha": "b07def21e88be17419745527786d50dc158e8832", "filename": "src/test/ui/simd/issue-32947.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsimd%2Fissue-32947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsimd%2Fissue-32947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fissue-32947.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-32947.rs"}, {"sha": "05a4a0eb1266debed55155a0fa6b9651ca88b17f", "filename": "src/test/ui/suggestions/field-access.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.fixed?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct A {\n+    b: B,\n+}\n+\n+enum B {\n+    Fst,\n+    Snd,\n+}\n+\n+union Foo {\n+    bar: u32,\n+    qux: f32,\n+}\n+\n+fn main() {\n+    let a = A { b: B::Fst };\n+    if let B::Fst = a.b {}; //~ ERROR mismatched types [E0308]\n+    //~^ HELP you might have meant to use field `b` of type `B`\n+    match a.b {\n+        //~^ HELP you might have meant to use field `b` of type `B`\n+        //~| HELP you might have meant to use field `b` of type `B`\n+        B::Fst => (), //~ ERROR mismatched types [E0308]\n+        B::Snd => (), //~ ERROR mismatched types [E0308]\n+    }\n+\n+    let foo = Foo { bar: 42 };\n+    match unsafe { foo.bar } {\n+        //~^ HELP you might have meant to use field `bar` of type `u32`\n+        1u32 => (), //~ ERROR mismatched types [E0308]\n+        _ => (),\n+    }\n+}"}, {"sha": "ad23c0ffa2e74c60abba1ea2c1969a16331ad633", "filename": "src/test/ui/suggestions/field-access.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+struct A {\n+    b: B,\n+}\n+\n+enum B {\n+    Fst,\n+    Snd,\n+}\n+\n+union Foo {\n+    bar: u32,\n+    qux: f32,\n+}\n+\n+fn main() {\n+    let a = A { b: B::Fst };\n+    if let B::Fst = a {}; //~ ERROR mismatched types [E0308]\n+    //~^ HELP you might have meant to use field `b` of type `B`\n+    match a {\n+        //~^ HELP you might have meant to use field `b` of type `B`\n+        //~| HELP you might have meant to use field `b` of type `B`\n+        B::Fst => (), //~ ERROR mismatched types [E0308]\n+        B::Snd => (), //~ ERROR mismatched types [E0308]\n+    }\n+\n+    let foo = Foo { bar: 42 };\n+    match foo {\n+        //~^ HELP you might have meant to use field `bar` of type `u32`\n+        1u32 => (), //~ ERROR mismatched types [E0308]\n+        _ => (),\n+    }\n+}"}, {"sha": "aad9872032a2a85b8bd5db6a5c0fdefe01ddbc82", "filename": "src/test/ui/suggestions/field-access.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffield-access.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -0,0 +1,67 @@\n+error[E0308]: mismatched types\n+  --> $DIR/field-access.rs:20:12\n+   |\n+LL |     Fst,\n+   |     --- unit variant defined here\n+...\n+LL |     if let B::Fst = a {};\n+   |            ^^^^^^   - this expression has type `A`\n+   |            |\n+   |            expected struct `A`, found enum `B`\n+   |\n+help: you might have meant to use field `b` of type `B`\n+   |\n+LL |     if let B::Fst = a.b {};\n+   |                     ^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/field-access.rs:25:9\n+   |\n+LL |     Fst,\n+   |     --- unit variant defined here\n+...\n+LL |     match a {\n+   |           - this expression has type `A`\n+...\n+LL |         B::Fst => (),\n+   |         ^^^^^^ expected struct `A`, found enum `B`\n+   |\n+help: you might have meant to use field `b` of type `B`\n+   |\n+LL |     match a.b {\n+   |           ^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/field-access.rs:26:9\n+   |\n+LL |     Snd,\n+   |     --- unit variant defined here\n+...\n+LL |     match a {\n+   |           - this expression has type `A`\n+...\n+LL |         B::Snd => (),\n+   |         ^^^^^^ expected struct `A`, found enum `B`\n+   |\n+help: you might have meant to use field `b` of type `B`\n+   |\n+LL |     match a.b {\n+   |           ^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/field-access.rs:32:9\n+   |\n+LL |     match foo {\n+   |           --- this expression has type `Foo`\n+LL |\n+LL |         1u32 => (),\n+   |         ^^^^ expected union `Foo`, found `u32`\n+   |\n+help: you might have meant to use field `bar` of type `u32`\n+   |\n+LL |     match unsafe { foo.bar } {\n+   |           ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e573038980d95195683b371a4183afbe72273f29", "filename": "src/test/ui/test-attrs/issue-53675-a-test-called-panic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-53675-a-test-called-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-53675-a-test-called-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fissue-53675-a-test-called-panic.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-53675-a-test-called-panic.rs"}, {"sha": "948f2a7bdf31cc63c70e8f87d12b3e4470599916", "filename": "src/test/ui/threads-sendsync/issue-4446.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthreads-sendsync%2Fissue-4446.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-4446.rs"}, {"sha": "d091162fced6b926ed6457a618946bc6f9f5c799", "filename": "src/test/ui/traits/issue-33140-hack-boundaries.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-33140-hack-boundaries.rs"}, {"sha": "ae65701ecb52ab96683b5baf458b46df79a97618", "filename": "src/test/ui/traits/issue-33140-hack-boundaries.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-33140-hack-boundaries.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-33140-hack-boundaries.stderr"}, {"sha": "b12c450c937fb9264311687cb4fb04b58e4818d0", "filename": "src/test/ui/traits/issue-3683.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-3683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-3683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-3683.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-3683.rs"}, {"sha": "0952843e60a1af67d6edb6d5809f202ee058318f", "filename": "src/test/ui/traits/issue-56202.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-56202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-56202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-56202.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-56202.rs"}, {"sha": "e2f3996927b7f8b93d850c779fd4fe83f78833cc", "filename": "src/test/ui/traits/issue-56488.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-56488.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-56488.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-56488.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-56488.rs"}, {"sha": "2bdb128d8c4c8af18121625ee55867223e3f2af5", "filename": "src/test/ui/traits/issue-59029-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-59029-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-59029-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-59029-2.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-59029-2.rs"}, {"sha": "8859fbe6afb7b4ef01c5a3595d30828d8fe61866", "filename": "src/test/ui/traits/issue-6128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-6128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-6128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-6128.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-6128.rs"}, {"sha": "018ce0459fd6f21794251af2a8bf3aab56bf31f4", "filename": "src/test/ui/traits/issue-65284-suggest-generic-trait-bound.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-65284-suggest-generic-trait-bound.rs"}, {"sha": "4807a0930e7d02e733b79d148bdbedde68410939", "filename": "src/test/ui/traits/issue-65284-suggest-generic-trait-bound.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-65284-suggest-generic-trait-bound.stderr?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "previous_filename": "src/test/ui/issues/issue-65284-suggest-generic-trait-bound.stderr"}, {"sha": "74ed2366752089ae81ab8844b1a7839d8cbb965c", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02b85d722050d61b40ae9746b3bac54ab55b1056/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=02b85d722050d61b40ae9746b3bac54ab55b1056", "patch": "@@ -8,7 +8,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 1459;\n-const ISSUES_ENTRY_LIMIT: usize = 2669;\n+const ISSUES_ENTRY_LIMIT: usize = 2615;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     let dirs = walkdir::WalkDir::new(&path.join(\"test/ui\"))"}]}