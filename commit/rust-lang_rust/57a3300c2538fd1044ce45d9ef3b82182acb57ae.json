{"sha": "57a3300c2538fd1044ce45d9ef3b82182acb57ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTMzMDBjMjUzOGZkMTA0NGNlNDVkOWVmM2I4MjE4MmFjYjU3YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-13T12:52:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-13T12:52:29Z"}, "message": "Auto merge of #61799 - Centril:rollup-vpm5uxr, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #61598 (Handle index out of bound errors during const eval without panic)\n - #61720 (std: Remove internal definitions of `cfg_if!` macro)\n - #61757 (Deprecate ONCE_INIT in future 1.38 release)\n - #61766 (submodules: update clippy from c0dbd34b to bd33a97c)\n - #61791 (Small cleanup in `check_pat_path`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3fa262efda57b73d9e6143b9e6ee569fecccd9c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fa262efda57b73d9e6143b9e6ee569fecccd9c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a3300c2538fd1044ce45d9ef3b82182acb57ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a3300c2538fd1044ce45d9ef3b82182acb57ae", "html_url": "https://github.com/rust-lang/rust/commit/57a3300c2538fd1044ce45d9ef3b82182acb57ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a3300c2538fd1044ce45d9ef3b82182acb57ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96636f3eb8206f7499451ebc5b347d000d7aee08", "url": "https://api.github.com/repos/rust-lang/rust/commits/96636f3eb8206f7499451ebc5b347d000d7aee08", "html_url": "https://github.com/rust-lang/rust/commit/96636f3eb8206f7499451ebc5b347d000d7aee08"}, {"sha": "8917b8e32ca5928b83afc8da03746acb4914a53a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8917b8e32ca5928b83afc8da03746acb4914a53a", "html_url": "https://github.com/rust-lang/rust/commit/8917b8e32ca5928b83afc8da03746acb4914a53a"}], "stats": {"total": 341, "additions": 97, "deletions": 244}, "files": [{"sha": "d3c6be59b75df5c3498825be9e0df77146a6629b", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -1832,6 +1832,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3384,6 +3385,7 @@ dependencies = [\n  \"alloc 0.0.0\",\n  \"backtrace 0.3.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3982,6 +3984,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"compiler_builtins 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "519212bb6cb4e034961a245b66ae89d41de6a78a", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -111,31 +111,31 @@ pub fn spin_loop() {\n /// This function is a no-op, and does not even read from `dummy`.\n #[inline]\n #[unstable(feature = \"test\", issue = \"27812\")]\n+#[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\n pub fn black_box<T>(dummy: T) -> T {\n-    cfg_if! {\n-        if #[cfg(any(\n-            target_arch = \"asmjs\",\n-            all(\n-                target_arch = \"wasm32\",\n-                target_os = \"emscripten\"\n-            )\n-        ))] {\n-            #[inline]\n-            unsafe fn black_box_impl<T>(d: T) -> T {\n-                // these targets do not support inline assembly\n-                let ret = crate::ptr::read_volatile(&d);\n-                crate::mem::forget(d);\n-                ret\n-            }\n-        } else {\n-            #[inline]\n-            unsafe fn black_box_impl<T>(d: T) -> T {\n-                // we need to \"use\" the argument in some way LLVM can't\n-                // introspect.\n-                asm!(\"\" : : \"r\"(&d));\n-                d\n-            }\n-        }\n+    // We need to \"use\" the argument in some way LLVM can't introspect, and on\n+    // targets that support it we can typically leverage inline assembly to do\n+    // this. LLVM's intepretation of inline assembly is that it's, well, a black\n+    // box. This isn't the greatest implementation since it probably deoptimizes\n+    // more than we want, but it's so far good enough.\n+    #[cfg(not(any(\n+        target_arch = \"asmjs\",\n+        all(\n+            target_arch = \"wasm32\",\n+            target_os = \"emscripten\"\n+        )\n+    )))]\n+    unsafe {\n+        asm!(\"\" : : \"r\"(&dummy));\n+        return dummy;\n+    }\n+\n+    // Not all platforms support inline assembly so try to do something without\n+    // inline assembly which in theory still hinders at least some optimizations\n+    // on those targets. This is the \"best effort\" scenario.\n+    unsafe {\n+        let ret = crate::ptr::read_volatile(&dummy);\n+        crate::mem::forget(dummy);\n+        ret\n     }\n-    unsafe { black_box_impl(dummy) }\n }"}, {"sha": "3acf2ec837d88cae0ca415e45d0c08af150e4686", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -117,84 +117,3 @@ macro_rules! impl_fn_for_zst {\n         )+\n     }\n }\n-\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// The macro provided by this crate, `cfg_if`, is similar to the `if/elif` C\n-/// preprocessor macro by allowing definition of a cascade of `#[cfg]` cases,\n-/// emitting the implementation which matches first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-///\n-/// # Example\n-///\n-/// ```\n-/// #[macro_use]\n-/// extern crate cfg_if;\n-///\n-/// cfg_if! {\n-///     if #[cfg(unix)] {\n-///         fn foo() { /* unix specific functionality */ }\n-///     } else if #[cfg(target_pointer_width = \"32\")] {\n-///         fn foo() { /* non-unix, 32-bit functionality */ }\n-///     } else {\n-///         fn foo() { /* fallback implementation */ }\n-///     }\n-/// }\n-///\n-/// # fn main() {}\n-/// ```\n-macro_rules! cfg_if {\n-    // match if/else chains with a final `else`\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        cfg_if! {\n-            @__items\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    };\n-\n-    // match if/else chains lacking a final `else`\n-    (\n-        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }\n-        $(\n-            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }\n-        )*\n-    ) => {\n-        cfg_if! {\n-            @__items\n-            () ;\n-            ( ($($i_met),*) ($($i_it)*) ),\n-            $( ( ($($e_met),*) ($($e_it)*) ), )*\n-            ( () () ),\n-        }\n-    };\n-\n-    // Internal and recursive macro to emit all the items\n-    //\n-    // Collects all the negated cfgs in a list at the beginning and after the\n-    // semicolon is all the remaining items\n-    (@__items ($($not:meta,)*) ; ) => {};\n-    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        // Emit all items within one block, applying an approprate #[cfg]. The\n-        // #[cfg] will require all `$m` matchers specified and must also negate\n-        // all previous matchers.\n-        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }\n-\n-        // Recurse to emit all other items in `$rest`, and when we do so add all\n-        // our `$m` matchers to the list of `$not` matchers as future emissions\n-        // will have to negate everything we just matched as well.\n-        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }\n-    };\n-\n-    // Internal macro to Apply a cfg attribute to a list of items\n-    (@__apply $m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    };\n-}"}, {"sha": "47cd09f1b0510715a51b1f681c3b2c2e2e0468a8", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -16,3 +16,4 @@ core = { path = \"../libcore\" }\n libc = { version = \"0.2\", default-features = false }\n unwind = { path = \"../libunwind\" }\n compiler_builtins = \"0.1.0\"\n+cfg-if = \"0.1.8\""}, {"sha": "2bb9ce6ab220b650a64c950a5a84235aa1e40f8d", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -38,10 +38,7 @@ use core::mem;\n use core::raw;\n use core::panic::BoxMeUp;\n \n-#[macro_use]\n-mod macros;\n-\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;"}, {"sha": "659e977285e3567b3ed5d46a2f3fe08f4f87f5de", "filename": "src/libpanic_unwind/macros.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96636f3eb8206f7499451ebc5b347d000d7aee08/src%2Flibpanic_unwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96636f3eb8206f7499451ebc5b347d000d7aee08/src%2Flibpanic_unwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmacros.rs?ref=96636f3eb8206f7499451ebc5b347d000d7aee08", "patch": "@@ -1,35 +0,0 @@\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}, {"sha": "395270f5bb53aeb08b3b8c9efc83d1b53bd0c194", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -161,8 +161,8 @@ mod dl {\n     pub fn check_for_errors_in<T, F>(f: F) -> Result<T, String> where\n         F: FnOnce() -> T,\n     {\n-        use std::sync::{Mutex, Once, ONCE_INIT};\n-        static INIT: Once = ONCE_INIT;\n+        use std::sync::{Mutex, Once};\n+        static INIT: Once = Once::new();\n         static mut LOCK: *mut Mutex<()> = 0 as *mut _;\n         unsafe {\n             INIT.call_once(|| {"}, {"sha": "eef0940a8e48d46fda4075ab5d0937f1b768a19c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -348,8 +348,12 @@ where\n                 offsets[usize::try_from(field).unwrap()],\n             layout::FieldPlacement::Array { stride, .. } => {\n                 let len = base.len(self)?;\n-                assert!(field < len, \"Tried to access element {} of array/slice with length {}\",\n-                    field, len);\n+                if field >= len {\n+                    // This can be violated because this runs during promotion on code where the\n+                    // type system has not yet ensured that such things don't happen.\n+                    debug!(\"Tried to access element {} of array/slice with length {}\", field, len);\n+                    return err!(BoundsCheck { len, index: field });\n+                }\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {"}, {"sha": "b882b696938ac36a170d9998f4e2c53eddea7fed", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -1067,10 +1067,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 self.set_tainted_by_errors();\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::Method, _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n-                return tcx.types.err;\n-            }\n+            Res::Def(DefKind::Method, _) |\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n             Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n                 report_unexpected_variant_res(tcx, res, pat.span, qpath);"}, {"sha": "a170dae2b08caa68b3c621eb1c0322cda8c248e4", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -15,6 +15,7 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n alloc = { path = \"../liballoc\" }\n+cfg-if = \"0.1.8\"\n panic_unwind = { path = \"../libpanic_unwind\", optional = true }\n panic_abort = { path = \"../libpanic_abort\" }\n core = { path = \"../libcore\" }"}, {"sha": "e0ffc9ba92f11563a425c780d2f575f5660a780d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -336,6 +336,12 @@ extern crate libc;\n #[allow(unused_extern_crates)]\n extern crate unwind;\n \n+// Only needed for now for the `std_detect` module until that crate changes to\n+// use `cfg_if::cfg_if!`\n+#[macro_use]\n+#[cfg(not(test))]\n+extern crate cfg_if;\n+\n // During testing, this crate is not actually the \"real\" std library, but rather\n // it links to the real std library, which was compiled from this same source\n // code. So any lang items std defines are conditionally excluded (or else they"}, {"sha": "d695141bef0b9496a10620be590fd96d1973f06c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -896,39 +896,3 @@ mod builtin {\n         ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n     }\n }\n-\n-/// Defines `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}, {"sha": "94e8b7805cf933325615e09a16bb6ed25aaae65b", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -3,7 +3,7 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, nonstandard_style, missing_debug_implementations)]\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(rustdoc)] {\n \n         // When documenting libstd we want to show unix/windows/linux modules as"}, {"sha": "fd6e46fd61dc581d7c331de0aecba4c16a6ece5f", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -163,6 +163,7 @@ pub use self::condvar::{Condvar, WaitTimeoutResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::mutex::{Mutex, MutexGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::once::{Once, OnceState, ONCE_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use crate::sys_common::poison::{PoisonError, TryLockError, TryLockResult, LockResult};"}, {"sha": "e529b8c4227fa7a1d4c6c5ca14f0cb070529380e", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -115,6 +115,11 @@ pub struct OnceState {\n /// static START: Once = ONCE_INIT;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(\n+    since = \"1.38.0\",\n+    reason = \"the `new` function is now preferred\",\n+    suggestion = \"Once::new()\",\n+)]\n pub const ONCE_INIT: Once = Once::new();\n \n // Four states that a Once can be in, encoded into the lower bits of `state` in"}, {"sha": "21360e2e0f0286c8da5bcf8c16b30ddccd039018", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -22,7 +22,7 @@\n \n #![allow(missing_debug_implementations)]\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(unix)] {\n         mod unix;\n         pub use self::unix::*;\n@@ -54,7 +54,7 @@ cfg_if! {\n // Windows when we're compiling for Linux.\n \n #[cfg(rustdoc)]\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(any(unix, target_os = \"redox\"))] {\n         // On unix we'll document what's already available\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -77,7 +77,7 @@ cfg_if! {\n }\n \n #[cfg(rustdoc)]\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(windows)] {\n         // On windows we'll just be documenting what's already available\n         #[allow(missing_docs)]"}, {"sha": "7d157709eb6bf410ad1f2a3bdd0acd8df5e19820", "filename": "src/libstd/sys/wasm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmod.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -40,7 +40,7 @@ pub mod stdio;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_feature = \"atomics\")] {\n         #[path = \"condvar_atomics.rs\"]\n         pub mod condvar;"}, {"sha": "61b4003cd3d148e473bfb2c7c31e678bef77566f", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -59,7 +59,7 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n }\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n         #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n         extern {"}, {"sha": "13a59f66c5c2f16f4f461371a7b59d6c5505a680", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -65,7 +65,7 @@ pub mod bytestring;\n pub mod process;\n pub mod fs;\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\",\n                  target_os = \"l4re\",\n                  target_os = \"redox\","}, {"sha": "f0f1bab425d7af10c4e8d4aea1544c3d8f5fb5ce", "filename": "src/libunwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -19,6 +19,7 @@ doc = false\n core = { path = \"../libcore\" }\n libc = { version = \"0.2.43\", features = ['rustc-dep-of-std'], default-features = false }\n compiler_builtins = \"0.1.0\"\n+cfg-if = \"0.1.8\"\n \n [build-dependencies]\n cc = { optional = true, version = \"1.0.1\" }"}, {"sha": "9182e349b196ea1893d48243c952fa40e480b40d", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -11,10 +11,7 @@\n \n #![cfg_attr(not(target_env = \"msvc\"), feature(libc))]\n \n-#[macro_use]\n-mod macros;\n-\n-cfg_if! {\n+cfg_if::cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n     } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {"}, {"sha": "5794e0b7683cbf7760e2ba505043555c54ae091a", "filename": "src/libunwind/libunwind.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Flibunwind%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flibunwind.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -1,10 +1,5 @@\n #![allow(nonstandard_style)]\n \n-macro_rules! cfg_if {\n-    ( $( if #[cfg( $meta:meta )] { $($it1:item)* } else { $($it2:item)* } )* ) =>\n-        ( $( $( #[cfg($meta)] $it1)* $( #[cfg(not($meta))] $it2)* )* )\n-}\n-\n use libc::{c_int, c_void, uintptr_t};\n \n #[repr(C)]\n@@ -82,7 +77,7 @@ extern \"C\" {\n     pub fn _Unwind_GetDataRelBase(ctx: *mut _Unwind_Context) -> _Unwind_Ptr;\n }\n \n-cfg_if! {\n+cfg_if::cfg_if! {\n if #[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\"))))] {\n     // Not ARM EHABI\n     #[repr(C)]\n@@ -206,7 +201,9 @@ if #[cfg(all(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\n         pc\n     }\n }\n+} // cfg_if!\n \n+cfg_if::cfg_if! {\n if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     // Not 32-bit iOS\n     extern \"C\" {"}, {"sha": "659e977285e3567b3ed5d46a2f3fe08f4f87f5de", "filename": "src/libunwind/macros.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/96636f3eb8206f7499451ebc5b347d000d7aee08/src%2Flibunwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96636f3eb8206f7499451ebc5b347d000d7aee08/src%2Flibunwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fmacros.rs?ref=96636f3eb8206f7499451ebc5b347d000d7aee08", "patch": "@@ -1,35 +0,0 @@\n-/// A macro for defining `#[cfg]` if-else statements.\n-///\n-/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n-/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n-/// first.\n-///\n-/// This allows you to conveniently provide a long list `#[cfg]`'d blocks of code\n-/// without having to rewrite each clause multiple times.\n-macro_rules! cfg_if {\n-    ($(\n-        if #[cfg($($meta:meta),*)] { $($it:item)* }\n-    ) else * else {\n-        $($it2:item)*\n-    }) => {\n-        __cfg_if_items! {\n-            () ;\n-            $( ( ($($meta),*) ($($it)*) ), )*\n-            ( () ($($it2)*) ),\n-        }\n-    }\n-}\n-\n-macro_rules! __cfg_if_items {\n-    (($($not:meta,)*) ; ) => {};\n-    (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n-        __cfg_if_apply! { cfg(all(not(any($($not),*)), $($m,)*)), $($it)* }\n-        __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n-    }\n-}\n-\n-macro_rules! __cfg_if_apply {\n-    ($m:meta, $($it:item)*) => {\n-        $(#[$m] $it)*\n-    }\n-}"}, {"sha": "2e2b480e0660225e07e6764e2108aa41ead777f7", "filename": "src/test/run-pass/issues/issue-39367.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39367.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39367.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-39367.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -11,13 +11,13 @@ fn arena() -> &'static ArenaSet<Vec<u8>> {\n         ArenaSet(vec![], &Z)\n     }\n     unsafe {\n-        use std::sync::{Once, ONCE_INIT};\n+        use std::sync::Once;\n         fn require_sync<T: Sync>(_: &T) { }\n         unsafe fn __stability() -> &'static ArenaSet<Vec<u8>> {\n             use std::mem::transmute;\n             static mut DATA: *const ArenaSet<Vec<u8>> = 0 as *const ArenaSet<Vec<u8>>;\n \n-            static mut ONCE: Once = ONCE_INIT;\n+            static mut ONCE: Once = Once::new();\n             ONCE.call_once(|| {\n                 DATA = transmute\n                     ::<Box<ArenaSet<Vec<u8>>>, *const ArenaSet<Vec<u8>>>"}, {"sha": "76013c77de0c258917db8cbd81f2491da6a26c95", "filename": "src/test/ui/consts/array-literal-index-oob.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.rs?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    &{[1, 2, 3][4]};\n+    //~^ ERROR index out of bounds\n+    //~| ERROR reaching this expression at runtime will panic or abort\n+    //~| ERROR this expression will panic at runtime\n+}"}, {"sha": "727ce9e57a47bc8dbadc87c763d1625b8f227da5", "filename": "src/test/ui/consts/array-literal-index-oob.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57a3300c2538fd1044ce45d9ef3b82182acb57ae/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Farray-literal-index-oob.stderr?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -0,0 +1,24 @@\n+error: index out of bounds: the len is 3 but the index is 4\n+  --> $DIR/array-literal-index-oob.rs:2:7\n+   |\n+LL |     &{[1, 2, 3][4]};\n+   |       ^^^^^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: this expression will panic at runtime\n+  --> $DIR/array-literal-index-oob.rs:2:5\n+   |\n+LL |     &{[1, 2, 3][4]};\n+   |     ^^^^^^^^^^^^^^^ index out of bounds: the len is 3 but the index is 4\n+\n+error: reaching this expression at runtime will panic or abort\n+  --> $DIR/array-literal-index-oob.rs:2:7\n+   |\n+LL |     &{[1, 2, 3][4]};\n+   |     --^^^^^^^^^^^^-\n+   |       |\n+   |       index out of bounds: the len is 3 but the index is 4\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7b2a7a225700d972313e23a042f8dbc6adabfbd8", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=57a3300c2538fd1044ce45d9ef3b82182acb57ae", "patch": "@@ -1 +1 @@\n-Subproject commit c0dbd34ba99a949ece25c297a4a377685eb89c7c\n+Subproject commit 7b2a7a225700d972313e23a042f8dbc6adabfbd8"}]}