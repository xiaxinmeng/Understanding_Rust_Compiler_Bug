{"sha": "13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYmZkNWMwYjdiNTdiM2U5MGJlNWMzZTczOGI4Yzk0MjYwNTU0MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T19:40:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-26T19:40:53Z"}, "message": "Auto merge of #32240 - jseyfried:cleanup_resolve, r=nikomatsakis\n\nCleanup resolve\n\nThis is a collection of small refactorings and improvements in `resolve`, most of which could stand alone.\nr? @nikomatsakis", "tree": {"sha": "020b610043419a9273c0e18e3fb1c0d642cfd8ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020b610043419a9273c0e18e3fb1c0d642cfd8ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "html_url": "https://github.com/rust-lang/rust/commit/13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65bc9d77308e55321f36f7c8381a98ed10f93f6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/65bc9d77308e55321f36f7c8381a98ed10f93f6a", "html_url": "https://github.com/rust-lang/rust/commit/65bc9d77308e55321f36f7c8381a98ed10f93f6a"}, {"sha": "e011ae5ea9c48d71772c054771ead2d0f053c8c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e011ae5ea9c48d71772c054771ead2d0f053c8c7", "html_url": "https://github.com/rust-lang/rust/commit/e011ae5ea9c48d71772c054771ead2d0f053c8c7"}], "stats": {"total": 634, "additions": 224, "deletions": 410}, "files": [{"sha": "fac79eb8a28763003e83cbae99067491970b2322", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 63, "deletions": 158, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "patch": "@@ -19,12 +19,11 @@ use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n use Module;\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind};\n-use module_to_string;\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::{CrateStore, ChildItem, DlDef, DlField, DlImpl};\n+use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::middle::ty::VariantKind;\n@@ -42,30 +41,8 @@ use rustc_front::hir::{ItemForeignMod, ItemImpl, ItemMod, ItemStatic, ItemDefaul\n use rustc_front::hir::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use rustc_front::hir::{PathListIdent, PathListMod, StmtDecl};\n use rustc_front::hir::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use rustc_front::hir::Visibility;\n use rustc_front::intravisit::{self, Visitor};\n \n-use std::mem::replace;\n-use std::ops::{Deref, DerefMut};\n-\n-struct GraphBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    resolver: &'a mut Resolver<'b, 'tcx>,\n-}\n-\n-impl<'a, 'b:'a, 'tcx:'b> Deref for GraphBuilder<'a, 'b, 'tcx> {\n-    type Target = Resolver<'b, 'tcx>;\n-\n-    fn deref(&self) -> &Resolver<'b, 'tcx> {\n-        &*self.resolver\n-    }\n-}\n-\n-impl<'a, 'b:'a, 'tcx:'b> DerefMut for GraphBuilder<'a, 'b, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Resolver<'b, 'tcx> {\n-        &mut *self.resolver\n-    }\n-}\n-\n trait ToNameBinding<'a> {\n     fn to_name_binding(self) -> NameBinding<'a>;\n }\n@@ -83,12 +60,12 @@ impl<'a> ToNameBinding<'a> for (Def, Span, DefModifiers) {\n     }\n }\n \n-impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n+impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n     /// Constructs the reduced graph for the entire crate.\n-    fn build_reduced_graph(self, krate: &hir::Crate) {\n+    pub fn build_reduced_graph(&mut self, krate: &hir::Crate) {\n         let mut visitor = BuildReducedGraphVisitor {\n             parent: self.graph_root,\n-            builder: self,\n+            resolver: self,\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n     }\n@@ -124,7 +101,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent: Module<'b>) -> Module<'b> {\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n+        let parent = *parent_ref;\n         let name = item.name;\n         let sp = item.span;\n         let is_public = item.vis == hir::Public;\n@@ -244,7 +222,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     is_prelude);\n                     }\n                 }\n-                parent\n             }\n \n             ItemExternCrate(_) => {\n@@ -262,7 +239,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     self.build_reduced_graph_for_external_crate(module);\n                 }\n-                parent\n             }\n \n             ItemMod(..) => {\n@@ -271,34 +247,30 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n                 self.define(parent, name, TypeNS, (module, sp));\n                 parent.module_children.borrow_mut().insert(item.id, module);\n-                module\n+                *parent_ref = module;\n             }\n \n-            ItemForeignMod(..) => parent,\n+            ItemForeignMod(..) => {}\n \n             // These items live in the value namespace.\n             ItemStatic(_, m, _) => {\n                 let mutbl = m == hir::MutMutable;\n                 let def = Def::Static(self.ast_map.local_def_id(item.id), mutbl);\n                 self.define(parent, name, ValueNS, (def, sp, modifiers));\n-                parent\n             }\n             ItemConst(_, _) => {\n                 let def = Def::Const(self.ast_map.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, modifiers));\n-                parent\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let def = Def::Fn(self.ast_map.local_def_id(item.id));\n                 self.define(parent, name, ValueNS, (def, sp, modifiers));\n-                parent\n             }\n \n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n                 self.define(parent, name, TypeNS, (def, sp, modifiers));\n-                parent\n             }\n \n             ItemEnum(ref enum_definition, _) => {\n@@ -317,7 +289,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.build_reduced_graph_for_variant(variant, item_def_id,\n                                                          module, variant_modifiers);\n                 }\n-                parent\n             }\n \n             // These items live in both the type and value namespaces.\n@@ -340,12 +311,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             .collect();\n                 let item_def_id = self.ast_map.local_def_id(item.id);\n                 self.structs.insert(item_def_id, field_names);\n-\n-                parent\n             }\n \n-            ItemDefaultImpl(_, _) |\n-            ItemImpl(..) => parent,\n+            ItemDefaultImpl(_, _) | ItemImpl(..) => {}\n \n             ItemTrait(_, _, _, ref items) => {\n                 let def_id = self.ast_map.local_def_id(item.id);\n@@ -370,8 +338,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     self.trait_item_map.insert((item.name, def_id), item_def_id);\n                 }\n-\n-                parent\n             }\n         }\n     }\n@@ -422,7 +388,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         self.define(parent, name, ValueNS, (def, foreign_item.span, modifiers));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: Module<'b>) -> Module<'b> {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n@@ -433,48 +399,52 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             let parent_link = BlockParentLink(parent, block_id);\n             let new_module = self.new_module(parent_link, None, false, false);\n             parent.module_children.borrow_mut().insert(block_id, new_module);\n-            new_module\n-        } else {\n-            parent\n+            *parent = new_module;\n         }\n     }\n \n-    fn handle_external_def(&mut self,\n-                           def: Def,\n-                           vis: Visibility,\n-                           final_ident: &str,\n-                           name: Name,\n-                           new_parent: Module<'b>) {\n-        debug!(\"(building reduced graph for external crate) building external def {}, priv {:?}\",\n-               final_ident,\n-               vis);\n-        let is_public = vis == hir::Public || new_parent.is_trait();\n+    /// Builds the reduced graph for a single item in an external crate.\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, xcdef: ChildItem) {\n+        let def = match xcdef.def {\n+            DlDef(def) => def,\n+            _ => return,\n+        };\n+\n+        if let Def::ForeignMod(def_id) = def {\n+            // Foreign modules have no names. Recur and populate eagerly.\n+            for child in self.session.cstore.item_children(def_id) {\n+                self.build_reduced_graph_for_external_crate_def(parent, child);\n+            }\n+            return;\n+        }\n+\n+        let name = xcdef.name;\n+        let is_public = xcdef.vis == hir::Public || parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {\n             modifiers = modifiers | DefModifiers::PUBLIC;\n         }\n-        if new_parent.is_normal() {\n+        if parent.is_normal() {\n             modifiers = modifiers | DefModifiers::IMPORTABLE;\n         }\n \n         match def {\n             Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                       final_ident,\n+                       name,\n                        is_public);\n-                let parent_link = ModuleParentLink(new_parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true, is_public);\n-                self.try_define(new_parent, name, TypeNS, (module, DUMMY_SP));\n+                self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::Variant(_, variant_id) => {\n-                debug!(\"(building reduced graph for external crate) building variant {}\",\n-                       final_ident);\n+                debug!(\"(building reduced graph for external crate) building variant {}\", name);\n                 // Variants are always treated as importable to allow them to be glob used.\n                 // All variants are defined in both type and value namespaces as future-proofing.\n                 let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n-                self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n                 if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n@@ -486,12 +456,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n-                       final_ident);\n-                self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                       name);\n+                self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n             }\n             Def::Trait(def_id) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\",\n-                       final_ident);\n+                debug!(\"(building reduced graph for external crate) building type {}\", name);\n \n                 // If this is a trait, add all the trait item names to the trait\n                 // info.\n@@ -508,24 +477,22 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((trait_item_name, def_id), trait_item_def.def_id());\n                 }\n \n-                let parent_link = ModuleParentLink(new_parent, name);\n+                let parent_link = ModuleParentLink(parent, name);\n                 let module = self.new_module(parent_link, Some(def), true, is_public);\n-                self.try_define(new_parent, name, TypeNS, (module, DUMMY_SP));\n+                self.try_define(parent, name, TypeNS, (module, DUMMY_SP));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                debug!(\"(building reduced graph for external crate) building type {}\",\n-                       final_ident);\n-                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                debug!(\"(building reduced graph for external crate) building type {}\", name);\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n             }\n             Def::Struct(def_id)\n                 if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n-                debug!(\"(building reduced graph for external crate) building type and value for \\\n-                        {}\",\n-                       final_ident);\n-                self.try_define(new_parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n+                debug!(\"(building reduced graph for external crate) building type and value for {}\",\n+                       name);\n+                self.try_define(parent, name, TypeNS, (def, DUMMY_SP, modifiers));\n                 if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n                     let def = Def::Struct(ctor_def_id);\n-                    self.try_define(new_parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n+                    self.try_define(parent, name, ValueNS, (def, DUMMY_SP, modifiers));\n                 }\n \n                 // Record the def ID and fields of this struct.\n@@ -545,69 +512,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self,\n-                                                  root: Module<'b>,\n-                                                  xcdef: ChildItem) {\n-        match xcdef.def {\n-            DlDef(def) => {\n-                // Add the new child item, if necessary.\n-                match def {\n-                    Def::ForeignMod(def_id) => {\n-                        // Foreign modules have no names. Recur and populate\n-                        // eagerly.\n-                        for child in self.session.cstore.item_children(def_id) {\n-                            self.build_reduced_graph_for_external_crate_def(root, child)\n-                        }\n-                    }\n-                    _ => {\n-                        self.handle_external_def(def,\n-                                                 xcdef.vis,\n-                                                 &xcdef.name.as_str(),\n-                                                 xcdef.name,\n-                                                 root);\n-                    }\n-                }\n-            }\n-            DlImpl(_) => {\n-                debug!(\"(building reduced graph for external crate) ignoring impl\");\n-            }\n-            DlField => {\n-                debug!(\"(building reduced graph for external crate) ignoring field\");\n-            }\n-        }\n-    }\n-\n-    /// Builds the reduced graph rooted at the given external module.\n-    fn populate_external_module(&mut self, module: Module<'b>) {\n-        debug!(\"(populating external module) attempting to populate {}\",\n-               module_to_string(module));\n-\n-        let def_id = match module.def_id() {\n-            None => {\n-                debug!(\"(populating external module) ... no def ID!\");\n-                return;\n-            }\n-            Some(def_id) => def_id,\n-        };\n-\n-        for child in self.session.cstore.item_children(def_id) {\n-            debug!(\"(populating external module) ... found ident: {}\",\n-                   child.name);\n-            self.build_reduced_graph_for_external_crate_def(module, child);\n-        }\n-        module.populated.set(true)\n-    }\n-\n-    /// Ensures that the reduced graph rooted at the given external module\n-    /// is built, building it if it is not.\n-    fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n-        if !module.populated.get() {\n-            self.populate_external_module(module)\n-        }\n-        assert!(module.populated.get())\n-    }\n-\n     /// Builds the reduced graph rooted at the 'use' directive for an external\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self, root: Module<'b>) {\n@@ -649,42 +553,43 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         module_.add_import_directive(directive);\n         self.unresolved_imports += 1;\n     }\n+\n+    /// Ensures that the reduced graph rooted at the given external module\n+    /// is built, building it if it is not.\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n+        if module.populated.get() { return }\n+        for child in self.session.cstore.item_children(module.def_id().unwrap()) {\n+            self.build_reduced_graph_for_external_crate_def(module, child);\n+        }\n+        module.populated.set(true)\n+    }\n }\n \n struct BuildReducedGraphVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    builder: GraphBuilder<'a, 'b, 'tcx>,\n+    resolver: &'a mut Resolver<'b, 'tcx>,\n     parent: Module<'b>,\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.builder.resolver.ast_map.expect_item(item.id))\n+        self.visit_item(self.resolver.ast_map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &Item) {\n-        let p = self.builder.build_reduced_graph_for_item(item, &self.parent);\n-        let old_parent = replace(&mut self.parent, p);\n+        let old_parent = self.parent;\n+        self.resolver.build_reduced_graph_for_item(item, &mut self.parent);\n         intravisit::walk_item(self, item);\n         self.parent = old_parent;\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.builder.build_reduced_graph_for_foreign_item(foreign_item, &self.parent);\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, &self.parent);\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n-        let old_parent = replace(&mut self.parent, np);\n+        let old_parent = self.parent;\n+        self.resolver.build_reduced_graph_for_block(block, &mut self.parent);\n         intravisit::walk_block(self, block);\n         self.parent = old_parent;\n     }\n }\n-\n-pub fn build_reduced_graph(resolver: &mut Resolver, krate: &hir::Crate) {\n-    GraphBuilder { resolver: resolver }.build_reduced_graph(krate);\n-}\n-\n-pub fn populate_module_if_necessary<'a, 'tcx>(resolver: &mut Resolver<'a, 'tcx>,\n-                                              module: Module<'a>) {\n-    GraphBuilder { resolver: resolver }.populate_module_if_necessary(module);\n-}"}, {"sha": "d9fc678554ff6de1e961d4c604641c830fcb46a1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 127, "deletions": 199, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "patch": "@@ -51,7 +51,7 @@ use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n-use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings;\n@@ -95,7 +95,7 @@ use resolve_imports::{ImportDirective, NameResolution};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod check_unused;\n mod build_reduced_graph;\n@@ -119,12 +119,12 @@ enum SuggestionType {\n }\n \n /// Candidates for a name resolution failure\n-pub struct SuggestedCandidates {\n+struct SuggestedCandidates {\n     name: String,\n     candidates: Vec<Path>,\n }\n \n-pub enum ResolutionError<'a> {\n+enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n     /// error E0402: cannot use an outer type parameter in this context\n@@ -201,7 +201,7 @@ pub enum ResolutionError<'a> {\n \n /// Context of where `ResolutionError::UnresolvedName` arose.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum UnresolvedNameContext {\n+enum UnresolvedNameContext {\n     /// `PathIsMod(id)` indicates that a given path, used in\n     /// expression context, actually resolved to a module rather than\n     /// a value. The `id` attached to the variant is the node id of\n@@ -756,7 +756,7 @@ enum BareIdentifierPatternResolution {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<Name, DefLike>,\n+    bindings: HashMap<Name, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -784,6 +784,31 @@ impl LocalDef {\n     }\n }\n \n+enum LexicalScopeBinding<'a> {\n+    Item(&'a NameBinding<'a>),\n+    LocalDef(LocalDef),\n+}\n+\n+impl<'a> LexicalScopeBinding<'a> {\n+    fn local_def(self) -> LocalDef {\n+        match self {\n+            LexicalScopeBinding::LocalDef(local_def) => local_def,\n+            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def().unwrap()),\n+        }\n+    }\n+\n+    fn def(self) -> Def {\n+        self.local_def().def\n+    }\n+\n+    fn module(self) -> Option<Module<'a>> {\n+        match self {\n+            LexicalScopeBinding::Item(binding) => binding.module(),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink<'a> {\n@@ -1106,7 +1131,7 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     arenas: &'a ResolverArenas<'a>,\n }\n \n-pub struct ResolverArenas<'a> {\n+struct ResolverArenas<'a> {\n     modules: arena::TypedArena<ModuleS<'a>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective>,\n@@ -1340,9 +1365,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n-    ///\n-    /// On success, returns the resolved module, and the closest *private*\n-    /// module found to the destination when resolving this path.\n     fn resolve_module_path(&mut self,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n@@ -1357,28 +1379,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                module_to_string(self.current_module));\n \n         // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_path);\n+        let module_prefix_result = self.resolve_module_prefix(module_path, span);\n \n         let search_module;\n         let start_index;\n         match module_prefix_result {\n-            Failed(None) => {\n-                let mpath = names_to_string(module_path);\n-                let mpath = &mpath[..];\n-                match mpath.rfind(':') {\n-                    Some(idx) => {\n-                        let msg = format!(\"Could not find `{}` in `{}`\",\n-                                          // idx +- 1 to account for the\n-                                          // colons on either side\n-                                          &mpath[idx + 1..],\n-                                          &mpath[..idx - 1]);\n-                        return Failed(Some((span, msg)));\n-                    }\n-                    None => {\n-                        return Failed(None);\n-                    }\n-                }\n-            }\n             Failed(err) => return Failed(err),\n             Indeterminate => {\n                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n@@ -1399,20 +1404,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_item_in_lexical_scope(module_path[0],\n-                                                                 TypeNS,\n-                                                                 true) {\n-                            Failed(err) => return Failed(err),\n-                            Indeterminate => {\n-                                debug!(\"(resolving module path for import) indeterminate; bailing\");\n-                                return Indeterminate;\n-                            }\n-                            Success(binding) => match binding.module() {\n-                                Some(containing_module) => {\n-                                    search_module = containing_module;\n-                                    start_index = 1;\n-                                }\n-                                None => return Failed(None),\n+                        let ident = hir::Ident::from_name(module_path[0]);\n+                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n+                                  .and_then(LexicalScopeBinding::module) {\n+                            None => return Failed(None),\n+                            Some(containing_module) => {\n+                                search_module = containing_module;\n+                                start_index = 1;\n                             }\n                         }\n                     }\n@@ -1430,40 +1428,54 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            span)\n     }\n \n-    /// This function resolves `name` in `namespace` in the current lexical scope, returning\n-    /// Success(binding) if `name` resolves to an item, or Failed(None) if `name` does not resolve\n-    /// or resolves to a type parameter or local variable.\n-    /// n.b. `resolve_identifier_in_local_ribs` also resolves names in the current lexical scope.\n+    /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n+    /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n+    /// `ident` in the first scope that defines it (or None if no scopes define it).\n+    ///\n+    /// A block's items are above its local variables in the scope hierarchy, regardless of where\n+    /// the items are defined in the block. For example,\n+    /// ```rust\n+    /// fn f() {\n+    ///    g(); // Since there are no local variables in scope yet, this resolves to the item.\n+    ///    let g = || {};\n+    ///    fn g() {}\n+    ///    g(); // This resolves to the local variable `g` since it shadows the item.\n+    /// }\n+    /// ```\n     ///\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n-    fn resolve_item_in_lexical_scope(&mut self,\n-                                     name: Name,\n-                                     namespace: Namespace,\n-                                     record_used: bool)\n-                                     -> ResolveResult<&'a NameBinding<'a>> {\n+    fn resolve_ident_in_lexical_scope(&mut self,\n+                                      ident: hir::Ident,\n+                                      ns: Namespace,\n+                                      record_used: bool)\n+                                      -> Option<LexicalScopeBinding<'a>> {\n+        let name = match ns { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n+\n         // Walk backwards up the ribs in scope.\n-        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n-            if let Some(_) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n-                // The name resolves to a type parameter or local variable, so return Failed(None).\n-                return Failed(None);\n-            }\n-\n-            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success(binding) = self.resolve_name_in_module(module,\n-                                                                      name,\n-                                                                      namespace,\n-                                                                      true,\n-                                                                      record_used) {\n-                    // The name resolves to an item.\n-                    return Success(binding);\n+        for i in (0 .. self.get_ribs(ns).len()).rev() {\n+            if let Some(def) = self.get_ribs(ns)[i].bindings.get(&name).cloned() {\n+                // The ident resolves to a type parameter or local variable.\n+                return Some(LexicalScopeBinding::LocalDef(LocalDef {\n+                    ribs: Some((ns, i)),\n+                    def: def,\n+                }));\n+            }\n+\n+            if let ModuleRibKind(module) = self.get_ribs(ns)[i].kind {\n+                let name = ident.unhygienic_name;\n+                let item = self.resolve_name_in_module(module, name, ns, true, record_used);\n+                if let Success(binding) = item {\n+                    // The ident resolves to an item.\n+                    return Some(LexicalScopeBinding::Item(binding));\n                 }\n+\n                 // We can only see through anonymous modules\n-                if module.def.is_some() { return Failed(None); }\n+                if module.def.is_some() { return None; }\n             }\n         }\n \n-        Failed(None)\n+        None\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n@@ -1499,7 +1511,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Name])\n+    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Span)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -1516,7 +1528,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n-                None => return Failed(None),\n+                None => {\n+                    let msg = \"There are too many initial `super`s.\".into();\n+                    return Failed(Some((span, msg)));\n+                }\n                 Some(new_module) => {\n                     containing_module = new_module;\n                     i += 1;\n@@ -1542,7 +1557,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n-        build_reduced_graph::populate_module_if_necessary(self, module);\n+        self.populate_module_if_necessary(module);\n         match use_lexical_scope {\n             true => module.resolve_name_in_lexical_scope(name, namespace)\n                           .map(Success).unwrap_or(Failed(None)),\n@@ -1594,7 +1609,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, name: Name) -> Option<DefLike> {\n+    fn search_label(&self, name: Name) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n@@ -1753,13 +1768,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     seen_bindings.insert(name);\n \n                     // plain insert (no renaming)\n-                    function_type_rib.bindings\n-                                     .insert(name,\n-                                             DlDef(Def::TyParam(space,\n-                                                              index as u32,\n-                                                              self.ast_map\n-                                                                  .local_def_id(type_parameter.id),\n-                                                              name)));\n+                    let def_id = self.ast_map.local_def_id(type_parameter.id);\n+                    let def = Def::TyParam(space, index as u32, def_id, name);\n+                    function_type_rib.bindings.insert(name, def);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -1948,7 +1959,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // plain insert (no renaming, types are not currently hygienic....)\n         let name = special_names::type_self;\n-        self_type_rib.bindings.insert(name, DlDef(self_def));\n+        self_type_rib.bindings.insert(name, self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         if !self.resolved {\n@@ -2261,8 +2272,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let ident = path1.node;\n                     let renamed = ident.name;\n \n-                    match self.resolve_bare_identifier_pattern(ident.unhygienic_name,\n-                                                               pattern.span) {\n+                    match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n                         FoundStructOrEnumVariant(def) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to struct or enum variant\",\n                                    renamed);\n@@ -2328,7 +2338,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             if !bindings_list.contains_key(&renamed) {\n                                 let this = &mut *self;\n                                 let last_rib = this.value_ribs.last_mut().unwrap();\n-                                last_rib.bindings.insert(renamed, DlDef(def));\n+                                last_rib.bindings.insert(renamed, def);\n                                 bindings_list.insert(renamed, pat_id);\n                             } else if mode == ArgumentIrrefutableMode &&\n                                bindings_list.contains_key(&renamed) {\n@@ -2513,49 +2523,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         });\n     }\n \n-    fn resolve_bare_identifier_pattern(&mut self,\n-                                       name: Name,\n-                                       span: Span)\n+    fn resolve_bare_identifier_pattern(&mut self, ident: hir::Ident, span: Span)\n                                        -> BareIdentifierPatternResolution {\n-        match self.resolve_item_in_lexical_scope(name, ValueNS, true) {\n-            Success(binding) => {\n-                debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n-                       name,\n-                       binding);\n-                match binding.def() {\n-                    None => {\n-                        panic!(\"resolved name in the value namespace to a set of name bindings \\\n-                                with no def?!\");\n-                    }\n-                    // For the two success cases, this lookup can be\n-                    // considered as not having a private component because\n-                    // the lookup happened only within the current module.\n-                    Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n-                        return FoundStructOrEnumVariant(def);\n-                    }\n-                    Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n-                        return FoundConst(def, name);\n-                    }\n-                    Some(Def::Static(..)) => {\n-                        resolve_error(self, span, ResolutionError::StaticVariableReference);\n-                        return BareIdentifierPatternUnresolved;\n-                    }\n-                    _ => return BareIdentifierPatternUnresolved\n-                }\n+        match self.resolve_ident_in_lexical_scope(ident, ValueNS, true)\n+                  .map(LexicalScopeBinding::def) {\n+            Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n+                FoundStructOrEnumVariant(def)\n             }\n-\n-            Indeterminate => return BareIdentifierPatternUnresolved,\n-            Failed(err) => {\n-                match err {\n-                    Some((span, msg)) => {\n-                        resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                    }\n-                    None => (),\n-                }\n-\n-                debug!(\"(resolve bare identifier pattern) failed to find {}\", name);\n-                return BareIdentifierPatternUnresolved;\n+            Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n+                FoundConst(def, ident.unhygienic_name)\n+            }\n+            Some(Def::Static(..)) => {\n+                resolve_error(self, span, ResolutionError::StaticVariableReference);\n+                BareIdentifierPatternUnresolved\n             }\n+            _ => BareIdentifierPatternUnresolved,\n         }\n     }\n \n@@ -2602,12 +2584,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Skips `path_depth` trailing segments, which is also reflected in the\n     /// returned value. See `middle::def::PathResolution` for more info.\n-    pub fn resolve_path(&mut self,\n-                        id: NodeId,\n-                        path: &Path,\n-                        path_depth: usize,\n-                        namespace: Namespace)\n-                        -> Option<PathResolution> {\n+    fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n+                    -> Option<PathResolution> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len() - path_depth];\n \n@@ -2676,7 +2654,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return Some(LocalDef::from_def(Def::Err));\n         }\n \n-        self.resolve_identifier_in_local_ribs(identifier, namespace, record_used)\n+        self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)\n+            .map(LexicalScopeBinding::local_def)\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n@@ -2860,54 +2839,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         })\n     }\n \n-    fn resolve_identifier_in_local_ribs(&mut self,\n-                                        ident: hir::Ident,\n-                                        namespace: Namespace,\n-                                        record_used: bool)\n-                                        -> Option<LocalDef> {\n-        // Check the local set of ribs.\n-        let name = match namespace { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n-\n-        for i in (0 .. self.get_ribs(namespace).len()).rev() {\n-            if let Some(def_like) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n-                match def_like {\n-                    DlDef(def) => {\n-                        debug!(\"(resolving path in local ribs) resolved `{}` to {:?} at {}\",\n-                               name,\n-                               def,\n-                               i);\n-                        return Some(LocalDef {\n-                            ribs: Some((namespace, i)),\n-                            def: def,\n-                        });\n-                    }\n-                    def_like => {\n-                        debug!(\"(resolving path in local ribs) resolved `{}` to pseudo-def {:?}\",\n-                               name,\n-                               def_like);\n-                        return None;\n-                    }\n-                }\n-            }\n-\n-            if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success(binding) = self.resolve_name_in_module(module,\n-                                                                      ident.unhygienic_name,\n-                                                                      namespace,\n-                                                                      true,\n-                                                                      record_used) {\n-                    if let Some(def) = binding.def() {\n-                        return Some(LocalDef::from_def(def));\n-                    }\n-                }\n-                // We can only see through anonymous modules\n-                if module.def.is_some() { return None; }\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver) -> T\n     {\n@@ -3230,11 +3161,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n                 self.with_label_rib(|this| {\n-                    let def_like = DlDef(Def::Label(expr.id));\n+                    let def = Def::Label(expr.id);\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(label.name, def_like);\n+                        rib.bindings.insert(label.name, def);\n                     }\n \n                     intravisit::walk_expr(this, expr);\n@@ -3249,7 +3180,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                       label.span,\n                                       ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n                     }\n-                    Some(DlDef(def @ Def::Label(_))) => {\n+                    Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n                         self.record_def(expr.id,\n                                         PathResolution {\n@@ -3302,18 +3233,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let mut found_traits = Vec::new();\n-        let mut search_module = self.current_module;\n-        loop {\n-            // Look for the current trait.\n-            match self.current_trait_ref {\n-                Some((trait_def_id, _)) => {\n-                    if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        add_trait_info(&mut found_traits, trait_def_id, name);\n-                    }\n-                }\n-                None => {} // Nothing to do.\n+        // Look for the current trait.\n+        if let Some((trait_def_id, _)) = self.current_trait_ref {\n+            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                add_trait_info(&mut found_traits, trait_def_id, name);\n             }\n+        }\n \n+        let mut search_module = self.current_module;\n+        loop {\n             // Look for trait children.\n             let mut search_in_module = |module: Module<'a>| module.for_each_child(|_, ns, binding| {\n                 if ns != TypeNS { return }\n@@ -3363,7 +3291,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         while let Some((in_module,\n                         path_segments,\n                         in_module_is_extern)) = worklist.pop() {\n-            build_reduced_graph::populate_module_if_necessary(self, &in_module);\n+            self.populate_module_if_necessary(in_module);\n \n             in_module.for_each_child(|name, ns, name_binding| {\n \n@@ -3723,18 +3651,18 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n /// preserving the ribs + current module. This allows resolve_path\n /// calls to be made with the correct scope info. The node in the\n /// callback corresponds to the current node in the walk.\n-pub fn create_resolver<'a, 'tcx>(session: &'a Session,\n-                                 ast_map: &'a hir_map::Map<'tcx>,\n-                                 krate: &'a Crate,\n-                                 make_glob_map: MakeGlobMap,\n-                                 arenas: &'a ResolverArenas<'a>,\n-                                 callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n-                                 -> Resolver<'a, 'tcx> {\n+fn create_resolver<'a, 'tcx>(session: &'a Session,\n+                             ast_map: &'a hir_map::Map<'tcx>,\n+                             krate: &'a Crate,\n+                             make_glob_map: MakeGlobMap,\n+                             arenas: &'a ResolverArenas<'a>,\n+                             callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n+                             -> Resolver<'a, 'tcx> {\n     let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n \n     resolver.callback = callback;\n \n-    build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n+    resolver.build_reduced_graph(krate);\n \n     resolve_imports::resolve_imports(&mut resolver);\n "}, {"sha": "7c5d131dbc540eaa5fa69b95e4f50c21cfe40aeb", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "patch": "@@ -17,12 +17,10 @@ use {NameBinding, NameBindingKind, PrivacyError};\n use ResolveResult;\n use ResolveResult::*;\n use Resolver;\n-use UseLexicalScopeFlag;\n+use UseLexicalScopeFlag::DontUseLexicalScope;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n-use build_reduced_graph;\n-\n use rustc::lint;\n use rustc::middle::def::*;\n \n@@ -60,12 +58,12 @@ impl ImportDirectiveSubclass {\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective {\n-    pub module_path: Vec<Name>,\n-    pub subclass: ImportDirectiveSubclass,\n-    pub span: Span,\n-    pub id: NodeId,\n-    pub is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n-    pub is_prelude: bool,\n+    module_path: Vec<Name>,\n+    subclass: ImportDirectiveSubclass,\n+    span: Span,\n+    id: NodeId,\n+    is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n+    is_prelude: bool,\n }\n \n impl ImportDirective {\n@@ -285,7 +283,6 @@ impl<'a> ::ModuleS<'a> {\n \n     fn define_in_glob_importers(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>) {\n         if !binding.defined_with(DefModifiers::PUBLIC | DefModifiers::IMPORTABLE) { return }\n-        if binding.is_extern_crate() { return }\n         for &(importer, directive) in self.glob_importers.borrow_mut().iter() {\n             let _ = importer.try_define_child(name, ns, directive.import(binding, None));\n         }\n@@ -384,7 +381,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n                module_to_string(&module_));\n         let orig_module = replace(&mut self.resolver.current_module, module_);\n-        self.resolve_imports_for_module(module_, errors);\n+        self.resolve_imports_in_current_module(errors);\n         self.resolver.current_module = orig_module;\n \n         for (_, child_module) in module_.module_children.borrow().iter() {\n@@ -393,29 +390,31 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self,\n-                                  module: Module<'b>,\n-                                  errors: &mut Vec<ImportResolvingError<'b>>) {\n+    fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n         let mut imports = Vec::new();\n-        let mut unresolved_imports = module.unresolved_imports.borrow_mut();\n+        let mut unresolved_imports = self.resolver.current_module.unresolved_imports.borrow_mut();\n         ::std::mem::swap(&mut imports, &mut unresolved_imports);\n \n         for import_directive in imports {\n-            match self.resolve_import_for_module(module, &import_directive) {\n+            match self.resolve_import(&import_directive) {\n                 Failed(err) => {\n                     let (span, help) = match err {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new()),\n                     };\n                     errors.push(ImportResolvingError {\n-                        source_module: module,\n+                        source_module: self.resolver.current_module,\n                         import_directive: import_directive,\n                         span: span,\n                         help: help,\n                     });\n                 }\n                 Indeterminate => unresolved_imports.push(import_directive),\n-                Success(()) => {}\n+                Success(()) => {\n+                    // Decrement the count of unresolved imports.\n+                    assert!(self.resolver.unresolved_imports >= 1);\n+                    self.resolver.unresolved_imports -= 1;\n+                }\n             }\n         }\n     }\n@@ -425,43 +424,27 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(&mut self,\n-                                 module_: Module<'b>,\n-                                 import_directive: &'b ImportDirective)\n-                                 -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective) -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               names_to_string(&import_directive.module_path),\n-               module_to_string(&module_));\n-\n-        self.resolver\n-            .resolve_module_path(&import_directive.module_path,\n-                                 UseLexicalScopeFlag::DontUseLexicalScope,\n-                                 import_directive.span)\n-            .and_then(|containing_module| {\n-                // We found the module that the target is contained\n-                // within. Attempt to resolve the import within it.\n-                self.resolve_import(module_, containing_module, import_directive)\n-            })\n-            .and_then(|()| {\n-                // Decrement the count of unresolved imports.\n-                assert!(self.resolver.unresolved_imports >= 1);\n-                self.resolver.unresolved_imports -= 1;\n-                Success(())\n-            })\n-    }\n+               names_to_string(&directive.module_path),\n+               module_to_string(self.resolver.current_module));\n+\n+        let target_module = match self.resolver.resolve_module_path(&directive.module_path,\n+                                                                    DontUseLexicalScope,\n+                                                                    directive.span) {\n+            Success(module) => module,\n+            Indeterminate => return Indeterminate,\n+            Failed(err) => return Failed(err),\n+        };\n \n-    fn resolve_import(&mut self,\n-                      module_: Module<'b>,\n-                      target_module: Module<'b>,\n-                      directive: &'b ImportDirective)\n-                      -> ResolveResult<()> {\n         let (source, target, value_determined, type_determined) = match directive.subclass {\n             SingleImport { source, target, ref value_determined, ref type_determined } =>\n                 (source, target, value_determined, type_determined),\n-            GlobImport => return self.resolve_glob_import(module_, target_module, directive),\n+            GlobImport => return self.resolve_glob_import(target_module, directive),\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n+        let module_ = self.resolver.current_module;\n         let (value_result, type_result) = {\n             let mut resolve_in_ns = |ns, determined: bool| {\n                 // Temporarily count the directive as determined so that the resolution fails\n@@ -596,21 +579,19 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     // succeeds or bails out (as importing * from an empty module or a module\n     // that exports nothing is valid). target_module is the module we are\n     // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self,\n-                           module_: Module<'b>,\n-                           target_module: Module<'b>,\n-                           directive: &'b ImportDirective)\n+    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective)\n                            -> ResolveResult<()> {\n         if let Some(Def::Trait(_)) = target_module.def {\n             self.resolver.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n+        let module_ = self.resolver.current_module;\n         if module_.def_id() == target_module.def_id() {\n             // This means we are trying to glob import a module into itself, and it is a no-go\n             let msg = \"Cannot glob-import a module into itself.\".into();\n             return Failed(Some((directive.span, msg)));\n         }\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n+        self.resolver.populate_module_if_necessary(target_module);\n \n         if directive.is_prelude {\n             *module_.prelude.borrow_mut() = Some(target_module);"}, {"sha": "f59caef4631361f546e077efd37784b1362605d9", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bfd5c0b7b57b3e90be5c3e738b8c9426055433/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=13bfd5c0b7b57b3e90be5c3e738b8c9426055433", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR unresolved import `super::f`\n+use super::f; //~ ERROR unresolved import `super::f`. There are too many initial `super`s.\n \n fn main() {\n }"}]}