{"sha": "1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOWU2NmMwZWJmYjE2Njg2Y2E0ZjU3Y2JjN2FmMTM0M2FkMDgyNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-05T18:16:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-05T18:16:44Z"}, "message": "auto merge of #11304 : alexcrichton/rust/eintr, r=brson\n\nCloses #11214", "tree": {"sha": "d5625f73c866bff2f2949faad17b352a5d27662f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5625f73c866bff2f2949faad17b352a5d27662f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "html_url": "https://github.com/rust-lang/rust/commit/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc148f9919d158576309fa95a50cd1866e97e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc148f9919d158576309fa95a50cd1866e97e66", "html_url": "https://github.com/rust-lang/rust/commit/8fc148f9919d158576309fa95a50cd1866e97e66"}, {"sha": "674d24e2e6fad26fc4cedc2fe935ade63198ba7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/674d24e2e6fad26fc4cedc2fe935ade63198ba7e", "html_url": "https://github.com/rust-lang/rust/commit/674d24e2e6fad26fc4cedc2fe935ade63198ba7e"}], "stats": {"total": 178, "additions": 108, "deletions": 70}, "files": [{"sha": "0021dfcb881a41a5b25436085e773d66fcff1268", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 59, "deletions": 41, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "patch": "@@ -20,7 +20,7 @@ use std::rt::rtio;\n use std::unstable::intrinsics;\n use std::vec;\n \n-use super::IoResult;\n+use io::{IoResult, retry};\n \n #[cfg(windows)] use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n #[cfg(windows)] use std::ptr;\n@@ -143,8 +143,8 @@ impl rtio::RtioFileStream for FileDesc {\n                 overlap.OffsetHigh = (offset >> 32) as libc::DWORD;\n \n                 match libc::ReadFile(handle, buf as libc::LPVOID,\n-                                     amt as libc::DWORD,\n-                                     &mut bytes_read, &mut overlap) {\n+                                   amt as libc::DWORD,\n+                                   &mut bytes_read, &mut overlap) {\n                     0 => Err(super::last_error()),\n                     _ => Ok(bytes_read as int)\n                 }\n@@ -153,10 +153,10 @@ impl rtio::RtioFileStream for FileDesc {\n \n         #[cfg(unix)]\n         fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n-            match unsafe {\n+            match retry(|| unsafe {\n                 libc::pread(fd, buf as *libc::c_void, amt as libc::size_t,\n-                            offset as libc::off_t)\n-            } {\n+                            offset as libc::off_t) as libc::c_int\n+            }) {\n                 -1 => Err(super::last_error()),\n                 n => Ok(n as int)\n             }\n@@ -184,10 +184,10 @@ impl rtio::RtioFileStream for FileDesc {\n \n         #[cfg(unix)]\n         fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n-            super::mkerr_libc(unsafe {\n+            super::mkerr_libc(retry(|| unsafe {\n                 libc::pwrite(fd, buf as *libc::c_void, amt as libc::size_t,\n                              offset as libc::off_t)\n-            } as c_int)\n+            } as c_int))\n         }\n     }\n     #[cfg(windows)]\n@@ -240,7 +240,7 @@ impl rtio::RtioFileStream for FileDesc {\n         }\n         #[cfg(unix)]\n         fn os_fsync(fd: c_int) -> IoResult<()> {\n-            super::mkerr_libc(unsafe { libc::fsync(fd) })\n+            super::mkerr_libc(retry(|| unsafe { libc::fsync(fd) }))\n         }\n     }\n     #[cfg(windows)]\n@@ -255,9 +255,13 @@ impl rtio::RtioFileStream for FileDesc {\n             unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n         }\n         #[cfg(target_os = \"linux\")]\n-        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fdatasync(fd) } }\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fdatasync(fd) })\n+        }\n         #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n-        fn os_datasync(fd: c_int) -> c_int { unsafe { libc::fsync(fd) } }\n+        fn os_datasync(fd: c_int) -> c_int {\n+            retry(|| unsafe { libc::fsync(fd) })\n+        }\n     }\n \n     #[cfg(windows)]\n@@ -278,9 +282,9 @@ impl rtio::RtioFileStream for FileDesc {\n     }\n     #[cfg(unix)]\n     fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        super::mkerr_libc(unsafe {\n+        super::mkerr_libc(retry(|| unsafe {\n             libc::ftruncate(self.fd, offset as libc::off_t)\n-        })\n+        }))\n     }\n }\n \n@@ -311,9 +315,17 @@ impl rtio::RtioTTY for FileDesc {\n \n impl Drop for FileDesc {\n     fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n         if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n-            unsafe { libc::close(self.fd); }\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                warn!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n         }\n     }\n }\n@@ -336,7 +348,7 @@ impl CFile {\n     }\n \n     pub fn flush(&mut self) -> Result<(), IoError> {\n-        super::mkerr_libc(unsafe { libc::fflush(self.file) })\n+        super::mkerr_libc(retry(|| unsafe { libc::fflush(self.file) }))\n     }\n }\n \n@@ -444,13 +456,13 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n     #[cfg(windows)]\n     fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n         as_utf16_p(path.as_str().unwrap(), |path| {\n-            unsafe { libc::wopen(path, flags, mode) }\n+            retry(|| unsafe { libc::wopen(path, flags, mode) })\n         })\n     }\n \n     #[cfg(unix)]\n     fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        unsafe { libc::open(path.with_ref(|p| p), flags, mode) }\n+        retry(|| unsafe { libc::open(path.with_ref(|p| p), flags, mode) })\n     }\n }\n \n@@ -469,9 +481,9 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_mkdir(p: &CString, mode: c_int) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n+        super::mkerr_libc(retry(|| unsafe {\n             libc::mkdir(p.with_ref(|p| p), mode as libc::mode_t)\n-        })\n+        }))\n     }\n }\n \n@@ -582,7 +594,7 @@ pub fn unlink(p: &CString) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_unlink(p: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe { libc::unlink(p.with_ref(|p| p)) })\n+        super::mkerr_libc(retry(|| unsafe { libc::unlink(p.with_ref(|p| p)) }))\n     }\n }\n \n@@ -602,9 +614,9 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n+        super::mkerr_libc(retry(|| unsafe {\n             libc::rename(old.with_ref(|p| p), new.with_ref(|p| p))\n-        })\n+        }))\n     }\n }\n \n@@ -614,13 +626,15 @@ pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_chmod(p: &CString, mode: c_int) -> c_int {\n         unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wchmod(p, mode))\n+            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n+                libc::wchmod(p, mode)\n+            }))\n         }\n     }\n \n     #[cfg(unix)]\n     fn os_chmod(p: &CString, mode: c_int) -> c_int {\n-        unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) }\n+        retry(||unsafe { libc::chmod(p.with_ref(|p| p), mode as libc::mode_t) })\n     }\n }\n \n@@ -630,13 +644,15 @@ pub fn rmdir(p: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_rmdir(p: &CString) -> c_int {\n         unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wrmdir(p))\n+            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n+                libc::wrmdir(p)\n+            }))\n         }\n     }\n \n     #[cfg(unix)]\n     fn os_rmdir(p: &CString) -> c_int {\n-        unsafe { libc::rmdir(p.with_ref(|p| p)) }\n+        retry(|| unsafe { libc::rmdir(p.with_ref(|p| p)) })\n     }\n }\n \n@@ -649,10 +665,10 @@ pub fn chown(p: &CString, uid: int, gid: int) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_chown(p: &CString, uid: int, gid: int) -> c_int {\n-        unsafe {\n+        retry(|| unsafe {\n             libc::chown(p.with_ref(|p| p), uid as libc::uid_t,\n                         gid as libc::gid_t)\n-        }\n+        })\n     }\n }\n \n@@ -697,10 +713,10 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n             len = 1024; // XXX: read PATH_MAX from C ffi?\n         }\n         let mut buf = vec::with_capacity::<u8>(len as uint);\n-        match unsafe {\n+        match retry(|| unsafe {\n             libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n-                           len as libc::size_t)\n-        } {\n+                           len as libc::size_t) as libc::c_int\n+        }) {\n             -1 => Err(super::last_error()),\n             n => {\n                 assert!(n > 0);\n@@ -725,9 +741,9 @@ pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n+        super::mkerr_libc(retry(|| unsafe {\n             libc::symlink(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        })\n+        }))\n     }\n }\n \n@@ -745,9 +761,9 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(unix)]\n     fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_libc(unsafe {\n+        super::mkerr_libc(retry(|| unsafe {\n             libc::link(src.with_ref(|p| p), dst.with_ref(|p| p))\n-        })\n+        }))\n     }\n }\n \n@@ -842,7 +858,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n         as_utf16_p(p.as_str().unwrap(), |up| {\n-            match unsafe { libc::wstat(up, &mut stat) } {\n+            match retry(|| unsafe { libc::wstat(up, &mut stat) }) {\n                 0 => Ok(mkstat(&stat, p)),\n                 _ => Err(super::last_error()),\n             }\n@@ -852,7 +868,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     #[cfg(unix)]\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        match unsafe { libc::stat(p.with_ref(|p| p), &mut stat) } {\n+        match retry(|| unsafe { libc::stat(p.with_ref(|p| p), &mut stat) }) {\n             0 => Ok(mkstat(&stat, p)),\n             _ => Err(super::last_error()),\n         }\n@@ -871,7 +887,7 @@ pub fn lstat(p: &CString) -> IoResult<io::FileStat> {\n     #[cfg(unix)]\n     fn os_lstat(p: &CString) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        match unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) } {\n+        match retry(|| unsafe { libc::lstat(p.with_ref(|p| p), &mut stat) }) {\n             0 => Ok(mkstat(&stat, p)),\n             _ => Err(super::last_error()),\n         }\n@@ -888,7 +904,9 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n             modtime: (mtime / 1000) as libc::time64_t,\n         };\n         unsafe {\n-            as_utf16_p(p.as_str().unwrap(), |p| libc::wutime(p, &buf))\n+            as_utf16_p(p.as_str().unwrap(), |p| retry(|| {\n+                libc::wutime(p, &buf)\n+            }))\n         }\n     }\n \n@@ -898,7 +916,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n             actime: (atime / 1000) as libc::time_t,\n             modtime: (mtime / 1000) as libc::time_t,\n         };\n-        unsafe { libc::utime(p.with_ref(|p| p), &buf) }\n+        retry(|| unsafe { libc::utime(p.with_ref(|p| p), &buf) })\n     }\n }\n "}, {"sha": "f1bec440547e1ead57281e19963eab9735490b96", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "patch": "@@ -134,13 +134,24 @@ fn mkerr_winbool(ret: libc::c_int) -> IoResult<()> {\n     }\n }\n \n+#[cfg(windows)]\n+#[inline]\n+fn retry(f: || -> libc::c_int) -> libc::c_int {\n+    loop {\n+        match f() {\n+            -1 if os::errno() as int == libc::WSAEINTR as int => {}\n+            n => return n,\n+        }\n+    }\n+}\n+\n #[cfg(unix)]\n-fn retry(f: || -> libc::c_int) -> IoResult<libc::c_int> {\n+#[inline]\n+fn retry(f: || -> libc::c_int) -> libc::c_int {\n     loop {\n         match f() {\n             -1 if os::errno() as int == libc::EINTR as int => {}\n-            -1 => return Err(last_error()),\n-            n => return Ok(n),\n+            n => return n,\n         }\n     }\n }"}, {"sha": "b26ac141192bfb93ea9bff1859744332ea55343e", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "patch": "@@ -16,7 +16,7 @@ use std::mem;\n use std::rt::rtio;\n use std::unstable::intrinsics;\n \n-use super::IoResult;\n+use super::{IoResult, retry};\n use super::file::keep_going;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -227,8 +227,10 @@ impl TcpStream {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n                 let ret = TcpStream { fd: fd };\n-                match libc::connect(fd, addrp as *libc::sockaddr,\n-                                    len as libc::socklen_t) {\n+                match retry(|| {\n+                    libc::connect(fd, addrp as *libc::sockaddr,\n+                                  len as libc::socklen_t)\n+                }) {\n                     -1 => Err(super::last_error()),\n                     _ => Ok(ret),\n                 }\n@@ -394,9 +396,11 @@ impl TcpAcceptor {\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let size = mem::size_of::<libc::sockaddr_storage>();\n             let mut size = size as libc::socklen_t;\n-            match libc::accept(self.fd(),\n-                               storagep as *mut libc::sockaddr,\n-                               &mut size as *mut libc::socklen_t) {\n+            match retry(|| {\n+                libc::accept(self.fd(),\n+                             storagep as *mut libc::sockaddr,\n+                             &mut size as *mut libc::socklen_t) as libc::c_int\n+            }) as sock_t {\n                 -1 => Err(super::last_error()),\n                 fd => Ok(TcpStream { fd: fd })\n             }\n@@ -493,12 +497,14 @@ impl rtio::RtioUdpSocket for UdpSocket {\n             let storagep = &mut storage as *mut libc::sockaddr_storage;\n             let mut addrlen: libc::socklen_t =\n                     mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n-            let ret = libc::recvfrom(self.fd,\n-                                     buf.as_ptr() as *mut libc::c_void,\n-                                     buf.len() as msglen_t,\n-                                     0,\n-                                     storagep as *mut libc::sockaddr,\n-                                     &mut addrlen);\n+            let ret = retry(|| {\n+                libc::recvfrom(self.fd,\n+                               buf.as_ptr() as *mut libc::c_void,\n+                               buf.len() as msglen_t,\n+                               0,\n+                               storagep as *mut libc::sockaddr,\n+                               &mut addrlen) as libc::c_int\n+            });\n             if ret < 0 { return Err(super::last_error()) }\n             sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n                 Ok((ret as uint, addr))\n@@ -509,12 +515,14 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         let (dst, len) = addr_to_sockaddr(dst);\n         let dstp = &dst as *libc::sockaddr_storage;\n         unsafe {\n-            let ret = libc::sendto(self.fd,\n-                                   buf.as_ptr() as *libc::c_void,\n-                                   buf.len() as msglen_t,\n-                                   0,\n-                                   dstp as *libc::sockaddr,\n-                                   len as libc::socklen_t);\n+            let ret = retry(|| {\n+                libc::sendto(self.fd,\n+                             buf.as_ptr() as *libc::c_void,\n+                             buf.len() as msglen_t,\n+                             0,\n+                             dstp as *libc::sockaddr,\n+                             len as libc::socklen_t) as libc::c_int\n+            });\n             match ret {\n                 -1 => Err(super::last_error()),\n                 n if n as uint != buf.len() => {"}, {"sha": "0569c45f6def9e46b35687c1e21fb569835384e6", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d9e66c0ebfb16686ca4f57cbc7af1343ad08251/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=1d9e66c0ebfb16686ca4f57cbc7af1343ad08251", "patch": "@@ -16,11 +16,12 @@ use std::ptr;\n use std::rt::rtio;\n use p = std::io::process;\n \n-#[cfg(windows)] use std::cast;\n-\n use super::IoResult;\n use super::file;\n \n+#[cfg(windows)] use std::cast;\n+#[cfg(not(windows))] use super::retry;\n+\n /**\n  * A value representing a child process.\n  *\n@@ -445,17 +446,17 @@ fn spawn_process_os(prog: &str, args: &[~str],\n \n         if in_fd == -1 {\n             libc::close(libc::STDIN_FILENO);\n-        } else if dup2(in_fd, 0) == -1 {\n+        } else if retry(|| dup2(in_fd, 0)) == -1 {\n             fail!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n         }\n         if out_fd == -1 {\n             libc::close(libc::STDOUT_FILENO);\n-        } else if dup2(out_fd, 1) == -1 {\n+        } else if retry(|| dup2(out_fd, 1)) == -1 {\n             fail!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n         }\n         if err_fd == -1 {\n             libc::close(libc::STDERR_FILENO);\n-        } else if dup2(err_fd, 2) == -1 {\n+        } else if retry(|| dup2(err_fd, 2)) == -1 {\n             fail!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n         }\n         // close all other fds\n@@ -664,9 +665,9 @@ fn waitpid(pid: pid_t) -> p::ProcessExit {\n         }\n \n         let mut status = 0 as c_int;\n-        match super::retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n-            Err(e) => fail!(\"unknown waitpid error: {:?}\", e),\n-            Ok(_ret) => {\n+        match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+            -1 => fail!(\"unknown waitpid error: {:?}\", super::last_error()),\n+            _ => {\n                 if imp::WIFEXITED(status) {\n                     p::ExitStatus(imp::WEXITSTATUS(status) as int)\n                 } else {"}]}