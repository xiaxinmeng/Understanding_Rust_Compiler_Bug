{"sha": "05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YmIxZGJjNDNhNjIwZmJiZDY1YWU4MzBiYjUzYmE5NzY4YWMxODU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T23:01:22Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T23:01:22Z"}, "message": "OBRM for aturon", "tree": {"sha": "bc7fa8f0eb844ce528e2b32d2d6b370a2c3f1570", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc7fa8f0eb844ce528e2b32d2d6b370a2c3f1570"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "html_url": "https://github.com/rust-lang/rust/commit/05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "html_url": "https://github.com/rust-lang/rust/commit/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7"}], "stats": {"total": 76, "additions": 50, "deletions": 26}, "files": [{"sha": "a7014d7f0207a628869132a65e24329051f75b8a", "filename": "src/doc/tarpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2FSUMMARY.md?ref=05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "patch": "@@ -27,7 +27,7 @@\n \t* [Checked](checked-uninit.md)\n \t* [Drop Flags](drop-flags.md)\n \t* [Unchecked](unchecked-uninit.md)\n-* [Ownership-Oriented Resource Management](raii.md)\n+* [Ownership Based Resource Management](obrm.md)\n \t* [Constructors](constructors.md)\n \t* [Destructors](destructors.md)\n \t* [Leaking](leaking.md)"}, {"sha": "34c8b2b8624d3122cc4a4d52fbe1311a089bff99", "filename": "src/doc/tarpl/destructors.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fdestructors.md?ref=05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "patch": "@@ -45,8 +45,8 @@ impl<T> Drop for Box<T> {\n ```\n \n and this works fine because when Rust goes to drop the `ptr` field it just sees\n-a *mut that has no actual `Drop` implementation. Similarly nothing can use-\n-after-free the `ptr` because the Box is immediately marked as uninitialized.\n+a [Unique][] that has no actual `Drop` implementation. Similarly nothing can\n+use-after-free the `ptr` because when drop exits, it becomes inacessible.\n \n However this wouldn't work:\n \n@@ -174,3 +174,5 @@ arbitrarily invalid state in there.\n On balance this is an ok choice. Certainly what you should reach for by default.\n However, in the future we expect there to be a first-class way to announce that\n a field shouldn't be automatically dropped.\n+\n+[Unique]: phantom-data.html"}, {"sha": "dcb03b1c8b6a0df9ba93235f2ac3e3fe7fead53c", "filename": "src/doc/tarpl/leaking.md", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fleaking.md?ref=05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "patch": "@@ -8,14 +8,17 @@ is perfect and all of our problems are solved.\n \n Everything is terrible and we have new and exotic problems to try to solve.\n \n-Many people like to believe that Rust eliminates resource leaks, but this is\n-absolutely not the case, no matter how you look at it. In the strictest sense,\n-\"leaking\" is so abstract as to be unpreventable. It's quite trivial to\n-initialize a collection at the start of a program, fill it with tons of objects\n-with destructors, and then enter an infinite event loop that never refers to it.\n-The collection will sit around uselessly, holding on to its precious resources\n-until the program terminates (at which point all those resources would have been\n-reclaimed by the OS anyway).\n+Many people like to believe that Rust eliminates resource leaks. In practice,\n+this is basically true. You would be surprised to see a Safe Rust program\n+leak resources in an uncontrolled way.\n+\n+However from a theoretical perspective this is absolutely not the case, no\n+matter how you look at it. In the strictest sense, \"leaking\" is so abstract as\n+to be unpreventable. It's quite trivial to initialize a collection at the start\n+of a program, fill it with tons of objects with destructors, and then enter an\n+infinite event loop that never refers to it. The collection will sit around\n+uselessly, holding on to its precious resources until the program terminates (at\n+which point all those resources would have been reclaimed by the OS anyway).\n \n We may consider a more restricted form of leak: failing to drop a value that is\n unreachable. Rust also doesn't prevent this. In fact Rust has a *function for\n@@ -181,7 +184,26 @@ in memory.\n ## thread::scoped::JoinGuard\n \n The thread::scoped API intends to allow threads to be spawned that reference\n-data on the stack without any synchronization over that data. Usage looked like:\n+data on their parent's stack without any synchronization over that data by\n+ensuring the parent joins the thread before any of the shared data goes out\n+of scope.\n+\n+```rust\n+pub fn scoped<'a, F>(f: F) -> JoinGuard<'a>\n+    where F: FnOnce() + Send + 'a\n+```\n+\n+Here `f` is some closure for the other thread to execute. Saying that\n+`F: Send +'a` is saying that it closes over data that lives for `'a`, and it\n+either owns that data or the data was Sync (implying `&data` is Send).\n+\n+Because JoinGuard has a lifetime, it keeps all the data it closes over\n+borrowed in the parent thread. This means the JoinGuard can't outlive\n+the data that the other thread is working on. When the JoinGuard *does* get\n+dropped it blocks the parent thread, ensuring the child terminates before any\n+of the closed-over data goes out of scope in the parent.\n+\n+Usage looked like:\n \n ```rust,ignore\n let mut data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "2c495240c1278859aaaae31fdfb1e86e3e9b760d", "filename": "src/doc/tarpl/obrm.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fobrm.md", "raw_url": "https://github.com/rust-lang/rust/raw/05bb1dbc43a620fbbd65ae830bb53ba9768ac185/src%2Fdoc%2Ftarpl%2Fobrm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fobrm.md?ref=05bb1dbc43a620fbbd65ae830bb53ba9768ac185", "patch": "@@ -0,0 +1,14 @@\n+% The Perils Of Ownership Based Resource Management (OBRM)\n+\n+OBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\n+interact with a lot in Rust. Especially if you use the standard library.\n+\n+Roughly speaking the pattern is as follows: to acquire a resource, you create an\n+object that manages it. To release the resource, you simply destroy the object,\n+and it cleans up the resource for you. The most common \"resource\" this pattern\n+manages is simply *memory*. `Box`, `Rc`, and basically everything in\n+`std::collections` is a convenience to enable correctly managing memory. This is\n+particularly important in Rust because we have no pervasive GC to rely on for\n+memory management. Which is the point, really: Rust is about control. However we\n+are not limited to just memory. Pretty much every other system resource like a\n+thread, file, or socket is exposed through this kind of API."}, {"sha": "e9b92c69ccd2d1d747b955315567bdd32d2a21c0", "filename": "src/doc/tarpl/raii.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fraii.md", "raw_url": "https://github.com/rust-lang/rust/raw/fd13bdf626a50b5b21afbbe87806dc346f8ea9d7/src%2Fdoc%2Ftarpl%2Fraii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fraii.md?ref=fd13bdf626a50b5b21afbbe87806dc346f8ea9d7", "patch": "@@ -1,14 +0,0 @@\n-% The Perils Of RAII\n-\n-Ownership Based Resource Management (AKA RAII: Resource Acquisition Is Initialization) is\n-something you'll interact with a lot in Rust. Especially if you use the standard library.\n-\n-Roughly speaking the pattern is as follows: to acquire a resource, you create an object that\n-manages it. To release the resource, you simply destroy the object, and it cleans up the\n-resource for you. The most common \"resource\"\n-this pattern manages is simply *memory*. `Box`, `Rc`, and basically everything in\n-`std::collections` is a convenience to enable correctly managing memory. This is particularly\n-important in Rust because we have no pervasive GC to rely on for memory management. Which is the\n-point, really: Rust is about control. However we are not limited to just memory.\n-Pretty much every other system resource like a thread, file, or socket is exposed through\n-this kind of API."}]}