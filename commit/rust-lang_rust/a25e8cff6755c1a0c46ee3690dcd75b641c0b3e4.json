{"sha": "a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWU4Y2ZmNjc1NWMxYTBjNDZlZTM2OTBkY2Q3NWI2NDFjMGIzZTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-06T14:19:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-06T14:19:06Z"}, "message": "Merge #2487\n\n2487: Don't unify within a reference r=matklad a=flodiebold\n\nIf we are expecting a `&Foo` and get a `&something`, when checking the `something`, we are *expecting* a `Foo`, but we shouldn't try to unify whatever we get with that expectation, because it could actually be a `&Foo`, and `&&Foo` coerces to `&Foo`. So this fixes quite a few false type mismatches.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "891cf4be4893c79598800928e7c0b669d9d2a9c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/891cf4be4893c79598800928e7c0b669d9d2a9c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6mNaCRBK7hj4Ov3rIwAAdHIIAAOaSE1j/mutGIskscMY0AE1\nCTD5Xu2l2RAChjWN6sS6W5TwL2mBQTMsEjEzMdxVWZHhaTckCNZatjhEe72c2cj2\nAaw8I1uCBb9IFdD7oIDyFYMqB1Lv0A0ck9fmpdL5Q+ncrLBLAc2uPtaSUTGZIuhY\nv81u0IFKzgEMVelgpj0bfimqkyOJ2dWwyOZyZuy7Q+8JWxoDg8wpUp0UE56gHtFi\n1hxA3MZLMxu9WLvipauM8DXDG9bgD3Ffw1f8QkezIsgXjXaWBn8ukeYbLmQsC9Yh\n8MFaRmZxAXmCnV+f0AzTqXsLrLqK/cXGhqua1c32MjanKIZETLwsWpRtQN7ju5E=\n=Z6lZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 891cf4be4893c79598800928e7c0b669d9d2a9c2\nparent d2b210a02e3e8ee1cf38909411fa8945aec99f4e\nparent f86fe3d891ab295e9e394a1338da86524a6205d3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1575641946 +0000\ncommitter GitHub <noreply@github.com> 1575641946 +0000\n\nMerge #2487\n\n2487: Don't unify within a reference r=matklad a=flodiebold\n\nIf we are expecting a `&Foo` and get a `&something`, when checking the `something`, we are *expecting* a `Foo`, but we shouldn't try to unify whatever we get with that expectation, because it could actually be a `&Foo`, and `&&Foo` coerces to `&Foo`. So this fixes quite a few false type mismatches.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "html_url": "https://github.com/rust-lang/rust/commit/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2b210a02e3e8ee1cf38909411fa8945aec99f4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b210a02e3e8ee1cf38909411fa8945aec99f4e", "html_url": "https://github.com/rust-lang/rust/commit/d2b210a02e3e8ee1cf38909411fa8945aec99f4e"}, {"sha": "f86fe3d891ab295e9e394a1338da86524a6205d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f86fe3d891ab295e9e394a1338da86524a6205d3", "html_url": "https://github.com/rust-lang/rust/commit/f86fe3d891ab295e9e394a1338da86524a6205d3"}], "stats": {"total": 83, "additions": 72, "deletions": 11}, "files": [{"sha": "b8df277063e073ec4a0c568f1fbaa65bd9d3a453", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "patch": "@@ -201,7 +201,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n+                    self.infer_expr_coerce(*expr, &Expectation::has_type(self.return_ty.clone()));\n                 }\n                 Ty::simple(TypeCtor::Never)\n             }\n@@ -245,7 +245,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 ty\n             }\n             Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n+                let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let canonicalized = self.canonicalizer().canonicalize_ty(receiver_ty);\n                 let ty = autoderef::autoderef(\n                     self.db,\n@@ -280,7 +280,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 self.normalize_associated_types_in(ty)\n             }\n             Expr::Await { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let ty = match self.resolve_future_future_output() {\n                     Some(future_future_output_alias) => {\n                         let ty = self.table.new_type_var();\n@@ -299,7 +299,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 ty\n             }\n             Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let ty = match self.resolve_ops_try_ok() {\n                     Some(ops_try_ok_alias) => {\n                         let ty = self.table.new_type_var();\n@@ -318,7 +318,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 ty\n             }\n             Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let _inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n                 // FIXME check the cast...\n                 cast_ty\n@@ -334,20 +334,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     } else {\n                         Expectation::none()\n                     };\n-                // FIXME reference coercions etc.\n-                let inner_ty = self.infer_expr(*expr, &expectation);\n+                let inner_ty = self.infer_expr_inner(*expr, &expectation);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n             Expr::Box { expr } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 if let Some(box_) = self.resolve_boxed_box() {\n                     Ty::apply_one(TypeCtor::Adt(box_), inner_ty)\n                 } else {\n                     Ty::Unknown\n                 }\n             }\n             Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 match op {\n                     UnaryOp::Deref => match self.resolver.krate() {\n                         Some(krate) => {\n@@ -417,7 +416,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 _ => Ty::Unknown,\n             },\n             Expr::Range { lhs, rhs, range_type } => {\n-                let lhs_ty = lhs.map(|e| self.infer_expr(e, &Expectation::none()));\n+                let lhs_ty = lhs.map(|e| self.infer_expr_inner(e, &Expectation::none()));\n                 let rhs_expect = lhs_ty\n                     .as_ref()\n                     .map_or_else(Expectation::none, |ty| Expectation::has_type(ty.clone()));\n@@ -455,7 +454,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n             Expr::Index { base, index } => {\n-                let _base_ty = self.infer_expr(*base, &Expectation::none());\n+                let _base_ty = self.infer_expr_inner(*base, &Expectation::none());\n                 let _index_ty = self.infer_expr(*index, &Expectation::none());\n                 // FIXME: use `std::ops::Index::Output` to figure out the real return type\n                 Ty::Unknown"}, {"sha": "f1b67555f233a8b4b02b4893bfaba2e13c08300b", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "patch": "@@ -50,13 +50,18 @@ fn type_at(content: &str) -> String {\n }\n \n fn infer(content: &str) -> String {\n+    infer_with_mismatches(content, false)\n+}\n+\n+fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n     let (db, file_id) = TestDB::with_single_file(content);\n \n     let mut acc = String::new();\n \n     let mut infer_def = |inference_result: Arc<InferenceResult>,\n                          body_source_map: Arc<BodySourceMap>| {\n         let mut types = Vec::new();\n+        let mut mismatches = Vec::new();\n \n         for (pat, ty) in inference_result.type_of_pat.iter() {\n             let syntax_ptr = match body_source_map.pat_syntax(pat) {\n@@ -76,6 +81,9 @@ fn infer(content: &str) -> String {\n                 None => continue,\n             };\n             types.push((syntax_ptr, ty));\n+            if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr) {\n+                mismatches.push((syntax_ptr, mismatch));\n+            }\n         }\n \n         // sort ranges for consistency\n@@ -101,6 +109,24 @@ fn infer(content: &str) -> String {\n             )\n             .unwrap();\n         }\n+        if include_mismatches {\n+            mismatches.sort_by_key(|(src_ptr, _)| {\n+                (src_ptr.value.range().start(), src_ptr.value.range().end())\n+            });\n+            for (src_ptr, mismatch) in &mismatches {\n+                let range = src_ptr.value.range();\n+                let macro_prefix = if src_ptr.file_id != file_id.into() { \"!\" } else { \"\" };\n+                write!(\n+                    acc,\n+                    \"{}{}: expected {}, got {}\\n\",\n+                    macro_prefix,\n+                    range,\n+                    mismatch.expected.display(&db),\n+                    mismatch.actual.display(&db),\n+                )\n+                .unwrap();\n+            }\n+        }\n     };\n \n     let module = db.module_for_file(file_id);"}, {"sha": "58b22396fc9cf978189c4280334b498d1c0e0ac2", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a25e8cff6755c1a0c46ee3690dcd75b641c0b3e4", "patch": "@@ -1,3 +1,4 @@\n+use super::infer_with_mismatches;\n use insta::assert_snapshot;\n use test_utils::covers;\n \n@@ -367,3 +368,38 @@ fn test() {\n     \"###\n     );\n }\n+\n+#[test]\n+fn coerce_autoderef() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+struct Foo;\n+fn takes_ref_foo(x: &Foo) {}\n+fn test() {\n+    takes_ref_foo(&Foo);\n+    takes_ref_foo(&&Foo);\n+    takes_ref_foo(&&&Foo);\n+}\n+\"#, true),\n+        @r###\"\n+    [30; 31) 'x': &Foo\n+    [39; 41) '{}': ()\n+    [52; 133) '{     ...oo); }': ()\n+    [58; 71) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [58; 77) 'takes_...(&Foo)': ()\n+    [72; 76) '&Foo': &Foo\n+    [73; 76) 'Foo': Foo\n+    [83; 96) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [83; 103) 'takes_...&&Foo)': ()\n+    [97; 102) '&&Foo': &&Foo\n+    [98; 102) '&Foo': &Foo\n+    [99; 102) 'Foo': Foo\n+    [109; 122) 'takes_ref_foo': fn takes_ref_foo(&Foo) -> ()\n+    [109; 130) 'takes_...&&Foo)': ()\n+    [123; 129) '&&&Foo': &&&Foo\n+    [124; 129) '&&Foo': &&Foo\n+    [125; 129) '&Foo': &Foo\n+    [126; 129) 'Foo': Foo\n+    \"###\n+    );\n+}"}]}