{"sha": "8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMmIwZTYwNjQzMzBmOWU3YjA0Y2JkNjgzNmU5ZjBiNWMwYWI0ZTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-02T12:09:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-02T12:09:51Z"}, "message": "Merge #7847\n\n7847: Switch from pico-args to xflags r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0944b063e9ea128a111027d83bc0411004af9fe4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0944b063e9ea128a111027d83bc0411004af9fe4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPisPCRBK7hj4Ov3rIwAAdHIIACs0YhiTfw6N/aQ587LGi8hv\nJJZS2/oQr6TV4k/1dcPrfJQIqPNmfroWP/DKlRBkVCROHXaCBM05/Kd1GhiWiaiX\n9VQebQBAQ/h15Vc0fVu+T4Kcqm6BpkEnsGVnIl7/Cxc0jpfBpcZjIwlINucx79wO\nJByYSdpz4dbw2T2geHboL4nkMVhq3HBG+LhNrbfkkTaWcp5JGMeUSe2CcLXR5K/P\nkcH8aC8anFL3mInaHmUrNgNrJKM24hL9da7Gdta8kLhlwfAB2HkfOVxEnhvgiIdS\nLYn6EuhxMwhZU0yy7WvtN8bVHVo7fCExlgH1xRDwJHy9naX3wMESmJsWB5EZpmU=\n=nFAx\n-----END PGP SIGNATURE-----\n", "payload": "tree 0944b063e9ea128a111027d83bc0411004af9fe4\nparent 61c73caa307a4972e8cc42a607d6974388d44d59\nparent 3038579c8ed446b296ff8afbe51ffcfa9c1869a2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614686991 +0000\ncommitter GitHub <noreply@github.com> 1614686991 +0000\n\nMerge #7847\n\n7847: Switch from pico-args to xflags r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "html_url": "https://github.com/rust-lang/rust/commit/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61c73caa307a4972e8cc42a607d6974388d44d59", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c73caa307a4972e8cc42a607d6974388d44d59", "html_url": "https://github.com/rust-lang/rust/commit/61c73caa307a4972e8cc42a607d6974388d44d59"}, {"sha": "3038579c8ed446b296ff8afbe51ffcfa9c1869a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3038579c8ed446b296ff8afbe51ffcfa9c1869a2", "html_url": "https://github.com/rust-lang/rust/commit/3038579c8ed446b296ff8afbe51ffcfa9c1869a2"}], "stats": {"total": 629, "additions": 317, "deletions": 312}, "files": [{"sha": "625c618831135d1480da287874f41d26cfef7161", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "patch": "@@ -1114,12 +1114,6 @@ dependencies = [\n  \"indexmap\",\n ]\n \n-[[package]]\n-name = \"pico-args\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d70072c20945e1ab871c472a285fc772aefd4f5407723c206242f2c6f94595d6\"\n-\n [[package]]\n name = \"pin-project-lite\"\n version = \"0.2.4\"\n@@ -1339,7 +1333,6 @@ dependencies = [\n  \"mimalloc\",\n  \"oorandom\",\n  \"parking_lot\",\n- \"pico-args\",\n  \"proc_macro_srv\",\n  \"profile\",\n  \"project_model\",\n@@ -1361,6 +1354,7 @@ dependencies = [\n  \"vfs\",\n  \"vfs-notify\",\n  \"winapi\",\n+ \"xflags\",\n ]\n \n [[package]]\n@@ -1914,18 +1908,18 @@ checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n \n [[package]]\n name = \"xflags\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a6292b9528efc06cb25a41b8a0814dd3a9590c0fe2cd95341fe41bbe034fafb\"\n+checksum = \"ddb4b07c0db813f8e2b5e1b2189ef56fcddb27a6f9ef71314dbf8cc50096a5db\"\n dependencies = [\n  \"xflags-macros\",\n ]\n \n [[package]]\n name = \"xflags-macros\"\n-version = \"0.1.2\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba2108d40e49a0653f2ee4eda59f51447e0cab5cc2cc197a5abd96525c6bd89e\"\n+checksum = \"f8e168a99d6ce9d5dd0d0913f1bded279377843952dd8ff83f81b862a1dad0e1\"\n dependencies = [\n  \"proc-macro2\",\n ]"}, {"sha": "8789f085218b819e7cbd48bcab5c73756ffc0490", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "patch": "@@ -24,7 +24,7 @@ jod-thread = \"0.1.0\"\n log = \"0.4.8\"\n lsp-types = { version = \"0.88.0\", features = [\"proposed\"] }\n parking_lot = \"0.11.0\"\n-pico-args = \"0.4.0\"\n+xflags = \"0.1.2\"\n oorandom = \"11.1.2\"\n rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.106\", features = [\"derive\"] }"}, {"sha": "164d94a3044e6e5160b7917c58eae97ae1caf8fb", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/61c73caa307a4972e8cc42a607d6974388d44d59/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c73caa307a4972e8cc42a607d6974388d44d59/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=61c73caa307a4972e8cc42a607d6974388d44d59", "patch": "@@ -1,274 +0,0 @@\n-//! Command like parsing for rust-analyzer.\n-//!\n-//! If run started args, we run the LSP server loop. With a subcommand, we do a\n-//! one-time batch processing.\n-\n-use std::{env, path::PathBuf};\n-\n-use anyhow::{bail, format_err, Result};\n-use ide_ssr::{SsrPattern, SsrRule};\n-use pico_args::Arguments;\n-use rust_analyzer::cli::{AnalysisStatsCmd, BenchCmd, BenchWhat, Position, Verbosity};\n-use vfs::AbsPathBuf;\n-\n-pub(crate) struct Args {\n-    pub(crate) verbosity: Verbosity,\n-    pub(crate) log_file: Option<PathBuf>,\n-    pub(crate) no_buffering: bool,\n-    pub(crate) command: Command,\n-    #[allow(unused)]\n-    pub(crate) wait_dbg: bool,\n-}\n-\n-pub(crate) enum Command {\n-    Parse { no_dump: bool },\n-    Symbols,\n-    Highlight { rainbow: bool },\n-    AnalysisStats(AnalysisStatsCmd),\n-    Bench(BenchCmd),\n-    Diagnostics { path: PathBuf, load_output_dirs: bool, with_proc_macro: bool },\n-    Ssr { rules: Vec<SsrRule> },\n-    StructuredSearch { debug_snippet: Option<String>, patterns: Vec<SsrPattern> },\n-    ProcMacro,\n-    RunServer,\n-    PrintConfigSchema,\n-    Version,\n-    Help,\n-}\n-\n-const HELP: &str = \"\\\n-rust-analyzer\n-\n-USAGE:\n-    rust-analyzer [FLAGS] [COMMAND] [COMMAND_OPTIONS]\n-\n-FLAGS:\n-    --version         Print version\n-    -h, --help        Print this help\n-\n-    -v,  --verbose\n-    -vv, --spammy\n-    -q,  --quiet      Set verbosity\n-\n-    --print-config-schema\n-                      Dump a LSP config JSON schema\n-    --log-file <PATH> Log to the specified file instead of stderr\n-    --no-log-buffering\n-                      Flush log records to the file immediately\n-\n-    --wait-dbg        Wait until a debugger is attached to.\n-                      The flag is valid for debug builds only\n-\n-ENVIRONMENTAL VARIABLES:\n-    RA_LOG            Set log filter in env_logger format\n-    RA_PROFILE        Enable hierarchical profiler\n-    RA_WAIT_DBG       If set acts like a --wait-dbg flag\n-\n-COMMANDS:\n-\n-not specified         Launch LSP server\n-\n-parse < main.rs       Parse tree\n-    --no-dump         Suppress printing\n-\n-symbols < main.rs     Parse input an print the list of symbols\n-\n-highlight < main.rs   Highlight input as html\n-    --rainbow         Enable rainbow highlighting of identifiers\n-\n-analysis-stats <PATH> Batch typecheck project and print summary statistics\n-    <PATH>            Directory with Cargo.toml\n-    --randomize       Randomize order in which crates, modules, and items are processed\n-    --parallel        Run type inference in parallel\n-    --memory-usage    Collect memory usage statistics\n-    -o, --only <PATH> Only analyze items matching this path\n-    --with-deps       Also analyze all dependencies\n-    --load-output-dirs\n-                      Load OUT_DIR values by running `cargo check` before analysis\n-    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n-\n-analysis-bench <PATH> Benchmark specific analysis operation\n-    <PATH>            Directory with Cargo.toml\n-    --highlight <PATH>\n-                      Compute syntax highlighting for this file\n-    --complete <PATH:LINE:COLUMN>\n-                      Compute completions at this location\n-    --goto-def <PATH:LINE:COLUMN>\n-                      Compute goto definition at this location\n-    --memory-usage    Collect memory usage statistics\n-    --load-output-dirs\n-                      Load OUT_DIR values by running `cargo check` before analysis\n-    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n-\n-diagnostics <PATH>\n-    <PATH>            Directory with Cargo.toml\n-    --load-output-dirs\n-                      Load OUT_DIR values by running `cargo check` before analysis\n-    --with-proc-macro Use proc-macro-srv for proc-macro expanding\n-\n-ssr [RULE...]\n-    <RULE>            A structured search replace rule (`$a.foo($b) ==> bar($a, $b)`)\n-\n-search [PATTERN..]\n-    <PATTERN>         A structured search replace pattern (`$a.foo($b)`)\n-    --debug <snippet> Prints debug information for any nodes with source exactly\n-                      equal to <snippet>\n-\";\n-\n-impl Args {\n-    pub(crate) fn parse() -> Result<Args> {\n-        let mut matches = Arguments::from_env();\n-\n-        if matches.contains(\"--version\") {\n-            finish_args(matches)?;\n-            return Ok(Args {\n-                verbosity: Verbosity::Normal,\n-                log_file: None,\n-                command: Command::Version,\n-                no_buffering: false,\n-                wait_dbg: false,\n-            });\n-        }\n-\n-        let verbosity = match (\n-            matches.contains([\"-vv\", \"--spammy\"]),\n-            matches.contains([\"-v\", \"--verbose\"]),\n-            matches.contains([\"-q\", \"--quiet\"]),\n-        ) {\n-            (true, _, true) => bail!(\"Invalid flags: -q conflicts with -vv\"),\n-            (true, _, false) => Verbosity::Spammy,\n-            (false, false, false) => Verbosity::Normal,\n-            (false, false, true) => Verbosity::Quiet,\n-            (false, true, false) => Verbosity::Verbose,\n-            (false, true, true) => bail!(\"Invalid flags: -q conflicts with -v\"),\n-        };\n-        let log_file = matches.opt_value_from_str(\"--log-file\")?;\n-        let no_buffering = matches.contains(\"--no-log-buffering\");\n-        let wait_dbg = matches.contains(\"--wait-dbg\");\n-\n-        if matches.contains([\"-h\", \"--help\"]) {\n-            eprintln!(\"{}\", HELP);\n-            return Ok(Args {\n-                verbosity,\n-                log_file: None,\n-                command: Command::Help,\n-                no_buffering,\n-                wait_dbg,\n-            });\n-        }\n-\n-        if matches.contains(\"--print-config-schema\") {\n-            return Ok(Args {\n-                verbosity,\n-                log_file,\n-                command: Command::PrintConfigSchema,\n-                no_buffering,\n-                wait_dbg,\n-            });\n-        }\n-\n-        let subcommand = match matches.subcommand()? {\n-            Some(it) => it,\n-            None => {\n-                finish_args(matches)?;\n-                return Ok(Args {\n-                    verbosity,\n-                    log_file,\n-                    command: Command::RunServer,\n-                    no_buffering,\n-                    wait_dbg,\n-                });\n-            }\n-        };\n-        let command = match subcommand.as_str() {\n-            \"parse\" => Command::Parse { no_dump: matches.contains(\"--no-dump\") },\n-            \"symbols\" => Command::Symbols,\n-            \"highlight\" => Command::Highlight { rainbow: matches.contains(\"--rainbow\") },\n-            \"analysis-stats\" => Command::AnalysisStats(AnalysisStatsCmd {\n-                randomize: matches.contains(\"--randomize\"),\n-                parallel: matches.contains(\"--parallel\"),\n-                memory_usage: matches.contains(\"--memory-usage\"),\n-                only: matches.opt_value_from_str([\"-o\", \"--only\"])?,\n-                with_deps: matches.contains(\"--with-deps\"),\n-                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n-                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n-                path: matches\n-                    .opt_free_from_str()?\n-                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n-            }),\n-            \"analysis-bench\" => Command::Bench(BenchCmd {\n-                what: {\n-                    let highlight_path: Option<String> =\n-                        matches.opt_value_from_str(\"--highlight\")?;\n-                    let complete_path: Option<Position> =\n-                        matches.opt_value_from_str(\"--complete\")?;\n-                    let goto_def_path: Option<Position> =\n-                        matches.opt_value_from_str(\"--goto-def\")?;\n-                    match (highlight_path, complete_path, goto_def_path) {\n-                            (Some(path), None, None) => {\n-                                let path = env::current_dir().unwrap().join(path);\n-                                BenchWhat::Highlight { path: AbsPathBuf::assert(path) }\n-                            }\n-                            (None, Some(position), None) => BenchWhat::Complete(position),\n-                            (None, None, Some(position)) => BenchWhat::GotoDef(position),\n-                            _ => panic!(\n-                                \"exactly one of  `--highlight`, `--complete` or `--goto-def` must be set\"\n-                            ),\n-                        }\n-                },\n-                memory_usage: matches.contains(\"--memory-usage\"),\n-                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n-                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n-                path: matches\n-                    .opt_free_from_str()?\n-                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n-            }),\n-            \"diagnostics\" => Command::Diagnostics {\n-                load_output_dirs: matches.contains(\"--load-output-dirs\"),\n-                with_proc_macro: matches.contains(\"--with-proc-macro\"),\n-                path: matches\n-                    .opt_free_from_str()?\n-                    .ok_or_else(|| format_err!(\"expected positional argument\"))?,\n-            },\n-            \"proc-macro\" => Command::ProcMacro,\n-            \"ssr\" => Command::Ssr {\n-                rules: {\n-                    let mut acc = Vec::new();\n-                    while let Some(rule) = matches.opt_free_from_str()? {\n-                        acc.push(rule);\n-                    }\n-                    acc\n-                },\n-            },\n-            \"search\" => Command::StructuredSearch {\n-                debug_snippet: matches.opt_value_from_str(\"--debug\")?,\n-                patterns: {\n-                    let mut acc = Vec::new();\n-                    while let Some(rule) = matches.opt_free_from_str()? {\n-                        acc.push(rule);\n-                    }\n-                    acc\n-                },\n-            },\n-            _ => {\n-                eprintln!(\"{}\", HELP);\n-                return Ok(Args {\n-                    verbosity,\n-                    log_file: None,\n-                    command: Command::Help,\n-                    no_buffering,\n-                    wait_dbg,\n-                });\n-            }\n-        };\n-        finish_args(matches)?;\n-        Ok(Args { verbosity, log_file, command, no_buffering, wait_dbg })\n-    }\n-}\n-\n-fn finish_args(args: Arguments) -> Result<()> {\n-    if !args.finish().is_empty() {\n-        bail!(\"Unused arguments.\");\n-    }\n-    Ok(())\n-}"}, {"sha": "244912d26e6e5ad35f746d93e0799cffe9e23574", "filename": "crates/rust-analyzer/src/bin/flags.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fflags.rs?ref=8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "patch": "@@ -0,0 +1,251 @@\n+//! Grammar for the command-line arguments.\n+#![allow(unreachable_pub)]\n+use std::{env, path::PathBuf};\n+\n+use ide_ssr::{SsrPattern, SsrRule};\n+use rust_analyzer::cli::{BenchWhat, Position, Verbosity};\n+use vfs::AbsPathBuf;\n+\n+xflags::args_parser! {\n+    /// LSP server for the Rust programming language.\n+    cmd rust-analyzer {\n+        /// Verbosity level, can be repeated multiple times.\n+        repeated -v, --verbose\n+        /// Verbosity level.\n+        optional -q, --quiet\n+\n+        /// Log to the specified file instead of stderr.\n+        optional --log-file path: PathBuf\n+        /// Flush log records to the file immediately.\n+        optional --no-log-buffering\n+\n+        /// Wait until a debugger is attached to (requires debug build).\n+        optional --wait-dbg\n+\n+        default cmd lsp-server {\n+            /// Print version.\n+            optional --version\n+            /// Print help.\n+            optional -h, --help\n+\n+            /// Dump a LSP config JSON schema.\n+            optional --print-config-schema\n+        }\n+\n+        /// Parse stdin.\n+        cmd parse {\n+            /// Suppress printing.\n+            optional --no-dump\n+        }\n+\n+        /// Parse stdin and print the list of symbols.\n+        cmd symbols {}\n+\n+        /// Highlight stdin as html.\n+        cmd highlight {\n+            /// Enable rainbow highlighting of identifiers.\n+            optional --rainbow\n+        }\n+\n+        /// Batch typecheck project and print summary statistics\n+        cmd analysis-stats\n+            /// Directory with Cargo.toml.\n+            required path: PathBuf\n+        {\n+            /// Randomize order in which crates, modules, and items are processed.\n+            optional --randomize\n+            /// Run type inference in parallel.\n+            optional --parallel\n+            /// Collect memory usage statistics.\n+            optional --memory-usage\n+\n+            /// Only analyze items matching this path.\n+            optional -o, --only path: String\n+            /// Also analyze all dependencies.\n+            optional --with-deps\n+\n+            /// Load OUT_DIR values by running `cargo check` before analysis.\n+            optional --load-output-dirs\n+            /// Use proc-macro-srv for proc-macro expanding.\n+            optional --with-proc-macro\n+        }\n+\n+        /// Benchmark specific analysis operation\n+        cmd analysis-bench\n+            /// Directory with Cargo.toml.\n+            required path: PathBuf\n+        {\n+            /// Collect memory usage statistics.\n+            optional --memory-usage\n+\n+            /// Compute syntax highlighting for this file\n+            optional --highlight path: PathBuf\n+            /// Compute completions at file:line:column location.\n+            optional --complete location: Position\n+            /// Compute goto definition at file:line:column location.\n+            optional --goto-def location: Position\n+\n+            /// Load OUT_DIR values by running `cargo check` before analysis.\n+            optional --load-output-dirs\n+            /// Use proc-macro-srv for proc-macro expanding.\n+            optional --with-proc-macro\n+        }\n+\n+        cmd diagnostics\n+            /// Directory with Cargo.toml.\n+            required path: PathBuf\n+        {\n+            /// Load OUT_DIR values by running `cargo check` before analysis.\n+            optional --load-output-dirs\n+            /// Use proc-macro-srv for proc-macro expanding.\n+            optional --with-proc-macro\n+        }\n+\n+        cmd ssr\n+            /// A structured search replace rule (`$a.foo($b) ==> bar($a, $b)`)\n+            repeated rule: SsrRule\n+        {}\n+\n+        cmd search\n+            /// A structured search replace pattern (`$a.foo($b)`)\n+            repeated pattern: SsrPattern\n+        {\n+            /// Prints debug information for any nodes with source exactly equal to snippet.\n+            optional --debug snippet: String\n+        }\n+\n+        cmd proc-macro {}\n+    }\n+}\n+\n+// generated start\n+// The following code is generated by `xflags` macro.\n+// Run `env XFLAGS_DUMP= cargo build` to regenerate.\n+#[derive(Debug)]\n+pub struct RustAnalyzer {\n+    pub verbose: u32,\n+    pub quiet: bool,\n+    pub log_file: Option<PathBuf>,\n+    pub no_log_buffering: bool,\n+    pub wait_dbg: bool,\n+    pub subcommand: RustAnalyzerCmd,\n+}\n+\n+#[derive(Debug)]\n+pub enum RustAnalyzerCmd {\n+    LspServer(LspServer),\n+    Parse(Parse),\n+    Symbols(Symbols),\n+    Highlight(Highlight),\n+    AnalysisStats(AnalysisStats),\n+    AnalysisBench(AnalysisBench),\n+    Diagnostics(Diagnostics),\n+    Ssr(Ssr),\n+    Search(Search),\n+    ProcMacro(ProcMacro),\n+}\n+\n+#[derive(Debug)]\n+pub struct LspServer {\n+    pub version: bool,\n+    pub help: bool,\n+    pub print_config_schema: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct Parse {\n+    pub no_dump: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct Symbols {}\n+\n+#[derive(Debug)]\n+pub struct Highlight {\n+    pub rainbow: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct AnalysisStats {\n+    pub path: PathBuf,\n+\n+    pub randomize: bool,\n+    pub parallel: bool,\n+    pub memory_usage: bool,\n+    pub only: Option<String>,\n+    pub with_deps: bool,\n+    pub load_output_dirs: bool,\n+    pub with_proc_macro: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct AnalysisBench {\n+    pub path: PathBuf,\n+\n+    pub memory_usage: bool,\n+    pub highlight: Option<PathBuf>,\n+    pub complete: Option<Position>,\n+    pub goto_def: Option<Position>,\n+    pub load_output_dirs: bool,\n+    pub with_proc_macro: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct Diagnostics {\n+    pub path: PathBuf,\n+\n+    pub load_output_dirs: bool,\n+    pub with_proc_macro: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct Ssr {\n+    pub rule: Vec<SsrRule>,\n+}\n+\n+#[derive(Debug)]\n+pub struct Search {\n+    pub pattern: Vec<SsrPattern>,\n+\n+    pub debug: Option<String>,\n+}\n+\n+#[derive(Debug)]\n+pub struct ProcMacro {}\n+\n+impl RustAnalyzer {\n+    pub const HELP: &'static str = Self::_HELP;\n+\n+    pub fn from_env() -> xflags::Result<Self> {\n+        let mut p = xflags::rt::Parser::new_from_env();\n+        Self::_parse(&mut p)\n+    }\n+}\n+// generated end\n+\n+impl RustAnalyzer {\n+    pub(crate) fn verbosity(&self) -> Verbosity {\n+        if self.quiet {\n+            return Verbosity::Quiet;\n+        }\n+        match self.verbose {\n+            0 => Verbosity::Normal,\n+            1 => Verbosity::Verbose,\n+            _ => Verbosity::Spammy,\n+        }\n+    }\n+}\n+\n+impl AnalysisBench {\n+    pub(crate) fn what(&self) -> BenchWhat {\n+        match (&self.highlight, &self.complete, &self.goto_def) {\n+            (Some(path), None, None) => {\n+                let path = env::current_dir().unwrap().join(path);\n+                BenchWhat::Highlight { path: AbsPathBuf::assert(path) }\n+            }\n+            (None, Some(position), None) => BenchWhat::Complete(position.clone()),\n+            (None, None, Some(position)) => BenchWhat::GotoDef(position.clone()),\n+            _ => panic!(\"exactly one of  `--highlight`, `--complete` or `--goto-def` must be set\"),\n+        }\n+    }\n+}"}, {"sha": "288847980b89afc67d4d10357fa019292413db3e", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 59, "deletions": 26, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "patch": "@@ -1,14 +1,20 @@\n //! Driver for rust-analyzer.\n //!\n //! Based on cli flags, either spawns an LSP server, or runs a batch analysis\n-mod args;\n+mod flags;\n mod logger;\n \n-use std::{convert::TryFrom, env, fs, path::PathBuf, process};\n+use std::{convert::TryFrom, env, fs, path::Path, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{cli, config::Config, from_json, lsp_ext::supports_utf8, Result};\n+use rust_analyzer::{\n+    cli::{self, AnalysisStatsCmd, BenchCmd},\n+    config::Config,\n+    from_json,\n+    lsp_ext::supports_utf8,\n+    Result,\n+};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -28,46 +34,73 @@ fn main() {\n }\n \n fn try_main() -> Result<()> {\n-    let args = args::Args::parse()?;\n+    let flags = flags::RustAnalyzer::from_env()?;\n \n     #[cfg(debug_assertions)]\n-    if args.wait_dbg || env::var(\"RA_WAIT_DBG\").is_ok() {\n+    if flags.wait_dbg || env::var(\"RA_WAIT_DBG\").is_ok() {\n         #[allow(unused_mut)]\n         let mut d = 4;\n         while d == 4 {\n             d = 4;\n         }\n     }\n \n-    setup_logging(args.log_file, args.no_buffering)?;\n-    match args.command {\n-        args::Command::RunServer => run_server()?,\n-        args::Command::PrintConfigSchema => {\n-            println!(\"{:#}\", Config::json_schema());\n+    setup_logging(flags.log_file.as_deref(), flags.no_log_buffering)?;\n+    let verbosity = flags.verbosity();\n+\n+    match flags.subcommand {\n+        flags::RustAnalyzerCmd::LspServer(cmd) => {\n+            if cmd.print_config_schema {\n+                println!(\"{:#}\", Config::json_schema());\n+                return Ok(());\n+            }\n+            if cmd.version {\n+                println!(\"rust-analyzer {}\", env!(\"REV\"));\n+                return Ok(());\n+            }\n+            if cmd.help {\n+                println!(\"{}\", flags::RustAnalyzer::HELP);\n+                return Ok(());\n+            }\n+            run_server()?\n         }\n-        args::Command::ProcMacro => proc_macro_srv::cli::run()?,\n-\n-        args::Command::Parse { no_dump } => cli::parse(no_dump)?,\n-        args::Command::Symbols => cli::symbols()?,\n-        args::Command::Highlight { rainbow } => cli::highlight(rainbow)?,\n-        args::Command::AnalysisStats(cmd) => cmd.run(args.verbosity)?,\n-        args::Command::Bench(cmd) => cmd.run(args.verbosity)?,\n-        args::Command::Diagnostics { path, load_output_dirs, with_proc_macro } => {\n-            cli::diagnostics(path.as_ref(), load_output_dirs, with_proc_macro)?\n+        flags::RustAnalyzerCmd::ProcMacro(_) => proc_macro_srv::cli::run()?,\n+        flags::RustAnalyzerCmd::Parse(cmd) => cli::parse(cmd.no_dump)?,\n+        flags::RustAnalyzerCmd::Symbols(_) => cli::symbols()?,\n+        flags::RustAnalyzerCmd::Highlight(cmd) => cli::highlight(cmd.rainbow)?,\n+        flags::RustAnalyzerCmd::AnalysisStats(cmd) => AnalysisStatsCmd {\n+            randomize: cmd.randomize,\n+            parallel: cmd.parallel,\n+            memory_usage: cmd.memory_usage,\n+            only: cmd.only,\n+            with_deps: cmd.with_deps,\n+            path: cmd.path,\n+            load_output_dirs: cmd.load_output_dirs,\n+            with_proc_macro: cmd.with_proc_macro,\n         }\n-        args::Command::Ssr { rules } => {\n-            cli::apply_ssr_rules(rules)?;\n+        .run(verbosity)?,\n+        flags::RustAnalyzerCmd::AnalysisBench(cmd) => {\n+            let what = cmd.what();\n+            BenchCmd {\n+                memory_usage: cmd.memory_usage,\n+                path: cmd.path,\n+                load_output_dirs: cmd.load_output_dirs,\n+                with_proc_macro: cmd.with_proc_macro,\n+                what,\n+            }\n+            .run(verbosity)?\n         }\n-        args::Command::StructuredSearch { patterns, debug_snippet } => {\n-            cli::search_for_patterns(patterns, debug_snippet)?;\n+\n+        flags::RustAnalyzerCmd::Diagnostics(cmd) => {\n+            cli::diagnostics(&cmd.path, cmd.load_output_dirs, cmd.with_proc_macro)?\n         }\n-        args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n-        args::Command::Help => {}\n+        flags::RustAnalyzerCmd::Ssr(cmd) => cli::apply_ssr_rules(cmd.rule)?,\n+        flags::RustAnalyzerCmd::Search(cmd) => cli::search_for_patterns(cmd.pattern, cmd.debug)?,\n     }\n     Ok(())\n }\n \n-fn setup_logging(log_file: Option<PathBuf>, no_buffering: bool) -> Result<()> {\n+fn setup_logging(log_file: Option<&Path>, no_buffering: bool) -> Result<()> {\n     env::set_var(\"RUST_BACKTRACE\", \"short\");\n \n     let log_file = match log_file {"}, {"sha": "3bd7e678d3f53e653be7473309475501f73975f1", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=8d2b0e6064330f9e7b04cbd6836e9f0b5c0ab4e6", "patch": "@@ -35,6 +35,7 @@ pub enum BenchWhat {\n     GotoDef(Position),\n }\n \n+#[derive(Debug, Clone)]\n pub struct Position {\n     pub path: AbsPathBuf,\n     pub line: u32,"}]}