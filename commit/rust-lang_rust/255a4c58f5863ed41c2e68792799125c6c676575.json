{"sha": "255a4c58f5863ed41c2e68792799125c6c676575", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NWE0YzU4ZjU4NjNlZDQxYzJlNjg3OTI3OTkxMjVjNmM2NzY1NzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T01:38:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T01:38:26Z"}, "message": "Auto merge of #72632 - jonas-schievink:dest-prop, r=oli-obk\n\nImplement a generic Destination Propagation optimization on MIR\n\nThis takes the work that was originally started by `@eddyb` in https://github.com/rust-lang/rust/pull/47954, and then explored by me in https://github.com/rust-lang/rust/pull/71003, and implements it in a general (ie. not limited to acyclic CFGs) and dataflow-driven way (so that no additional infrastructure in rustc is needed).\n\nThe pass is configured to run at `mir-opt-level=2` and higher only. To enable it by default, some followup work on it is still needed:\n* Performance needs to be evaluated. I did some light optimization work and tested against `tuple-stress`, which caused trouble in my last attempt, but didn't go much in depth here.\n  * We can also enable the pass only at `opt-level=2` and higher, if it is too slow to run in debug mode, but fine when optimizations run anyways.\n* Debuginfo needs to be fixed after locals are merged. I did not look into what is required for this.\n* Live ranges of locals (aka `StorageLive` and `StorageDead`) are currently deleted. We either need to decide that this is fine, or if not, merge the variable's live ranges (or remove these statements entirely \u2013 https://github.com/rust-lang/rust/issues/68622).\n\nSome benchmarks of the pass were done in https://github.com/rust-lang/rust/pull/72635.", "tree": {"sha": "07f3b9a5dccecda14b0b7f6e6579be0d615c5f73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07f3b9a5dccecda14b0b7f6e6579be0d615c5f73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/255a4c58f5863ed41c2e68792799125c6c676575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/255a4c58f5863ed41c2e68792799125c6c676575", "html_url": "https://github.com/rust-lang/rust/commit/255a4c58f5863ed41c2e68792799125c6c676575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/255a4c58f5863ed41c2e68792799125c6c676575/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f68e08933d8f519a9655934fedebbc509661b219", "url": "https://api.github.com/repos/rust-lang/rust/commits/f68e08933d8f519a9655934fedebbc509661b219", "html_url": "https://github.com/rust-lang/rust/commit/f68e08933d8f519a9655934fedebbc509661b219"}, {"sha": "2f9271b14c9ec0e5ed72ec91c2e24e850c580f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9271b14c9ec0e5ed72ec91c2e24e850c580f83", "html_url": "https://github.com/rust-lang/rust/commit/2f9271b14c9ec0e5ed72ec91c2e24e850c580f83"}], "stats": {"total": 2375, "additions": 1919, "deletions": 456}, "files": [{"sha": "1769feaf7a5140c2abf61f6592a0796224303116", "filename": "compiler/rustc_mir/src/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fmod.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'tcx> {\n \n /// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n-/// for a function, without an intervening `Storage Dead`.\n+/// for a function, without an intervening `StorageDead`.\n ///\n /// This dataflow is used to determine if an immutable local variable may\n /// be assigned to."}, {"sha": "251037792c917db60d79899ac67b7d88d1a4ae33", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -6,6 +6,7 @@ Rust MIR: a lowered representation of Rust.\n \n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "46cbced2d54bc74c04b1496d8d617225227163a2", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "added", "additions": 1057, "deletions": 0, "changes": 1057, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,1057 @@\n+//! Propagates assignment destinations backwards in the CFG to eliminate redundant assignments.\n+//!\n+//! # Motivation\n+//!\n+//! MIR building can insert a lot of redundant copies, and Rust code in general often tends to move\n+//! values around a lot. The result is a lot of assignments of the form `dest = {move} src;` in MIR.\n+//! MIR building for constants in particular tends to create additional locals that are only used\n+//! inside a single block to shuffle a value around unnecessarily.\n+//!\n+//! LLVM by itself is not good enough at eliminating these redundant copies (eg. see\n+//! https://github.com/rust-lang/rust/issues/32966), so this leaves some performance on the table\n+//! that we can regain by implementing an optimization for removing these assign statements in rustc\n+//! itself. When this optimization runs fast enough, it can also speed up the constant evaluation\n+//! and code generation phases of rustc due to the reduced number of statements and locals.\n+//!\n+//! # The Optimization\n+//!\n+//! Conceptually, this optimization is \"destination propagation\". It is similar to the Named Return\n+//! Value Optimization, or NRVO, known from the C++ world, except that it isn't limited to return\n+//! values or the return place `_0`. On a very high level, independent of the actual implementation\n+//! details, it does the following:\n+//!\n+//! 1) Identify `dest = src;` statements that can be soundly eliminated.\n+//! 2) Replace all mentions of `src` with `dest` (\"unifying\" them and propagating the destination\n+//!    backwards).\n+//! 3) Delete the `dest = src;` statement (by making it a `nop`).\n+//!\n+//! Step 1) is by far the hardest, so it is explained in more detail below.\n+//!\n+//! ## Soundness\n+//!\n+//! Given an `Assign` statement `dest = src;`, where `dest` is a `Place` and `src` is an `Rvalue`,\n+//! there are a few requirements that must hold for the optimization to be sound:\n+//!\n+//! * `dest` must not contain any *indirection* through a pointer. It must access part of the base\n+//!   local. Otherwise it might point to arbitrary memory that is hard to track.\n+//!\n+//!   It must also not contain any indexing projections, since those take an arbitrary `Local` as\n+//!   the index, and that local might only be initialized shortly before `dest` is used.\n+//!\n+//!   Subtle case: If `dest` is a, or projects through a union, then we have to make sure that there\n+//!   remains an assignment to it, since that sets the \"active field\" of the union. But if `src` is\n+//!   a ZST, it might not be initialized, so there might not be any use of it before the assignment,\n+//!   and performing the optimization would simply delete the assignment, leaving `dest`\n+//!   uninitialized.\n+//!\n+//! * `src` must be a bare `Local` without any indirections or field projections (FIXME: Is this a\n+//!   fundamental restriction or just current impl state?). It can be copied or moved by the\n+//!   assignment.\n+//!\n+//! * The `dest` and `src` locals must never be [*live*][liveness] at the same time. If they are, it\n+//!   means that they both hold a (potentially different) value that is needed by a future use of\n+//!   the locals. Unifying them would overwrite one of the values.\n+//!\n+//!   Note that computing liveness of locals that have had their address taken is more difficult:\n+//!   Short of doing full escape analysis on the address/pointer/reference, the pass would need to\n+//!   assume that any operation that can potentially involve opaque user code (such as function\n+//!   calls, destructors, and inline assembly) may access any local that had its address taken\n+//!   before that point.\n+//!\n+//! Here, the first two conditions are simple structural requirements on the `Assign` statements\n+//! that can be trivially checked. The liveness requirement however is more difficult and costly to\n+//! check.\n+//!\n+//! ## Previous Work\n+//!\n+//! A [previous attempt] at implementing an optimization like this turned out to be a significant\n+//! regression in compiler performance. Fixing the regressions introduced a lot of undesirable\n+//! complexity to the implementation.\n+//!\n+//! A [subsequent approach] tried to avoid the costly computation by limiting itself to acyclic\n+//! CFGs, but still turned out to be far too costly to run due to suboptimal performance within\n+//! individual basic blocks, requiring a walk across the entire block for every assignment found\n+//! within the block. For the `tuple-stress` benchmark, which has 458745 statements in a single\n+//! block, this proved to be far too costly.\n+//!\n+//! Since the first attempt at this, the compiler has improved dramatically, and new analysis\n+//! frameworks have been added that should make this approach viable without requiring a limited\n+//! approach that only works for some classes of CFGs:\n+//! - rustc now has a powerful dataflow analysis framework that can handle forwards and backwards\n+//!   analyses efficiently.\n+//! - Layout optimizations for generators have been added to improve code generation for\n+//!   async/await, which are very similar in spirit to what this optimization does. Both walk the\n+//!   MIR and record conflicting uses of locals in a `BitMatrix`.\n+//!\n+//! Also, rustc now has a simple NRVO pass (see `nrvo.rs`), which handles a subset of the cases that\n+//! this destination propagation pass handles, proving that similar optimizations can be performed\n+//! on MIR.\n+//!\n+//! ## Pre/Post Optimization\n+//!\n+//! It is recommended to run `SimplifyCfg` and then `SimplifyLocals` some time after this pass, as\n+//! it replaces the eliminated assign statements with `nop`s and leaves unused locals behind.\n+//!\n+//! [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n+//! [previous attempt]: https://github.com/rust-lang/rust/pull/47954\n+//! [subsequent approach]: https://github.com/rust-lang/rust/pull/71003\n+\n+use crate::dataflow::impls::{MaybeInitializedLocals, MaybeLiveLocals};\n+use crate::dataflow::Analysis;\n+use crate::{\n+    transform::{MirPass, MirSource},\n+    util::{dump_mir, PassWhere},\n+};\n+use itertools::Itertools;\n+use rustc_data_structures::unify::{InPlaceUnificationTable, UnifyKey};\n+use rustc_index::{\n+    bit_set::{BitMatrix, BitSet},\n+    vec::IndexVec,\n+};\n+use rustc_middle::mir::tcx::PlaceTy;\n+use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    traversal, Body, InlineAsmOperand, Local, LocalKind, Location, Operand, Place, PlaceElem,\n+    Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n+};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+// Empirical measurements have resulted in some observations:\n+// - Running on a body with a single block and 500 locals takes barely any time\n+// - Running on a body with ~400 blocks and ~300 relevant locals takes \"too long\"\n+// ...so we just limit both to somewhat reasonable-ish looking values.\n+const MAX_LOCALS: usize = 500;\n+const MAX_BLOCKS: usize = 250;\n+\n+pub struct DestinationPropagation;\n+\n+impl<'tcx> MirPass<'tcx> for DestinationPropagation {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // Only run at mir-opt-level=2 or higher for now (we don't fix up debuginfo and remove\n+        // storage statements at the moment).\n+        if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n+            return;\n+        }\n+\n+        let candidates = find_candidates(tcx, body);\n+        if candidates.is_empty() {\n+            debug!(\"{:?}: no dest prop candidates, done\", source.def_id());\n+            return;\n+        }\n+\n+        // Collect all locals we care about. We only compute conflicts for these to save time.\n+        let mut relevant_locals = BitSet::new_empty(body.local_decls.len());\n+        for CandidateAssignment { dest, src, loc: _ } in &candidates {\n+            relevant_locals.insert(dest.local);\n+            relevant_locals.insert(*src);\n+        }\n+\n+        // This pass unfortunately has `O(l\u00b2 * s)` performance, where `l` is the number of locals\n+        // and `s` is the number of statements and terminators in the function.\n+        // To prevent blowing up compile times too much, we bail out when there are too many locals.\n+        let relevant = relevant_locals.count();\n+        debug!(\n+            \"{:?}: {} locals ({} relevant), {} blocks\",\n+            source.def_id(),\n+            body.local_decls.len(),\n+            relevant,\n+            body.basic_blocks().len()\n+        );\n+        if relevant > MAX_LOCALS {\n+            warn!(\n+                \"too many candidate locals in {:?} ({}, max is {}), not optimizing\",\n+                source.def_id(),\n+                relevant,\n+                MAX_LOCALS\n+            );\n+            return;\n+        }\n+        if body.basic_blocks().len() > MAX_BLOCKS {\n+            warn!(\n+                \"too many blocks in {:?} ({}, max is {}), not optimizing\",\n+                source.def_id(),\n+                body.basic_blocks().len(),\n+                MAX_BLOCKS\n+            );\n+            return;\n+        }\n+\n+        let mut conflicts = Conflicts::build(tcx, body, source, &relevant_locals);\n+\n+        let mut replacements = Replacements::new(body.local_decls.len());\n+        for candidate @ CandidateAssignment { dest, src, loc } in candidates {\n+            // Merge locals that don't conflict.\n+            if !conflicts.can_unify(dest.local, src) {\n+                debug!(\"at assignment {:?}, conflict {:?} vs. {:?}\", loc, dest.local, src);\n+                continue;\n+            }\n+\n+            if replacements.for_src(candidate.src).is_some() {\n+                debug!(\"src {:?} already has replacement\", candidate.src);\n+                continue;\n+            }\n+\n+            if !tcx.consider_optimizing(|| {\n+                format!(\"DestinationPropagation {:?} {:?}\", source.def_id(), candidate)\n+            }) {\n+                break;\n+            }\n+\n+            replacements.push(candidate);\n+            conflicts.unify(candidate.src, candidate.dest.local);\n+        }\n+\n+        replacements.flatten(tcx);\n+\n+        debug!(\"replacements {:?}\", replacements.map);\n+\n+        Replacer { tcx, replacements, place_elem_cache: Vec::new() }.visit_body(body);\n+\n+        // FIXME fix debug info\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Copy, Clone)]\n+struct UnifyLocal(Local);\n+\n+impl From<Local> for UnifyLocal {\n+    fn from(l: Local) -> Self {\n+        Self(l)\n+    }\n+}\n+\n+impl UnifyKey for UnifyLocal {\n+    type Value = ();\n+    fn index(&self) -> u32 {\n+        self.0.as_u32()\n+    }\n+    fn from_index(u: u32) -> Self {\n+        Self(Local::from_u32(u))\n+    }\n+    fn tag() -> &'static str {\n+        \"UnifyLocal\"\n+    }\n+}\n+\n+struct Replacements<'tcx> {\n+    /// Maps locals to their replacement.\n+    map: IndexVec<Local, Option<Place<'tcx>>>,\n+\n+    /// Whose locals' live ranges to kill.\n+    kill: BitSet<Local>,\n+}\n+\n+impl Replacements<'tcx> {\n+    fn new(locals: usize) -> Self {\n+        Self { map: IndexVec::from_elem_n(None, locals), kill: BitSet::new_empty(locals) }\n+    }\n+\n+    fn push(&mut self, candidate: CandidateAssignment<'tcx>) {\n+        trace!(\"Replacements::push({:?})\", candidate);\n+        let entry = &mut self.map[candidate.src];\n+        assert!(entry.is_none());\n+\n+        *entry = Some(candidate.dest);\n+        self.kill.insert(candidate.src);\n+        self.kill.insert(candidate.dest.local);\n+    }\n+\n+    /// Applies the stored replacements to all replacements, until no replacements would result in\n+    /// locals that need further replacements when applied.\n+    fn flatten(&mut self, tcx: TyCtxt<'tcx>) {\n+        // Note: This assumes that there are no cycles in the replacements, which is enforced via\n+        // `self.unified_locals`. Otherwise this can cause an infinite loop.\n+\n+        for local in self.map.indices() {\n+            if let Some(replacement) = self.map[local] {\n+                // Substitute the base local of `replacement` until fixpoint.\n+                let mut base = replacement.local;\n+                let mut reversed_projection_slices = Vec::with_capacity(1);\n+                while let Some(replacement_for_replacement) = self.map[base] {\n+                    base = replacement_for_replacement.local;\n+                    reversed_projection_slices.push(replacement_for_replacement.projection);\n+                }\n+\n+                let projection: Vec<_> = reversed_projection_slices\n+                    .iter()\n+                    .rev()\n+                    .flat_map(|projs| projs.iter())\n+                    .chain(replacement.projection.iter())\n+                    .collect();\n+                let projection = tcx.intern_place_elems(&projection);\n+\n+                // Replace with the final `Place`.\n+                self.map[local] = Some(Place { local: base, projection });\n+            }\n+        }\n+    }\n+\n+    fn for_src(&self, src: Local) -> Option<Place<'tcx>> {\n+        self.map[src]\n+    }\n+}\n+\n+struct Replacer<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    replacements: Replacements<'tcx>,\n+    place_elem_cache: Vec<PlaceElem<'tcx>>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn visit_local(&mut self, local: &mut Local, context: PlaceContext, location: Location) {\n+        if context.is_use() && self.replacements.for_src(*local).is_some() {\n+            bug!(\n+                \"use of local {:?} should have been replaced by visit_place; context={:?}, loc={:?}\",\n+                local,\n+                context,\n+                location,\n+            );\n+        }\n+    }\n+\n+    fn process_projection_elem(\n+        &mut self,\n+        elem: PlaceElem<'tcx>,\n+        _: Location,\n+    ) -> Option<PlaceElem<'tcx>> {\n+        match elem {\n+            PlaceElem::Index(local) => {\n+                if let Some(replacement) = self.replacements.for_src(local) {\n+                    bug!(\n+                        \"cannot replace {:?} with {:?} in index projection {:?}\",\n+                        local,\n+                        replacement,\n+                        elem,\n+                    );\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n+        if let Some(replacement) = self.replacements.for_src(place.local) {\n+            // Rebase `place`s projections onto `replacement`'s.\n+            self.place_elem_cache.clear();\n+            self.place_elem_cache.extend(replacement.projection.iter().chain(place.projection));\n+            let projection = self.tcx.intern_place_elems(&self.place_elem_cache);\n+            let new_place = Place { local: replacement.local, projection };\n+\n+            debug!(\"Replacer: {:?} -> {:?}\", place, new_place);\n+            *place = new_place;\n+        }\n+\n+        self.super_place(place, context, location);\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        self.super_statement(statement, location);\n+\n+        match &statement.kind {\n+            // FIXME: Don't delete storage statements, merge the live ranges instead\n+            StatementKind::StorageDead(local) | StatementKind::StorageLive(local)\n+                if self.replacements.kill.contains(*local) =>\n+            {\n+                statement.make_nop()\n+            }\n+\n+            StatementKind::Assign(box (dest, rvalue)) => {\n+                match rvalue {\n+                    Rvalue::Use(Operand::Copy(place) | Operand::Move(place)) => {\n+                        // These might've been turned into self-assignments by the replacement\n+                        // (this includes the original statement we wanted to eliminate).\n+                        if dest == place {\n+                            debug!(\"{:?} turned into self-assignment, deleting\", location);\n+                            statement.make_nop();\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n+struct Conflicts<'a> {\n+    relevant_locals: &'a BitSet<Local>,\n+\n+    /// The conflict matrix. It is always symmetric and the adjacency matrix of the corresponding\n+    /// conflict graph.\n+    matrix: BitMatrix<Local, Local>,\n+\n+    /// Preallocated `BitSet` used by `unify`.\n+    unify_cache: BitSet<Local>,\n+\n+    /// Tracks locals that have been merged together to prevent cycles and propagate conflicts.\n+    unified_locals: InPlaceUnificationTable<UnifyLocal>,\n+}\n+\n+impl Conflicts<'a> {\n+    fn build<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'_ Body<'tcx>,\n+        source: MirSource<'tcx>,\n+        relevant_locals: &'a BitSet<Local>,\n+    ) -> Self {\n+        // We don't have to look out for locals that have their address taken, since\n+        // `find_candidates` already takes care of that.\n+\n+        let conflicts = BitMatrix::from_row_n(\n+            &BitSet::new_empty(body.local_decls.len()),\n+            body.local_decls.len(),\n+        );\n+\n+        let def_id = source.def_id();\n+        let mut init = MaybeInitializedLocals\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+        let mut live = MaybeLiveLocals\n+            .into_engine(tcx, body, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+\n+        let mut reachable = None;\n+        dump_mir(\n+            tcx,\n+            None,\n+            \"DestinationPropagation-dataflow\",\n+            &\"\",\n+            source,\n+            body,\n+            |pass_where, w| {\n+                let reachable =\n+                    reachable.get_or_insert_with(|| traversal::reachable_as_bitset(body));\n+\n+                match pass_where {\n+                    PassWhere::BeforeLocation(loc) if reachable.contains(loc.block) => {\n+                        init.seek_before_primary_effect(loc);\n+                        live.seek_after_primary_effect(loc);\n+\n+                        writeln!(w, \"        // init: {:?}\", init.get())?;\n+                        writeln!(w, \"        // live: {:?}\", live.get())?;\n+                    }\n+                    PassWhere::AfterTerminator(bb) if reachable.contains(bb) => {\n+                        let loc = body.terminator_loc(bb);\n+                        init.seek_after_primary_effect(loc);\n+                        live.seek_before_primary_effect(loc);\n+\n+                        writeln!(w, \"        // init: {:?}\", init.get())?;\n+                        writeln!(w, \"        // live: {:?}\", live.get())?;\n+                    }\n+\n+                    PassWhere::BeforeBlock(bb) if reachable.contains(bb) => {\n+                        init.seek_to_block_start(bb);\n+                        live.seek_to_block_start(bb);\n+\n+                        writeln!(w, \"    // init: {:?}\", init.get())?;\n+                        writeln!(w, \"    // live: {:?}\", live.get())?;\n+                    }\n+\n+                    PassWhere::BeforeCFG | PassWhere::AfterCFG | PassWhere::AfterLocation(_) => {}\n+\n+                    PassWhere::BeforeLocation(_) | PassWhere::AfterTerminator(_) => {\n+                        writeln!(w, \"        // init: <unreachable>\")?;\n+                        writeln!(w, \"        // live: <unreachable>\")?;\n+                    }\n+\n+                    PassWhere::BeforeBlock(_) => {\n+                        writeln!(w, \"    // init: <unreachable>\")?;\n+                        writeln!(w, \"    // live: <unreachable>\")?;\n+                    }\n+                }\n+\n+                Ok(())\n+            },\n+        );\n+\n+        let mut this = Self {\n+            relevant_locals,\n+            matrix: conflicts,\n+            unify_cache: BitSet::new_empty(body.local_decls.len()),\n+            unified_locals: {\n+                let mut table = InPlaceUnificationTable::new();\n+                // Pre-fill table with all locals (this creates N nodes / \"connected\" components,\n+                // \"graph\"-ically speaking).\n+                for local in 0..body.local_decls.len() {\n+                    assert_eq!(table.new_key(()), UnifyLocal(Local::from_usize(local)));\n+                }\n+                table\n+            },\n+        };\n+\n+        let mut live_and_init_locals = Vec::new();\n+\n+        // Visit only reachable basic blocks. The exact order is not important.\n+        for (block, data) in traversal::preorder(body) {\n+            // We need to observe the dataflow state *before* all possible locations (statement or\n+            // terminator) in each basic block, and then observe the state *after* the terminator\n+            // effect is applied. As long as neither `init` nor `borrowed` has a \"before\" effect,\n+            // we will observe all possible dataflow states.\n+\n+            // Since liveness is a backwards analysis, we need to walk the results backwards. To do\n+            // that, we first collect in the `MaybeInitializedLocals` results in a forwards\n+            // traversal.\n+\n+            live_and_init_locals.resize_with(data.statements.len() + 1, || {\n+                BitSet::new_empty(body.local_decls.len())\n+            });\n+\n+            // First, go forwards for `MaybeInitializedLocals` and apply intra-statement/terminator\n+            // conflicts.\n+            for (i, statement) in data.statements.iter().enumerate() {\n+                this.record_statement_conflicts(statement);\n+\n+                let loc = Location { block, statement_index: i };\n+                init.seek_before_primary_effect(loc);\n+\n+                live_and_init_locals[i].clone_from(init.get());\n+            }\n+\n+            this.record_terminator_conflicts(data.terminator());\n+            let term_loc = Location { block, statement_index: data.statements.len() };\n+            init.seek_before_primary_effect(term_loc);\n+            live_and_init_locals[term_loc.statement_index].clone_from(init.get());\n+\n+            // Now, go backwards and union with the liveness results.\n+            for statement_index in (0..=data.statements.len()).rev() {\n+                let loc = Location { block, statement_index };\n+                live.seek_after_primary_effect(loc);\n+\n+                live_and_init_locals[statement_index].intersect(live.get());\n+\n+                trace!(\"record conflicts at {:?}\", loc);\n+\n+                this.record_dataflow_conflicts(&mut live_and_init_locals[statement_index]);\n+            }\n+\n+            init.seek_to_block_end(block);\n+            live.seek_to_block_end(block);\n+            let mut conflicts = init.get().clone();\n+            conflicts.intersect(live.get());\n+            trace!(\"record conflicts at end of {:?}\", block);\n+\n+            this.record_dataflow_conflicts(&mut conflicts);\n+        }\n+\n+        this\n+    }\n+\n+    fn record_dataflow_conflicts(&mut self, new_conflicts: &mut BitSet<Local>) {\n+        // Remove all locals that are not candidates.\n+        new_conflicts.intersect(self.relevant_locals);\n+\n+        for local in new_conflicts.iter() {\n+            self.matrix.union_row_with(&new_conflicts, local);\n+        }\n+    }\n+\n+    fn record_local_conflict(&mut self, a: Local, b: Local, why: &str) {\n+        trace!(\"conflict {:?} <-> {:?} due to {}\", a, b, why);\n+        self.matrix.insert(a, b);\n+        self.matrix.insert(b, a);\n+    }\n+\n+    /// Records locals that must not overlap during the evaluation of `stmt`. These locals conflict\n+    /// and must not be merged.\n+    fn record_statement_conflicts(&mut self, stmt: &Statement<'_>) {\n+        match &stmt.kind {\n+            // While the left and right sides of an assignment must not overlap, we do not mark\n+            // conflicts here as that would make this optimization useless. When we optimize, we\n+            // eliminate the resulting self-assignments automatically.\n+            StatementKind::Assign(_) => {}\n+\n+            StatementKind::LlvmInlineAsm(asm) => {\n+                // Inputs and outputs must not overlap.\n+                for (_, input) in &*asm.inputs {\n+                    if let Some(in_place) = input.place() {\n+                        if !in_place.is_indirect() {\n+                            for out_place in &*asm.outputs {\n+                                if !out_place.is_indirect() && !in_place.is_indirect() {\n+                                    self.record_local_conflict(\n+                                        in_place.local,\n+                                        out_place.local,\n+                                        \"aliasing llvm_asm! operands\",\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            StatementKind::SetDiscriminant { .. }\n+            | StatementKind::StorageLive(..)\n+            | StatementKind::StorageDead(..)\n+            | StatementKind::Retag(..)\n+            | StatementKind::FakeRead(..)\n+            | StatementKind::AscribeUserType(..)\n+            | StatementKind::Coverage(..)\n+            | StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn record_terminator_conflicts(&mut self, term: &Terminator<'_>) {\n+        match &term.kind {\n+            TerminatorKind::DropAndReplace {\n+                place: dropped_place,\n+                value,\n+                target: _,\n+                unwind: _,\n+            } => {\n+                if let Some(place) = value.place() {\n+                    if !place.is_indirect() && !dropped_place.is_indirect() {\n+                        self.record_local_conflict(\n+                            place.local,\n+                            dropped_place.local,\n+                            \"DropAndReplace operand overlap\",\n+                        );\n+                    }\n+                }\n+            }\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n+                if let Some(place) = value.place() {\n+                    if !place.is_indirect() && !resume_arg.is_indirect() {\n+                        self.record_local_conflict(\n+                            place.local,\n+                            resume_arg.local,\n+                            \"Yield operand overlap\",\n+                        );\n+                    }\n+                }\n+            }\n+            TerminatorKind::Call {\n+                func,\n+                args,\n+                destination: Some((dest_place, _)),\n+                cleanup: _,\n+                from_hir_call: _,\n+                fn_span: _,\n+            } => {\n+                // No arguments may overlap with the destination.\n+                for arg in args.iter().chain(Some(func)) {\n+                    if let Some(place) = arg.place() {\n+                        if !place.is_indirect() && !dest_place.is_indirect() {\n+                            self.record_local_conflict(\n+                                dest_place.local,\n+                                place.local,\n+                                \"call dest/arg overlap\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+            TerminatorKind::InlineAsm {\n+                template: _,\n+                operands,\n+                options: _,\n+                line_spans: _,\n+                destination: _,\n+            } => {\n+                // The intended semantics here aren't documented, we just assume that nothing that\n+                // could be written to by the assembly may overlap with any other operands.\n+                for op in operands {\n+                    match op {\n+                        InlineAsmOperand::Out { reg: _, late: _, place: Some(dest_place) }\n+                        | InlineAsmOperand::InOut {\n+                            reg: _,\n+                            late: _,\n+                            in_value: _,\n+                            out_place: Some(dest_place),\n+                        } => {\n+                            // For output place `place`, add all places accessed by the inline asm.\n+                            for op in operands {\n+                                match op {\n+                                    InlineAsmOperand::In { reg: _, value } => {\n+                                        if let Some(p) = value.place() {\n+                                            if !p.is_indirect() && !dest_place.is_indirect() {\n+                                                self.record_local_conflict(\n+                                                    p.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n+                                            }\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::Out {\n+                                        reg: _,\n+                                        late: _,\n+                                        place: Some(place),\n+                                    } => {\n+                                        if !place.is_indirect() && !dest_place.is_indirect() {\n+                                            self.record_local_conflict(\n+                                                place.local,\n+                                                dest_place.local,\n+                                                \"asm! operand overlap\",\n+                                            );\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::InOut {\n+                                        reg: _,\n+                                        late: _,\n+                                        in_value,\n+                                        out_place,\n+                                    } => {\n+                                        if let Some(place) = in_value.place() {\n+                                            if !place.is_indirect() && !dest_place.is_indirect() {\n+                                                self.record_local_conflict(\n+                                                    place.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n+                                            }\n+                                        }\n+\n+                                        if let Some(place) = out_place {\n+                                            if !place.is_indirect() && !dest_place.is_indirect() {\n+                                                self.record_local_conflict(\n+                                                    place.local,\n+                                                    dest_place.local,\n+                                                    \"asm! operand overlap\",\n+                                                );\n+                                            }\n+                                        }\n+                                    }\n+                                    InlineAsmOperand::Out { reg: _, late: _, place: None }\n+                                    | InlineAsmOperand::Const { value: _ }\n+                                    | InlineAsmOperand::SymFn { value: _ }\n+                                    | InlineAsmOperand::SymStatic { def_id: _ } => {}\n+                                }\n+                            }\n+                        }\n+                        InlineAsmOperand::Const { value } => {\n+                            assert!(value.place().is_none());\n+                        }\n+                        InlineAsmOperand::InOut {\n+                            reg: _,\n+                            late: _,\n+                            in_value: _,\n+                            out_place: None,\n+                        }\n+                        | InlineAsmOperand::In { reg: _, value: _ }\n+                        | InlineAsmOperand::Out { reg: _, late: _, place: None }\n+                        | InlineAsmOperand::SymFn { value: _ }\n+                        | InlineAsmOperand::SymStatic { def_id: _ } => {}\n+                    }\n+                }\n+            }\n+\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::Call { destination: None, .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Drop { .. }\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. } => {}\n+        }\n+    }\n+\n+    /// Checks whether `a` and `b` may be merged. Returns `false` if there's a conflict.\n+    fn can_unify(&mut self, a: Local, b: Local) -> bool {\n+        // After some locals have been unified, their conflicts are only tracked in the root key,\n+        // so look that up.\n+        let a = self.unified_locals.find(a).0;\n+        let b = self.unified_locals.find(b).0;\n+\n+        if a == b {\n+            // Already merged (part of the same connected component).\n+            return false;\n+        }\n+\n+        if self.matrix.contains(a, b) {\n+            // Conflict (derived via dataflow, intra-statement conflicts, or inherited from another\n+            // local during unification).\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n+    /// Merges the conflicts of `a` and `b`, so that each one inherits all conflicts of the other.\n+    ///\n+    /// `can_unify` must have returned `true` for the same locals, or this may panic or lead to\n+    /// miscompiles.\n+    ///\n+    /// This is called when the pass makes the decision to unify `a` and `b` (or parts of `a` and\n+    /// `b`) and is needed to ensure that future unification decisions take potentially newly\n+    /// introduced conflicts into account.\n+    ///\n+    /// For an example, assume we have locals `_0`, `_1`, `_2`, and `_3`. There are these conflicts:\n+    ///\n+    /// * `_0` <-> `_1`\n+    /// * `_1` <-> `_2`\n+    /// * `_3` <-> `_0`\n+    ///\n+    /// We then decide to merge `_2` with `_3` since they don't conflict. Then we decide to merge\n+    /// `_2` with `_0`, which also doesn't have a conflict in the above list. However `_2` is now\n+    /// `_3`, which does conflict with `_0`.\n+    fn unify(&mut self, a: Local, b: Local) {\n+        trace!(\"unify({:?}, {:?})\", a, b);\n+\n+        // Get the root local of the connected components. The root local stores the conflicts of\n+        // all locals in the connected component (and *is stored* as the conflicting local of other\n+        // locals).\n+        let a = self.unified_locals.find(a).0;\n+        let b = self.unified_locals.find(b).0;\n+        assert_ne!(a, b);\n+\n+        trace!(\"roots: a={:?}, b={:?}\", a, b);\n+        trace!(\"{:?} conflicts: {:?}\", a, self.matrix.iter(a).format(\", \"));\n+        trace!(\"{:?} conflicts: {:?}\", b, self.matrix.iter(b).format(\", \"));\n+\n+        self.unified_locals.union(a, b);\n+\n+        let root = self.unified_locals.find(a).0;\n+        assert!(root == a || root == b);\n+\n+        // Make all locals that conflict with `a` also conflict with `b`, and vice versa.\n+        self.unify_cache.clear();\n+        for conflicts_with_a in self.matrix.iter(a) {\n+            self.unify_cache.insert(conflicts_with_a);\n+        }\n+        for conflicts_with_b in self.matrix.iter(b) {\n+            self.unify_cache.insert(conflicts_with_b);\n+        }\n+        for conflicts_with_a_or_b in self.unify_cache.iter() {\n+            // Set both `a` and `b` for this local's row.\n+            self.matrix.insert(conflicts_with_a_or_b, a);\n+            self.matrix.insert(conflicts_with_a_or_b, b);\n+        }\n+\n+        // Write the locals `a` conflicts with to `b`'s row.\n+        self.matrix.union_rows(a, b);\n+        // Write the locals `b` conflicts with to `a`'s row.\n+        self.matrix.union_rows(b, a);\n+    }\n+}\n+\n+/// A `dest = {move} src;` statement at `loc`.\n+///\n+/// We want to consider merging `dest` and `src` due to this assignment.\n+#[derive(Debug, Copy, Clone)]\n+struct CandidateAssignment<'tcx> {\n+    /// Does not contain indirection or indexing (so the only local it contains is the place base).\n+    dest: Place<'tcx>,\n+    src: Local,\n+    loc: Location,\n+}\n+\n+/// Scans the MIR for assignments between locals that we might want to consider merging.\n+///\n+/// This will filter out assignments that do not match the right form (as described in the top-level\n+/// comment) and also throw out assignments that involve a local that has its address taken or is\n+/// otherwise ineligible (eg. locals used as array indices are ignored because we cannot propagate\n+/// arbitrary places into array indices).\n+fn find_candidates<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+) -> Vec<CandidateAssignment<'tcx>> {\n+    let mut visitor = FindAssignments {\n+        tcx,\n+        body,\n+        candidates: Vec::new(),\n+        ever_borrowed_locals: ever_borrowed_locals(body),\n+        locals_used_as_array_index: locals_used_as_array_index(body),\n+    };\n+    visitor.visit_body(body);\n+    visitor.candidates\n+}\n+\n+struct FindAssignments<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+    candidates: Vec<CandidateAssignment<'tcx>>,\n+    ever_borrowed_locals: BitSet<Local>,\n+    locals_used_as_array_index: BitSet<Local>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        if let StatementKind::Assign(box (\n+            dest,\n+            Rvalue::Use(Operand::Copy(src) | Operand::Move(src)),\n+        )) = &statement.kind\n+        {\n+            // `dest` must not have pointer indirection.\n+            if dest.is_indirect() {\n+                return;\n+            }\n+\n+            // `src` must be a plain local.\n+            if !src.projection.is_empty() {\n+                return;\n+            }\n+\n+            // Since we want to replace `src` with `dest`, `src` must not be required.\n+            if is_local_required(src.local, self.body) {\n+                return;\n+            }\n+\n+            // Can't optimize if both locals ever have their address taken (can introduce\n+            // aliasing).\n+            // FIXME: This can be smarter and take `StorageDead` into account (which\n+            // invalidates borrows).\n+            if self.ever_borrowed_locals.contains(dest.local)\n+                && self.ever_borrowed_locals.contains(src.local)\n+            {\n+                return;\n+            }\n+\n+            assert_ne!(dest.local, src.local, \"self-assignments are UB\");\n+\n+            // We can't replace locals occurring in `PlaceElem::Index` for now.\n+            if self.locals_used_as_array_index.contains(src.local) {\n+                return;\n+            }\n+\n+            // Handle the \"subtle case\" described above by rejecting any `dest` that is or\n+            // projects through a union.\n+            let is_union = |ty: Ty<'_>| {\n+                if let ty::Adt(def, _) = ty.kind() {\n+                    if def.is_union() {\n+                        return true;\n+                    }\n+                }\n+\n+                false\n+            };\n+            let mut place_ty = PlaceTy::from_ty(self.body.local_decls[dest.local].ty);\n+            if is_union(place_ty.ty) {\n+                return;\n+            }\n+            for elem in dest.projection {\n+                if let PlaceElem::Index(_) = elem {\n+                    // `dest` contains an indexing projection.\n+                    return;\n+                }\n+\n+                place_ty = place_ty.projection_ty(self.tcx, elem);\n+                if is_union(place_ty.ty) {\n+                    return;\n+                }\n+            }\n+\n+            self.candidates.push(CandidateAssignment {\n+                dest: *dest,\n+                src: src.local,\n+                loc: location,\n+            });\n+        }\n+    }\n+}\n+\n+/// Some locals are part of the function's interface and can not be removed.\n+///\n+/// Note that these locals *can* still be merged with non-required locals by removing that other\n+/// local.\n+fn is_local_required(local: Local, body: &Body<'_>) -> bool {\n+    match body.local_kind(local) {\n+        LocalKind::Arg | LocalKind::ReturnPointer => true,\n+        LocalKind::Var | LocalKind::Temp => false,\n+    }\n+}\n+\n+/// Walks MIR to find all locals that have their address taken anywhere.\n+fn ever_borrowed_locals(body: &Body<'_>) -> BitSet<Local> {\n+    let mut visitor = BorrowCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n+    visitor.visit_body(body);\n+    visitor.locals\n+}\n+\n+struct BorrowCollector {\n+    locals: BitSet<Local>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BorrowCollector {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match rvalue {\n+            Rvalue::AddressOf(_, borrowed_place) | Rvalue::Ref(_, _, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n+                    self.locals.insert(borrowed_place.local);\n+                }\n+            }\n+\n+            Rvalue::Cast(..)\n+            | Rvalue::Use(..)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Aggregate(..)\n+            | Rvalue::ThreadLocalRef(..) => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n+\n+        match terminator.kind {\n+            TerminatorKind::Drop { place: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+                self.locals.insert(dropped_place.local);\n+            }\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n+        }\n+    }\n+}\n+\n+/// `PlaceElem::Index` only stores a `Local`, so we can't replace that with a full `Place`.\n+///\n+/// Collect locals used as indices so we don't generate candidates that are impossible to apply\n+/// later.\n+fn locals_used_as_array_index(body: &Body<'_>) -> BitSet<Local> {\n+    let mut visitor = IndexCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n+    visitor.visit_body(body);\n+    visitor.locals\n+}\n+\n+struct IndexCollector {\n+    locals: BitSet<Local>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for IndexCollector {\n+    fn visit_projection_elem(\n+        &mut self,\n+        local: Local,\n+        proj_base: &[PlaceElem<'tcx>],\n+        elem: PlaceElem<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        if let PlaceElem::Index(i) = elem {\n+            self.locals.insert(i);\n+        }\n+        self.super_projection_elem(local, proj_base, elem, context, location);\n+    }\n+}"}, {"sha": "fc9854ba499f839ab51a7b509e956977eb80e262", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,6 +24,7 @@ pub mod cleanup_post_borrowck;\n pub mod const_prop;\n pub mod copy_prop;\n pub mod deaggregator;\n+pub mod dest_prop;\n pub mod dump_mir;\n pub mod elaborate_drops;\n pub mod generator;\n@@ -467,6 +468,7 @@ fn run_optimization_passes<'tcx>(\n         &simplify_comparison_integral::SimplifyComparisonIntegral,\n         &simplify_try::SimplifyArmIdentity,\n         &simplify_try::SimplifyBranchSame,\n+        &dest_prop::DestinationPropagation,\n         &copy_prop::CopyPropagation,\n         &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,"}, {"sha": "1ffb5a87c4762f2b00a77e483e7e51dc139950bd", "filename": "compiler/rustc_mir/src/transform/nrvo.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -36,6 +36,12 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n             return;\n         }\n \n+        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n+            // The `DestinationPropagation` pass runs at level 2, so this pass is redundant (and\n+            // fails some asserts).\n+            return;\n+        }\n+\n         let returned_local = match local_eligible_for_nrvo(body) {\n             Some(l) => l,\n             None => {"}, {"sha": "8b09eade067046e68feae5b216914b5c60b5576b", "filename": "src/test/mir-opt/const_allocation.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,42 +24,42 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc17\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc14\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc17 (size: 48, align: 4) {\n+alloc14 (size: 48, align: 4) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc4\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc7\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc11\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n alloc4 (size: 0, align: 4) {}\n \n-alloc8 (size: 16, align: 4) {\n-    \u257e\u2500alloc7\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc7 (size: 16, align: 4) {\n+    \u257e\u2500alloc6\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc8\u2500\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n-alloc7 (size: 3, align: 1) {\n+alloc6 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc8 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500alloc12\u2500\u257c 03 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 \u257e\u2500alloc15\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc11 (size: 24, align: 4) {\n+    0x00 \u2502 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u257e\u2500alloc12\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257e\u2500alloc13\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc12 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc12 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc13 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "2853a0ac18b0dcdbcb55b2d0b371da1f84510f4d", "filename": "src/test/mir-opt/const_allocation.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,46 +24,46 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc17 (size: 72, align: 8) {\n+alloc14 (size: 72, align: 8) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n alloc4 (size: 0, align: 8) {}\n \n-alloc8 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc7 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc7 (size: 3, align: 1) {\n+alloc6 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc8 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc11 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc12 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc12 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc13 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "710ffeeda075a8a966f7568aea01215c0be8a062", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,41 +24,41 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc23\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc20\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc23 (size: 48, align: 4) {\n+alloc20 (size: 48, align: 4) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc13\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc21\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc12\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc19\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n alloc8 (size: 0, align: 4) {}\n \n-alloc13 (size: 8, align: 4) {\n-    \u257e\u2500alloc11\u2500\u257c \u257e\u2500alloc12\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc12 (size: 8, align: 4) {\n+    \u257e\u2500alloc10\u2500\u257c \u257e\u2500alloc11\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc11 (size: 1, align: 1) {\n+alloc10 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc11 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc21 (size: 12, align: 4) {\n-    \u257e\u2500a17+0x3\u2500\u257c \u257e\u2500alloc18\u2500\u257c \u257e\u2500a20+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc19 (size: 12, align: 4) {\n+    \u257e\u2500a15+0x3\u2500\u257c \u257e\u2500alloc16\u2500\u257c \u257e\u2500a18+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc15 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc16 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc20 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "97a7f76f6bb5dba64d29f4af51d100c7522a02ca", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,44 +24,44 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc23 (size: 72, align: 8) {\n+alloc20 (size: 72, align: 8) {\n     0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n alloc8 (size: 0, align: 8) {}\n \n-alloc13 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc12 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc11 (size: 1, align: 1) {\n+alloc10 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc11 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc21 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc20+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc19 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc15+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc18+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc15 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc16 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc20 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "19d6c51bc75f316f5e185b8194eacdeeca77f0a8", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,10 +24,10 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500alloc9\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc3\u2500\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n-alloc9 (size: 168, align: 1) {\n+alloc3 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n     0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc4\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "94388b08c0ec0bd9c51b7d8069ebc13727ef6f41", "filename": "src/test/mir-opt/const_allocation3.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -24,10 +24,10 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc3\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc9 (size: 180, align: 1) {\n+alloc3 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n     0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc4\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............"}, {"sha": "1f3e559c1b7f47d2f4381324a3d0b5f3d7215c4a", "filename": "src/test/mir-opt/copy_propagation.test.CopyPropagation.diff", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation.test.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation.test.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation.test.CopyPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -6,19 +6,14 @@\n       let mut _0: u32;                     // return place in scope 0 at $DIR/copy_propagation.rs:3:20: 3:23\n       let _2: u32;                         // in scope 0 at $DIR/copy_propagation.rs:4:9: 4:10\n       scope 1 {\n--         debug y => _2;                   // in scope 1 at $DIR/copy_propagation.rs:4:9: 4:10\n-+         debug y => _1;                   // in scope 1 at $DIR/copy_propagation.rs:4:9: 4:10\n+          debug y => _0;                   // in scope 1 at $DIR/copy_propagation.rs:4:9: 4:10\n       }\n   \n       bb0: {\n--         StorageLive(_2);                 // scope 0 at $DIR/copy_propagation.rs:4:9: 4:10\n--         _2 = _1;                         // scope 0 at $DIR/copy_propagation.rs:4:13: 4:14\n--         _0 = _2;                         // scope 1 at $DIR/copy_propagation.rs:5:5: 5:6\n--         StorageDead(_2);                 // scope 0 at $DIR/copy_propagation.rs:6:1: 6:2\n-+         nop;                             // scope 0 at $DIR/copy_propagation.rs:4:9: 4:10\n-+         nop;                             // scope 0 at $DIR/copy_propagation.rs:4:13: 4:14\n-+         _0 = _1;                         // scope 1 at $DIR/copy_propagation.rs:5:5: 5:6\n-+         nop;                             // scope 0 at $DIR/copy_propagation.rs:6:1: 6:2\n+          nop;                             // scope 0 at $DIR/copy_propagation.rs:4:9: 4:10\n+          _0 = _1;                         // scope 0 at $DIR/copy_propagation.rs:4:13: 4:14\n+          nop;                             // scope 1 at $DIR/copy_propagation.rs:5:5: 5:6\n+          nop;                             // scope 0 at $DIR/copy_propagation.rs:6:1: 6:2\n           return;                          // scope 0 at $DIR/copy_propagation.rs:6:2: 6:2\n       }\n   }"}, {"sha": "8aab2299d26510c3e5ec78b239700ca36a064cda", "filename": "src/test/mir-opt/copy_propagation_arg.arg_src.CopyPropagation.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.arg_src.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.arg_src.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.arg_src.CopyPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -6,15 +6,15 @@\n       let mut _0: i32;                     // return place in scope 0 at $DIR/copy_propagation_arg.rs:27:27: 27:30\n       let _2: i32;                         // in scope 0 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n       scope 1 {\n-          debug y => _2;                   // in scope 1 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n+          debug y => _0;                   // in scope 1 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n-          _2 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:28:13: 28:14\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:28:9: 28:10\n+          _0 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:28:13: 28:14\n           _1 = const 123_i32;              // scope 1 at $DIR/copy_propagation_arg.rs:29:5: 29:12\n-          _0 = _2;                         // scope 1 at $DIR/copy_propagation_arg.rs:30:5: 30:6\n-          StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:31:1: 31:2\n+          nop;                             // scope 1 at $DIR/copy_propagation_arg.rs:30:5: 30:6\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:31:1: 31:2\n           return;                          // scope 0 at $DIR/copy_propagation_arg.rs:31:2: 31:2\n       }\n   }"}, {"sha": "1ea51fec7106992eb821598dba86d45913196c4f", "filename": "src/test/mir-opt/copy_propagation_arg.baz.CopyPropagation.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.baz.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.baz.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.baz.CopyPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -7,10 +7,10 @@\n       let mut _2: i32;                     // in scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n-          _2 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n-          _1 = move _2;                    // scope 0 at $DIR/copy_propagation_arg.rs:23:5: 23:10\n-          StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:23:5: 23:10\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:23:9: 23:10\n           _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:21:20: 24:2\n           return;                          // scope 0 at $DIR/copy_propagation_arg.rs:24:2: 24:2\n       }"}, {"sha": "48ab37a239c62f105204133536f54659ef4ae088", "filename": "src/test/mir-opt/copy_propagation_arg.foo.CopyPropagation.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.foo.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.foo.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg.foo.CopyPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -8,19 +8,19 @@\n       let mut _3: u8;                      // in scope 0 at $DIR/copy_propagation_arg.rs:11:15: 11:16\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:11:9: 11:17\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:11:9: 11:17\n           StorageLive(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:11:15: 11:16\n           _3 = _1;                         // scope 0 at $DIR/copy_propagation_arg.rs:11:15: 11:16\n-          _2 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:11:9: 11:17\n+          _1 = dummy(move _3) -> bb1;      // scope 0 at $DIR/copy_propagation_arg.rs:11:9: 11:17\n                                            // mir::Constant\n                                            // + span: $DIR/copy_propagation_arg.rs:11:9: 11:14\n                                            // + literal: Const { ty: fn(u8) -> u8 {dummy}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb1: {\n           StorageDead(_3);                 // scope 0 at $DIR/copy_propagation_arg.rs:11:16: 11:17\n-          _1 = move _2;                    // scope 0 at $DIR/copy_propagation_arg.rs:11:5: 11:17\n-          StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:11:16: 11:17\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:11:5: 11:17\n+          nop;                             // scope 0 at $DIR/copy_propagation_arg.rs:11:16: 11:17\n           _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:9:19: 12:2\n           return;                          // scope 0 at $DIR/copy_propagation_arg.rs:12:2: 12:2\n       }"}, {"sha": "9c213eaed3c04c44d70a8241da0b353dfdd2e638", "filename": "src/test/mir-opt/dest-prop/branch.main.DestinationPropagation.diff", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.main.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,73 @@\n+- // MIR for `main` before DestinationPropagation\n++ // MIR for `main` after DestinationPropagation\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/branch.rs:12:11: 12:11\n+      let _1: i32;                         // in scope 0 at $DIR/branch.rs:13:9: 13:10\n+      let mut _3: bool;                    // in scope 0 at $DIR/branch.rs:15:16: 15:22\n+      let _4: i32;                         // in scope 0 at $DIR/branch.rs:18:9: 18:14\n+      scope 1 {\n+-         debug x => _1;                   // in scope 1 at $DIR/branch.rs:13:9: 13:10\n++         debug x => _2;                   // in scope 1 at $DIR/branch.rs:13:9: 13:10\n+          let _2: i32;                     // in scope 1 at $DIR/branch.rs:15:9: 15:10\n+          scope 2 {\n+              debug y => _2;               // in scope 2 at $DIR/branch.rs:15:9: 15:10\n+          }\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_1);                 // scope 0 at $DIR/branch.rs:13:9: 13:10\n+-         _1 = val() -> bb1;               // scope 0 at $DIR/branch.rs:13:13: 13:18\n++         nop;                             // scope 0 at $DIR/branch.rs:13:9: 13:10\n++         _2 = val() -> bb1;               // scope 0 at $DIR/branch.rs:13:13: 13:18\n+                                           // mir::Constant\n+                                           // + span: $DIR/branch.rs:13:13: 13:16\n+                                           // + literal: Const { ty: fn() -> i32 {val}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+-         StorageLive(_2);                 // scope 1 at $DIR/branch.rs:15:9: 15:10\n++         nop;                             // scope 1 at $DIR/branch.rs:15:9: 15:10\n+          StorageLive(_3);                 // scope 1 at $DIR/branch.rs:15:16: 15:22\n+          _3 = cond() -> bb2;              // scope 1 at $DIR/branch.rs:15:16: 15:22\n+                                           // mir::Constant\n+                                           // + span: $DIR/branch.rs:15:16: 15:20\n+                                           // + literal: Const { ty: fn() -> bool {cond}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2: {\n+          switchInt(_3) -> [false: bb3, otherwise: bb4]; // scope 1 at $DIR/branch.rs:15:13: 20:6\n+      }\n+  \n+      bb3: {\n+          StorageLive(_4);                 // scope 1 at $DIR/branch.rs:18:9: 18:14\n+          _4 = val() -> bb5;               // scope 1 at $DIR/branch.rs:18:9: 18:14\n+                                           // mir::Constant\n+                                           // + span: $DIR/branch.rs:18:9: 18:12\n+                                           // + literal: Const { ty: fn() -> i32 {val}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb4: {\n+-         _2 = _1;                         // scope 1 at $DIR/branch.rs:16:9: 16:10\n++         nop;                             // scope 1 at $DIR/branch.rs:16:9: 16:10\n+          goto -> bb6;                     // scope 1 at $DIR/branch.rs:15:13: 20:6\n+      }\n+  \n+      bb5: {\n+          StorageDead(_4);                 // scope 1 at $DIR/branch.rs:18:14: 18:15\n+-         _2 = _1;                         // scope 1 at $DIR/branch.rs:19:9: 19:10\n++         nop;                             // scope 1 at $DIR/branch.rs:19:9: 19:10\n+          goto -> bb6;                     // scope 1 at $DIR/branch.rs:15:13: 20:6\n+      }\n+  \n+      bb6: {\n+          StorageDead(_3);                 // scope 1 at $DIR/branch.rs:20:6: 20:7\n+          _0 = const ();                   // scope 0 at $DIR/branch.rs:12:11: 21:2\n+-         StorageDead(_2);                 // scope 1 at $DIR/branch.rs:21:1: 21:2\n+-         StorageDead(_1);                 // scope 0 at $DIR/branch.rs:21:1: 21:2\n++         nop;                             // scope 1 at $DIR/branch.rs:21:1: 21:2\n++         nop;                             // scope 0 at $DIR/branch.rs:21:1: 21:2\n+          return;                          // scope 0 at $DIR/branch.rs:21:2: 21:2\n+      }\n+  }\n+  "}, {"sha": "7e0e40671ddb20b46668b2fc56fbc2da9b87d2c1", "filename": "src/test/mir-opt/dest-prop/branch.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,21 @@\n+//! Tests that assignment in both branches of an `if` are eliminated.\n+\n+fn val() -> i32 {\n+    1\n+}\n+\n+fn cond() -> bool {\n+    true\n+}\n+\n+// EMIT_MIR branch.main.DestinationPropagation.diff\n+fn main() {\n+    let x = val();\n+\n+    let y = if cond() {\n+        x\n+    } else {\n+        val();\n+        x\n+    };\n+}"}, {"sha": "dd717c1b9c324480a9f229d1ba97211f8c18a016", "filename": "src/test/mir-opt/dest-prop/cycle.main.DestinationPropagation.diff", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.main.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,76 @@\n+- // MIR for `main` before DestinationPropagation\n++ // MIR for `main` after DestinationPropagation\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/cycle.rs:8:11: 8:11\n+      let mut _1: i32;                     // in scope 0 at $DIR/cycle.rs:9:9: 9:14\n+      let mut _4: i32;                     // in scope 0 at $DIR/cycle.rs:12:9: 12:10\n+      let _5: ();                          // in scope 0 at $DIR/cycle.rs:14:5: 14:12\n+      let mut _6: i32;                     // in scope 0 at $DIR/cycle.rs:14:10: 14:11\n+      scope 1 {\n+-         debug x => _1;                   // in scope 1 at $DIR/cycle.rs:9:9: 9:14\n++         debug x => _4;                   // in scope 1 at $DIR/cycle.rs:9:9: 9:14\n+          let _2: i32;                     // in scope 1 at $DIR/cycle.rs:10:9: 10:10\n+          scope 2 {\n+-             debug y => _2;               // in scope 2 at $DIR/cycle.rs:10:9: 10:10\n++             debug y => _4;               // in scope 2 at $DIR/cycle.rs:10:9: 10:10\n+              let _3: i32;                 // in scope 2 at $DIR/cycle.rs:11:9: 11:10\n+              scope 3 {\n+-                 debug z => _3;           // in scope 3 at $DIR/cycle.rs:11:9: 11:10\n++                 debug z => _4;           // in scope 3 at $DIR/cycle.rs:11:9: 11:10\n+                  scope 4 {\n+                      debug _x => _6;      // in scope 4 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_1);                 // scope 0 at $DIR/cycle.rs:9:9: 9:14\n+-         _1 = val() -> bb1;               // scope 0 at $DIR/cycle.rs:9:17: 9:22\n++         nop;                             // scope 0 at $DIR/cycle.rs:9:9: 9:14\n++         _4 = val() -> bb1;               // scope 0 at $DIR/cycle.rs:9:17: 9:22\n+                                           // mir::Constant\n+                                           // + span: $DIR/cycle.rs:9:17: 9:20\n+                                           // + literal: Const { ty: fn() -> i32 {val}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+-         StorageLive(_2);                 // scope 1 at $DIR/cycle.rs:10:9: 10:10\n+-         _2 = _1;                         // scope 1 at $DIR/cycle.rs:10:13: 10:14\n+-         StorageLive(_3);                 // scope 2 at $DIR/cycle.rs:11:9: 11:10\n+-         _3 = _2;                         // scope 2 at $DIR/cycle.rs:11:13: 11:14\n+-         StorageLive(_4);                 // scope 3 at $DIR/cycle.rs:12:9: 12:10\n+-         _4 = _3;                         // scope 3 at $DIR/cycle.rs:12:9: 12:10\n+-         _1 = move _4;                    // scope 3 at $DIR/cycle.rs:12:5: 12:10\n+-         StorageDead(_4);                 // scope 3 at $DIR/cycle.rs:12:9: 12:10\n++         nop;                             // scope 1 at $DIR/cycle.rs:10:9: 10:10\n++         nop;                             // scope 1 at $DIR/cycle.rs:10:13: 10:14\n++         nop;                             // scope 2 at $DIR/cycle.rs:11:9: 11:10\n++         nop;                             // scope 2 at $DIR/cycle.rs:11:13: 11:14\n++         nop;                             // scope 3 at $DIR/cycle.rs:12:9: 12:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:12:9: 12:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:12:5: 12:10\n++         nop;                             // scope 3 at $DIR/cycle.rs:12:9: 12:10\n+          StorageLive(_5);                 // scope 3 at $DIR/cycle.rs:14:5: 14:12\n+          StorageLive(_6);                 // scope 3 at $DIR/cycle.rs:14:10: 14:11\n+-         _6 = _1;                         // scope 3 at $DIR/cycle.rs:14:10: 14:11\n++         _6 = _4;                         // scope 3 at $DIR/cycle.rs:14:10: 14:11\n+          _5 = const ();                   // scope 4 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+          drop(_6) -> bb2;                 // scope 4 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+      }\n+  \n+      bb2: {\n+          StorageDead(_6);                 // scope 3 at $DIR/cycle.rs:14:11: 14:12\n+          StorageDead(_5);                 // scope 3 at $DIR/cycle.rs:14:12: 14:13\n+          _0 = const ();                   // scope 0 at $DIR/cycle.rs:8:11: 15:2\n+-         StorageDead(_3);                 // scope 2 at $DIR/cycle.rs:15:1: 15:2\n+-         StorageDead(_2);                 // scope 1 at $DIR/cycle.rs:15:1: 15:2\n+-         StorageDead(_1);                 // scope 0 at $DIR/cycle.rs:15:1: 15:2\n++         nop;                             // scope 2 at $DIR/cycle.rs:15:1: 15:2\n++         nop;                             // scope 1 at $DIR/cycle.rs:15:1: 15:2\n++         nop;                             // scope 0 at $DIR/cycle.rs:15:1: 15:2\n+          return;                          // scope 0 at $DIR/cycle.rs:15:2: 15:2\n+      }\n+  }\n+  "}, {"sha": "7fbffb13359468922c723b83f91c8b91ad2ecbd0", "filename": "src/test/mir-opt/dest-prop/cycle.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fcycle.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,15 @@\n+//! Tests that cyclic assignments don't hang DestinationPropagation, and result in reasonable code.\n+\n+fn val() -> i32 {\n+    1\n+}\n+\n+// EMIT_MIR cycle.main.DestinationPropagation.diff\n+fn main() {\n+    let mut x = val();\n+    let y = x;\n+    let z = y;\n+    x = z;\n+\n+    drop(x);\n+}"}, {"sha": "1277c51f2a050abaf56c8c2694a595fa1c9e0156", "filename": "src/test/mir-opt/dest-prop/simple.nrvo.DestinationPropagation.diff", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.nrvo.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,45 @@\n+- // MIR for `nrvo` before DestinationPropagation\n++ // MIR for `nrvo` after DestinationPropagation\n+  \n+  fn nrvo(_1: for<'r> fn(&'r mut [u8; 1024])) -> [u8; 1024] {\n+      debug init => _1;                    // in scope 0 at $DIR/simple.rs:4:9: 4:13\n+      let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/simple.rs:4:39: 4:49\n+      let mut _2: [u8; 1024];              // in scope 0 at $DIR/simple.rs:5:9: 5:16\n+      let _3: ();                          // in scope 0 at $DIR/simple.rs:6:5: 6:19\n+      let mut _4: for<'r> fn(&'r mut [u8; 1024]); // in scope 0 at $DIR/simple.rs:6:5: 6:9\n+      let mut _5: &mut [u8; 1024];         // in scope 0 at $DIR/simple.rs:6:10: 6:18\n+      let mut _6: &mut [u8; 1024];         // in scope 0 at $DIR/simple.rs:6:10: 6:18\n+      scope 1 {\n+-         debug buf => _2;                 // in scope 1 at $DIR/simple.rs:5:9: 5:16\n++         debug buf => _0;                 // in scope 1 at $DIR/simple.rs:5:9: 5:16\n+      }\n+  \n+      bb0: {\n+-         StorageLive(_2);                 // scope 0 at $DIR/simple.rs:5:9: 5:16\n+-         _2 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:5:19: 5:28\n++         nop;                             // scope 0 at $DIR/simple.rs:5:9: 5:16\n++         _0 = [const 0_u8; 1024];         // scope 0 at $DIR/simple.rs:5:19: 5:28\n+          StorageLive(_3);                 // scope 1 at $DIR/simple.rs:6:5: 6:19\n+          StorageLive(_4);                 // scope 1 at $DIR/simple.rs:6:5: 6:9\n+          _4 = _1;                         // scope 1 at $DIR/simple.rs:6:5: 6:9\n+          StorageLive(_5);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n+          StorageLive(_6);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n+-         _6 = &mut _2;                    // scope 1 at $DIR/simple.rs:6:10: 6:18\n++         _6 = &mut _0;                    // scope 1 at $DIR/simple.rs:6:10: 6:18\n+          _5 = &mut (*_6);                 // scope 1 at $DIR/simple.rs:6:10: 6:18\n+          _3 = move _4(move _5) -> bb1;    // scope 1 at $DIR/simple.rs:6:5: 6:19\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 1 at $DIR/simple.rs:6:18: 6:19\n+          StorageDead(_4);                 // scope 1 at $DIR/simple.rs:6:18: 6:19\n+          StorageDead(_6);                 // scope 1 at $DIR/simple.rs:6:19: 6:20\n+          StorageDead(_3);                 // scope 1 at $DIR/simple.rs:6:19: 6:20\n+-         _0 = _2;                         // scope 1 at $DIR/simple.rs:7:5: 7:8\n+-         StorageDead(_2);                 // scope 0 at $DIR/simple.rs:8:1: 8:2\n++         nop;                             // scope 1 at $DIR/simple.rs:7:5: 7:8\n++         nop;                             // scope 0 at $DIR/simple.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/simple.rs:8:2: 8:2\n+      }\n+  }\n+  "}, {"sha": "4655f96699874c58b503237fd8272a97d47e4334", "filename": "src/test/mir-opt/dest-prop/simple.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fsimple.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,14 @@\n+//! Copy of `nrvo-simple.rs`, to ensure that full dest-prop handles it too.\n+\n+// EMIT_MIR simple.nrvo.DestinationPropagation.diff\n+fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n+    let mut buf = [0; 1024];\n+    init(&mut buf);\n+    buf\n+}\n+\n+fn main() {\n+    let _ = nrvo(|buf| {\n+        buf[4] = 4;\n+    });\n+}"}, {"sha": "871f6e35043ec666522dac1599412efb64c41b17", "filename": "src/test/mir-opt/dest-prop/union.main.DestinationPropagation.diff", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.main.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,46 @@\n+- // MIR for `main` before DestinationPropagation\n++ // MIR for `main` after DestinationPropagation\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/union.rs:8:11: 8:11\n+      let _1: main::Un;                    // in scope 0 at $DIR/union.rs:13:9: 13:11\n+      let mut _2: u32;                     // in scope 0 at $DIR/union.rs:13:23: 13:28\n+      let _3: ();                          // in scope 0 at $DIR/union.rs:15:5: 15:27\n+      let mut _4: u32;                     // in scope 0 at $DIR/union.rs:15:10: 15:26\n+      scope 1 {\n+          debug un => _1;                  // in scope 1 at $DIR/union.rs:13:9: 13:11\n+          scope 2 {\n+          }\n+          scope 3 {\n+              debug _x => _4;              // in scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/union.rs:13:9: 13:11\n+          StorageLive(_2);                 // scope 0 at $DIR/union.rs:13:23: 13:28\n+          _2 = val() -> bb1;               // scope 0 at $DIR/union.rs:13:23: 13:28\n+                                           // mir::Constant\n+                                           // + span: $DIR/union.rs:13:23: 13:26\n+                                           // + literal: Const { ty: fn() -> u32 {val}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          (_1.0: u32) = move _2;           // scope 0 at $DIR/union.rs:13:14: 13:30\n+          StorageDead(_2);                 // scope 0 at $DIR/union.rs:13:29: 13:30\n+          StorageLive(_3);                 // scope 1 at $DIR/union.rs:15:5: 15:27\n+          StorageLive(_4);                 // scope 1 at $DIR/union.rs:15:10: 15:26\n+          _4 = (_1.0: u32);                // scope 2 at $DIR/union.rs:15:19: 15:24\n+          _3 = const ();                   // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+          drop(_4) -> bb2;                 // scope 3 at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+      }\n+  \n+      bb2: {\n+          StorageDead(_4);                 // scope 1 at $DIR/union.rs:15:26: 15:27\n+          StorageDead(_3);                 // scope 1 at $DIR/union.rs:15:27: 15:28\n+          _0 = const ();                   // scope 0 at $DIR/union.rs:8:11: 16:2\n+          StorageDead(_1);                 // scope 0 at $DIR/union.rs:16:1: 16:2\n+          return;                          // scope 0 at $DIR/union.rs:16:2: 16:2\n+      }\n+  }\n+  "}, {"sha": "b9d831389e8b3ae62ce3db76f42ccb95b3bc89c5", "filename": "src/test/mir-opt/dest-prop/union.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Funion.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,16 @@\n+//! Tests that projections through unions cancel `DestinationPropagation`.\n+\n+fn val() -> u32 {\n+    1\n+}\n+\n+// EMIT_MIR union.main.DestinationPropagation.diff\n+fn main() {\n+    union Un {\n+        us: u32,\n+    }\n+\n+    let un = Un { us: val() };\n+\n+    drop(unsafe { un.us });\n+}"}, {"sha": "ab194cf532ff3e074878fed6b6f7eb0fc920a7e8", "filename": "src/test/mir-opt/inline/inline_closure_captures.foo.Inline.after.mir", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_captures.foo.Inline.after.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -10,15 +10,14 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n     let mut _6: &[closure@foo<T>::{{closure}}#0 q:&i32, t:&T]; // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:6\n     let mut _7: (i32,);                  // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n     let mut _8: i32;                     // in scope 0 at $DIR/inline-closure-captures.rs:12:7: 12:8\n-    let mut _11: i32;                    // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+    let mut _10: i32;                    // in scope 0 at $DIR/inline-closure-captures.rs:12:5: 12:9\n     scope 1 {\n         debug x => _3;                   // in scope 1 at $DIR/inline-closure-captures.rs:11:9: 11:10\n         scope 2 {\n-            debug _q => _11;             // in scope 2 at $DIR/inline-closure-captures.rs:11:14: 11:16\n+            debug _q => _10;             // in scope 2 at $DIR/inline-closure-captures.rs:11:14: 11:16\n             debug q => (*((*_6).0: &i32)); // in scope 2 at $DIR/inline-closure-captures.rs:10:23: 10:24\n             debug t => (*((*_6).1: &T)); // in scope 2 at $DIR/inline-closure-captures.rs:10:17: 10:18\n-            let mut _9: i32;             // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-            let mut _10: T;              // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+            let mut _9: T;               // in scope 2 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         }\n     }\n \n@@ -38,17 +37,14 @@ fn foo(_1: T, _2: i32) -> (i32, T) {\n         StorageLive(_8);                 // scope 1 at $DIR/inline-closure-captures.rs:12:7: 12:8\n         _8 = _2;                         // scope 1 at $DIR/inline-closure-captures.rs:12:7: 12:8\n         (_7.0: i32) = move _8;           // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        StorageLive(_11);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        _11 = move (_7.0: i32);          // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n-        StorageLive(_9);                 // scope 2 at $DIR/inline-closure-captures.rs:11:19: 11:20\n-        _9 = (*((*_6).0: &i32));         // scope 2 at $DIR/inline-closure-captures.rs:11:19: 11:20\n-        StorageLive(_10);                // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n-        _10 = (*((*_6).1: &T));          // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n-        (_0.0: i32) = move _9;           // scope 2 at $DIR/inline-closure-captures.rs:11:18: 11:24\n-        (_0.1: T) = move _10;            // scope 2 at $DIR/inline-closure-captures.rs:11:18: 11:24\n-        StorageDead(_10);                // scope 2 at $DIR/inline-closure-captures.rs:11:23: 11:24\n+        StorageLive(_10);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        _10 = move (_7.0: i32);          // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        (_0.0: i32) = (*((*_6).0: &i32)); // scope 2 at $DIR/inline-closure-captures.rs:11:19: 11:20\n+        StorageLive(_9);                 // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n+        _9 = (*((*_6).1: &T));           // scope 2 at $DIR/inline-closure-captures.rs:11:22: 11:23\n+        (_0.1: T) = move _9;             // scope 2 at $DIR/inline-closure-captures.rs:11:18: 11:24\n         StorageDead(_9);                 // scope 2 at $DIR/inline-closure-captures.rs:11:23: 11:24\n-        StorageDead(_11);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n+        StorageDead(_10);                // scope 1 at $DIR/inline-closure-captures.rs:12:5: 12:9\n         StorageDead(_8);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9\n         StorageDead(_7);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9\n         StorageDead(_6);                 // scope 1 at $DIR/inline-closure-captures.rs:12:8: 12:9"}, {"sha": "a8662b96566cc7db862c617b77fdc58de78b31f1", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.32bit.diff", "status": "modified", "additions": 85, "deletions": 122, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -3,205 +3,168 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue-73223.rs:1:11: 1:11\n-      let mut _1: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-      let _2: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-      let mut _4: i32;                     // in scope 0 at $DIR/issue-73223.rs:7:22: 7:27\n-      let mut _5: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _9: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _10: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _11: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _12: &std::fmt::Arguments;       // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _13: std::fmt::Arguments;        // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _14: &[&str];                // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _15: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _16: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _17: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _18: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _19: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _20: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _21: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _24: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _25: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _26: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n+      let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let mut _4: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _5: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _6: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: &std::fmt::Arguments;    // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _9: std::fmt::Arguments;         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _10: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _11: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _12: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _13: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _14: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _15: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _16: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _17: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       scope 1 {\n-          debug split => _2;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n+          debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _3: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _3;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n-              let _7: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-              let _8: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _7;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _8;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _22: &&i32;          // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _23: &&i32;          // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _13;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _15;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _22;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg0 => _20;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _23;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _22;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _25;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _28: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _29: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _19;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _18: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _19: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _20: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                       scope 8 {\n                           debug x => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _27;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _30: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _31: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug f => _22;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _21: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _22: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n-                      debug pieces => _14; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      debug args => _15;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _32: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      debug pieces => (_9.0: &[&str]); // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      debug args => _25;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _24: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _25: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n-          debug v => _2;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n+          debug v => _1;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n       scope 7 {\n       }\n       scope 9 {\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          ((_1 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          discriminant(_1) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          _2 = ((_1 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-          StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          StorageLive(_3);                 // scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n-          StorageLive(_4);                 // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n-          _4 = _2;                         // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n-          ((_3 as Some).0: i32) = move _4; // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n+          StorageLive(_2);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          ((_2 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          discriminant(_2) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          _1 = ((_2 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n+          StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n+          ((_3 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n           discriminant(_3) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          StorageDead(_4);                 // scope 1 at $DIR/issue-73223.rs:7:27: 7:28\n-          StorageLive(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = &_2;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_5.0: &i32) = move _6;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_5.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = (_5.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _8 = (_5.1: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _11 = (*_7);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _10 = Eq(move _11, const 1_i32); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _9 = Not(move _10);              // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(_9) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _13 = (_4.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = (_4.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = (*_13);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _6 = Eq(move _7, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _5 = Not(move _6);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(_5) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n-          StorageDead(_3);                 // scope 1 at $DIR/issue-73223.rs:9:1: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }\n   \n       bb2: {\n-          StorageLive(_13);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _14 = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_9.0: &[&str]) = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          StorageLive(_17);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_18);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_19);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_20);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _20 = _7;                        // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _19 = &_20;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_21);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _21 = &_8;                       // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_18.0: &&i32) = move _19;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          (_18.1: &&i32) = move _21;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_21);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_19);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _22 = (_18.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _23 = (_18.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_24);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _25 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_12.0: &&i32) = &_13;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _14 = &_15;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_12.1: &&i32) = move _14;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageDead(_14);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _20 = (_12.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _23 = (_12.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _19 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_28);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _28 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _25) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _18 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _19) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb3: {\n-          StorageLive(_29);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _29 = transmute::<&&i32, &core::fmt::Opaque>(move _22) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_16.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _20) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb4: {\n-          (_24.0: &core::fmt::Opaque) = move _29; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_24.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _28; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_29);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_28);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageLive(_26);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _27 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_16.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _18; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _22 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_30);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _30 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _27) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _21 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _22) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb5: {\n-          StorageLive(_31);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _31 = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb6: {\n-          (_26.0: &core::fmt::Opaque) = move _31; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_26.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _30; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_31);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_30);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _17 = [move _24, move _26];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_26);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_24);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _16 = &_17;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _15 = move _16 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_32);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          discriminant(_32) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.0: &[&str]) = move _14;     // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _32; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.2: &[std::fmt::ArgumentV1]) = move _15; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_32);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _12 = &_13;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          begin_panic_fmt(move _12);       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _21; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _11 = [move _16, move _17];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _10 = &_11;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _25 = move _10 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          discriminant(_24) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_9.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _24; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_9.2: &[std::fmt::ArgumentV1]) = move _25; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _8 = &_9;                        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          begin_panic_fmt(move _8);        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's> fn(&'r std::fmt::Arguments<'s>) -> ! {std::rt::begin_panic_fmt}, val: Value(Scalar(<ZST>)) }"}, {"sha": "a8662b96566cc7db862c617b77fdc58de78b31f1", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.64bit.diff", "status": "modified", "additions": 85, "deletions": 122, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -3,205 +3,168 @@\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/issue-73223.rs:1:11: 1:11\n-      let mut _1: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-      let _2: i32;                         // in scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-      let mut _4: i32;                     // in scope 0 at $DIR/issue-73223.rs:7:22: 7:27\n-      let mut _5: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _6: &i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _9: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _10: bool;                   // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _11: i32;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _12: &std::fmt::Arguments;       // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _13: std::fmt::Arguments;        // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _14: &[&str];                // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _15: &[std::fmt::ArgumentV1]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _16: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let _17: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _18: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _19: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let _20: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _21: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _24: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _25: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-      let mut _26: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n-      let mut _27: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _1: i32;                         // in scope 0 at $DIR/issue-73223.rs:2:9: 2:14\n+      let mut _2: std::option::Option<i32>; // in scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+      let mut _4: (&i32, &i32);            // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _5: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _6: bool;                    // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _7: i32;                     // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _8: &std::fmt::Arguments;    // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _9: std::fmt::Arguments;         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _10: &[std::fmt::ArgumentV1; 2]; // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _11: [std::fmt::ArgumentV1; 2];  // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _12: (&&i32, &&i32);         // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let _13: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _14: &&i32;                  // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let _15: &i32;                       // in scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+      let mut _16: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n+      let mut _17: std::fmt::ArgumentV1;   // in scope 0 at $SRC_DIR/std/src/macros.rs:LL:COL\n       scope 1 {\n-          debug split => _2;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n+          debug split => _1;               // in scope 1 at $DIR/issue-73223.rs:2:9: 2:14\n           let _3: std::option::Option<i32>; // in scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n           scope 3 {\n               debug _prev => _3;           // in scope 3 at $DIR/issue-73223.rs:7:9: 7:14\n-              let _7: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-              let _8: &i32;                // in scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n               scope 4 {\n-                  debug left_val => _7;    // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  debug right_val => _8;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _22: &&i32;          // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                  let _23: &&i32;          // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug left_val => _13;   // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                  debug right_val => _15;  // in scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                   scope 5 {\n-                      debug arg0 => _22;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+                      debug arg0 => _20;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       debug arg1 => _23;   // in scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                       scope 6 {\n-                          debug x => _22;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _25;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _28: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _29: &core::fmt::Opaque; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug x => _20;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          debug f => _19;  // in scope 6 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _18: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _19: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _20: &&i32; // in scope 6 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                       scope 8 {\n                           debug x => _23;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          debug f => _27;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                          let mut _30: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n-                          let mut _31: &core::fmt::Opaque; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          debug f => _22;  // in scope 8 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                          let mut _21: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _22: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                          let mut _23: &&i32; // in scope 8 at $SRC_DIR/std/src/macros.rs:LL:COL\n                       }\n                   }\n                   scope 10 {\n-                      debug pieces => _14; // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      debug args => _15;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-                      let mut _32: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      debug pieces => (_9.0: &[&str]); // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      debug args => _25;   // in scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+                      let mut _24: std::option::Option<&[std::fmt::rt::v1::Argument]>; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n+                      let mut _25: &[std::fmt::ArgumentV1]; // in scope 10 at $SRC_DIR/std/src/macros.rs:LL:COL\n                   }\n               }\n           }\n       }\n       scope 2 {\n-          debug v => _2;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n+          debug v => _1;                   // in scope 2 at $DIR/issue-73223.rs:3:14: 3:15\n       }\n       scope 7 {\n       }\n       scope 9 {\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          ((_1 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          discriminant(_1) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n-          _2 = ((_1 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n-          StorageDead(_1);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n-          StorageLive(_3);                 // scope 1 at $DIR/issue-73223.rs:7:9: 7:14\n-          StorageLive(_4);                 // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n-          _4 = _2;                         // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n-          ((_3 as Some).0: i32) = move _4; // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n+          StorageLive(_2);                 // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          ((_2 as Some).0: i32) = const 1_i32; // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          discriminant(_2) = 1;            // scope 0 at $DIR/issue-73223.rs:2:23: 2:30\n+          _1 = ((_2 as Some).0: i32);      // scope 0 at $DIR/issue-73223.rs:3:14: 3:15\n+          StorageDead(_2);                 // scope 0 at $DIR/issue-73223.rs:5:6: 5:7\n+          ((_3 as Some).0: i32) = _1;      // scope 1 at $DIR/issue-73223.rs:7:22: 7:27\n           discriminant(_3) = 1;            // scope 1 at $DIR/issue-73223.rs:7:17: 7:28\n-          StorageDead(_4);                 // scope 1 at $DIR/issue-73223.rs:7:27: 7:28\n-          StorageLive(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _6 = &_2;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_5.0: &i32) = move _6;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_5.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.0: &i32) = &_1;              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_4.1: &i32) = const main::promoted[1]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &i32\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &i32, val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[1])) }\n-          StorageDead(_6);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _7 = (_5.0: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _8 = (_5.1: &i32);               // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _11 = (*_7);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _10 = Eq(move _11, const 1_i32); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_11);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _9 = Not(move _10);              // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_10);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(_9) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _13 = (_4.0: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _15 = (_4.1: &i32);              // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _7 = (*_13);                     // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _6 = Eq(move _7, const 1_i32);   // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_7);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _5 = Not(move _6);               // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_6);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(_5) -> [false: bb1, otherwise: bb2]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n-          StorageDead(_9);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_7);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageDead(_5);                 // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageDead(_5);                 // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _0 = const ();                   // scope 0 at $DIR/issue-73223.rs:1:11: 9:2\n-          StorageDead(_3);                 // scope 1 at $DIR/issue-73223.rs:9:1: 9:2\n           return;                          // scope 0 at $DIR/issue-73223.rs:9:2: 9:2\n       }\n   \n       bb2: {\n-          StorageLive(_13);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _14 = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_9.0: &[&str]) = const main::promoted[0] as &[&str] (Pointer(Unsize)); // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // ty::Const\n                                            // + ty: &[&str; 3]\n                                            // + val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: &[&str; 3], val: Unevaluated(WithOptConstParam { did: DefId(0:3 ~ issue_73223[317d]::main[0]), const_param_did: None }, [], Some(promoted[0])) }\n-          StorageLive(_17);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_18);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_19);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_20);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _20 = _7;                        // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _19 = &_20;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_21);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _21 = &_8;                       // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          (_18.0: &&i32) = move _19;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          (_18.1: &&i32) = move _21;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_21);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_19);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _22 = (_18.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          _23 = (_18.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          StorageLive(_24);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _25 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_11);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_12.0: &&i32) = &_13;           // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          StorageLive(_14);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _14 = &_15;                      // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_12.1: &&i32) = move _14;       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageDead(_14);                // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _20 = (_12.0: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _23 = (_12.1: &&i32);            // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          _19 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_28);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _28 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _25) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _18 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _19) -> bb3; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb3: {\n-          StorageLive(_29);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _29 = transmute::<&&i32, &core::fmt::Opaque>(move _22) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_16.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _20) -> bb4; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb4: {\n-          (_24.0: &core::fmt::Opaque) = move _29; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_24.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _28; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_29);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_28);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageLive(_26);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _27 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          (_16.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _18; // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_18);                // scope 7 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _22 = <&i32 as Debug>::fmt as for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> (Pointer(ReifyFnPointer)); // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {<&i32 as std::fmt::Debug>::fmt}, val: Value(Scalar(<ZST>)) }\n-          StorageLive(_30);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _30 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _27) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageLive(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _21 = transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>(move _22) -> bb5; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) -> for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error> {std::intrinsics::transmute::<for<'r, 's, 't0> fn(&'r &i32, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>, for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb5: {\n-          StorageLive(_31);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _31 = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_17.0: &core::fmt::Opaque) = transmute::<&&i32, &core::fmt::Opaque>(move _23) -> bb6; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n                                            // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(&&i32) -> &core::fmt::Opaque {std::intrinsics::transmute::<&&i32, &core::fmt::Opaque>}, val: Value(Scalar(<ZST>)) }\n       }\n   \n       bb6: {\n-          (_26.0: &core::fmt::Opaque) = move _31; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_26.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _30; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_31);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_30);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _17 = [move _24, move _26];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_26);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageDead(_24);                // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _16 = &_17;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          _15 = move _16 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          StorageLive(_32);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          discriminant(_32) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.0: &[&str]) = move _14;     // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _32; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          (_13.2: &[std::fmt::ArgumentV1]) = move _15; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          StorageDead(_32);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n-          _12 = &_13;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n-          begin_panic_fmt(move _12);       // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          (_17.1: for<'r, 's, 't0> fn(&'r core::fmt::Opaque, &'s mut std::fmt::Formatter<'t0>) -> std::result::Result<(), std::fmt::Error>) = move _21; // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_21);                // scope 9 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _11 = [move _16, move _17];      // scope 5 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _10 = &_11;                      // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          _25 = move _10 as &[std::fmt::ArgumentV1] (Pointer(Unsize)); // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          StorageLive(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          discriminant(_24) = 0;           // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_9.1: std::option::Option<&[std::fmt::rt::v1::Argument]>) = move _24; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          (_9.2: &[std::fmt::ArgumentV1]) = move _25; // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          StorageDead(_24);                // scope 10 at $SRC_DIR/core/src/fmt/mod.rs:LL:COL\n+          _8 = &_9;                        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n+          begin_panic_fmt(move _8);        // scope 4 at $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/std/src/macros.rs:LL:COL\n                                            // + literal: Const { ty: for<'r, 's> fn(&'r std::fmt::Arguments<'s>) -> ! {std::rt::begin_panic_fmt}, val: Value(Scalar(<ZST>)) }"}, {"sha": "ab46d7b94c72c09872aec2d17d961ae5f1cc4d97", "filename": "src/test/mir-opt/nrvo-simple.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnrvo-simple.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -1,3 +1,5 @@\n+// compile-flags: -Zmir-opt-level=1\n+\n // EMIT_MIR nrvo_simple.nrvo.RenameReturnPlace.diff\n fn nrvo(init: fn(&mut [u8; 1024])) -> [u8; 1024] {\n     let mut buf = [0; 1024];"}, {"sha": "f438eaa002780958f07d88a70f123bd229129de0", "filename": "src/test/mir-opt/nrvo_simple.nrvo.RenameReturnPlace.diff", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fnrvo_simple.nrvo.RenameReturnPlace.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fnrvo_simple.nrvo.RenameReturnPlace.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnrvo_simple.nrvo.RenameReturnPlace.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -2,39 +2,42 @@\n + // MIR for `nrvo` after RenameReturnPlace\n   \n   fn nrvo(_1: for<'r> fn(&'r mut [u8; 1024])) -> [u8; 1024] {\n-      debug init => _1;                    // in scope 0 at $DIR/nrvo-simple.rs:2:9: 2:13\n--     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:2:39: 2:49\n-+     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n-      let mut _2: [u8; 1024];              // in scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n-      let _3: ();                          // in scope 0 at $DIR/nrvo-simple.rs:4:5: 4:19\n-      let mut _4: for<'r> fn(&'r mut [u8; 1024]); // in scope 0 at $DIR/nrvo-simple.rs:4:5: 4:9\n-      let mut _5: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:4:10: 4:18\n-      let mut _6: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:4:10: 4:18\n+      debug init => _1;                    // in scope 0 at $DIR/nrvo-simple.rs:4:9: 4:13\n+-     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:4:39: 4:49\n++     let mut _0: [u8; 1024];              // return place in scope 0 at $DIR/nrvo-simple.rs:5:9: 5:16\n+      let mut _2: [u8; 1024];              // in scope 0 at $DIR/nrvo-simple.rs:5:9: 5:16\n+      let _3: ();                          // in scope 0 at $DIR/nrvo-simple.rs:6:5: 6:19\n+      let mut _4: for<'r> fn(&'r mut [u8; 1024]); // in scope 0 at $DIR/nrvo-simple.rs:6:5: 6:9\n+      let mut _5: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:6:10: 6:18\n+      let mut _6: &mut [u8; 1024];         // in scope 0 at $DIR/nrvo-simple.rs:6:10: 6:18\n       scope 1 {\n--         debug buf => _2;                 // in scope 1 at $DIR/nrvo-simple.rs:3:9: 3:16\n-+         debug buf => _0;                 // in scope 1 at $DIR/nrvo-simple.rs:3:9: 3:16\n+-         debug buf => _2;                 // in scope 1 at $DIR/nrvo-simple.rs:5:9: 5:16\n++         debug buf => _0;                 // in scope 1 at $DIR/nrvo-simple.rs:5:9: 5:16\n       }\n   \n       bb0: {\n--         StorageLive(_2);                 // scope 0 at $DIR/nrvo-simple.rs:3:9: 3:16\n--         _2 = [const 0_u8; 1024];         // scope 0 at $DIR/nrvo-simple.rs:3:19: 3:28\n-+         _0 = [const 0_u8; 1024];         // scope 0 at $DIR/nrvo-simple.rs:3:19: 3:28\n-          StorageLive(_3);                 // scope 1 at $DIR/nrvo-simple.rs:4:5: 4:19\n-          StorageLive(_5);                 // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n-          StorageLive(_6);                 // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n--         _6 = &mut _2;                    // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n-+         _6 = &mut _0;                    // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n-          _5 = &mut (*_6);                 // scope 1 at $DIR/nrvo-simple.rs:4:10: 4:18\n-          _3 = move _1(move _5) -> bb1;    // scope 1 at $DIR/nrvo-simple.rs:4:5: 4:19\n+-         StorageLive(_2);                 // scope 0 at $DIR/nrvo-simple.rs:5:9: 5:16\n+-         _2 = [const 0_u8; 1024];         // scope 0 at $DIR/nrvo-simple.rs:5:19: 5:28\n++         _0 = [const 0_u8; 1024];         // scope 0 at $DIR/nrvo-simple.rs:5:19: 5:28\n+          StorageLive(_3);                 // scope 1 at $DIR/nrvo-simple.rs:6:5: 6:19\n+          StorageLive(_4);                 // scope 1 at $DIR/nrvo-simple.rs:6:5: 6:9\n+          _4 = _1;                         // scope 1 at $DIR/nrvo-simple.rs:6:5: 6:9\n+          StorageLive(_5);                 // scope 1 at $DIR/nrvo-simple.rs:6:10: 6:18\n+          StorageLive(_6);                 // scope 1 at $DIR/nrvo-simple.rs:6:10: 6:18\n+-         _6 = &mut _2;                    // scope 1 at $DIR/nrvo-simple.rs:6:10: 6:18\n++         _6 = &mut _0;                    // scope 1 at $DIR/nrvo-simple.rs:6:10: 6:18\n+          _5 = &mut (*_6);                 // scope 1 at $DIR/nrvo-simple.rs:6:10: 6:18\n+          _3 = move _4(move _5) -> bb1;    // scope 1 at $DIR/nrvo-simple.rs:6:5: 6:19\n       }\n   \n       bb1: {\n-          StorageDead(_5);                 // scope 1 at $DIR/nrvo-simple.rs:4:18: 4:19\n-          StorageDead(_6);                 // scope 1 at $DIR/nrvo-simple.rs:4:19: 4:20\n-          StorageDead(_3);                 // scope 1 at $DIR/nrvo-simple.rs:4:19: 4:20\n--         _0 = _2;                         // scope 1 at $DIR/nrvo-simple.rs:5:5: 5:8\n--         StorageDead(_2);                 // scope 0 at $DIR/nrvo-simple.rs:6:1: 6:2\n-          return;                          // scope 0 at $DIR/nrvo-simple.rs:6:2: 6:2\n+          StorageDead(_5);                 // scope 1 at $DIR/nrvo-simple.rs:6:18: 6:19\n+          StorageDead(_4);                 // scope 1 at $DIR/nrvo-simple.rs:6:18: 6:19\n+          StorageDead(_6);                 // scope 1 at $DIR/nrvo-simple.rs:6:19: 6:20\n+          StorageDead(_3);                 // scope 1 at $DIR/nrvo-simple.rs:6:19: 6:20\n+-         _0 = _2;                         // scope 1 at $DIR/nrvo-simple.rs:7:5: 7:8\n+-         StorageDead(_2);                 // scope 0 at $DIR/nrvo-simple.rs:8:1: 8:2\n+          return;                          // scope 0 at $DIR/nrvo-simple.rs:8:2: 8:2\n       }\n   }\n   "}, {"sha": "c3e503bf2c686bf784accdb4776e0d3047ca25ad", "filename": "src/test/mir-opt/rustc.try_identity.DestinationPropagation.diff", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Frustc.try_identity.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Frustc.try_identity.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Frustc.try_identity.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,72 @@\n+- // MIR for `try_identity` before DestinationPropagation\n++ // MIR for `try_identity` after DestinationPropagation\n+  \n+  fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:6:17: 6:18\n+      let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:6:41: 6:57\n+      let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+      let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+      let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:8:8: 8:9\n+      scope 1 {\n+          debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n+      }\n+      scope 2 {\n+          debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n+          scope 3 {\n+              scope 7 {\n+                  debug t => _9;           // in scope 7 at $SRC_DIR/libcore/convert/mod.rs:LL:COL\n+              }\n+              scope 8 {\n+                  debug v => _8;           // in scope 8 at $SRC_DIR/libcore/result.rs:LL:COL\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:7:14: 7:15\n+              }\n+          }\n+      }\n+      scope 4 {\n+          debug val => _10;                // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n+          scope 5 {\n+          }\n+      }\n+      scope 6 {\n+-         debug self => _4;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n++         debug self => _0;                // in scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+-         StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+-         StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+-         _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+-         _3 = move _4;                    // scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n+-         StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n++         _0 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n++         nop;                             // scope 6 at $SRC_DIR/libcore/result.rs:LL:COL\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n++         _5 = discriminant(_0);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+          goto -> bb1;                     // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      }\n+  \n+      bb1: {\n+-         _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+-         StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n++         nop;                             // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:9:1: 9:2\n+          goto -> bb2;                     // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "fca80bee89679df7dbdcbf074baf1796bfc21596", "filename": "src/test/mir-opt/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -1,6 +1,7 @@\n // EMIT_MIR simplify_try.try_identity.SimplifyArmIdentity.diff\n // EMIT_MIR simplify_try.try_identity.SimplifyBranchSame.after.mir\n // EMIT_MIR simplify_try.try_identity.SimplifyLocals.after.mir\n+// EMIT_MIR simplify_try.try_identity.DestinationPropagation.diff\n \n fn try_identity(x: Result<u32, i32>) -> Result<u32, i32> {\n     let y = x?;"}, {"sha": "187a3cfbb896d545e2bbed1f86e29e6439bf4d7a", "filename": "src/test/mir-opt/simplify_try.try_identity.DestinationPropagation.diff", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.DestinationPropagation.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,72 @@\n+- // MIR for `try_identity` before DestinationPropagation\n++ // MIR for `try_identity` after DestinationPropagation\n+  \n+  fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n+      debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:6:17: 6:18\n+      let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:6:41: 6:57\n+      let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+      let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+      let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:8:8: 8:9\n+      scope 1 {\n+          debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n+      }\n+      scope 2 {\n+          debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n+          scope 3 {\n+              scope 7 {\n+                  debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+              }\n+              scope 8 {\n+                  debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:7:14: 7:15\n+              }\n+          }\n+      }\n+      scope 4 {\n+          debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n+          scope 5 {\n+          }\n+      }\n+      scope 6 {\n+-         debug self => _4;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n++         debug self => _0;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+-         StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+-         StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+-         _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+-         _3 = move _4;                    // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+-         StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+-         _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n++         _0 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n++         nop;                             // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n++         _5 = discriminant(_0);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+          goto -> bb1;                     // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      }\n+  \n+      bb1: {\n+-         _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+-         StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n++         nop;                             // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n++         nop;                             // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:9:1: 9:2\n+          goto -> bb2;                     // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n+      }\n+  \n+      bb2: {\n+          return;                          // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "0c687684c508ea25d83005607844dbc25820a519", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyArmIdentity.diff", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyArmIdentity.diff?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -2,25 +2,25 @@\n + // MIR for `try_identity` after SimplifyArmIdentity\n   \n   fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n-      debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:5:17: 5:18\n-      let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:5:41: 5:57\n-      let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n-      let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-      let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n-      let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-      let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-      let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-      let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-      let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-      let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-      let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:7:8: 7:9\n+      debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:6:17: 6:18\n+      let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:6:41: 6:57\n+      let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+      let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+      let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+      let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+      let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:8:8: 8:9\n       scope 1 {\n--         debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n-+         debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+-         debug y => _2;                   // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n++         debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n       }\n       scope 2 {\n--         debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n-+         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n+-         debug err => _6;                 // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n++         debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n           scope 3 {\n               scope 7 {\n -                 debug t => _9;           // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n@@ -29,13 +29,13 @@\n               scope 8 {\n -                 debug v => _8;           // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n +                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:6:14: 6:15\n+                  let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:7:14: 7:15\n               }\n           }\n       }\n       scope 4 {\n--         debug val => _10;                // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n-+         debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n+-         debug val => _10;                // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n++         debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n           scope 5 {\n           }\n       }\n@@ -44,55 +44,55 @@\n       }\n   \n       bb0: {\n-          StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n-          StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-          StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n-          _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+          StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+          StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+          _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n           _3 = move _4;                    // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-          _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-          switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+          StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+          _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+          switchInt(move _5) -> [0_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n       }\n   \n       bb1: {\n--         StorageLive(_10);                // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n--         _10 = ((_3 as Ok).0: u32);       // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n--         _2 = _10;                        // scope 5 at $DIR/simplify_try.rs:6:13: 6:15\n--         StorageDead(_10);                // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-+         _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n--         StorageLive(_11);                // scope 1 at $DIR/simplify_try.rs:7:8: 7:9\n--         _11 = _2;                        // scope 1 at $DIR/simplify_try.rs:7:8: 7:9\n--         ((_0 as Ok).0: u32) = move _11;  // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n--         discriminant(_0) = 0;            // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n--         StorageDead(_11);                // scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n-          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n-          goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n+-         StorageLive(_10);                // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+-         _10 = ((_3 as Ok).0: u32);       // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+-         _2 = _10;                        // scope 5 at $DIR/simplify_try.rs:7:13: 7:15\n+-         StorageDead(_10);                // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n++         _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n+-         StorageLive(_11);                // scope 1 at $DIR/simplify_try.rs:8:8: 8:9\n+-         _11 = _2;                        // scope 1 at $DIR/simplify_try.rs:8:8: 8:9\n+-         ((_0 as Ok).0: u32) = move _11;  // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+-         discriminant(_0) = 0;            // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+-         StorageDead(_11);                // scope 1 at $DIR/simplify_try.rs:8:9: 8:10\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:9:1: 9:2\n+          goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n       }\n   \n       bb2: {\n--         StorageLive(_6);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n--         _6 = ((_3 as Err).0: i32);       // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n--         StorageLive(_8);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n--         StorageLive(_9);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n--         _9 = _6;                         // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageLive(_6);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+-         _6 = ((_3 as Err).0: i32);       // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+-         StorageLive(_8);                 // scope 3 at $DIR/simplify_try.rs:7:14: 7:15\n+-         StorageLive(_9);                 // scope 3 at $DIR/simplify_try.rs:7:14: 7:15\n+-         _9 = _6;                         // scope 3 at $DIR/simplify_try.rs:7:14: 7:15\n -         _8 = move _9;                    // scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n--         StorageDead(_9);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageDead(_9);                 // scope 3 at $DIR/simplify_try.rs:7:14: 7:15\n -         StorageLive(_12);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n -         _12 = move _8;                   // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n -         ((_0 as Err).0: i32) = move _12; // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n -         discriminant(_0) = 1;            // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n -         StorageDead(_12);                // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n--         StorageDead(_8);                 // scope 3 at $DIR/simplify_try.rs:6:14: 6:15\n--         StorageDead(_6);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+-         StorageDead(_8);                 // scope 3 at $DIR/simplify_try.rs:7:14: 7:15\n+-         StorageDead(_6);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n +         _0 = move _3;                    // scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n-          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n-          goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+          StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:9:1: 9:2\n+          goto -> bb3;                     // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n       }\n   \n       bb3: {\n-          return;                          // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n+          return;                          // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n       }\n   }\n   "}, {"sha": "9428d305c87319547ed2864aae42ac4279b0b73e", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyBranchSame.after.mir", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyBranchSame.after.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -1,35 +1,35 @@\n // MIR for `try_identity` after SimplifyBranchSame\n \n fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n-    debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:5:17: 5:18\n-    let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:5:41: 5:57\n-    let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n-    let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-    let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n-    let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-    let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-    let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:7:8: 7:9\n+    debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:6:17: 6:18\n+    let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:6:41: 6:57\n+    let _2: u32;                         // in scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+    let mut _3: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+    let mut _4: std::result::Result<u32, i32>; // in scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+    let mut _5: isize;                   // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+    let _6: i32;                         // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+    let mut _7: !;                       // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+    let mut _8: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+    let mut _9: i32;                     // in scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+    let _10: u32;                        // in scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+    let mut _11: u32;                    // in scope 0 at $DIR/simplify_try.rs:8:8: 8:9\n     scope 1 {\n-        debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+        debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n     }\n     scope 2 {\n-        debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n+        debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n         scope 3 {\n             scope 7 {\n                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n             }\n             scope 8 {\n                 debug v => ((_0 as Err).0: i32); // in scope 8 at $SRC_DIR/core/src/result.rs:LL:COL\n-                let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:6:14: 6:15\n+                let mut _12: i32;        // in scope 8 at $DIR/simplify_try.rs:7:14: 7:15\n             }\n         }\n     }\n     scope 4 {\n-        debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n+        debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n         scope 5 {\n         }\n     }\n@@ -38,24 +38,24 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n     }\n \n     bb0: {\n-        StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:6:9: 6:10\n-        StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:15\n-        StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n-        _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:6:13: 6:14\n+        StorageLive(_2);                 // scope 0 at $DIR/simplify_try.rs:7:9: 7:10\n+        StorageLive(_3);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:15\n+        StorageLive(_4);                 // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+        _4 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n         _3 = move _4;                    // scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n-        StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-        _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n-        goto -> bb1;                     // scope 0 at $DIR/simplify_try.rs:6:14: 6:15\n+        StorageDead(_4);                 // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+        _5 = discriminant(_3);           // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n+        goto -> bb1;                     // scope 0 at $DIR/simplify_try.rs:7:14: 7:15\n     }\n \n     bb1: {\n-        _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-        StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:6:15: 6:16\n-        StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:8:1: 8:2\n-        goto -> bb2;                     // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n+        _0 = move _3;                    // scope 1 at $DIR/simplify_try.rs:8:5: 8:10\n+        StorageDead(_3);                 // scope 0 at $DIR/simplify_try.rs:7:15: 7:16\n+        StorageDead(_2);                 // scope 0 at $DIR/simplify_try.rs:9:1: 9:2\n+        goto -> bb2;                     // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n     }\n \n     bb2: {\n-        return;                          // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n+        return;                          // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n     }\n }"}, {"sha": "a25472f6a5e05c96224b9b5ac5b7bb9b9e446e37", "filename": "src/test/mir-opt/simplify_try.try_identity.SimplifyLocals.after.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_try.try_identity.SimplifyLocals.after.mir?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -1,13 +1,13 @@\n // MIR for `try_identity` after SimplifyLocals\n \n fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i32> {\n-    debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:5:17: 5:18\n-    let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:5:41: 5:57\n+    debug x => _1;                       // in scope 0 at $DIR/simplify_try.rs:6:17: 6:18\n+    let mut _0: std::result::Result<u32, i32>; // return place in scope 0 at $DIR/simplify_try.rs:6:41: 6:57\n     scope 1 {\n-        debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:6:9: 6:10\n+        debug y => ((_0 as Ok).0: u32);  // in scope 1 at $DIR/simplify_try.rs:7:9: 7:10\n     }\n     scope 2 {\n-        debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:6:14: 6:15\n+        debug err => ((_0 as Err).0: i32); // in scope 2 at $DIR/simplify_try.rs:7:14: 7:15\n         scope 3 {\n             scope 7 {\n                 debug t => ((_0 as Err).0: i32); // in scope 7 at $SRC_DIR/core/src/convert/mod.rs:LL:COL\n@@ -18,16 +18,16 @@ fn try_identity(_1: std::result::Result<u32, i32>) -> std::result::Result<u32, i\n         }\n     }\n     scope 4 {\n-        debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:6:13: 6:15\n+        debug val => ((_0 as Ok).0: u32); // in scope 4 at $DIR/simplify_try.rs:7:13: 7:15\n         scope 5 {\n         }\n     }\n     scope 6 {\n-        debug self => _1;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n+        debug self => _0;                // in scope 6 at $SRC_DIR/core/src/result.rs:LL:COL\n     }\n \n     bb0: {\n-        _0 = move _1;                    // scope 1 at $DIR/simplify_try.rs:7:5: 7:10\n-        return;                          // scope 0 at $DIR/simplify_try.rs:8:2: 8:2\n+        _0 = _1;                         // scope 0 at $DIR/simplify_try.rs:7:13: 7:14\n+        return;                          // scope 0 at $DIR/simplify_try.rs:9:2: 9:2\n     }\n }"}, {"sha": "c27a1f04532e719b1f251fcf4766c519cf8a3e67", "filename": "src/test/ui/dest-prop/skeptic-miscompile.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/255a4c58f5863ed41c2e68792799125c6c676575/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdest-prop%2Fskeptic-miscompile.rs?ref=255a4c58f5863ed41c2e68792799125c6c676575", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+// compile-flags: -Zmir-opt-level=2\n+\n+trait IterExt: Iterator {\n+    fn fold_ex<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next() {\n+            accum = f(accum, x);\n+        }\n+        accum\n+    }\n+}\n+\n+impl<T: Iterator> IterExt for T {}\n+\n+fn main() {\n+    let test = &[\"\\n\"];\n+    test.iter().fold_ex(String::new(), |_, b| b.to_string());\n+}"}]}