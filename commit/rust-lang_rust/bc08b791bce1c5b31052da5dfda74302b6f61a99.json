{"sha": "bc08b791bce1c5b31052da5dfda74302b6f61a99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMDhiNzkxYmNlMWM1YjMxMDUyZGE1ZGZkYTc0MzAyYjZmNjFhOTk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-22T21:43:18Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Fix bugs in evaluating WellFormed predicates\n\n- List the nestsed obligations in an order that works with the\n  single pass used by evaluation\n- Propagate recursion depth correctly", "tree": {"sha": "3b914ec159f4221ef06c76f3f74d5fd25fbdf00f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b914ec159f4221ef06c76f3f74d5fd25fbdf00f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc08b791bce1c5b31052da5dfda74302b6f61a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc08b791bce1c5b31052da5dfda74302b6f61a99", "html_url": "https://github.com/rust-lang/rust/commit/bc08b791bce1c5b31052da5dfda74302b6f61a99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc08b791bce1c5b31052da5dfda74302b6f61a99/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f52b2d88903036beb0533b04011064575b3abd36", "url": "https://api.github.com/repos/rust-lang/rust/commits/f52b2d88903036beb0533b04011064575b3abd36", "html_url": "https://github.com/rust-lang/rust/commit/f52b2d88903036beb0533b04011064575b3abd36"}], "stats": {"total": 159, "additions": 117, "deletions": 42}, "files": [{"sha": "289e0e0ba63ecb676f50f5ef28d5ad3fb3bd61ab", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -449,6 +449,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         self.selcx.infcx(),\n                         obligation.param_env,\n                         obligation.cause.body_id,\n+                        obligation.recursion_depth + 1,\n                         arg,\n                         obligation.cause.span,\n                     ) {"}, {"sha": "ced99b3eb641c895b00a32735bcb2b6f63ebbd57", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -139,9 +139,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     );\n                 });\n             // Require that the projection is well-formed.\n-            let self_ty = obligation.predicate.skip_binder().self_ty();\n-            obligations.push(Obligation::new(\n+            let self_ty = self.infcx.replace_bound_vars_with_placeholders(&obligation.self_ty());\n+            let self_ty = normalize_with_depth_to(\n+                self,\n+                obligation.param_env,\n                 obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n+                &self_ty,\n+                &mut obligations,\n+            );\n+            obligations.push(Obligation::with_depth(\n+                obligation.cause.clone(),\n+                obligation.recursion_depth + 1,\n                 obligation.param_env,\n                 ty::PredicateKind::WellFormed(self_ty.into()).to_predicate(self.tcx()),\n             ));\n@@ -333,9 +342,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // relying on projections in the impl-trait-ref.\n         //\n         // e.g., `impl<U: Tr, V: Iterator<Item=U>> Foo<<U as Tr>::T> for V`\n-        impl_obligations.append(&mut substs.obligations);\n+        substs.obligations.append(&mut impl_obligations);\n \n-        ImplSourceUserDefinedData { impl_def_id, substs: substs.value, nested: impl_obligations }\n+        ImplSourceUserDefinedData { impl_def_id, substs: substs.value, nested: substs.obligations }\n     }\n \n     fn confirm_object_candidate("}, {"sha": "0537e94cc1c21d9a4e871e382bf806c52ff80ef1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -343,7 +343,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(SelectionError::Overflow)\n             }\n             Err(e) => Err(e),\n-            Ok(candidate) => Ok(Some(candidate)),\n+            Ok(candidate) => {\n+                debug!(\"select: candidate = {:?}\", candidate);\n+                Ok(Some(candidate))\n+            }\n         }\n     }\n \n@@ -413,9 +416,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         predicates: I,\n     ) -> Result<EvaluationResult, OverflowError>\n     where\n-        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n+        I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n         let mut result = EvaluatedToOk;\n+        debug!(\"evaluate_predicates_recursively({:?})\", predicates);\n         for obligation in predicates {\n             let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n             debug!(\"evaluate_predicate_recursively({:?}) = {:?}\", obligation, eval);\n@@ -436,7 +440,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         debug!(\n-            \"evaluate_predicate_recursively(previous_stack={:?}, obligation={:?})\",\n+            \"evaluate_predicate_recursively(obligation={:?}, previous_stack={:?})\",\n             previous_stack.head(),\n             obligation\n         );\n@@ -479,15 +483,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     self.infcx,\n                     obligation.param_env,\n                     obligation.cause.body_id,\n+                    obligation.recursion_depth + 1,\n                     arg,\n                     obligation.cause.span,\n                 ) {\n                     Some(mut obligations) => {\n                         self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n-                        self.evaluate_predicates_recursively(\n-                            previous_stack,\n-                            obligations.into_iter(),\n-                        )\n+                        self.evaluate_predicates_recursively(previous_stack, obligations)\n                     }\n                     None => Ok(EvaluatedToAmbig),\n                 },\n@@ -511,10 +513,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n                             self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n-                            let result = self.evaluate_predicates_recursively(\n-                                previous_stack,\n-                                subobligations.into_iter(),\n-                            );\n+                            let result = self\n+                                .evaluate_predicates_recursively(previous_stack, subobligations);\n                             if let Some(key) =\n                                 ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                             {\n@@ -879,10 +879,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = self.evaluation_probe(|this| {\n             let candidate = (*candidate).clone();\n             match this.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => this.evaluate_predicates_recursively(\n-                    stack.list(),\n-                    selection.nested_obligations().into_iter(),\n-                ),\n+                Ok(selection) => {\n+                    debug!(\"evaluate_candidate: selection = {:?}\", selection);\n+                    this.evaluate_predicates_recursively(\n+                        stack.list(),\n+                        selection.nested_obligations().into_iter(),\n+                    )\n+                }\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n         })?;\n@@ -1231,9 +1234,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n-                Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.into_iter())\n-                }\n+                Ok(obligations) => this.evaluate_predicates_recursively(stack.list(), obligations),\n                 Err(()) => Ok(EvaluatedToErr),\n             }\n         })"}, {"sha": "0b4edf5e71b18d0efa8fbd5160c6979f6d7caec7", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -20,6 +20,7 @@ pub fn obligations<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n+    recursion_depth: usize,\n     arg: GenericArg<'tcx>,\n     span: Span,\n ) -> Option<Vec<traits::PredicateObligation<'tcx>>> {\n@@ -59,7 +60,8 @@ pub fn obligations<'a, 'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n@@ -80,7 +82,8 @@ pub fn trait_obligations<'a, 'tcx>(\n     span: Span,\n     item: Option<&'tcx hir::Item<'tcx>>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item };\n+    let mut wf =\n+        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth: 0, item };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n@@ -92,7 +95,15 @@ pub fn predicate_obligations<'a, 'tcx>(\n     predicate: ty::Predicate<'tcx>,\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n-    let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n+    let mut wf = WfPredicates {\n+        infcx,\n+        param_env,\n+        body_id,\n+        span,\n+        out: vec![],\n+        recursion_depth: 0,\n+        item: None,\n+    };\n \n     // It's ok to skip the binder here because wf code is prepared for it\n     match predicate.skip_binders() {\n@@ -142,6 +153,7 @@ struct WfPredicates<'a, 'tcx> {\n     body_id: hir::HirId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n+    recursion_depth: usize,\n     item: Option<&'tcx hir::Item<'tcx>>,\n }\n \n@@ -249,19 +261,19 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         for mut obligation in self.out {\n             assert!(!obligation.has_escaping_bound_vars());\n             let mut selcx = traits::SelectionContext::new(infcx);\n-            let i = obligations.len();\n             // Don't normalize the whole obligation, the param env is either\n             // already normalized, or we're currently normalizing the\n             // param_env. Either way we should only normalize the predicate.\n-            let normalized_predicate = traits::normalize_to(\n+            let normalized_predicate = traits::project::normalize_with_depth_to(\n                 &mut selcx,\n                 param_env,\n                 cause.clone(),\n+                self.recursion_depth,\n                 &obligation.predicate,\n                 &mut obligations,\n             );\n             obligation.predicate = normalized_predicate;\n-            obligations.insert(i, obligation);\n+            obligations.push(obligation);\n         }\n         obligations\n     }\n@@ -274,6 +286,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         debug!(\"compute_trait_ref obligations {:?}\", obligations);\n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n \n         let item = self.item;\n \n@@ -295,7 +308,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 &obligation.predicate,\n                 tcx.associated_items(trait_ref.def_id).in_definition_order(),\n             );\n-            traits::Obligation::new(cause, param_env, obligation.predicate)\n+            traits::Obligation::with_depth(cause, depth, param_env, obligation.predicate)\n         };\n \n         if let Elaborate::All = elaborate {\n@@ -324,8 +337,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             new_cause.make_mut().span = self_ty.span;\n                         }\n                     }\n-                    traits::Obligation::new(\n+                    traits::Obligation::with_depth(\n                         new_cause,\n+                        depth,\n                         param_env,\n                         ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n                     )\n@@ -363,6 +377,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         let tcx = self.tcx();\n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n \n         self.out.extend(\n             data.substs\n@@ -372,8 +387,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 })\n                 .filter(|arg| !arg.has_escaping_bound_vars())\n                 .map(|arg| {\n-                    traits::Obligation::new(\n+                    traits::Obligation::with_depth(\n                         cause.clone(),\n+                        depth,\n                         param_env,\n                         ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n                     )\n@@ -388,8 +404,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 def_id: self.infcx.tcx.require_lang_item(LangItem::Sized, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n-            self.out.push(traits::Obligation::new(\n+            self.out.push(traits::Obligation::with_depth(\n                 cause,\n+                self.recursion_depth,\n                 self.param_env,\n                 trait_ref.without_const().to_predicate(self.infcx.tcx),\n             ));\n@@ -400,6 +417,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn compute(&mut self, arg: GenericArg<'tcx>) {\n         let mut walker = arg.walk();\n         let param_env = self.param_env;\n+        let depth = self.recursion_depth;\n         while let Some(arg) = walker.next() {\n             let ty = match arg.unpack() {\n                 GenericArgKind::Type(ty) => ty,\n@@ -419,8 +437,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             let predicate = ty::PredicateAtom::ConstEvaluatable(def, substs)\n                                 .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n-                            self.out.push(traits::Obligation::new(\n+                            self.out.push(traits::Obligation::with_depth(\n                                 cause,\n+                                self.recursion_depth,\n                                 self.param_env,\n                                 predicate,\n                             ));\n@@ -435,8 +454,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                     val: ty::ConstKind::Infer(resolved),\n                                     ..*constant\n                                 });\n-                                self.out.push(traits::Obligation::new(\n+                                self.out.push(traits::Obligation::with_depth(\n                                     cause,\n+                                    self.recursion_depth,\n                                     self.param_env,\n                                     ty::PredicateAtom::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n@@ -521,8 +541,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n-                        self.out.push(traits::Obligation::new(\n+                        self.out.push(traits::Obligation::with_depth(\n                             cause,\n+                            depth,\n                             param_env,\n                             ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(rty, r))\n                                 .to_predicate(self.tcx()),\n@@ -612,8 +633,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         let component_traits = data.auto_traits().chain(data.principal_def_id());\n                         let tcx = self.tcx();\n                         self.out.extend(component_traits.map(|did| {\n-                            traits::Obligation::new(\n+                            traits::Obligation::with_depth(\n                                 cause.clone(),\n+                                depth,\n                                 param_env,\n                                 ty::PredicateAtom::ObjectSafe(did).to_predicate(tcx),\n                             )\n@@ -638,8 +660,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     if let ty::Infer(ty::TyVar(_)) = ty.kind() {\n                         // Not yet resolved, but we've made progress.\n                         let cause = self.cause(traits::MiscObligation);\n-                        self.out.push(traits::Obligation::new(\n+                        self.out.push(traits::Obligation::with_depth(\n                             cause,\n+                            self.recursion_depth,\n                             param_env,\n                             ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n@@ -676,7 +699,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             .zip(origins.into_iter().rev())\n             .map(|((pred, span), origin_def_id)| {\n                 let cause = self.cause(traits::BindingObligation(origin_def_id, span));\n-                traits::Obligation::new(cause, self.param_env, pred)\n+                traits::Obligation::with_depth(cause, self.recursion_depth, self.param_env, pred)\n             })\n             .filter(|pred| !pred.has_escaping_bound_vars())\n             .collect()\n@@ -729,8 +752,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n                 let outlives =\n                     ty::Binder::dummy(ty::OutlivesPredicate(explicit_bound, implicit_bound));\n-                self.out.push(traits::Obligation::new(\n+                self.out.push(traits::Obligation::with_depth(\n                     cause,\n+                    self.recursion_depth,\n                     self.param_env,\n                     outlives.to_predicate(self.infcx.tcx),\n                 ));"}, {"sha": "bc5c07fce045c385f7c8e839f7714e456dab798c", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -61,8 +61,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // than the ultimate set. (Note: normally there won't be\n         // unresolved inference variables here anyway, but there might be\n         // during typeck under some circumstances.)\n-        let obligations =\n-            wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, arg, DUMMY_SP).unwrap_or(vec![]);\n+        let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n+            .unwrap_or(vec![]);\n \n         // N.B., all of these predicates *ought* to be easily proven\n         // true. In fact, their correctness is (mostly) implied by"}, {"sha": "cfd75db61f7cdd5610aab8469f2ad3f56e61df74", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -561,7 +561,7 @@ fn check_opaque_meets_bounds<'tcx>(\n         let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n         let (_, opaque_type_map) = inh.register_infer_ok_obligations(\n-            infcx.instantiate_opaque_types(def_id.to_def_id(), hir_id, param_env, &opaque_ty, span),\n+            infcx.instantiate_opaque_types(def_id, hir_id, param_env, &opaque_ty, span),\n         );\n \n         for (def_id, opaque_defn) in opaque_type_map {"}, {"sha": "4cf3efcf5136d254e834414e846d59ea15aa4ba5", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -337,6 +337,7 @@ fn check_predicates<'tcx>(\n             infcx,\n             tcx.param_env(impl1_def_id),\n             tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n+            0,\n             arg,\n             span,\n         ) {"}, {"sha": "c7d6bb870962a27b0998a92610cb52d6485d52dc", "filename": "src/test/ui/impl-trait/wf-eval-order.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bc08b791bce1c5b31052da5dfda74302b6f61a99/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc08b791bce1c5b31052da5dfda74302b6f61a99/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwf-eval-order.rs?ref=bc08b791bce1c5b31052da5dfda74302b6f61a99", "patch": "@@ -0,0 +1,39 @@\n+// Check that we handle evaluating `wf` predicates correctly.\n+\n+// check-pass\n+\n+struct X<T: B>(T)\n+where\n+    T::V: Clone;\n+\n+fn hide<T>(t: T) -> impl Sized {\n+    t\n+}\n+\n+trait A {\n+    type U;\n+}\n+\n+impl<T> A for T {\n+    type U = T;\n+}\n+\n+trait B {\n+    type V;\n+}\n+\n+impl<S: A<U = T>, T> B for S {\n+    type V = T;\n+}\n+\n+fn main() {\n+    // Evaluating `typeof(x): Sized` requires\n+    //\n+    // - `wf(typeof(x))` because we use a projection candidate.\n+    // - `<i32 as B>::V: Clone` because that's a bound on the trait.\n+    // - `<i32 as B>::V` normalizes to `_#1` where `<i32 as A>::U == _#1`\n+    //\n+    // This all works if we evaluate `<i32 as A>::U == _#1` before\n+    // `<i32 as B>::V`, but we previously had the opposite order.\n+    let x = hide(X(0));\n+}"}]}