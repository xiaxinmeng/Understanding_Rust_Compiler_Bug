{"sha": "17e96879d8ea81ff9b4194ad6529df1a5784a70c", "node_id": "C_kwDOAAsO6NoAKDE3ZTk2ODc5ZDhlYTgxZmY5YjQxOTRhZDY1MjlkZjFhNTc4NGE3MGM", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-03T04:53:20Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-07-18T16:59:14Z"}, "message": "proc_macro: use fxhash within the proc_macro crate\n\nUnfortunately, as it is difficult to depend on crates from within proc_macro,\nthis is done by vendoring a copy of the hasher as a module rather than\ndepending on the rustc_hash crate.\n\nThis probably doesn't have a substantial impact up-front, however will be more\nrelevant once symbols are interned within the proc_macro client.", "tree": {"sha": "7eeb0e3f8bde3fadd82c305a38db7239f3cbad42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eeb0e3f8bde3fadd82c305a38db7239f3cbad42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17e96879d8ea81ff9b4194ad6529df1a5784a70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17e96879d8ea81ff9b4194ad6529df1a5784a70c", "html_url": "https://github.com/rust-lang/rust/commit/17e96879d8ea81ff9b4194ad6529df1a5784a70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17e96879d8ea81ff9b4194ad6529df1a5784a70c/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "144227dae949fb98896a2ba077d8fe7f36c3238e", "url": "https://api.github.com/repos/rust-lang/rust/commits/144227dae949fb98896a2ba077d8fe7f36c3238e", "html_url": "https://github.com/rust-lang/rust/commit/144227dae949fb98896a2ba077d8fe7f36c3238e"}], "stats": {"total": 145, "additions": 125, "deletions": 20}, "files": [{"sha": "4b1e412e24b709e2ed77e6dd1ccebb3be2a11a1d", "filename": "library/proc_macro/src/bridge/fxhash.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Ffxhash.rs?ref=17e96879d8ea81ff9b4194ad6529df1a5784a70c", "patch": "@@ -0,0 +1,117 @@\n+//! This is a copy of the `rustc_hash` crate, adapted to work as a module.\n+//!\n+//! If in the future it becomes more reasonable to add dependencies to\n+//! `proc_macro`, this module should be removed and replaced with a dependency\n+//! on the `rustc_hash` crate.\n+\n+use std::collections::HashMap;\n+use std::convert::TryInto;\n+use std::default::Default;\n+use std::hash::BuildHasherDefault;\n+use std::hash::Hasher;\n+use std::mem::size_of;\n+use std::ops::BitXor;\n+\n+/// Type alias for a hashmap using the `fx` hash algorithm.\n+pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n+\n+/// A speedy hash algorithm for use within rustc. The hashmap in liballoc\n+/// by default uses SipHash which isn't quite as speedy as we want. In the\n+/// compiler we're not really worried about DOS attempts, so we use a fast\n+/// non-cryptographic hash.\n+///\n+/// This is the same as the algorithm used by Firefox -- which is a homespun\n+/// one not based on any widely-known algorithm -- though modified to produce\n+/// 64-bit hash values instead of 32-bit hash values. It consistently\n+/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n+/// similar or slightly worse than FNV, but the speed of the hash function\n+/// itself is much higher because it works on up to 8 bytes at a time.\n+pub struct FxHasher {\n+    hash: usize,\n+}\n+\n+#[cfg(target_pointer_width = \"32\")]\n+const K: usize = 0x9e3779b9;\n+#[cfg(target_pointer_width = \"64\")]\n+const K: usize = 0x517cc1b727220a95;\n+\n+impl Default for FxHasher {\n+    #[inline]\n+    fn default() -> FxHasher {\n+        FxHasher { hash: 0 }\n+    }\n+}\n+\n+impl FxHasher {\n+    #[inline]\n+    fn add_to_hash(&mut self, i: usize) {\n+        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n+    }\n+}\n+\n+impl Hasher for FxHasher {\n+    #[inline]\n+    fn write(&mut self, mut bytes: &[u8]) {\n+        #[cfg(target_pointer_width = \"32\")]\n+        let read_usize = |bytes: &[u8]| u32::from_ne_bytes(bytes[..4].try_into().unwrap());\n+        #[cfg(target_pointer_width = \"64\")]\n+        let read_usize = |bytes: &[u8]| u64::from_ne_bytes(bytes[..8].try_into().unwrap());\n+\n+        let mut hash = FxHasher { hash: self.hash };\n+        assert!(size_of::<usize>() <= 8);\n+        while bytes.len() >= size_of::<usize>() {\n+            hash.add_to_hash(read_usize(bytes) as usize);\n+            bytes = &bytes[size_of::<usize>()..];\n+        }\n+        if (size_of::<usize>() > 4) && (bytes.len() >= 4) {\n+            hash.add_to_hash(u32::from_ne_bytes(bytes[..4].try_into().unwrap()) as usize);\n+            bytes = &bytes[4..];\n+        }\n+        if (size_of::<usize>() > 2) && bytes.len() >= 2 {\n+            hash.add_to_hash(u16::from_ne_bytes(bytes[..2].try_into().unwrap()) as usize);\n+            bytes = &bytes[2..];\n+        }\n+        if (size_of::<usize>() > 1) && bytes.len() >= 1 {\n+            hash.add_to_hash(bytes[0] as usize);\n+        }\n+        self.hash = hash.hash;\n+    }\n+\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+        self.add_to_hash((i >> 32) as usize);\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.add_to_hash(i as usize);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.add_to_hash(i);\n+    }\n+\n+    #[inline]\n+    fn finish(&self) -> u64 {\n+        self.hash as u64\n+    }\n+}"}, {"sha": "00954107b7769c8af31d6d2c3e5f3a938716926c", "filename": "library/proc_macro/src/bridge/handle.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fhandle.rs?ref=17e96879d8ea81ff9b4194ad6529df1a5784a70c", "patch": "@@ -1,11 +1,13 @@\n //! Server-side handles and storage for per-handle data.\n \n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::{BuildHasher, Hash};\n+use std::collections::BTreeMap;\n+use std::hash::Hash;\n use std::num::NonZeroU32;\n use std::ops::{Index, IndexMut};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n+use super::fxhash::FxHashMap;\n+\n pub(super) type Handle = NonZeroU32;\n \n /// A store that associates values of type `T` with numeric handles. A value can\n@@ -51,31 +53,15 @@ impl<T> IndexMut<Handle> for OwnedStore<T> {\n     }\n }\n \n-// HACK(eddyb) deterministic `std::collections::hash_map::RandomState` replacement\n-// that doesn't require adding any dependencies to `proc_macro` (like `rustc-hash`).\n-#[derive(Clone)]\n-struct NonRandomState;\n-\n-impl BuildHasher for NonRandomState {\n-    type Hasher = std::collections::hash_map::DefaultHasher;\n-    #[inline]\n-    fn build_hasher(&self) -> Self::Hasher {\n-        Self::Hasher::new()\n-    }\n-}\n-\n /// Like `OwnedStore`, but avoids storing any value more than once.\n pub(super) struct InternedStore<T: 'static> {\n     owned: OwnedStore<T>,\n-    interner: HashMap<T, Handle, NonRandomState>,\n+    interner: FxHashMap<T, Handle>,\n }\n \n impl<T: Copy + Eq + Hash> InternedStore<T> {\n     pub(super) fn new(counter: &'static AtomicUsize) -> Self {\n-        InternedStore {\n-            owned: OwnedStore::new(counter),\n-            interner: HashMap::with_hasher(NonRandomState),\n-        }\n+        InternedStore { owned: OwnedStore::new(counter), interner: FxHashMap::default() }\n     }\n \n     pub(super) fn alloc(&mut self, x: T) -> Handle {"}, {"sha": "c97d1099ecc2897d070c32192575b65f35832ada", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e96879d8ea81ff9b4194ad6529df1a5784a70c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=17e96879d8ea81ff9b4194ad6529df1a5784a70c", "patch": "@@ -177,6 +177,8 @@ pub mod client;\n #[allow(unsafe_code)]\n mod closure;\n #[forbid(unsafe_code)]\n+mod fxhash;\n+#[forbid(unsafe_code)]\n mod handle;\n #[macro_use]\n #[forbid(unsafe_code)]"}]}