{"sha": "6d965cc2c99787a949d38abf225412fe502d3ed8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTY1Y2MyYzk5Nzg3YTk0OWQzOGFiZjIyNTQxMmZlNTAyZDNlZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T12:02:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-04T12:02:56Z"}, "message": "auto merge of #19167 : japaric/rust/rhs-cmp, r=aturon\n\nComparison traits have gained an `Rhs` input parameter that defaults to `Self`. And now the comparison operators can be overloaded to work between different types. In particular, this PR allows the following operations (and their commutative versions):\r\n\r\n- `&str` == `String` == `CowString`\r\n- `&[A]` == `&mut [B]` == `Vec<C>` == `CowVec<D>` == `[E, ..N]` (for `N` up to 32)\r\n- `&mut A` == `&B` (for `Sized` `A` and `B`)\r\n\r\nWhere `A`, `B`, `C`, `D`, `E` may be different types that implement `PartialEq`. For example, these comparisons are now valid: `string == \"foo\"`, and `vec_of_strings == [\"Hello\", \"world\"]`.\r\n\r\n[breaking-change]s\r\n\r\nSince the `==` may now work on different types, operations that relied on the old \"same type restriction\" to drive type inference, will need to be type annotated. These are the most common fallout cases:\r\n\r\n- `some_vec == some_iter.collect()`: `collect` needs to be type annotated: `collect::<Vec<_>>()`\r\n- `slice == &[a, b, c]`: RHS doesn't get coerced to an slice, use an array instead `[a, b, c]`\r\n- `lhs == []`: Change expression to `lhs.is_empty()`\r\n- `lhs == some_generic_function()`: Type annotate the RHS as necessary\r\n\r\ncc #19148\r\n\r\nr? @aturon", "tree": {"sha": "d8702f66ba3753eba622b978b91974a0bc913cee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8702f66ba3753eba622b978b91974a0bc913cee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d965cc2c99787a949d38abf225412fe502d3ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d965cc2c99787a949d38abf225412fe502d3ed8", "html_url": "https://github.com/rust-lang/rust/commit/6d965cc2c99787a949d38abf225412fe502d3ed8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d965cc2c99787a949d38abf225412fe502d3ed8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e", "html_url": "https://github.com/rust-lang/rust/commit/53e8bd641a4d3495fb4ffb12e732390d9b4ff93e"}, {"sha": "5cfac942018b3f8e0b384c49d6564fcff25634e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfac942018b3f8e0b384c49d6564fcff25634e6", "html_url": "https://github.com/rust-lang/rust/commit/5cfac942018b3f8e0b384c49d6564fcff25634e6"}], "stats": {"total": 643, "additions": 421, "deletions": 222}, "files": [{"sha": "39cdf0c456413d48f81393993d3168591c525e64", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -945,15 +945,15 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.rotate_backward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect());\n+        assert_eq!(v.iter().collect::<Vec<&int>>(), m.iter().collect::<Vec<_>>());\n         m.rotate_forward(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.pop_front(); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect());\n+        assert_eq!(vec![3i,9,5,1,2], m.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]"}, {"sha": "2cbde0168a2e80444c13641f2557a26e0cc7842d", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -397,23 +397,23 @@ mod test {\n     fn test_iterator() {\n         let mut e1: EnumSet<Foo> = EnumSet::new();\n \n-        let elems: Vec<Foo> = e1.iter().collect();\n+        let elems: ::vec::Vec<Foo> = e1.iter().collect();\n         assert!(elems.is_empty())\n \n         e1.insert(A);\n-        let elems = e1.iter().collect();\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n         assert_eq!(vec![A], elems)\n \n         e1.insert(C);\n-        let elems = e1.iter().collect();\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n         e1.insert(C);\n-        let elems = e1.iter().collect();\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n         assert_eq!(vec![A,C], elems)\n \n         e1.insert(B);\n-        let elems = e1.iter().collect();\n+        let elems: ::vec::Vec<_> = e1.iter().collect();\n         assert_eq!(vec![A,B,C], elems)\n     }\n \n@@ -431,35 +431,35 @@ mod test {\n         e2.insert(C);\n \n         let e_union = e1 | e2;\n-        let elems = e_union.iter().collect();\n+        let elems: ::vec::Vec<_> = e_union.iter().collect();\n         assert_eq!(vec![A,B,C], elems)\n \n         let e_intersection = e1 & e2;\n-        let elems = e_intersection.iter().collect();\n+        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n         assert_eq!(vec![C], elems)\n \n         // Another way to express intersection\n         let e_intersection = e1 - (e1 - e2);\n-        let elems = e_intersection.iter().collect();\n+        let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n         assert_eq!(vec![C], elems)\n \n         let e_subtract = e1 - e2;\n-        let elems = e_subtract.iter().collect();\n+        let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n         assert_eq!(vec![A], elems)\n \n         // Bitwise XOR of two sets, aka symmetric difference\n         let e_symmetric_diff = e1 ^ e2;\n-        let elems = e_symmetric_diff.iter().collect();\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n         assert_eq!(vec![A,B], elems)\n \n         // Another way to express symmetric difference\n         let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n-        let elems = e_symmetric_diff.iter().collect();\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n         assert_eq!(vec![A,B], elems)\n \n         // Yet another way to express symmetric difference\n         let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n-        let elems = e_symmetric_diff.iter().collect();\n+        let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n         assert_eq!(vec![A,B], elems)\n     }\n "}, {"sha": "ad0a5e76176464fdcd2611adc612d7e284d76b82", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -563,6 +563,7 @@ impl<'a> Ord for MaybeOwned<'a> {\n     }\n }\n \n+#[allow(deprecated)]\n #[deprecated = \"use std::str::CowString\"]\n impl<'a, S: Str> Equiv<S> for MaybeOwned<'a> {\n     #[inline]"}, {"sha": "fbb0bb5c4ce8673cf5fa71d3d34914a65d2ce024", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -30,7 +30,7 @@ use str::{CharRange, CowString, FromStr, StrAllocating, Owned};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n-#[deriving(Clone, PartialEq, PartialOrd, Eq, Ord)]\n+#[deriving(Clone, PartialOrd, Eq, Ord)]\n #[stable]\n pub struct String {\n     vec: Vec<u8>,\n@@ -738,6 +738,49 @@ impl Extend<char> for String {\n     }\n }\n \n+impl PartialEq for String {\n+    #[inline]\n+    fn eq(&self, other: &String) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &String) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs: ty) => {\n+        impl<'a> PartialEq<$rhs> for $lhs {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a> PartialEq<$lhs> for $rhs {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+    }\n+}\n+\n+impl_eq!(String, &'a str)\n+impl_eq!(CowString<'a>, String)\n+\n+impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n+    #[inline]\n+    fn eq(&self, other: &&'b str) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &&'b str) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n+    #[inline]\n+    fn eq(&self, other: &CowString<'a>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n #[experimental = \"waiting on Str stabilization\"]\n impl Str for String {\n     #[inline]\n@@ -779,7 +822,8 @@ impl<H: hash::Writer> hash::Hash<H> for String {\n     }\n }\n \n-#[experimental = \"waiting on Equiv stabilization\"]\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<'a, S: Str> Equiv<S> for String {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n@@ -967,10 +1011,12 @@ mod tests {\n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        assert_eq!(String::from_utf8_lossy(xs), \"hello\".into_cow());\n+        let ys: str::CowString = \"hello\".into_cow();\n+        assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(String::from_utf8_lossy(xs), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow());\n+        let ys: str::CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+        assert_eq!(String::from_utf8_lossy(xs), ys);\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),"}, {"sha": "2396cf8cec67ce20d235031f3a44e8888728b2c7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -535,14 +535,69 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on PartialEq stability\"]\n-impl<T: PartialEq> PartialEq for Vec<T> {\n+impl<A, B> PartialEq<Vec<B>> for Vec<A> where A: PartialEq<B> {\n     #[inline]\n-    fn eq(&self, other: &Vec<T>) -> bool {\n-        self.as_slice() == other.as_slice()\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq {\n+    ($lhs:ty, $rhs:ty) => {\n+        impl<'b, A, B> PartialEq<$rhs> for $lhs where A: PartialEq<B> {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'b, A, B> PartialEq<$lhs> for $rhs where B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$lhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n     }\n }\n \n+impl_eq!(Vec<A>, &'b [B])\n+impl_eq!(Vec<A>, &'b mut [B])\n+\n+impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+    #[inline]\n+    fn eq(&self, other: &Vec<B>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &Vec<B>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+impl<'a, A, B> PartialEq<CowVec<'a, A>> for Vec<B> where A: Clone, B: PartialEq<A> {\n+    #[inline]\n+    fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+    #[inline]\n+    fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+}\n+\n+macro_rules! impl_eq_for_cowvec {\n+    ($rhs:ty) => {\n+        impl<'a, 'b, A, B> PartialEq<$rhs> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n+            #[inline]\n+            fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &$rhs) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+\n+        impl<'a, 'b, A, B> PartialEq<CowVec<'a, A>> for $rhs where A: Clone, B: PartialEq<A> {\n+            #[inline]\n+            fn eq(&self, other: &CowVec<'a, A>) -> bool { PartialEq::eq(&**self, &**other) }\n+            #[inline]\n+            fn ne(&self, other: &CowVec<'a, A>) -> bool { PartialEq::ne(&**self, &**other) }\n+        }\n+    }\n+}\n+\n+impl_eq_for_cowvec!(&'b [B])\n+impl_eq_for_cowvec!(&'b mut [B])\n+\n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n@@ -554,7 +609,8 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n #[unstable = \"waiting on Eq stability\"]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[experimental]\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for Vec<T> {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n@@ -1813,27 +1869,27 @@ mod tests {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_from_mut(2);\n-            assert!(slice == &mut [3, 4, 5]);\n+            assert!(slice == [3, 4, 5]);\n             for p in slice.iter_mut() {\n                 *p += 2;\n             }\n         }\n \n-        assert!(values.as_slice() == &[1, 2, 5, 6, 7]);\n+        assert!(values.as_slice() == [1, 2, 5, 6, 7]);\n     }\n \n     #[test]\n     fn test_slice_to_mut() {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_to_mut(2);\n-            assert!(slice == &mut [1, 2]);\n+            assert!(slice == [1, 2]);\n             for p in slice.iter_mut() {\n                 *p += 1;\n             }\n         }\n \n-        assert!(values.as_slice() == &[2, 3, 3, 4, 5]);\n+        assert!(values.as_slice() == [2, 3, 3, 4, 5]);\n     }\n \n     #[test]"}, {"sha": "ffaf35414ea0c41d0b3453510b8641da8fee479e", "filename": "src/libcore/array.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -18,6 +18,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use kinds::Copy;\n+use ops::Deref;\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -39,17 +40,37 @@ macro_rules! array_impls {\n             }\n \n             #[unstable = \"waiting for PartialEq to stabilize\"]\n-            impl<T:PartialEq> PartialEq for [T, ..$N] {\n+            impl<A, B> PartialEq<[B, ..$N]> for [A, ..$N] where A: PartialEq<B> {\n                 #[inline]\n-                fn eq(&self, other: &[T, ..$N]) -> bool {\n+                fn eq(&self, other: &[B, ..$N]) -> bool {\n                     self[] == other[]\n                 }\n                 #[inline]\n-                fn ne(&self, other: &[T, ..$N]) -> bool {\n+                fn ne(&self, other: &[B, ..$N]) -> bool {\n                     self[] != other[]\n                 }\n             }\n \n+            impl<'a, A, B, Rhs> PartialEq<Rhs> for [A, ..$N] where\n+                A: PartialEq<B>,\n+                Rhs: Deref<[B]>,\n+            {\n+                #[inline(always)]\n+                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n+                #[inline(always)]\n+                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n+            }\n+\n+            impl<'a, A, B, Lhs> PartialEq<[B, ..$N]> for Lhs where\n+                A: PartialEq<B>,\n+                Lhs: Deref<[A]>\n+            {\n+                #[inline(always)]\n+                fn eq(&self, other: &[B, ..$N]) -> bool { PartialEq::eq(&**self, other[]) }\n+                #[inline(always)]\n+                fn ne(&self, other: &[B, ..$N]) -> bool { PartialEq::ne(&**self, other[]) }\n+            }\n+\n             #[unstable = \"waiting for Eq to stabilize\"]\n             impl<T:Eq> Eq for [T, ..$N] { }\n "}, {"sha": "b88fb914dd8b03a0bf915acf96e2b63da111a745", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -196,9 +196,12 @@ impl<'a, T, Sized? B> Ord for Cow<'a, T, B> where B: Ord + ToOwned<T> {\n     }\n }\n \n-impl<'a, T, Sized? B> PartialEq for Cow<'a, T, B> where B: PartialEq + ToOwned<T> {\n+impl<'a, 'b, T, U, Sized? B, Sized? C> PartialEq<Cow<'b, U, C>> for Cow<'a, T, B> where\n+    B: PartialEq<C> + ToOwned<T>,\n+    C: ToOwned<U>,\n+{\n     #[inline]\n-    fn eq(&self, other: &Cow<'a, T, B>) -> bool {\n+    fn eq(&self, other: &Cow<'b, U, C>) -> bool {\n         PartialEq::eq(&**self, &**other)\n     }\n }"}, {"sha": "df19256471ede6db1caffc05207901bdc2955564", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -61,13 +61,13 @@ use option::{Option, Some, None};\n /// `Eq`.\n #[lang=\"eq\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait PartialEq for Sized? {\n+pub trait PartialEq<Sized? Rhs = Self> for Sized? {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n-    fn eq(&self, other: &Self) -> bool;\n+    fn eq(&self, other: &Rhs) -> bool;\n \n     /// This method tests for `!=`.\n     #[inline]\n-    fn ne(&self, other: &Self) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Rhs) -> bool { !self.eq(other) }\n }\n \n /// Trait for equality comparisons which are [equivalence relations](\n@@ -80,7 +80,7 @@ pub trait PartialEq for Sized? {\n /// - symmetric: `a == b` implies `b == a`; and\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n #[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Eq for Sized?: PartialEq {\n+pub trait Eq<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n     // itself, the current deriving infrastructure means doing this\n@@ -150,7 +150,7 @@ impl Ordering {\n /// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for\n ///   both `==` and `>`.\n #[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait Ord for Sized?: Eq + PartialOrd {\n+pub trait Ord<Sized? Rhs = Self> for Sized?: Eq<Rhs> + PartialOrd<Rhs> {\n     /// This method returns an ordering between `self` and `other` values.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching\n@@ -161,7 +161,7 @@ pub trait Ord for Sized?: Eq + PartialOrd {\n     /// assert_eq!(10u.cmp(&5),  Greater);  // because 10 > 5\n     /// assert_eq!( 5u.cmp(&5),  Equal);    // because 5 == 5\n     /// ```\n-    fn cmp(&self, other: &Self) -> Ordering;\n+    fn cmp(&self, other: &Rhs) -> Ordering;\n }\n \n #[unstable = \"Trait is unstable.\"]\n@@ -194,14 +194,14 @@ impl PartialOrd for Ordering {\n /// 5.11).\n #[lang=\"ord\"]\n #[unstable = \"Definition may change slightly after trait reform\"]\n-pub trait PartialOrd for Sized?: PartialEq {\n+pub trait PartialOrd<Sized? Rhs = Self> for Sized?: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values\n     /// if one exists.\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering>;\n+    fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;\n \n     /// This method tests less than (for `self` and `other`) and is used by the `<` operator.\n     #[inline]\n-    fn lt(&self, other: &Self) -> bool {\n+    fn lt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) => true,\n             _ => false,\n@@ -210,7 +210,7 @@ pub trait PartialOrd for Sized?: PartialEq {\n \n     /// This method tests less than or equal to (`<=`).\n     #[inline]\n-    fn le(&self, other: &Self) -> bool {\n+    fn le(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Less) | Some(Equal) => true,\n             _ => false,\n@@ -219,7 +219,7 @@ pub trait PartialOrd for Sized?: PartialEq {\n \n     /// This method tests greater than (`>`).\n     #[inline]\n-    fn gt(&self, other: &Self) -> bool {\n+    fn gt(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) => true,\n             _ => false,\n@@ -228,7 +228,7 @@ pub trait PartialOrd for Sized?: PartialEq {\n \n     /// This method tests greater than or equal to (`>=`).\n     #[inline]\n-    fn ge(&self, other: &Self) -> bool {\n+    fn ge(&self, other: &Rhs) -> bool {\n         match self.partial_cmp(other) {\n             Some(Greater) | Some(Equal) => true,\n             _ => false,\n@@ -240,7 +240,7 @@ pub trait PartialOrd for Sized?: PartialEq {\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n /// values to look up entries in a container with `String` keys.\n-#[experimental = \"Better solutions may be discovered.\"]\n+#[deprecated = \"Use overloaded core::cmp::PartialEq\"]\n pub trait Equiv<Sized? T> for Sized? {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;\n@@ -400,11 +400,11 @@ mod impls {\n     // & pointers\n \n     #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: & &'b B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: & &'a T) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: & &'b B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a T {\n@@ -432,11 +432,11 @@ mod impls {\n     // &mut pointers\n \n     #[unstable = \"Trait is unstable.\"]\n-    impl<'a, Sized? T: PartialEq> PartialEq for &'a mut T {\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a mut A where A: PartialEq<B> {\n         #[inline]\n-        fn eq(&self, other: &&'a mut T) -> bool { PartialEq::eq(*self, *other) }\n+        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n         #[inline]\n-        fn ne(&self, other: &&'a mut T) -> bool { PartialEq::ne(*self, *other) }\n+        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: PartialOrd> PartialOrd for &'a mut T {\n@@ -460,4 +460,18 @@ mod impls {\n     }\n     #[unstable = \"Trait is unstable.\"]\n     impl<'a, Sized? T: Eq> Eq for &'a mut T {}\n+\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b mut B> for &'a A where A: PartialEq<B> {\n+        #[inline]\n+        fn eq(&self, other: &&'b mut B) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'b mut B) -> bool { PartialEq::ne(*self, *other) }\n+    }\n+\n+    impl<'a, 'b, Sized? A, Sized? B> PartialEq<&'b B> for &'a mut A where A: PartialEq<B> {\n+        #[inline]\n+        fn eq(&self, other: &&'b B) -> bool { PartialEq::eq(*self, *other) }\n+        #[inline]\n+        fn ne(&self, other: &&'b B) -> bool { PartialEq::ne(*self, *other) }\n+    }\n }"}, {"sha": "347777b587aa59d0af34892c48a91ed598abf979", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -226,7 +226,7 @@ extern \"rust-intrinsic\" {\n     /// use std::mem;\n     ///\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n-    /// assert!(v == &[76u8]);\n+    /// assert!(v == [76u8]);\n     /// ```\n     pub fn transmute<T,U>(e: T) -> U;\n "}, {"sha": "f9595f0663d57a5e94f4cc1ab72cc322ccda11d0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -2473,7 +2473,11 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n-    pub fn eq<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn eq<A, B, L, R>(mut a: L, mut b: R) -> bool where\n+        A: PartialEq<B>,\n+        L: Iterator<A>,\n+        R: Iterator<B>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2484,7 +2488,11 @@ pub mod order {\n     }\n \n     /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n-    pub fn ne<A: PartialEq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn ne<A, B, L, R>(mut a: L, mut b: R) -> bool where\n+        A: PartialEq<B>,\n+        L: Iterator<A>,\n+        R: Iterator<B>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,"}, {"sha": "5ad9462daf274cfe525ed29cd9c1912ea59db663", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -59,6 +59,7 @@\n #![allow(unknown_features)]\n #![feature(globs, intrinsics, lang_items, macro_rules, phase)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n+#![feature(default_type_params)]\n #![deny(missing_docs)]\n \n mod macros;"}, {"sha": "ef895a1d7fbcca26920c7858c65b430a11f7f1da", "filename": "src/libcore/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -274,9 +274,9 @@ impl<T> Option<T> {\n     /// let mut x = Some(\"Diamonds\");\n     /// {\n     ///     let v = x.as_mut_slice();\n-    ///     assert!(v == &mut [\"Diamonds\"]);\n+    ///     assert!(v == [\"Diamonds\"]);\n     ///     v[0] = \"Dirt\";\n-    ///     assert!(v == &mut [\"Dirt\"]);\n+    ///     assert!(v == [\"Dirt\"]);\n     /// }\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n@@ -554,7 +554,7 @@ impl<T> Option<T> {\n     ///\n     /// let x = None;\n     /// let v: Vec<&str> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![]);\n+    /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]"}, {"sha": "416bc4588b43ca03945b1fd1529d7ea36b2c04a5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -321,12 +321,16 @@ impl<T> PartialEq for *mut T {\n impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<T> Equiv<*mut T> for *const T {\n     fn equiv(&self, other: &*mut T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<T> Equiv<*const T> for *mut T {\n     fn equiv(&self, other: &*const T) -> bool {\n         self.to_uint() == other.to_uint()"}, {"sha": "07bb6f15c94ff83b0f0dc5b3fdbd30f0d2cd56ce", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -407,14 +407,14 @@ impl<T, E> Result<T, E> {\n     /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n-    ///     assert!(v == &mut [\"Gold\"]);\n+    ///     assert!(v == [\"Gold\"]);\n     ///     v[0] = \"Silver\";\n-    ///     assert!(v == &mut [\"Silver\"]);\n+    ///     assert!(v == [\"Silver\"]);\n     /// }\n     /// assert_eq!(x, Ok(\"Silver\"));\n     ///\n     /// let mut x: Result<&str, uint> = Err(45);\n-    /// assert!(x.as_mut_slice() == &mut []);\n+    /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]"}, {"sha": "85bd6adf8b8a60b60acc6b77603e8102769fa836", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -374,20 +374,20 @@ pub trait SlicePrelude<T> for Sized? {\n     /// // scoped to restrict the lifetime of the borrows\n     /// {\n     ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1i, 2, 3, 4, 5, 6]);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == &mut [1i, 2]);\n-    ///     assert!(right == &mut [3i, 4, 5, 6]);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n     /// }\n     ///\n     /// {\n     ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == &mut [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n     /// }\n     /// ```\n     #[unstable = \"waiting on final error conventions\"]\n@@ -1802,12 +1802,12 @@ pub mod bytes {\n //\n \n #[unstable = \"waiting for DST\"]\n-impl<T: PartialEq> PartialEq for [T] {\n-    fn eq(&self, other: &[T]) -> bool {\n+impl<A, B> PartialEq<[B]> for [A] where A: PartialEq<B> {\n+    fn eq(&self, other: &[B]) -> bool {\n         self.len() == other.len() &&\n             order::eq(self.iter(), other.iter())\n     }\n-    fn ne(&self, other: &[T]) -> bool {\n+    fn ne(&self, other: &[B]) -> bool {\n         self.len() != other.len() ||\n             order::ne(self.iter(), other.iter())\n     }\n@@ -1816,13 +1816,15 @@ impl<T: PartialEq> PartialEq for [T] {\n #[unstable = \"waiting for DST\"]\n impl<T: Eq> Eq for [T] {}\n \n-#[unstable = \"waiting for DST\"]\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n }\n \n-#[unstable = \"waiting for DST\"]\n+#[allow(deprecated)]\n+#[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n impl<'a,T:PartialEq, Sized? V: AsSlice<T>> Equiv<V> for &'a mut [T] {\n     #[inline]\n     fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }"}, {"sha": "4be628f0ac3b3c757ca4af02beea1d88dc12ade6", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -1248,6 +1248,8 @@ pub mod traits {\n         }\n     }\n \n+    #[allow(deprecated)]\n+    #[deprecated = \"Use overloaded `core::cmp::PartialEq`\"]\n     impl<S: Str> Equiv<S> for str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(self, other.as_slice()) }"}, {"sha": "75ddfd5413b31e2c10fc051c0a53c85ab88015c1", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -109,7 +109,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert!(vec![76u8] == transmute(\"L\".to_string()));\n+        assert!(vec![76u8] == transmute::<_, Vec<u8>>(\"L\".to_string()));\n     }\n }\n "}, {"sha": "05932db6632ffdcb7aa3d5119ff6ed8b4d2dcb56", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -96,6 +96,7 @@ impl<'a, T: Ord> Ord for MaybeOwnedVector<'a, T> {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a, T: PartialEq, Sized? V: AsSlice<T>> Equiv<V> for MaybeOwnedVector<'a, T> {\n     fn equiv(&self, other: &V) -> bool {\n         self.as_slice() == other.as_slice()"}, {"sha": "9a214d531d157b2e6235a172766e33aeaea8b7dc", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -1377,7 +1377,7 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| {\n             match a.node.value.node {\n-                ast::MetaNameValue(ref name, _) if name.equiv(&(\"doc\")) => true,\n+                ast::MetaNameValue(ref name, _) if *name == \"doc\" => true,\n                 _ => false\n             }\n         });"}, {"sha": "5a8d60fbecd6c3c71ac369bdeec91e6e74454a15", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -105,7 +105,7 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n }\n \n fn visit_crate(e: &Env, c: &ast::Crate) {\n-    for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n+    for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n         match a.value_str() {\n             Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n             None => { /* fallthrough */ }\n@@ -205,7 +205,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n             // First, add all of the custom link_args attributes\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name().equiv(&(\"link_args\")) {\n+                .filter_map(|at| if at.name() == \"link_args\" {\n                     Some(at)\n                 } else {\n                     None\n@@ -220,7 +220,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n \n             // Next, process all of the #[link(..)]-style arguments\n             let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name().equiv(&(\"link\")) {\n+                .filter_map(|at| if at.name() == \"link\" {\n                     Some(at)\n                 } else {\n                     None\n@@ -230,18 +230,18 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 match m.meta_item_list() {\n                     Some(items) => {\n                         let kind = items.iter().find(|k| {\n-                            k.name().equiv(&(\"kind\"))\n+                            k.name() == \"kind\"\n                         }).and_then(|a| a.value_str());\n                         let kind = match kind {\n                             Some(k) => {\n-                                if k.equiv(&(\"static\")) {\n+                                if k == \"static\" {\n                                     cstore::NativeStatic\n                                 } else if e.sess.target.target.options.is_like_osx\n-                                          && k.equiv(&(\"framework\")) {\n+                                          && k == \"framework\" {\n                                     cstore::NativeFramework\n-                                } else if k.equiv(&(\"framework\")) {\n+                                } else if k == \"framework\" {\n                                     cstore::NativeFramework\n-                                } else if k.equiv(&(\"dylib\")) {\n+                                } else if k == \"dylib\" {\n                                     cstore::NativeUnknown\n                                 } else {\n                                     e.sess.span_err(m.span,\n@@ -253,7 +253,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             None => cstore::NativeUnknown\n                         };\n                         let n = items.iter().find(|n| {\n-                            n.name().equiv(&(\"name\"))\n+                            n.name() == \"name\"\n                         }).and_then(|a| a.value_str());\n                         let n = match n {\n                             Some(n) => n,"}, {"sha": "92c87aacc7dc5bf75e276fdb9a1b6be4d2f455a1", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -40,7 +40,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n         let mut last_two: Vec<_> =\n             s.as_slice().chars().rev().take(2).collect();\n         last_two.reverse();\n-        if last_two.as_slice() != &['\\\\', 'l'] {\n+        if last_two != ['\\\\', 'l'] {\n             s.push_str(\"\\\\l\");\n         }\n         s"}, {"sha": "33de2c9abe928ca0c5bc1ea2a36a402b63bf1582", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -944,7 +944,7 @@ mod test {\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n+        let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }"}, {"sha": "9c94823f867586d6c1296d08d31b923574fc1a2f", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -156,7 +156,7 @@ mod test {\n             \"rpath2\".to_string(),\n             \"rpath1\".to_string()\n         ]);\n-        assert!(res.as_slice() == &[\n+        assert!(res.as_slice() == [\n             \"rpath1\".to_string(),\n             \"rpath2\".to_string()\n         ]);\n@@ -176,7 +176,7 @@ mod test {\n             \"4a\".to_string(),\n             \"3\".to_string()\n         ]);\n-        assert!(res.as_slice() == &[\n+        assert!(res.as_slice() == [\n             \"1a\".to_string(),\n             \"2\".to_string(),\n             \"4a\".to_string(),"}, {"sha": "d3281ae1c19fcb3d6c8a186a2bd3a686b9e81895", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -679,19 +679,19 @@ pub fn collect_crate_types(session: &Session,\n     let attr_types: Vec<config::CrateType> = attrs.iter().filter_map(|a| {\n         if a.check_name(\"crate_type\") {\n             match a.value_str() {\n-                Some(ref n) if n.equiv(&(\"rlib\")) => {\n+                Some(ref n) if *n == \"rlib\" => {\n                     Some(config::CrateTypeRlib)\n                 }\n-                Some(ref n) if n.equiv(&(\"dylib\")) => {\n+                Some(ref n) if *n == \"dylib\" => {\n                     Some(config::CrateTypeDylib)\n                 }\n-                Some(ref n) if n.equiv(&(\"lib\")) => {\n+                Some(ref n) if *n == \"lib\" => {\n                     Some(config::default_lib_output())\n                 }\n-                Some(ref n) if n.equiv(&(\"staticlib\")) => {\n+                Some(ref n) if *n == \"staticlib\" => {\n                     Some(config::CrateTypeStaticlib)\n                 }\n-                Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n+                Some(ref n) if *n == \"bin\" => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n                     session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n                                      ast::CRATE_NODE_ID,"}, {"sha": "555cb0004892fd08af9d3f8edc3057ea91222ff4", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -1545,7 +1545,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                     Some(ref p) if p.is_relative() => {\n                             // prepend \"./\" if necessary\n                             let dotdot = b\"..\";\n-                            let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n+                            let prefix = [dotdot[0], ::std::path::SEP_BYTE];\n                             let mut path_bytes = p.as_vec().to_vec();\n \n                             if path_bytes.slice_to(2) != prefix &&"}, {"sha": "cc946a6ca4a96ea1a956dc952194fb495dadebaa", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -172,7 +172,7 @@ pub fn main_args(args: &[String]) -> int {\n         }\n     }\n \n-    if matches.opt_strs(\"passes\").as_slice() == &[\"list\".to_string()] {\n+    if matches.opt_strs(\"passes\") == [\"list\"] {\n         println!(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n             println!(\"{:>20} - {}\", name, description);"}, {"sha": "cf09c93f91785ef35913a52ca2c7f020e94d366d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -432,12 +432,14 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         table::make_hash(&self.hasher, x)\n     }\n \n+    #[allow(deprecated)]\n     fn search_equiv<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a self, q: &Q)\n                     -> Option<FullBucketImm<'a, K, V>> {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, &hash, |k| q.equiv(k)).into_option()\n     }\n \n+    #[allow(deprecated)]\n     fn search_equiv_mut<'a, Sized? Q: Hash<S> + Equiv<K>>(&'a mut self, q: &Q)\n                     -> Option<FullBucketMut<'a, K, V>> {\n         let hash = self.make_hash(q);"}, {"sha": "fd6b57d096ae6e2b5484852aead077aa5d6ebebb", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -1528,7 +1528,7 @@ mod test {\n \n         check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n         let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual.as_slice() == &bytes);\n+        assert!(actual == bytes.as_slice());\n     }\n \n     #[test]"}, {"sha": "0abd030a16347e58b3f7e08462508c1bfceadd6e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -2034,7 +2034,7 @@ mod tests {\n     fn split_paths_windows() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect()\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n@@ -2054,7 +2054,7 @@ mod tests {\n     fn split_paths_unix() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect()\n+                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));"}, {"sha": "f6778588addb9f0c8ce3f6ec8af058d6e55ec715", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 41, "deletions": 52, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -443,7 +443,6 @@ static dot_dot_static: &'static [u8] = b\"..\";\n mod tests {\n     use prelude::*;\n     use super::*;\n-    use mem;\n     use str;\n     use str::StrPrelude;\n \n@@ -601,10 +600,8 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    unsafe {\n-                        let path = Path::new($path);\n-                        assert!(path.$op() == mem::transmute(($exp).as_bytes()));\n-                    }\n+                    let path = Path::new($path);\n+                    assert!(path.$op() == ($exp).as_bytes());\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -616,11 +613,9 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    unsafe {\n-                        let arg = $path;\n-                        let path = Path::new(arg);\n-                        assert!(path.$op() == mem::transmute($exp));\n-                    }\n+                    let arg = $path;\n+                    let path = Path::new(arg);\n+                    assert!(path.$op() == $exp);\n                 }\n             );\n         )\n@@ -668,9 +663,8 @@ mod tests {\n         t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n         t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n-        let no: Option<&'static [u8]> = None;\n-        t!(v: b\"hi/there\", extension, no);\n-        t!(v: b\"hi/there\\x80\", extension, no);\n+        t!(v: b\"hi/there\", extension, None);\n+        t!(v: b\"hi/there\\x80\", extension, None);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -959,62 +953,57 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        let filename = $filename;\n-                        assert!(path.filename_str() == filename,\n-                                \"{}.filename_str(): Expected `{}`, found {}\",\n-                                path.as_str().unwrap(), filename, path.filename_str());\n-                        let dirname = $dirname;\n-                        assert!(path.dirname_str() == dirname,\n-                                \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), dirname, path.dirname_str());\n-                        let filestem = $filestem;\n-                        assert!(path.filestem_str() == filestem,\n-                                \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), filestem, path.filestem_str());\n-                        let ext = $ext;\n-                        assert!(path.extension_str() == mem::transmute(ext),\n-                                \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), ext, path.extension_str());\n-                    }\n+                    let path = $path;\n+                    let filename = $filename;\n+                    assert!(path.filename_str() == filename,\n+                            \"{}.filename_str(): Expected `{}`, found {}\",\n+                            path.as_str().unwrap(), filename, path.filename_str());\n+                    let dirname = $dirname;\n+                    assert!(path.dirname_str() == dirname,\n+                            \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), dirname, path.dirname_str());\n+                    let filestem = $filestem;\n+                    assert!(path.filestem_str() == filestem,\n+                            \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), filestem, path.filestem_str());\n+                    let ext = $ext;\n+                    assert!(path.extension_str() == ext,\n+                            \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), ext, path.extension_str());\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        assert!(path.filename() == mem::transmute($filename));\n-                        assert!(path.dirname() == mem::transmute($dirname));\n-                        assert!(path.filestem() == mem::transmute($filestem));\n-                        assert!(path.extension() == mem::transmute($ext));\n-                    }\n+                    let path = $path;\n+                    assert!(path.filename() == $filename);\n+                    assert!(path.dirname() == $dirname);\n+                    assert!(path.filestem() == $filestem);\n+                    assert!(path.extension() == $ext);\n                 }\n             )\n         )\n \n-        let no: Option<&'static str> = None;\n-        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), no);\n-        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), no);\n+        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n+        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n         t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n               Some(b\"there\"), Some(b\"\\xFF\"));\n-        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), no);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n-        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, no);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n-        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, no);\n+        t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"../..\"), None, Some(\"../..\"), None, None);\n         t!(s: Path::new(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n+        t!(s: Path::new(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n         t!(s: Path::new(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n+        t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, no);\n+        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n         t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), no);\n-        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), no);\n+        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]"}, {"sha": "13891a63330144da656fdd005f12b13ede1fcb9a", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -1115,7 +1115,6 @@ fn prefix_len(p: Option<PathPrefix>) -> uint {\n \n #[cfg(test)]\n mod tests {\n-    use mem;\n     use prelude::*;\n     use super::*;\n     use super::parse_prefix;\n@@ -1358,11 +1357,9 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        let path = Path::new(path);\n-                        assert!(path.$op() == Some(mem::transmute($exp)));\n-                    }\n+                    let path = $path;\n+                    let path = Path::new(path);\n+                    assert!(path.$op() == Some($exp));\n                 }\n             );\n             (s: $path:expr, $op:ident, $exp:expr, opt) => (\n@@ -1375,11 +1372,9 @@ mod tests {\n             );\n             (v: $path:expr, $op:ident, $exp:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        let path = Path::new(path);\n-                        assert!(path.$op() == mem::transmute($exp));\n-                    }\n+                    let path = $path;\n+                    let path = Path::new(path);\n+                    assert!(path.$op() == $exp);\n                 }\n             )\n         )\n@@ -1464,8 +1459,7 @@ mod tests {\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n         t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n-        let no: Option<&'static [u8]> = None;\n-        t!(v: b\"hi\\\\there\", extension, no);\n+        t!(v: b\"hi\\\\there\", extension, None);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1872,53 +1866,48 @@ mod tests {\n         macro_rules! t(\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        let filename = $filename;\n-                        assert!(path.filename_str() == filename,\n-                                \"`{}`.filename_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), filename, path.filename_str());\n-                        let dirname = $dirname;\n-                        assert!(path.dirname_str() == dirname,\n-                                \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), dirname, path.dirname_str());\n-                        let filestem = $filestem;\n-                        assert!(path.filestem_str() == filestem,\n-                                \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), filestem, path.filestem_str());\n-                        let ext = $ext;\n-                        assert!(path.extension_str() == mem::transmute(ext),\n-                                \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n-                                path.as_str().unwrap(), ext, path.extension_str());\n-                    }\n+                    let path = $path;\n+                    let filename = $filename;\n+                    assert!(path.filename_str() == filename,\n+                            \"`{}`.filename_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), filename, path.filename_str());\n+                    let dirname = $dirname;\n+                    assert!(path.dirname_str() == dirname,\n+                            \"`{}`.dirname_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), dirname, path.dirname_str());\n+                    let filestem = $filestem;\n+                    assert!(path.filestem_str() == filestem,\n+                            \"`{}`.filestem_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), filestem, path.filestem_str());\n+                    let ext = $ext;\n+                    assert!(path.extension_str() == ext,\n+                            \"`{}`.extension_str(): Expected `{}`, found `{}`\",\n+                            path.as_str().unwrap(), ext, path.extension_str());\n                 }\n             );\n             (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n-                    unsafe {\n-                        let path = $path;\n-                        assert!(path.filename() == mem::transmute($filename));\n-                        assert!(path.dirname() == mem::transmute($dirname));\n-                        assert!(path.filestem() == mem::transmute($filestem));\n-                        assert!(path.extension() == mem::transmute($ext));\n-                    }\n+                    let path = $path;\n+                    assert!(path.filename() == $filename);\n+                    assert!(path.dirname() == $dirname);\n+                    assert!(path.filestem() == $filestem);\n+                    assert!(path.extension() == $ext);\n                 }\n             )\n         )\n \n-        let no: Option<&'static str> = None;\n-        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), no);\n-        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), no);\n-        t!(s: Path::new(\".\"), None, Some(\".\"), None, no);\n-        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, no);\n-        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, no);\n-        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, no);\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n+        t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n+        t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n+        t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n+        t!(s: Path::new(\"..\"), None, Some(\"..\"), None, None);\n+        t!(s: Path::new(\"..\\\\..\"), None, Some(\"..\\\\..\"), None, None);\n         t!(s: Path::new(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"txt\"));\n-        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), no);\n+        t!(s: Path::new(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n         t!(s: Path::new(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n               Some(\"there\"), Some(\"\"));\n-        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), no);\n+        t!(s: Path::new(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::new(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n "}, {"sha": "a2811681efd37591a25d6a9d4d5861f21042f2ff", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -287,11 +287,11 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline]\n     attrs.iter().fold(InlineNone, |ia,attr| {\n         match attr.node.value.node {\n-            MetaWord(ref n) if n.equiv(&(\"inline\")) => {\n+            MetaWord(ref n) if *n == \"inline\" => {\n                 mark_used(attr);\n                 InlineHint\n             }\n-            MetaList(ref n, ref items) if n.equiv(&(\"inline\")) => {\n+            MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n                 if contains_name(items.as_slice(), \"always\") {\n                     InlineAlways\n@@ -409,7 +409,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n pub fn find_repr_attrs(diagnostic: &SpanHandler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     match attr.node.value.node {\n-        ast::MetaList(ref s, ref items) if s.equiv(&(\"repr\")) => {\n+        ast::MetaList(ref s, ref items) if *s == \"repr\" => {\n             mark_used(attr);\n             for item in items.iter() {\n                 match item.node {"}, {"sha": "b138811187ba9ac8fd802ce8341046e0604d4763", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -148,7 +148,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n                     let (s, _str_style) = p.parse_str();\n \n-                    if OPTIONS.iter().any(|opt| s.equiv(opt)) {\n+                    if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.last_span, \"expected a clobber, found an option\");\n                     }\n                     clobs.push(s);\n@@ -157,13 +157,13 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             Options => {\n                 let (option, _str_style) = p.parse_str();\n \n-                if option.equiv(&(\"volatile\")) {\n+                if option == \"volatile\" {\n                     // Indicates that the inline assembly has side effects\n                     // and must not be optimized out along with its outputs.\n                     volatile = true;\n-                } else if option.equiv(&(\"alignstack\")) {\n+                } else if option == \"alignstack\" {\n                     alignstack = true;\n-                } else if option.equiv(&(\"intel\")) {\n+                } else if option == \"intel\" {\n                     dialect = ast::AsmIntel;\n                 } else {\n                     cx.span_warn(p.last_span, \"unrecognized option\");"}, {"sha": "c7aef0020b2c4705778889e1e4dd8015cfe31c3a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -172,12 +172,12 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item) {\n         for attr in i.attrs.iter() {\n-            if attr.name().equiv(&(\"thread_local\")) {\n+            if attr.name() == \"thread_local\" {\n                 self.gate_feature(\"thread_local\", i.span,\n                                   \"`#[thread_local]` is an experimental feature, and does not \\\n                                   currently handle destructors. There is no corresponding \\\n                                   `#[task_local]` mapping to the task model\");\n-            } else if attr.name().equiv(&(\"linkage\")) {\n+            } else if attr.name() == \"linkage\" {\n                 self.gate_feature(\"linkage\", i.span,\n                                   \"the `linkage` attribute is experimental \\\n                                    and not portable across platforms\")\n@@ -429,7 +429,7 @@ pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features,\n                         }\n                     };\n                     match KNOWN_FEATURES.iter()\n-                                        .find(|& &(n, _)| name.equiv(&n)) {\n+                                        .find(|& &(n, _)| name == n) {\n                         Some(&(name, Active)) => { cx.features.push(name); }\n                         Some(&(_, Removed)) => {\n                             span_handler.span_err(mi.span, \"feature has been removed\");"}, {"sha": "650f8295d01a6df3bd2bd636d7fc1d3dd8664741", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -117,7 +117,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     fn is_obsolete_ident(&mut self, ident: &str) -> bool {\n         match self.token {\n             token::Ident(sid, _) => {\n-                token::get_ident(sid).equiv(&ident)\n+                token::get_ident(sid) == ident\n             }\n             _ => false\n         }"}, {"sha": "52b54bc7f2d6dc81cde165c9a90757a869b1cbbb", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -623,12 +623,35 @@ impl fmt::Show for InternedString {\n     }\n }\n \n+#[allow(deprecated)]\n impl<'a> Equiv<&'a str> for InternedString {\n     fn equiv(&self, other: & &'a str) -> bool {\n         (*other) == self.string.as_slice()\n     }\n }\n \n+impl<'a> PartialEq<&'a str> for InternedString {\n+    #[inline(always)]\n+    fn eq(&self, other: & &'a str) -> bool {\n+        PartialEq::eq(self.string.as_slice(), *other)\n+    }\n+    #[inline(always)]\n+    fn ne(&self, other: & &'a str) -> bool {\n+        PartialEq::ne(self.string.as_slice(), *other)\n+    }\n+}\n+\n+impl<'a> PartialEq<InternedString > for &'a str {\n+    #[inline(always)]\n+    fn eq(&self, other: &InternedString) -> bool {\n+        PartialEq::eq(*self, other.string.as_slice())\n+    }\n+    #[inline(always)]\n+    fn ne(&self, other: &InternedString) -> bool {\n+        PartialEq::ne(*self, other.string.as_slice())\n+    }\n+}\n+\n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern("}, {"sha": "d56e4f704499ef9871359de20d603a5ac6d3af5a", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -224,10 +224,10 @@ mod test {\n         assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1i);\n-        assert_eq!(vec!(1i), v.into_iter().collect());\n+        assert_eq!(vec!(1i), v.into_iter().collect::<Vec<_>>());\n \n         let v = SmallVector::many(vec!(1i, 2i, 3i));\n-        assert_eq!(vec!(1i, 2i, 3i), v.into_iter().collect());\n+        assert_eq!(vec!(1i, 2i, 3i), v.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]"}, {"sha": "d644542db0732532ccf49db2121b5c77cb57f613", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -582,23 +582,23 @@ mod test {\n     fn test_basic_setabf() {\n         let s = b\"\\\\E[48;5;%p1%dm\";\n         assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n-                   \"\\\\E[48;5;1m\".bytes().collect());\n+                   \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n     }\n \n     #[test]\n     fn test_multiple_int_constants() {\n         assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n-                   \"21\".bytes().collect());\n+                   \"21\".bytes().collect::<Vec<_>>());\n     }\n \n     #[test]\n     fn test_op_i() {\n         let mut vars = Variables::new();\n         assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n                           &[Number(1),Number(2),Number(3)], &mut vars),\n-                   Ok(\"123233\".bytes().collect()));\n+                   Ok(\"123233\".bytes().collect::<Vec<_>>()));\n         assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n-                   Ok(\"0011\".bytes().collect()));\n+                   Ok(\"0011\".bytes().collect::<Vec<_>>()));\n     }\n \n     #[test]\n@@ -672,15 +672,15 @@ mod test {\n         let res = expand(s, &[Number(1)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   \"\\\\E[31m\".bytes().collect());\n+                   \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(8)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   \"\\\\E[90m\".bytes().collect());\n+                   \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(42)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   \"\\\\E[38;5;42m\".bytes().collect());\n+                   \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -692,13 +692,13 @@ mod test {\n                             Words(\"foo\".to_string()),\n                             Words(\"f\".to_string()),\n                             Words(\"foo\".to_string())], vars),\n-                   Ok(\"foofoo ffo\".bytes().collect()));\n+                   Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n         assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n-                   Ok(\"fo  \".bytes().collect()));\n+                   Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n-                   Ok(\"1001    1+1\".bytes().collect()));\n+                   Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n         assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", &[Number(15), Number(27)], vars),\n-                   Ok(\"17017  001b0X001B\".bytes().collect()));\n+                   Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n     }\n }"}, {"sha": "018e8cddc71c6a2a87fff3161b27da263600f640", "filename": "src/test/run-pass/eq-multidispatch.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Feq-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Feq-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Feq-multidispatch.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(default_type_params)]\n+\n+#[deriving(PartialEq)]\n+struct Bar;\n+struct Baz;\n+struct Foo;\n+struct Fu;\n+\n+impl PartialEq for Baz { fn eq(&self, _: &Baz) -> bool  { true } }\n+\n+impl PartialEq<Fu> for Foo { fn eq(&self, _: &Fu) -> bool { true } }\n+impl PartialEq<Foo> for Fu { fn eq(&self, _: &Foo) -> bool { true } }\n+\n+impl PartialEq<Bar> for Foo { fn eq(&self, _: &Bar) -> bool { false } }\n+impl PartialEq<Foo> for Bar { fn eq(&self, _: &Foo) -> bool { false } }\n+\n+fn main() {\n+    assert!(Bar != Foo);\n+    assert!(Foo != Bar);\n+\n+    assert!(Bar == Bar);\n+\n+    assert!(Baz == Baz);\n+\n+    assert!(Foo == Fu);\n+    assert!(Fu == Foo);\n+}"}, {"sha": "76b8463a4170133185419e07f4f88fd2b6d4bbf0", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -26,5 +26,5 @@ fn main() {\n                 break\n         }\n     }\n-    assert!(result.as_slice() == &[2, 4]);\n+    assert!(result == [2, 4]);\n }"}, {"sha": "666847517efdeda568d337a45d628f586e46fb20", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d965cc2c99787a949d38abf225412fe502d3ed8/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=6d965cc2c99787a949d38abf225412fe502d3ed8", "patch": "@@ -33,6 +33,6 @@ fn main() {\n     let out = bar(\"baz\", \"foo\");\n     let [a, xs.., d] = out;\n     assert_eq!(a, \"baz\");\n-    assert!(xs == &[\"foo\", \"foo\"]);\n+    assert!(xs == [\"foo\", \"foo\"]);\n     assert_eq!(d, \"baz\");\n }"}]}