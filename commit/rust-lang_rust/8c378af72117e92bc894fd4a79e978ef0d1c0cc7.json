{"sha": "8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzc4YWY3MjExN2U5MmJjODk0ZmQ0YTc5ZTk3OGVmMGQxYzBjYzc=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-03-24T11:40:58Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T12:12:08Z"}, "message": "missing match arms diagnostic", "tree": {"sha": "6c011c93de19d4bca21de349b5c050459a6aaf6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c011c93de19d4bca21de349b5c050459a6aaf6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "html_url": "https://github.com/rust-lang/rust/commit/8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7e5d94bda362ffc21174a79aa0be113c3288e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e5d94bda362ffc21174a79aa0be113c3288e1e", "html_url": "https://github.com/rust-lang/rust/commit/b7e5d94bda362ffc21174a79aa0be113c3288e1e"}], "stats": {"total": 1059, "additions": 1048, "deletions": 11}, "files": [{"sha": "eb9824218f3ec55513cad57507738d12c7b19195", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -995,6 +995,7 @@ dependencies = [\n  \"ra_prof\",\n  \"ra_syntax\",\n  \"rustc-hash\",\n+ \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n ]"}, {"sha": "c82883d0c1611fadf6255223950a99ff5e2e6ffb", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -1,4 +1,4 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-pub use hir_ty::diagnostics::{MissingFields, MissingOkInTailExpr, NoSuchField};\n+pub use hir_ty::diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField};"}, {"sha": "9a4a7aa6f7e60f3d8ec806526f89b2fb6a133717", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -9,6 +9,7 @@ doctest = false\n \n [dependencies]\n arrayvec = \"0.5.1\"\n+smallvec = \"1.2.0\"\n ena = \"0.13.1\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\""}, {"sha": "ac66dd415b2d4dba59c963eabadea50559f6dcbe", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "added", "additions": 944, "deletions": 0, "changes": 944, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -0,0 +1,944 @@\n+//! This module implements match statement exhaustiveness checking and usefulness checking\n+//! for match arms.\n+//!\n+//! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n+//! contains very detailed documentation about the match checking algorithm.\n+use std::sync::Arc;\n+\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{\n+    db::HirDatabase,\n+    expr::{Body, Expr, Literal, Pat, PatId},\n+    InferenceResult,\n+};\n+use hir_def::{adt::VariantData, EnumVariantId, VariantId};\n+\n+#[derive(Debug, Clone, Copy)]\n+enum PatIdOrWild {\n+    PatId(PatId),\n+    Wild,\n+}\n+\n+impl PatIdOrWild {\n+    fn as_pat(self, cx: &MatchCheckCtx) -> Pat {\n+        match self {\n+            PatIdOrWild::PatId(id) => cx.body.pats[id].clone(),\n+            PatIdOrWild::Wild => Pat::Wild,\n+        }\n+    }\n+\n+    fn as_id(self) -> Option<PatId> {\n+        match self {\n+            PatIdOrWild::PatId(id) => Some(id),\n+            PatIdOrWild::Wild => None,\n+        }\n+    }\n+}\n+\n+impl From<PatId> for PatIdOrWild {\n+    fn from(pat_id: PatId) -> Self {\n+        Self::PatId(pat_id)\n+    }\n+}\n+\n+type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n+#[derive(Debug)]\n+pub(crate) struct PatStack(PatStackInner);\n+\n+impl PatStack {\n+    pub(crate) fn from_pattern(pat_id: PatId) -> PatStack {\n+        Self(smallvec!(pat_id.into()))\n+    }\n+\n+    pub(crate) fn from_wild() -> PatStack {\n+        Self(smallvec!(PatIdOrWild::Wild))\n+    }\n+\n+    fn from_slice(slice: &[PatIdOrWild]) -> PatStack {\n+        Self(SmallVec::from_slice(slice))\n+    }\n+\n+    fn from_vec(v: PatStackInner) -> PatStack {\n+        Self(v)\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn head(&self) -> PatIdOrWild {\n+        self.0[0]\n+    }\n+\n+    fn get_head(&self) -> Option<PatIdOrWild> {\n+        self.0.first().copied()\n+    }\n+\n+    fn to_tail(&self) -> PatStack {\n+        Self::from_slice(&self.0[1..])\n+    }\n+\n+    fn replace_head_with(&self, pat_ids: &[PatId]) -> PatStack {\n+        let mut patterns: PatStackInner = smallvec![];\n+        for pat in pat_ids {\n+            patterns.push((*pat).into());\n+        }\n+        for pat in &self.0[1..] {\n+            patterns.push(*pat);\n+        }\n+        PatStack::from_vec(patterns)\n+    }\n+\n+    // Computes `D(self)`.\n+    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n+        if matches!(self.head().as_pat(cx), Pat::Wild) {\n+            Some(self.to_tail())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Computes `S(constructor, self)`.\n+    fn specialize_constructor(\n+        &self,\n+        cx: &MatchCheckCtx,\n+        constructor: &Constructor,\n+    ) -> Option<PatStack> {\n+        match (self.head().as_pat(cx), constructor) {\n+            (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n+                if pat_ids.len() != *arity {\n+                    return None;\n+                }\n+\n+                Some(self.replace_head_with(pat_ids))\n+            }\n+            (Pat::Lit(_), Constructor::Bool(_)) => {\n+                // for now we only support bool literals\n+                Some(self.to_tail())\n+            }\n+            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)),\n+            (Pat::Path(_), Constructor::Enum(constructor)) => {\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                    return None;\n+                }\n+                // enums with no associated data become `Pat::Path`\n+                Some(self.to_tail())\n+            }\n+            (Pat::TupleStruct { args: ref pat_ids, .. }, Constructor::Enum(constructor)) => {\n+                let pat_id = self.head().as_id().expect(\"we know this isn't a wild\");\n+                if !enum_variant_matches(cx, pat_id, *constructor) {\n+                    return None;\n+                }\n+\n+                Some(self.replace_head_with(pat_ids))\n+            }\n+            (Pat::Or(_), _) => unreachable!(\"we desugar or patterns so this should never happen\"),\n+            (a, b) => unimplemented!(\"{:?}, {:?}\", a, b),\n+        }\n+    }\n+\n+    fn expand_wildcard(&self, cx: &MatchCheckCtx, constructor: &Constructor) -> PatStack {\n+        assert_eq!(\n+            Pat::Wild,\n+            self.head().as_pat(cx),\n+            \"expand_wildcard must only be called on PatStack with wild at head\",\n+        );\n+\n+        let mut patterns: PatStackInner = smallvec![];\n+        let arity = match constructor {\n+            Constructor::Bool(_) => 0,\n+            Constructor::Tuple { arity } => *arity,\n+            Constructor::Enum(e) => {\n+                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n+                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n+                    VariantData::Unit => 0,\n+                    x => unimplemented!(\"{:?}\", x),\n+                }\n+            }\n+        };\n+\n+        for _ in 0..arity {\n+            patterns.push(PatIdOrWild::Wild);\n+        }\n+\n+        for pat in &self.0[1..] {\n+            patterns.push(*pat);\n+        }\n+\n+        PatStack::from_vec(patterns)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Matrix(Vec<PatStack>);\n+\n+impl Matrix {\n+    pub(crate) fn empty() -> Self {\n+        Self(vec![])\n+    }\n+\n+    pub(crate) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n+        // if the pattern is an or pattern it should be expanded\n+        if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n+            for pat_id in pat_ids {\n+                self.0.push(PatStack::from_pattern(pat_id));\n+            }\n+        } else {\n+            self.0.push(row);\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    fn heads(&self) -> Vec<PatIdOrWild> {\n+        self.0.iter().map(|p| p.head()).collect()\n+    }\n+\n+    // Computes `D(self)`.\n+    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Self {\n+        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_wildcard(cx)))\n+    }\n+\n+    // Computes `S(constructor, self)`.\n+    fn specialize_constructor(&self, cx: &MatchCheckCtx, constructor: &Constructor) -> Self {\n+        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_constructor(cx, constructor)))\n+    }\n+\n+    fn collect<T: IntoIterator<Item = PatStack>>(cx: &MatchCheckCtx, iter: T) -> Self {\n+        let mut matrix = Matrix::empty();\n+\n+        for pat in iter {\n+            // using push ensures we expand or-patterns\n+            matrix.push(cx, pat);\n+        }\n+\n+        matrix\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Usefulness {\n+    Useful,\n+    NotUseful,\n+}\n+\n+pub struct MatchCheckCtx<'a> {\n+    pub body: Arc<Body>,\n+    pub match_expr: &'a Expr,\n+    pub infer: Arc<InferenceResult>,\n+    pub db: &'a dyn HirDatabase,\n+}\n+\n+// see src/librustc_mir_build/hair/pattern/_match.rs\n+// It seems the rustc version of this method is able to assume that all the match arm\n+// patterns are valid (they are valid given a particular match expression), but I\n+// don't think we can make that assumption here. How should that be handled?\n+//\n+// Perhaps check that validity before passing the patterns into this method?\n+pub(crate) fn is_useful(cx: &MatchCheckCtx, matrix: &Matrix, v: &PatStack) -> Usefulness {\n+    dbg!(matrix);\n+    dbg!(v);\n+    if v.is_empty() {\n+        if matrix.is_empty() {\n+            return Usefulness::Useful;\n+        } else {\n+            return Usefulness::NotUseful;\n+        }\n+    }\n+\n+    if let Pat::Or(pat_ids) = v.head().as_pat(cx) {\n+        let any_useful = pat_ids.iter().any(|&pat_id| {\n+            let v = PatStack::from_pattern(pat_id);\n+\n+            is_useful(cx, matrix, &v) == Usefulness::Useful\n+        });\n+\n+        return if any_useful { Usefulness::Useful } else { Usefulness::NotUseful };\n+    }\n+\n+    if let Some(constructor) = pat_constructor(cx, v.head()) {\n+        let matrix = matrix.specialize_constructor(&cx, &constructor);\n+        let v = v.specialize_constructor(&cx, &constructor).expect(\"todo handle this case\");\n+\n+        is_useful(&cx, &matrix, &v)\n+    } else {\n+        dbg!(\"expanding wildcard\");\n+        // expanding wildcard\n+        let used_constructors: Vec<Constructor> =\n+            matrix.heads().iter().filter_map(|&p| pat_constructor(cx, p)).collect();\n+\n+        // We assume here that the first constructor is the \"correct\" type. Since we\n+        // only care about the \"type\" of the constructor (i.e. if it is a bool we\n+        // don't care about the value), this assumption should be valid as long as\n+        // the match statement is well formed. But potentially a better way to handle\n+        // this is to use the match expressions type.\n+        match &used_constructors.first() {\n+            Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n+                dbg!(\"all constructors are covered\");\n+                // If all constructors are covered, then we need to consider whether\n+                // any values are covered by this wildcard.\n+                //\n+                // For example, with matrix '[[Some(true)], [None]]', all\n+                // constructors are covered (`Some`/`None`), so we need\n+                // to perform specialization to see that our wildcard will cover\n+                // the `Some(false)` case.\n+                let constructor =\n+                    matrix.heads().iter().filter_map(|&pat| pat_constructor(cx, pat)).next();\n+\n+                if let Some(constructor) = constructor {\n+                    dbg!(\"found constructor {:?}, specializing..\", &constructor);\n+                    if let Constructor::Enum(e) = constructor {\n+                        // For enums we handle each variant as a distinct constructor, so\n+                        // here we create a constructor for each variant and then check\n+                        // usefulness after specializing for that constructor.\n+                        let any_useful = cx\n+                            .db\n+                            .enum_data(e.parent)\n+                            .variants\n+                            .iter()\n+                            .map(|(local_id, _)| {\n+                                Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n+                            })\n+                            .any(|constructor| {\n+                                let matrix = matrix.specialize_constructor(&cx, &constructor);\n+                                let v = v.expand_wildcard(&cx, &constructor);\n+\n+                                is_useful(&cx, &matrix, &v) == Usefulness::Useful\n+                            });\n+\n+                        if any_useful {\n+                            Usefulness::Useful\n+                        } else {\n+                            Usefulness::NotUseful\n+                        }\n+                    } else {\n+                        let matrix = matrix.specialize_constructor(&cx, &constructor);\n+                        let v = v.expand_wildcard(&cx, &constructor);\n+\n+                        is_useful(&cx, &matrix, &v)\n+                    }\n+                } else {\n+                    Usefulness::NotUseful\n+                }\n+            }\n+            _ => {\n+                // Either not all constructors are covered, or the only other arms\n+                // are wildcards. Either way, this pattern is useful if it is useful\n+                // when compared to those arms with wildcards.\n+                let matrix = matrix.specialize_wildcard(&cx);\n+                let v = v.to_tail();\n+\n+                is_useful(&cx, &matrix, &v)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+enum Constructor {\n+    Bool(bool),\n+    Tuple { arity: usize },\n+    Enum(EnumVariantId),\n+}\n+\n+fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> Option<Constructor> {\n+    match pat.as_pat(cx) {\n+        Pat::Wild => None,\n+        Pat::Tuple(pats) => Some(Constructor::Tuple { arity: pats.len() }),\n+        Pat::Lit(lit_expr) => {\n+            // for now we only support bool literals\n+            match cx.body.exprs[lit_expr] {\n+                Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n+                _ => unimplemented!(),\n+            }\n+        }\n+        Pat::TupleStruct { .. } | Pat::Path(_) => {\n+            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n+            let variant_id =\n+                cx.infer.variant_resolution_for_pat(pat_id).unwrap_or_else(|| unimplemented!());\n+            match variant_id {\n+                VariantId::EnumVariantId(enum_variant_id) => {\n+                    Some(Constructor::Enum(enum_variant_id))\n+                }\n+                _ => unimplemented!(),\n+            }\n+        }\n+        x => unimplemented!(\"{:?} not yet implemented\", x),\n+    }\n+}\n+\n+fn all_constructors_covered(\n+    cx: &MatchCheckCtx,\n+    constructor: &Constructor,\n+    used_constructors: &[Constructor],\n+) -> bool {\n+    match constructor {\n+        Constructor::Tuple { arity } => {\n+            used_constructors.iter().any(|constructor| match constructor {\n+                Constructor::Tuple { arity: used_arity } => arity == used_arity,\n+                _ => false,\n+            })\n+        }\n+        Constructor::Bool(_) => {\n+            if used_constructors.is_empty() {\n+                return false;\n+            }\n+\n+            let covers_true =\n+                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(true)));\n+            let covers_false =\n+                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(false)));\n+\n+            covers_true && covers_false\n+        }\n+        Constructor::Enum(e) => cx.db.enum_data(e.parent).variants.iter().all(|(id, _)| {\n+            for constructor in used_constructors {\n+                if let Constructor::Enum(e) = constructor {\n+                    if id == e.local_id {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            false\n+        }),\n+    }\n+}\n+\n+fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: EnumVariantId) -> bool {\n+    if let Some(VariantId::EnumVariantId(pat_variant_id)) =\n+        cx.infer.variant_resolution_for_pat(pat_id)\n+    {\n+        if pat_variant_id.local_id == enum_variant_id.local_id {\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    pub(super) use insta::assert_snapshot;\n+    pub(super) use ra_db::fixture::WithFixture;\n+\n+    pub(super) use crate::test_db::TestDB;\n+\n+    pub(super) fn check_diagnostic_message(content: &str) -> String {\n+        TestDB::with_single_file(content).0.diagnostics().0\n+    }\n+\n+    pub(super) fn check_diagnostic_with_no_fix(content: &str) {\n+        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+\n+        assert_eq!(1, diagnostic_count, \"no diagnotic reported\");\n+    }\n+\n+    pub(super) fn check_no_diagnostic(content: &str) {\n+        let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n+\n+        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one\");\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_arms_diagnostic_message() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                }\n+            }\n+        \";\n+\n+        assert_snapshot!(\n+            check_diagnostic_message(content),\n+            @\"\\\"{\\\\n                }\\\": Missing match arm\\n\"\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match () {\n+                    () => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (()) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (()) {\n+                    (()) => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match ((), ()) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_two_empty_tuple_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match ((), ()) {\n+                    ((), ()) => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn bool_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn bool_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                    true => {}\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn bool_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match false {\n+                    true => {}\n+                    false => {}\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (true, true) => {},\n+                    (true, false) => {},\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_no_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                    (true, ((), false)) => {},\n+                    (false, ((), true)) => {},\n+                    (false, ((), false)) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, _) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, ((), false)) {\n+                    (true, ((), true)) => {},\n+                    (true, ((), false)) => {},\n+                    (false, _) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn enum_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn enum_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A => {},\n+                    Either::B => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_no_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(true) => (),\n+                    Either::A(false) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_with_wild_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::B => (),\n+                    _ => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_containing_bool_with_wild_2_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B,\n+            }\n+            fn test_fn() {\n+                match Either::B {\n+                    Either::A(_) => (),\n+                    Either::B => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes_missing_arms() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(_) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic_with_no_fix(content);\n+    }\n+\n+    #[test]\n+    fn enum_different_sizes_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(_) => (),\n+                    Either::B(true, _) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn or_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            fn test_fn() {\n+                match Either::A(false) {\n+                    Either::A(true) | Either::A(false) => (),\n+                    Either::B(true, _) => (),\n+                    Either::B(false, _) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_enum_no_diagnostic() {\n+        let content = r\"\n+            enum Either {\n+                A(bool),\n+                B(bool, bool),\n+            }\n+            enum Either2 {\n+                C,\n+                D,\n+            }\n+            fn test_fn() {\n+                match (Either::A(false), Either2::C) {\n+                    (Either::A(true), _) | (Either::A(false), _) => (),\n+                    (Either::B(true, _), Either2::C) => (),\n+                    (Either::B(false, _), Either2::C) => (),\n+                    (Either::B(_, _), Either2::D) => (),\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod false_negatives {\n+    //! The implementation of match checking here is a work in progress. As we roll this out, we\n+    //! prefer false negatives to false positives (ideally there would be no false positives). This\n+    //! test module should document known false negatives. Eventually we will have a complete\n+    //! implementation of match checking and this module will be empty.\n+    //!\n+    //! The reasons for documenting known false negatives:\n+    //!\n+    //!   1. It acts as a backlog of work that can be done to improve the behavior of the system.\n+    //!   2. It ensures the code doesn't panic when handling these cases.\n+\n+    use super::tests::*;\n+\n+    #[test]\n+    fn mismatched_types() {\n+        let content = r\"\n+            enum Either {\n+                A,\n+                B,\n+            }\n+            enum Either2 {\n+                C,\n+                D,\n+            }\n+            fn test_fn() {\n+                match Either::A {\n+                    Either2::C => (),\n+                    Either2::D => (),\n+                }\n+            }\n+        \";\n+\n+        // This is a false negative.\n+        // We don't currently check that the match arms actually\n+        // match the type of the match expression.\n+        check_no_diagnostic(content);\n+    }\n+}"}, {"sha": "3457905e225e16be9f3f042d7ae2d55d78294854", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -6,7 +6,7 @@ use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n use stdx::format_to;\n \n-pub use hir_def::diagnostics::UnresolvedModule;\n+pub use hir_def::{diagnostics::UnresolvedModule, expr::MatchArm};\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n \n #[derive(Debug)]\n@@ -62,6 +62,24 @@ impl AstDiagnostic for MissingFields {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct MissingMatchArms {\n+    pub file: HirFileId,\n+    pub arms: AstPtr<ast::MatchArmList>,\n+}\n+\n+impl Diagnostic for MissingMatchArms {\n+    fn message(&self) -> String {\n+        String::from(\"Missing match arm\")\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.arms.into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MissingOkInTailExpr {\n     pub file: HirFileId,"}, {"sha": "3caeeb3946064ea511158b0427ccd293256f7b87", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -14,9 +14,10 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{MissingFields, MissingOkInTailExpr},\n+    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr},\n     utils::variant_data,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n+    _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n };\n \n pub use hir_def::{\n@@ -52,15 +53,63 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         for e in body.exprs.iter() {\n             if let (id, Expr::RecordLit { path, fields, spread }) = e {\n                 self.validate_record_literal(id, path, fields, *spread, db);\n+            } else if let (id, Expr::Match { expr, arms }) = e {\n+                self.validate_match(id, *expr, arms, db, self.infer.clone());\n             }\n         }\n \n         let body_expr = &body[body.body_expr];\n-        if let Expr::Block { statements: _, tail: Some(t) } = body_expr {\n+        if let Expr::Block { tail: Some(t), .. } = body_expr {\n             self.validate_results_in_tail_expr(body.body_expr, *t, db);\n         }\n     }\n \n+    fn validate_match(\n+        &mut self,\n+        id: ExprId,\n+        expr: ExprId,\n+        arms: &[MatchArm],\n+        db: &dyn HirDatabase,\n+        infer: Arc<InferenceResult>,\n+    ) {\n+        let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n+            db.body_with_source_map(self.func.into());\n+\n+        let match_expr: &hir_def::expr::Expr = &body[expr];\n+\n+        let cx = MatchCheckCtx { body: body.clone(), match_expr, infer, db };\n+        let pats = arms.iter().map(|arm| arm.pat);\n+\n+        let mut seen = Matrix::empty();\n+        for pat in pats {\n+            // If we had a NotUsefulMatchArm diagnostic, we could\n+            // check the usefulness of each pattern as we added it\n+            // to the matrix here.\n+            let v = PatStack::from_pattern(pat);\n+            seen.push(&cx, v);\n+        }\n+\n+        match is_useful(&cx, &seen, &PatStack::from_wild()) {\n+            Usefulness::Useful => (),\n+            // if a wildcard pattern is not useful, then all patterns are covered\n+            Usefulness::NotUseful => return,\n+        }\n+\n+        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+            if let Some(expr) = source_ptr.value.left() {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Expr::MatchExpr(match_expr) = expr.to_node(&root) {\n+                    if let Some(arms) = match_expr.match_arm_list() {\n+                        self.sink.push(MissingMatchArms {\n+                            file: source_ptr.file_id,\n+                            arms: AstPtr::new(&arms),\n+                        })\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn validate_record_literal(\n         &mut self,\n         id: ExprId,"}, {"sha": "69bbb4307f59c11544f7ea388c1e1e8034fbfe39", "filename": "crates/ra_hir_ty/src/infer/pat.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -21,9 +21,13 @@ impl<'a> InferenceContext<'a> {\n         subpats: &[PatId],\n         expected: &Ty,\n         default_bm: BindingMode,\n+        id: PatId,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n         let var_data = def.map(|it| variant_data(self.db.upcast(), it));\n+        if let Some(variant) = def {\n+            self.write_variant_resolution(id.into(), variant);\n+        }\n         self.unify(&ty, expected);\n \n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n@@ -152,7 +156,7 @@ impl<'a> InferenceContext<'a> {\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n             Pat::TupleStruct { path: p, args: subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n             }\n             Pat::Record { path: p, args: fields } => {\n                 self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)"}, {"sha": "2b6bc0f798f79752ff3e871c40a97d377870c332", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -67,8 +67,16 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::FunctionId(it) => it.into(),\n             ValueNs::ConstId(it) => it.into(),\n             ValueNs::StaticId(it) => it.into(),\n-            ValueNs::StructId(it) => it.into(),\n-            ValueNs::EnumVariantId(it) => it.into(),\n+            ValueNs::StructId(it) => {\n+                self.write_variant_resolution(id, it.into());\n+\n+                it.into()\n+            }\n+            ValueNs::EnumVariantId(it) => {\n+                self.write_variant_resolution(id, it.into());\n+\n+                it.into()\n+            }\n         };\n \n         let ty = self.db.value_ty(typable);"}, {"sha": "18f74d3b12bd47c2145ef72cfc12b47cbfb01927", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -43,6 +43,7 @@ mod tests;\n #[cfg(test)]\n mod test_db;\n mod marks;\n+mod _match;\n \n use std::ops::Deref;\n use std::sync::Arc;"}, {"sha": "3a4d58bf9c4ffae26eb29326a6a346558a929b0c", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -105,8 +105,9 @@ impl TestDB {\n     }\n \n     // FIXME: don't duplicate this\n-    pub fn diagnostics(&self) -> String {\n+    pub fn diagnostics(&self) -> (String, u32) {\n         let mut buf = String::new();\n+        let mut count = 0;\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n@@ -133,13 +134,14 @@ impl TestDB {\n                 let infer = self.infer(f.into());\n                 let mut sink = DiagnosticSink::new(|d| {\n                     format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n+                    count += 1;\n                 });\n                 infer.add_diagnostics(self, f, &mut sink);\n                 let mut validator = ExprValidator::new(f, infer, &mut sink);\n                 validator.validate_body(self);\n             }\n         }\n-        buf\n+        (buf, count)\n     }\n }\n "}, {"sha": "e4a103d1be100d328b587ee16be555ca297fb53b", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -309,7 +309,8 @@ fn no_such_field_diagnostics() {\n         }\n         \",\n     )\n-    .diagnostics();\n+    .diagnostics()\n+    .0;\n \n     assert_snapshot!(diagnostics, @r###\"\n     \"baz: 62\": no such field"}, {"sha": "901ad104c10f24d4bd0725b02a38c00f9b4bbaca", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c378af72117e92bc894fd4a79e978ef0d1c0cc7/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=8c378af72117e92bc894fd4a79e978ef0d1c0cc7", "patch": "@@ -101,6 +101,14 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix,\n         })\n     })\n+    .on::<hir::diagnostics::MissingMatchArms, _>(|d| {\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+    })\n     .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n         let node = d.ast(db);\n         let replacement = format!(\"Ok({})\", node.syntax());\n@@ -291,7 +299,7 @@ mod tests {\n     fn check_no_diagnostic(content: &str) {\n         let (analysis, file_id) = single_file(content);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n-        assert_eq!(diagnostics.len(), 0);\n+        assert_eq!(diagnostics.len(), 0, \"expected no diagnostic, found one\");\n     }\n \n     #[test]"}]}