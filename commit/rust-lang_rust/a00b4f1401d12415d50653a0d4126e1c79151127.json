{"sha": "a00b4f1401d12415d50653a0d4126e1c79151127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMGI0ZjE0MDFkMTI0MTVkNTA2NTNhMGQ0MTI2ZTFjNzkxNTExMjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-17T20:57:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-17T20:57:32Z"}, "message": "Rollup merge of #63657 - RalfJung:invalid_value, r=Centril\n\nCrank up invalid value lint\n\n* Warn against uninit `bool` and `char`.\n* Warn against 0-init `NonNull` and friends\n* Detect transmute-from-0 as zero-initialization ([seen in the wild](https://github.com/glium/glium/issues/1775#issuecomment-522144636))", "tree": {"sha": "b0151e31bc143d8a01514aa4ebdb1dbce1039f17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0151e31bc143d8a01514aa4ebdb1dbce1039f17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a00b4f1401d12415d50653a0d4126e1c79151127", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWGo8CRBK7hj4Ov3rIwAAdHIIAE6NX/9o+DL4UT6cf+OhvUVC\n4tDncqwS4Ke1BKaNnub0+9rM1jHMP6j2YLKVXuk2rxfZ0qDK4vh5dG8KBNG4JfbD\ndxHX2GzZb925nNsQzEaim2jgWhfBgjKKEBVSOFoV9cUXe4Rp6U9uxOZ3GdKbLjq/\nj03I0zI3qsbnqdVrRyY8JOSAvs0r0gOK3M4pK8+2ltjCUjWjaVgRCI9DGf58QUXl\nZk7rOZc4gALnT64MCIayptMLDzVYMctfP3Z82XuPwJes3EZ6QO5+0OQvKJGgJWMu\n36rM2Ghp0kGApKfzk5cGmoVYptTnhVdKbTWqs8R96qnSvTfhrOD13VLcrxcXJnI=\n=OZmB\n-----END PGP SIGNATURE-----\n", "payload": "tree b0151e31bc143d8a01514aa4ebdb1dbce1039f17\nparent a396434136ad93f97f03f4316dd989073ad160e9\nparent 3288be515feb4e2143c97ccf0e8455f572e3b360\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1566075452 +0200\ncommitter GitHub <noreply@github.com> 1566075452 +0200\n\nRollup merge of #63657 - RalfJung:invalid_value, r=Centril\n\nCrank up invalid value lint\n\n* Warn against uninit `bool` and `char`.\n* Warn against 0-init `NonNull` and friends\n* Detect transmute-from-0 as zero-initialization ([seen in the wild](https://github.com/glium/glium/issues/1775#issuecomment-522144636))\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a00b4f1401d12415d50653a0d4126e1c79151127", "html_url": "https://github.com/rust-lang/rust/commit/a00b4f1401d12415d50653a0d4126e1c79151127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a00b4f1401d12415d50653a0d4126e1c79151127/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a396434136ad93f97f03f4316dd989073ad160e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a396434136ad93f97f03f4316dd989073ad160e9", "html_url": "https://github.com/rust-lang/rust/commit/a396434136ad93f97f03f4316dd989073ad160e9"}, {"sha": "3288be515feb4e2143c97ccf0e8455f572e3b360", "url": "https://api.github.com/repos/rust-lang/rust/commits/3288be515feb4e2143c97ccf0e8455f572e3b360", "html_url": "https://github.com/rust-lang/rust/commit/3288be515feb4e2143c97ccf0e8455f572e3b360"}], "stats": {"total": 349, "additions": 267, "deletions": 82}, "files": [{"sha": "ce7681c974a5dcf73d1bd6bdcda0a75f8ba2e46d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 111, "deletions": 43, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -1876,25 +1876,101 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+        #[derive(Debug, Copy, Clone, PartialEq)]\n+        enum InitKind { Zeroed, Uninit };\n \n         /// Information about why a type cannot be initialized this way.\n         /// Contains an error message and optionally a span to point at.\n         type InitError = (String, Option<Span>);\n \n+        /// Test if this constant is all-0.\n+        fn is_zero(expr: &hir::Expr) -> bool {\n+            use hir::ExprKind::*;\n+            use syntax::ast::LitKind::*;\n+            match &expr.node {\n+                Lit(lit) =>\n+                    if let Int(i, _) = lit.node {\n+                        i == 0\n+                    } else {\n+                        false\n+                    },\n+                Tup(tup) =>\n+                    tup.iter().all(is_zero),\n+                _ =>\n+                    false\n+            }\n+        }\n+\n+        /// Determine if this expression is a \"dangerous initialization\".\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+            // `transmute` is inside an anonymous module (the `extern` block?);\n+            // `Invalid` represents the empty string and matches that.\n+            const TRANSMUTE_PATH: &[Symbol] =\n+                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n+\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                    let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+\n+                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                        return Some(InitKind::Zeroed);\n+                    }\n+                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                        return Some(InitKind::Uninit);\n+                    }\n+                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                        if is_zero(&args[0]) {\n+                            return Some(InitKind::Zeroed);\n+                        }\n+                    }\n+                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n+                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            }\n+\n+            None\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n+        fn ty_find_init_error<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            ty: Ty<'tcx>,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n-                // Recurse for some compound types.\n+                // Primitive types with other constraints.\n+                Bool if init == InitKind::Uninit =>\n+                    Some((format!(\"Booleans must be `true` or `false`\"), None)),\n+                Char if init == InitKind::Uninit =>\n+                    Some((format!(\"Characters must be a valid unicode codepoint\"), None)),\n+                // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    use std::ops::Bound;\n+                    match tcx.layout_scalar_valid_range(adt_def.did) {\n+                        // We exploit here that `layout_scalar_valid_range` will never\n+                        // return `Bound::Excluded`.  (And we have tests checking that we\n+                        // handle the attribute correctly.)\n+                        (Bound::Included(lo), _) if lo > 0 =>\n+                            return Some((format!(\"{} must be non-null\", ty), None)),\n+                        (Bound::Included(_), _) | (_, Bound::Included(_))\n+                        if init == InitKind::Uninit =>\n+                            return Some((\n+                                format!(\"{} must be initialized inside its custom valid range\", ty),\n+                                None,\n+                            )),\n+                        _ => {}\n+                    }\n+                    // Now, recurse.\n                     match adt_def.variants.len() {\n                         0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n                         1 => {\n@@ -1905,6 +1981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n+                                    init,\n                                 ).map(|(mut msg, span)| if span.is_none() {\n                                     // Point to this field, should be helpful for figuring\n                                     // out where the source of the error is.\n@@ -1918,57 +1995,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 })\n                             })\n                         }\n+                        // Multi-variant enums are tricky: if all but one variant are\n+                        // uninhabited, we might actually do layout like for a single-variant\n+                        // enum, and then even leaving them uninitialized could be okay.\n                         _ => None, // Conservative fallback for multi-variant enum.\n                     }\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n-                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n-                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n-                //        `char`, and any multivariant enum.\n                 // Conservative fallback.\n                 _ => None,\n             }\n         }\n \n-        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n-            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n-                        cx.match_def_path(def_id, &UININIT_PATH)\n-                    {\n-                        // This conjures an instance of a type out of nothing,\n-                        // using zeroed or uninitialized memory.\n-                        // We are extremely conservative with what we warn about.\n-                        let conjured_ty = cx.tables.expr_ty(expr);\n-                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n-                            let mut err = cx.struct_span_lint(\n-                                INVALID_VALUE,\n-                                expr.span,\n-                                &format!(\n-                                    \"the type `{}` does not permit {}\",\n-                                    conjured_ty,\n-                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n-                                        \"zero-initialization\"\n-                                    } else {\n-                                        \"being left uninitialized\"\n-                                    }\n-                                ),\n-                            );\n-                            err.span_label(expr.span,\n-                                \"this code causes undefined behavior when executed\");\n-                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n-                            if let Some(span) = span {\n-                                err.span_note(span, &msg);\n-                            } else {\n-                                err.note(&msg);\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n+        if let Some(init) = is_dangerous_init(cx, expr) {\n+            // This conjures an instance of a type out of nothing,\n+            // using zeroed or uninitialized memory.\n+            // We are extremely conservative with what we warn about.\n+            let conjured_ty = cx.tables.expr_ty(expr);\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n+                let mut err = cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    &format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ),\n+                );\n+                err.span_label(expr.span,\n+                    \"this code causes undefined behavior when executed\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                if let Some(span) = span {\n+                    err.span_note(span, &msg);\n+                } else {\n+                    err.note(&msg);\n                 }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "9edae1965ce1609f51706e775585d225a8fbee5c", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -1,5 +1,5 @@\n #![feature(rustc_attrs, const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n use std::ptr::NonNull;"}, {"sha": "bbab85c2121a5b3fc9963fa84291cd3a92a540b7", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-linelength\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "baab14dc161412e5fa34f03f9e578f48f61f5f0e", "filename": "src/test/ui/consts/const-eval/ub-upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -1,5 +1,5 @@\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "5cf62b869123975f0a7c43568a0f5199c8475e92", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -2,11 +2,13 @@\n // This test checks that calling `mem::{uninitialized,zeroed}` with certain types results\n // in a lint.\n \n-#![feature(never_type)]\n+#![feature(never_type, rustc_attrs)]\n #![allow(deprecated)]\n #![deny(invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n+use std::ptr::NonNull;\n+use std::num::NonZeroU32;\n \n enum Void {}\n \n@@ -16,6 +18,11 @@ struct RefPair((&'static i32, i32));\n struct Wrap<T> { wrapped: T }\n enum WrapEnum<T> { Wrapped(T) }\n \n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(128)]\n+#[repr(transparent)]\n+pub(crate) struct NonBig(u64);\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -29,6 +36,7 @@ fn generic<T: 'static>() {\n \n fn main() {\n     unsafe {\n+        // Things that cannot even be zero.\n         let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n@@ -56,11 +64,28 @@ fn main() {\n         let _val: Wrap<(RefPair, i32)> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: Wrap<(RefPair, i32)> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n-        // Some types that should work just fine.\n+        let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Things that can be zero, but not uninit.\n+        let _val: bool = mem::zeroed();\n+        let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<char> = mem::zeroed();\n+        let _val: Wrap<char> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: NonBig = mem::zeroed();\n+        let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Transmute-from-0\n+        let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n+        let _val: NonZeroU32 = mem::transmute(0); //~ ERROR: does not permit zero-initialization\n+\n+        // Some more types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n-        let _val: bool = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n     }\n }"}, {"sha": "a36a32a39a11b3ab2675883f838ce6bca3ef0e2b", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a00b4f1401d12415d50653a0d4126e1c79151127/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=a00b4f1401d12415d50653a0d4126e1c79151127", "patch": "@@ -1,5 +1,5 @@\n error: the type `&'static T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:22:32\n+  --> $DIR/uninitialized-zeroed.rs:29:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: References must be non-null\n \n error: the type `&'static T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:23:32\n+  --> $DIR/uninitialized-zeroed.rs:30:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Wrap<&'static T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:25:38\n+  --> $DIR/uninitialized-zeroed.rs:32:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&'static T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:26:38\n+  --> $DIR/uninitialized-zeroed.rs:33:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:32:23\n+  --> $DIR/uninitialized-zeroed.rs:40:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:33:23\n+  --> $DIR/uninitialized-zeroed.rs:41:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:35:30\n+  --> $DIR/uninitialized-zeroed.rs:43:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:36:30\n+  --> $DIR/uninitialized-zeroed.rs:44:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:38:26\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: 0-variant enums have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:39:26\n+  --> $DIR/uninitialized-zeroed.rs:47:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: 0-variant enums have no valid value\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:41:34\n+  --> $DIR/uninitialized-zeroed.rs:49:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: References must be non-null\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:42:34\n+  --> $DIR/uninitialized-zeroed.rs:50:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:44:25\n+  --> $DIR/uninitialized-zeroed.rs:52:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +153,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:45:25\n+  --> $DIR/uninitialized-zeroed.rs:53:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +168,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:47:26\n+  --> $DIR/uninitialized-zeroed.rs:55:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: Function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:48:26\n+  --> $DIR/uninitialized-zeroed.rs:56:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: Function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:50:32\n+  --> $DIR/uninitialized-zeroed.rs:58:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +205,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:51:32\n+  --> $DIR/uninitialized-zeroed.rs:59:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,13 +220,13 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:53:36\n+  --> $DIR/uninitialized-zeroed.rs:61:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -235,13 +235,13 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:54:36\n+  --> $DIR/uninitialized-zeroed.rs:62:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -250,13 +250,13 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:56:42\n+  --> $DIR/uninitialized-zeroed.rs:64:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +265,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:57:42\n+  --> $DIR/uninitialized-zeroed.rs:65:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,10 +280,102 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:67:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::zeroed();\n+   |                                  ^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:68:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::uninitialized();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `bool` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:72:26\n+   |\n+LL |         let _val: bool = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n+   |\n+   = note: Booleans must be `true` or `false`\n+\n+error: the type `Wrap<char>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:75:32\n+   |\n+LL |         let _val: Wrap<char> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Characters must be a valid unicode codepoint (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+\n+error: the type `NonBig` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:78:28\n+   |\n+LL |         let _val: NonBig = mem::uninitialized();\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+   |                            |\n+   |                            this code causes undefined behavior when executed\n+   |                            help: use `MaybeUninit<T>` instead\n+   |\n+   = note: NonBig must be initialized inside its custom valid range\n+\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:81:34\n+   |\n+LL |         let _val: &'static i32 = mem::transmute(0usize);\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `&'static [i32]` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:82:36\n+   |\n+LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `std::num::NonZeroU32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:83:32\n+   |\n+LL |         let _val: NonZeroU32 = mem::transmute(0);\n+   |                                ^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::num::NonZeroU32 must be non-null\n+\n+error: aborting due to 30 previous errors\n "}]}