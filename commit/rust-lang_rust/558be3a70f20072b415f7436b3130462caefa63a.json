{"sha": "558be3a70f20072b415f7436b3130462caefa63a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1OGJlM2E3MGYyMDA3MmI0MTVmNzQzNmIzMTMwNDYyY2FlZmE2M2E=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T15:51:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T15:51:16Z"}, "message": "pull method lookup / region manip into their own modules", "tree": {"sha": "b1fa953475a8db36bf7f68a597c1ee8188a79173", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1fa953475a8db36bf7f68a597c1ee8188a79173"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/558be3a70f20072b415f7436b3130462caefa63a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/558be3a70f20072b415f7436b3130462caefa63a", "html_url": "https://github.com/rust-lang/rust/commit/558be3a70f20072b415f7436b3130462caefa63a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/558be3a70f20072b415f7436b3130462caefa63a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "564aa59a3ff1ec462f4be15041d89c2ac662f861", "url": "https://api.github.com/repos/rust-lang/rust/commits/564aa59a3ff1ec462f4be15041d89c2ac662f861", "html_url": "https://github.com/rust-lang/rust/commit/564aa59a3ff1ec462f4be15041d89c2ac662f861"}], "stats": {"total": 1123, "additions": 566, "deletions": 557}, "files": [{"sha": "02e0f48012ca754c97d6fdeccebd0af9ac77705a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 75, "deletions": 557, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=558be3a70f20072b415f7436b3130462caefa63a", "patch": "@@ -38,12 +38,64 @@ can be broken down into several distinct phases:\n   are written into the `tcx.node_types` table, which should *never* contain\n   any reference to a type variable.\n \n+## Intermediate types\n+\n+While type checking a function, the intermediate types for the\n+expressions, blocks, and so forth contained within the function are\n+stored in `fcx.node_types` and `fcx.node_type_substs`.  These types\n+may contain unresolved type variables.  After type checking is\n+complete, the functions in the writeback module are used to take the\n+types from this table, resolve them, and then write them into their\n+permanent home in the type context `ccx.tcx`.\n+\n+This means that during inferencing you should use `fcx.write_ty()`\n+and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of\n+nodes within the function.\n+\n+The types of top-level items, which never contain unbound type\n+variables, are stored directly into the `tcx` tables.\n+\n+n.b.: A type variable is not the same thing as a type parameter.  A\n+type variable is rather an \"instance\" of a type parameter: that is,\n+given a generic function `fn foo<T>(t: T)`: while checking the\n+function `foo`, the type `ty_param(0)` refers to the type `T`, which\n+is treated in abstract.  When `foo()` is called, however, `T` will be\n+substituted for a fresh type variable `ty_var(N)`.  This variable will\n+eventually be resolved to some concrete type (which might itself be\n+type parameter).\n \n */\n \n import astconv::{ast_conv, region_scope, empty_rscope, ast_ty_to_ty,\n                  in_anon_rscope};\n import collect::{methods}; // ccx.to_ty()\n+import method::{methods};  // methods for method::lookup\n+import regionmanip::{universally_quantify_regions_before_call,\n+                     region_of, replace_bound_regions,\n+                     collect_bound_regions_in_tys};\n+\n+type fn_ctxt =\n+    // var_bindings, locals and next_var_id are shared\n+    // with any nested functions that capture the environment\n+    // (and with any functions whose environment is being captured).\n+    {self_ty: option<ty::t>,\n+     ret_ty: ty::t,\n+     // Used by loop bodies that return from the outer function\n+     indirect_ret_ty: option<ty::t>,\n+     purity: ast::purity,\n+     proto: ast::proto,\n+     infcx: infer::infer_ctxt,\n+     locals: hashmap<ast::node_id, ty_vid>,\n+     ty_var_counter: @mut uint,\n+     region_var_counter: @mut uint,\n+\n+     mut blocks: [ast::node_id], // stack of blocks in scope, may be empty\n+     in_scope_regions: isr_alist,\n+\n+     node_types: smallintmap::smallintmap<ty::t>,\n+     node_type_substs: hashmap<ast::node_id, ty::substs>,\n+\n+     ccx: @crate_ctxt};\n \n // a list of mapping from in-scope-region-names (\"isr\") to the\n // corresponding ty::region\n@@ -602,111 +654,6 @@ fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n     const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n-// Helper for the other universally_quantify_*() routines.  Extracts the bound\n-// regions from bound_tys and then replaces those same regions with fresh\n-// variables in `sty`, returning the resulting type.\n-fn universally_quantify_from_sty(fcx: @fn_ctxt,\n-                                 span: span,\n-                                 bound_tys: [ty::t],\n-                                 sty: ty::sty) -> ty::t {\n-\n-    #debug[\"universally_quantify_from_sty(bound_tys=%?)\",\n-           bound_tys.map {|x| fcx.ty_to_str(x) }];\n-    indent {||\n-        let tcx = fcx.tcx();\n-        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n-            let rvar = fcx.next_region_var();\n-            #debug[\"Bound region %s maps to %s\",\n-                   bound_region_to_str(fcx.ccx.tcx, br),\n-                   region_to_str(fcx.ccx.tcx, rvar)];\n-            rvar\n-        };\n-        let t_res = ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n-            replace_bound_regions(tcx, span, isr, t)\n-        };\n-        #debug[\"Result of universal quant. is %s\", fcx.ty_to_str(t_res)];\n-        t_res\n-    }\n-}\n-\n-// Replaces all region parameters in the given type with region variables.\n-// Does not descend into fn types.  This is used when deciding whether an impl\n-// applies at a given call site.  See also universally_quantify_before_call().\n-fn universally_quantify_regions(fcx: @fn_ctxt,\n-                                span: span,\n-                                ty: ty::t) -> ty::t {\n-    universally_quantify_from_sty(fcx, span, [ty], ty::get(ty).struct)\n-}\n-\n-// Expects a function type.  Replaces all region parameters in the arguments\n-// and return type with fresh region variables. This is used when typechecking\n-// function calls, bind expressions, and method calls.\n-fn universally_quantify_before_call(fcx: @fn_ctxt,\n-                                    span: span,\n-                                    ty: ty::t) -> ty::t {\n-\n-    #debug[\"universally_quantify_before_call(ty=%s)\",\n-           fcx.ty_to_str(ty)];\n-\n-    // This is subtle: we expect `ty` to be a function type, which normally\n-    // introduce a level of binding.  In this case, we want to process the\n-    // types bound by the function but not by any nested functions.\n-    // Therefore, we match one level of structure.\n-    alt structure_of(fcx, span, ty) {\n-      sty @ ty::ty_fn(fty) {\n-        let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n-        universally_quantify_from_sty(fcx, span, all_tys, sty)\n-      }\n-      sty {\n-        #debug[\"not a fn ty: %?\", sty];\n-\n-        // if not a function type, we're gonna' report an error\n-        // at some point, since the user is trying to call this thing\n-        ty\n-      }\n-    }\n-}\n-\n-fn replace_bound_regions(\n-    tcx: ty::ctxt,\n-    span: span,\n-    isr: isr_alist,\n-    ty: ty::t) -> ty::t {\n-\n-    ty::fold_regions(tcx, ty) { |r, in_fn|\n-        alt r {\n-          // As long as we are not within a fn() type, `&T` is mapped to the\n-          // free region anon_r.  But within a fn type, it remains bound.\n-          ty::re_bound(ty::br_anon) if in_fn { r }\n-\n-          ty::re_bound(br) {\n-            alt isr.find(br) {\n-              // In most cases, all named, bound regions will be mapped to\n-              // some free region.\n-              some(fr) { fr }\n-\n-              // But in the case of a fn() type, there may be named regions\n-              // within that remain bound:\n-              none if in_fn { r }\n-              none {\n-                tcx.sess.span_bug(\n-                    span,\n-                    #fmt[\"Bound region not found in \\\n-                          in_scope_regions list: %s\",\n-                         region_to_str(tcx, r)]);\n-              }\n-            }\n-          }\n-\n-          // Free regions like these just stay the same:\n-          ty::re_static |\n-          ty::re_scope(_) |\n-          ty::re_free(_, _) |\n-          ty::re_var(_) { r }\n-        }\n-    }\n-}\n-\n fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     check_expr(fcx, expr, some(expected))\n }\n@@ -770,300 +717,6 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n     {substs: substs, ty: substd_ty}\n }\n \n-type self_subst = {selfty: ty::t,\n-                   fcx: @fn_ctxt,\n-                   sp: span};\n-\n-enum lookup = {\n-    fcx: @fn_ctxt,\n-    expr: @ast::expr, // expr for a.b in a.b()\n-    node_id: ast::node_id, // node id of call (not always expr.id)\n-    m_name: ast::ident, // b in a.b(...)\n-    self_ty: ty::t, // type of a in a.b(...)\n-    supplied_tps: [ty::t], // Xs in a.b::<Xs>(...)\n-    include_private: bool\n-};\n-\n-impl methods for lookup {\n-    // Entrypoint:\n-    fn method() -> option<method_origin> {\n-        // First, see whether this is an interface-bounded parameter\n-        let pass1 = alt ty::get(self.self_ty).struct {\n-          ty::ty_param(n, did) {\n-            self.method_from_param(n, did)\n-          }\n-          ty::ty_iface(did, substs) {\n-            self.method_from_iface(did, substs)\n-          }\n-          ty::ty_class(did, substs) {\n-            self.method_from_class(did, substs)\n-          }\n-          _ {\n-            none\n-          }\n-        };\n-\n-        alt pass1 {\n-          some(r) { some(r) }\n-          none { self.method_from_scope() }\n-        }\n-    }\n-\n-    fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n-\n-    fn method_from_param(n: uint, did: ast::def_id) -> option<method_origin> {\n-        let tcx = self.tcx();\n-        let mut iface_bnd_idx = 0u; // count only iface bounds\n-        let bounds = tcx.ty_param_bounds.get(did.node);\n-        for vec::each(*bounds) {|bound|\n-            let (iid, bound_substs) = alt bound {\n-              ty::bound_copy | ty::bound_send { cont; /* ok */ }\n-              ty::bound_iface(bound_t) {\n-                alt check ty::get(bound_t).struct {\n-                  ty::ty_iface(i, substs) { (i, substs) }\n-                }\n-              }\n-            };\n-\n-            let ifce_methods = ty::iface_methods(tcx, iid);\n-            alt vec::position(*ifce_methods, {|m| m.ident == self.m_name}) {\n-              none {\n-                /* check next bound */\n-                iface_bnd_idx += 1u;\n-              }\n-\n-              some(pos) {\n-                // Replace any appearance of `self` with the type of the\n-                // generic parameter itself.  Note that this is the only case\n-                // where this replacement is necessary: in all other cases, we\n-                // are either invoking a method directly from an impl or class\n-                // (where the self type is not permitted), or from a iface\n-                // type (in which case methods that refer to self are not\n-                // permitted).\n-                let substs = {self_ty: some(self.self_ty)\n-                              with bound_substs};\n-\n-                ret some(self.write_mty_from_m(\n-                    substs, ifce_methods[pos],\n-                    method_param(iid, pos, n, iface_bnd_idx)));\n-              }\n-            }\n-        }\n-        ret none;\n-    }\n-\n-    fn method_from_iface(\n-        did: ast::def_id, iface_substs: ty::substs) -> option<method_origin> {\n-\n-        let ms = *ty::iface_methods(self.tcx(), did);\n-        for ms.eachi {|i, m|\n-            if m.ident != self.m_name { cont; }\n-\n-            let m_fty = ty::mk_fn(self.tcx(), m.fty);\n-\n-            if ty::type_has_self(m_fty) {\n-                self.tcx().sess.span_err(\n-                    self.expr.span,\n-                    \"can not call a method that contains a \\\n-                     self type through a boxed iface\");\n-            }\n-\n-            if (*m.tps).len() > 0u {\n-                self.tcx().sess.span_err(\n-                    self.expr.span,\n-                    \"can not call a generic method through a \\\n-                     boxed iface\");\n-            }\n-\n-            // Note: although it is illegal to invoke a method that uses self\n-            // through a iface instance, we use a dummy subst here so that we\n-            // can soldier on with the compilation.\n-            let substs = {self_ty: some(self.self_ty)\n-                          with iface_substs};\n-\n-            ret some(self.write_mty_from_m(\n-                substs, m, method_iface(did, i)));\n-        }\n-\n-        ret none;\n-    }\n-\n-    fn method_from_class(did: ast::def_id, class_substs: ty::substs)\n-        -> option<method_origin> {\n-\n-        let ms = *ty::iface_methods(self.tcx(), did);\n-\n-        for ms.each {|m|\n-            if m.ident != self.m_name { cont; }\n-\n-            if m.vis == ast::private && !self.include_private {\n-                self.tcx().sess.span_fatal(\n-                    self.expr.span,\n-                    \"Call to private method not allowed outside \\\n-                     its defining class\");\n-            }\n-\n-            // look up method named <name>.\n-            let m_declared = ty::lookup_class_method_by_name(\n-                self.tcx(), did, self.m_name, self.expr.span);\n-\n-            ret some(self.write_mty_from_m(\n-                class_substs, m,\n-                method_static(m_declared)));\n-        }\n-\n-        ret none;\n-    }\n-\n-    fn ty_from_did(did: ast::def_id) -> ty::t {\n-        alt check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n-          ty::ty_fn(fty) {\n-            ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n-          }\n-        }\n-        /*\n-        if did.crate == ast::local_crate {\n-            alt check self.tcx().items.get(did.node) {\n-              ast_map::node_method(m, _, _) {\n-                // NDM iface/impl regions\n-                let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n-                ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n-              }\n-            }\n-        } else {\n-            alt check ty::get(csearch::get_type(self.tcx(), did).ty).struct {\n-              ty::ty_fn(fty) {\n-                ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n-              }\n-            }\n-        }\n-        */\n-    }\n-\n-    fn method_from_scope() -> option<method_origin> {\n-        let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n-\n-        for list::each(impls_vecs) {|impls|\n-            let mut results = [];\n-            for vec::each(*impls) {|im|\n-                // Check whether this impl has a method with the right name.\n-                for im.methods.find({|m| m.ident == self.m_name}).each {|m|\n-\n-                    // determine the `self` with fresh variables for\n-                    // each parameter:\n-                    let {substs: self_substs, ty: self_ty} =\n-                        impl_self_ty(self.fcx, im.did);\n-\n-                    // Here \"self\" refers to the callee side...\n-                    let self_ty =\n-                        universally_quantify_regions(\n-                            self.fcx, self.expr.span, self_ty);\n-\n-                    // ... and \"ty\" refers to the caller side.\n-                    let ty =\n-                        universally_quantify_regions(\n-                            self.fcx, self.expr.span, self.self_ty);\n-\n-                    // if we can assign the caller to the callee, that's a\n-                    // potential match.  Collect those in the vector.\n-                    alt self.fcx.mk_subty(ty, self_ty) {\n-                      result::err(_) { /* keep looking */ }\n-                      result::ok(_) {\n-                        results += [(self_substs, m.n_tps, m.did)];\n-                      }\n-                    }\n-                }\n-            }\n-\n-            if results.len() >= 1u {\n-                if results.len() > 1u {\n-                    self.tcx().sess.span_err(\n-                        self.expr.span,\n-                        \"multiple applicable methods in scope\");\n-\n-                    // I would like to print out how each impl was imported,\n-                    // but I cannot for the life of me figure out how to\n-                    // annotate resolve to preserve this information.\n-                    for results.eachi { |i, result|\n-                        let (_, _, did) = result;\n-                        let span = if did.crate == ast::local_crate {\n-                            alt check self.tcx().items.get(did.node) {\n-                              ast_map::node_method(m, _, _) { m.span }\n-                            }\n-                        } else {\n-                            self.expr.span\n-                        };\n-                        self.tcx().sess.span_note(\n-                            span,\n-                            #fmt[\"candidate #%u is %s\",\n-                                 (i+1u),\n-                                 ty::item_path_str(self.tcx(), did)]);\n-                    }\n-                }\n-\n-                let (self_substs, n_tps, did) = results[0];\n-                let fty = self.ty_from_did(did);\n-                ret some(self.write_mty_from_fty(\n-                    self_substs, n_tps, fty,\n-                    method_static(did)));\n-            }\n-        }\n-\n-        ret none;\n-    }\n-\n-    fn write_mty_from_m(self_substs: ty::substs,\n-                        m: ty::method,\n-                        origin: method_origin) -> method_origin {\n-        let tcx = self.fcx.ccx.tcx;\n-\n-        // a bit hokey, but the method unbound has a bare protocol, whereas\n-        // a.b has a protocol like fn@() (perhaps eventually fn&()):\n-        let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n-\n-        ret self.write_mty_from_fty(self_substs, (*m.tps).len(),\n-                                    fty, origin);\n-    }\n-\n-    fn write_mty_from_fty(self_substs: ty::substs,\n-                          n_tps_m: uint,\n-                          fty: ty::t,\n-                          origin: method_origin) -> method_origin {\n-\n-        let tcx = self.fcx.ccx.tcx;\n-\n-        // Here I will use the \"c_\" prefix to refer to the method's\n-        // owner.  You can read it as class, but it may also be an iface.\n-\n-        let n_tps_supplied = self.supplied_tps.len();\n-        let m_substs = {\n-            if n_tps_supplied == 0u {\n-                self.fcx.next_ty_vars(n_tps_m)\n-            } else if n_tps_m == 0u {\n-                tcx.sess.span_err(\n-                    self.expr.span,\n-                    \"this method does not take type parameters\");\n-                self.fcx.next_ty_vars(n_tps_m)\n-            } else if n_tps_supplied != n_tps_m {\n-                tcx.sess.span_err(\n-                    self.expr.span,\n-                    \"incorrect number of type \\\n-                     parameters given for this method\");\n-                self.fcx.next_ty_vars(n_tps_m)\n-            } else {\n-                self.supplied_tps\n-            }\n-        };\n-\n-        let all_substs = {tps: self_substs.tps + m_substs\n-                          with self_substs};\n-\n-        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n-\n-        ret origin;\n-    }\n-}\n-\n // Only for fields! Returns <none> for methods>\n // FIXME: privacy flags\n fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n@@ -1076,47 +729,6 @@ fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n     }\n }\n \n-/* Returns the region that &expr should be placed into.  If expr is an\n- * lvalue, this will be the region of the lvalue.  Otherwise, if region is\n- * an rvalue, the semantics are that the result is stored into a temporary\n- * stack position and so the resulting region will be the enclosing block.\n- */\n-fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n-    fn borrow(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n-        ty::encl_region(fcx.ccx.tcx, expr.id)\n-    }\n-\n-    fn deref(fcx: @fn_ctxt, base: @ast::expr) -> ty::region {\n-        let base_ty = fcx.expr_ty(base);\n-        let base_ty = structurally_resolved_type(fcx, base.span, base_ty);\n-        alt ty::get(base_ty).struct {\n-          ty::ty_rptr(region, _) { region }\n-          ty::ty_box(_) | ty::ty_uniq(_) { borrow(fcx, base) }\n-          _ { region_of(fcx, base) }\n-        }\n-    }\n-\n-    alt expr.node {\n-      ast::expr_path(path) {\n-        let defn = lookup_def(fcx, path.span, expr.id);\n-        alt defn {\n-          ast::def_local(local_id, _) |\n-          ast::def_upvar(local_id, _, _) {\n-            let local_scope = fcx.ccx.tcx.region_map.get(local_id);\n-            ty::re_scope(local_scope)\n-          }\n-          _ {\n-            ty::re_static\n-          }\n-        }\n-      }\n-      ast::expr_field(base, _, _) { deref(fcx, base) }\n-      ast::expr_index(base, _) { deref(fcx, base) }\n-      ast::expr_unary(ast::deref, base) { deref(fcx, base) }\n-      _ { borrow(fcx, expr) }\n-    }\n-}\n-\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: option<ty::t>,\n@@ -1133,7 +745,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let mut bot = false;\n \n-        let fty = universally_quantify_before_call(fcx, sp, fty);\n+        let fty = universally_quantify_regions_before_call(fcx, sp, fty);\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.ty_to_str(fty)];\n \n@@ -1291,13 +903,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         opname: str, args: [option<@ast::expr>])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n-        let lkup = lookup({fcx: fcx,\n-                           expr: op_ex,\n-                           node_id: callee_id,\n-                           m_name: opname,\n-                           self_ty: self_t,\n-                           supplied_tps: [],\n-                           include_private: false});\n+        let lkup = method::lookup({fcx: fcx,\n+                                   expr: op_ex,\n+                                   node_id: callee_id,\n+                                   m_name: opname,\n+                                   self_ty: self_t,\n+                                   supplied_tps: [],\n+                                   include_private: false});\n         alt lkup.method() {\n           some(origin) {\n             let {fty: method_ty, bot: bot} = {\n@@ -1977,13 +1589,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         if !handled {\n             let tps = vec::map(tys) { |ty| fcx.to_ty(ty) };\n-            let lkup = lookup({fcx: fcx,\n-                               expr: expr,\n-                               node_id: expr.id,\n-                               m_name: field,\n-                               self_ty: expr_t,\n-                               supplied_tps: tps,\n-                               include_private: self_ref(fcx, base.id)});\n+            let is_self_ref = self_ref(fcx, base.id);\n+            let lkup = method::lookup({fcx: fcx,\n+                                      expr: expr,\n+                                      node_id: expr.id,\n+                                      m_name: field,\n+                                      self_ty: expr_t,\n+                                      supplied_tps: tps,\n+                                      include_private: is_self_ref});\n             alt lkup.method() {\n               some(origin) {\n                 fcx.ccx.method_map.insert(id, origin);\n@@ -2032,13 +1645,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let p_ty = fcx.expr_ty(p);\n \n-        let lkup = lookup({fcx: fcx,\n-                           expr: p,\n-                           node_id: alloc_id,\n-                           m_name: \"alloc\",\n-                           self_ty: p_ty,\n-                           supplied_tps: [],\n-                           include_private: false});\n+        let lkup = method::lookup({fcx: fcx,\n+                                   expr: p,\n+                                   node_id: alloc_id,\n+                                   m_name: \"alloc\",\n+                                   self_ty: p_ty,\n+                                   supplied_tps: [],\n+                                   include_private: false});\n         alt lkup.method() {\n           some(origin) {\n             fcx.ccx.method_map.insert(alloc_id, origin);\n@@ -2431,52 +2044,6 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     }\n }\n \n-type fn_ctxt =\n-    // var_bindings, locals and next_var_id are shared\n-    // with any nested functions that capture the environment\n-    // (and with any functions whose environment is being captured).\n-    {self_ty: option<ty::t>,\n-     ret_ty: ty::t,\n-     // Used by loop bodies that return from the outer function\n-     indirect_ret_ty: option<ty::t>,\n-     purity: ast::purity,\n-     proto: ast::proto,\n-     infcx: infer::infer_ctxt,\n-     locals: hashmap<ast::node_id, ty_vid>,\n-     ty_var_counter: @mut uint,\n-     region_var_counter: @mut uint,\n-\n-     mut blocks: [ast::node_id], // stack of blocks in scope, may be empty\n-     in_scope_regions: isr_alist,\n-\n-     // While type checking a function, the intermediate types for the\n-     // expressions, blocks, and so forth contained within the function are\n-     // stored in these tables.  These types may contain unresolved type\n-     // variables.  After type checking is complete, the functions in the\n-     // writeback module are used to take the types from this table, resolve\n-     // them, and then write them into their permanent home in the type\n-     // context `ccx.tcx`.\n-     //\n-     // This means that during inferencing you should use `fcx.write_ty()`\n-     // and `fcx.expr_ty()` / `fcx.node_ty()` to write/obtain the types of\n-     // nodes within the function.\n-     //\n-     // The types of top-level items, which never contain unbound type\n-     // variables, are stored directly into the `tcx` tables.\n-     //\n-     // n.b.: A type variable is not the same thing as a type parameter.  A\n-     // type variable is rather an \"instance\" of a type parameter: that is,\n-     // given a generic function `fn foo<T>(t: T)`: while checking the\n-     // function `foo`, the type `ty_param(0)` refers to the type `T`, which\n-     // is treated in abstract.  When `foo()` is called, however, `T` will be\n-     // substituted for a fresh type variable `ty_var(N)`.  This variable will\n-     // eventually be resolved to some concrete type (which might itself be\n-     // type parameter).\n-     node_types: smallintmap::smallintmap<ty::t>,\n-     node_type_substs: hashmap<ast::node_id, ty::substs>,\n-\n-     ccx: @crate_ctxt};\n-\n // Determines whether the given node ID is a use of the def of\n // the self ID for the current method, if there is one\n // self IDs in an outer scope count. so that means that you can\n@@ -2711,52 +2278,3 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     }\n }\n \n-type next_region_param_id = { mut id: uint };\n-\n-fn collect_bound_regions_in_tys(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    tys: [ty::t],\n-    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n-\n-    tys.foldl(isr) { |isr, t|\n-        collect_bound_regions_in_ty(tcx, isr, t, to_r)\n-    }\n-}\n-\n-fn collect_bound_regions_in_ty(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    ty: ty::t,\n-    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n-\n-    fn append_isr(isr: isr_alist,\n-                  to_r: fn(ty::bound_region) -> ty::region,\n-                  r: ty::region) -> isr_alist {\n-        alt r {\n-          ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n-          ty::re_var(_) {\n-            isr\n-          }\n-          ty::re_bound(br) {\n-            alt isr.find(br) {\n-              some(_) { isr }\n-              none { @cons((br, to_r(br)), isr) }\n-            }\n-          }\n-        }\n-    }\n-\n-    let mut isr = isr;\n-\n-    // Using fold_regions is inefficient, because it constructs new types, but\n-    // it avoids code duplication in terms of locating all the regions within\n-    // the various kinds of types.  This had already caused me several bugs\n-    // so I decided to switch over.\n-    ty::fold_regions(tcx, ty) { |r, in_fn|\n-        if !in_fn { isr = append_isr(isr, to_r, r); }\n-        r\n-    };\n-\n-    ret isr;\n-}"}, {"sha": "18ea67e2ad408a09b45585c8becab9ee33026c70", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=558be3a70f20072b415f7436b3130462caefa63a", "patch": "@@ -0,0 +1,294 @@\n+/* Code to handle method lookups (which can be quite complex) */\n+\n+import regionmanip::universally_quantify_regions;\n+\n+enum lookup = {\n+    fcx: @fn_ctxt,\n+    expr: @ast::expr, // expr for a.b in a.b()\n+    node_id: ast::node_id, // node id of call (not always expr.id)\n+    m_name: ast::ident, // b in a.b(...)\n+    self_ty: ty::t, // type of a in a.b(...)\n+    supplied_tps: [ty::t], // Xs in a.b::<Xs>(...)\n+    include_private: bool\n+};\n+\n+impl methods for lookup {\n+    // Entrypoint:\n+    fn method() -> option<method_origin> {\n+        // First, see whether this is an interface-bounded parameter\n+        let pass1 = alt ty::get(self.self_ty).struct {\n+          ty::ty_param(n, did) {\n+            self.method_from_param(n, did)\n+          }\n+          ty::ty_iface(did, substs) {\n+            self.method_from_iface(did, substs)\n+          }\n+          ty::ty_class(did, substs) {\n+            self.method_from_class(did, substs)\n+          }\n+          _ {\n+            none\n+          }\n+        };\n+\n+        alt pass1 {\n+          some(r) { some(r) }\n+          none { self.method_from_scope() }\n+        }\n+    }\n+\n+    fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n+\n+    fn method_from_param(n: uint, did: ast::def_id) -> option<method_origin> {\n+        let tcx = self.tcx();\n+        let mut iface_bnd_idx = 0u; // count only iface bounds\n+        let bounds = tcx.ty_param_bounds.get(did.node);\n+        for vec::each(*bounds) {|bound|\n+            let (iid, bound_substs) = alt bound {\n+              ty::bound_copy | ty::bound_send { cont; /* ok */ }\n+              ty::bound_iface(bound_t) {\n+                alt check ty::get(bound_t).struct {\n+                  ty::ty_iface(i, substs) { (i, substs) }\n+                }\n+              }\n+            };\n+\n+            let ifce_methods = ty::iface_methods(tcx, iid);\n+            alt vec::position(*ifce_methods, {|m| m.ident == self.m_name}) {\n+              none {\n+                /* check next bound */\n+                iface_bnd_idx += 1u;\n+              }\n+\n+              some(pos) {\n+                // Replace any appearance of `self` with the type of the\n+                // generic parameter itself.  Note that this is the only case\n+                // where this replacement is necessary: in all other cases, we\n+                // are either invoking a method directly from an impl or class\n+                // (where the self type is not permitted), or from a iface\n+                // type (in which case methods that refer to self are not\n+                // permitted).\n+                let substs = {self_ty: some(self.self_ty)\n+                              with bound_substs};\n+\n+                ret some(self.write_mty_from_m(\n+                    substs, ifce_methods[pos],\n+                    method_param(iid, pos, n, iface_bnd_idx)));\n+              }\n+            }\n+        }\n+        ret none;\n+    }\n+\n+    fn method_from_iface(\n+        did: ast::def_id, iface_substs: ty::substs) -> option<method_origin> {\n+\n+        let ms = *ty::iface_methods(self.tcx(), did);\n+        for ms.eachi {|i, m|\n+            if m.ident != self.m_name { cont; }\n+\n+            let m_fty = ty::mk_fn(self.tcx(), m.fty);\n+\n+            if ty::type_has_self(m_fty) {\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"can not call a method that contains a \\\n+                     self type through a boxed iface\");\n+            }\n+\n+            if (*m.tps).len() > 0u {\n+                self.tcx().sess.span_err(\n+                    self.expr.span,\n+                    \"can not call a generic method through a \\\n+                     boxed iface\");\n+            }\n+\n+            // Note: although it is illegal to invoke a method that uses self\n+            // through a iface instance, we use a dummy subst here so that we\n+            // can soldier on with the compilation.\n+            let substs = {self_ty: some(self.self_ty)\n+                          with iface_substs};\n+\n+            ret some(self.write_mty_from_m(\n+                substs, m, method_iface(did, i)));\n+        }\n+\n+        ret none;\n+    }\n+\n+    fn method_from_class(did: ast::def_id, class_substs: ty::substs)\n+        -> option<method_origin> {\n+\n+        let ms = *ty::iface_methods(self.tcx(), did);\n+\n+        for ms.each {|m|\n+            if m.ident != self.m_name { cont; }\n+\n+            if m.vis == ast::private && !self.include_private {\n+                self.tcx().sess.span_fatal(\n+                    self.expr.span,\n+                    \"Call to private method not allowed outside \\\n+                     its defining class\");\n+            }\n+\n+            // look up method named <name>.\n+            let m_declared = ty::lookup_class_method_by_name(\n+                self.tcx(), did, self.m_name, self.expr.span);\n+\n+            ret some(self.write_mty_from_m(\n+                class_substs, m,\n+                method_static(m_declared)));\n+        }\n+\n+        ret none;\n+    }\n+\n+    fn ty_from_did(did: ast::def_id) -> ty::t {\n+        alt check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n+          ty::ty_fn(fty) {\n+            ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n+          }\n+        }\n+        /*\n+        if did.crate == ast::local_crate {\n+            alt check self.tcx().items.get(did.node) {\n+              ast_map::node_method(m, _, _) {\n+                // NDM iface/impl regions\n+                let mt = ty_of_method(self.fcx.ccx, m, ast::rp_none);\n+                ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n+              }\n+            }\n+        } else {\n+            alt check ty::get(csearch::get_type(self.tcx(), did).ty).struct {\n+              ty::ty_fn(fty) {\n+                ty::mk_fn(self.tcx(), {proto: ast::proto_box with fty})\n+              }\n+            }\n+        }\n+        */\n+    }\n+\n+    fn method_from_scope() -> option<method_origin> {\n+        let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n+\n+        for list::each(impls_vecs) {|impls|\n+            let mut results = [];\n+            for vec::each(*impls) {|im|\n+                // Check whether this impl has a method with the right name.\n+                for im.methods.find({|m| m.ident == self.m_name}).each {|m|\n+\n+                    // determine the `self` with fresh variables for\n+                    // each parameter:\n+                    let {substs: self_substs, ty: self_ty} =\n+                        impl_self_ty(self.fcx, im.did);\n+\n+                    // Here \"self\" refers to the callee side...\n+                    let self_ty =\n+                        universally_quantify_regions(\n+                            self.fcx, self.expr.span, self_ty);\n+\n+                    // ... and \"ty\" refers to the caller side.\n+                    let ty =\n+                        universally_quantify_regions(\n+                            self.fcx, self.expr.span, self.self_ty);\n+\n+                    // if we can assign the caller to the callee, that's a\n+                    // potential match.  Collect those in the vector.\n+                    alt self.fcx.mk_subty(ty, self_ty) {\n+                      result::err(_) { /* keep looking */ }\n+                      result::ok(_) {\n+                        results += [(self_substs, m.n_tps, m.did)];\n+                      }\n+                    }\n+                }\n+            }\n+\n+            if results.len() >= 1u {\n+                if results.len() > 1u {\n+                    self.tcx().sess.span_err(\n+                        self.expr.span,\n+                        \"multiple applicable methods in scope\");\n+\n+                    // I would like to print out how each impl was imported,\n+                    // but I cannot for the life of me figure out how to\n+                    // annotate resolve to preserve this information.\n+                    for results.eachi { |i, result|\n+                        let (_, _, did) = result;\n+                        let span = if did.crate == ast::local_crate {\n+                            alt check self.tcx().items.get(did.node) {\n+                              ast_map::node_method(m, _, _) { m.span }\n+                            }\n+                        } else {\n+                            self.expr.span\n+                        };\n+                        self.tcx().sess.span_note(\n+                            span,\n+                            #fmt[\"candidate #%u is %s\",\n+                                 (i+1u),\n+                                 ty::item_path_str(self.tcx(), did)]);\n+                    }\n+                }\n+\n+                let (self_substs, n_tps, did) = results[0];\n+                let fty = self.ty_from_did(did);\n+                ret some(self.write_mty_from_fty(\n+                    self_substs, n_tps, fty,\n+                    method_static(did)));\n+            }\n+        }\n+\n+        ret none;\n+    }\n+\n+    fn write_mty_from_m(self_substs: ty::substs,\n+                        m: ty::method,\n+                        origin: method_origin) -> method_origin {\n+        let tcx = self.fcx.ccx.tcx;\n+\n+        // a bit hokey, but the method unbound has a bare protocol, whereas\n+        // a.b has a protocol like fn@() (perhaps eventually fn&()):\n+        let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n+\n+        ret self.write_mty_from_fty(self_substs, (*m.tps).len(),\n+                                    fty, origin);\n+    }\n+\n+    fn write_mty_from_fty(self_substs: ty::substs,\n+                          n_tps_m: uint,\n+                          fty: ty::t,\n+                          origin: method_origin) -> method_origin {\n+\n+        let tcx = self.fcx.ccx.tcx;\n+\n+        // Here I will use the \"c_\" prefix to refer to the method's\n+        // owner.  You can read it as class, but it may also be an iface.\n+\n+        let n_tps_supplied = self.supplied_tps.len();\n+        let m_substs = {\n+            if n_tps_supplied == 0u {\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else if n_tps_m == 0u {\n+                tcx.sess.span_err(\n+                    self.expr.span,\n+                    \"this method does not take type parameters\");\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else if n_tps_supplied != n_tps_m {\n+                tcx.sess.span_err(\n+                    self.expr.span,\n+                    \"incorrect number of type \\\n+                     parameters given for this method\");\n+                self.fcx.next_ty_vars(n_tps_m)\n+            } else {\n+                self.supplied_tps\n+            }\n+        };\n+\n+        let all_substs = {tps: self_substs.tps + m_substs\n+                          with self_substs};\n+\n+        self.fcx.write_ty_substs(self.node_id, fty, all_substs);\n+\n+        ret origin;\n+    }\n+}\n+"}, {"sha": "7fb4409d9701f1e0ed9ed25c8eb315238b0e21f3", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=558be3a70f20072b415f7436b3130462caefa63a", "patch": "@@ -0,0 +1,195 @@\n+// Helper functions related to manipulating region types.\n+\n+// Helper for the other universally_quantify_*() routines.  Extracts the bound\n+// regions from bound_tys and then replaces those same regions with fresh\n+// variables in `sty`, returning the resulting type.\n+fn universally_quantify_from_sty(fcx: @fn_ctxt,\n+                                 span: span,\n+                                 bound_tys: [ty::t],\n+                                 sty: ty::sty) -> ty::t {\n+\n+    #debug[\"universally_quantify_from_sty(bound_tys=%?)\",\n+           bound_tys.map {|x| fcx.ty_to_str(x) }];\n+    indent {||\n+        let tcx = fcx.tcx();\n+        let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n+            let rvar = fcx.next_region_var();\n+            #debug[\"Bound region %s maps to %s\",\n+                   bound_region_to_str(fcx.ccx.tcx, br),\n+                   region_to_str(fcx.ccx.tcx, rvar)];\n+            rvar\n+        };\n+        let t_res = ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n+            replace_bound_regions(tcx, span, isr, t)\n+        };\n+        #debug[\"Result of universal quant. is %s\", fcx.ty_to_str(t_res)];\n+        t_res\n+    }\n+}\n+\n+// Replaces all region parameters in the given type with region variables.\n+// Does not descend into fn types.  This is used when deciding whether an impl\n+// applies at a given call site.  See also universally_quantify_before_call().\n+fn universally_quantify_regions(fcx: @fn_ctxt,\n+                                span: span,\n+                                ty: ty::t) -> ty::t {\n+    universally_quantify_from_sty(fcx, span, [ty], ty::get(ty).struct)\n+}\n+\n+// Expects a function type.  Replaces all region parameters in the arguments\n+// and return type with fresh region variables. This is used when typechecking\n+// function calls, bind expressions, and method calls.\n+fn universally_quantify_regions_before_call(fcx: @fn_ctxt,\n+                                            span: span,\n+                                            ty: ty::t) -> ty::t {\n+\n+    #debug[\"universally_quantify_before_call(ty=%s)\",\n+           fcx.ty_to_str(ty)];\n+\n+    // This is subtle: we expect `ty` to be a function type, which normally\n+    // introduce a level of binding.  In this case, we want to process the\n+    // types bound by the function but not by any nested functions.\n+    // Therefore, we match one level of structure.\n+    alt structure_of(fcx, span, ty) {\n+      sty @ ty::ty_fn(fty) {\n+        let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n+        universally_quantify_from_sty(fcx, span, all_tys, sty)\n+      }\n+      sty {\n+        #debug[\"not a fn ty: %?\", sty];\n+\n+        // if not a function type, we're gonna' report an error\n+        // at some point, since the user is trying to call this thing\n+        ty\n+      }\n+    }\n+}\n+\n+fn replace_bound_regions(\n+    tcx: ty::ctxt,\n+    span: span,\n+    isr: isr_alist,\n+    ty: ty::t) -> ty::t {\n+\n+    ty::fold_regions(tcx, ty) { |r, in_fn|\n+        alt r {\n+          // As long as we are not within a fn() type, `&T` is mapped to the\n+          // free region anon_r.  But within a fn type, it remains bound.\n+          ty::re_bound(ty::br_anon) if in_fn { r }\n+\n+          ty::re_bound(br) {\n+            alt isr.find(br) {\n+              // In most cases, all named, bound regions will be mapped to\n+              // some free region.\n+              some(fr) { fr }\n+\n+              // But in the case of a fn() type, there may be named regions\n+              // within that remain bound:\n+              none if in_fn { r }\n+              none {\n+                tcx.sess.span_bug(\n+                    span,\n+                    #fmt[\"Bound region not found in \\\n+                          in_scope_regions list: %s\",\n+                         region_to_str(tcx, r)]);\n+              }\n+            }\n+          }\n+\n+          // Free regions like these just stay the same:\n+          ty::re_static |\n+          ty::re_scope(_) |\n+          ty::re_free(_, _) |\n+          ty::re_var(_) { r }\n+        }\n+    }\n+}\n+\n+/* Returns the region that &expr should be placed into.  If expr is an\n+ * lvalue, this will be the region of the lvalue.  Otherwise, if region is\n+ * an rvalue, the semantics are that the result is stored into a temporary\n+ * stack position and so the resulting region will be the enclosing block.\n+ */\n+fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n+    fn borrow(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n+        ty::encl_region(fcx.ccx.tcx, expr.id)\n+    }\n+\n+    fn deref(fcx: @fn_ctxt, base: @ast::expr) -> ty::region {\n+        let base_ty = fcx.expr_ty(base);\n+        let base_ty = structurally_resolved_type(fcx, base.span, base_ty);\n+        alt ty::get(base_ty).struct {\n+          ty::ty_rptr(region, _) { region }\n+          ty::ty_box(_) | ty::ty_uniq(_) { borrow(fcx, base) }\n+          _ { region_of(fcx, base) }\n+        }\n+    }\n+\n+    alt expr.node {\n+      ast::expr_path(path) {\n+        let defn = lookup_def(fcx, path.span, expr.id);\n+        alt defn {\n+          ast::def_local(local_id, _) |\n+          ast::def_upvar(local_id, _, _) {\n+            let local_scope = fcx.ccx.tcx.region_map.get(local_id);\n+            ty::re_scope(local_scope)\n+          }\n+          _ {\n+            ty::re_static\n+          }\n+        }\n+      }\n+      ast::expr_field(base, _, _) { deref(fcx, base) }\n+      ast::expr_index(base, _) { deref(fcx, base) }\n+      ast::expr_unary(ast::deref, base) { deref(fcx, base) }\n+      _ { borrow(fcx, expr) }\n+    }\n+}\n+\n+fn collect_bound_regions_in_tys(\n+    tcx: ty::ctxt,\n+    isr: isr_alist,\n+    tys: [ty::t],\n+    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n+\n+    tys.foldl(isr) { |isr, t|\n+        collect_bound_regions_in_ty(tcx, isr, t, to_r)\n+    }\n+}\n+\n+fn collect_bound_regions_in_ty(\n+    tcx: ty::ctxt,\n+    isr: isr_alist,\n+    ty: ty::t,\n+    to_r: fn(ty::bound_region) -> ty::region) -> isr_alist {\n+\n+    fn append_isr(isr: isr_alist,\n+                  to_r: fn(ty::bound_region) -> ty::region,\n+                  r: ty::region) -> isr_alist {\n+        alt r {\n+          ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n+          ty::re_var(_) {\n+            isr\n+          }\n+          ty::re_bound(br) {\n+            alt isr.find(br) {\n+              some(_) { isr }\n+              none { @cons((br, to_r(br)), isr) }\n+            }\n+          }\n+        }\n+    }\n+\n+    let mut isr = isr;\n+\n+    // Using fold_regions is inefficient, because it constructs new types, but\n+    // it avoids code duplication in terms of locating all the regions within\n+    // the various kinds of types.  This had already caused me several bugs\n+    // so I decided to switch over.\n+    ty::fold_regions(tcx, ty) { |r, in_fn|\n+        if !in_fn { isr = append_isr(isr, to_r, r); }\n+        r\n+    };\n+\n+    ret isr;\n+}"}, {"sha": "74a48820d9da68fdba8d031c9d3eeffcdfec4212", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/558be3a70f20072b415f7436b3130462caefa63a/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=558be3a70f20072b415f7436b3130462caefa63a", "patch": "@@ -56,8 +56,10 @@ mod middle {\n             mod alt;\n             mod vtable;\n             mod writeback;\n+            mod regionmanip;\n             mod regionck;\n             mod demand;\n+            mod method;\n         }\n         mod astconv;\n         mod infer;"}]}