{"sha": "efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYWY0ZGIyNGM5MmUxMTllMjZkYzU3NWZmZDZiZmQzYjkxZmI4N2Q=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-23T10:29:35Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-23T20:44:10Z"}, "message": "Transition to new `Hash`, removing IterBytes and std::to_bytes.", "tree": {"sha": "e735230061b0c480550fdaad749a998bc48df78d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e735230061b0c480550fdaad749a998bc48df78d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "html_url": "https://github.com/rust-lang/rust/commit/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5444da54fd32b705eec28112e309f63b704e3f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5444da54fd32b705eec28112e309f63b704e3f8c", "html_url": "https://github.com/rust-lang/rust/commit/5444da54fd32b705eec28112e309f63b704e3f8c"}], "stats": {"total": 1607, "additions": 286, "deletions": 1321}, "files": [{"sha": "543b77ccdb9bd58cbc3b97c6109bda6b02055edd", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -38,7 +38,7 @@ order.\n Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n making the order of a set of keys in a given hash table randomized. Rust\n provides a [SipHash](https://131002.net/siphash/) implementation for any type\n-implementing the `IterBytes` trait.\n+implementing the `Hash` trait.\n \n ## Double-ended queues\n \n@@ -186,12 +186,12 @@ let mut calls = 0;\n     let it = xs.iter().scan((), |_, x| {\n         calls += 1;\n         if *x < 3 { Some(x) } else { None }});\n-        \n+\n     // the iterator will only yield 1 and 2 before returning None\n     // If we were to call it 5 times, calls would end up as 5, despite\n     // only 2 values being yielded (and therefore 3 unique calls being\n     // made). The fuse() adaptor can fix this.\n-    \n+\n     let mut it = it.fuse();\n     it.next();\n     it.next();"}, {"sha": "2646460346b56d57cb945accd711e899753ac46a", "filename": "src/doc/po/ja/tutorial.md.po", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fpo%2Fja%2Ftutorial.md.po?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -4421,15 +4421,15 @@ msgstr \"\"\n #, fuzzy\n #| msgid \"\"\n #| \"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n-#| \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, \"\n+#| \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, \"\n #| \"`Zero`, and `ToStr`.\"\n msgid \"\"\n \"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n-\"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, \"\n+\"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, \"\n \"`Default`, `Zero`, and `ToStr`.\"\n msgstr \"\"\n \"\u5b9f\u88c5\u3092\u81ea\u52d5\u7684\u306b\u5c0e\u51fa\u53ef\u80fd\u306a\u30c8\u30ec\u30a4\u30c8\u306f\u3001 `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n-\"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, `Zero`, \"\n+\"`Encodable` `Decodable`, `Clone`, `DeepClone`, `Hash`, `Rand`, `Zero`, \"\n \"\u304a\u3088\u3073 `ToStr` \u3067\u3059\u3002.\"\n \n #. type: Plain text"}, {"sha": "650bee7d335ce2bc78a6eccd410c22664fb9193e", "filename": "src/doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -2035,7 +2035,7 @@ Supported traits for `deriving` are:\n * Comparison traits: `Eq`, `TotalEq`, `Ord`, `TotalOrd`.\n * Serialization: `Encodable`, `Decodable`. These require `serialize`.\n * `Clone` and `DeepClone`, to perform (deep) copies.\n-* `IterBytes`, to iterate over the bytes in a data type.\n+* `Hash`, to iterate over the bytes in a data type.\n * `Rand`, to create a random instance of a data type.\n * `Default`, to create an empty instance of a data type.\n * `Zero`, to create an zero instance of a numeric data type."}, {"sha": "59e0bca5a97262f7403bfa7769e1f7e6650a10af", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -2525,7 +2525,7 @@ enum ABC { A, B, C }\n \n The full list of derivable traits is `Eq`, `TotalEq`, `Ord`,\n `TotalOrd`, `Encodable` `Decodable`, `Clone`, `DeepClone`,\n-`IterBytes`, `Rand`, `Default`, `Zero`, `FromPrimitive` and `Show`.\n+`Hash`, `Rand`, `Default`, `Zero`, `FromPrimitive` and `Show`.\n \n # Crates and the module system\n "}, {"sha": "837a87879b026d69782c5a19fd0891e2f18532e2", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -93,7 +93,6 @@ syn keyword rustTrait GenericPath Path PosixPath WindowsPath\n syn keyword rustTrait RawPtr\n syn keyword rustTrait Buffer Writer Reader Seek\n syn keyword rustTrait Str StrVector StrSlice OwnedStr IntoMaybeOwned\n-syn keyword rustTrait IterBytes\n syn keyword rustTrait ToStr IntoStr\n syn keyword rustTrait Tuple1 Tuple2 Tuple3 Tuple4\n syn keyword rustTrait Tuple5 Tuple6 Tuple7 Tuple8"}, {"sha": "0de6eaf53dd83aababd564d9660eb896d9dbf3f4", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -15,7 +15,7 @@\n \n use std::num::Bitwise;\n \n-#[deriving(Clone, Eq, IterBytes, ToStr, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Hash, ToStr, Encodable, Decodable)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {\n     // We must maintain the invariant that no bits are set"}, {"sha": "fe56dbdd2f14732b0c916075778a5dd9498801ef", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -54,7 +54,7 @@\n \n use std::cmp::max;\n use std::fmt;\n-use std::hash_old::Hash;\n+use std::hash::{Hash, Hasher, sip};\n use std::iter::{FilterMap, Chain, Repeat, Zip};\n use std::iter;\n use std::mem::replace;\n@@ -79,10 +79,7 @@ struct Bucket<K,V> {\n /// hash function for internal state. This means that the order of all hash maps\n /// is randomized by keying each hash map randomly on creation.\n ///\n-/// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by just implementing the `Eq` and\n-/// `IterBytes` traits as `Hash` is automatically implemented for types that\n-/// implement `IterBytes`.\n+/// It is required that the keys implement the `Eq` and `Hash` traits.\n pub struct HashMap<K,V> {\n     priv k0: u64,\n     priv k1: u64,\n@@ -131,14 +128,14 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n     #[inline]\n     fn bucket_for_key(&self, k: &K) -> SearchResult {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n         self.bucket_for_key_with_hash(hash, k)\n     }\n \n     #[inline]\n     fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n                                                -> SearchResult {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n \n@@ -339,14 +336,14 @@ impl<K:Hash + Eq,V> MutableMap<K, V> for HashMap<K, V> {\n             self.expand();\n         }\n \n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let hash = sip::hash_with_keys(self.k0, self.k1, &k) as uint;\n         self.insert_internal(hash, k, v)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     fn pop(&mut self, k: &K) -> Option<V> {\n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let hash = sip::hash_with_keys(self.k0, self.k1, k) as uint;\n         self.pop_internal(hash, k)\n     }\n }\n@@ -446,7 +443,7 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n             self.expand();\n         }\n \n-        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let hash = sip::hash_with_keys(self.k0, self.k1, &k) as uint;\n         let idx = match self.bucket_for_key_with_hash(hash, &k) {\n             TableFull => fail!(\"Internal logic error\"),\n             FoundEntry(idx) => { found(&k, self.mut_value_for_bucket(idx), a); idx }\n@@ -925,7 +922,7 @@ pub type SetAlgebraItems<'a, T> =\n \n impl<\n     E: Encoder,\n-    K: Encodable<E> + Hash + IterBytes + Eq,\n+    K: Encodable<E> + Hash + Eq,\n     V: Encodable<E>\n > Encodable<E> for HashMap<K, V> {\n     fn encode(&self, e: &mut E) {\n@@ -942,7 +939,7 @@ impl<\n \n impl<\n     D: Decoder,\n-    K: Decodable<D> + Hash + IterBytes + Eq,\n+    K: Decodable<D> + Hash + Eq,\n     V: Decodable<D>\n > Decodable<D> for HashMap<K, V> {\n     fn decode(d: &mut D) -> HashMap<K, V> {\n@@ -960,7 +957,7 @@ impl<\n \n impl<\n     S: Encoder,\n-    T: Encodable<S> + Hash + IterBytes + Eq\n+    T: Encodable<S> + Hash + Eq\n > Encodable<S> for HashSet<T> {\n     fn encode(&self, s: &mut S) {\n         s.emit_seq(self.len(), |s| {\n@@ -975,7 +972,7 @@ impl<\n \n impl<\n     D: Decoder,\n-    T: Decodable<D> + Hash + IterBytes + Eq\n+    T: Decodable<D> + Hash + Eq\n > Decodable<D> for HashSet<T> {\n     fn decode(d: &mut D) -> HashSet<T> {\n         d.read_seq(|d, len| {"}, {"sha": "ec387df7215d35efdab74ac8b27a05cf95bf53fd", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -38,7 +38,7 @@\n //! ```\n \n use std::container::Container;\n-use std::to_bytes::Cb;\n+use std::hash::{Hash, sip};\n use std::ptr;\n use std::cast;\n \n@@ -61,9 +61,9 @@ pub struct LruCache<K, V> {\n     priv tail: *mut LruEntry<K, V>,\n }\n \n-impl<K: IterBytes> IterBytes for KeyRef<K> {\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        unsafe{ (*self.k).iter_bytes(lsb0, f) }\n+impl<K: Hash> Hash for KeyRef<K> {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        unsafe {(*self.k).hash(s)}\n     }\n }\n \n@@ -93,7 +93,7 @@ impl<K, V> LruEntry<K, V> {\n     }\n }\n \n-impl<K: IterBytes + Eq, V> LruCache<K, V> {\n+impl<K: Hash + Eq, V> LruCache<K, V> {\n     /// Create an LRU Cache that holds at most `capacity` items.\n     pub fn new(capacity: uint) -> LruCache<K, V> {\n         let cache = LruCache {\n@@ -217,7 +217,7 @@ impl<K: IterBytes + Eq, V> LruCache<K, V> {\n     }\n }\n \n-impl<A: ToStr + IterBytes + Eq, B: ToStr> ToStr for LruCache<A, B> {\n+impl<A: ToStr + Hash + Eq, B: ToStr> ToStr for LruCache<A, B> {\n     /// Return a string that lists the key-value pairs from most-recently\n     /// used to least-recently used.\n     #[inline]\n@@ -250,14 +250,14 @@ impl<A: ToStr + IterBytes + Eq, B: ToStr> ToStr for LruCache<A, B> {\n     }\n }\n \n-impl<K: IterBytes + Eq, V> Container for LruCache<K, V> {\n+impl<K: Hash + Eq, V> Container for LruCache<K, V> {\n     /// Return the number of key-value pairs in the cache.\n     fn len(&self) -> uint {\n         self.map.len()\n     }\n }\n \n-impl<K: IterBytes + Eq, V> Mutable for LruCache<K, V> {\n+impl<K: Hash + Eq, V> Mutable for LruCache<K, V> {\n     /// Clear the cache of all key-value pairs.\n     fn clear(&mut self) {\n         self.map.clear();"}, {"sha": "2450e22fc105dbd052678432f319956c231d3535", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -11,7 +11,7 @@\n #[allow(missing_doc)];\n \n use std::cmp;\n-use std::hash_old::Hash;\n+use std::hash::Hash;\n use std::io;\n use std::mem;\n use std::num;"}, {"sha": "41d6d95c6bb35711ada2971ed20980dab9cd43f2", "filename": "src/libextra/url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -15,7 +15,7 @@\n use std::io::BufReader;\n use std::cmp::Eq;\n use collections::HashMap;\n-use std::to_bytes;\n+use std::hash::{Hash, sip};\n use std::uint;\n \n /// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n@@ -855,15 +855,15 @@ impl ToStr for Path {\n     }\n }\n \n-impl IterBytes for Url {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_str().iter_bytes(lsb0, f)\n+impl Hash for Url {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.to_str().hash(s)\n     }\n }\n \n-impl IterBytes for Path {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.to_str().iter_bytes(lsb0, f)\n+impl Hash for Path {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.to_str().hash(s)\n     }\n }\n "}, {"sha": "819e0949e3be498cf880cea0fc40a3483fe15546", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -165,12 +165,12 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n /**\n  * A compiled Unix shell style pattern.\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash, Default)]\n pub struct Pattern {\n     priv tokens: ~[PatternToken]\n }\n \n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n enum PatternToken {\n     Char(char),\n     AnyChar,\n@@ -179,7 +179,7 @@ enum PatternToken {\n     AnyExcept(~[CharSpecifier])\n }\n \n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash)]\n enum CharSpecifier {\n     SingleChar(char),\n     CharRange(char, char)\n@@ -490,7 +490,7 @@ fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n+#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, Hash, Default)]\n pub struct MatchOptions {\n \n     /**"}, {"sha": "f9f55fbc1bb01fba659f034f672e9dc8b4a1500b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -27,7 +27,8 @@ use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n use std::u64;\n-use std::hash_old::Hash;\n+use std::hash;\n+use std::hash::Hash;\n use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;\n@@ -86,7 +87,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n-                (item_id as i64).hash())\n+                hash::hash(&(item_id as i64)))\n }\n \n fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {"}, {"sha": "733d1de27dea2a8425b9c1e08f142985153488ea", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -26,7 +26,8 @@ use middle;\n use serialize::Encodable;\n use std::cast;\n use std::cell::{Cell, RefCell};\n-use std::hash_old::Hash;\n+use std::hash;\n+use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n use collections::{HashMap, HashSet};\n@@ -1380,15 +1381,15 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n-fn create_index<T:Clone + Hash + IterBytes + 'static>(\n+fn create_index<T:Clone + Hash + 'static>(\n                 index: ~[entry<T>])\n                 -> ~[@~[entry<T>]] {\n     let mut buckets: ~[@RefCell<~[entry<T>]>] = ~[];\n     for _ in range(0u, 256u) {\n         buckets.push(@RefCell::new(~[]));\n     }\n     for elt in index.iter() {\n-        let h = elt.val.hash() as uint;\n+        let h = hash::hash(&elt.val) as uint;\n         let mut bucket = buckets[h % 256].borrow_mut();\n         bucket.get().push((*elt).clone());\n     }"}, {"sha": "6a47743a03f579d3709959aefffe362279c723f7", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -186,7 +186,7 @@ pub struct BorrowStats {\n //\n // Note that there is no entry with derefs:3---the type of that expression\n // is T, which is not a box.\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub struct root_map_key {\n     id: ast::NodeId,\n     derefs: uint\n@@ -224,13 +224,13 @@ pub enum LoanCause {\n     RefBinding,\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n     LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs"}, {"sha": "c413439cb5359655f70f8f327dc77e86273c6b8d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -94,7 +94,7 @@ pub struct CopiedUpvar {\n }\n \n // different kinds of pointers:\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum PointerKind {\n     OwnedPtr,\n     GcPtr,\n@@ -104,26 +104,26 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum ElementKind {\n     VecElement,\n     StrElement,\n     OtherElement,\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable."}, {"sha": "8b7ade1099081a0a8ca93da7941b2333ae7d2d89", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -105,7 +105,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n enum Namespace {\n     TypeNS,\n     ValueNS"}, {"sha": "278a7ccbc7b76fafc836ee08a58be85e85c3a119", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -722,7 +722,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq,IterBytes)]\n+#[deriving(Eq,Hash)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<@~[mono_id]>),\n     mono_any,\n@@ -732,7 +732,7 @@ pub enum mono_param_id {\n               datum::RvalueMode),\n }\n \n-#[deriving(Eq,IterBytes)]\n+#[deriving(Eq,Hash)]\n pub enum MonoDataClass {\n     MonoBits,    // Anything not treated differently from arbitrary integer data\n     MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n@@ -755,7 +755,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n }\n \n \n-#[deriving(Eq,IterBytes)]\n+#[deriving(Eq,Hash)]\n pub struct mono_id_ {\n     def: ast::DefId,\n     params: ~[mono_param_id]"}, {"sha": "fe848c429aee278e5f8a32241beff47f6c6a03c4", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -82,7 +82,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,"}, {"sha": "8d88c084e99956949dcdc93678b9338cd7c9dd5b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 86, "deletions": 88, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -33,9 +33,9 @@ use util::common::{indenter};\n use std::cast;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n+use std::hash::{Hash, sip};\n use std::ops;\n use std::rc::Rc;\n-use std::to_bytes;\n use std::to_str::ToStr;\n use std::vec;\n use collections::{HashMap, HashSet};\n@@ -60,7 +60,7 @@ pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n // Data types\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub struct field {\n     ident: ast::Ident,\n     mt: mt\n@@ -122,20 +122,20 @@ pub struct Impl {\n     methods: ~[@Method]\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::Mutability,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash, ToStr)]\n pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_slice(Region)\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+#[deriving(Clone, Eq, Hash, Encodable, Decodable, ToStr)]\n pub enum TraitStore {\n     UniqTraitStore,             // ~Trait\n     RegionTraitStore(Region),   // &Trait\n@@ -149,7 +149,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq,IterBytes)]\n+#[deriving(Eq,Hash)]\n pub struct creader_cache_key {\n     cnum: CrateNum,\n     pos: uint,\n@@ -176,12 +176,10 @@ impl cmp::Eq for intern_key {\n     }\n }\n \n-// NB: Do not replace this with #[deriving(IterBytes)], as above. (Figured\n-// this out the hard way.)\n-impl to_bytes::IterBytes for intern_key {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n+impl Hash for intern_key {\n+    fn hash(&self, s: &mut sip::SipState) {\n         unsafe {\n-            (*self.sty).iter_bytes(lsb0, f)\n+            (*self.sty).hash(s)\n         }\n     }\n }\n@@ -416,14 +414,14 @@ pub fn type_has_regions(t: t) -> bool {\n }\n pub fn type_id(t: t) -> uint { get(t).id }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct BareFnTy {\n     purity: ast::Purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct ClosureTy {\n     purity: ast::Purity,\n     sigil: ast::Sigil,\n@@ -445,22 +443,22 @@ pub struct ClosureTy {\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct FnSig {\n     binder_id: ast::NodeId,\n     inputs: ~[t],\n     output: t,\n     variadic: bool\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct param_ty {\n     idx: uint,\n     def_id: DefId\n }\n \n /// Representation of regions:\n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr, Show)]\n+#[deriving(Clone, Eq, Hash, Encodable, Decodable, ToStr, Show)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -501,13 +499,13 @@ pub enum Region {\n  * the original var id (that is, the root variable that is referenced\n  * by the upvar) and the id of the closure expression.\n  */\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct UpvarId {\n     var_id: ast::NodeId,\n     closure_expr_id: ast::NodeId,\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -620,13 +618,13 @@ impl Region {\n     }\n }\n \n-#[deriving(Clone, Eq, TotalOrd, TotalEq, IterBytes, Encodable, Decodable, ToStr, Show)]\n+#[deriving(Clone, Eq, TotalOrd, TotalEq, Hash, Encodable, Decodable, ToStr, Show)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n     bound_region: BoundRegion\n }\n \n-#[deriving(Clone, Eq, TotalEq, TotalOrd, IterBytes, Encodable, Decodable, ToStr, Show)]\n+#[deriving(Clone, Eq, TotalEq, TotalOrd, Hash, Encodable, Decodable, ToStr, Show)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(uint),\n@@ -645,7 +643,7 @@ pub enum BoundRegion {\n  * Represents the values to use when substituting lifetime parameters.\n  * If the value is `ErasedRegions`, then this subst is occurring during\n  * trans, and all region parameters will be replaced with `ty::ReStatic`. */\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(OptVec<ty::Region>)\n@@ -668,7 +666,7 @@ pub enum RegionSubsts {\n  * - `self_ty` is the type to which `self` should be remapped, if any.  The\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct substs {\n     self_ty: Option<ty::t>,\n     tps: ~[t],\n@@ -723,7 +721,7 @@ mod primitives {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -758,7 +756,7 @@ pub enum sty {\n     ty_unboxed_vec(mt),\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub struct TraitRef {\n     def_id: DefId,\n     substs: substs\n@@ -820,15 +818,15 @@ pub enum type_err {\n     terr_variadic_mismatch(expected_found<bool>)\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub struct ParamBounds {\n     builtin_bounds: BuiltinBounds,\n     trait_bounds: ~[@TraitRef]\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n-#[deriving(Clone, Encodable, Eq, Decodable, IterBytes, ToStr)]\n+#[deriving(Clone, Encodable, Eq, Decodable, Hash, ToStr)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundStatic,\n@@ -860,28 +858,28 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct TyVid(uint);\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct IntVid(uint);\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub struct FloatVid(uint);\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, Show)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash, Show)]\n pub struct RegionVid {\n     id: uint\n }\n \n-#[deriving(Clone, Eq, IterBytes)]\n+#[deriving(Clone, Eq, Hash)]\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n }\n \n-#[deriving(Clone, Encodable, Decodable, IterBytes, ToStr, Show)]\n+#[deriving(Clone, Encodable, Decodable, Hash, ToStr, Show)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, BoundRegion)\n@@ -4916,10 +4914,13 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n-    use std::hash_old::{SipState, Streaming};\n+    use std::hash::{sip, Hash};\n \n-    let mut hash = SipState::new(0, 0);\n-    let region = |_hash: &mut SipState, r: Region| {\n+    let mut hash = sip::SipState::new(0, 0);\n+    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut hash) } );\n+    macro_rules! hash( ($e:expr) => { $e.hash(&mut hash) } );\n+\n+    let region = |_hash: &mut sip::SipState, r: Region| {\n         match r {\n             ReStatic => {}\n \n@@ -4933,130 +4934,127 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             }\n         }\n     };\n-    let vstore = |hash: &mut SipState, v: vstore| {\n+    let vstore = |hash: &mut sip::SipState, v: vstore| {\n         match v {\n-            vstore_fixed(_) => hash.input([0]),\n-            vstore_uniq => hash.input([1]),\n+            vstore_fixed(_) => 0u8.hash(hash),\n+            vstore_uniq => 1u8.hash(hash),\n             vstore_slice(r) => {\n-                hash.input([3]);\n+                2u8.hash(hash);\n                 region(hash, r);\n             }\n         }\n     };\n-    let did = |hash: &mut SipState, did: DefId| {\n+    let did = |hash: &mut sip::SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n             local_hash.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        hash.input(h.as_bytes());\n-        iter(hash, &did.node);\n+        h.as_bytes().hash(hash);\n+        did.node.hash(hash);\n     };\n-    let mt = |hash: &mut SipState, mt: mt| {\n-        iter(hash, &mt.mutbl);\n+    let mt = |hash: &mut sip::SipState, mt: mt| {\n+        mt.mutbl.hash(hash);\n     };\n-    fn iter<T: IterBytes>(hash: &mut SipState, t: &T) {\n-        t.iter_bytes(true, |bytes| { hash.input(bytes); true });\n-    }\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n-            ty_nil => hash.input([0]),\n-            ty_bot => hash.input([1]),\n-            ty_bool => hash.input([2]),\n-            ty_char => hash.input([3]),\n+            ty_nil => byte!(0),\n+            ty_bot => byte!(1),\n+            ty_bool => byte!(2),\n+            ty_char => byte!(3),\n             ty_int(i) => {\n-                hash.input([4]);\n-                iter(&mut hash, &i);\n+                byte!(4);\n+                hash!(i);\n             }\n             ty_uint(u) => {\n-                hash.input([5]);\n-                iter(&mut hash, &u);\n+                byte!(5);\n+                hash!(u);\n             }\n             ty_float(f) => {\n-                hash.input([6]);\n-                iter(&mut hash, &f);\n+                byte!(6);\n+                hash!(f);\n             }\n             ty_str(v) => {\n-                hash.input([7]);\n-                vstore(&mut hash, v);\n+                byte!(7);\n+                hash!(v);\n             }\n             ty_enum(d, _) => {\n-                hash.input([8]);\n-                did(&mut hash, d);\n+                byte!(8);\n+                hash!(d)\n             }\n             ty_box(_) => {\n-                hash.input([9]);\n+                byte!(9);\n             }\n             ty_uniq(_) => {\n-                hash.input([10]);\n+                byte!(10);\n             }\n             ty_vec(m, v) => {\n-                hash.input([11]);\n+                byte!(11);\n                 mt(&mut hash, m);\n                 vstore(&mut hash, v);\n             }\n             ty_ptr(m) => {\n-                hash.input([12]);\n+                byte!(12);\n                 mt(&mut hash, m);\n             }\n             ty_rptr(r, m) => {\n-                hash.input([13]);\n+                byte!(13);\n                 region(&mut hash, r);\n                 mt(&mut hash, m);\n             }\n             ty_bare_fn(ref b) => {\n-                hash.input([14]);\n-                iter(&mut hash, &b.purity);\n-                iter(&mut hash, &b.abis);\n+                byte!(14);\n+                hash!(b.purity);\n+                hash!(b.abis);\n             }\n             ty_closure(ref c) => {\n-                hash.input([15]);\n-                iter(&mut hash, &c.purity);\n-                iter(&mut hash, &c.sigil);\n-                iter(&mut hash, &c.onceness);\n-                iter(&mut hash, &c.bounds);\n+                byte!(15);\n+                hash!(c.purity);\n+                hash!(c.sigil);\n+                hash!(c.onceness);\n+                hash!(c.bounds);\n                 region(&mut hash, c.region);\n             }\n             ty_trait(d, _, store, m, bounds) => {\n-                hash.input([17]);\n+                byte!(17);\n                 did(&mut hash, d);\n                 match store {\n-                    UniqTraitStore => hash.input([0]),\n+                    UniqTraitStore => byte!(0),\n                     RegionTraitStore(r) => {\n-                        hash.input([1]);\n+                        byte!(1)\n                         region(&mut hash, r);\n                     }\n                 }\n-                iter(&mut hash, &m);\n-                iter(&mut hash, &bounds);\n+                hash!(m);\n+                hash!(bounds);\n             }\n             ty_struct(d, _) => {\n-                hash.input([18]);\n+                byte!(18);\n                 did(&mut hash, d);\n             }\n             ty_tup(ref inner) => {\n-                hash.input([19]);\n-                iter(&mut hash, &inner.len());\n+                byte!(19);\n+                hash!(inner.len());\n             }\n             ty_param(p) => {\n-                hash.input([20]);\n-                iter(&mut hash, &p.idx);\n+                byte!(20);\n+                hash!(p.idx);\n                 did(&mut hash, p.def_id);\n             }\n             ty_self(d) => {\n-                hash.input([21]);\n+                byte!(21);\n                 did(&mut hash, d);\n             }\n             ty_infer(_) => unreachable!(),\n-            ty_err => hash.input([23]),\n+            ty_err => byte!(23),\n             ty_unboxed_vec(m) => {\n-                hash.input([24]);\n+                byte!(24);\n                 mt(&mut hash, m);\n             }\n         }\n     });\n \n-    hash.result_u64()\n+    hash.result()\n }\n \n impl Variance {"}, {"sha": "abf6df6124ebf3c2d54b13a17bf4bd5fc5737bb9", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -34,15 +34,15 @@ use syntax::opt_vec::OptVec;\n \n mod doc;\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region),\n     ConstrainRegSubReg(Region, Region),\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n struct TwoRegions {\n     a: Region,\n     b: Region,"}, {"sha": "1ae36ab46aad2e1a08d8c329dbe633fc042d4108", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -18,9 +18,9 @@ use str::OwnedStr;\n use container::Container;\n use cast;\n use fmt;\n+use hash::{Hash, sip};\n use iter::Iterator;\n use vec::{ImmutableVector, MutableVector, Vector};\n-use to_bytes::IterBytes;\n use option::{Option, Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n@@ -314,10 +314,10 @@ impl IntoStr for ~[Ascii] {\n     }\n }\n \n-impl IterBytes for Ascii {\n+impl Hash for Ascii {\n     #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n-        f([self.to_byte()])\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.to_byte().hash(s)\n     }\n }\n "}, {"sha": "6ad69d5618165bb52fe22b0419229e2fa04f998d", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -121,7 +121,7 @@ pub enum Method<'a> {\n }\n \n /// A selector for what pluralization a plural method should take\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum PluralSelector {\n     /// One of the plural keywords should be used\n     Keyword(PluralKeyword),\n@@ -143,7 +143,7 @@ pub struct PluralArm<'a> {\n /// specially placed in the `Plural` variant of `Method`\n ///\n /// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n #[allow(missing_doc)]\n pub enum PluralKeyword {\n     Zero, One, Two, Few, Many"}, {"sha": "07b16db95f867e24d87bf1000a3a1f88a84ceed5", "filename": "src/libstd/hash_old.rs", "status": "removed", "additions": 0, "deletions": 510, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibstd%2Fhash_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibstd%2Fhash_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash_old.rs?ref=5444da54fd32b705eec28112e309f63b704e3f8c", "patch": "@@ -1,510 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Implementation of SipHash 2-4\n- *\n- * See: http://131002.net/siphash/\n- *\n- * Consider this as a main \"general-purpose\" hash for all hashtables: it\n- * runs at good speed (competitive with spooky and city) and permits\n- * strong _keyed_ hashing. Key your hashtables from a strong RNG,\n- * such as rand::rng.\n- *\n- * Although the SipHash algorithm is considered to be cryptographically\n- * strong, this implementation has not been reviewed for such purposes.\n- * As such, all cryptographic uses of this implementation are strongly\n- * discouraged.\n- */\n-\n-#[allow(missing_doc)];\n-\n-use container::Container;\n-use io::{Writer, IoResult};\n-use iter::Iterator;\n-use option::{Some, None};\n-use result::Ok;\n-use str::OwnedStr;\n-use to_bytes::IterBytes;\n-use vec::ImmutableVector;\n-\n-// Alias `SipState` to `State`.\n-pub use State = hash_old::SipState;\n-\n-/**\n- * Types that can meaningfully be hashed should implement this.\n- *\n- * Note that this trait is likely to change somewhat as it is\n- * closely related to `to_bytes::IterBytes` and in almost all\n- * cases presently the two are (and must be) used together.\n- *\n- * In general, most types only need to implement `IterBytes`,\n- * and the implementation of `Hash` below will take care of\n- * the rest. This is the recommended approach, since constructing\n- * good keyed hash functions is quite difficult.\n- */\n-pub trait Hash {\n-    /**\n-     * Compute a \"keyed\" hash of the value implementing the trait,\n-     * taking `k0` and `k1` as \"keying\" parameters that randomize or\n-     * otherwise perturb the hash function in such a way that a\n-     * hash table built using such \"keyed hash functions\" cannot\n-     * be made to perform linearly by an attacker controlling the\n-     * hashtable's contents.\n-     *\n-     * In practical terms, we implement this using the SipHash 2-4\n-     * function and require most types to only implement the\n-     * IterBytes trait, that feeds SipHash.\n-     */\n-    fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n-\n-    #[inline]\n-    fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n-}\n-\n-/// Streaming hash-functions should implement this.\n-pub trait Streaming {\n-    fn input(&mut self, &[u8]);\n-    // These can be refactored some when we have default methods.\n-    fn result_bytes(&mut self) -> ~[u8];\n-    fn result_str(&mut self) -> ~str;\n-    fn result_u64(&mut self) -> u64;\n-    fn reset(&mut self);\n-}\n-\n-impl<A:IterBytes> Hash for A {\n-    #[inline]\n-    fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n-        let mut s = State::new(k0, k1);\n-        self.iter_bytes(true, |bytes| {\n-            s.input(bytes);\n-            true\n-        });\n-        s.result_u64()\n-    }\n-}\n-\n-#[inline]\n-pub fn default_state() -> State {\n-    State::new(0, 0)\n-}\n-\n-struct SipState {\n-    k0: u64,\n-    k1: u64,\n-    length: uint, // how many bytes we've processed\n-    v0: u64,      // hash state\n-    v1: u64,\n-    v2: u64,\n-    v3: u64,\n-    tail: [u8, ..8], // unprocessed bytes\n-    ntail: uint,  // how many bytes in tail are valid\n-}\n-\n-impl SipState {\n-    #[inline]\n-    fn new(key0: u64, key1: u64) -> SipState {\n-        let mut state = SipState {\n-            k0: key0,\n-            k1: key1,\n-            length: 0,\n-            v0: 0,\n-            v1: 0,\n-            v2: 0,\n-            v3: 0,\n-            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n-            ntail: 0,\n-        };\n-        state.reset();\n-        state\n-    }\n-}\n-\n-// sadly, these macro definitions can't appear later,\n-// because they're needed in the following defs;\n-// this design could be improved.\n-\n-macro_rules! u8to64_le (\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     $buf[1+$i] as u64 << 8 |\n-     $buf[2+$i] as u64 << 16 |\n-     $buf[3+$i] as u64 << 24 |\n-     $buf[4+$i] as u64 << 32 |\n-     $buf[5+$i] as u64 << 40 |\n-     $buf[6+$i] as u64 << 48 |\n-     $buf[7+$i] as u64 << 56)\n-)\n-\n-macro_rules! rotl (\n-    ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64 - $b)))\n-)\n-\n-macro_rules! compress (\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n-    ({\n-        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-        $v0 = rotl!($v0, 32);\n-        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-        $v2 = rotl!($v2, 32);\n-    })\n-)\n-\n-\n-impl Writer for SipState {\n-    // Methods for io::writer\n-    #[inline]\n-    fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n-        let length = msg.len();\n-        self.length += length;\n-\n-        let mut needed = 0u;\n-\n-        if self.ntail != 0 {\n-            needed = 8 - self.ntail;\n-\n-            if length < needed {\n-                let mut t = 0;\n-                while t < length {\n-                    self.tail[self.ntail+t] = msg[t];\n-                    t += 1;\n-                }\n-                self.ntail += length;\n-                return Ok(())\n-            }\n-\n-            let mut t = 0;\n-            while t < needed {\n-                self.tail[self.ntail+t] = msg[t];\n-                t += 1;\n-            }\n-\n-            let m = u8to64_le!(self.tail, 0);\n-\n-            self.v3 ^= m;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= m;\n-\n-            self.ntail = 0;\n-        }\n-\n-        // Buffered tail is now flushed, process new input.\n-        let len = length - needed;\n-        let end = len & (!0x7);\n-        let left = len & 0x7;\n-\n-        let mut i = needed;\n-        while i < end {\n-            let mi = u8to64_le!(msg, i);\n-\n-            self.v3 ^= mi;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= mi;\n-\n-            i += 8;\n-        }\n-\n-        let mut t = 0u;\n-        while t < left {\n-            self.tail[t] = msg[i+t];\n-            t += 1\n-        }\n-        self.ntail = left;\n-        Ok(())\n-    }\n-}\n-\n-impl Streaming for SipState {\n-    #[inline]\n-    fn input(&mut self, buf: &[u8]) {\n-        self.write(buf).unwrap();\n-    }\n-\n-    #[inline]\n-    fn result_u64(&mut self) -> u64 {\n-        let mut v0 = self.v0;\n-        let mut v1 = self.v1;\n-        let mut v2 = self.v2;\n-        let mut v3 = self.v3;\n-\n-        let mut b : u64 = (self.length as u64 & 0xff) << 56;\n-\n-        if self.ntail > 0 { b |= self.tail[0] as u64 <<  0; }\n-        if self.ntail > 1 { b |= self.tail[1] as u64 <<  8; }\n-        if self.ntail > 2 { b |= self.tail[2] as u64 << 16; }\n-        if self.ntail > 3 { b |= self.tail[3] as u64 << 24; }\n-        if self.ntail > 4 { b |= self.tail[4] as u64 << 32; }\n-        if self.ntail > 5 { b |= self.tail[5] as u64 << 40; }\n-        if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n-\n-        v3 ^= b;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        v0 ^= b;\n-\n-        v2 ^= 0xff;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-\n-        return v0 ^ v1 ^ v2 ^ v3;\n-    }\n-\n-    fn result_bytes(&mut self) -> ~[u8] {\n-        let h = self.result_u64();\n-        ~[(h >> 0) as u8,\n-          (h >> 8) as u8,\n-          (h >> 16) as u8,\n-          (h >> 24) as u8,\n-          (h >> 32) as u8,\n-          (h >> 40) as u8,\n-          (h >> 48) as u8,\n-          (h >> 56) as u8,\n-        ]\n-    }\n-\n-    fn result_str(&mut self) -> ~str {\n-        let r = self.result_bytes();\n-        let mut s = ~\"\";\n-        for b in r.iter() {\n-            s.push_str(format!(\"{:x}\", *b));\n-        }\n-        s\n-    }\n-\n-    #[inline]\n-    fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{Hash, Streaming, SipState};\n-    use iter::Iterator;\n-    use num::ToStrRadix;\n-    use option::Some;\n-    use str::OwnedStr;\n-    use to_bytes::IterBytes;\n-    use vec::{Vector, OwnedVector, ImmutableVector};\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'a>(&'a [u8]);\n-    impl<'a> IterBytes for Bytes<'a> {\n-        fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n-            let Bytes(v) = *self;\n-            f(v)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_siphash() {\n-        let vecs : [[u8, ..8], ..64] = [\n-            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-        ];\n-\n-        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf : ~[u8] = ~[];\n-        let mut t = 0;\n-        let mut stream_inc = SipState::new(k0, k1);\n-        let mut stream_full = SipState::new(k0, k1);\n-\n-        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n-            let mut s = ~\"\";\n-            for b in r.iter() {\n-                s.push_str(format!(\"{:x}\", *b));\n-            }\n-            s\n-        }\n-\n-        while t < 64 {\n-            debug!(\"siphash test {}\", t);\n-            let vec = u8to64_le!(vecs[t], 0);\n-            let out = Bytes(buf.as_slice()).hash_keyed(k0, k1);\n-            debug!(\"got {:?}, expected {:?}\", out, vec);\n-            assert_eq!(vec, out);\n-\n-            stream_full.reset();\n-            stream_full.input(buf);\n-            let f = stream_full.result_str();\n-            let i = stream_inc.result_str();\n-            let v = to_hex_str(&vecs[t]);\n-            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n-\n-            assert!(f == i && f == v);\n-\n-            buf.push(t as u8);\n-            stream_inc.input([t as u8]);\n-\n-            t += 1;\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!((val as u64).hash() != (val as uint).hash());\n-        assert_eq!((val as u32).hash(), (val as uint).hash());\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!((val as u64).hash(), (val as uint).hash());\n-        assert!((val as u32).hash() != (val as uint).hash());\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!((val as u64).hash() != (val as uint).hash());\n-        assert_eq!((val as u32).hash(), (val as uint).hash());\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        val64.hash() == val64.hash();\n-        let val32 = 0xdeadbeef_u32;\n-        val32.hash() == val32.hash();\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(val.hash() != zero_byte(val, 0).hash());\n-        assert!(val.hash() != zero_byte(val, 1).hash());\n-        assert!(val.hash() != zero_byte(val, 2).hash());\n-        assert!(val.hash() != zero_byte(val, 3).hash());\n-        assert!(val.hash() != zero_byte(val, 4).hash());\n-        assert!(val.hash() != zero_byte(val, 5).hash());\n-        assert!(val.hash() != zero_byte(val, 6).hash());\n-        assert!(val.hash() != zero_byte(val, 7).hash());\n-\n-        fn zero_byte(val: u64, byte: uint) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(val.hash() != zero_byte(val, 0).hash());\n-        assert!(val.hash() != zero_byte(val, 1).hash());\n-        assert!(val.hash() != zero_byte(val, 2).hash());\n-        assert!(val.hash() != zero_byte(val, 3).hash());\n-\n-        fn zero_byte(val: u32, byte: uint) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_float_hashes_differ() {\n-        assert!(0.0.hash() != 1.0.hash());\n-        assert!(1.0.hash() != (-1.0).hash());\n-    }\n-\n-    #[test]\n-    fn test_float_hashes_of_zero() {\n-        assert_eq!(0.0.hash(), (-0.0).hash());\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        let v = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w = (&[1u8, 0, 0, 0], &[], &[]);\n-\n-        assert!(v != w);\n-        assert!(s.hash() != t.hash() && s.hash() != u.hash());\n-        assert!(v.hash() != w.hash());\n-    }\n-}"}, {"sha": "7c2db7688fd0c8bf992b4336b7aedcf5fd2e8320", "filename": "src/libstd/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fintrinsics.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -444,7 +444,7 @@ extern \"rust-intrinsic\" {\n /// `TypeId` represents a globally unique identifier for a type\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n #[cfg(not(test))]\n pub struct TypeId {\n     priv t: u64,"}, {"sha": "13ea552ab3b65b5bf45a852b503a5a32e188dee4", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -14,12 +14,11 @@ use iter::Iterator;\n use option::{Option, None, Some};\n use str::StrSlice;\n use to_str::ToStr;\n-use to_bytes::IterBytes;\n use vec::{MutableCloneableVector, ImmutableVector, MutableVector};\n \n pub type Port = u16;\n \n-#[deriving(Eq, TotalEq, Clone, IterBytes)]\n+#[deriving(Eq, TotalEq, Clone, Hash)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n@@ -49,7 +48,7 @@ impl ToStr for IpAddr {\n     }\n }\n \n-#[deriving(Eq, TotalEq, Clone, IterBytes)]\n+#[deriving(Eq, TotalEq, Clone, Hash)]\n pub struct SocketAddr {\n     ip: IpAddr,\n     port: Port,\n@@ -340,7 +339,6 @@ impl FromStr for SocketAddr {\n mod test {\n     use prelude::*;\n     use super::*;\n-    use to_bytes::ToBytes;\n \n     #[test]\n     fn test_from_str_ipv4() {\n@@ -442,14 +440,4 @@ mod test {\n         assert!(a1.to_str() == ~\"::ffff:192.0.2.128\" || a1.to_str() == ~\"::FFFF:192.0.2.128\");\n         assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_str(), ~\"8:9:a:b:c:d:e:f\");\n     }\n-\n-    #[test]\n-    fn ipv4_addr_to_bytes() {\n-        Ipv4Addr(123, 20, 12, 56).to_bytes(true);\n-    }\n-\n-    #[test]\n-    fn socket_addr_to_bytes() {\n-        SocketAddr { ip: Ipv4Addr(1, 2, 3, 4), port: 1234 }.to_bytes(true);\n-    }\n }"}, {"sha": "32670fa7c2c2415b4032ea4dc98c19a205413d5b", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -30,7 +30,7 @@ use rt::rtio::{IoFactory, LocalIo, RtioSignal};\n use vec::{ImmutableVector, OwnedVector};\n \n #[repr(int)]\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n pub enum Signum {\n     /// Equivalent to SIGBREAK, delivered when the user presses Ctrl-Break.\n     Break = 21i,"}, {"sha": "2c81bcd4b0ec4b7449ad014622de0e62c8afac8b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -143,9 +143,7 @@ pub mod from_str;\n pub mod num;\n pub mod iter;\n pub mod to_str;\n-pub mod to_bytes;\n pub mod clone;\n-pub mod hash_old;\n pub mod hash;\n pub mod container;\n pub mod default;\n@@ -228,7 +226,6 @@ mod std {\n     pub use os;\n     pub use rt;\n     pub use str;\n-    pub use to_bytes;\n     pub use to_str;\n     pub use unstable;\n }"}, {"sha": "d1af612e0ec5ebba2d7f1936b275b187454a201a", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -15,11 +15,11 @@ use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::Eq;\n use from_str::FromStr;\n+use hash::{Hash, sip};\n use iter::{AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use to_bytes::IterBytes;\n use vec;\n use vec::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n           ImmutableEqVector, OwnedVector, ImmutableVector, OwnedCloneableVector};\n@@ -88,10 +88,10 @@ impl ToCStr for Path {\n     }\n }\n \n-impl IterBytes for Path {\n+impl Hash for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: |buf: &[u8]| -> bool) -> bool {\n-        self.repr.iter_bytes(lsb0, f)\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.repr.hash(s)\n     }\n }\n "}, {"sha": "8902ab2edd744b561ac56babced949535f055baf", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -17,11 +17,11 @@ use clone::Clone;\n use container::Container;\n use cmp::Eq;\n use from_str::FromStr;\n+use hash::{Hash, sip};\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n use str;\n use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n-use to_bytes::IterBytes;\n use vec::{Vector, OwnedVector, ImmutableVector};\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n@@ -112,10 +112,10 @@ impl ToCStr for Path {\n     }\n }\n \n-impl IterBytes for Path {\n+impl Hash for Path {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: |&[u8]| -> bool) -> bool {\n-        self.repr.iter_bytes(lsb0, f)\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.repr.hash(s)\n     }\n }\n "}, {"sha": "ce746852daed6447aa9bdb7583837ec19be95202", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -55,7 +55,6 @@ pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n pub use io::{Buffer, Writer, Reader, Seek};\n pub use str::{Str, StrVector, StrSlice, OwnedStr, IntoMaybeOwned};\n-pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, IntoStr};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};"}, {"sha": "4b03f478cd75dbe0522a93b286c306c26678e546", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -89,6 +89,7 @@ use clone::{Clone, DeepClone};\n use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv, Ordering};\n use container::{Container, Mutable};\n use fmt;\n+use hash::{Hash, sip};\n use iter::{Iterator, FromIterator, Extendable, range};\n use iter::{Filter, AdditiveIterator, Map};\n use iter::{Rev, DoubleEndedIterator, ExactSize};\n@@ -103,7 +104,6 @@ use vec;\n use vec::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use vec_ng::Vec;\n use default::Default;\n-use to_bytes::{IterBytes, Cb};\n use raw::Repr;\n \n /*\n@@ -1356,13 +1356,10 @@ impl<'a> Default for MaybeOwned<'a> {\n     fn default() -> MaybeOwned<'a> { Slice(\"\") }\n }\n \n-impl<'a> IterBytes for MaybeOwned<'a> {\n+impl<'a> Hash for MaybeOwned<'a> {\n     #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        match *self {\n-            Slice(s) => s.iter_bytes(lsb0, f),\n-            Owned(ref s) => s.iter_bytes(lsb0, f)\n-        }\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.as_slice().hash(s)\n     }\n }\n "}, {"sha": "5518fa11684add9cf5397c6c17f62d4463e6d4f0", "filename": "src/libstd/to_bytes.rs", "status": "removed", "additions": 0, "deletions": 375, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=5444da54fd32b705eec28112e309f63b704e3f8c", "patch": "@@ -1,375 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `ToBytes` and `IterBytes` traits for converting to raw bytes\n-\n-*/\n-\n-use cast;\n-use container::Container;\n-use iter::Iterator;\n-use option::{None, Option, Some};\n-use rc::Rc;\n-use str::{Str, StrSlice};\n-use vec::{Vector, ImmutableVector};\n-use vec_ng::Vec;\n-\n-pub type Cb<'a> = 'a |buf: &[u8]| -> bool;\n-\n-///\n-/// A trait to implement in order to make a type hashable;\n-/// This works in combination with the trait `std::hash::Hash`, and\n-/// may in the future be merged with that trait or otherwise\n-/// modified when default methods and trait inheritance are\n-/// completed.\n-///\n-/// IterBytes should be implemented so that the extent of the\n-/// produced byte stream can be discovered, given the original\n-/// type.\n-/// For example, the IterBytes implementation for vectors emits\n-/// its length first, and enums should emit their discriminant.\n-///\n-pub trait IterBytes {\n-    /// Call the provided callback `f` one or more times with\n-    /// byte-slices that should be used when computing a hash\n-    /// value or otherwise \"flattening\" the structure into\n-    /// a sequence of bytes. The `lsb0` parameter conveys\n-    /// whether the caller is asking for little-endian bytes\n-    /// (`true`) or big-endian (`false`); this should only be\n-    /// relevant in implementations that represent a single\n-    /// multi-byte datum such as a 32 bit integer or 64 bit\n-    /// floating-point value. It can be safely ignored for\n-    /// larger structured types as they are usually processed\n-    /// left-to-right in declaration order, regardless of\n-    /// underlying memory endianness.\n-    ///\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool;\n-}\n-\n-impl IterBytes for bool {\n-    #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        f([\n-            *self as u8\n-        ])\n-    }\n-}\n-\n-impl IterBytes for u8 {\n-    #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        f([\n-            *self\n-        ])\n-    }\n-}\n-\n-impl IterBytes for u16 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8\n-            ])\n-        } else {\n-            f([\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ])\n-        }\n-    }\n-}\n-\n-impl IterBytes for u32 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 24) as u8,\n-            ])\n-        } else {\n-            f([\n-                (*self >> 24) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ])\n-        }\n-    }\n-}\n-\n-impl IterBytes for u64 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        if lsb0 {\n-            f([\n-                *self as u8,\n-                (*self >> 8) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 24) as u8,\n-                (*self >> 32) as u8,\n-                (*self >> 40) as u8,\n-                (*self >> 48) as u8,\n-                (*self >> 56) as u8\n-            ])\n-        } else {\n-            f([\n-                (*self >> 56) as u8,\n-                (*self >> 48) as u8,\n-                (*self >> 40) as u8,\n-                (*self >> 32) as u8,\n-                (*self >> 24) as u8,\n-                (*self >> 16) as u8,\n-                (*self >> 8) as u8,\n-                *self as u8\n-            ])\n-        }\n-    }\n-}\n-\n-impl IterBytes for i8 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u8).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for i16 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u16).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for i32 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for i64 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u64).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for char {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(target_word_size = \"32\")]\n-impl IterBytes for uint {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u32).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-#[cfg(target_word_size = \"64\")]\n-impl IterBytes for uint {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as u64).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for int {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for f32 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        let i: u32 = unsafe {\n-            // 0.0 == -0.0 so they should also have the same hashcode\n-            cast::transmute(if *self == -0.0 { 0.0 } else { *self })\n-        };\n-        i.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl IterBytes for f64 {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        let i: u64 = unsafe {\n-            // 0.0 == -0.0 so they should also have the same hashcode\n-            cast::transmute(if *self == -0.0 { 0.0 } else { *self })\n-        };\n-        i.iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<'a,A:IterBytes> IterBytes for &'a [A] {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.len().iter_bytes(lsb0, |b| f(b)) &&\n-        self.iter().advance(|elt| elt.iter_bytes(lsb0, |b| f(b)))\n-    }\n-}\n-\n-impl<A: IterBytes> IterBytes for (A, ) {\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        match *self {\n-            (ref a, ) => a.iter_bytes(lsb0, |b| f(b))\n-        }\n-    }\n-}\n-\n-macro_rules! iter_bytes_tuple(\n-    ($($A:ident),+) => (\n-        impl<$($A: IterBytes),+> IterBytes for ($($A),+) {\n-            fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-                match *self {\n-                    ($(ref $A),+) => {\n-                        $(\n-                            $A .iter_bytes(lsb0, |b| f(b))\n-                        )&&+\n-                    }\n-                }\n-            }\n-        }\n-    )\n-)\n-\n-iter_bytes_tuple!(A, B)\n-iter_bytes_tuple!(A, B, C)\n-iter_bytes_tuple!(A, B, C, D)\n-iter_bytes_tuple!(A, B, C, D, E)\n-iter_bytes_tuple!(A, B, C, D, E, F)\n-iter_bytes_tuple!(A, B, C, D, E, F, G)\n-iter_bytes_tuple!(A, B, C, D, E, F, G, H)\n-\n-impl<A:IterBytes> IterBytes for ~[A] {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A:IterBytes> IterBytes for Vec<A> {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<'a> IterBytes for &'a str {\n-    #[inline]\n-    fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n-        // Terminate the string with a byte that does not appear in UTF-8\n-        f(self.as_bytes()) && f([0xFF])\n-    }\n-}\n-\n-impl IterBytes for ~str {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.as_slice().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A:IterBytes> IterBytes for Option<A> {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        match *self {\n-          Some(ref a) => 0u8.iter_bytes(lsb0, |b| f(b)) && a.iter_bytes(lsb0, |b| f(b)),\n-          None => 1u8.iter_bytes(lsb0, f)\n-        }\n-    }\n-}\n-\n-impl<'a,A:IterBytes> IterBytes for &'a A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A:IterBytes> IterBytes for @A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A:IterBytes> IterBytes for Rc<A> {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        self.borrow().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A:IterBytes> IterBytes for ~A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-// NB: raw-pointer IterBytes does _not_ dereference\n-// to the target; it just gives you the pointer-bytes.\n-impl<A> IterBytes for *A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl<A> IterBytes for *mut A {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-/// A trait for converting a value to a list of bytes.\n-pub trait ToBytes {\n-    /// Converts the current value to a list of bytes. This is equivalent to\n-    /// invoking iter_bytes on a type and collecting all yielded values in an\n-    /// array\n-    fn to_bytes(&self, lsb0: bool) -> ~[u8];\n-}\n-\n-impl<A:IterBytes> ToBytes for A {\n-    fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n-        use io::Writer;\n-\n-        let mut m = ::io::MemWriter::new();\n-        self.iter_bytes(lsb0, |bytes| {\n-            m.write(bytes).unwrap();\n-            true\n-        });\n-        m.unwrap()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    // just test to see if it compiles:\n-    #[test] fn iterbytes_compiles () {\n-        takes_iterbytes((3,4,5,false));\n-    }\n-    fn takes_iterbytes<T : IterBytes>(_x : T) {}\n-}"}, {"sha": "13725ef24734f64ee5ad3942b90c8a2cced72bae", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::to_bytes;\n+use std::hash::{Hash, sip};\n \n #[deriving(Eq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n@@ -64,7 +64,7 @@ enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct AbiSet {\n     priv bits: u32   // each bit represents one of the abis below\n }\n@@ -265,15 +265,9 @@ impl AbiSet {\n     }\n }\n \n-impl to_bytes::IterBytes for Abi {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.index().iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl to_bytes::IterBytes for AbiSet {\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.bits.iter_bytes(lsb0, f)\n+impl Hash for Abi {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.index().hash(s)\n     }\n }\n "}, {"sha": "8bc3888b1d09c5ebf78d989eb4634ae9c1225ef0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -39,7 +39,7 @@ pub fn P<T: 'static>(value: T) -> P<T> {\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, IterBytes, ToStr, TotalEq, TotalOrd, Show)]\n+#[deriving(Clone, Hash, ToStr, TotalEq, TotalOrd, Show)]\n pub struct Ident { name: Name, ctxt: SyntaxContext }\n \n impl Ident {\n@@ -101,7 +101,7 @@ pub struct SCTable {\n pub static EMPTY_CTXT : SyntaxContext = 0;\n pub static ILLEGAL_CTXT : SyntaxContext = 1;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -140,7 +140,7 @@ impl<D:Decoder> Decodable<D> for Ident {\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n@@ -151,7 +151,7 @@ pub struct Lifetime {\n // for instance: std::cmp::Eq  .  It's represented\n // as a sequence of identifiers, along with a bunch\n // of supporting information.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Path {\n     span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -163,7 +163,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     identifier: Ident,\n@@ -177,7 +177,7 @@ pub type CrateNum = u32;\n \n pub type NodeId = u32;\n \n-#[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, IterBytes, ToStr, Show)]\n+#[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, Hash, ToStr, Show)]\n pub struct DefId {\n     krate: CrateNum,\n     node: NodeId,\n@@ -197,21 +197,21 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n // detects Copy, Send, Send, and Freeze.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum TyParamBound {\n     TraitTyParamBound(TraitRef),\n     RegionTyParamBound\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct TyParam {\n     ident: Ident,\n     id: NodeId,\n     bounds: OptVec<TyParamBound>,\n     default: Option<P<Ty>>\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     lifetimes: OptVec<Lifetime>,\n     ty_params: OptVec<TyParam>,\n@@ -229,13 +229,13 @@ impl Generics {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum MethodProvenance {\n     FromTrait(DefId),\n     FromImpl(DefId),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Def {\n     DefFn(DefId, Purity),\n     DefStaticMethod(/* method */ DefId, MethodProvenance, Purity),\n@@ -272,7 +272,7 @@ pub enum Def {\n     DefMethod(DefId /* method */, Option<DefId> /* trait */),\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+#[deriving(Clone, Eq, Hash, Encodable, Decodable, ToStr)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* index */ uint, /* lifetime decl */ NodeId),\n@@ -284,7 +284,7 @@ pub enum DefRegion {\n // used to drive conditional compilation\n pub type CrateConfig = ~[@MetaItem];\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Crate {\n     module: Mod,\n     attrs: ~[Attribute],\n@@ -294,7 +294,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[deriving(Clone, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, ~[@MetaItem]),\n@@ -326,7 +326,7 @@ impl Eq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct Block {\n     view_items: ~[ViewItem],\n     stmts: ~[@Stmt],\n@@ -336,26 +336,26 @@ pub struct Block {\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Pat {\n     id: NodeId,\n     node: Pat_,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct FieldPat {\n     ident: Ident,\n     pat: @Pat,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n@@ -380,13 +380,13 @@ pub enum Pat_ {\n     PatVec(~[@Pat], Option<@Pat>, ~[@Pat])\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Sigil {\n     BorrowedSigil,\n     OwnedSigil,\n@@ -403,14 +403,14 @@ impl ToStr for Sigil {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum ExprVstore {\n     ExprVstoreUniq,                 // ~[1,2,3,4]\n     ExprVstoreSlice,                // &[1,2,3,4]\n     ExprVstoreMutSlice,             // &mut [1,2,3,4]\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum BinOp {\n     BiAdd,\n     BiSub,\n@@ -432,7 +432,7 @@ pub enum BinOp {\n     BiGt,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum UnOp {\n     UnBox,\n     UnUniq,\n@@ -443,7 +443,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Stmt_ {\n     // could be an item or a local (let) binding:\n     StmtDecl(@Decl, NodeId),\n@@ -461,7 +461,7 @@ pub enum Stmt_ {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct Local {\n     ty: P<Ty>,\n     pat: @Pat,\n@@ -472,22 +472,22 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n     // an item binding:\n     DeclItem(@Item),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Arm {\n     pats: ~[@Pat],\n     guard: Option<@Expr>,\n     body: P<Block>,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Field {\n     ident: SpannedIdent,\n     expr: @Expr,\n@@ -496,19 +496,19 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct Expr {\n     id: NodeId,\n     node: Expr_,\n@@ -528,7 +528,7 @@ impl Expr {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n@@ -600,7 +600,7 @@ pub enum Expr_ {\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     // a single token\n@@ -674,7 +674,7 @@ pub enum TokenTree {\n //\n pub type Matcher = Spanned<Matcher_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Matcher_ {\n     // match one token\n     MatchTok(::parse::token::Token),\n@@ -691,20 +691,20 @@ pub type Mac = Spanned<Mac_>;\n // is being invoked, and the vector of token-trees contains the source\n // of the macro invocation.\n // There's only one flavor, now, so this could presumably be simplified.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Mac_ {\n     MacInvocTT(Path, ~[TokenTree], SyntaxContext),   // new macro-invocation\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(uint)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<~[u8]>),\n@@ -720,20 +720,20 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct MutTy {\n     ty: P<Ty>,\n     mutbl: Mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct TypeField {\n     ident: Ident,\n     mt: MutTy,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -748,13 +748,13 @@ pub struct TypeMethod {\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum TraitMethod {\n     Required(TypeMethod),\n     Provided(@Method),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum IntTy {\n     TyI,\n     TyI8,\n@@ -769,7 +769,7 @@ impl ToStr for IntTy {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum UintTy {\n     TyU,\n     TyU8,\n@@ -784,7 +784,7 @@ impl ToStr for UintTy {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum FloatTy {\n     TyF32,\n     TyF64,\n@@ -797,15 +797,15 @@ impl ToStr for FloatTy {\n }\n \n // NB Eq method appears below.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Ty {\n     id: NodeId,\n     node: Ty_,\n     span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -815,7 +815,7 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Onceness {\n     Once,\n     Many\n@@ -830,7 +830,7 @@ impl ToStr for Onceness {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct ClosureTy {\n     sigil: Sigil,\n     region: Option<Lifetime>,\n@@ -845,15 +845,15 @@ pub struct ClosureTy {\n     bounds: Option<OptVec<TyParamBound>>,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     purity: Purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n     decl: P<FnDecl>\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Ty_ {\n     TyNil,\n     TyBot, /* bottom type */\n@@ -874,13 +874,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct InlineAsm {\n     asm: InternedString,\n     asm_str_style: StrStyle,\n@@ -892,7 +892,7 @@ pub struct InlineAsm {\n     dialect: AsmDialect\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     ty: P<Ty>,\n     pat: @Pat,\n@@ -919,15 +919,15 @@ impl Arg {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     inputs: ~[Arg],\n     output: P<Ty>,\n     cf: RetStyle,\n     variadic: bool\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Purity {\n     UnsafeFn, // declared with \"unsafe fn\"\n     ImpureFn, // declared with \"fn\"\n@@ -944,14 +944,14 @@ impl ToStr for Purity {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum RetStyle {\n     NoReturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     Return, // everything else\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n     SelfValue,                                 // `self`\n@@ -961,7 +961,7 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct Method {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -975,37 +975,37 @@ pub struct Method {\n     vis: Visibility,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Mod {\n     view_items: ~[ViewItem],\n     items: ~[@Item],\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct ForeignMod {\n     abis: AbiSet,\n     view_items: ~[ViewItem],\n     items: ~[@ForeignItem],\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct VariantArg {\n     ty: P<Ty>,\n     id: NodeId,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum VariantKind {\n     TupleVariantKind(~[VariantArg]),\n     StructVariantKind(@StructDef),\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct EnumDef {\n     variants: ~[P<Variant>],\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Variant_ {\n     name: Ident,\n     attrs: ~[Attribute],\n@@ -1017,7 +1017,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct PathListIdent_ {\n     name: Ident,\n     id: NodeId,\n@@ -1027,7 +1027,7 @@ pub type PathListIdent = Spanned<PathListIdent_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[deriving(Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub enum ViewPath_ {\n \n     // quux = foo::bar::baz\n@@ -1044,15 +1044,15 @@ pub enum ViewPath_ {\n     ViewPathList(Path, ~[PathListIdent], NodeId)\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ViewItem {\n     node: ViewItem_,\n     attrs: ~[Attribute],\n     vis: Visibility,\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional (InternedString,StrStyle): if present, this is a location\n@@ -1068,14 +1068,14 @@ pub type Attribute = Spanned<Attribute_>;\n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct Attribute_ {\n     style: AttrStyle,\n     value: @MetaItem,\n@@ -1089,13 +1089,13 @@ pub struct Attribute_ {\n   If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct TraitRef {\n     path: Path,\n     ref_id: NodeId,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub enum Visibility {\n     Public,\n     Private,\n@@ -1111,7 +1111,7 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub struct StructField_ {\n     kind: StructFieldKind,\n     id: NodeId,\n@@ -1121,13 +1121,13 @@ pub struct StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     UnnamedField // element of a tuple-like struct\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct StructDef {\n     fields: ~[StructField], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1139,7 +1139,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Item {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -1149,7 +1149,7 @@ pub struct Item {\n     span: Span,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n     ItemFn(P<FnDecl>, Purity, AbiSet, Generics, P<Block>),\n@@ -1167,7 +1167,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub struct ForeignItem {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -1177,7 +1177,7 @@ pub struct ForeignItem {\n     vis: Visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1186,7 +1186,7 @@ pub enum ForeignItem_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, Encodable, Decodable,IterBytes)]\n+#[deriving(Eq, Encodable, Decodable,Hash)]\n pub enum InlinedItem {\n     IIItem(@Item),\n     IIMethod(DefId /* impl id */, bool /* is provided */, @Method),"}, {"sha": "83700e390cbf1b42cc2e4f08bc97eb604cfd1567", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -32,13 +32,13 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[deriving(Clone, Eq, IterBytes, Ord)]\n+#[deriving(Clone, Eq, Hash, Ord)]\n pub struct BytePos(u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq,IterBytes, Ord)]\n+#[deriving(Eq,Hash, Ord)]\n pub struct CharPos(uint);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -84,7 +84,7 @@ are *absolute* positions from the beginning of the codemap, not positions\n relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n to the original source.\n */\n-#[deriving(Clone, IterBytes)]\n+#[deriving(Clone, Hash)]\n pub struct Span {\n     lo: BytePos,\n     hi: BytePos,\n@@ -93,7 +93,7 @@ pub struct Span {\n \n pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Spanned<T> {\n     node: T,\n     span: Span,\n@@ -160,15 +160,15 @@ pub struct LocWithOpt {\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n \n-#[deriving(Clone, IterBytes)]\n+#[deriving(Clone, Hash)]\n pub enum MacroFormat {\n     // e.g. #[deriving(...)] <item>\n     MacroAttribute,\n     // e.g. `format!()`\n     MacroBang\n }\n \n-#[deriving(Clone, IterBytes)]\n+#[deriving(Clone, Hash)]\n pub struct NameAndSpan {\n     name: ~str,\n     // the format with which the macro was invoked.\n@@ -177,7 +177,7 @@ pub struct NameAndSpan {\n }\n \n /// Extra information for tracking macro expansion of spans\n-#[deriving(IterBytes)]\n+#[deriving(Hash)]\n pub struct ExpnInfo {\n     call_site: Span,\n     callee: NameAndSpan"}, {"sha": "b39e22bc1adc65f88e1113b67c126e01d372d157", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5444da54fd32b705eec28112e309f63b704e3f8c/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=5444da54fd32b705eec28112e309f63b704e3f8c", "patch": "@@ -1,100 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{MetaItem, Item, Expr, BiAnd};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-\n-\n-pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n-                                  span: Span,\n-                                  mitem: @MetaItem,\n-                                  item: @Item,\n-                                  push: |@Item|) {\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: ~[],\n-        path: Path::new(~[\"std\", \"to_bytes\", \"IterBytes\"]),\n-        additional_bounds: ~[],\n-        generics: LifetimeBounds::empty(),\n-        methods: ~[\n-            MethodDef {\n-                name: \"iter_bytes\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: ~[\n-                    Literal(Path::new(~[\"bool\"])),\n-                    Literal(Path::new(~[\"std\", \"to_bytes\", \"Cb\"]))\n-                ],\n-                ret_ty: Literal(Path::new(~[\"bool\"])),\n-                inline: true,\n-                const_nonmatching: false,\n-                combine_substructure: iter_bytes_substructure\n-            }\n-        ]\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-fn iter_bytes_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n-    let (lsb0, f)= match substr.nonself_args {\n-        [l, f] => (l, f),\n-        _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(IterBytes)`\")\n-    };\n-    // Build the \"explicitly borrowed\" stack closure, \"|_buf| f(_buf)\".\n-    let blk_arg = cx.ident_of(\"_buf\");\n-    let borrowed_f =\n-        cx.lambda_expr_1(trait_span,\n-                         cx.expr_call(trait_span, f, ~[cx.expr_ident(trait_span, blk_arg)]),\n-                         blk_arg);\n-\n-    let iter_bytes_ident = substr.method_ident;\n-    let call_iterbytes = |span, thing_expr| {\n-        cx.expr_method_call(span,\n-                            thing_expr,\n-                            iter_bytes_ident,\n-                            ~[lsb0, borrowed_f])\n-    };\n-    let mut exprs = ~[];\n-    let fields;\n-    match *substr.fields {\n-        Struct(ref fs) => {\n-            fields = fs\n-        }\n-        EnumMatching(index, ref variant, ref fs) => {\n-            // Determine the discriminant. We will feed this value to the byte\n-            // iteration function.\n-            let discriminant = match variant.node.disr_expr {\n-                Some(d)=> d,\n-                None => cx.expr_uint(trait_span, index)\n-            };\n-\n-            exprs.push(call_iterbytes(trait_span, discriminant));\n-\n-            fields = fs;\n-        }\n-        _ => cx.span_bug(trait_span, \"impossible substructure in `deriving(IterBytes)`\")\n-    }\n-\n-    for &FieldInfo { self_, span, .. } in fields.iter() {\n-        exprs.push(call_iterbytes(span, self_));\n-    }\n-\n-    if exprs.len() == 0 {\n-        cx.span_bug(trait_span, \"#[deriving(IterBytes)] needs at least one field\");\n-    }\n-\n-    exprs.slice(1, exprs.len()).iter().fold(exprs[0], |prev, me| {\n-        cx.expr_binary(trait_span, BiAnd, prev, *me)\n-    })\n-}"}, {"sha": "95b9a45b9fc2d19e59c16fd9177defdefb298579", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -23,7 +23,6 @@ use ext::base::ExtCtxt;\n use codemap::Span;\n \n pub mod clone;\n-pub mod iter_bytes;\n pub mod encodable;\n pub mod decodable;\n pub mod hash;\n@@ -74,7 +73,6 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n                             \"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n \n-                            \"IterBytes\" => expand!(iter_bytes::expand_deriving_iter_bytes),\n                             \"Hash\" => expand!(hash::expand_deriving_hash),\n \n                             \"Encodable\" => expand!(encodable::expand_deriving_encodable),"}, {"sha": "3abd411a003998b6ecd48a310f82c4f50f572b2d", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -17,7 +17,7 @@\n \n use std::vec;\n \n-#[deriving(Clone, Encodable, Decodable, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Hash)]\n pub enum OptVec<T> {\n     Empty,\n     Vec(~[T])"}, {"sha": "393282dd06302270460d8e0ed4ab8e546100860e", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -22,10 +22,8 @@ use codemap::{Span, respan};\n use parse::parser::Parser;\n use parse::token;\n \n-use std::to_bytes;\n-\n /// The specific types of unsupported syntax\n-#[deriving(Eq)]\n+#[deriving(Eq, Hash)]\n pub enum ObsoleteSyntax {\n     ObsoleteSwap,\n     ObsoleteUnsafeBlock,\n@@ -46,13 +44,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteManagedVec,\n }\n \n-impl to_bytes::IterBytes for ObsoleteSyntax {\n-    #[inline]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n pub trait ParserObsoleteMethods {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax);"}, {"sha": "a2f3b65f06e31af965faf4d267e8390436307dd8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -23,7 +23,7 @@ use std::local_data;\n use std::path::BytesContainer;\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n pub enum BinOp {\n     PLUS,\n     MINUS,\n@@ -38,7 +38,7 @@ pub enum BinOp {\n }\n \n #[allow(non_camel_case_types)]\n-#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -102,7 +102,7 @@ pub enum Token {\n     EOF,\n }\n \n-#[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n+#[deriving(Clone, Encodable, Decodable, Eq, Hash)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(@ast::Item),\n@@ -536,7 +536,7 @@ pub fn get_ident_interner() -> @IdentInterner {\n /// destroyed. In particular, they must not access string contents. This can\n /// be fixed in the future by just leaking all strings until task death\n /// somehow.\n-#[deriving(Clone, Eq, IterBytes, Ord, TotalEq, TotalOrd)]\n+#[deriving(Clone, Eq, Hash, Ord, TotalEq, TotalOrd)]\n pub struct InternedString {\n     priv string: RcStr,\n }"}, {"sha": "fa21924bbb9d1e165a0a43a36997e3ec9e6559d0", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -18,7 +18,7 @@ use collections::HashMap;\n use std::cast;\n use std::cell::RefCell;\n use std::cmp::Equiv;\n-use std::hash_old::Hash;\n+use std::hash::Hash;\n use std::rc::Rc;\n \n pub struct Interner<T> {\n@@ -27,7 +27,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n+impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: RefCell::new(HashMap::new()),\n@@ -75,7 +75,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<T>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + Equiv<T>>(&self, val: &Q)\n                                               -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {\n@@ -85,7 +85,7 @@ impl<T:Eq + IterBytes + Hash + Freeze + Clone + 'static> Interner<T> {\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes, Ord)]\n+#[deriving(Clone, Eq, Hash, Ord)]\n pub struct RcStr {\n     priv string: Rc<~str>,\n }\n@@ -207,7 +207,7 @@ impl StrInterner {\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<RcStr>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + Equiv<RcStr>>(&self, val: &Q)\n                                                          -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {"}, {"sha": "dec27719beb191656b749bb8f99ff3c135641784", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -74,7 +74,7 @@ use std::rand;\n use std::rand::Rng;\n use std::cmp::Eq;\n use std::cast::{transmute,transmute_copy};\n-use std::to_bytes::{IterBytes, Cb};\n+use std::hash::{Hash, sip};\n \n use serialize::{Encoder, Encodable, Decoder, Decodable};\n \n@@ -114,9 +114,9 @@ pub struct Uuid {\n     /// The 128-bit number stored in 16 bytes\n     bytes: UuidBytes\n }\n-impl IterBytes for Uuid {\n-    fn iter_bytes(&self, _: bool, f: Cb) -> bool {\n-        f(self.bytes.slice_from(0))\n+impl Hash for Uuid {\n+    fn hash(&self, s: &mut sip::SipState) {\n+        self.bytes.slice_from(0).hash(s)\n     }\n }\n "}, {"sha": "ffca06dc628d0a43d1cbf013fb0f48cd3448d21d", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -27,21 +27,18 @@ mod submod {\n     // function calls, then being in a submodule will (correctly)\n     // cause errors about unrecognised module `std` (or `extra`)\n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n-               IterBytes,\n                Clone, DeepClone,\n                ToStr, Rand,\n                Encodable, Decodable)]\n     enum A { A1(uint), A2(int) }\n \n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n-               IterBytes,\n                Clone, DeepClone,\n                ToStr, Rand,\n                Encodable, Decodable)]\n     struct B { x: uint, y: int }\n \n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n-               IterBytes,\n                Clone, DeepClone,\n                ToStr, Rand,\n                Encodable, Decodable)]"}, {"sha": "58ec8e35281efed8b4f0d592ab8e9d42df3f2c89", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -10,11 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash_old::Hash;\n-\n #[deriving(Eq)]\n #[deriving(Clone)]\n-#[deriving(IterBytes)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -25,5 +22,4 @@ pub fn main() {\n \n     a == a;    // check for Eq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n-    a.hash();  // check for IterBytes impl w/o testing its correctness\n }"}, {"sha": "7f31aa586cc1717c6eb7da8d5f15ee76081a861f", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -10,9 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash_old::Hash;\n-\n-#[deriving(Eq, Clone, IterBytes)]\n+#[deriving(Eq, Clone)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -23,5 +21,4 @@ pub fn main() {\n \n     a == a;    // check for Eq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n-    a.hash();  // check for IterBytes impl w/o testing its correctness\n }"}, {"sha": "fed10567a196470bde9a8a0f405cf489e8b32950", "filename": "src/test/run-pass/deriving-via-extension-hash-enum.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-enum.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -10,13 +10,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(IterBytes)]\n+#[deriving(Hash)]\n enum Foo {\n     Bar(int, char),\n     Baz(char, int)\n }\n \n-#[deriving(IterBytes)]\n+#[deriving(Hash)]\n enum A {\n     B,\n     C,", "previous_filename": "src/test/run-pass/deriving-via-extension-iter-bytes-enum.rs"}, {"sha": "57c13a504d3d8a8ccfd8be06b9798f79478b745a", "filename": "src/test/run-pass/deriving-via-extension-hash-struct.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-hash-struct.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -10,7 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(IterBytes)]\n+#[deriving(Hash)]\n struct Foo {\n     x: int,\n     y: int,", "previous_filename": "src/test/run-pass/deriving-via-extension-iter-bytes-struct.rs"}, {"sha": "c483816099ddcc08e0c5dfcd655319df976c757c", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -11,7 +11,7 @@\n // except according to those terms.\n \n #[deriving(Eq)]\n-#[deriving(IterBytes)]\n+#[deriving(Hash)]\n struct Foo<T> {\n     x: int,\n     y: T,"}, {"sha": "1a29bb75f91f431ecf0512dd994d4616f7595d7e", "filename": "src/test/run-pass/regions-mock-tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-tcx.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -85,7 +85,7 @@ impl<'tcx,'ast> TypeContext<'tcx, 'ast> {\n     }\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Eq, Hash)]\n struct NodeId {\n     id: uint\n }"}, {"sha": "c874fbb7a8b68f34fcf4ebec2e2055200013b362", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efaf4db24c92e119e26dc575ffd6bfd3b91fb87d/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=efaf4db24c92e119e26dc575ffd6bfd3b91fb87d", "patch": "@@ -15,7 +15,7 @@\n extern crate other1 = \"typeid-intrinsic\";\n extern crate other2 = \"typeid-intrinsic2\";\n \n-use std::hash_old::Hash;\n+use std::hash;\n use std::intrinsics;\n use std::intrinsics::TypeId;\n \n@@ -71,5 +71,5 @@ pub fn main() {\n     // check it has a hash\n     let (a, b) = (TypeId::of::<uint>(), TypeId::of::<uint>());\n \n-    assert_eq!(a.hash(), b.hash());\n+    assert_eq!(hash::hash(&a), hash::hash(&b));\n }"}]}