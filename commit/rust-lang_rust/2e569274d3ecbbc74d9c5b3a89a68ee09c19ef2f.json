{"sha": "2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "node_id": "C_kwDOAAsO6NoAKDJlNTY5Mjc0ZDNlY2JiYzc0ZDljNWIzYTg5YTY4ZWUwOWMxOWVmMmY", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-05-25T19:58:36Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-10T20:52:54Z"}, "message": "rustdoc: search for slices and arrays by type with `[]`\n\nPart of #60485", "tree": {"sha": "020c3d9d28407927968cd42623fec0033d252013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/020c3d9d28407927968cd42623fec0033d252013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "html_url": "https://github.com/rust-lang/rust/commit/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ed4c17d90e0d0c46281fc3503106080b39985b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ed4c17d90e0d0c46281fc3503106080b39985b2", "html_url": "https://github.com/rust-lang/rust/commit/3ed4c17d90e0d0c46281fc3503106080b39985b2"}], "stats": {"total": 569, "additions": 487, "deletions": 82}, "files": [{"sha": "984358396ab2a4659de61929a2609618ed907178", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 151, "deletions": 82, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "patch": "@@ -208,6 +208,46 @@ function initSearch(rawSearchIndex) {\n     let typeNameIdMap;\n     const ALIASES = new Map();\n \n+    /**\n+     * Special type name IDs for searching by array.\n+     */\n+    let typeNameIdOfArray;\n+    /**\n+     * Special type name IDs for searching by slice.\n+     */\n+    let typeNameIdOfSlice;\n+    /**\n+     * Special type name IDs for searching by both array and slice (`[]` syntax).\n+     */\n+    let typeNameIdOfArrayOrSlice;\n+\n+    /**\n+     * Add an item to the type Name->ID map, or, if one already exists, use it.\n+     * Returns the number. If name is \"\" or null, return -1 (pure generic).\n+     *\n+     * This is effectively string interning, so that function matching can be\n+     * done more quickly. Two types with the same name but different item kinds\n+     * get the same ID.\n+     *\n+     * @param {string} name\n+     *\n+     * @returns {integer}\n+     */\n+    function buildTypeMapIndex(name) {\n+\n+        if (name === \"\" || name === null) {\n+            return -1;\n+        }\n+\n+        if (typeNameIdMap.has(name)) {\n+            return typeNameIdMap.get(name);\n+        } else {\n+            const id = typeNameIdMap.size;\n+            typeNameIdMap.set(name, id);\n+            return id;\n+        }\n+    }\n+\n     function isWhitespace(c) {\n         return \" \\t\\n\\r\".indexOf(c) !== -1;\n     }\n@@ -217,7 +257,7 @@ function initSearch(rawSearchIndex) {\n     }\n \n     function isEndCharacter(c) {\n-        return \",>-\".indexOf(c) !== -1;\n+        return \",>-]\".indexOf(c) !== -1;\n     }\n \n     function isStopCharacter(c) {\n@@ -466,35 +506,64 @@ function initSearch(rawSearchIndex) {\n \n         let start = parserState.pos;\n         let end;\n-        // We handle the strings on their own mostly to make code easier to follow.\n-        if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n-            start += 1;\n-            getStringElem(query, parserState, isInGenerics);\n-            end = parserState.pos - 1;\n+        if (parserState.userQuery[parserState.pos] === \"[\") {\n+            parserState.pos += 1;\n+            getItemsBefore(query, parserState, generics, \"]\");\n+            const typeFilter = parserState.typeFilter;\n+            if (typeFilter !== null && typeFilter !== \"primitive\") {\n+                throw [\n+                    \"Invalid search type: primitive \",\n+                    \"[]\",\n+                    \" and \",\n+                    typeFilter,\n+                    \" both specified\",\n+                ];\n+            }\n+            parserState.typeFilter = null;\n+            parserState.totalElems += 1;\n+            if (isInGenerics) {\n+                parserState.genericsElems += 1;\n+            }\n+            elems.push({\n+                name: \"[]\",\n+                id: -1,\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics,\n+                typeFilter: \"primitive\",\n+            });\n         } else {\n-            end = getIdentEndPosition(parserState);\n-        }\n-        if (parserState.pos < parserState.length &&\n-            parserState.userQuery[parserState.pos] === \"<\"\n-        ) {\n-            if (start >= end) {\n-                throw [\"Found generics without a path\"];\n+            // We handle the strings on their own mostly to make code easier to follow.\n+            if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n+                start += 1;\n+                getStringElem(query, parserState, isInGenerics);\n+                end = parserState.pos - 1;\n+            } else {\n+                end = getIdentEndPosition(parserState);\n             }\n-            parserState.pos += 1;\n-            getItemsBefore(query, parserState, generics, \">\");\n-        }\n-        if (start >= end && generics.length === 0) {\n-            return;\n+            if (parserState.pos < parserState.length &&\n+                parserState.userQuery[parserState.pos] === \"<\"\n+            ) {\n+                if (start >= end) {\n+                    throw [\"Found generics without a path\"];\n+                }\n+                parserState.pos += 1;\n+                getItemsBefore(query, parserState, generics, \">\");\n+            }\n+            if (start >= end && generics.length === 0) {\n+                return;\n+            }\n+            elems.push(\n+                createQueryElement(\n+                    query,\n+                    parserState,\n+                    parserState.userQuery.slice(start, end),\n+                    generics,\n+                    isInGenerics\n+                )\n+            );\n         }\n-        elems.push(\n-            createQueryElement(\n-                query,\n-                parserState,\n-                parserState.userQuery.slice(start, end),\n-                generics,\n-                isInGenerics\n-            )\n-        );\n     }\n \n     /**\n@@ -518,6 +587,17 @@ function initSearch(rawSearchIndex) {\n         const oldTypeFilter = parserState.typeFilter;\n         parserState.typeFilter = null;\n \n+        let extra = \"\";\n+        if (endChar === \">\") {\n+            extra = \"<\";\n+        } else if (endChar === \"]\") {\n+            extra = \"[\";\n+        } else if (endChar === \"\") {\n+            extra = \"->\";\n+        } else {\n+            extra = endChar;\n+        }\n+\n         while (parserState.pos < parserState.length) {\n             const c = parserState.userQuery[parserState.pos];\n             if (c === endChar) {\n@@ -547,14 +627,6 @@ function initSearch(rawSearchIndex) {\n                 foundStopChar = true;\n                 continue;\n             } else if (isEndCharacter(c)) {\n-                let extra = \"\";\n-                if (endChar === \">\") {\n-                    extra = \"<\";\n-                } else if (endChar === \"\") {\n-                    extra = \"->\";\n-                } else {\n-                    extra = endChar;\n-                }\n                 throw [\"Unexpected \", c, \" after \", extra];\n             }\n             if (!foundStopChar) {\n@@ -581,9 +653,9 @@ function initSearch(rawSearchIndex) {\n             }\n             const posBefore = parserState.pos;\n             start = parserState.pos;\n-            getNextElem(query, parserState, elems, endChar === \">\");\n+            getNextElem(query, parserState, elems, endChar !== \"\");\n             if (endChar !== \"\" && parserState.pos >= parserState.length) {\n-                throw [\"Unclosed \", \"<\"];\n+                throw [\"Unclosed \", extra];\n             }\n             // This case can be encountered if `getNextElem` encountered a \"stop character\" right\n             // from the start. For example if you have `,,` or `<>`. In this case, we simply move up\n@@ -594,7 +666,7 @@ function initSearch(rawSearchIndex) {\n             foundStopChar = false;\n         }\n         if (parserState.pos >= parserState.length && endChar !== \"\") {\n-            throw [\"Unclosed \", \"<\"];\n+            throw [\"Unclosed \", extra];\n         }\n         // We are either at the end of the string or on the `endChar` character, let's move forward\n         // in any case.\n@@ -779,7 +851,8 @@ function initSearch(rawSearchIndex) {\n      *\n      * ident = *(ALPHA / DIGIT / \"_\")\n      * path = ident *(DOUBLE-COLON ident) [!]\n-     * arg = [type-filter *WS COLON *WS] path [generics]\n+     * slice = OPEN-SQUARE-BRACKET [ nonempty-arg-list ] CLOSE-SQUARE-BRACKET\n+     * arg = [type-filter *WS COLON *WS] (path [generics] / slice)\n      * type-sep = COMMA/WS *(COMMA/WS)\n      * nonempty-arg-list = *(type-sep) arg *(type-sep arg) *(type-sep)\n      * generics = OPEN-ANGLE-BRACKET [ nonempty-arg-list ] *(type-sep)\n@@ -821,6 +894,8 @@ function initSearch(rawSearchIndex) {\n      *\n      * OPEN-ANGLE-BRACKET = \"<\"\n      * CLOSE-ANGLE-BRACKET = \">\"\n+     * OPEN-SQUARE-BRACKET = \"[\"\n+     * CLOSE-SQUARE-BRACKET = \"]\"\n      * COLON = \":\"\n      * DOUBLE-COLON = \"::\"\n      * QUOTE = %x22\n@@ -1170,7 +1245,22 @@ function initSearch(rawSearchIndex) {\n                 // ones with no type filter, which can match any entry regardless of its\n                 // own type.\n                 for (const generic of elem.generics) {\n-                    if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n+                    if (generic.typeFilter === TY_PRIMITIVE &&\n+                        generic.id === typeNameIdOfArrayOrSlice) {\n+                        const genericArray = {\n+                            id: typeNameIdOfArray,\n+                            typeFilter: TY_PRIMITIVE,\n+                            generics: generic.generics,\n+                        };\n+                        const genericSlice = {\n+                            id: typeNameIdOfSlice,\n+                            typeFilter: TY_PRIMITIVE,\n+                            generics: generic.generics,\n+                        };\n+                        if (!handleGeneric(genericArray) && !handleGeneric(genericSlice)) {\n+                            return false;\n+                        }\n+                    } else if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n                         return false;\n                     }\n                 }\n@@ -1217,7 +1307,12 @@ function initSearch(rawSearchIndex) {\n                 return row.generics.length > 0 ? checkIfInGenerics(row, elem) : false;\n             }\n \n-            if (row.id === elem.id && typePassesFilter(elem.typeFilter, row.ty)) {\n+            const matchesExact = row.id === elem.id;\n+            const matchesArrayOrSlice = elem.id === typeNameIdOfArrayOrSlice &&\n+                (row.id === typeNameIdOfSlice || row.id === typeNameIdOfArray);\n+\n+            if ((matchesExact || matchesArrayOrSlice) &&\n+                typePassesFilter(elem.typeFilter, row.ty)) {\n                 if (elem.generics.length > 0) {\n                     return checkGenerics(row, elem);\n                 }\n@@ -2082,34 +2177,6 @@ function initSearch(rawSearchIndex) {\n             filterCrates);\n     }\n \n-    /**\n-     * Add an item to the type Name->ID map, or, if one already exists, use it.\n-     * Returns the number. If name is \"\" or null, return -1 (pure generic).\n-     *\n-     * This is effectively string interning, so that function matching can be\n-     * done more quickly. Two types with the same name but different item kinds\n-     * get the same ID.\n-     *\n-     * @param {Map<string, integer>} typeNameIdMap\n-     * @param {string} name\n-     *\n-     * @returns {integer}\n-     */\n-    function buildTypeMapIndex(typeNameIdMap, name) {\n-\n-        if (name === \"\" || name === null) {\n-            return -1;\n-        }\n-\n-        if (typeNameIdMap.has(name)) {\n-            return typeNameIdMap.get(name);\n-        } else {\n-            const id = typeNameIdMap.size;\n-            typeNameIdMap.set(name, id);\n-            return id;\n-        }\n-    }\n-\n     /**\n      * Convert a list of RawFunctionType / ID to object-based FunctionType.\n      *\n@@ -2128,7 +2195,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {Array<FunctionSearchType>}\n      */\n-    function buildItemSearchTypeAll(types, lowercasePaths, typeNameIdMap) {\n+    function buildItemSearchTypeAll(types, lowercasePaths) {\n         const PATH_INDEX_DATA = 0;\n         const GENERICS_DATA = 1;\n         return types.map(type => {\n@@ -2140,15 +2207,14 @@ function initSearch(rawSearchIndex) {\n                 pathIndex = type[PATH_INDEX_DATA];\n                 generics = buildItemSearchTypeAll(\n                     type[GENERICS_DATA],\n-                    lowercasePaths,\n-                    typeNameIdMap\n+                    lowercasePaths\n                 );\n             }\n             return {\n                 // `0` is used as a sentinel because it's fewer bytes than `null`\n                 id: pathIndex === 0\n                     ? -1\n-                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                    : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: generics,\n             };\n@@ -2171,7 +2237,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {null|FunctionSearchType}\n      */\n-    function buildFunctionSearchType(functionSearchType, lowercasePaths, typeNameIdMap) {\n+    function buildFunctionSearchType(functionSearchType, lowercasePaths) {\n         const INPUTS_DATA = 0;\n         const OUTPUT_DATA = 1;\n         // `0` is used as a sentinel because it's fewer bytes than `null`\n@@ -2184,15 +2250,14 @@ function initSearch(rawSearchIndex) {\n             inputs = [{\n                 id: pathIndex === 0\n                     ? -1\n-                    : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                    : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                 ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                 generics: [],\n             }];\n         } else {\n             inputs = buildItemSearchTypeAll(\n                 functionSearchType[INPUTS_DATA],\n-                lowercasePaths,\n-                typeNameIdMap\n+                lowercasePaths\n             );\n         }\n         if (functionSearchType.length > 1) {\n@@ -2201,15 +2266,14 @@ function initSearch(rawSearchIndex) {\n                 output = [{\n                     id: pathIndex === 0\n                         ? -1\n-                        : buildTypeMapIndex(typeNameIdMap, lowercasePaths[pathIndex - 1].name),\n+                        : buildTypeMapIndex(lowercasePaths[pathIndex - 1].name),\n                     ty: pathIndex === 0 ? null : lowercasePaths[pathIndex - 1].ty,\n                     generics: [],\n                 }];\n             } else {\n                 output = buildItemSearchTypeAll(\n                     functionSearchType[OUTPUT_DATA],\n-                    lowercasePaths,\n-                    typeNameIdMap\n+                    lowercasePaths\n                 );\n             }\n         } else {\n@@ -2233,6 +2297,12 @@ function initSearch(rawSearchIndex) {\n         let currentIndex = 0;\n         let id = 0;\n \n+        // Initialize type map indexes for primitive list types\n+        // that can be searched using `[]` syntax.\n+        typeNameIdOfArray = buildTypeMapIndex(\"array\");\n+        typeNameIdOfSlice = buildTypeMapIndex(\"slice\");\n+        typeNameIdOfArrayOrSlice = buildTypeMapIndex(\"[]\");\n+\n         for (const crate in rawSearchIndex) {\n             if (!hasOwnPropertyRustdoc(rawSearchIndex, crate)) {\n                 continue;\n@@ -2363,8 +2433,7 @@ function initSearch(rawSearchIndex) {\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n                     type: buildFunctionSearchType(\n                         itemFunctionSearchTypes[i],\n-                        lowercasePaths,\n-                        typeNameIdMap\n+                        lowercasePaths\n                     ),\n                     id: id,\n                     normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),"}, {"sha": "25997850661458e44cc3e3188cfc37d381810744", "filename": "tests/rustdoc-js-std/option-type-signatures.js", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "raw_url": "https://github.com/rust-lang/rust/raw/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js-std%2Foption-type-signatures.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Foption-type-signatures.js?ref=2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "patch": "@@ -12,4 +12,11 @@ const EXPECTED = [\n             { 'path': 'std::option::Option', 'name': 'get_or_insert_default' },\n         ],\n     },\n+    {\n+        'query': 'option -> []',\n+        'others': [\n+            { 'path': 'std::option::Option', 'name': 'as_slice' },\n+            { 'path': 'std::option::Option', 'name': 'as_mut_slice' },\n+        ],\n+    },\n ];"}, {"sha": "4c0a1defe71051ada4294b407b01288e052dbd8a", "filename": "tests/rustdoc-js-std/parser-slice-array.js", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js-std%2Fparser-slice-array.js", "raw_url": "https://github.com/rust-lang/rust/raw/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js-std%2Fparser-slice-array.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fparser-slice-array.js?ref=2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "patch": "@@ -0,0 +1,308 @@\n+const QUERY = [\n+    '[[[D, []]]',\n+    '[[[D, []]]]',\n+    '[] u8',\n+    '[u8]',\n+    '[u8,u8]',\n+    '[u8<u8>]',\n+    '[]',\n+    '[>',\n+    '[<',\n+    '[a>',\n+    '[a<',\n+    '[a',\n+    '[',\n+    ']',\n+    'primitive:[u8]',\n+    'macro:[u8]',\n+];\n+\n+const PARSED = [\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: '[[[D, []]]',\n+        returned: [],\n+        userQuery: '[[[d, []]]',\n+        error: 'Unclosed `[`',\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"[]\",\n+                        fullPath: [\"[]\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"[]\",\n+                        generics: [\n+                            {\n+                                name: \"[]\",\n+                                fullPath: [\"[]\"],\n+                                pathWithoutLast: [],\n+                                pathLast: \"[]\",\n+                                generics: [\n+                                    {\n+                                        name: \"d\",\n+                                        fullPath: [\"d\"],\n+                                        pathWithoutLast: [],\n+                                        pathLast: \"d\",\n+                                        generics: [],\n+                                        typeFilter: -1,\n+                                    },\n+                                    {\n+                                        name: \"[]\",\n+                                        fullPath: [\"[]\"],\n+                                        pathWithoutLast: [],\n+                                        pathLast: \"[]\",\n+                                        generics: [],\n+                                        typeFilter: 15,\n+                                    },\n+                                ],\n+                                typeFilter: 15,\n+                            },\n+                        ],\n+                        typeFilter: 15,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: '[[[D, []]]]',\n+        returned: [],\n+        userQuery: '[[[d, []]]]',\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [],\n+                typeFilter: 15,\n+            },\n+            {\n+                name: \"u8\",\n+                fullPath: [\"u8\"],\n+                pathWithoutLast: [],\n+                pathLast: \"u8\",\n+                generics: [],\n+                typeFilter: -1,\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"[] u8\",\n+        returned: [],\n+        userQuery: \"[] u8\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8]\",\n+        returned: [],\n+        userQuery: \"[u8]\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8,u8]\",\n+        returned: [],\n+        userQuery: \"[u8,u8]\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [\n+                            {\n+                                name: \"u8\",\n+                                fullPath: [\"u8\"],\n+                                pathWithoutLast: [],\n+                                pathLast: \"u8\",\n+                                generics: [],\n+                                typeFilter: -1,\n+                            },\n+                        ],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[u8<u8>]\",\n+        returned: [],\n+        userQuery: \"[u8<u8>]\",\n+        error: null,\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"[]\",\n+        returned: [],\n+        userQuery: \"[]\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[>\",\n+        returned: [],\n+        userQuery: \"[>\",\n+        error: \"Unexpected `>` after `[`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[<\",\n+        returned: [],\n+        userQuery: \"[<\",\n+        error: \"Found generics without a path\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a>\",\n+        returned: [],\n+        userQuery: \"[a>\",\n+        error: \"Unexpected `>` after `[`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a<\",\n+        returned: [],\n+        userQuery: \"[a<\",\n+        error: \"Unclosed `<`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[a\",\n+        returned: [],\n+        userQuery: \"[a\",\n+        error: \"Unclosed `[`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"[\",\n+        returned: [],\n+        userQuery: \"[\",\n+        error: \"Unclosed `[`\",\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"]\",\n+        returned: [],\n+        userQuery: \"]\",\n+        error: \"Unexpected `]`\",\n+    },\n+    {\n+        elems: [\n+            {\n+                name: \"[]\",\n+                fullPath: [\"[]\"],\n+                pathWithoutLast: [],\n+                pathLast: \"[]\",\n+                generics: [\n+                    {\n+                        name: \"u8\",\n+                        fullPath: [\"u8\"],\n+                        pathWithoutLast: [],\n+                        pathLast: \"u8\",\n+                        generics: [],\n+                        typeFilter: -1,\n+                    },\n+                ],\n+                typeFilter: 15,\n+            },\n+        ],\n+        foundElems: 1,\n+        original: \"primitive:[u8]\",\n+        returned: [],\n+        userQuery: \"primitive:[u8]\",\n+        error: null,\n+    },\n+    {\n+        elems: [],\n+        foundElems: 0,\n+        original: \"macro:[u8]\",\n+        returned: [],\n+        userQuery: \"macro:[u8]\",\n+        error: \"Invalid search type: primitive `[]` and `macro` both specified\",\n+    },\n+];"}, {"sha": "83b9f69d03e90af8a367d8d0a205528df76ee225", "filename": "tests/rustdoc-js/slice-array.js", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js%2Fslice-array.js", "raw_url": "https://github.com/rust-lang/rust/raw/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js%2Fslice-array.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fslice-array.js?ref=2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "patch": "@@ -51,4 +51,23 @@ const EXPECTED = [\n             { 'path': 'slice_array', 'name': 'gamma' },\n         ],\n     },\n+    {\n+        'query': '[TraitDog]',\n+        'in_args': [\n+            { 'path': 'slice_array', 'name': 'gamma' },\n+            { 'path': 'slice_array', 'name': 'epsilon' },\n+        ],\n+    },\n+    {\n+        'query': 'R<[Q]>',\n+        'returned': [\n+            { 'path': 'slice_array', 'name': 'bet' },\n+        ],\n+    },\n+    {\n+        'query': 'R<[P]>',\n+        'in_args': [\n+            { 'path': 'slice_array', 'name': 'alpha' },\n+        ],\n+    },\n ];"}, {"sha": "15ac4294f3d79ce01526efb089ad2842af11995a", "filename": "tests/rustdoc-js/slice-array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js%2Fslice-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f/tests%2Frustdoc-js%2Fslice-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fslice-array.rs?ref=2e569274d3ecbbc74d9c5b3a89a68ee09c19ef2f", "patch": "@@ -14,3 +14,5 @@ pub trait TraitCat {}\n pub trait TraitDog {}\n \n pub fn gamma<T: TraitCat + TraitDog>(t: [T; 32]) {}\n+\n+pub fn epsilon<T: TraitCat + TraitDog>(t: &[T]) {}"}]}