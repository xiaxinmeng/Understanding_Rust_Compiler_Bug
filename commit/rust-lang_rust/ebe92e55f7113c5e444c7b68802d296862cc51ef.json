{"sha": "ebe92e55f7113c5e444c7b68802d296862cc51ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZTkyZTU1ZjcxMTNjNWU0NDRjN2I2ODgwMmQyOTY4NjJjYzUxZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-29T13:45:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-29T13:45:03Z"}, "message": "Auto merge of #31212 - jseyfried:fix_ICE_in_resolve, r=nrc\n\nThis fixes an ICE introduced by #31065 that occurs when a path cannot be resolved because of a certain class of unresolved import (`Indeterminate` imports).\nFor example, this currently causes an ICE:\n```rust\nmod foo { pub use self::*; }\nfn main() { foo::f() }\n```\n\nr? @nrc", "tree": {"sha": "80a0224f4bcb49e344a467ec06b06fbacfc4c799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80a0224f4bcb49e344a467ec06b06fbacfc4c799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe92e55f7113c5e444c7b68802d296862cc51ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe92e55f7113c5e444c7b68802d296862cc51ef", "html_url": "https://github.com/rust-lang/rust/commit/ebe92e55f7113c5e444c7b68802d296862cc51ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe92e55f7113c5e444c7b68802d296862cc51ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f030d1fba198e00d981de9e1cefe596e263aa880", "url": "https://api.github.com/repos/rust-lang/rust/commits/f030d1fba198e00d981de9e1cefe596e263aa880", "html_url": "https://github.com/rust-lang/rust/commit/f030d1fba198e00d981de9e1cefe596e263aa880"}, {"sha": "d2d2144656fadfae2909a6e7995a9c519b41d646", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d2144656fadfae2909a6e7995a9c519b41d646", "html_url": "https://github.com/rust-lang/rust/commit/d2d2144656fadfae2909a6e7995a9c519b41d646"}], "stats": {"total": 108, "additions": 35, "deletions": 73}, "files": [{"sha": "4b62e65bb0f1365ff9657a8914bea3f995a1197b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 70, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ebe92e55f7113c5e444c7b68802d296862cc51ef", "patch": "@@ -44,7 +44,6 @@ use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n use self::AssocItemResolveResult::*;\n-use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n use self::FallbackChecks::*;\n@@ -784,16 +783,6 @@ enum AssocItemResolveResult {\n     ResolveAttempt(Option<PathResolution>),\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n-enum NameSearchType {\n-    /// We're doing a name search in order to resolve a `use` directive.\n-    ImportSearch,\n-\n-    /// We're doing a name search in order to resolve a path type, a path\n-    /// expression, or a path pattern.\n-    PathSearch,\n-}\n-\n #[derive(Copy, Clone)]\n enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(Def, LastPrivate),\n@@ -1370,7 +1359,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      module_path: &[Name],\n                                      index: usize,\n                                      span: Span,\n-                                     name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n                                      -> ResolveResult<(Module<'a>, LastPrivate)> {\n         fn search_parent_externals<'a>(needle: Name, module: Module<'a>)\n@@ -1396,11 +1384,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module,\n-                                              name,\n-                                              TypeNS,\n-                                              name_search_type,\n-                                              false) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1477,8 +1461,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            module_: Module<'a>,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Span,\n-                           name_search_type: NameSearchType)\n+                           span: Span)\n                            -> ResolveResult<(Module<'a>, LastPrivate)> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n@@ -1559,7 +1542,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            module_path,\n                                            start_index,\n                                            span,\n-                                           name_search_type,\n                                            last_private)\n     }\n \n@@ -1658,11 +1640,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Resolve the name in the parent module.\n-            match self.resolve_name_in_module(search_module,\n-                                              name,\n-                                              namespace,\n-                                              PathSearch,\n-                                              true) {\n+            match self.resolve_name_in_module(search_module, name, namespace, true) {\n                 Failed(Some((span, msg))) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 }\n@@ -1787,7 +1765,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               module_: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n-                              name_search_type: NameSearchType,\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n@@ -1811,14 +1788,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        // Next, check the module's imports if necessary.\n-\n-        // If this is a search of all imports, we should be done with glob\n-        // resolution at this point.\n-        if name_search_type == PathSearch {\n-            assert_eq!(module_.glob_count.get(), 0);\n-        }\n-\n         // Check the list of resolved imports.\n         let children = module_.import_resolutions.borrow();\n         match children.get(&name) {\n@@ -2912,9 +2881,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            Indeterminate => {\n-                panic!(\"unexpected indeterminate result\");\n-            }\n+            Indeterminate => return BareIdentifierPatternUnresolved,\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n@@ -3154,11 +3121,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         let current_module = self.current_module;\n-        match self.resolve_module_path(current_module,\n-                                       &module_path[..],\n-                                       UseLexicalScope,\n-                                       span,\n-                                       PathSearch) {\n+        match self.resolve_module_path(current_module, &module_path, UseLexicalScope, span) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -3172,19 +3135,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n-            Indeterminate => panic!(\"indeterminate unexpected\"),\n+            Indeterminate => return None,\n             Success((resulting_module, resulting_last_private)) => {\n                 containing_module = resulting_module;\n                 last_private = resulting_last_private;\n             }\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_name_in_module(containing_module,\n-                                                    name,\n-                                                    namespace,\n-                                                    NameSearchType::PathSearch,\n-                                                    false) {\n+        let def = match self.resolve_name_in_module(containing_module, name, namespace, false) {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n@@ -3219,7 +3178,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                  &module_path[..],\n                                                  0,\n                                                  span,\n-                                                 PathSearch,\n                                                  LastMod(AllPublic)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n@@ -3235,9 +3193,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 return None;\n             }\n \n-            Indeterminate => {\n-                panic!(\"indeterminate unexpected\");\n-            }\n+            Indeterminate => return None,\n \n             Success((resulting_module, resulting_last_private)) => {\n                 containing_module = resulting_module;\n@@ -3246,11 +3202,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_name_in_module(containing_module,\n-                                          name,\n-                                          namespace,\n-                                          NameSearchType::PathSearch,\n-                                          false) {\n+        match self.resolve_name_in_module(containing_module, name, namespace, false) {\n             Success((Target { binding, .. }, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n@@ -3292,7 +3244,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Success((target, _)) = self.resolve_name_in_module(module,\n                                                                           ident.unhygienic_name,\n                                                                           namespace,\n-                                                                          PathSearch,\n                                                                           true) {\n                     if let Some(def) = target.binding.def() {\n                         return Some(LocalDef::from_def(def));\n@@ -3332,9 +3283,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-            Indeterminate => {\n-                panic!(\"unexpected indeterminate result\");\n-            }\n+            Indeterminate => None,\n             Failed(err) => {\n                 debug!(\"(resolving item path by identifier in lexical scope) failed to resolve {}\",\n                        name);\n@@ -3390,11 +3339,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             } else {\n-                match this.resolve_module_path(root,\n-                                               &name_path[..],\n-                                               UseLexicalScope,\n-                                               span,\n-                                               PathSearch) {\n+                match this.resolve_module_path(root, &name_path, UseLexicalScope, span) {\n                     Success((module, _)) => Some(module),\n                     _ => None,\n                 }\n@@ -3640,10 +3585,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let current_module = self.current_module;\n \n                                     match self.resolve_module_path(current_module,\n-                                                   &name_path[..],\n-                                                   UseLexicalScope,\n-                                                   expr.span,\n-                                                   PathSearch) {\n+                                                                   &name_path[..],\n+                                                                   UseLexicalScope,\n+                                                                   expr.span) {\n                                         Success(_) => {\n                                             context = UnresolvedNameContext::PathIsMod(expr.id);\n                                         },"}, {"sha": "364218d84137cf0648801f185743b31899e7eade", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ebe92e55f7113c5e444c7b68802d296862cc51ef", "patch": "@@ -16,7 +16,6 @@ use Namespace::{self, TypeNS, ValueNS};\n use {NameBindings, NameBinding};\n use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n use NamespaceResult;\n-use NameSearchType;\n use ResolveResult;\n use Resolver;\n use UseLexicalScopeFlag;\n@@ -321,8 +320,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             match self.resolver.resolve_module_path(module_,\n                                                     &module_path[..],\n                                                     UseLexicalScopeFlag::DontUseLexicalScope,\n-                                                    import_directive.span,\n-                                                    NameSearchType::ImportSearch) {\n+                                                    import_directive.span) {\n                 ResolveResult::Failed(err) => {\n                     resolution_result = ResolveResult::Failed(err);\n                     None"}, {"sha": "b9a4de701f513402e745bfb33d4c5c8566284642", "filename": "src/test/compile-fail/issue-31212.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Ftest%2Fcompile-fail%2Fissue-31212.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe92e55f7113c5e444c7b68802d296862cc51ef/src%2Ftest%2Fcompile-fail%2Fissue-31212.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31212.rs?ref=ebe92e55f7113c5e444c7b68802d296862cc51ef", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This checks that a path that cannot be resolved because of an indeterminate import\n+// does not trigger an ICE.\n+\n+mod foo {\n+    pub use self::*; //~ ERROR unresolved\n+}\n+\n+fn main() {\n+    foo::f(); //~ ERROR unresolved\n+}"}]}