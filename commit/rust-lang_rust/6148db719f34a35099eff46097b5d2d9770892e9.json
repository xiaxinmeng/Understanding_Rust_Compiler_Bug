{"sha": "6148db719f34a35099eff46097b5d2d9770892e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNDhkYjcxOWYzNGEzNTA5OWVmZjQ2MDk3YjVkMmQ5NzcwODkyZTk=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-12T12:45:41Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-04-23T22:14:07Z"}, "message": "Modify `as_local_hir_id` to accept a `LocalDefId` instead of a `DefId`", "tree": {"sha": "fea7df58a9c88ef2cada621f44cb3ccbafc2d9f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fea7df58a9c88ef2cada621f44cb3ccbafc2d9f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6148db719f34a35099eff46097b5d2d9770892e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6148db719f34a35099eff46097b5d2d9770892e9", "html_url": "https://github.com/rust-lang/rust/commit/6148db719f34a35099eff46097b5d2d9770892e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6148db719f34a35099eff46097b5d2d9770892e9/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92fb59d7f37596f91b8d4619c4d146f273349b4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/92fb59d7f37596f91b8d4619c4d146f273349b4c", "html_url": "https://github.com/rust-lang/rust/commit/92fb59d7f37596f91b8d4619c4d146f273349b4c"}], "stats": {"total": 1023, "additions": 579, "deletions": 444}, "files": [{"sha": "6ad75cff3ddb6be9af1c8cced0c99c0f50930e60", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -116,7 +116,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n                 if cx.tcx.sess.opts.share_generics() {\n                     // We are in share_generics mode.\n \n-                    if instance_def_id.is_local() {\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n                         // This is a definition from the current crate. If the\n                         // definition is unreachable for downstream crates or\n                         // the current crate does not re-export generics, the"}, {"sha": "ac2f47a740d571391af8ef3767cf927a920368c2", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -209,7 +209,9 @@ impl CodegenCx<'ll, 'tcx> {\n \n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n-        let g = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        let g = if let Some(id) =\n+            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+        {\n             let llty = self.layout_of(ty).llvm_type(self);\n             let (g, attrs) = match self.tcx.hir().get(id) {\n                 Node::Item(&hir::Item { attrs, span, kind: hir::ItemKind::Static(..), .. }) => {"}, {"sha": "5970059bb4ca99bf2f8000353a77456993d54f9a", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -361,8 +361,8 @@ fn upstream_drop_glue_for_provider<'tcx>(\n }\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&hir_id)\n+    if let Some(def_id) = def_id.as_local() {\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().as_local_hir_id(def_id).unwrap())\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "8927814ee04ba2d204783f5bd964c2458cb5a045", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -342,12 +342,8 @@ impl Definitions {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n-        if let Some(def_id) = def_id.as_local() {\n-            Some(self.local_def_id_to_hir_id(def_id))\n-        } else {\n-            None\n-        }\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> Option<hir::HirId> {\n+        Some(self.local_def_id_to_hir_id(def_id))\n     }\n \n     #[inline]"}, {"sha": "7d8924718bb04197d7e23d2ac63be37e0500c2b1", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -191,7 +191,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope).unwrap();\n+    let node = tcx.hir().as_local_hir_id(scope.expect_local()).unwrap();\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_) | Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),\n@@ -1782,10 +1782,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if !(generics.has_self && param.index == 0) {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n-                        hir.as_local_hir_id(type_param.def_id).map(|id| {\n+                        type_param.def_id.as_local().map(|def_id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n+                            let id = hir.as_local_hir_id(def_id).unwrap();\n                             let mut has_bounds = false;\n                             if let Node::GenericParam(param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();"}, {"sha": "d0141dc062af8e6c4bd9e69e00ef2ad5b37eacbe", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -29,7 +29,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n+            if let Some(hir_id) =\n+                def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 let fndecl = match self.tcx().hir().get(hir_id) {\n                     Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n                     | Node::TraitItem(&hir::TraitItem {"}, {"sha": "6bf60db0094973919f1a2da4093b72db4925b8bd", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -46,7 +46,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = (&sub_origin, sup_region)\n             {\n                 let hir = &self.tcx().hir();\n-                if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n+                if let Some(hir_id) =\n+                    free_region.scope.as_local().map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                {\n                     if let Node::Expr(Expr { kind: Closure(_, _, _, closure_span, None), .. }) =\n                         hir.get(hir_id)\n                     {"}, {"sha": "ab74513a6755d88d8ccd9f25440de268b6ea9e44", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        let hir_id = hir.as_local_hir_id(id)?;\n+        let hir_id = hir.as_local_hir_id(id.as_local()?)?;\n         let body_id = hir.maybe_body_owned_by(hir_id)?;\n         let body = hir.body(body_id);\n         let owner_id = hir.body_owner(body_id);"}, {"sha": "4040545db968b8edd47d92cde9605d0624f4cf36", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -436,7 +436,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n-                if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n+                if let Some(hir_id) = real_trait\n+                    .as_local()\n+                    .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                {\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n                             for impl_item_ref in items {\n@@ -609,7 +612,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n             let mut impls = HirIdSet::default();\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(ty_def.did) {\n+                    if let Some(hir_id) = ty_def\n+                        .did\n+                        .as_local()\n+                        .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    {\n                         impls.insert(hir_id);\n                     }\n                 }"}, {"sha": "0a0505e89d46869dfd1e686e77717314e09f6f39", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -19,7 +19,7 @@ use rustc_ast::ast;\n use rustc_ast::walk_list;\n use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit as hir_visit;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::hir::map::Map;\n@@ -353,7 +353,7 @@ crate::late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n \n fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n+    module_def_id: LocalDefId,\n     pass: T,\n ) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -382,7 +382,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n     tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n+    module_def_id: LocalDefId,\n     builtin_lints: T,\n ) {\n     if tcx.sess.opts.debugging_opts.no_interleave_lints {"}, {"sha": "1041ad0186681dc3aa86d3887106820e118b994e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -91,7 +91,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+    late::late_lint_mod(\n+        tcx,\n+        module_def_id.expect_local(),\n+        BuiltinCombinedModuleLateLintPass::new(),\n+    );\n }\n \n macro_rules! pre_expansion_lint_passes {"}, {"sha": "7abd454a6f3066836a014630af66ac6ce9352fb1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -617,7 +617,7 @@ impl EncodeContext<'tcx> {\n             ctor: variant.ctor_def_id.map(|did| did.index),\n         };\n \n-        let enum_id = tcx.hir().as_local_hir_id(def.did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local()).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n@@ -663,7 +663,7 @@ impl EncodeContext<'tcx> {\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().as_local_hir_id(def.did).unwrap();\n+        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local()).unwrap();\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n@@ -729,7 +729,7 @@ impl EncodeContext<'tcx> {\n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n+        let variant_id = tcx.hir().as_local_hir_id(variant.def_id.expect_local()).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n@@ -756,7 +756,7 @@ impl EncodeContext<'tcx> {\n             ctor: Some(def_id.index),\n         };\n \n-        let struct_id = tcx.hir().as_local_hir_id(adt_def.did).unwrap();\n+        let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local()).unwrap();\n         let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n@@ -818,7 +818,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         let ast_item = tcx.hir().expect_trait_item(hir_id);\n         let trait_item = tcx.associated_item(def_id);\n \n@@ -909,7 +909,7 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         let ast_item = self.tcx.hir().expect_impl_item(hir_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n@@ -1309,14 +1309,14 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n-        let def_id = def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck_tables_of.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n+        let def_id = def_id.to_def_id();\n         record!(self.tables.kind[def_id] <- match ty.kind {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n@@ -1340,11 +1340,11 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n-        let def_id = def_id.to_def_id();\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n         let id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n+        let def_id = def_id.to_def_id();\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Const(qualifs, const_data));"}, {"sha": "0aca0f6e5b73449043b9e9d8a2ee85f8e40b541b", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n \n mod dep_node;\n \n@@ -106,7 +106,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         match dep_node.kind {\n             DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n                 if let Some(def_id) = dep_node.extract_def_id(*self) {\n-                    if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n+                    if def_id_corresponds_to_hir_dep_node(*self, def_id.expect_local()) {\n                         if dep_node.kind == DepKind::CrateMetadata {\n                             // The `DefPath` has corresponding node,\n                             // and that node should have been marked\n@@ -180,7 +180,7 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n     }\n }\n \n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner.local_def_index\n+    def_id == hir_id.owner\n }"}, {"sha": "1dbb333708e421b3c5737704dc4f6e633c86d38f", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -198,7 +198,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> Option<HirId> {\n         self.tcx.definitions.as_local_hir_id(def_id)\n     }\n \n@@ -448,7 +448,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n+    pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         match self.get_entry(hir_id).node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n@@ -482,7 +482,11 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        self.as_local_hir_id(id).map(|id| self.get(id))\n+        if let Some(id) = id.as_local() {\n+            self.as_local_hir_id(id).map(|id| self.get(id))\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n@@ -883,7 +887,11 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        self.as_local_hir_id(id).map(|id| self.span(id))\n+        if let Some(id) = id.as_local() {\n+            self.as_local_hir_id(id).map(|id| self.span(id))\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn res_span(&self, res: Res) -> Option<Span> {\n@@ -1083,8 +1091,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.def_kind = |tcx, def_id| {\n-        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-            tcx.hir().def_kind(hir_id)\n+        if let Some(def_id) = def_id.as_local() {\n+            tcx.hir().def_kind(tcx.hir().as_local_hir_id(def_id).unwrap())\n         } else {\n             bug!(\"calling local def_kind query provider for upstream DefId: {:?}\", def_id);\n         }"}, {"sha": "c44a8b0b12e72f80342b6cadd5dabb65d72f72ac", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -68,13 +68,13 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers<'_>) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id.to_def_id()).unwrap()))\n+        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id).unwrap()))\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n     providers.hir_module_items = |tcx, id| {\n         let hir = tcx.hir();\n-        let module = hir.as_local_hir_id(id.to_def_id()).unwrap();\n+        let module = hir.as_local_hir_id(id).unwrap();\n         &tcx.untracked_crate.modules[&module]\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;"}, {"sha": "41f712f600aa0d44c73d789c3c7006d6d5adf054", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> ScopeTree {\n     pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local()).unwrap();\n         let scope = tcx\n             .hir()\n             .maybe_body_owned_by(param_owner_id)\n@@ -595,7 +595,7 @@ impl<'tcx> ScopeTree {\n         // on the same function that they ended up being freed in.\n         assert_eq!(param_owner, fr.scope);\n \n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n+        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local()).unwrap();\n         let body_id = tcx.hir().body_owned_by(param_owner_id);\n         Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n     }"}, {"sha": "96012c9e6538f327af6dda4172c1f6c5375b79e7", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -2338,7 +2338,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(hir_id) = def_id\n+                            .as_local()\n+                            .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(&substs).unwrap();\n                                 format!(\n@@ -2364,7 +2367,10 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     }),\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n-                        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(hir_id) = def_id\n+                            .as_local()\n+                            .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        {\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n "}, {"sha": "1b18060c886657f0d60bd868ebaf9d87799dd612", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -197,8 +197,12 @@ impl<'tcx> MonoItem<'tcx> {\n \n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n-            MonoItem::Fn(Instance { def, .. }) => tcx.hir().as_local_hir_id(def.def_id()),\n-            MonoItem::Static(def_id) => tcx.hir().as_local_hir_id(def_id),\n+            MonoItem::Fn(Instance { def, .. }) => {\n+                def.def_id().as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+            }\n+            MonoItem::Static(def_id) => {\n+                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+            }\n             MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n         }\n         .map(|hir_id| tcx.hir().span(hir_id))\n@@ -339,7 +343,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def_id) => tcx.hir().as_local_hir_id(def_id),\n+                            InstanceDef::Item(def_id) => def_id\n+                                .as_local()\n+                                .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap()),\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -350,7 +356,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::CloneShim(..) => None,\n                         }\n                     }\n-                    MonoItem::Static(def_id) => tcx.hir().as_local_hir_id(def_id),\n+                    MonoItem::Static(def_id) => {\n+                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    }\n                     MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n                 },\n                 item.symbol_name(tcx),"}, {"sha": "618a83dc38fd68f8c0e5e3c3d2056d1c9e7a3791", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -277,7 +277,7 @@ rustc_queries! {\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n-                let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n+                let id = tcx.hir().as_local_hir_id(key.1.expect_local()).unwrap();\n                 tcx.hir().ty_param_name(id)\n             }}\n         }"}, {"sha": "85d216d9ca9044f56f73aca287edb9d029937d3b", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1413,7 +1413,8 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope).unwrap();\n+        let hir_id =\n+            self.hir().as_local_hir_id(suitable_region_binding_scope.expect_local()).unwrap();\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1431,7 +1432,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local()).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {"}, {"sha": "9839bd806bd61c77542fbebd252c0fc58e05c28f", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -2667,12 +2667,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n-        self.hir().as_local_hir_id(def_id).and_then(|hir_id| self.hir().get(hir_id).ident())\n+        def_id\n+            .as_local()\n+            .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id).unwrap()).ident())\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n-        let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n-            match self.hir().get(hir_id) {\n+        let is_associated_item = if let Some(def_id) = def_id.as_local() {\n+            match self.hir().get(self.hir().as_local_hir_id(def_id).unwrap()) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -2824,8 +2826,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n-        if let Some(id) = self.hir().as_local_hir_id(did) {\n-            self.hir().attrs(id)\n+        if let Some(did) = did.as_local() {\n+            self.hir().attrs(self.hir().as_local_hir_id(did).unwrap())\n         } else {\n             self.item_attrs(did)\n         }\n@@ -2863,7 +2865,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n-        if impl_did.is_local() {\n+        if let Some(impl_did) = impl_did.as_local() {\n             let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n             Ok(self.hir().span(hir_id))\n         } else {\n@@ -2924,8 +2926,8 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-        if let Node::Item(item) = tcx.hir().get(hir_id) {\n+    if let Some(def_id) = def_id.as_local() {\n+        if let Node::Item(item) = tcx.hir().get(tcx.hir().as_local_hir_id(def_id).unwrap()) {\n             if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }"}, {"sha": "646fc6fc8eb9de365ff49bdbcceb106f5c842928", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -608,7 +608,9 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                if let Some(hir_id) =\n+                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did).unwrap())\n+                {\n                     p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n \n                     if substs.as_generator().is_valid() {\n@@ -652,7 +654,9 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(write(\"[closure\"));\n \n                 // FIXME(eddyb) should use `def_span`.\n-                if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n+                if let Some(hir_id) =\n+                    did.as_local().map(|did| self.tcx().hir().as_local_hir_id(did).unwrap())\n+                {\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@\"), print_def_path(did, substs));\n                     } else {"}, {"sha": "4edd8420ebec1cf7db0af4ad1cf9cdf3a5b421f2", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -2266,7 +2266,7 @@ impl<'tcx> Const<'tcx> {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n                 // Find the name and index of the const parameter by indexing the generics of\n                 // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id.to_def_id());"}, {"sha": "f4e75b1c971e66385b559d724ea778c69d50a8d4", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -192,7 +192,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local()).unwrap();\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n                 }\n@@ -864,7 +864,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(fn_hir_id) = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id) {\n+            if let Some(fn_hir_id) = self\n+                .mir_def_id\n+                .as_local()\n+                .map(|def_id| self.infcx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 err.span_label(\n                     drop_span,\n                     format!(\n@@ -1782,7 +1786,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did)?;\n+        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did.as_local()?)?;\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking"}, {"sha": "b3c6bee03ae52d6b579d1eaa8a101b2c976959dd", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local()).unwrap();\n \n                     if let Some((span, name)) =\n                         self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -119,7 +119,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n-                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n+                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local()).unwrap();\n \n                 if let Some((span, name)) =\n                     self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -803,7 +803,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id)?;\n+        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id.as_local()?)?;\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {"}, {"sha": "0614538f4e40ac8ef577902276d0ae7930b6403c", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id).unwrap();\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);\n@@ -691,7 +691,7 @@ fn annotate_struct_field(\n         if let ty::Adt(def, _) = ty.kind {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().as_local_hir_id(field.did)?;\n+            let hir_id = tcx.hir().as_local_hir_id(field.did.as_local()?)?;\n             let node = tcx.hir().find(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type."}, {"sha": "74cdccd7e3f01b341fdfe403d91ff84004ccf00e", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -241,8 +241,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         .infcx\n                         .tcx\n                         .hir()\n-                        .as_local_hir_id(self.mir_def_id)\n-                        .expect(\"non-local mir\");\n+                        .as_local_hir_id(self.mir_def_id.expect_local())\n+                        .unwrap();\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -328,7 +328,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?)?;\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -639,7 +639,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -691,7 +691,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local()).unwrap();\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "7de890dfa6cb4cf7cfdf7c1486e16a12689d087c", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -5,7 +5,10 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::{def_id::DefId, HirId, Node};\n+use rustc_hir::{\n+    def_id::{DefId, LocalDefId},\n+    HirId, Node,\n+};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -96,7 +99,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> &BorrowCheckResult<'_> {\n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n+        do_mir_borrowck(&infcx, input_body, promoted, def_id.expect_local())\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -107,13 +110,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     infcx: &InferCtxt<'a, 'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> BorrowCheckResult<'tcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n \n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(def_id);\n-    let id = tcx.hir().as_local_hir_id(def_id).expect(\"do_mir_borrowck: non-local DefId\");\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n@@ -140,7 +143,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n     let upvars: Vec<_> = tables\n         .upvar_list\n-        .get(&def_id)\n+        .get(&def_id.to_def_id())\n         .into_iter()\n         .flat_map(|v| v.values())\n         .map(|upvar_id| {\n@@ -171,7 +174,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id.to_def_id(), param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -186,7 +189,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mdpe = MoveDataParamEnv { move_data, param_env };\n \n     let mut flow_inits = MaybeInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n@@ -203,7 +206,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         nll_errors,\n     } = nll::compute_regions(\n         infcx,\n-        def_id,\n+        def_id.to_def_id(),\n         free_regions,\n         body,\n         &promoted,\n@@ -216,14 +219,20 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(infcx, MirSource::item(def_id), &body, &regioncx, &opt_closure_req);\n+    nll::dump_mir_results(\n+        infcx,\n+        MirSource::item(def_id.to_def_id()),\n+        &body,\n+        &regioncx,\n+        &opt_closure_req,\n+    );\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n         infcx,\n         &body,\n-        def_id,\n+        def_id.to_def_id(),\n         &regioncx,\n         &opt_closure_req,\n         &opaque_type_values,\n@@ -238,13 +247,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let regioncx = Rc::new(regioncx);\n \n     let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n     let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body, def_id)\n+        .into_engine(tcx, &body, def_id.to_def_id())\n         .iterate_to_fixpoint();\n \n     let movable_generator = match tcx.hir().get(id) {\n@@ -260,7 +269,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id,\n+        mir_def_id: def_id.to_def_id(),\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,"}, {"sha": "e0cfcdb87a5a91e0182789a4da6b743714587a25", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -66,7 +66,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def_id.expect_local(), param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);"}, {"sha": "931e01d30718524fdd83452406d10c41ea899892", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1989,7 +1989,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n                             let ccx = ConstCx::new_with_param_env(\n                                 tcx,\n-                                self.mir_def_id,\n+                                self.mir_def_id.expect_local(),\n                                 body,\n                                 self.param_env,\n                             );"}, {"sha": "de985cb37c56df719f46c4c23ec7f4d6d291e18a", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -16,7 +16,7 @@ use either::Either;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -220,12 +220,13 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// known between those regions.\n     pub fn new(\n         infcx: &InferCtxt<'_, 'tcx>,\n-        mir_def_id: DefId,\n+        mir_def_id: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n         let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).unwrap();\n-        UniversalRegionsBuilder { infcx, mir_def_id, mir_hir_id, param_env }.build()\n+        UniversalRegionsBuilder { infcx, mir_def_id: mir_def_id.to_def_id(), mir_hir_id, param_env }\n+            .build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values"}, {"sha": "6b6d02dedcb58f63032f2be255d347e74e80ea92", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -342,7 +342,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n                     Some(DefKind::Const | DefKind::AssocConst) => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def_id)),\n                             \"any use of this value will cause an error\",\n@@ -365,7 +365,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                                 err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                                    tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap(),\n                                     Some(err.span),\n                                 )\n                             }"}, {"sha": "8decebf6f8c2c0b9c67120cbb16d905f76229ac6", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -90,8 +90,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic is on the whitelist for being const callable.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id =\n-        tcx.hir().as_local_hir_id(def_id).expect(\"Non-local call to local provider is_const_fn\");\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "a65b14e64f1bb0eeee4236d2922d6e60fd8544f8", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -430,7 +430,9 @@ fn check_recursion_limit<'tcx>(\n     // infinite expansion.\n     if adjusted_recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n-        if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(hir_id) =\n+            def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+        {\n             tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n         } else {\n             tcx.sess.fatal(&error);"}, {"sha": "a0692cf8a70951dd8e57e0530530d708a50691e8", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -5,7 +5,7 @@\n //! it finds operations that are invalid in a certain context.\n \n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -29,20 +29,20 @@ pub struct ConstCx<'mir, 'tcx> {\n }\n \n impl ConstCx<'mir, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'mir mir::Body<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'mir mir::Body<'tcx>) -> Self {\n         let param_env = tcx.param_env(def_id);\n         Self::new_with_param_env(tcx, def_id, body, param_env)\n     }\n \n     pub fn new_with_param_env(\n         tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         body: &'mir mir::Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let const_kind = ConstKind::for_item(tcx, def_id);\n \n-        ConstCx { body, tcx, def_id, param_env, const_kind }\n+        ConstCx { body, tcx, def_id: def_id.to_def_id(), param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n@@ -69,7 +69,7 @@ pub enum ConstKind {\n impl ConstKind {\n     /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n     /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Option<Self> {\n         use hir::BodyOwnerKind as HirKind;\n \n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();"}, {"sha": "609499d25fde8d02b02210f479bd975603b21cf3", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -190,7 +190,7 @@ impl Validator<'a, 'mir, 'tcx> {\n             const_kind == Some(ConstKind::Static) && !tcx.has_attr(def_id, sym::thread_local);\n \n         if should_check_for_sync {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n             check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }"}, {"sha": "6f9d007f9d364a7bc3fd16f08f97c0358304638d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::Node;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n@@ -465,12 +465,11 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n \n fn check_unused_unsafe(\n     tcx: TyCtxt<'_>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     used_unsafe: &FxHashSet<hir::HirId>,\n     unsafe_blocks: &mut Vec<(hir::HirId, bool)>,\n ) {\n-    let body_id =\n-        tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| tcx.hir().maybe_body_owned_by(hir_id));\n+    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().as_local_hir_id(def_id).unwrap());\n \n     let body_id = match body_id {\n         Some(body) => body,\n@@ -495,7 +494,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n \n     let param_env = tcx.param_env(def_id);\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n@@ -504,18 +503,20 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n     checker.visit_body(&body);\n \n-    check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n+    check_unused_unsafe(\n+        tcx,\n+        def_id.expect_local(),\n+        &checker.used_unsafe,\n+        &mut checker.inherited_blocks,\n+    );\n     UnsafetyCheckResult {\n         violations: checker.violations.into(),\n         unsafe_blocks: checker.inherited_blocks.into(),\n     }\n }\n \n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let lint_hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n+    let lint_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its"}, {"sha": "8647c3f07275b292db46599034bd2fc6dca0a299", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -66,10 +66,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         use rustc_middle::hir::map::blocks::FnLikeNode;\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(source.def_id())\n-            .expect(\"Non-local call to local provider is_const_fn\");\n+        let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local()).unwrap();\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n         let is_assoc_const = match tcx.def_kind(source.def_id()) {"}, {"sha": "cf0197659c80209970ea462964c7c1226b8d0a91", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -69,7 +69,7 @@ impl Inliner<'tcx> {\n         let param_env = self.tcx.param_env(self.source.def_id()).with_reveal_all();\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n+        let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local()).unwrap();\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) =\n@@ -94,10 +94,14 @@ impl Inliner<'tcx> {\n                     continue;\n                 }\n \n-                let callee_hir_id = self.tcx.hir().as_local_hir_id(callsite.callee);\n+                let callee_hir_id = self.tcx.hir().as_local_hir_id(callsite.callee.expect_local());\n \n                 let callee_body = if let Some(callee_hir_id) = callee_hir_id {\n-                    let self_hir_id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n+                    let self_hir_id = self\n+                        .tcx\n+                        .hir()\n+                        .as_local_hir_id(self.source.def_id().expect_local())\n+                        .unwrap();\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation."}, {"sha": "a5ed059ba09e74ff1b1abe38072d884d15e7bfe5", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -176,7 +176,7 @@ pub fn run_passes(\n }\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let const_kind = check_consts::ConstKind::for_item(tcx, def_id);\n+    let const_kind = check_consts::ConstKind::for_item(tcx, def_id.expect_local());\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {"}, {"sha": "0b73643e33956dace465cda90d4c3500d6c58b6d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n         let def_id = src.def_id();\n \n         let mut rpo = traversal::reverse_postorder(body);\n-        let ccx = ConstCx::new(tcx, def_id, body);\n+        let ccx = ConstCx::new(tcx, def_id.expect_local(), body);\n         let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n         let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);"}, {"sha": "d2f1920b26344d10f774f7d6beaf6344a1bfbaa3", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -13,7 +13,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     // Prevent const trait methods from being annotated as `stable`.\n     if tcx.features().staged_api {\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n             return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n         }"}, {"sha": "595f39d028de5d6f688c88e0e9438c7508e32225", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -285,7 +285,7 @@ fn dump_matched_mir_node<'tcx>(\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_hir_id(source.def_id()).unwrap();\n+    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local()).unwrap();\n     let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n     file_path.push(&file_name);\n     let _ = fs::File::create(&file_path).and_then(|file| {"}, {"sha": "ce3df93bf1e2f3984a1ea95920f87611af1e4f84", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -22,11 +22,11 @@ use rustc_target::spec::PanicStrategy;\n use super::lints;\n \n crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<Body<'_>> {\n-    tcx.alloc_steal_mir(mir_build(tcx, def_id))\n+    tcx.alloc_steal_mir(mir_build(tcx, def_id.expect_local()))\n }\n \n /// Construct the MIR for a given `DefId`.\n-fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n+fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -181,7 +181,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> Body<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id);\n+        lints::check(tcx, &body, def_id.to_def_id());\n \n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here."}, {"sha": "9669090eb4669f0b2c768dd1e25e09a2b4ef16b1", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -690,7 +690,7 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n             let item_id = cx.tcx.hir().get_parent_node(hir_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);"}, {"sha": "14f36038232a6c48ca1d9eedcfe674786160007d", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -21,9 +21,9 @@ use rustc_span::{sym, Span};\n use std::slice;\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n-    let body_id = match tcx.hir().as_local_hir_id(def_id) {\n+    let body_id = match def_id.as_local() {\n         None => return,\n-        Some(id) => tcx.hir().body_owned_by(id),\n+        Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id).unwrap()),\n     };\n \n     let mut visitor ="}, {"sha": "dd2d6b06c18e833647e75bc425520341485dd645", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -11,7 +11,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         if let FnKind::Closure(_) = fn_like_node.kind() {\n@@ -37,7 +37,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n \n         vis.reachable_recursive_calls.sort();\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");"}, {"sha": "6ce1a7ef777647b8ceed84e94044cecc70c92885", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -52,7 +52,8 @@ struct MarkSymbolVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n             if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n@@ -61,7 +62,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n             debug_assert!(!should_explore(self.tcx, hir_id));\n             self.live_symbols.insert(hir_id);\n         }\n@@ -450,7 +452,8 @@ fn create_and_seed_worklist<'tcx>(\n         )\n         .chain(\n             // Seed entry point\n-            tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id).unwrap()),\n+            tcx.entry_fn(LOCAL_CRATE)\n+                .map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap()),\n         )\n         .collect::<Vec<_>>();\n \n@@ -534,7 +537,9 @@ impl DeadVisitor<'tcx> {\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n-                if let Some(item_hir_id) = self.tcx.hir().as_local_hir_id(item_did) {\n+                if let Some(item_hir_id) =\n+                    item_did.as_local().map(|did| self.tcx.hir().as_local_hir_id(did).unwrap())\n+                {\n                     if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }"}, {"sha": "a8ab127ddf836712b0e950c86fcefdabe34f53f4", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -53,7 +53,7 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src.to_def_id()) {\n+    if let Some(impl_hir_id) = tcx.hir().as_local_hir_id(impl_src) {\n         match tcx.hir().find(impl_hir_id) {\n             Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n@@ -108,9 +108,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n             }\n             Some(res) => {\n                 if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n+                    def_id\n+                        .as_local()\n+                        .map(|def_id| (self.tcx.hir().as_local_hir_id(def_id).unwrap(), def_id))\n                 }) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n+                    if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n                         self.worklist.push(hir_id);\n                     } else {\n                         match res {\n@@ -141,8 +143,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-            Some(hir_id) => hir_id,\n+        let hir_id = match def_id.as_local() {\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id).unwrap(),\n             None => {\n                 return false;\n             }\n@@ -170,7 +172,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n-                            let impl_did = self.tcx.hir().get_parent_did(hir_id).to_def_id();\n+                            let impl_did = self.tcx.hir().get_parent_did(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n@@ -360,8 +362,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n                 self.worklist.extend(\n-                    tcx.provided_trait_methods(trait_def_id)\n-                        .map(|assoc| tcx.hir().as_local_hir_id(assoc.def_id).unwrap()),\n+                    tcx.provided_trait_methods(trait_def_id).map(|assoc| {\n+                        tcx.hir().as_local_hir_id(assoc.def_id.expect_local()).unwrap()\n+                    }),\n                 );\n             }\n         }\n@@ -400,7 +403,8 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap())\n+            {\n                 reachable_context.worklist.push(hir_id);\n             }\n         }"}, {"sha": "3a9edd0410e0c21c0a5f029895c7a47112391fe8", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -807,7 +807,7 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,"}, {"sha": "0cdc4f5bd8f747bbbdbc48340cb37edba01a752b", "filename": "src/librustc_passes/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -15,7 +15,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n             return None;\n         }\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();"}, {"sha": "c268189c5b2e767354ffef31e0b7a32d505cedee", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -235,7 +235,7 @@ fn def_id_visibility<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (ty::Visibility, Span, &'static str) {\n-    match tcx.hir().as_local_hir_id(def_id) {\n+    match def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap()) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n@@ -445,7 +445,9 @@ impl VisibilityLike for Option<AccessLevel> {\n     const SHALLOW: bool = true;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(\n-            if let Some(hir_id) = find.tcx.hir().as_local_hir_id(def_id) {\n+            if let Some(hir_id) =\n+                def_id.as_local().map(|def_id| find.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 find.access_levels.map.get(&hir_id).cloned()\n             } else {\n                 Self::MAX\n@@ -532,7 +534,7 @@ impl EmbargoVisitor<'tcx> {\n \n     fn update_macro_reachable_mod(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) {\n         let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n-        let module = self.tcx.hir().get_module(module_def_id.to_def_id()).0;\n+        let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n@@ -547,7 +549,10 @@ impl EmbargoVisitor<'tcx> {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n-                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                        if let Some(hir_id) = def_id\n+                            .as_local()\n+                            .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                        {\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -654,7 +659,9 @@ impl EmbargoVisitor<'tcx> {\n                 // If the module is `self`, i.e. the current crate,\n                 // there will be no corresponding item.\n                 .filter(|def_id| def_id.index != CRATE_DEF_INDEX || def_id.krate != LOCAL_CRATE)\n-                .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+                .and_then(|def_id| {\n+                    def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                })\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n             {\n                 if let hir::ItemKind::Mod(m) = &item.kind {\n@@ -908,7 +915,10 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.res.opt_def_id() {\n-                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            if let Some(hir_id) = def_id\n+                                .as_local()\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                            {\n                                 self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n                         }\n@@ -996,10 +1006,11 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         self.ev.tcx\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n-        if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.ev.tcx.hir().as_local_hir_id(def_id).unwrap();\n             if let ((ty::Visibility::Public, ..), _)\n             | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (def_id_visibility(self.tcx(), def_id), self.access_level)\n+                (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n             {\n                 self.ev.update(hir_id, self.access_level);\n             }\n@@ -1443,10 +1454,10 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n         // A path can only be private if:\n         // it's in this crate...\n-        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+        if let Some(did) = did.as_local() {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find(hir_id) {\n+            match self.tcx.hir().find(self.tcx.hir().as_local_hir_id(did).unwrap()) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1564,8 +1575,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     |tr| {\n                         let did = tr.path.res.def_id();\n \n-                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n-                            self.trait_is_public(hir_id)\n+                        if let Some(did) = did.as_local() {\n+                            self.trait_is_public(self.tcx.hir().as_local_hir_id(did).unwrap())\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1825,8 +1836,8 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n             );\n         }\n \n-        let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-            Some(hir_id) => hir_id,\n+        let hir_id = match def_id.as_local() {\n+            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id).unwrap(),\n             None => return false,\n         };\n \n@@ -2070,7 +2081,7 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n         current_item: None,\n         empty_tables: &empty_tables,\n     };\n-    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id.expect_local());\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n "}, {"sha": "225e6da5ced98cca2bf2b990616f671e511f5b8b", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -596,7 +596,10 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n-                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            if let Some(hir_id) = def_id\n+                                .as_local()\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                            {\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n@@ -1166,7 +1169,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n+                        let hir_id =\n+                            tcx.hir().as_local_hir_id(def.id().unwrap().expect_local()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n@@ -1537,7 +1541,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                     debug!(\"hir id first={:?}\", hir_id);\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n@@ -1556,8 +1560,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(parent_hir_id) =\n-                                self.tcx.hir().as_local_hir_id(parent_def_id)\n+                            if let Some(parent_hir_id) = parent_def_id\n+                                .as_local()\n+                                .map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n                             {\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self\n@@ -1600,7 +1605,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n@@ -1955,7 +1960,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.tcx.hir().as_local_hir_id(def_id) {\n+            let unsubst = if let Some(id) =\n+                def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2661,7 +2668,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n+                        let hir_id = self\n+                            .tcx\n+                            .hir()\n+                            .as_local_hir_id(def.id().unwrap().expect_local())\n+                            .unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,"}, {"sha": "c255b8304e5b71cdf6d46ba01e843d8c050258ff", "filename": "src/librustc_symbol_mangling/lib.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_symbol_mangling%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_symbol_mangling%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flib.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -165,22 +165,18 @@ fn compute_symbol_name(\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\", def_id, substs);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n-\n-    if def_id.is_local() {\n-        if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id) {\n+    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+    let is_foreign = if let Some(def_id) = def_id.as_local() {\n+        if tcx.plugin_registrar_fn(LOCAL_CRATE) == Some(def_id.to_def_id()) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_plugin_registrar_symbol(disambiguator);\n         }\n-        if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id) {\n+        if tcx.proc_macro_decls_static(LOCAL_CRATE) == Some(def_id.to_def_id()) {\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n-    }\n-\n-    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let is_foreign = if let Some(id) = hir_id {\n-        match tcx.hir().get(id) {\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        match tcx.hir().get(hir_id) {\n             Node::ForeignItem(_) => true,\n             _ => false,\n         }"}, {"sha": "16fef2f6e36059b51b3589cd2dd7e2ca68780c75", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -3,7 +3,7 @@ use crate::traits::{self, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1036,7 +1036,9 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     //     let x = || foo(); // returns the Opaque assoc with `foo`\n                     // }\n                     // ```\n-                    if let Some(opaque_hir_id) = tcx.hir().as_local_hir_id(def_id) {\n+                    if let Some(opaque_hir_id) =\n+                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    {\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n@@ -1057,14 +1059,22 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                                     origin,\n                                     ..\n                                 }) => (\n-                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n+                                    may_define_opaque_type(\n+                                        tcx,\n+                                        self.parent_def_id.expect_local(),\n+                                        opaque_hir_id,\n+                                    ),\n                                     origin,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n                             },\n                             Some(Node::ImplItem(item)) => match item.kind {\n                                 hir::ImplItemKind::OpaqueTy(_) => (\n-                                    may_define_opaque_type(tcx, self.parent_def_id, opaque_hir_id),\n+                                    may_define_opaque_type(\n+                                        tcx,\n+                                        self.parent_def_id.expect_local(),\n+                                        opaque_hir_id,\n+                                    ),\n                                     hir::OpaqueTyOrigin::TypeAlias,\n                                 ),\n                                 _ => (def_scope_default(), hir::OpaqueTyOrigin::TypeAlias),\n@@ -1201,10 +1211,14 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n /// }\n /// ```\n ///\n-/// Here, `def_id` is the `DefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n+/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n /// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-pub fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: DefId, opaque_hir_id: hir::HirId) -> bool {\n+pub fn may_define_opaque_type(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    opaque_hir_id: hir::HirId,\n+) -> bool {\n     let mut hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Named opaque types can be defined by any siblings or children of siblings."}, {"sha": "c6c9b068a5e7368ecc6092732b2154b58bfcdbec", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -507,7 +507,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let hir_id =\n+                            self.tcx.hir().as_local_hir_id(closure_def_id.expect_local()).unwrap();\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,"}, {"sha": "b6d592b3143ed90d4d2a64edec5771bb46430f07", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -430,7 +430,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n         let hir = self.tcx.hir();\n-        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let hir_id = hir.as_local_hir_id(def_id.as_local()?)?;\n         let parent_node = hir.get_parent_node(hir_id);\n         match hir.find(parent_node) {\n             Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let span = self.tcx.def_span(generator_did);\n \n         // Do not ICE on closure typeck (#66868).\n-        if hir.as_local_hir_id(generator_did).is_none() {\n+        if !generator_did.is_local() {\n             return false;\n         }\n \n@@ -1235,8 +1235,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let generator_body = hir\n-            .as_local_hir_id(generator_did)\n+        let generator_body = generator_did\n+            .as_local()\n+            .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n             .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n             .map(|body_id| hir.body(body_id));\n         let mut visitor = AwaitsVisitor::default();\n@@ -1386,6 +1387,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         GeneratorKind::Async(AsyncGeneratorKind::Fn) => self\n                             .tcx\n                             .parent(generator_did)\n+                            .and_then(|parent_did| parent_did.as_local())\n                             .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n                             .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n                             .map(|name| {"}, {"sha": "95bc64fdaff23fff90d25d859832e316ee5a8b47", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -17,7 +17,7 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -271,9 +271,9 @@ pub(super) fn specialization_graph_provider(\n         .sort_unstable_by_key(|def_id| (-(def_id.krate.as_u32() as i64), def_id.index.index()));\n \n     for impl_def_id in trait_impls {\n-        if impl_def_id.is_local() {\n+        if let Some(impl_def_id) = impl_def_id.as_local() {\n             // This is where impl overlap checking happens:\n-            let insert_result = sg.insert(tcx, impl_def_id);\n+            let insert_result = sg.insert(tcx, impl_def_id.to_def_id());\n             // Report error if there was one.\n             let (overlap, used_to_be_allowed) = match insert_result {\n                 Err(overlap) => (Some(overlap), None),\n@@ -296,19 +296,19 @@ pub(super) fn specialization_graph_provider(\n fn report_overlap_conflict(\n     tcx: TyCtxt<'_>,\n     overlap: OverlapError,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_polarity = tcx.impl_polarity(impl_def_id);\n+    let impl_polarity = tcx.impl_polarity(impl_def_id.to_def_id());\n     let other_polarity = tcx.impl_polarity(overlap.with_impl);\n     match (impl_polarity, other_polarity) {\n         (ty::ImplPolarity::Negative, ty::ImplPolarity::Positive) => {\n             report_negative_positive_conflict(\n                 tcx,\n                 &overlap,\n                 impl_def_id,\n-                impl_def_id,\n+                impl_def_id.to_def_id(),\n                 overlap.with_impl,\n                 sg,\n             );\n@@ -320,7 +320,7 @@ fn report_overlap_conflict(\n                 &overlap,\n                 impl_def_id,\n                 overlap.with_impl,\n-                impl_def_id,\n+                impl_def_id.to_def_id(),\n                 sg,\n             );\n         }\n@@ -334,13 +334,15 @@ fn report_overlap_conflict(\n fn report_negative_positive_conflict(\n     tcx: TyCtxt<'_>,\n     overlap: &OverlapError,\n-    local_impl_def_id: DefId,\n+    local_impl_def_id: LocalDefId,\n     negative_impl_def_id: DefId,\n     positive_impl_def_id: DefId,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span =\n-        tcx.sess.source_map().guess_head_span(tcx.span_of_impl(local_impl_def_id).unwrap());\n+    let impl_span = tcx\n+        .sess\n+        .source_map()\n+        .guess_head_span(tcx.span_of_impl(local_impl_def_id.to_def_id()).unwrap());\n \n     let mut err = struct_span_err!(\n         tcx.sess,\n@@ -382,11 +384,12 @@ fn report_negative_positive_conflict(\n fn report_conflicting_impls(\n     tcx: TyCtxt<'_>,\n     overlap: OverlapError,\n-    impl_def_id: DefId,\n+    impl_def_id: LocalDefId,\n     used_to_be_allowed: Option<FutureCompatOverlapErrorKind>,\n     sg: &mut specialization_graph::Graph,\n ) {\n-    let impl_span = tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id).unwrap());\n+    let impl_span =\n+        tcx.sess.source_map().guess_head_span(tcx.span_of_impl(impl_def_id.to_def_id()).unwrap());\n \n     // Work to be done after we've built the DiagnosticBuilder. We have to define it\n     // now because the struct_lint methods don't return back the DiagnosticBuilder"}, {"sha": "b598b6f4fb4e479507f08bf87365d7d17f9196a4", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -174,7 +174,7 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         // could bound lifetimes.\n         .map(Clause::ForAll);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let node = tcx.hir().get(hir_id);\n \n     enum NodeKind {"}, {"sha": "1e215ebc42f1eb64b4553ff0aaac13ed6c56fe6f", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -128,7 +128,7 @@ fn associated_item_from_impl_item_ref(\n }\n \n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n@@ -166,7 +166,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n     if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n         defaultness\n@@ -200,7 +200,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n }\n \n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let item = tcx.hir().expect_item(id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n@@ -265,9 +265,12 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     let unnormalized_env =\n         ty::ParamEnv::new(tcx.intern_predicates(&predicates), traits::Reveal::UserFacing, None);\n \n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::CRATE_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n-    });\n+    let body_id = def_id\n+        .as_local()\n+        .map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+        .map_or(hir::CRATE_HIR_ID, |id| {\n+            tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n+        });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n@@ -352,10 +355,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "1de01168c2f093e3231f9781d06cb6551acc6fbf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -15,7 +15,7 @@ use rustc_errors::ErrorReported;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::lang_items::SizedTraitLangItem;\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n@@ -153,7 +153,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n \n             Some(rl::Region::LateBound(debruijn, id, _)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrNamed(id, name)))\n             }\n \n@@ -162,12 +162,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n \n             Some(rl::Region::EarlyBound(index, id, _)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id: id, index, name }))\n             }\n \n             Some(rl::Region::Free(scope, id)) => {\n-                let name = lifetime_name(id);\n+                let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n                     bound_region: ty::BrNamed(id, name),\n@@ -1974,7 +1974,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // any ambiguity.\n     fn find_bound_for_assoc_item(\n         &self,\n-        ty_param_def_id: DefId,\n+        ty_param_def_id: LocalDefId,\n         assoc_name: ast::Ident,\n         span: Span,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported> {\n@@ -1985,7 +1985,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates = &self.get_type_parameter_bounds(span, ty_param_def_id).predicates;\n+        let predicates =\n+            &self.get_type_parameter_bounds(span, ty_param_def_id.to_def_id()).predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n@@ -2236,7 +2237,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             (\n                 &ty::Param(_),\n                 Res::SelfTy(Some(param_did), None) | Res::Def(DefKind::TyParam, param_did),\n-            ) => self.find_bound_for_assoc_item(param_did, assoc_ident, span)?,\n+            ) => self.find_bound_for_assoc_item(param_did.expect_local(), assoc_ident, span)?,\n             _ => {\n                 if variant_resolution.is_some() {\n                     // Variant in type position\n@@ -2372,7 +2373,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             debug!(\"qpath_to_ty: self.item_def_id()={:?}\", def_id);\n \n             let parent_def_id = def_id\n-                .and_then(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                .and_then(|def_id| {\n+                    def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+                })\n                 .map(|hir_id| tcx.hir().get_parent_did(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n@@ -2666,7 +2669,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);"}, {"sha": "9da3dd0408a0b95174208bc75456692903f7a21c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1393,7 +1393,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {\n-                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                     // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                     // get the `Trait`'s `DefId`.\n                     if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "dbdb26afaec2d85dff1b390948a15bcf20db8ac7", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -76,7 +76,7 @@ fn compare_predicate_entailment<'tcx>(\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n \n     let cause = ObligationCause {\n         span: impl_m_span,\n@@ -399,7 +399,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     trait_sig: ty::FnSig<'tcx>,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n     let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n         ImplItemKind::Fn(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n@@ -409,7 +409,9 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n \n     match *terr {\n         TypeError::Mutability => {\n-            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n+            if let Some(trait_m_hir_id) =\n+                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                     TraitItemKind::Fn(ref trait_m_sig, _) => trait_m_sig.decl.inputs.iter(),\n                     _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n@@ -436,7 +438,9 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n             }\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(trait_m_hir_id) = tcx.hir().as_local_hir_id(trait_m.def_id) {\n+            if let Some(trait_m_hir_id) =\n+                trait_m.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 let (trait_m_output, trait_m_iter) =\n                     match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                         TraitItemKind::Fn(ref trait_m_sig, _) => {\n@@ -587,33 +591,34 @@ fn compare_number_of_generics<'tcx>(\n         if impl_count != trait_count {\n             err_occurred = true;\n \n-            let (trait_spans, impl_trait_spans) =\n-                if let Some(trait_hir_id) = tcx.hir().as_local_hir_id(trait_.def_id) {\n-                    let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n-                    if trait_item.generics.params.is_empty() {\n-                        (Some(vec![trait_item.generics.span]), vec![])\n-                    } else {\n-                        let arg_spans: Vec<Span> =\n-                            trait_item.generics.params.iter().map(|p| p.span).collect();\n-                        let impl_trait_spans: Vec<Span> = trait_item\n-                            .generics\n-                            .params\n-                            .iter()\n-                            .filter_map(|p| match p.kind {\n-                                GenericParamKind::Type {\n-                                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                                    ..\n-                                } => Some(p.span),\n-                                _ => None,\n-                            })\n-                            .collect();\n-                        (Some(arg_spans), impl_trait_spans)\n-                    }\n+            let (trait_spans, impl_trait_spans) = if let Some(trait_hir_id) =\n+                trait_.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n+                let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n+                if trait_item.generics.params.is_empty() {\n+                    (Some(vec![trait_item.generics.span]), vec![])\n                 } else {\n-                    (trait_span.map(|s| vec![s]), vec![])\n-                };\n+                    let arg_spans: Vec<Span> =\n+                        trait_item.generics.params.iter().map(|p| p.span).collect();\n+                    let impl_trait_spans: Vec<Span> = trait_item\n+                        .generics\n+                        .params\n+                        .iter()\n+                        .filter_map(|p| match p.kind {\n+                            GenericParamKind::Type {\n+                                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                                ..\n+                            } => Some(p.span),\n+                            _ => None,\n+                        })\n+                        .collect();\n+                    (Some(arg_spans), impl_trait_spans)\n+                }\n+            } else {\n+                (trait_span.map(|s| vec![s]), vec![])\n+            };\n \n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id.expect_local()).unwrap();\n             let impl_item = tcx.hir().expect_impl_item(impl_hir_id);\n             let impl_item_impl_trait_spans: Vec<Span> = impl_item\n                 .generics\n@@ -704,8 +709,8 @@ fn compare_number_of_method_arguments<'tcx>(\n     let trait_number_args = trait_m_fty.inputs().skip_binder().len();\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n-        let trait_m_hir_id = tcx.hir().as_local_hir_id(trait_m.def_id);\n-        let trait_span = if let Some(trait_id) = trait_m_hir_id {\n+        let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n+            let trait_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n             match tcx.hir().expect_trait_item(trait_id).kind {\n                 TraitItemKind::Fn(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n@@ -728,7 +733,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             trait_item_span\n         };\n-        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n+        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local()).unwrap();\n         let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n             ImplItemKind::Fn(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n@@ -810,7 +815,7 @@ fn compare_synthetic_generics<'tcx>(\n         impl_m_type_params.zip(trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n+            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id.expect_local()).unwrap();\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -831,10 +836,10 @@ fn compare_synthetic_generics<'tcx>(\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n                         let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n-                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id)?;\n+                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id.as_local()?)?;\n                         let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n \n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n@@ -868,7 +873,7 @@ fn compare_synthetic_generics<'tcx>(\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n+                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n@@ -961,7 +966,7 @@ crate fn compare_const_impl<'tcx>(\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id).unwrap();\n+        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id.expect_local()).unwrap();\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -1005,7 +1010,8 @@ crate fn compare_const_impl<'tcx>(\n                 trait_c.ident\n             );\n \n-            let trait_c_hir_id = tcx.hir().as_local_hir_id(trait_c.def_id);\n+            let trait_c_hir_id =\n+                trait_c.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id).unwrap());\n             let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n                 match tcx.hir().expect_trait_item(trait_c_hir_id).kind {\n@@ -1093,7 +1099,7 @@ fn compare_type_predicate_entailment(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id).unwrap();\n+    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local()).unwrap();\n     let cause = ObligationCause {\n         span: impl_ty_span,\n         body_id: impl_ty_hir_id,"}, {"sha": "40efbd6f95c28dca5ad824aa94b1bd1f249b5e56", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1,6 +1,6 @@\n use crate::check::regionck::RegionCtxt;\n use crate::hir;\n-use crate::hir::def_id::DefId;\n+use crate::hir::def_id::{DefId, LocalDefId};\n use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n@@ -39,15 +39,15 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n-                drop_impl_did,\n+                drop_impl_did.expect_local(),\n                 dtor_self_type,\n                 adt_def.did,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n                 dtor_predicates,\n-                adt_def.did,\n+                adt_def.did.expect_local(),\n                 self_to_impl_substs,\n             )\n         }\n@@ -67,7 +67,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n \n fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    drop_impl_did: DefId,\n+    drop_impl_did: LocalDefId,\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n@@ -83,7 +83,8 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let named_type = tcx.type_of(self_type_did);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n-        let fresh_impl_substs = infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+        let fresh_impl_substs =\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did.to_def_id());\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n@@ -135,7 +136,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n \n         infcx.resolve_regions_and_report_errors(\n-            drop_impl_did,\n+            drop_impl_did.to_def_id(),\n             &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n@@ -149,7 +150,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: DefId,\n+    self_type_did: LocalDefId,\n     self_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorReported> {\n     let mut result = Ok(());\n@@ -243,8 +244,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n \n         if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n-            let self_descr =\n-                tcx.def_kind(self_type_did).map(|kind| kind.descr(self_type_did)).unwrap_or(\"type\");\n+            let self_descr = tcx\n+                .def_kind(self_type_did)\n+                .map(|kind| kind.descr(self_type_did.to_def_id()))\n+                .unwrap_or(\"type\");\n             struct_span_err!(\n                 tcx.sess,\n                 *predicate_sp,"}, {"sha": "353ab250cf08fce09fcabd950842717ae0e51367", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -1625,8 +1625,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n         let param_def_id = generic_param.def_id;\n-        let param_hir_id = match self.tcx.hir().as_local_hir_id(param_def_id) {\n-            Some(x) => x,\n+        let param_hir_id = match param_def_id.as_local() {\n+            Some(x) => self.tcx.hir().as_local_hir_id(x).unwrap(),\n             None => return,\n         };\n         let param_span = self.tcx.hir().span(param_hir_id);"}, {"sha": "37cf5180cf860ba584e05668adb995759c13ea4e", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 65, "deletions": 59, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -579,11 +579,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 (&self_ty.kind, parent_pred)\n                             {\n                                 if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n-                                    let node = self\n-                                        .tcx\n-                                        .hir()\n-                                        .as_local_hir_id(def.did)\n-                                        .map(|id| self.tcx.hir().get(id));\n+                                    let node = def.did.as_local().map(|def_id| {\n+                                        self.tcx\n+                                            .hir()\n+                                            .get(self.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                                    });\n                                     if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                         if let Some(g) = kind.generics() {\n                                             let key = match &g.where_clause.predicates[..] {\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidates: Vec<DefId>,\n     ) {\n         let module_did = self.tcx.parent_module(self.body_id);\n-        let module_id = self.tcx.hir().as_local_hir_id(module_did.to_def_id()).unwrap();\n+        let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n@@ -950,62 +950,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 !unsatisfied_predicates.iter().any(|(p, _)| match p {\n-                    // Hide traits if they are present in predicates as they can be fixed without\n-                    // having to implement them.\n-                    ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n-                    ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n-                    _ => true,\n-                }) && (type_is_local || info.def_id.is_local())\n-                    && self\n-                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n-                        .filter(|item| {\n-                            if let ty::AssocKind::Fn = item.kind {\n-                                let id = self.tcx.hir().as_local_hir_id(item.def_id);\n-                                if let Some(hir::Node::TraitItem(hir::TraitItem {\n-                                    kind: hir::TraitItemKind::Fn(fn_sig, method),\n-                                    ..\n-                                })) = id.map(|id| self.tcx.hir().get(id))\n-                                {\n-                                    let self_first_arg = match method {\n-                                        hir::TraitFn::Required([ident, ..]) => {\n-                                            ident.name == kw::SelfLower\n-                                        }\n-                                        hir::TraitFn::Provided(body_id) => {\n-                                            match &self.tcx.hir().body(*body_id).params[..] {\n-                                                [hir::Param {\n-                                                    pat:\n-                                                        hir::Pat {\n-                                                            kind:\n-                                                                hir::PatKind::Binding(\n-                                                                    _,\n-                                                                    _,\n-                                                                    ident,\n-                                                                    ..,\n-                                                                ),\n-                                                            ..\n-                                                        },\n-                                                    ..\n-                                                }, ..] => ident.name == kw::SelfLower,\n-                                                _ => false,\n-                                            }\n-                                        }\n-                                        _ => false,\n-                                    };\n-\n-                                    if !fn_sig.decl.implicit_self.has_implicit_self()\n-                                        && self_first_arg\n+                        // Hide traits if they are present in predicates as they can be fixed without\n+                        // having to implement them.\n+                        ty::Predicate::Trait(t, _) => t.def_id() != info.def_id,\n+                        ty::Predicate::Projection(p) => p.item_def_id() != info.def_id,\n+                        _ => true,\n+                    }) && (type_is_local || info.def_id.is_local())\n+                        && self\n+                            .associated_item(info.def_id, item_name, Namespace::ValueNS)\n+                            .filter(|item| {\n+                                if let ty::AssocKind::Fn = item.kind {\n+                                    let id = item.def_id.as_local().map(|def_id| {\n+                                        self.tcx.hir().as_local_hir_id(def_id).unwrap()\n+                                    });\n+                                    if let Some(hir::Node::TraitItem(hir::TraitItem {\n+                                        kind: hir::TraitItemKind::Fn(fn_sig, method),\n+                                        ..\n+                                    })) = id.map(|id| self.tcx.hir().get(id))\n                                     {\n-                                        if let Some(ty) = fn_sig.decl.inputs.get(0) {\n-                                            arbitrary_rcvr.push(ty.span);\n+                                        let self_first_arg = match method {\n+                                            hir::TraitFn::Required([ident, ..]) => {\n+                                                ident.name == kw::SelfLower\n+                                            }\n+                                            hir::TraitFn::Provided(body_id) => {\n+                                                match &self.tcx.hir().body(*body_id).params[..] {\n+                                                    [hir::Param {\n+                                                        pat:\n+                                                            hir::Pat {\n+                                                                kind:\n+                                                                    hir::PatKind::Binding(\n+                                                                        _,\n+                                                                        _,\n+                                                                        ident,\n+                                                                        ..,\n+                                                                    ),\n+                                                                ..\n+                                                            },\n+                                                        ..\n+                                                    }, ..] => ident.name == kw::SelfLower,\n+                                                    _ => false,\n+                                                }\n+                                            }\n+                                            _ => false,\n+                                        };\n+\n+                                        if !fn_sig.decl.implicit_self.has_implicit_self()\n+                                            && self_first_arg\n+                                        {\n+                                            if let Some(ty) = fn_sig.decl.inputs.get(0) {\n+                                                arbitrary_rcvr.push(ty.span);\n+                                            }\n+                                            return false;\n                                         }\n-                                        return false;\n                                     }\n                                 }\n-                            }\n-                            // We only want to suggest public or local traits (#45781).\n-                            item.vis == ty::Visibility::Public || info.def_id.is_local()\n-                        })\n-                        .is_some()\n+                                // We only want to suggest public or local traits (#45781).\n+                                item.vis == ty::Visibility::Public || info.def_id.is_local()\n+                            })\n+                            .is_some()\n             })\n             .collect::<Vec<_>>();\n         for span in &arbitrary_rcvr {\n@@ -1052,7 +1054,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let generics = self.tcx.generics_of(table_owner.to_def_id());\n                     let type_param = generics.type_param(param, self.tcx);\n                     let hir = &self.tcx.hir();\n-                    if let Some(id) = hir.as_local_hir_id(type_param.def_id) {\n+                    if let Some(id) = type_param\n+                        .def_id\n+                        .as_local()\n+                        .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                    {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                         // instead we suggest `T: Foo + Bar` in that case."}, {"sha": "e318eec3e1c79866040000fbd3dfedd5d13aaabf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -750,20 +750,20 @@ fn check_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     debug_assert!(crate_num == LOCAL_CRATE);\n     tcx.par_body_owners(|body_owner_def_id| {\n-        tcx.ensure().typeck_tables_of(body_owner_def_id.to_def_id());\n+        tcx.ensure().typeck_tables_of(body_owner_def_id);\n     });\n }\n \n fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_item_well_formed(tcx, def_id);\n+    wfcheck::check_item_well_formed(tcx, def_id.expect_local());\n }\n \n fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_trait_item(tcx, def_id);\n+    wfcheck::check_trait_item(tcx, def_id.expect_local());\n }\n \n fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_impl_item(tcx, def_id);\n+    wfcheck::check_impl_item(tcx, def_id.expect_local());\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -977,7 +977,7 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n ) -> &ty::TypeckTables<'tcx> {\n     assert!(def_id.is_local());\n     let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id).unwrap());\n+        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap());\n         tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n         tcx.types.err\n     };\n@@ -996,7 +996,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n@@ -1333,7 +1333,7 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id());\n-    let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id.expect_local()).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n@@ -1448,7 +1448,7 @@ fn check_fn<'a, 'tcx>(\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.as_local_hir_id(def_id).unwrap();\n+            let main_id = hir.as_local_hir_id(def_id.expect_local()).unwrap();\n             if main_id == fn_id {\n                 let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n@@ -1626,9 +1626,7 @@ fn check_opaque<'tcx>(\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n-    let item = tcx.hir().expect_item(\n-        tcx.hir().as_local_hir_id(def_id.to_def_id()).expect(\"opaque type is not local\"),\n-    );\n+    let item = tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id).unwrap());\n     debug!(\n         \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n         def_id, span, item\n@@ -2462,7 +2460,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n                 );\n \n                 let hir = tcx.hir();\n-                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0) {\n+                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0.expect_local()) {\n                     if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n                         err.span_note(\n                             tcx.def_span(def_spans[0].0),\n@@ -2474,7 +2472,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n                 if def_spans.len() > 2 {\n                     let mut first = true;\n                     for (adt_def, span) in def_spans.iter().skip(1).rev() {\n-                        if let Some(hir_id) = hir.as_local_hir_id(*adt_def) {\n+                        if let Some(hir_id) = hir.as_local_hir_id(adt_def.expect_local()) {\n                             if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n                                 err.span_note(\n                                     *span,\n@@ -2698,7 +2696,7 @@ pub fn check_enum<'tcx>(\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n-            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n+            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did.expect_local()).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n@@ -2759,7 +2757,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n-        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n         let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);\n@@ -4974,7 +4972,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 Some(Node::Ctor(hir::VariantData::Tuple(fields, _))) => {\n                     sugg_call = fields.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                    match hir.as_local_hir_id(def_id).and_then(|hir_id| hir.def_kind(hir_id)) {\n+                    match def_id\n+                        .as_local()\n+                        .map(|def_id| hir.as_local_hir_id(def_id).unwrap())\n+                        .and_then(|hir_id| hir.def_kind(hir_id))\n+                    {\n                         Some(hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, _)) => {\n                             msg = \"instantiate this tuple variant\";\n                         }"}, {"sha": "b3c1b5b23e6854abd511940a3a2aa409794394d0", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -70,14 +70,14 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n-pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n         \"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n         item.hir_id,\n-        tcx.def_path_str(def_id)\n+        tcx.def_path_str(def_id.to_def_id())\n     );\n \n     match item.kind {\n@@ -183,7 +183,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n     }\n }\n \n-pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n@@ -257,7 +257,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     }\n }\n \n-pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n@@ -789,7 +789,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     let mut predicates = predicates.instantiate_identity(fcx.tcx);\n \n     if let Some((return_ty, span)) = return_ty {\n-        let opaque_types = check_opaque_types(tcx, fcx, def_id, span, return_ty);\n+        let opaque_types = check_opaque_types(tcx, fcx, def_id.expect_local(), span, return_ty);\n         for _ in 0..opaque_types.len() {\n             predicates.spans.push(span);\n         }\n@@ -862,7 +862,7 @@ fn check_fn_or_method<'fcx, 'tcx>(\n fn check_opaque_types<'fcx, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fcx: &FnCtxt<'fcx, 'tcx>,\n-    fn_def_id: DefId,\n+    fn_def_id: LocalDefId,\n     span: Span,\n     ty: Ty<'tcx>,\n ) -> Vec<ty::Predicate<'tcx>> {\n@@ -878,7 +878,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 // FIXME(eddyb) is  `generics.parent.is_none()` correct? It seems\n                 // potentially risky wrt associated types in `impl`s.\n                 if generics.parent.is_none() && def_id.is_local() {\n-                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    let opaque_hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n                     if may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n                         trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n                         let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();"}, {"sha": "f03438af920163f04c959237adc9a761309d8a56", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -427,7 +427,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n+            let hir_id = self.tcx().hir().as_local_hir_id(def_id.expect_local()).unwrap();\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());"}, {"sha": "0c6fc8f32aaf8e7be825040645617dacf423ce10", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -89,7 +89,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if let Some(id) = tcx.hir().as_local_hir_id(def_id) {\n+            if let Some(id) = tcx.hir().as_local_hir_id(def_id.expect_local()) {\n                 if tcx.hir().find(id).is_none() {\n                     return false;\n                 }\n@@ -115,7 +115,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     });\n \n     for extern_crate in &crates_to_lint {\n-        let id = tcx.hir().as_local_hir_id(extern_crate.def_id).unwrap();\n+        let id = tcx.hir().as_local_hir_id(extern_crate.def_id.expect_local()).unwrap();\n         let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether."}, {"sha": "c0613ffdf2ea9f702c3db86255c7015763d43913", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -53,8 +53,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         return;\n     }\n \n-    let impl_hir_id =\n-        tcx.hir().as_local_hir_id(impl_did.to_def_id()).expect(\"foreign Drop impl on non-ADT\");\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n         ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n@@ -73,7 +72,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did.to_def_id()) {\n+    let impl_hir_id = if let Some(n) = tcx.hir().as_local_hir_id(impl_did) {\n         n\n     } else {\n         debug!(\"visit_implementation_of_copy(): impl not in this crate\");\n@@ -153,7 +152,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n \n     let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.to_def_id()).unwrap();\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n     let span = tcx.hir().span(impl_hir_id);\n \n     let source = tcx.type_of(impl_did);\n@@ -327,9 +326,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n     });\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap_or_else(|| {\n-        bug!(\"coerce_unsized_info: invoked for non-local def-id {:?}\", impl_did)\n-    });\n+    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local()).unwrap();\n \n     let source = tcx.type_of(impl_did);\n     let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();"}, {"sha": "d3bb43f5eac9d5cdc127f6d35f45510810d09b76", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -269,10 +269,7 @@ impl ItemCtxt<'tcx> {\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n-        self.tcx\n-            .hir()\n-            .as_local_hir_id(self.item_def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\")\n+        self.tcx.hir().as_local_hir_id(self.item_def_id.expect_local()).unwrap()\n     }\n \n     pub fn node(&self) -> hir::Node<'tcx> {\n@@ -489,7 +486,7 @@ fn type_param_predicates(\n     // written inline like `<T: Foo>` or in a where-clause like\n     // `where T: Foo`.\n \n-    let param_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let param_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n@@ -511,7 +508,7 @@ fn type_param_predicates(\n         .unwrap_or_default();\n     let mut extend = None;\n \n-    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id).unwrap();\n+    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n     let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n@@ -814,13 +811,10 @@ fn convert_variant(\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData<'_>,\n     adt_kind: ty::AdtKind,\n-    parent_did: DefId,\n+    parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = Default::default();\n-    let hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(variant_did.map(LocalDefId::to_def_id).unwrap_or(parent_did))\n-        .unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did)).unwrap();\n     let fields = def\n         .fields()\n         .iter()\n@@ -862,21 +856,22 @@ fn convert_variant(\n         fields,\n         CtorKind::from_hir(def),\n         adt_kind,\n-        parent_did,\n+        parent_did.to_def_id(),\n         recovered,\n     )\n }\n \n fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     use rustc_hir::*;\n \n+    let def_id = def_id.expect_local();\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let item = match tcx.hir().get(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n     };\n \n-    let repr = ReprOptions::new(tcx, def_id);\n+    let repr = ReprOptions::new(tcx, def_id.to_def_id());\n     let (kind, variants) = match item.kind {\n         ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n@@ -949,15 +944,15 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n         }\n         _ => bug!(),\n     };\n-    tcx.alloc_adt_def(def_id, kind, variants, repr)\n+    tcx.alloc_adt_def(def_id.to_def_id(), kind, variants, repr)\n }\n \n /// Ensures that the super-predicates of the trait with a `DefId`\n /// of `trait_def_id` are converted and stored. This also ensures that\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id).unwrap();\n+    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id.expect_local()).unwrap();\n \n     let item = match tcx.hir().get(trait_hir_id) {\n         Node::Item(item) => item,\n@@ -1008,7 +1003,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::TraitDef {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.kind {\n@@ -1166,7 +1161,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n@@ -1464,7 +1459,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -1562,7 +1557,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n@@ -1573,7 +1568,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n }\n \n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n@@ -1707,7 +1702,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n@@ -2562,7 +2557,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if codegen_fn_attrs.flags.intersects(CodegenFnAttrFlags::NO_SANITIZE_ANY) {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().as_local_hir_id(id).unwrap();\n+                let hir_id = tcx.hir().as_local_hir_id(id.expect_local()).unwrap();\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,"}, {"sha": "4ff836855dd8fdc5d8bbdcb8838e08c7960784ca", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -2,7 +2,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -21,7 +21,7 @@ use super::{bad_placeholder_type, is_suggestable_infer_ty};\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local()).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n@@ -63,7 +63,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n                 }\n \n-                find_opaque_ty_constraints(tcx, def_id)\n+                find_opaque_ty_constraints(tcx, def_id.expect_local())\n             }\n             ImplItemKind::TyAlias(ref ty) => {\n                 if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n@@ -96,7 +96,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.mk_adt(def, substs)\n                 }\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n-                    find_opaque_ty_constraints(tcx, def_id)\n+                    find_opaque_ty_constraints(tcx, def_id.expect_local())\n                 }\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n@@ -364,7 +364,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n-fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n \n     debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n@@ -516,7 +516,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n+    let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n     debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n "}, {"sha": "f419f052b811fe00a90d9d1d4e71d1366faa3884", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -69,7 +69,7 @@ use crate::constrained_generic_params as cgp;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n@@ -130,7 +130,14 @@ fn check_always_applicable(\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n \n-        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+        check_predicates(\n+            infcx,\n+            impl1_def_id.expect_local(),\n+            impl1_substs,\n+            impl2_node,\n+            impl2_substs,\n+            span,\n+        );\n     }\n }\n \n@@ -287,7 +294,7 @@ fn check_static_lifetimes<'tcx>(\n ///   including the `Self`-type.\n fn check_predicates<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    impl1_def_id: DefId,\n+    impl1_def_id: LocalDefId,\n     impl1_substs: SubstsRef<'tcx>,\n     impl2_node: Node,\n     impl2_substs: SubstsRef<'tcx>,"}, {"sha": "0c922ff17ac8cd0e426f800d22288c1ef9ea5cf0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -91,7 +91,7 @@ mod variance;\n \n use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n@@ -152,7 +152,7 @@ fn require_same_types<'tcx>(\n     })\n }\n \n-fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n+fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n     let main_id = tcx.hir().as_local_hir_id(main_def_id).unwrap();\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n@@ -231,7 +231,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     }\n }\n \n-fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n+fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n     let start_id = tcx.hir().as_local_hir_id(start_def_id).unwrap();\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n@@ -303,8 +303,8 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n \n fn check_for_entry_fn(tcx: TyCtxt<'_>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n-        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n-        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n+        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id.expect_local()),\n+        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id.expect_local()),\n         _ => {}\n     }\n }"}, {"sha": "3c579538e64bb4c0e6f96cfc0ffa442c19a61997", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -53,7 +53,7 @@ pub struct InferVisitor<'cx, 'tcx> {\n \n impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let item_did = self.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let item_did = self.tcx.hir().local_def_id(item.hir_id);\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n@@ -66,7 +66,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.kind {\n             hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n-                let adt_def = self.tcx.adt_def(item_did);\n+                let adt_def = self.tcx.adt_def(item_did.to_def_id());\n \n                 // Iterate over all fields in item_did\n                 for field_def in adt_def.all_fields() {\n@@ -99,10 +99,10 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n         // we walk the crates again and re-calculate predicates for all\n         // items.\n         let item_predicates_len: usize =\n-            self.global_inferred_outlives.get(&item_did).map(|p| p.len()).unwrap_or(0);\n+            self.global_inferred_outlives.get(&item_did.to_def_id()).map(|p| p.len()).unwrap_or(0);\n         if item_required_predicates.len() > item_predicates_len {\n             *self.predicates_added = true;\n-            self.global_inferred_outlives.insert(item_did, item_required_predicates);\n+            self.global_inferred_outlives.insert(item_did.to_def_id(), item_required_predicates);\n         }\n     }\n "}, {"sha": "71fcd9ddd6bc551af1717939d83c2a24b4cc92f4", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -18,7 +18,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n \n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {"}, {"sha": "5b0ccc5169ee09d1670d74754ff9554dcefad235", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -3,7 +3,7 @@\n //! The second pass over the AST determines the set of constraints.\n //! We walk the set of items and, for each member, generate new constraints.\n \n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, LocalDefId};\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n@@ -121,16 +121,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: hir::HirId) {\n         let tcx = self.terms_cx.tcx;\n         let def_id = tcx.hir().local_def_id(id);\n-        self.build_constraints_for_item(def_id.to_def_id());\n+        self.build_constraints_for_item(def_id);\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.terms_cx.tcx\n     }\n \n-    fn build_constraints_for_item(&mut self, def_id: DefId) {\n+    fn build_constraints_for_item(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx();\n-        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id));\n+        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id.to_def_id()));\n \n         // Skip items with no generics - there's nothing to infer in them.\n         if tcx.generics_of(def_id).count() == 0 {\n@@ -377,7 +377,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let (local, remote) = if let Some(id) = self.tcx().hir().as_local_hir_id(def_id) {\n+        let (local, remote) = if let Some(id) =\n+            def_id.as_local().map(|def_id| self.tcx().hir().as_local_hir_id(def_id).unwrap())\n+        {\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "f9e32c2a6b0cda553fb3b96a0b9e10fc1a6004be", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -38,7 +38,7 @@ fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> &CrateVariancesMap<'\n }\n \n fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n+    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local()).unwrap();\n     let unsupported = || {\n         // Variance not relevant.\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")"}, {"sha": "c6cdac5d0ccf6770eb866a5e91eaf7b7bc9a2a28", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -94,7 +94,9 @@ fn lang_items(tcx: TyCtxt<'_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n         .filter(|&(ref d, _)| d.is_some())\n         .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-        .filter_map(|(d, v)| tcx.hir().as_local_hir_id(d).map(|n| (n, v))) // (HirId, Variance)\n+        .filter_map(|(d, v)| {\n+            d.as_local().map(|d| tcx.hir().as_local_hir_id(d).unwrap()).map(|n| (n, v))\n+        }) // (HirId, Variance)\n         .collect()\n }\n "}, {"sha": "fc50a0ac2253819aa6153a73e9b3e5603a0faa18", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -340,14 +340,15 @@ pub fn build_impl(\n         }\n     }\n \n-    let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n-            _ => panic!(\"did given to build_impl was not an impl\"),\n-        }\n-    } else {\n-        tcx.type_of(did).clean(cx)\n-    };\n+    let for_ =\n+        if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap()) {\n+            match tcx.hir().expect_item(hir_id).kind {\n+                hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n+                _ => panic!(\"did given to build_impl was not an impl\"),\n+            }\n+        } else {\n+            tcx.type_of(did).clean(cx)\n+        };\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n@@ -360,7 +361,9 @@ pub fn build_impl(\n     }\n \n     let predicates = tcx.explicit_predicates_of(did);\n-    let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+    let (trait_items, generics) = if let Some(hir_id) =\n+        did.as_local().map(|did| tcx.hir().as_local_hir_id(did).unwrap())\n+    {\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { ref generics, ref items, .. } => (\n                 items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n@@ -486,7 +489,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n-    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+    if let Some(hir_id) = did.as_local().map(|did| cx.tcx.hir().as_local_hir_id(did).unwrap()) {\n         rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n@@ -498,11 +501,9 @@ fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did),\n         value: clean::utils::print_evaluated_const(cx, did),\n-        is_literal: cx\n-            .tcx\n-            .hir()\n-            .as_local_hir_id(did)\n-            .map_or(false, |hir_id| clean::utils::is_literal_expr(cx, hir_id)),\n+        is_literal: did.as_local().map_or(false, |did| {\n+            clean::utils::is_literal_expr(cx, cx.tcx.hir().as_local_hir_id(did).unwrap())\n+        }),\n     }\n }\n "}, {"sha": "751f3b868fd06506d868de2ecf7c32de87599a4a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -976,12 +976,7 @@ where\n impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if cx.tcx.hir().as_local_hir_id(did).is_some() {\n-            &[]\n-        } else {\n-            cx.tcx.fn_arg_names(did)\n-        }\n-        .iter();\n+        let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n \n         FnDecl {\n             output: Return(sig.skip_binder().output().clean(cx)),\n@@ -1384,7 +1379,10 @@ impl Clean<Type> for hir::Ty<'_> {\n                 let mut alias = None;\n                 if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n                     // Substitute private type aliases\n-                    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+                    if let Some(hir_id) = def_id\n+                        .as_local()\n+                        .map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+                    {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n                             alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                         }"}, {"sha": "ebb1838a83b12b3e1ad3ad6b4defca7319efb9e3", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -473,7 +473,9 @@ pub fn name_from_pat(p: &hir::Pat) -> String {\n pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def_id, _, promoted) => {\n-            let mut s = if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n+            let mut s = if let Some(hir_id) =\n+                def_id.as_local().map(|def_id| cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)"}, {"sha": "cc5bb335baee6ada800e0e8449fd4c06334f3397", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -144,7 +144,7 @@ impl<'tcx> DocContext<'tcx> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n-            self.tcx.hir().as_local_hir_id(def_id)\n+            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id).unwrap())\n         }\n     }\n "}, {"sha": "675cc918490e1df42f56204eacc9726797b31c7a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -335,7 +335,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n-            if let Some(id) = self.cx.tcx.hir().as_local_hir_id(item.def_id) {\n+            if let Some(id) = item\n+                .def_id\n+                .as_local()\n+                .map(|def_id| self.cx.tcx.hir().as_local_hir_id(def_id).unwrap())\n+            {\n                 Some(id)\n             } else {\n                 debug!(\"attempting to fold on a non-local item: {:?}\", item);"}, {"sha": "6b9f3acf9e8920e35aeabf1aca1ee9cb60d6ccc1", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6148db719f34a35099eff46097b5d2d9770892e9/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6148db719f34a35099eff46097b5d2d9770892e9", "patch": "@@ -331,8 +331,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        let res_hir_id = match tcx.hir().as_local_hir_id(res_did) {\n-            Some(n) => n,\n+        let res_hir_id = match res_did.as_local() {\n+            Some(n) => tcx.hir().as_local_hir_id(n).unwrap(),\n             None => return false,\n         };\n "}]}