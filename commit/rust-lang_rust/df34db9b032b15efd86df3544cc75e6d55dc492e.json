{"sha": "df34db9b032b15efd86df3544cc75e6d55dc492e", "node_id": "C_kwDOAAsO6NoAKGRmMzRkYjliMDMyYjE1ZWZkODZkZjM1NDRjYzc1ZTZkNTVkYzQ5MmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-15T18:14:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-15T18:14:29Z"}, "message": "Auto merge of #101858 - oli-obk:lift_derive, r=lcnr\n\nderive various impls instead of hand-rolling them\n\nr? `@lcnr`\n\nThis may not have been what you asked for in https://github.com/rust-lang/rust/commit/964b97e845d5dd18e09d5e045f5b376086714836#r84051418 but I got carried away while following the compiler team meeting today.", "tree": {"sha": "14657ed79c4895970c086d704fcb0674a8f7a904", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14657ed79c4895970c086d704fcb0674a8f7a904"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df34db9b032b15efd86df3544cc75e6d55dc492e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df34db9b032b15efd86df3544cc75e6d55dc492e", "html_url": "https://github.com/rust-lang/rust/commit/df34db9b032b15efd86df3544cc75e6d55dc492e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df34db9b032b15efd86df3544cc75e6d55dc492e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a0407814a6b5a04f0929105631e9c69e293e9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a0407814a6b5a04f0929105631e9c69e293e9d", "html_url": "https://github.com/rust-lang/rust/commit/35a0407814a6b5a04f0929105631e9c69e293e9d"}, {"sha": "c6fcb1c6a33d45d34ffed681e73f6e8a5fd35e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fcb1c6a33d45d34ffed681e73f6e8a5fd35e9b", "html_url": "https://github.com/rust-lang/rust/commit/c6fcb1c6a33d45d34ffed681e73f6e8a5fd35e9b"}], "stats": {"total": 977, "additions": 90, "deletions": 887}, "files": [{"sha": "d3cf519b633c71db5860a291a17347e06ac07104", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -44,6 +44,15 @@ pub struct Canonical<'tcx, V> {\n \n pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo<'tcx>>;\n \n+impl<'tcx> ty::TypeFoldable<'tcx> for CanonicalVarInfos<'tcx> {\n+    fn try_fold_with<F: ty::FallibleTypeFolder<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_canonical_var_infos(v))\n+    }\n+}\n+\n /// A set of values corresponding to the canonical variables from some\n /// `Canonical`. You can give these values to\n /// `canonical_value.substitute` to substitute them into the canonical\n@@ -90,6 +99,7 @@ impl<'tcx> Default for OriginalQueryValues<'tcx> {\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub struct CanonicalVarInfo<'tcx> {\n     pub kind: CanonicalVarKind<'tcx>,\n }\n@@ -115,6 +125,7 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub enum CanonicalVarKind<'tcx> {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -299,14 +310,7 @@ pub type QueryOutlivesConstraint<'tcx> = (\n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {\n         crate::infer::canonical::Certainty,\n-        crate::infer::canonical::CanonicalVarInfo<'tcx>,\n-        crate::infer::canonical::CanonicalVarKind<'tcx>,\n-    }\n-}\n-\n-TrivialTypeTraversalImpls! {\n-    for <'tcx> {\n-        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n+        crate::infer::canonical::CanonicalTyVarKind,\n     }\n }\n "}, {"sha": "5e3dfcbcc496221c9bd1c09abb3a7f9eda8beac4", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -137,7 +137,7 @@ pub use self::pointer::{Pointer, PointerArithmetic, Provenance};\n /// - A constant\n /// - A static\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, Lift)]\n+#[derive(HashStable, Lift, TypeFoldable, TypeVisitable)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n     /// For a promoted global, the `Instance` of the function they belong to."}, {"sha": "ac5fddb7ad1eb9f2ffe29c4d7c869e8e3e8418e8", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -8,7 +8,7 @@ use rustc_apfloat::{\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n \n-use crate::ty::{Lift, ParamEnv, ScalarInt, Ty, TyCtxt};\n+use crate::ty::{ParamEnv, ScalarInt, Ty, TyCtxt};\n \n use super::{\n     AllocId, AllocRange, ConstAllocation, InterpResult, Pointer, PointerArithmetic, Provenance,\n@@ -27,7 +27,7 @@ pub struct ConstAlloc<'tcx> {\n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI.\n     ///\n@@ -53,22 +53,6 @@ pub enum ConstValue<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstValue<'_>, 32);\n \n-impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n-    type Lifted = ConstValue<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ConstValue<'tcx>> {\n-        Some(match self {\n-            ConstValue::Scalar(s) => ConstValue::Scalar(s),\n-            ConstValue::ZeroSized => ConstValue::ZeroSized,\n-            ConstValue::Slice { data, start, end } => {\n-                ConstValue::Slice { data: tcx.lift(data)?, start, end }\n-            }\n-            ConstValue::ByRef { alloc, offset } => {\n-                ConstValue::ByRef { alloc: tcx.lift(alloc)?, offset }\n-            }\n-        })\n-    }\n-}\n-\n impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar<AllocId>> {"}, {"sha": "af00118fcbebacab546f2a42a379975f8896e83f", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -2028,6 +2028,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// particular, one must be wary of `NaN`!\n \n #[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2551,8 +2552,6 @@ impl UserTypeProjection {\n     }\n }\n \n-TrivialTypeTraversalAndLiftImpls! { ProjectionKind, }\n-\n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         Ok(UserTypeProjection {"}, {"sha": "c7d0283aac9bab59ad008ddf303fc9c1724cef56", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -488,7 +488,7 @@ pub struct CopyNonOverlapping<'tcx> {\n ///     must also be `cleanup`. This is a part of the type system and checked statically, so it is\n ///     still an error to have such an edge in the CFG even if it's known that it won't be taken at\n ///     runtime.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum TerminatorKind<'tcx> {\n     /// Block has one successor; we continue execution there.\n     Goto { target: BasicBlock },\n@@ -741,7 +741,7 @@ pub enum TerminatorKind<'tcx> {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),\n@@ -863,7 +863,7 @@ pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n ///\n /// Rust currently requires that every place obey those two rules. This is checked by MIRI and taken\n /// advantage of by codegen (via `gep inbounds`). That is possibly subject to change.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n \n@@ -872,7 +872,7 @@ pub struct Place<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[derive(TyEncodable, TyDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -955,7 +955,7 @@ pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n /// **Needs clarifiation:** Is loading a place that has its variant index set well-formed? Miri\n /// currently implements it, but it seems like this may be something to check against in the\n /// validator.\n-#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub enum Operand<'tcx> {\n     /// Creates a value by loading the given place.\n     ///\n@@ -986,7 +986,7 @@ pub enum Operand<'tcx> {\n /// Computing any rvalue begins by evaluating the places and operands in some order (**Needs\n /// clarification**: Which order?). These are then used to produce a \"value\" - the same kind of\n /// value that an [`Operand`] produces.\n-#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, Hash, HashStable, PartialEq, TypeFoldable, TypeVisitable)]\n pub enum Rvalue<'tcx> {\n     /// Yields the operand unchanged\n     Use(Operand<'tcx>),\n@@ -1146,6 +1146,7 @@ pub enum CastKind {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(TypeFoldable, TypeVisitable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),"}, {"sha": "4ea333cff7d9db9841502b4a18362a36148dc3b0", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -102,7 +102,7 @@ impl<'a> Iterator for SwitchTargetsIter<'a> {\n \n impl<'a> ExactSizeIterator for SwitchTargetsIter<'a> {}\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,"}, {"sha": "b8f8f697a9c05b77d62d2bc68c3c985ae6f69fef", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 17, "deletions": 187, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -1,8 +1,9 @@\n //! `TypeFoldable` implementations for MIR types\n \n+use rustc_ast::InlineAsmTemplatePiece;\n+\n use super::*;\n use crate::ty;\n-use rustc_data_structures::functor::IdFunctor;\n \n TrivialTypeTraversalAndLiftImpls! {\n     BlockTailInfo,\n@@ -13,96 +14,27 @@ TrivialTypeTraversalAndLiftImpls! {\n     SourceScope,\n     SourceScopeLocalData,\n     UserTypeAnnotationIndex,\n+    BorrowKind,\n+    CastKind,\n+    BinOp,\n+    NullOp,\n+    UnOp,\n+    hir::Movability,\n+    BasicBlock,\n+    SwitchTargets,\n+    GeneratorKind,\n+    GeneratorSavedLocal,\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::mir::TerminatorKind::*;\n-\n-        let kind = match self.kind {\n-            Goto { target } => Goto { target },\n-            SwitchInt { discr, switch_ty, targets } => SwitchInt {\n-                discr: discr.try_fold_with(folder)?,\n-                switch_ty: switch_ty.try_fold_with(folder)?,\n-                targets,\n-            },\n-            Drop { place, target, unwind } => {\n-                Drop { place: place.try_fold_with(folder)?, target, unwind }\n-            }\n-            DropAndReplace { place, value, target, unwind } => DropAndReplace {\n-                place: place.try_fold_with(folder)?,\n-                value: value.try_fold_with(folder)?,\n-                target,\n-                unwind,\n-            },\n-            Yield { value, resume, resume_arg, drop } => Yield {\n-                value: value.try_fold_with(folder)?,\n-                resume,\n-                resume_arg: resume_arg.try_fold_with(folder)?,\n-                drop,\n-            },\n-            Call { func, args, destination, target, cleanup, from_hir_call, fn_span } => Call {\n-                func: func.try_fold_with(folder)?,\n-                args: args.try_fold_with(folder)?,\n-                destination: destination.try_fold_with(folder)?,\n-                target,\n-                cleanup,\n-                from_hir_call,\n-                fn_span,\n-            },\n-            Assert { cond, expected, msg, target, cleanup } => {\n-                use AssertKind::*;\n-                let msg = match msg {\n-                    BoundsCheck { len, index } => BoundsCheck {\n-                        len: len.try_fold_with(folder)?,\n-                        index: index.try_fold_with(folder)?,\n-                    },\n-                    Overflow(op, l, r) => {\n-                        Overflow(op, l.try_fold_with(folder)?, r.try_fold_with(folder)?)\n-                    }\n-                    OverflowNeg(op) => OverflowNeg(op.try_fold_with(folder)?),\n-                    DivisionByZero(op) => DivisionByZero(op.try_fold_with(folder)?),\n-                    RemainderByZero(op) => RemainderByZero(op.try_fold_with(folder)?),\n-                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => msg,\n-                };\n-                Assert { cond: cond.try_fold_with(folder)?, expected, msg, target, cleanup }\n-            }\n-            GeneratorDrop => GeneratorDrop,\n-            Resume => Resume,\n-            Abort => Abort,\n-            Return => Return,\n-            Unreachable => Unreachable,\n-            FalseEdge { real_target, imaginary_target } => {\n-                FalseEdge { real_target, imaginary_target }\n-            }\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-            InlineAsm { template, operands, options, line_spans, destination, cleanup } => {\n-                InlineAsm {\n-                    template,\n-                    operands: operands.try_fold_with(folder)?,\n-                    options,\n-                    line_spans,\n-                    destination,\n-                    cleanup,\n-                }\n-            }\n-        };\n-        Ok(Terminator { source_info: self.source_info, kind })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [InlineAsmTemplatePiece] {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Place {\n-            local: self.local.try_fold_with(folder)?,\n-            projection: self.projection.try_fold_with(folder)?,\n-        })\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [Span] {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n+        Ok(self)\n     }\n }\n \n@@ -112,114 +44,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::mir::Rvalue::*;\n-        Ok(match self {\n-            Use(op) => Use(op.try_fold_with(folder)?),\n-            Repeat(op, len) => Repeat(op.try_fold_with(folder)?, len.try_fold_with(folder)?),\n-            ThreadLocalRef(did) => ThreadLocalRef(did.try_fold_with(folder)?),\n-            Ref(region, bk, place) => {\n-                Ref(region.try_fold_with(folder)?, bk, place.try_fold_with(folder)?)\n-            }\n-            CopyForDeref(place) => CopyForDeref(place.try_fold_with(folder)?),\n-            AddressOf(mutability, place) => AddressOf(mutability, place.try_fold_with(folder)?),\n-            Len(place) => Len(place.try_fold_with(folder)?),\n-            Cast(kind, op, ty) => Cast(kind, op.try_fold_with(folder)?, ty.try_fold_with(folder)?),\n-            BinaryOp(op, box (rhs, lhs)) => {\n-                BinaryOp(op, Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)))\n-            }\n-            CheckedBinaryOp(op, box (rhs, lhs)) => CheckedBinaryOp(\n-                op,\n-                Box::new((rhs.try_fold_with(folder)?, lhs.try_fold_with(folder)?)),\n-            ),\n-            UnaryOp(op, val) => UnaryOp(op, val.try_fold_with(folder)?),\n-            Discriminant(place) => Discriminant(place.try_fold_with(folder)?),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.try_fold_with(folder)?),\n-            Aggregate(kind, fields) => {\n-                let kind = kind.try_map_id(|kind| {\n-                    Ok(match kind {\n-                        AggregateKind::Array(ty) => AggregateKind::Array(ty.try_fold_with(folder)?),\n-                        AggregateKind::Tuple => AggregateKind::Tuple,\n-                        AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                            def,\n-                            v,\n-                            substs.try_fold_with(folder)?,\n-                            user_ty.try_fold_with(folder)?,\n-                            n,\n-                        ),\n-                        AggregateKind::Closure(id, substs) => {\n-                            AggregateKind::Closure(id, substs.try_fold_with(folder)?)\n-                        }\n-                        AggregateKind::Generator(id, substs, movablity) => {\n-                            AggregateKind::Generator(id, substs.try_fold_with(folder)?, movablity)\n-                        }\n-                    })\n-                })?;\n-                Aggregate(kind, fields.try_fold_with(folder)?)\n-            }\n-            ShallowInitBox(op, ty) => {\n-                ShallowInitBox(op.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n-            }\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(match self {\n-            Operand::Copy(place) => Operand::Copy(place.try_fold_with(folder)?),\n-            Operand::Move(place) => Operand::Move(place.try_fold_with(folder)?),\n-            Operand::Constant(c) => Operand::Constant(c.try_fold_with(folder)?),\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::mir::ProjectionElem::*;\n-\n-        Ok(match self {\n-            Deref => Deref,\n-            Field(f, ty) => Field(f, ty.try_fold_with(folder)?),\n-            Index(v) => Index(v.try_fold_with(folder)?),\n-            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n-            ConstantIndex { offset, min_length, from_end } => {\n-                ConstantIndex { offset, min_length, from_end }\n-            }\n-            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Constant {\n-            span: self.span,\n-            user_ty: self.user_ty.try_fold_with(folder)?,\n-            literal: self.literal.try_fold_with(folder)?,\n-        })\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ConstantKind<'tcx> {\n     #[inline(always)]\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {"}, {"sha": "27a251f2f56f8271dd6f9d7c0b63ed32ca3e3b44", "filename": "compiler/rustc_middle/src/mir/type_visitable.rs", "status": "modified", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_visitable.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -1,179 +1,13 @@\n //! `TypeVisitable` implementations for MIR types\n \n use super::*;\n-use crate::ty;\n-\n-impl<'tcx> TypeVisitable<'tcx> for Terminator<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        use crate::mir::TerminatorKind::*;\n-\n-        match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor)?;\n-                switch_ty.visit_with(visitor)\n-            }\n-            Drop { ref place, .. } => place.visit_with(visitor),\n-            DropAndReplace { ref place, ref value, .. } => {\n-                place.visit_with(visitor)?;\n-                value.visit_with(visitor)\n-            }\n-            Yield { ref value, .. } => value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n-                destination.visit_with(visitor)?;\n-                func.visit_with(visitor)?;\n-                args.visit_with(visitor)\n-            }\n-            Assert { ref cond, ref msg, .. } => {\n-                cond.visit_with(visitor)?;\n-                use AssertKind::*;\n-                match msg {\n-                    BoundsCheck { ref len, ref index } => {\n-                        len.visit_with(visitor)?;\n-                        index.visit_with(visitor)\n-                    }\n-                    Overflow(_, l, r) => {\n-                        l.visit_with(visitor)?;\n-                        r.visit_with(visitor)\n-                    }\n-                    OverflowNeg(op) | DivisionByZero(op) | RemainderByZero(op) => {\n-                        op.visit_with(visitor)\n-                    }\n-                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => ControlFlow::CONTINUE,\n-                }\n-            }\n-            InlineAsm { ref operands, .. } => operands.visit_with(visitor),\n-            Goto { .. }\n-            | Resume\n-            | Abort\n-            | Return\n-            | GeneratorDrop\n-            | Unreachable\n-            | FalseEdge { .. }\n-            | FalseUnwind { .. } => ControlFlow::CONTINUE,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for GeneratorKind {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Place<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.local.visit_with(visitor)?;\n-        self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Rvalue<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => op.visit_with(visitor),\n-            CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n-                op.visit_with(visitor)\n-            }\n-            Repeat(ref op, _) => op.visit_with(visitor),\n-            ThreadLocalRef(did) => did.visit_with(visitor),\n-            Ref(region, _, ref place) => {\n-                region.visit_with(visitor)?;\n-                place.visit_with(visitor)\n-            }\n-            AddressOf(_, ref place) => place.visit_with(visitor),\n-            Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => {\n-                op.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-            BinaryOp(_, box (ref rhs, ref lhs)) | CheckedBinaryOp(_, box (ref rhs, ref lhs)) => {\n-                rhs.visit_with(visitor)?;\n-                lhs.visit_with(visitor)\n-            }\n-            UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref place) => place.visit_with(visitor),\n-            NullaryOp(_, ty) => ty.visit_with(visitor),\n-            Aggregate(ref kind, ref fields) => {\n-                match **kind {\n-                    AggregateKind::Array(ty) => {\n-                        ty.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Tuple => {}\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor)?;\n-                        user_ty.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Closure(_, substs) => {\n-                        substs.visit_with(visitor)?;\n-                    }\n-                    AggregateKind::Generator(_, substs, _) => {\n-                        substs.visit_with(visitor)?;\n-                    }\n-                }\n-                fields.visit_with(visitor)\n-            }\n-            ShallowInitBox(ref op, ty) => {\n-                op.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Operand<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        match *self {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for PlaceElem<'tcx> {\n-    fn visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> ControlFlow<Vs::BreakTy> {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match self {\n-            Field(_, ty) => ty.visit_with(visitor),\n-            Index(v) => v.visit_with(visitor),\n-            _ => ControlFlow::CONTINUE,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for Field {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for GeneratorSavedLocal {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}\n \n impl<'tcx, R: Idx, C: Idx> TypeVisitable<'tcx> for BitMatrix<R, C> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n         ControlFlow::CONTINUE\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for Constant<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.literal.visit_with(visitor)?;\n-        self.user_ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeVisitable<'tcx> for ConstantKind<'tcx> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         visitor.visit_mir_const(*self)"}, {"sha": "b809f176760d6d720384db62881b6de6cdb87724", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -77,7 +77,7 @@ pub enum PointerCast {\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., `Box<[i32; 4]>` ->\n ///    `Box<[i32]>` is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n@@ -89,7 +89,7 @@ impl<'tcx> Adjustment<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -108,7 +108,7 @@ pub enum Adjust<'tcx> {\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n #[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n+#[derive(TypeFoldable, TypeVisitable, Lift)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -167,7 +167,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n }\n \n #[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n-#[derive(TypeFoldable, TypeVisitable)]\n+#[derive(TypeFoldable, TypeVisitable, Lift)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),"}, {"sha": "2f7352e0aff247ffcc7f0bd8aa1d5ba921359942", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -50,7 +50,7 @@ impl<'tcx, P: Default> Unevaluated<'tcx, P> {\n \n /// Represents a constant in Rust.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n-#[derive(Hash, HashStable)]\n+#[derive(Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub enum ConstKind<'tcx> {\n     /// A const generic parameter.\n     Param(ty::ParamConst),"}, {"sha": "4a9fbc5511c1ddff0e13f350f6ea017bfe6a59ed", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -1820,7 +1820,9 @@ nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariable\n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n-CloneLiftImpls! { for<'tcx> { Constness, traits::WellFormedLoc, } }\n+CloneLiftImpls! { for<'tcx> {\n+    Constness, traits::WellFormedLoc, ImplPolarity, crate::mir::ReturnConstraint,\n+} }\n \n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};"}, {"sha": "01e1e97b21a0b43ab11d507cf4f587da6351e365", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi;\n use std::borrow::Cow;\n use std::fmt;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n     pub found: T,\n@@ -31,7 +31,7 @@ impl<T> ExpectedFound<T> {\n }\n \n // Data structures used in type unification\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n #[rustc_pass_by_value]\n pub enum TypeError<'tcx> {\n     Mismatch,"}, {"sha": "9afd662075620fcc89a4ae00265cb6ce866144d6", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -20,14 +20,14 @@ use std::fmt;\n /// simply couples a potentially generic `InstanceDef` with some substs, and codegen and const eval\n /// will do all required substitution as they run.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, Lift)]\n+#[derive(HashStable, Lift, TypeFoldable, TypeVisitable)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///"}, {"sha": "e8fe37e7dab730f9f5a080e6971a626ed46ed61c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -636,7 +636,7 @@ impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum PredicateKind<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -808,7 +808,7 @@ impl<'tcx> Predicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n \n@@ -888,7 +888,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n@@ -899,7 +899,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicat\n /// whether the `a` type is the type that we should label as \"expected\" when\n /// presenting user diagnostics.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n     pub a: Ty<'tcx>,\n@@ -909,7 +909,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<'tcx, SubtypePredicate<'tcx>>;\n \n /// Encodes that we have to coerce *from* the `a` type to the `b` type.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct CoercePredicate<'tcx> {\n     pub a: Ty<'tcx>,\n     pub b: Ty<'tcx>,\n@@ -1058,7 +1058,7 @@ impl<'tcx> TermKind<'tcx> {\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub term: Term<'tcx>,\n@@ -1526,16 +1526,15 @@ impl<'tcx> TypeFoldable<'tcx> for ParamEnv<'tcx> {\n         Ok(ParamEnv::new(\n             self.caller_bounds().try_fold_with(folder)?,\n             self.reveal().try_fold_with(folder)?,\n-            self.constness().try_fold_with(folder)?,\n+            self.constness(),\n         ))\n     }\n }\n \n impl<'tcx> TypeVisitable<'tcx> for ParamEnv<'tcx> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.caller_bounds().visit_with(visitor)?;\n-        self.reveal().visit_with(visitor)?;\n-        self.constness().visit_with(visitor)\n+        self.reveal().visit_with(visitor)\n     }\n }\n \n@@ -1692,7 +1691,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TypeFoldable, TypeVisitable)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub struct ParamEnvAnd<'tcx, T> {\n     pub param_env: ParamEnv<'tcx>,\n     pub value: T,"}, {"sha": "f5fd1f6ffafce2ce0c16bb59ffa6d0c44c22fc9a", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 17, "deletions": 461, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -9,7 +9,6 @@ use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use crate::ty::{self, InferConst, Lift, Term, TermKind, Ty, TyCtxt};\n use rustc_data_structures::functor::IdFunctor;\n-use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -238,12 +237,24 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::Variance,\n     ::rustc_span::Span,\n     ::rustc_errors::ErrorGuaranteed,\n+    Field,\n+    interpret::Scalar,\n+    rustc_target::abi::Size,\n+    ty::DelaySpanBugEmitted,\n+    rustc_type_ir::DebruijnIndex,\n+    ty::BoundVar,\n+    ty::Placeholder<ty::BoundVar>,\n+}\n+\n+TrivialTypeTraversalAndLiftImpls! {\n+    for<'tcx> {\n+        ty::ValTree<'tcx>,\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n-// FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -261,10 +272,7 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            Some(x) => tcx.lift(x).map(Some),\n-            None => Some(None),\n-        }\n+        tcx.lift(self?).map(Some)\n     }\n }\n \n@@ -281,21 +289,21 @@ impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(*self).map(Box::new)\n+        Some(Box::new(tcx.lift(*self)?))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Rc<T> {\n     type Lifted = Rc<T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().clone()).map(Rc::new)\n+        Some(Rc::new(tcx.lift(self.as_ref().clone())?))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Arc<T> {\n     type Lifted = Arc<T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().clone()).map(Arc::new)\n+        Some(Arc::new(tcx.lift(self.as_ref().clone())?))\n     }\n }\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n@@ -312,35 +320,6 @@ impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n-    type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n-    type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n-    type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::ExistentialPredicate::Trait(x) => tcx.lift(x).map(ty::ExistentialPredicate::Trait),\n-            ty::ExistentialPredicate::Projection(x) => {\n-                tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n-            }\n-            ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                Some(ty::ExistentialPredicate::AutoTrait(def_id))\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Term<'a> {\n     type Lifted = ty::Term<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -353,121 +332,6 @@ impl<'a, 'tcx> Lift<'tcx> for Term<'a> {\n         )\n     }\n }\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n-    type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n-            trait_ref,\n-            constness: self.constness,\n-            polarity: self.polarity,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n-    type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n-        tcx.lift((self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n-            a_is_expected: self.a_is_expected,\n-            a,\n-            b,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::CoercePredicate<'a> {\n-    type Lifted = ty::CoercePredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::CoercePredicate<'tcx>> {\n-        tcx.lift((self.a, self.b)).map(|(a, b)| ty::CoercePredicate { a, b })\n-    }\n-}\n-\n-impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n-    type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift((self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n-    type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n-        tcx.lift(self.substs)\n-            .map(|substs| ty::ProjectionTy { item_def_id: self.item_def_id, substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n-    type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift((self.projection_ty, self.term))\n-            .map(|(projection_ty, term)| ty::ProjectionPredicate { projection_ty, term })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n-    type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ExistentialProjection {\n-            substs,\n-            term: tcx.lift(self.term).expect(\"type must lift when substs do\"),\n-            item_def_id: self.item_def_id,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n-    type Lifted = ty::PredicateKind<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::PredicateKind::Trait(data) => tcx.lift(data).map(ty::PredicateKind::Trait),\n-            ty::PredicateKind::Subtype(data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n-            ty::PredicateKind::Coerce(data) => tcx.lift(data).map(ty::PredicateKind::Coerce),\n-            ty::PredicateKind::RegionOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n-            }\n-            ty::PredicateKind::TypeOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::TypeOutlives)\n-            }\n-            ty::PredicateKind::Projection(data) => {\n-                tcx.lift(data).map(ty::PredicateKind::Projection)\n-            }\n-            ty::PredicateKind::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateKind::WellFormed),\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                tcx.lift(closure_substs).map(|closure_substs| {\n-                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n-                })\n-            }\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n-            }\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                tcx.lift(uv).map(|uv| ty::PredicateKind::ConstEvaluatable(uv))\n-            }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n-            }\n-            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n-                tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<'a, T>\n-where\n-    <T as Lift<'tcx>>::Lifted: TypeVisitable<'tcx>,\n-{\n-    type Lifted = ty::Binder<'tcx, T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let bound_vars = tcx.lift(self.bound_vars());\n-        tcx.lift(self.skip_binder())\n-            .zip(bound_vars)\n-            .map(|(value, vars)| ty::Binder::bind_with_vars(value, vars))\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n@@ -476,192 +340,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     }\n }\n \n-impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n-    type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.param_env).and_then(|param_env| {\n-            tcx.lift(self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n-    type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::ClosureSubsts { substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n-    type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.substs).map(|substs| ty::GeneratorSubsts { substs })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n-    type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let ty::adjustment::Adjustment { kind, target } = self;\n-        tcx.lift(kind).and_then(|kind| {\n-            tcx.lift(target).map(|target| ty::adjustment::Adjustment { kind, target })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n-    type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::adjustment::Adjust::NeverToAny => Some(ty::adjustment::Adjust::NeverToAny),\n-            ty::adjustment::Adjust::Pointer(ptr) => Some(ty::adjustment::Adjust::Pointer(ptr)),\n-            ty::adjustment::Adjust::Deref(overloaded) => {\n-                tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n-            }\n-            ty::adjustment::Adjust::Borrow(autoref) => {\n-                tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n-    type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.region).map(|region| ty::adjustment::OverloadedDeref {\n-            region,\n-            mutbl: self.mutbl,\n-            span: self.span,\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n-    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                tcx.lift(r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n-            }\n-            ty::adjustment::AutoBorrow::RawPtr(m) => Some(ty::adjustment::AutoBorrow::RawPtr(m)),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n-    type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift((self.resume_ty, self.yield_ty, self.return_ty))\n-            .map(|(resume_ty, yield_ty, return_ty)| ty::GenSig { resume_ty, yield_ty, return_ty })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n-    type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.inputs_and_output).map(|x| ty::FnSig {\n-            inputs_and_output: x,\n-            c_variadic: self.c_variadic,\n-            unsafety: self.unsafety,\n-            abi: self.abi,\n-        })\n-    }\n-}\n-\n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n-    type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        let ty::error::ExpectedFound { expected, found } = self;\n-        tcx.lift(expected).and_then(|expected| {\n-            tcx.lift(found).map(|found| ty::error::ExpectedFound { expected, found })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n-    type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        use crate::ty::error::TypeError::*;\n-\n-        Some(match self {\n-            Mismatch => Mismatch,\n-            ConstnessMismatch(x) => ConstnessMismatch(x),\n-            PolarityMismatch(x) => PolarityMismatch(x),\n-            UnsafetyMismatch(x) => UnsafetyMismatch(x),\n-            AbiMismatch(x) => AbiMismatch(x),\n-            Mutability => Mutability,\n-            ArgumentMutability(i) => ArgumentMutability(i),\n-            TupleSize(x) => TupleSize(x),\n-            FixedArraySize(x) => FixedArraySize(x),\n-            ArgCount => ArgCount,\n-            FieldMisMatch(x, y) => FieldMisMatch(x, y),\n-            RegionsDoesNotOutlive(a, b) => {\n-                return tcx.lift((a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n-            }\n-            RegionsInsufficientlyPolymorphic(a, b) => {\n-                return tcx.lift(b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n-            }\n-            RegionsOverlyPolymorphic(a, b) => {\n-                return tcx.lift(b).map(|b| RegionsOverlyPolymorphic(a, b));\n-            }\n-            RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n-            IntMismatch(x) => IntMismatch(x),\n-            FloatMismatch(x) => FloatMismatch(x),\n-            Traits(x) => Traits(x),\n-            VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => return tcx.lift(t).map(|t| CyclicTy(t)),\n-            CyclicConst(ct) => return tcx.lift(ct).map(|ct| CyclicConst(ct)),\n-            ProjectionMismatched(x) => ProjectionMismatched(x),\n-            ArgumentSorts(x, i) => return tcx.lift(x).map(|x| ArgumentSorts(x, i)),\n-            Sorts(x) => return tcx.lift(x).map(Sorts),\n-            ExistentialMismatch(x) => return tcx.lift(x).map(ExistentialMismatch),\n-            ConstMismatch(x) => return tcx.lift(x).map(ConstMismatch),\n-            IntrinsicCast => IntrinsicCast,\n-            TargetFeatureCast(x) => TargetFeatureCast(x),\n-            ObjectUnsafeCoercion(x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n-    type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::InstanceDef::Item(def_id) => Some(ty::InstanceDef::Item(def_id)),\n-            ty::InstanceDef::VTableShim(def_id) => Some(ty::InstanceDef::VTableShim(def_id)),\n-            ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n-            ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n-            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n-                Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?))\n-            }\n-            ty::InstanceDef::Virtual(def_id, n) => Some(ty::InstanceDef::Virtual(def_id, n)),\n-            ty::InstanceDef::ClosureOnceShim { call_once, track_caller } => {\n-                Some(ty::InstanceDef::ClosureOnceShim { call_once, track_caller })\n-            }\n-            ty::InstanceDef::DropGlue(def_id, ty) => {\n-                Some(ty::InstanceDef::DropGlue(def_id, tcx.lift(ty)?))\n-            }\n-            ty::InstanceDef::CloneShim(def_id, ty) => {\n-                Some(ty::InstanceDef::CloneShim(def_id, tcx.lift(ty)?))\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> Lift<'tcx> for Field {\n-    type Lifted = Field;\n-    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(self)\n-    }\n-}\n-\n-impl<'tcx> Lift<'tcx> for crate::mir::ReturnConstraint {\n-    type Lifted = crate::mir::ReturnConstraint;\n-    fn lift_to_tcx(self, _tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(self)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n@@ -924,88 +602,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::Existentia\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx>\n-    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n-{\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|p| p.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for &'tcx ty::List<ProjectionKind> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        use crate::ty::InstanceDef::*;\n-        Ok(Self {\n-            substs: self.substs.try_fold_with(folder)?,\n-            def: match self.def {\n-                Item(def) => Item(def.try_fold_with(folder)?),\n-                VTableShim(did) => VTableShim(did.try_fold_with(folder)?),\n-                ReifyShim(did) => ReifyShim(did.try_fold_with(folder)?),\n-                Intrinsic(did) => Intrinsic(did.try_fold_with(folder)?),\n-                FnPtrShim(did, ty) => {\n-                    FnPtrShim(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n-                }\n-                Virtual(did, i) => Virtual(did.try_fold_with(folder)?, i),\n-                ClosureOnceShim { call_once, track_caller } => {\n-                    ClosureOnceShim { call_once: call_once.try_fold_with(folder)?, track_caller }\n-                }\n-                DropGlue(did, ty) => {\n-                    DropGlue(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n-                }\n-                CloneShim(did, ty) => {\n-                    CloneShim(did.try_fold_with(folder)?, ty.try_fold_with(folder)?)\n-                }\n-            },\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for ty::instance::Instance<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        use crate::ty::InstanceDef::*;\n-        self.substs.visit_with(visitor)?;\n-        match self.def {\n-            Item(def) => def.visit_with(visitor),\n-            VTableShim(did) | ReifyShim(did) | Intrinsic(did) | Virtual(did, _) => {\n-                did.visit_with(visitor)\n-            }\n-            FnPtrShim(did, ty) | CloneShim(did, ty) => {\n-                did.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-            DropGlue(did, ty) => {\n-                did.visit_with(visitor)?;\n-                ty.visit_with(visitor)\n-            }\n-            ClosureOnceShim { call_once, track_caller: _ } => call_once.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(Self { instance: self.instance.try_fold_with(folder)?, promoted: self.promoted })\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for interpret::GlobalId<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.instance.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         folder.try_fold_ty(self)\n@@ -1181,12 +783,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|p| p.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx, T: TypeFoldable<'tcx>, I: Idx> TypeFoldable<'tcx> for IndexVec<I, T> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         self.try_map_id(|x| x.try_fold_with(folder))\n@@ -1233,34 +829,6 @@ impl<'tcx> TypeSuperVisitable<'tcx> for ty::Const<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        Ok(match self {\n-            ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.try_fold_with(folder)?),\n-            ty::ConstKind::Param(p) => ty::ConstKind::Param(p.try_fold_with(folder)?),\n-            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.try_fold_with(folder)?),\n-            ty::ConstKind::Value(_)\n-            | ty::ConstKind::Bound(..)\n-            | ty::ConstKind::Placeholder(..)\n-            | ty::ConstKind::Error(_) => self,\n-        })\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for ty::ConstKind<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        match *self {\n-            ty::ConstKind::Infer(ic) => ic.visit_with(visitor),\n-            ty::ConstKind::Param(p) => p.visit_with(visitor),\n-            ty::ConstKind::Unevaluated(uv) => uv.visit_with(visitor),\n-            ty::ConstKind::Value(_)\n-            | ty::ConstKind::Bound(..)\n-            | ty::ConstKind::Placeholder(_)\n-            | ty::ConstKind::Error(_) => ControlFlow::CONTINUE,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _folder: &mut F) -> Result<Self, F::Error> {\n         Ok(self)\n@@ -1315,15 +883,3 @@ impl<'tcx> TypeVisitable<'tcx> for ty::Unevaluated<'tcx, ()> {\n         self.expand().visit_with(visitor)\n     }\n }\n-\n-impl<'tcx> TypeFoldable<'tcx> for hir::Constness {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, _: &mut F) -> Result<Self, F::Error> {\n-        Ok(self)\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for hir::Constness {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> ControlFlow<V::BreakTy> {\n-        ControlFlow::CONTINUE\n-    }\n-}"}, {"sha": "36e560850390451d2fbbb9681cc9d0824d078970", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -202,7 +202,7 @@ static_assert_size!(TyKind<'_>, 32);\n /// * `GR`: The \"return type\", which is the type of value returned upon\n ///   completion of the generator.\n /// * `GW`: The \"generator witness\".\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n     /// concatenated with a tuple containing the types of the upvars.\n@@ -333,7 +333,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n }\n \n /// Similar to `ClosureSubsts`; see the above documentation for more.\n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct GeneratorSubsts<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n@@ -660,7 +660,7 @@ impl<'tcx> InlineConstSubsts<'tcx> {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n     Trait(ExistentialTraitRef<'tcx>),\n@@ -789,7 +789,7 @@ impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -867,7 +867,7 @@ impl rustc_errors::IntoDiagnosticArg for PolyTraitRef<'_> {\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -1023,7 +1023,7 @@ impl BoundVariableKind {\n ///\n /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(HashStable)]\n+#[derive(HashStable, Lift)]\n pub struct Binder<'tcx, T>(T, &'tcx List<BoundVariableKind>);\n \n impl<'tcx, T> Binder<'tcx, T>\n@@ -1185,7 +1185,7 @@ impl<'tcx, T> Binder<'tcx, Option<T>> {\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n     pub substs: SubstsRef<'tcx>,\n@@ -1237,7 +1237,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]\n pub struct GenSig<'tcx> {\n     pub resume_ty: Ty<'tcx>,\n     pub yield_ty: Ty<'tcx>,\n@@ -1253,7 +1253,7 @@ pub type PolyGenSig<'tcx> = Binder<'tcx, GenSig<'tcx>>;\n /// - `output`: is the return type.\n /// - `c_variadic`: indicates whether this is a C-variadic function.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n     pub c_variadic: bool,\n@@ -1435,7 +1435,7 @@ impl From<BoundVar> for BoundTy {\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable, TypeVisitable)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "8e69bf067d08eeb47f6a621005239dc097bbf9d0", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df34db9b032b15efd86df3544cc75e6d55dc492e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=df34db9b032b15efd86df3544cc75e6d55dc492e", "patch": "@@ -459,12 +459,6 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for SubstsRef<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         // This code is fairly hot, though not as hot as `SubstsRef`.\n@@ -497,7 +491,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeVisitable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n+impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &'tcx ty::List<T> {\n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.iter().try_for_each(|t| t.visit_with(visitor))\n     }"}]}