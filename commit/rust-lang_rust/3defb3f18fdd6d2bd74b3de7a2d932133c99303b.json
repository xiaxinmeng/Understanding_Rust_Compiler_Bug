{"sha": "3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZWZiM2YxOGZkZDZkMmJkNzRiM2RlN2EyZDkzMjEzM2M5OTMwM2I=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-26T12:12:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-26T12:12:54Z"}, "message": "fix overflow error in signed wrapping offset", "tree": {"sha": "2349961a5917ced4dff683642cd603ad832c2070", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2349961a5917ced4dff683642cd603ad832c2070"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "html_url": "https://github.com/rust-lang/rust/commit/3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3defb3f18fdd6d2bd74b3de7a2d932133c99303b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082da0c6984dd37ab5d65db939c538f0d24bc19f", "url": "https://api.github.com/repos/rust-lang/rust/commits/082da0c6984dd37ab5d65db939c538f0d24bc19f", "html_url": "https://github.com/rust-lang/rust/commit/082da0c6984dd37ab5d65db939c538f0d24bc19f"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "33c85a6f46e8ea3f39c85513bcf4f7bd0cb1a1df", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3defb3f18fdd6d2bd74b3de7a2d932133c99303b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3defb3f18fdd6d2bd74b3de7a2d932133c99303b/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=3defb3f18fdd6d2bd74b3de7a2d932133c99303b", "patch": "@@ -20,45 +20,48 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         self.data_layout().pointer_size\n     }\n \n-    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    /// Helper function: truncate given value-\"overflowed flag\" pair to pointer size and\n+    /// update \"overflowed flag\" if there was an overflow.\n+    /// This should be called by all the other methods before returning!\n     #[inline]\n-    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n+    fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n+        let val = val as u128;\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n-    }\n-\n-    #[inline]\n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n-        let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n-        (res, over1 || over2)\n-    }\n-\n-    #[inline]\n-    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        let res = val.overflowing_add(i);\n+        self.truncate_to_ptr(res)\n     }\n \n     // Overflow checking only works properly on the range from -u64 to +u64.\n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n+            // Trickery to ensure that i64::min_value() works fine: compute n = -i.\n+            // This formula only works for true negative values, it overflows for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n+            let res = val.overflowing_sub(n);\n+            self.truncate_to_ptr(res)\n         } else {\n             self.overflowing_offset(val, i as u64)\n         }\n     }\n+\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n+\n+    #[inline]\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n }\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}"}]}