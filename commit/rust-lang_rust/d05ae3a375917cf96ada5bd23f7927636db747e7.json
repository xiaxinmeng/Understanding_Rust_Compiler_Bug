{"sha": "d05ae3a375917cf96ada5bd23f7927636db747e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNWFlM2EzNzU5MTdjZjk2YWRhNWJkMjNmNzkyNzYzNmRiNzQ3ZTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2020-04-15T16:28:01Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2020-04-15T16:28:01Z"}, "message": "Incorporated review feedback:\n\nRenamed the struct to make it a little clearer that it doesn't just hold one\nimports map. (I couldn't bring myself to write it as `ThinLTOImportsExports`\nthough, mainly since the exports map is literally derived from the imports map\ndata.) Added some doc to the struct too.\n\nRevised comments to add link to the newer issue that discusses why the exports\nare relevant.\n\nRenamed a few of the methods so that the two character difference is more\napparent (because 1. the method name is shorter and, perhaps more importantly,\nthe changed characters now lie at the beginning of the method name.)", "tree": {"sha": "b99220d09f104e1b5852a07a43e9b909fae0c8c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b99220d09f104e1b5852a07a43e9b909fae0c8c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d05ae3a375917cf96ada5bd23f7927636db747e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d05ae3a375917cf96ada5bd23f7927636db747e7", "html_url": "https://github.com/rust-lang/rust/commit/d05ae3a375917cf96ada5bd23f7927636db747e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d05ae3a375917cf96ada5bd23f7927636db747e7/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12207f6c66f6fa5a19790c9c8bf1b398a7dc263d", "url": "https://api.github.com/repos/rust-lang/rust/commits/12207f6c66f6fa5a19790c9c8bf1b398a7dc263d", "html_url": "https://github.com/rust-lang/rust/commit/12207f6c66f6fa5a19790c9c8bf1b398a7dc263d"}], "stats": {"total": 62, "additions": 40, "deletions": 22}, "files": [{"sha": "e21cdee961dc61c5d02b4d508495cf3a4b1e869f", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d05ae3a375917cf96ada5bd23f7927636db747e7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d05ae3a375917cf96ada5bd23f7927636db747e7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=d05ae3a375917cf96ada5bd23f7927636db747e7", "patch": "@@ -463,15 +463,18 @@ fn thin_lto(\n                 // If previous imports have been deleted, or we get an IO error\n                 // reading the file storing them, then we'll just use `None` as the\n                 // prev_import_map, which will force the code to be recompiled.\n-                let prev =\n-                    if path.exists() { ThinLTOImports::load_from_file(&path).ok() } else { None };\n-                let curr = ThinLTOImports::from_thin_lto_data(data);\n+                let prev = if path.exists() {\n+                    ThinLTOImportMaps::load_from_file(&path).ok()\n+                } else {\n+                    None\n+                };\n+                let curr = ThinLTOImportMaps::from_thin_lto_data(data);\n                 (Some(path), prev, curr)\n             } else {\n                 // If we don't compile incrementally, we don't need to load the\n                 // import data from LLVM.\n                 assert!(green_modules.is_empty());\n-                let curr = ThinLTOImports::default();\n+                let curr = ThinLTOImportMaps::default();\n                 (None, None, curr)\n             };\n         info!(\"thin LTO import map loaded\");\n@@ -497,10 +500,14 @@ fn thin_lto(\n             let module_name = module_name_to_str(module_name);\n \n             // If (1.) the module hasn't changed, and (2.) none of the modules\n-            // it imports from has changed, *and* (3.) the import-set itself has\n-            // not changed from the previous compile when it was last\n-            // ThinLTO'ed, then we can re-use the post-ThinLTO version of the\n-            // module. Otherwise, freshly perform LTO optimization.\n+            // it imports from nor exports to have changed, *and* (3.) the\n+            // import and export sets themselves have not changed from the\n+            // previous compile when it was last ThinLTO'ed, then we can re-use\n+            // the post-ThinLTO version of the module. Otherwise, freshly\n+            // perform LTO optimization.\n+            //\n+            // (Note that globally, the export set is just the inverse of the\n+            // import set.)\n             //\n             // This strategy means we can always save the computed imports as\n             // canon: when we reuse the post-ThinLTO version, condition (3.)\n@@ -509,16 +516,18 @@ fn thin_lto(\n             // version, the current import set *is* the correct one, since we\n             // are doing the ThinLTO in this current compilation cycle.)\n             //\n-            // See rust-lang/rust#59535.\n+            // For more discussion, see rust-lang/rust#59535 (where the import\n+            // issue was discovered) and rust-lang/rust#69798 (where the\n+            // analogous export issue was discovered).\n             if let (Some(prev_import_map), true) =\n                 (prev_import_map.as_ref(), green_modules.contains_key(module_name))\n             {\n                 assert!(cgcx.incr_comp_session_dir.is_some());\n \n-                let prev_imports = prev_import_map.modules_imported_by(module_name);\n-                let curr_imports = curr_import_map.modules_imported_by(module_name);\n-                let prev_exports = prev_import_map.modules_exported_by(module_name);\n-                let curr_exports = curr_import_map.modules_exported_by(module_name);\n+                let prev_imports = prev_import_map.imports_of(module_name);\n+                let curr_imports = curr_import_map.imports_of(module_name);\n+                let prev_exports = prev_import_map.exports_of(module_name);\n+                let curr_exports = curr_import_map.exports_of(module_name);\n                 let imports_all_green = curr_imports\n                     .iter()\n                     .all(|imported_module| green_modules.contains_key(imported_module));\n@@ -890,20 +899,29 @@ pub unsafe fn optimize_thin_module(\n     Ok(module)\n }\n \n+/// Summarizes module import/export relationships used by LLVM's ThinLTO pass.\n+///\n+/// Note that we tend to have two such instances of `ThinLTOImportMaps` in use:\n+/// one loaded from a file that represents the relationships used during the\n+/// compilation associated with the incremetnal build artifacts we are\n+/// attempting to reuse, and another constructed via `from_thin_lto_data`, which\n+/// captures the relationships of ThinLTO in the current compilation.\n #[derive(Debug, Default)]\n-pub struct ThinLTOImports {\n+pub struct ThinLTOImportMaps {\n     // key = llvm name of importing module, value = list of modules it imports from\n     imports: FxHashMap<String, Vec<String>>,\n     // key = llvm name of exporting module, value = list of modules it exports to\n     exports: FxHashMap<String, Vec<String>>,\n }\n \n-impl ThinLTOImports {\n-    fn modules_imported_by(&self, llvm_module_name: &str) -> &[String] {\n+impl ThinLTOImportMaps {\n+    /// Returns modules imported by `llvm_module_name` during some ThinLTO pass.\n+    fn imports_of(&self, llvm_module_name: &str) -> &[String] {\n         self.imports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n-    fn modules_exported_by(&self, llvm_module_name: &str) -> &[String] {\n+    /// Returns modules exported by `llvm_module_name` during some ThinLTO pass.\n+    fn exports_of(&self, llvm_module_name: &str) -> &[String] {\n         self.exports.get(llvm_module_name).map(|v| &v[..]).unwrap_or(&[])\n     }\n \n@@ -921,7 +939,7 @@ impl ThinLTOImports {\n         Ok(())\n     }\n \n-    fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n+    fn load_from_file(path: &Path) -> io::Result<ThinLTOImportMaps> {\n         use std::io::BufRead;\n         let mut imports = FxHashMap::default();\n         let mut exports: FxHashMap<_, Vec<_>> = FxHashMap::default();\n@@ -946,17 +964,17 @@ impl ThinLTOImports {\n                 current_module = Some(line.trim().to_string());\n             }\n         }\n-        Ok(ThinLTOImports { imports, exports })\n+        Ok(ThinLTOImportMaps { imports, exports })\n     }\n \n     /// Loads the ThinLTO import map from ThinLTOData.\n-    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n+    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImportMaps {\n         unsafe extern \"C\" fn imported_module_callback(\n             payload: *mut libc::c_void,\n             importing_module_name: *const libc::c_char,\n             imported_module_name: *const libc::c_char,\n         ) {\n-            let map = &mut *(payload as *mut ThinLTOImports);\n+            let map = &mut *(payload as *mut ThinLTOImportMaps);\n             let importing_module_name = CStr::from_ptr(importing_module_name);\n             let importing_module_name = module_name_to_str(&importing_module_name);\n             let imported_module_name = CStr::from_ptr(imported_module_name);\n@@ -981,7 +999,7 @@ impl ThinLTOImports {\n                 .push(importing_module_name.to_owned());\n         }\n \n-        let mut map = ThinLTOImports::default();\n+        let mut map = ThinLTOImportMaps::default();\n         llvm::LLVMRustGetThinLTOModuleImports(\n             data,\n             imported_module_callback,"}]}