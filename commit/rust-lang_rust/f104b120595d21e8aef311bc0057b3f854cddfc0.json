{"sha": "f104b120595d21e8aef311bc0057b3f854cddfc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMDRiMTIwNTk1ZDIxZThhZWYzMTFiYzAwNTdiM2Y4NTRjZGRmYzA=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-02-11T16:51:58Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-02-11T17:03:16Z"}, "message": "Change Step to be invoked with a path when in default mode.\n\nPreviously, a Step would be able to tell on its own when it was invoked\n\"by-default\" (that is, `./x.py test` was called instead of `./x.py test\nsome/path`). This commit replaces that functionality, invoking each Step\nwith each of the paths it has specified as \"should be invoked by.\"\n\nFor example, if a step calls `path(\"src/tools/cargo\")` and\n`path(\"src/doc/cargo\")` then it's make_run will be called twice, with\n\"src/tools/cargo\" and \"src/doc/cargo.\" This makes it so that default\nhandling logic is in builder, instead of spread across various Steps.\n\nHowever, this meant that some Step specifications needed to be updated,\nsince for example `rustdoc` can be built by `./x.py build\nsrc/librustdoc` or `./x.py build src/tools/rustdoc`. A `PathSet`\nabstraction is added that handles this: now, each Step can not only list\n`path(...)` but also `paths(&[a, b, ...])` which will make it so that we\ndon't invoke it with each of the individual paths, instead invoking it\nwith the first path in the list (though this shouldn't be depended on).\n\nFuture work likely consists of implementing a better/easier way for a\ngiven Step to work with \"any\" crate in-tree, especially those that want\nto run tests, build, or check crates in the std, test, or rustc crate\ntrees. Currently this is rather painful to do as most of the logic is\nduplicated across should_run and make_run. It seems likely this can be\nabstracted away into builder somehow.", "tree": {"sha": "90949b57ea12981bfdeabb37cc7ba55bac3f6687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90949b57ea12981bfdeabb37cc7ba55bac3f6687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f104b120595d21e8aef311bc0057b3f854cddfc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f104b120595d21e8aef311bc0057b3f854cddfc0", "html_url": "https://github.com/rust-lang/rust/commit/f104b120595d21e8aef311bc0057b3f854cddfc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f104b120595d21e8aef311bc0057b3f854cddfc0/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55c36e37443e6fa4252157d4bc47b49b3d6e201d", "url": "https://api.github.com/repos/rust-lang/rust/commits/55c36e37443e6fa4252157d4bc47b49b3d6e201d", "html_url": "https://github.com/rust-lang/rust/commit/55c36e37443e6fa4252157d4bc47b49b3d6e201d"}], "stats": {"total": 727, "additions": 415, "deletions": 312}, "files": [{"sha": "cbd303e114066a39c2636b3e52dd1d0a6d0c9736", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 85, "deletions": 40, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -95,7 +95,7 @@ pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n     pub host: Interned<String>,\n     pub target: Interned<String>,\n-    pub path: Option<&'a Path>,\n+    pub path: &'a Path,\n }\n \n struct StepDescription {\n@@ -105,6 +105,28 @@ struct StepDescription {\n     only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n+    name: &'static str,\n+}\n+\n+#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+struct PathSet {\n+    set: BTreeSet<PathBuf>,\n+}\n+\n+impl PathSet {\n+    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+        let mut set = BTreeSet::new();\n+        set.insert(path.into());\n+        PathSet { set }\n+    }\n+\n+    fn has(&self, needle: &Path) -> bool {\n+        self.set.iter().any(|p| p.ends_with(needle))\n+    }\n+\n+    fn path(&self) -> &Path {\n+        self.set.iter().next().unwrap()\n+    }\n }\n \n impl StepDescription {\n@@ -116,30 +138,17 @@ impl StepDescription {\n             only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n+            name: unsafe { ::std::intrinsics::type_name::<S>() },\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, should_run: &ShouldRun, path: Option<&Path>) {\n-        if let Some(path) = path {\n-            if builder.config.exclude.iter().any(|e| e == path) {\n-                eprintln!(\"Skipping {:?} because this path is excluded\", path);\n-                return;\n-            } else if !builder.config.exclude.is_empty() {\n-                eprintln!(\"{:?} not skipped -- not in {:?}\", path, builder.config.exclude);\n-            }\n-        } else {\n-            if !should_run.paths.is_empty() {\n-                if should_run.paths.iter().all(|p| builder.config.exclude.contains(&p)) {\n-                    eprintln!(\"Skipping because all of its paths ({:?}) are excluded\",\n-                        should_run.paths);\n-                    return;\n-                } else if should_run.paths.len() > 1 {\n-                    for path in &should_run.paths {\n-                        self.maybe_run(builder, should_run, Some(path));\n-                    }\n-                    return;\n-                }\n-            }\n+    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+            return;\n+        } else if !builder.config.exclude.is_empty() {\n+            eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n+                self.name, builder.config.exclude);\n         }\n         let build = builder.build;\n         let hosts = if self.only_build_targets || self.only_build {\n@@ -165,7 +174,7 @@ impl StepDescription {\n             for target in targets {\n                 let run = RunConfig {\n                     builder,\n-                    path,\n+                    path: pathset.path(),\n                     host: *host,\n                     target: *target,\n                 };\n@@ -178,19 +187,28 @@ impl StepDescription {\n         let should_runs = v.iter().map(|desc| {\n             (desc.should_run)(ShouldRun::new(builder))\n         }).collect::<Vec<_>>();\n+\n+        // sanity checks on rules\n+        for (desc, should_run) in v.iter().zip(&should_runs) {\n+            assert!(!should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\", desc.name);\n+        }\n+\n         if paths.is_empty() {\n             for (desc, should_run) in v.iter().zip(should_runs) {\n                 if desc.default && should_run.is_really_default {\n-                    desc.maybe_run(builder, &should_run, None);\n+                    for pathset in &should_run.paths {\n+                        desc.maybe_run(builder, pathset);\n+                    }\n                 }\n             }\n         } else {\n             for path in paths {\n                 let mut attempted_run = false;\n                 for (desc, should_run) in v.iter().zip(&should_runs) {\n-                    if should_run.run(path) {\n+                    if let Some(pathset) = should_run.pathset_for_path(path) {\n                         attempted_run = true;\n-                        desc.maybe_run(builder, &should_run, Some(path));\n+                        desc.maybe_run(builder, pathset);\n                     }\n                 }\n \n@@ -206,7 +224,7 @@ impl StepDescription {\n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n     // use a BTreeSet to maintain sort order\n-    paths: BTreeSet<PathBuf>,\n+    paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n     // it's run. Generally something like compiler docs being enabled.\n@@ -227,15 +245,35 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n+    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n+    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n+    // actually doing something different for every crate passed.\n+    pub fn all_krates(mut self, name: &str) -> Self {\n+        let mut set = BTreeSet::new();\n+        for krate in self.builder.in_tree_crates(name) {\n+            set.insert(PathBuf::from(&krate.path));\n+        }\n+        self.paths.insert(PathSet { set });\n+        self\n+    }\n+\n     pub fn krate(mut self, name: &str) -> Self {\n-        for (_, krate_path) in self.builder.crates(name) {\n-            self.paths.insert(t!(env::current_dir()).join(krate_path));\n+        for krate in self.builder.in_tree_crates(name) {\n+            self.paths.insert(PathSet::one(&krate.path));\n         }\n         self\n     }\n \n-    pub fn path(mut self, path: &str) -> Self {\n-        self.paths.insert(t!(env::current_dir()).join(path));\n+    // single, non-aliased path\n+    pub fn path(self, path: &str) -> Self {\n+        self.paths(&[path])\n+    }\n+\n+    // multiple aliases for the same job\n+    pub fn paths(mut self, paths: &[&str]) -> Self {\n+        self.paths.insert(PathSet {\n+            set: paths.iter().map(PathBuf::from).collect(),\n+        });\n         self\n     }\n \n@@ -244,8 +282,8 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n-    fn run(&self, path: &Path) -> bool {\n-        self.paths.iter().any(|p| path.ends_with(p))\n+    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path))\n     }\n }\n \n@@ -275,11 +313,16 @@ impl<'a> Builder<'a> {\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n             Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n-            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n-                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n-                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n-                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n-                test::RustdocJS, test::RustdocTheme),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n+                test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n+                test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n+                test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n+                test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n+                test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n+                test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n+                test::Cargo, test::Rls, test::Docs, test::ErrorIndex, test::Distcheck,\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n@@ -317,8 +360,10 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n-        for path in should_run.paths {\n-            help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+        for pathset in should_run.paths {\n+            for path in pathset.set {\n+                help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+            }\n         }\n         Some(help)\n     }"}, {"sha": "767ee4016c6f1d6df08505e8f323b6f9a61a167c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -26,7 +26,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -67,7 +67,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -114,7 +114,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "2dcc0e0e7cd9f0110a583a93ad1450cb7ca3d08a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -320,7 +320,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -436,7 +436,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -593,7 +593,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc_trans\")\n+        run.all_krates(\"rustc_trans\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -828,7 +828,7 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rustc\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`"}, {"sha": "55d9723527e6db26ac617f8fe77ea9acbcfc1fcf", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -429,7 +429,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"std\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\").default_condition(builder.build.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "afd740ce5484549f32ee7735514162726f3ed671", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -113,9 +113,8 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(warnings)]\n-#![allow(stable_features)]\n-#![feature(associated_consts)]\n+//#![deny(warnings)]\n+#![feature(core_intrinsics)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -267,6 +266,18 @@ struct Crate {\n     bench_step: String,\n }\n \n+impl Crate {\n+    fn is_local(&self, build: &Build) -> bool {\n+        self.path.starts_with(&build.config.src) &&\n+        !self.path.to_string_lossy().ends_with(\"_shim\")\n+    }\n+\n+    fn local_path(&self, build: &Build) -> PathBuf {\n+        assert!(self.is_local(build));\n+        self.path.strip_prefix(&build.config.src).unwrap().into()\n+    }\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -949,22 +960,18 @@ impl Build {\n         }\n     }\n \n-    /// Get a list of crates from a root crate.\n-    ///\n-    /// Returns Vec<(crate, path to crate, is_root_crate)>\n-    fn crates(&self, root: &str) -> Vec<(Interned<String>, &Path)> {\n-        let interned = INTERNER.intern_string(root.to_owned());\n+    fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n-        let mut list = vec![interned];\n+        let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            // If we can't strip prefix, then out-of-tree path\n-            let path = krate.path.strip_prefix(&self.src).unwrap_or(&krate.path);\n-            ret.push((krate.name, path));\n-            for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(*dep);\n+            if krate.is_local(self) {\n+                ret.push(krate);\n+                for dep in &krate.deps {\n+                    if visited.insert(dep) && dep != \"build_helper\" {\n+                        list.push(*dep);\n+                    }\n                 }\n             }\n         }"}, {"sha": "3c91cf3ecc7b5312f51d7a9997b3e656c017290f", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -51,9 +51,7 @@ impl Step for Llvm {\n     }\n \n     fn make_run(run: RunConfig) {\n-        let emscripten = run.path.map(|p| {\n-            p.ends_with(\"llvm-emscripten\")\n-        }).unwrap_or(false);\n+        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n             emscripten,"}, {"sha": "64ede4f4ecc885f071969a6f516db5eb63a6a10d", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 298, "deletions": 245, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f104b120595d21e8aef311bc0057b3f854cddfc0/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f104b120595d21e8aef311bc0057b3f854cddfc0", "patch": "@@ -13,7 +13,6 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::HashSet;\n use std::env;\n use std::ffi::OsString;\n use std::iter;\n@@ -26,6 +25,7 @@ use std::io::Read;\n use build_helper::{self, output};\n \n use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use Crate as CargoCrate;\n use cache::{INTERNER, Interned};\n use compile;\n use dist;\n@@ -550,181 +550,214 @@ fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! default_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: false });\n+    }\n }\n \n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! host_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: true });\n+    }\n }\n \n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n+macro_rules! test {\n+    ($name:ident {\n+        path: $path:expr,\n+        mode: $mode:expr,\n+        suite: $suite:expr,\n+        default: $default:expr,\n+        host: $host:expr\n+    }) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n         }\n-        run\n-    }\n \n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+        impl Step for $name {\n+            type Output = ();\n+            const DEFAULT: bool = $default;\n+            const ONLY_HOSTS: bool = $host;\n \n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                run.path($path)\n             }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test {\n-        path: \"src/test/incremental-fulldeps\",\n-        mode: \"incremental\",\n-        suite: \"incremental-fulldeps\",\n-    },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-];\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n+            fn make_run(run: RunConfig) {\n+                let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n+                run.builder.ensure($name {\n                     compiler,\n                     target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n                 });\n             }\n-        }\n-    }\n \n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n+            fn run(self, builder: &Builder) {\n+                builder.ensure(Compiletest {\n+                    compiler: self.compiler,\n+                    target: self.target,\n+                    mode: $mode,\n+                    suite: $suite,\n+                })\n+            }\n+        }\n     }\n }\n \n+default_test!(Ui {\n+    path: \"src/test/ui\",\n+    mode: \"ui\",\n+    suite: \"ui\"\n+});\n+\n+default_test!(RunPass {\n+    path: \"src/test/run-pass\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass\"\n+});\n+\n+default_test!(CompileFail {\n+    path: \"src/test/compile-fail\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail\"\n+});\n+\n+default_test!(ParseFail {\n+    path: \"src/test/parse-fail\",\n+    mode: \"parse-fail\",\n+    suite: \"parse-fail\"\n+});\n+\n+default_test!(RunFail {\n+    path: \"src/test/run-fail\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail\"\n+});\n+\n+default_test!(RunPassValgrind {\n+    path: \"src/test/run-pass-valgrind\",\n+    mode: \"run-pass-valgrind\",\n+    suite: \"run-pass-valgrind\"\n+});\n+\n+default_test!(MirOpt {\n+    path: \"src/test/mir-opt\",\n+    mode: \"mir-opt\",\n+    suite: \"mir-opt\"\n+});\n+\n+default_test!(Codegen {\n+    path: \"src/test/codegen\",\n+    mode: \"codegen\",\n+    suite: \"codegen\"\n+});\n+\n+default_test!(CodegenUnits {\n+    path: \"src/test/codegen-units\",\n+    mode: \"codegen-units\",\n+    suite: \"codegen-units\"\n+});\n+\n+default_test!(Incremental {\n+    path: \"src/test/incremental\",\n+    mode: \"incremental\",\n+    suite: \"incremental\"\n+});\n+\n+default_test!(Debuginfo {\n+    path: \"src/test/debuginfo\",\n+    // What this runs varies depending on the native platform being apple\n+    mode: \"debuginfo-XXX\",\n+    suite: \"debuginfo\"\n+});\n+\n+host_test!(UiFullDeps {\n+    path: \"src/test/ui-fulldeps\",\n+    mode: \"ui\",\n+    suite: \"ui-fulldeps\"\n+});\n+\n+host_test!(RunPassFullDeps {\n+    path: \"src/test/run-pass-fulldeps\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass-fulldeps\"\n+});\n+\n+host_test!(RunFailFullDeps {\n+    path: \"src/test/run-fail-fulldeps\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail-fulldeps\"\n+});\n+\n+host_test!(CompileFailFullDeps {\n+    path: \"src/test/compile-fail-fulldeps\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail-fulldeps\"\n+});\n+\n+host_test!(IncrementalFullDeps {\n+    path: \"src/test/incremental-fulldeps\",\n+    mode: \"incremental\",\n+    suite: \"incremental-fulldeps\"\n+});\n+\n+host_test!(Rustdoc {\n+    path: \"src/test/rustdoc\",\n+    mode: \"rustdoc\",\n+    suite: \"rustdoc\"\n+});\n+\n+test!(Pretty {\n+    path: \"src/test/pretty\",\n+    mode: \"pretty\",\n+    suite: \"pretty\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassPretty {\n+    path: \"src/test/run-pass/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailPretty {\n+    path: \"src/test/run-fail/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassValgrindPretty {\n+    path: \"src/test/run-pass-valgrind/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-valgrind\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassFullDepsPretty {\n+    path: \"src/test/run-pass-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailFullDepsPretty {\n+    path: \"src/test/run-fail-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+\n+host_test!(RunMake {\n+    path: \"src/test/run-make\",\n+    mode: \"run-make\",\n+    suite: \"run-make\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -902,7 +935,7 @@ impl Step for Compiletest {\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n             return;\n         }\n \n@@ -1099,7 +1132,7 @@ pub struct CrateLibrustc {\n     compiler: Compiler,\n     target: Interned<String>,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for CrateLibrustc {\n@@ -1115,35 +1148,26 @@ impl Step for CrateLibrustc {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n+        for krate in builder.in_tree_crates(\"rustc-main\") {\n+            if run.path.ends_with(&krate.path) {\n+                let test_kind = if builder.kind == Kind::Test {\n+                    TestKind::Test\n+                } else if builder.kind == Kind::Bench {\n+                    TestKind::Bench\n+                } else {\n+                    panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+                };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n+                builder.ensure(CrateLibrustc {\n+                    compiler,\n+                    target: run.target,\n+                    test_kind,\n+                    krate: krate.name,\n+                });\n             }\n-        } else {\n-            make(None);\n         }\n     }\n \n-\n     fn run(self, builder: &Builder) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n@@ -1155,28 +1179,96 @@ impl Step for CrateLibrustc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateNotDefault {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: &'static str,\n+}\n+\n+impl Step for CrateNotDefault {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/liballoc_jemalloc\")\n+            .path(\"src/librustc_asan\")\n+            .path(\"src/librustc_lsan\")\n+            .path(\"src/librustc_msan\")\n+            .path(\"src/librustc_tsan\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(CrateNotDefault {\n+            compiler,\n+            target: run.target,\n+            test_kind,\n+            krate: match run.path {\n+                _ if run.path.ends_with(\"src/liballoc_jemalloc\") => \"alloc_jemalloc\",\n+                _ if run.path.ends_with(\"src/librustc_asan\") => \"rustc_asan\",\n+                _ if run.path.ends_with(\"src/librustc_lsan\") => \"rustc_lsan\",\n+                _ if run.path.ends_with(\"src/librustc_msan\") => \"rustc_msan\",\n+                _ if run.path.ends_with(\"src/librustc_tsan\") => \"rustc_tsan\",\n+                _ => panic!(\"unexpected path {:?}\", run.path),\n+            },\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Libstd,\n+            test_kind: self.test_kind,\n+            krate: INTERNER.intern_str(self.krate),\n+        });\n+    }\n+}\n+\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n     compiler: Compiler,\n     target: Interned<String>,\n     mode: Mode,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run = run.krate(\"test\");\n+        for krate in run.builder.in_tree_crates(\"std\") {\n+            if krate.is_local(&run.builder) &&\n+                !krate.name.contains(\"jemalloc\") &&\n+                !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) &&\n+                krate.name != \"dlmalloc\" {\n+                run = run.path(krate.local_path(&builder).to_str().unwrap());\n+            }\n+        }\n+        run\n     }\n \n     fn make_run(run: RunConfig) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n+        let make = |mode: Mode, krate: &CargoCrate| {\n             let test_kind = if builder.kind == Kind::Test {\n                 TestKind::Test\n             } else if builder.kind == Kind::Bench {\n@@ -1190,29 +1282,24 @@ impl Step for Crate {\n                 target: run.target,\n                 mode,\n                 test_kind,\n-                krate: name,\n+                krate: krate.name,\n             });\n         };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n+        for krate in builder.in_tree_crates(\"std\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libstd, krate);\n             }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n+        }\n+        for krate in builder.in_tree_crates(\"test\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libtest, krate);\n             }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n+    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n     /// It essentially is the driver for running `cargo test`.\n@@ -1241,27 +1328,23 @@ impl Step for Crate {\n         };\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n+        match mode {\n             Mode::Libstd => {\n                 compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n             }\n             Mode::Libtest => {\n                 compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n             }\n             Mode::Librustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(build, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let root = INTERNER.intern_string(String::from(root));\n         let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n         });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n                 &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n@@ -1273,37 +1356,7 @@ impl Step for Crate {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        cargo.arg(\"-p\").arg(krate);\n \n         // The tests are going to run with the *target* libraries, so we need to\n         // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n@@ -1355,18 +1408,18 @@ impl Step for Crate {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n+pub struct CrateRustdoc {\n     host: Interned<String>,\n     test_kind: TestKind,\n }\n \n-impl Step for Rustdoc {\n+impl Step for CrateRustdoc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -1380,7 +1433,7 @@ impl Step for Rustdoc {\n             panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n         };\n \n-        builder.ensure(Rustdoc {\n+        builder.ensure(CrateRustdoc {\n             host: run.host,\n             test_kind,\n         });"}]}