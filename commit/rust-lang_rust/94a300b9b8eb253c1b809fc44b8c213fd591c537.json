{"sha": "94a300b9b8eb253c1b809fc44b8c213fd591c537", "node_id": "C_kwDOAAsO6NoAKDk0YTMwMGI5YjhlYjI1M2MxYjgwOWZjNDRiOGMyMTNmZDU5MWM1Mzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T21:29:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T21:29:52Z"}, "message": "Auto merge of #105102 - compiler-errors:copy-impl-considering-regions, r=lcnr\n\nCheck ADT fields for copy implementations considering regions\n\nFixes #88901\nr? `@ghost`", "tree": {"sha": "6d1023f8bd4b1e87978a19b038ac3c84d5165630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d1023f8bd4b1e87978a19b038ac3c84d5165630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94a300b9b8eb253c1b809fc44b8c213fd591c537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94a300b9b8eb253c1b809fc44b8c213fd591c537", "html_url": "https://github.com/rust-lang/rust/commit/94a300b9b8eb253c1b809fc44b8c213fd591c537", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94a300b9b8eb253c1b809fc44b8c213fd591c537/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14", "html_url": "https://github.com/rust-lang/rust/commit/5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14"}, {"sha": "75074e0e528cf8a50310bc0de19f73b60e8c8304", "url": "https://api.github.com/repos/rust-lang/rust/commits/75074e0e528cf8a50310bc0de19f73b60e8c8304", "html_url": "https://github.com/rust-lang/rust/commit/75074e0e528cf8a50310bc0de19f73b60e8c8304"}], "stats": {"total": 320, "additions": 218, "deletions": 102}, "files": [{"sha": "28c04087868a7d35e4677488297a5ebe865eed6f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -7,13 +7,15 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n-use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{self, RegionResolutionError};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitable};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n-use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n+use rustc_trait_selection::traits::misc::{\n+    type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n+};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n@@ -79,7 +81,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     };\n \n     let cause = traits::ObligationCause::misc(span, impl_hir_id);\n-    match can_type_implement_copy(tcx, param_env, self_type, cause) {\n+    match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let mut err = struct_span_err!(\n@@ -94,50 +96,70 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n             let mut errors: BTreeMap<_, Vec<_>> = Default::default();\n             let mut bounds = vec![];\n \n-            for (field, ty) in fields {\n+            for (field, ty, reason) in fields {\n                 let field_span = tcx.def_span(field.did);\n-                let field_ty_span = match tcx.hir().get_if_local(field.did) {\n-                    Some(hir::Node::Field(field_def)) => field_def.ty.span,\n-                    _ => field_span,\n-                };\n                 err.span_label(field_span, \"this field does not implement `Copy`\");\n-                // Spin up a new FulfillmentContext, so we can get the _precise_ reason\n-                // why this field does not implement Copy. This is useful because sometimes\n-                // it is not immediately clear why Copy is not implemented for a field, since\n-                // all we point at is the field itself.\n-                let infcx = tcx.infer_ctxt().ignoring_regions().build();\n-                for error in traits::fully_solve_bound(\n-                    &infcx,\n-                    traits::ObligationCause::dummy_with_span(field_ty_span),\n-                    param_env,\n-                    ty,\n-                    tcx.require_lang_item(LangItem::Copy, Some(span)),\n-                ) {\n-                    let error_predicate = error.obligation.predicate;\n-                    // Only note if it's not the root obligation, otherwise it's trivial and\n-                    // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n-\n-                    // FIXME: This error could be more descriptive, especially if the error_predicate\n-                    // contains a foreign type or if it's a deeply nested type...\n-                    if error_predicate != error.root_obligation.predicate {\n-                        errors\n-                            .entry((ty.to_string(), error_predicate.to_string()))\n-                            .or_default()\n-                            .push(error.obligation.cause.span);\n+\n+                match reason {\n+                    InfringingFieldsReason::Fulfill(fulfillment_errors) => {\n+                        for error in fulfillment_errors {\n+                            let error_predicate = error.obligation.predicate;\n+                            // Only note if it's not the root obligation, otherwise it's trivial and\n+                            // should be self-explanatory (i.e. a field literally doesn't implement Copy).\n+\n+                            // FIXME: This error could be more descriptive, especially if the error_predicate\n+                            // contains a foreign type or if it's a deeply nested type...\n+                            if error_predicate != error.root_obligation.predicate {\n+                                errors\n+                                    .entry((ty.to_string(), error_predicate.to_string()))\n+                                    .or_default()\n+                                    .push(error.obligation.cause.span);\n+                            }\n+                            if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                                ty::TraitPredicate {\n+                                    trait_ref,\n+                                    polarity: ty::ImplPolarity::Positive,\n+                                    ..\n+                                },\n+                            )) = error_predicate.kind().skip_binder()\n+                            {\n+                                let ty = trait_ref.self_ty();\n+                                if let ty::Param(_) = ty.kind() {\n+                                    bounds.push((\n+                                        format!(\"{ty}\"),\n+                                        trait_ref.print_only_trait_path().to_string(),\n+                                        Some(trait_ref.def_id),\n+                                    ));\n+                                }\n+                            }\n+                        }\n                     }\n-                    if let ty::PredicateKind::Clause(ty::Clause::Trait(ty::TraitPredicate {\n-                        trait_ref,\n-                        polarity: ty::ImplPolarity::Positive,\n-                        ..\n-                    })) = error_predicate.kind().skip_binder()\n-                    {\n-                        let ty = trait_ref.self_ty();\n-                        if let ty::Param(_) = ty.kind() {\n-                            bounds.push((\n-                                format!(\"{ty}\"),\n-                                trait_ref.print_only_trait_path().to_string(),\n-                                Some(trait_ref.def_id),\n-                            ));\n+                    InfringingFieldsReason::Regions(region_errors) => {\n+                        for error in region_errors {\n+                            let ty = ty.to_string();\n+                            match error {\n+                                RegionResolutionError::ConcreteFailure(origin, a, b) => {\n+                                    let predicate = format!(\"{b}: {a}\");\n+                                    errors\n+                                        .entry((ty.clone(), predicate.clone()))\n+                                        .or_default()\n+                                        .push(origin.span());\n+                                    if let ty::RegionKind::ReEarlyBound(ebr) = *b && ebr.has_name() {\n+                                        bounds.push((b.to_string(), a.to_string(), None));\n+                                    }\n+                                }\n+                                RegionResolutionError::GenericBoundFailure(origin, a, b) => {\n+                                    let predicate = format!(\"{a}: {b}\");\n+                                    errors\n+                                        .entry((ty.clone(), predicate.clone()))\n+                                        .or_default()\n+                                        .push(origin.span());\n+                                    if let infer::region_constraints::GenericKind::Param(_) = a {\n+                                        bounds.push((a.to_string(), b.to_string(), None));\n+                                    }\n+                                }\n+                                _ => continue,\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "fe188162cf85bee0c694155f9abcc97057981e88", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -72,7 +72,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n-use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n+use rustc_trait_selection::traits::{self, misc::type_allowed_to_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -709,12 +709,14 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n \n         // We shouldn't recommend implementing `Copy` on stateful things,\n         // such as iterators.\n-        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator) {\n-            if cx.tcx.infer_ctxt().build().type_implements_trait(iter_trait, [ty], param_env)\n-                == EvaluationResult::EvaluatedToOk\n-            {\n-                return;\n-            }\n+        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator)\n+            && cx.tcx\n+                .infer_ctxt()\n+                .build()\n+                .type_implements_trait(iter_trait, [ty], param_env)\n+                .must_apply_modulo_regions()\n+        {\n+            return;\n         }\n \n         // Default value of clippy::trivially_copy_pass_by_ref\n@@ -726,7 +728,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             }\n         }\n \n-        if can_type_implement_copy(\n+        if type_allowed_to_implement_copy(\n             cx.tcx,\n             param_env,\n             ty,"}, {"sha": "a41a601f2db076a700bdb32b787a202268f2a914", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -1,29 +1,36 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause};\n \n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n+use rustc_infer::{infer::outlives::env::OutlivesEnvironment, traits::FulfillmentError};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n \n-use crate::traits::error_reporting::TypeErrCtxtExt;\n+use super::outlives_bounds::InferCtxtExt;\n \n-#[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n-    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>)>),\n+    InfrigingFields(Vec<(&'tcx ty::FieldDef, Ty<'tcx>, InfringingFieldsReason<'tcx>)>),\n     NotAnAdt,\n     HasDestructor,\n }\n \n-pub fn can_type_implement_copy<'tcx>(\n+pub enum InfringingFieldsReason<'tcx> {\n+    Fulfill(Vec<FulfillmentError<'tcx>>),\n+    Regions(Vec<RegionResolutionError<'tcx>>),\n+}\n+\n+/// Checks that the fields of the type (an ADT) all implement copy.\n+///\n+/// If fields don't implement copy, return an error containing a list of\n+/// those violating fields. If it's not an ADT, returns `Err(NotAnAdt)`.\n+pub fn type_allowed_to_implement_copy<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     self_type: Ty<'tcx>,\n     parent_cause: ObligationCause<'tcx>,\n ) -> Result<(), CopyImplementationError<'tcx>> {\n-    // FIXME: (@jroesch) float this code up\n-    let infcx = tcx.infer_ctxt().build();\n     let (adt, substs) = match self_type.kind() {\n         // These types used to have a builtin impl.\n         // Now libcore provides that impl.\n@@ -42,42 +49,82 @@ pub fn can_type_implement_copy<'tcx>(\n         _ => return Err(CopyImplementationError::NotAnAdt),\n     };\n \n+    let copy_def_id = tcx.require_lang_item(hir::LangItem::Copy, Some(parent_cause.span));\n+\n     let mut infringing = Vec::new();\n     for variant in adt.variants() {\n         for field in &variant.fields {\n-            let ty = field.ty(tcx, substs);\n-            if ty.references_error() {\n+            // Do this per-field to get better error messages.\n+            let infcx = tcx.infer_ctxt().build();\n+            let ocx = traits::ObligationCtxt::new(&infcx);\n+\n+            let unnormalized_ty = field.ty(tcx, substs);\n+            if unnormalized_ty.references_error() {\n                 continue;\n             }\n-            let span = tcx.def_span(field.did);\n+\n+            let field_span = tcx.def_span(field.did);\n+            let field_ty_span = match tcx.hir().get_if_local(field.did) {\n+                Some(hir::Node::Field(field_def)) => field_def.ty.span,\n+                _ => field_span,\n+            };\n+\n             // FIXME(compiler-errors): This gives us better spans for bad\n             // projection types like in issue-50480.\n             // If the ADT has substs, point to the cause we are given.\n             // If it does not, then this field probably doesn't normalize\n             // to begin with, and point to the bad field's span instead.\n-            let cause = if field\n+            let normalization_cause = if field\n                 .ty(tcx, traits::InternalSubsts::identity_for_item(tcx, adt.did()))\n                 .has_non_region_param()\n             {\n                 parent_cause.clone()\n             } else {\n-                ObligationCause::dummy_with_span(span)\n-            };\n-            match traits::fully_normalize(&infcx, cause, param_env, ty) {\n-                Ok(ty) => {\n-                    if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n-                        infringing.push((field, ty));\n-                    }\n-                }\n-                Err(errors) => {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-                }\n+                ObligationCause::dummy_with_span(field_ty_span)\n             };\n+            let ty = ocx.normalize(&normalization_cause, param_env, unnormalized_ty);\n+            let normalization_errors = ocx.select_where_possible();\n+            if !normalization_errors.is_empty() {\n+                tcx.sess.delay_span_bug(field_span, format!(\"couldn't normalize struct field `{unnormalized_ty}` when checking Copy implementation\"));\n+                continue;\n+            }\n+\n+            ocx.register_bound(\n+                ObligationCause::dummy_with_span(field_ty_span),\n+                param_env,\n+                ty,\n+                copy_def_id,\n+            );\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infringing.push((field, ty, InfringingFieldsReason::Fulfill(errors)));\n+            }\n+\n+            // Check regions assuming the self type of the impl is WF\n+            let outlives_env = OutlivesEnvironment::with_bounds(\n+                param_env,\n+                Some(&infcx),\n+                infcx.implied_bounds_tys(\n+                    param_env,\n+                    parent_cause.body_id,\n+                    FxIndexSet::from_iter([self_type]),\n+                ),\n+            );\n+            infcx.process_registered_region_obligations(\n+                outlives_env.region_bound_pairs(),\n+                param_env,\n+            );\n+            let errors = infcx.resolve_regions(&outlives_env);\n+            if !errors.is_empty() {\n+                infringing.push((field, ty, InfringingFieldsReason::Regions(errors)));\n+            }\n         }\n     }\n+\n     if !infringing.is_empty() {\n         return Err(CopyImplementationError::InfrigingFields(infringing));\n     }\n+\n     if adt.has_dtor(tcx) {\n         return Err(CopyImplementationError::HasDestructor);\n     }"}, {"sha": "8c9d4c5cfe66fae84961b8ab9020b7313adc2bd3", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -24,7 +24,7 @@ use rustc_span::symbol::kw;\n use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::misc::can_type_implement_copy;\n+use rustc_trait_selection::traits::misc::type_allowed_to_implement_copy;\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -200,7 +200,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                     let sugg = |diag: &mut Diagnostic| {\n                         if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did()) {\n-                                if can_type_implement_copy(\n+                                if type_allowed_to_implement_copy(\n                                     cx.tcx,\n                                     cx.param_env,\n                                     ty,"}, {"sha": "86c511c0895670325eede43ff595e3db6e964e50", "filename": "tests/ui/traits/copy-impl-cannot-normalize.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-impl-cannot-normalize.stderr?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -4,6 +4,16 @@ error[E0277]: the trait bound `T: TraitFoo` is not satisfied\n LL | impl<T> Copy for Foo<T> {}\n    |                  ^^^^^^ the trait `TraitFoo` is not implemented for `T`\n    |\n+note: required for `Foo<T>` to implement `Clone`\n+  --> $DIR/copy-impl-cannot-normalize.rs:12:9\n+   |\n+LL | impl<T> Clone for Foo<T>\n+   |         ^^^^^     ^^^^^^\n+LL | where\n+LL |     T: TraitFoo,\n+   |        -------- unsatisfied trait bound introduced here\n+note: required by a bound in `Copy`\n+  --> $SRC_DIR/core/src/marker.rs:LL:COL\n help: consider restricting type parameter `T`\n    |\n LL | impl<T: TraitFoo> Copy for Foo<T> {}"}, {"sha": "edd94d2010b966ce358d77bb0f03911d90fdcaa6", "filename": "tests/ui/traits/copy-is-not-modulo-regions.not_static.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.not_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.not_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.not_static.stderr?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -0,0 +1,22 @@\n+error[E0204]: the trait `Copy` may not be implemented for this type\n+  --> $DIR/copy-is-not-modulo-regions.rs:13:21\n+   |\n+LL | struct Bar<'lt>(Foo<'lt>);\n+   |                 -------- this field does not implement `Copy`\n+...\n+LL | impl<'any> Copy for Bar<'any> {}\n+   |                     ^^^^^^^^^\n+   |\n+note: the `Copy` impl for `Foo<'any>` requires that `'any: 'static`\n+  --> $DIR/copy-is-not-modulo-regions.rs:10:17\n+   |\n+LL | struct Bar<'lt>(Foo<'lt>);\n+   |                 ^^^^^^^^\n+help: consider restricting type parameter `'any`\n+   |\n+LL | impl<'any: 'static> Copy for Bar<'any> {}\n+   |          +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0204`."}, {"sha": "adb8702376977697ec6fded585c425e43838330a", "filename": "tests/ui/traits/copy-is-not-modulo-regions.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-is-not-modulo-regions.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -0,0 +1,19 @@\n+// revisions: not_static yes_static\n+//[yes_static] check-pass\n+\n+#[derive(Clone)]\n+struct Foo<'lt>(&'lt ());\n+\n+impl Copy for Foo<'static> {}\n+\n+#[derive(Clone)]\n+struct Bar<'lt>(Foo<'lt>);\n+\n+#[cfg(not_static)]\n+impl<'any> Copy for Bar<'any> {}\n+//[not_static]~^ the trait `Copy` may not be implemented for this type\n+\n+#[cfg(yes_static)]\n+impl<'any> Copy for Bar<'static> {}\n+\n+fn main() {}"}, {"sha": "9abfdfab9d06da63ae4a30a43b48b13fc445b7a5", "filename": "tests/ui/traits/copy-requires-self-wf.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-requires-self-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fcopy-requires-self-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-requires-self-wf.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#[derive(Clone)]\n+struct A<'a, T>(&'a T);\n+\n+impl<'a, T: Copy + 'a> Copy for A<'a, T> {}\n+\n+#[derive(Clone)]\n+struct B<'a, T>(A<'a, T>);\n+\n+// `T: '_` should be implied by `WF(B<'_, T>)`.\n+impl<T: Copy> Copy for B<'_, T> {}\n+\n+fn main() {}"}, {"sha": "005939e0c46e4d39093d411cfaa3a832cdaa9545", "filename": "tests/ui/traits/issue-50480.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fissue-50480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fissue-50480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-50480.rs?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -5,13 +5,11 @@ struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n //~| ERROR cannot find type `NotDefined` in this scope\n //~| ERROR cannot find type `N` in this scope\n //~| ERROR cannot find type `N` in this scope\n-//~| ERROR `i32` is not an iterator\n \n #[derive(Clone, Copy)]\n //~^ ERROR the trait `Copy` may not be implemented for this type\n struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n //~^ ERROR cannot find type `NotDefined` in this scope\n //~| ERROR cannot find type `N` in this scope\n-//~| ERROR `i32` is not an iterator\n \n fn main() {}"}, {"sha": "5063fdca092731aeb154a9b66a55cff4b94006bb", "filename": "tests/ui/traits/issue-50480.stderr", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fissue-50480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94a300b9b8eb253c1b809fc44b8c213fd591c537/tests%2Fui%2Ftraits%2Fissue-50480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fissue-50480.stderr?ref=94a300b9b8eb253c1b809fc44b8c213fd591c537", "patch": "@@ -38,7 +38,7 @@ LL | struct Foo<NotDefined>(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, St\n    |           ++++++++++++\n \n error[E0412]: cannot find type `N` in this scope\n-  --> $DIR/issue-50480.rs:12:18\n+  --> $DIR/issue-50480.rs:11:18\n    |\n LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n    |            -     ^\n@@ -55,20 +55,11 @@ LL | struct Bar<T, N>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, Strin\n    |             +++\n \n error[E0412]: cannot find type `NotDefined` in this scope\n-  --> $DIR/issue-50480.rs:12:21\n+  --> $DIR/issue-50480.rs:11:21\n    |\n LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n    |                     ^^^^^^^^^^ not found in this scope\n \n-error[E0277]: `i32` is not an iterator\n-  --> $DIR/issue-50480.rs:3:27\n-   |\n-LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator\n-   |\n-   = help: the trait `Iterator` is not implemented for `i32`\n-   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n-\n error[E0204]: the trait `Copy` may not be implemented for this type\n   --> $DIR/issue-50480.rs:1:17\n    |\n@@ -82,17 +73,8 @@ LL | struct Foo(N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0277]: `i32` is not an iterator\n-  --> $DIR/issue-50480.rs:12:33\n-   |\n-LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ `i32` is not an iterator\n-   |\n-   = help: the trait `Iterator` is not implemented for `i32`\n-   = note: if you want to iterate between `start` until a value `end`, use the exclusive range syntax `start..end` or the inclusive range syntax `start..=end`\n-\n error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/issue-50480.rs:10:17\n+  --> $DIR/issue-50480.rs:9:17\n    |\n LL | #[derive(Clone, Copy)]\n    |                 ^^^^\n@@ -104,7 +86,7 @@ LL | struct Bar<T>(T, N, NotDefined, <i32 as Iterator>::Item, Vec<i32>, String);\n    |\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 8 previous errors\n \n-Some errors have detailed explanations: E0204, E0277, E0412.\n+Some errors have detailed explanations: E0204, E0412.\n For more information about an error, try `rustc --explain E0204`."}]}