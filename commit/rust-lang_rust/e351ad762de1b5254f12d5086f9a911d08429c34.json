{"sha": "e351ad762de1b5254f12d5086f9a911d08429c34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNTFhZDc2MmRlMWI1MjU0ZjEyZDUwODZmOWE5MTFkMDg0MjljMzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-04T03:25:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-04T03:25:44Z"}, "message": "rt: Stub shape glue and implement shape::print and shape::size_of.", "tree": {"sha": "6f86da26d2b398ce43b6316f6405f59c113bf94d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f86da26d2b398ce43b6316f6405f59c113bf94d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e351ad762de1b5254f12d5086f9a911d08429c34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e351ad762de1b5254f12d5086f9a911d08429c34", "html_url": "https://github.com/rust-lang/rust/commit/e351ad762de1b5254f12d5086f9a911d08429c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e351ad762de1b5254f12d5086f9a911d08429c34/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b1d8e7b91b2baab1a803e5ac853198eb275ffc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b1d8e7b91b2baab1a803e5ac853198eb275ffc1", "html_url": "https://github.com/rust-lang/rust/commit/1b1d8e7b91b2baab1a803e5ac853198eb275ffc1"}], "stats": {"total": 706, "additions": 706, "deletions": 0}, "files": [{"sha": "532483cdf31a60b9fae87c10d3889b7c267077a3", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e351ad762de1b5254f12d5086f9a911d08429c34/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e351ad762de1b5254f12d5086f9a911d08429c34/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=e351ad762de1b5254f12d5086f9a911d08429c34", "patch": "@@ -23,6 +23,7 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/isaac/randport.cpp \\\n               rt/rust_srv.cpp \\\n               rt/rust_kernel.cpp \\\n+              rt/rust_shape.cpp \\\n               rt/memory_region.cpp \\\n               rt/test/rust_test_harness.cpp \\\n               rt/test/rust_test_runtime.cpp \\"}, {"sha": "b13848df0954eb138eb049c12ff67a56fdb3f353", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e351ad762de1b5254f12d5086f9a911d08429c34/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/e351ad762de1b5254f12d5086f9a911d08429c34/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=e351ad762de1b5254f12d5086f9a911d08429c34", "patch": "@@ -251,6 +251,10 @@ typedef void CDECL (cmp_glue_fn)(void *, rust_task *, void *,\n                                  const type_desc **,\n                                  void *, void *, int8_t);\n \n+struct rust_shape_tables {\n+    uint8_t *tags;\n+    uint8_t *resources;\n+};\n \n struct type_desc {\n     // First part of type_desc is known to compiler.\n@@ -266,6 +270,9 @@ struct type_desc {\n     glue_fn *obj_drop_glue; // For custom destructors.\n     uintptr_t is_stateful;\n     cmp_glue_fn *cmp_glue;\n+    const uint8_t *shape;\n+    const rust_shape_tables *shape_tables;\n+    uint32_t n_params;\n \n     // Residual fields past here are known only to runtime.\n     UT_hash_handle hh;"}, {"sha": "9f469aa9d96d61e7d05df6ae389fdfb7ad973875", "filename": "src/rt/rust_shape.cpp", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/rust-lang/rust/blob/e351ad762de1b5254f12d5086f9a911d08429c34/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e351ad762de1b5254f12d5086f9a911d08429c34/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=e351ad762de1b5254f12d5086f9a911d08429c34", "patch": "@@ -0,0 +1,698 @@\n+// Functions that interpret the shape of a type to perform various low-level\n+// actions, such as copying, freeing, comparing, and so on.\n+\n+#include <algorithm>\n+#include <utility>\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include \"rust_internal.h\"\n+\n+#define ARENA_SIZE          256\n+\n+#define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n+#define DPRINTCX(cx)        print::print_cx(cx)\n+\n+//#define DPRINT(fmt,...)\n+//#define DPRINTCX(cx)\n+\n+#ifdef _MSC_VER\n+#define ALIGNOF     __alignof\n+#else\n+#define ALIGNOF     __alignof__\n+#endif\n+\n+namespace shape {\n+\n+using namespace shape;\n+\n+// Forward declarations\n+\n+struct rust_obj;\n+struct size_align;\n+struct type_param;\n+\n+\n+// Constants\n+\n+const uint8_t SHAPE_U8 = 0u;\n+const uint8_t SHAPE_U16 = 1u;\n+const uint8_t SHAPE_U32 = 2u;\n+const uint8_t SHAPE_U64 = 3u;\n+const uint8_t SHAPE_I8 = 4u;\n+const uint8_t SHAPE_I16 = 5u;\n+const uint8_t SHAPE_I32 = 6u;\n+const uint8_t SHAPE_I64 = 7u;\n+const uint8_t SHAPE_F32 = 8u;\n+const uint8_t SHAPE_F64 = 9u;\n+const uint8_t SHAPE_EVEC = 10u;\n+const uint8_t SHAPE_IVEC = 11u;\n+const uint8_t SHAPE_TAG = 12u;\n+const uint8_t SHAPE_BOX = 13u;\n+const uint8_t SHAPE_PORT = 14u;\n+const uint8_t SHAPE_CHAN = 15u;\n+const uint8_t SHAPE_TASK = 16u;\n+const uint8_t SHAPE_STRUCT = 17u;\n+const uint8_t SHAPE_FN = 18u;\n+const uint8_t SHAPE_OBJ = 19u;\n+const uint8_t SHAPE_RES = 20u;\n+const uint8_t SHAPE_VAR = 21u;\n+\n+const uint8_t CMP_EQ = 0u;\n+const uint8_t CMP_LT = 1u;\n+const uint8_t CMP_LE = 2u;\n+\n+\n+// Utility functions\n+\n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+template<typename T>\n+static inline T\n+round_up(T size, size_t alignment) {\n+    assert(alignment);\n+    T x = (T)(((uintptr_t)size + alignment - 1) & ~(alignment - 1));\n+    return x;\n+}\n+\n+\n+\n+// Contexts\n+\n+// The base context, an abstract class. We use the curiously recurring\n+// template pattern here to avoid virtual dispatch.\n+template<typename T>\n+class ctxt {\n+public:\n+    const uint8_t *sp;                  // shape pointer\n+    const type_param *params;           // shapes of type parameters\n+    const rust_shape_tables *tables;\n+    rust_task *task;\n+\n+    template<typename U>\n+    ctxt(const ctxt<U> &other,\n+         const uint8_t *in_sp = NULL,\n+         const type_param *in_params = NULL,\n+         const rust_shape_tables *in_tables = NULL)\n+    : sp(in_sp ? in_sp : other.sp),\n+      params(in_params ? in_params : other.params),\n+      tables(in_tables ? in_tables : other.tables),\n+      task(other.task) {}\n+\n+    void walk(bool align);\n+\n+protected:\n+    static inline uint16_t get_u16(const uint8_t *addr);\n+    static inline uint16_t get_u16_bump(const uint8_t *&addr);\n+    inline size_align get_size_align(const uint8_t *&addr);\n+\n+private:\n+    void walk_evec(bool align);\n+    void walk_ivec(bool align);\n+    void walk_tag(bool align);\n+    void walk_box(bool align);\n+    void walk_struct(bool align);\n+    void walk_res(bool align);\n+    void walk_var(bool align);\n+};\n+\n+\n+struct size_align {\n+    size_t size;\n+    size_t alignment;\n+\n+    size_align(size_t in_size = 0, size_t in_align = 1) :\n+        size(in_size), alignment(in_align) {}\n+\n+    bool is_set() const { return alignment != 0; }\n+\n+    inline void set(size_t in_size, size_t in_align) {\n+        size = in_size;\n+        alignment = in_align;\n+    }\n+\n+    inline void add(const size_align &other) {\n+        add(other.size, other.alignment);\n+    }\n+\n+    inline void add(size_t extra_size, size_t extra_align) {\n+        size += extra_size;\n+        alignment = max(alignment, extra_align);\n+    }\n+\n+    static inline size_align make(size_t in_size) {\n+        size_align sa;\n+        sa.size = sa.alignment = in_size;\n+        return sa;\n+    }\n+\n+    static inline size_align make(size_t in_size, size_t in_align) {\n+        size_align sa;\n+        sa.size = in_size;\n+        sa.alignment = in_align;\n+        return sa;\n+    }\n+};\n+\n+struct rust_fn {\n+    void (*code)(uint8_t *rv, rust_task *task, void *env, ...);\n+    void *env;\n+};\n+\n+struct rust_closure {\n+    type_desc *tydesc;\n+    uint32_t target_0;\n+    uint32_t target_1;\n+    uint32_t bindings[0];\n+\n+    uint8_t *get_bindings() const { return (uint8_t *)bindings; }\n+};\n+\n+struct rust_obj_box {\n+    type_desc *tydesc;\n+\n+    uint8_t *get_bindings() const { return (uint8_t *)this; }\n+};\n+\n+struct rust_vtable {\n+    CDECL void (*dtor)(void *rv, rust_task *task, rust_obj obj);\n+};\n+\n+struct rust_obj {\n+    rust_vtable *vtable;\n+    void *box;\n+};\n+\n+\n+// Arenas; these functions must execute very quickly, so we use an arena\n+// instead of malloc or new.\n+\n+class arena {\n+    uint8_t *ptr;\n+    uint8_t data[ARENA_SIZE];\n+\n+public:\n+    arena() : ptr(data) {}\n+\n+    template<typename T>\n+    inline T *alloc(size_t count = 1) {\n+        // FIXME: align\n+        size_t sz = count * sizeof(T);\n+        //DPRINT(\"size is %lu\\n\", sz);\n+        T *rv = (T *)ptr;\n+        ptr += sz;\n+        if (ptr > &data[ARENA_SIZE]) {\n+            fprintf(stderr, \"Arena space exhausted, sorry\\n\");\n+            abort();\n+        }\n+        return rv;\n+    }\n+};\n+\n+\n+// Type parameters\n+\n+struct type_param {\n+    const uint8_t *shape;\n+    const rust_shape_tables *tables;\n+    const struct type_param *params;    // subparameters\n+\n+    template<typename T>\n+    inline void set(ctxt<T> *cx) {\n+        shape = cx->sp;\n+        tables = cx->tables;\n+        params = cx->params;\n+    }\n+\n+    static type_param *make(const type_desc *tydesc, arena &arena) {\n+        uint32_t n_params = tydesc->n_params;\n+        if (!n_params)\n+            return NULL;\n+\n+        type_param *ptrs = arena.alloc<type_param>(n_params);\n+        for (int i = 0; i < n_params; i++) {\n+            const type_desc *subtydesc = tydesc->first_param[i];\n+            ptrs[i].shape = subtydesc->shape;\n+            ptrs[i].tables = subtydesc->shape_tables;\n+            ptrs[i].params = make(subtydesc, arena);\n+        }\n+        return ptrs;\n+    }\n+};\n+\n+\n+// Traversals\n+\n+#define WALK_NUMBER(c_type) \\\n+    static_cast<T *>(this)->template walk_number<c_type>(align)\n+#define WALK_SIMPLE(method) static_cast<T *>(this)->method(align)\n+\n+template<typename T>\n+void\n+ctxt<T>::walk(bool align) {\n+    switch (*sp++) {\n+    case SHAPE_U8:      WALK_NUMBER(uint8_t);   break;\n+    case SHAPE_U16:     WALK_NUMBER(uint16_t);  break;\n+    case SHAPE_U32:     WALK_NUMBER(uint32_t);  break;\n+    case SHAPE_U64:     WALK_NUMBER(uint64_t);  break;\n+    case SHAPE_I8:      WALK_NUMBER(int8_t);    break;\n+    case SHAPE_I16:     WALK_NUMBER(int16_t);   break;\n+    case SHAPE_I32:     WALK_NUMBER(int32_t);   break;\n+    case SHAPE_I64:     WALK_NUMBER(int64_t);   break;\n+    case SHAPE_F32:     WALK_NUMBER(float);     break;\n+    case SHAPE_F64:     WALK_NUMBER(double);    break;\n+    case SHAPE_EVEC:    walk_evec(align);       break;\n+    case SHAPE_IVEC:    walk_ivec(align);       break;\n+    case SHAPE_TAG:     walk_tag(align);        break;\n+    case SHAPE_BOX:     walk_box(align);        break;\n+    case SHAPE_PORT:    WALK_SIMPLE(walk_port); break;\n+    case SHAPE_CHAN:    WALK_SIMPLE(walk_chan); break;\n+    case SHAPE_TASK:    WALK_SIMPLE(walk_task); break;\n+    case SHAPE_STRUCT:  walk_struct(align);     break;\n+    case SHAPE_FN:      WALK_SIMPLE(walk_fn);   break;\n+    case SHAPE_OBJ:     WALK_SIMPLE(walk_obj);  break;\n+    case SHAPE_RES:     walk_res(align);        break;\n+    case SHAPE_VAR:     walk_var(align);        break;\n+    default:            abort();\n+    }\n+}\n+\n+template<typename T>\n+uint16_t\n+ctxt<T>::get_u16(const uint8_t *addr) {\n+    return *reinterpret_cast<const uint16_t *>(addr);\n+}\n+\n+template<typename T>\n+uint16_t\n+ctxt<T>::get_u16_bump(const uint8_t *&addr) {\n+    uint16_t result = get_u16(addr);\n+    addr += sizeof(uint16_t);\n+    return result;\n+}\n+\n+template<typename T>\n+size_align\n+ctxt<T>::get_size_align(const uint8_t *&addr) {\n+    size_align result;\n+    result.size = get_u16_bump(addr);\n+    result.alignment = *addr++;\n+    return result;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_evec(bool align) {\n+    bool is_pod = *sp++;\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_evec(align, is_pod, sp_size);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_ivec(bool align) {\n+    bool is_pod = *sp++;\n+    size_align elem_sa = get_size_align(sp);\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    // FIXME: Hack to work around our incorrect alignment in some cases.\n+    if (elem_sa.alignment == 8)\n+        elem_sa.alignment = 4;\n+\n+    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_tag(bool align) {\n+    uint16_t tag_id = get_u16_bump(sp);\n+\n+    // Determine the info pointer.\n+    uint16_t info_offset = get_u16(tables->tags + tag_id * sizeof(uint16_t));\n+    const uint8_t *info_ptr = tables->tags + info_offset;\n+\n+    uint16_t variant_count = get_u16_bump(info_ptr);\n+\n+    // Determine the largest-variants pointer.\n+    uint16_t largest_variants_offset = get_u16_bump(info_ptr);\n+    const uint8_t *largest_variants_ptr =\n+        tables->tags + largest_variants_offset;\n+\n+    // Determine the size and alignment.\n+    size_align tag_sa = get_size_align(info_ptr);\n+\n+    // Determine the number of parameters.\n+    uint16_t n_params = get_u16_bump(sp);\n+\n+    // Read in the tag type parameters.\n+    type_param params[n_params];\n+    for (uint16_t i = 0; i < n_params; i++) {\n+        uint16_t len = get_u16_bump(sp);\n+        params[i].set(this);\n+        sp += len;\n+    }\n+\n+    // Call to the implementation.\n+    static_cast<T *>(this)->walk_tag(align, tag_id, info_ptr, variant_count,\n+                                     largest_variants_ptr, tag_sa, n_params,\n+                                     params);\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_box(bool align) {\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_box(align);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_struct(bool align) {\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_struct(align, end_sp);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_res(bool align) {\n+    uint16_t dtor_offset = get_u16_bump(sp);\n+    const rust_fn **resources =\n+        reinterpret_cast<const rust_fn **>(tables->resources);\n+    const rust_fn *dtor = resources[dtor_offset];\n+\n+    uint16_t n_ty_params = get_u16_bump(sp);\n+\n+    uint16_t ty_params_size = get_u16_bump(sp);\n+    const uint8_t *ty_params_sp = sp;\n+    sp += ty_params_size;\n+\n+    uint16_t sp_size = get_u16_bump(sp);\n+    const uint8_t *end_sp = sp + sp_size;\n+\n+    static_cast<T *>(this)->walk_res(align, dtor, n_ty_params, ty_params_sp);\n+\n+    sp = end_sp;\n+}\n+\n+template<typename T>\n+void\n+ctxt<T>::walk_var(bool align) {\n+    uint8_t param = *sp++;\n+    static_cast<T *>(this)->walk_var(align, param);\n+}\n+\n+\n+// A shape printer, useful for debugging\n+\n+class print : public ctxt<print> {\n+public:\n+    template<typename T>\n+    print(const ctxt<T> &other,\n+          const uint8_t *in_sp = NULL,\n+          const type_param *in_params = NULL,\n+          const rust_shape_tables *in_tables = NULL)\n+    : ctxt<print>(other, in_sp, in_params, in_tables) {}\n+\n+    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n+                  size_align &tag_sa, uint16_t n_params,\n+                  const type_param *params);\n+    void walk_struct(bool align, const uint8_t *end_sp);\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp);\n+    void walk_var(bool align, uint8_t param);\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        DPRINT(\"evec<\"); walk(align); DPRINT(\">\");\n+    }\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+        DPRINT(\"ivec<\"); walk(align); DPRINT(\">\");\n+    }\n+    void walk_box(bool align) {\n+        DPRINT(\"box<\"); walk(align); DPRINT(\">\");\n+    }\n+\n+    void walk_port(bool align)                  { DPRINT(\"port\"); }\n+    void walk_chan(bool align)                  { DPRINT(\"chan\"); }\n+    void walk_task(bool align)                  { DPRINT(\"task\"); }\n+    void walk_fn(bool align)                    { DPRINT(\"fn\");   }\n+    void walk_obj(bool align)                   { DPRINT(\"obj\");  }\n+\n+    template<typename T>\n+    void walk_number(bool align) {}\n+\n+    template<typename T>\n+    static void print_cx(const T *cx) {\n+        print self(*cx);\n+        self.walk(false);\n+    }\n+};\n+\n+void\n+print::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                uint16_t variant_count, const uint8_t *largest_variants_ptr,\n+                size_align &tag_sa, uint16_t n_params,\n+                const type_param *params) {\n+    DPRINT(\"tag%u\", tag_id);\n+    if (!n_params)\n+        return;\n+\n+    DPRINT(\"<\");\n+\n+    bool first = true;\n+    for (uint16_t i = 0; i < n_params; i++) {\n+        if (!first)\n+            DPRINT(\",\");\n+        first = false;\n+\n+        ctxt<print> sub(*this, params[i].shape);\n+        sub.walk(align);\n+    }\n+\n+    DPRINT(\">\");\n+}\n+\n+void\n+print::walk_struct(bool align, const uint8_t *end_sp) {\n+    DPRINT(\"(\");\n+\n+    bool first = true;\n+    while (sp != end_sp) {\n+        if (!first)\n+            DPRINT(\",\");\n+        first = false;\n+\n+        walk(align);\n+    }\n+\n+    DPRINT(\")\");\n+}\n+\n+void\n+print::walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                const uint8_t *ty_params_sp) {\n+    DPRINT(\"res@%p\", dtor);\n+    if (!n_ty_params)\n+        return;\n+\n+    DPRINT(\"<\");\n+\n+    bool first = true;\n+    for (uint16_t i = 0; i < n_ty_params; i++) {\n+        if (!first)\n+            DPRINT(\",\");\n+        first = false;\n+        get_u16_bump(sp);   // Skip over the size.\n+        walk(align);\n+    }\n+\n+    DPRINT(\">\");\n+}\n+\n+void\n+print::walk_var(bool align, uint8_t param_index) {\n+    DPRINT(\"%c=\", 'T' + param_index);\n+\n+    const type_param *param = &params[param_index];\n+    print sub(*this, param->shape, param->params, param->tables);\n+    sub.walk(align);\n+}\n+\n+template<>\n+void print::walk_number<uint8_t>(bool align)    { DPRINT(\"u8\"); }\n+template<>\n+void print::walk_number<uint16_t>(bool align)   { DPRINT(\"u16\"); }\n+template<>\n+void print::walk_number<uint32_t>(bool align)   { DPRINT(\"u32\"); }\n+template<>\n+void print::walk_number<uint64_t>(bool align)   { DPRINT(\"u64\"); }\n+template<>\n+void print::walk_number<int8_t>(bool align)     { DPRINT(\"i8\"); }\n+template<>\n+void print::walk_number<int16_t>(bool align)    { DPRINT(\"i16\"); }\n+template<>\n+void print::walk_number<int32_t>(bool align)    { DPRINT(\"i32\"); }\n+template<>\n+void print::walk_number<int64_t>(bool align)    { DPRINT(\"i64\"); }\n+template<>\n+void print::walk_number<float>(bool align)      { DPRINT(\"f32\"); }\n+template<>\n+void print::walk_number<double>(bool align)     { DPRINT(\"f64\"); }\n+\n+\n+//\n+// Size-of (which also computes alignment). Be warned: this is an expensive\n+// operation.\n+//\n+// TODO: Maybe dynamic_size_of() should call into this somehow?\n+//\n+\n+class size_of : public ctxt<size_of> {\n+private:\n+    size_align sa;\n+\n+public:\n+    size_of(const size_of &other,\n+            const uint8_t *in_sp,\n+            const type_param *in_params,\n+            const rust_shape_tables *in_tables)\n+    : ctxt<size_of>(other, in_sp, in_params, in_tables) {}\n+\n+    void walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n+                  size_align &tag_sa, uint16_t n_params,\n+                  const type_param *params);\n+    void walk_struct(bool align, const uint8_t *end_sp);\n+    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n+\n+    void walk_box(bool align)   { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_port(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_chan(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_task(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n+    void walk_fn(bool align)    { sa.set(sizeof(void *)*2, sizeof(void *)); }\n+    void walk_obj(bool align)   { sa.set(sizeof(void *)*2, sizeof(void *)); }\n+\n+    void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n+        sa.set(sizeof(void *), sizeof(void *));\n+    }\n+\n+    void walk_var(bool align, uint8_t param_index) {\n+        const type_param *param = &params[param_index];\n+        size_of sub(*this, param->shape, param->params, param->tables);\n+        sub.walk(align);\n+        sa = sub.sa;\n+    }\n+\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp) {\n+        abort();    // TODO\n+    }\n+\n+    template<typename T>\n+    void walk_number(bool align) { sa.set(sizeof(T), ALIGNOF(T)); }\n+\n+    template<typename T>\n+    static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n+        size_of cx(*other_cx, other_cx->sp - back_up);\n+        cx.walk(false);\n+        assert(cx.sa.alignment > 0);\n+        return cx.sa;\n+    }\n+};\n+\n+void\n+size_of::walk_tag(bool align, uint16_t tag_id, const uint8_t *info_ptr,\n+                  uint16_t variant_count, const uint8_t *largest_variants_ptr,\n+                  size_align &tag_sa, uint16_t n_params,\n+                  const type_param *params) {\n+    // If the precalculated size and alignment are good, use them.\n+    if (tag_sa.is_set()) {\n+        sa = tag_sa;\n+        return;\n+    }\n+\n+    uint16_t n_largest_variants = get_u16_bump(largest_variants_ptr);\n+    sa.set(0, 0);\n+    for (uint16_t i = 0; i < n_largest_variants; i++) {\n+        uint16_t variant_id = get_u16_bump(largest_variants_ptr);\n+        uint16_t variant_offset = get_u16(info_ptr +\n+                                          variant_id * sizeof(uint16_t));\n+        const uint8_t *variant_ptr = tables->tags + variant_offset;\n+\n+        uint16_t variant_len = get_u16_bump(variant_ptr);\n+        const uint8_t *variant_end = variant_ptr + variant_len;\n+\n+        size_of sub(*this, variant_ptr, params, NULL);\n+\n+        // Compute the size of this variant.\n+        size_align variant_sa;\n+        bool first = true;\n+        while (sub.sp != variant_end) {\n+            if (!first)\n+                variant_sa.size = round_up(variant_sa.size, sub.sa.alignment);\n+            sub.walk(!first);\n+            first = false;\n+\n+            variant_sa.add(sub.sa.size, sub.sa.alignment);\n+        }\n+\n+        if (sa.size < variant_sa.size)\n+            sa = variant_sa;\n+    }\n+\n+    if (variant_count == 1) {\n+        if (!sa.size)\n+            sa.set(1, 1);\n+    } else {\n+        // Add in space for the tag.\n+        sa.add(sizeof(uint32_t), ALIGNOF(uint32_t));\n+    }\n+}\n+\n+void\n+size_of::walk_struct(bool align, const uint8_t *end_sp) {\n+    size_align struct_sa(0, 1);\n+\n+    bool first = true;\n+    while (sp != end_sp) {\n+        if (!first)\n+            struct_sa.size = round_up(struct_sa.size, sa.alignment);\n+        walk(!first);\n+        first = false;\n+\n+        struct_sa.add(sa);\n+    }\n+\n+    sa = struct_sa;\n+}\n+\n+void\n+size_of::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n+    if (!elem_sa.is_set())\n+        walk(align);    // Determine the size the slow way.\n+    else\n+        sa = elem_sa;   // Use the size hint.\n+\n+    sa.set(sizeof(rust_ivec) - sizeof(uintptr_t) + sa.size * 4,\n+           max(sa.alignment, sizeof(uintptr_t)));\n+}\n+\n+} // end namespace shape\n+"}]}