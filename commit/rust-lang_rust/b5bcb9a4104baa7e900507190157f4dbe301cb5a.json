{"sha": "b5bcb9a4104baa7e900507190157f4dbe301cb5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YmNiOWE0MTA0YmFhN2U5MDA1MDcxOTAxNTdmNGRiZTMwMWNiNWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-07T15:13:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-07T15:13:21Z"}, "message": "Merge branch 'incr_attr_queries' of https://github.com/wesleywiser/rust into update-cargo", "tree": {"sha": "3b716a1c516db6951e6fce3ac68d4fddc56bd454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b716a1c516db6951e6fce3ac68d4fddc56bd454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5bcb9a4104baa7e900507190157f4dbe301cb5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bcb9a4104baa7e900507190157f4dbe301cb5a", "html_url": "https://github.com/rust-lang/rust/commit/b5bcb9a4104baa7e900507190157f4dbe301cb5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5bcb9a4104baa7e900507190157f4dbe301cb5a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a5e9410148dd10586acd50e4e99b515b0e3111a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5e9410148dd10586acd50e4e99b515b0e3111a", "html_url": "https://github.com/rust-lang/rust/commit/5a5e9410148dd10586acd50e4e99b515b0e3111a"}, {"sha": "e0f752763ecfca5a81e7a100bbaa8e32f9c1ee57", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f752763ecfca5a81e7a100bbaa8e32f9c1ee57", "html_url": "https://github.com/rust-lang/rust/commit/e0f752763ecfca5a81e7a100bbaa8e32f9c1ee57"}], "stats": {"total": 850, "additions": 456, "deletions": 394}, "files": [{"sha": "ed46296389da4ba4f0ad96d6f5f83d3fca4183fe", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -559,6 +559,7 @@ define_dep_nodes!( <'tcx>\n     [] IsReachableNonGeneric(DefId),\n     [] IsMirAvailable(DefId),\n     [] ItemAttrs(DefId),\n+    [] TransFnAttrs(DefId),\n     [] FnArgNames(DefId),\n     [] DylibDepFormats(CrateNum),\n     [] IsPanicRuntime(CrateNum),\n@@ -626,8 +627,6 @@ define_dep_nodes!( <'tcx>\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),\n     [eval_always] CollectAndPartitionTranslationItems,\n-    [] ExportName(DefId),\n-    [] ContainsExternIndicator(DefId),\n     [] IsTranslatedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n@@ -637,7 +636,6 @@ define_dep_nodes!( <'tcx>\n     [] SubstituteNormalizeAndTestPredicates { key: (DefId, &'tcx Substs<'tcx>) },\n \n     [input] TargetFeaturesWhitelist,\n-    [] TargetFeaturesEnabled(DefId),\n \n     [] InstanceDefSizeEstimate { instance_def: InstanceDef<'tcx> },\n "}, {"sha": "d22703452605b6bb242a0b91d956ef22fe47d955", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -47,7 +47,7 @@ struct CheckAttrVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n     /// Check any attribute.\n     fn check_attributes(&self, item: &hir::Item, target: Target) {\n-        self.tcx.target_features_enabled(self.tcx.hir.local_def_id(item.id));\n+        self.tcx.trans_fn_attrs(self.tcx.hir.local_def_id(item.id));\n \n         for attr in &item.attrs {\n             if let Some(name) = attr.name() {"}, {"sha": "f4638c23c5f4bf35c721f6e8f7915e42064061fa", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -30,12 +30,14 @@ pub use self::Visibility::{Public, Inherited};\n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n+use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n+use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n@@ -2210,3 +2212,51 @@ pub type GlobMap = NodeMap<FxHashSet<Name>>;\n pub fn provide(providers: &mut Providers) {\n     providers.describe_def = map::describe_def;\n }\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Hash)]\n+pub struct TransFnAttrs {\n+    pub flags: TransFnAttrFlags,\n+    pub inline: InlineAttr,\n+    pub export_name: Option<Symbol>,\n+    pub target_features: Vec<Symbol>,\n+    pub linkage: Option<Linkage>,\n+}\n+\n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable)]\n+    pub struct TransFnAttrFlags: u8 {\n+        const COLD                      = 0b0000_0001;\n+        const ALLOCATOR                 = 0b0000_0010;\n+        const UNWIND                    = 0b0000_0100;\n+        const RUSTC_ALLOCATOR_NOUNWIND  = 0b0000_1000;\n+        const NAKED                     = 0b0001_0000;\n+        const NO_MANGLE                 = 0b0010_0000;\n+        const RUSTC_STD_INTERNAL_SYMBOL = 0b0100_0000;\n+    }\n+}\n+\n+impl TransFnAttrs {\n+    pub fn new() -> TransFnAttrs {\n+        TransFnAttrs {\n+            flags: TransFnAttrFlags::empty(),\n+            inline: InlineAttr::None,\n+            export_name: None,\n+            target_features: vec![],\n+            linkage: None,\n+        }\n+    }\n+\n+    /// True if `#[inline]` or `#[inline(always)]` is present.\n+    pub fn requests_inline(&self) -> bool {\n+        match self.inline {\n+            InlineAttr::Hint | InlineAttr::Always => true,\n+            InlineAttr::None | InlineAttr::Never => false,\n+        }\n+    }\n+\n+    /// True if `#[no_mangle]` or `#[export_name(...)]` is present.\n+    pub fn contains_extern_indicator(&self) -> bool {\n+        self.flags.contains(TransFnAttrFlags::NO_MANGLE) || self.export_name.is_some()\n+    }\n+}\n+"}, {"sha": "faad3f3563164e444e6d9fce75877ff8ce86025c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -19,6 +19,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use std::mem;\n use syntax::ast;\n+use syntax::attr;\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n     #[inline]\n@@ -1138,6 +1139,43 @@ impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n     }\n }\n \n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrs\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let hir::TransFnAttrs {\n+            flags,\n+            inline,\n+            export_name,\n+            ref target_features,\n+            linkage,\n+        } = *self;\n+\n+        flags.hash_stable(hcx, hasher);\n+        inline.hash_stable(hcx, hasher);\n+        export_name.hash_stable(hcx, hasher);\n+        target_features.hash_stable(hcx, hasher);\n+        linkage.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for hir::TransFnAttrFlags\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.bits().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'hir> HashStable<StableHashingContext<'hir>> for attr::InlineAttr {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(struct hir::Freevar {\n     def,"}, {"sha": "48a62c8c14d6969e00b20916ba05ecd55ee4c682", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -15,6 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n+use hir::TransFnAttrs;\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n@@ -43,8 +44,8 @@ fn generics_require_inlining(generics: &hir::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &hir::Item) -> bool {\n-    if attr::requests_inline(&item.attrs) {\n+fn item_might_be_inlined(item: &hir::Item, attrs: TransFnAttrs) -> bool {\n+    if attrs.requests_inline() {\n         return true\n     }\n \n@@ -60,14 +61,15 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_item: &hir::ImplItem,\n                                      impl_src: DefId) -> bool {\n-    if attr::requests_inline(&impl_item.attrs) ||\n+    let trans_fn_attrs = tcx.trans_fn_attrs(impl_item.hir_id.owner_def_id());\n+    if trans_fn_attrs.requests_inline() ||\n         generics_require_inlining(&impl_item.generics) {\n         return true\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n             Some(hir_map::NodeItem(item)) =>\n-                item_might_be_inlined(&item),\n+                item_might_be_inlined(&item, trans_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n         }\n@@ -160,7 +162,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.hir.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) => item_might_be_inlined(&item),\n+                    hir::ItemFn(..) =>\n+                        item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n@@ -176,8 +179,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n+                        let attrs = self.tcx.trans_fn_attrs(def_id);\n                         if generics_require_inlining(&impl_item.generics) ||\n-                                attr::requests_inline(&impl_item.attrs) {\n+                                attrs.requests_inline() {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -229,7 +233,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     false\n                 };\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n-                let is_extern = self.tcx.contains_extern_indicator(def_id);\n+                let is_extern = self.tcx.trans_fn_attrs(def_id).contains_extern_indicator();\n                 if reachable || is_extern {\n                     self.reachable_symbols.insert(search_item);\n                 }\n@@ -246,7 +250,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(.., body) => {\n-                        if item_might_be_inlined(&item) {\n+                        let def_id = self.tcx.hir.local_def_id(item.id);\n+                        if item_might_be_inlined(&item, self.tcx.trans_fn_attrs(def_id)) {\n                             self.visit_nested_body(body);\n                         }\n                     }"}, {"sha": "d8eac2b415989a698fd0f7a1cd74372fbb2698f2", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -73,7 +73,7 @@ pub struct CodegenUnit<'tcx> {\n     size_estimate: Option<usize>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,"}, {"sha": "a5f0abb9bc05c2348fccb8e4fb1b2cb4a29d2d82", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -96,7 +96,6 @@ impl<'tcx> InstanceDef<'tcx> {\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>\n     ) -> bool {\n-        use syntax::attr::requests_inline;\n         if self.is_inline(tcx) {\n             return true\n         }\n@@ -106,8 +105,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             // available to normal end-users.\n             return true\n         }\n-        requests_inline(&self.attrs(tcx)[..]) ||\n-            tcx.is_const_fn(self.def_id())\n+        let trans_fn_attrs = tcx.trans_fn_attrs(self.def_id());\n+        trans_fn_attrs.requests_inline() || tcx.is_const_fn(self.def_id())\n     }\n }\n "}, {"sha": "d880b022e2f18c90c981882b70a6b79d69bac763", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -687,8 +687,8 @@ impl_disk_cacheable_query!(borrowck, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(mir_borrowck, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(mir_const_qualif, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(check_match, |def_id| def_id.is_local());\n-impl_disk_cacheable_query!(contains_extern_indicator, |_| true);\n impl_disk_cacheable_query!(def_symbol_name, |_| true);\n impl_disk_cacheable_query!(type_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(predicates_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(used_trait_imports, |def_id| def_id.is_local());\n+impl_disk_cacheable_query!(trans_fn_attrs, |_| true);"}, {"sha": "43a71f1c0d367ab385449be5ecd9a546e202b7d4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -12,7 +12,7 @@ use dep_graph::{DepConstructor, DepNode};\n use errors::DiagnosticBuilder;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n-use hir::{self, TraitCandidate, ItemLocalId};\n+use hir::{self, TraitCandidate, ItemLocalId, TransFnAttrs};\n use hir::svh::Svh;\n use lint;\n use middle::borrowck::BorrowCheckResult;\n@@ -235,6 +235,7 @@ define_maps! { <'tcx>\n     [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n     [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n+    [] fn trans_fn_attrs: trans_fn_attrs(DefId) -> TransFnAttrs,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n@@ -362,8 +363,6 @@ define_maps! { <'tcx>\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),\n-    [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n-    [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n     [] fn symbol_export_level: GetSymbolExportLevel(DefId) -> SymbolExportLevel,\n     [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n@@ -385,7 +384,6 @@ define_maps! { <'tcx>\n \n     [] fn target_features_whitelist:\n         target_features_whitelist_node(CrateNum) -> Lrc<FxHashSet<String>>,\n-    [] fn target_features_enabled: TargetFeaturesEnabled(DefId) -> Lrc<Vec<String>>,\n \n     // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n     [] fn instance_def_size_estimate: instance_def_size_estimate_dep_node(ty::InstanceDef<'tcx>)\n@@ -403,6 +401,10 @@ fn features_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Features\n }\n \n+fn trans_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n+    DepConstructor::TransFnAttrs { 0: id }\n+}\n+\n fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }"}, {"sha": "b18837ff35aa81b86348e3b47567b0e38c68bea3", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -217,9 +217,9 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<mir_const_qualif, _>(tcx, enc, qri)?;\n                 encode_query_results::<def_symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<const_is_rvalue_promotable_to_static, _>(tcx, enc, qri)?;\n-                encode_query_results::<contains_extern_indicator, _>(tcx, enc, qri)?;\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n+                encode_query_results::<trans_fn_attrs, _>(tcx, enc, qri)?;\n             }\n \n             // Encode diagnostics"}, {"sha": "fcc69f3b2c39ee9e1acce9435222f15f768f432f", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -854,6 +854,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::IsReachableNonGeneric => { force!(is_reachable_non_generic, def_id!()); }\n         DepKind::IsMirAvailable => { force!(is_mir_available, def_id!()); }\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n+        DepKind::TransFnAttrs => { force!(trans_fn_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n         DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n         DepKind::IsPanicRuntime => { force!(is_panic_runtime, krate!()); }\n@@ -925,15 +926,10 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::CollectAndPartitionTranslationItems => {\n             force!(collect_and_partition_translation_items, LOCAL_CRATE);\n         }\n-        DepKind::ExportName => { force!(export_name, def_id!()); }\n-        DepKind::ContainsExternIndicator => {\n-            force!(contains_extern_indicator, def_id!());\n-        }\n         DepKind::IsTranslatedItem => { force!(is_translated_item, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }\n-        DepKind::TargetFeaturesEnabled => { force!(target_features_enabled, def_id!()); }\n \n         DepKind::GetSymbolExportLevel => { force!(symbol_export_level, def_id!()); }\n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n@@ -997,10 +993,10 @@ impl_load_from_cache!(\n     MirConstQualif => mir_const_qualif,\n     SymbolName => def_symbol_name,\n     ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n-    ContainsExternIndicator => contains_extern_indicator,\n     CheckMatch => check_match,\n     TypeOfItem => type_of,\n     GenericsOfItem => generics_of,\n     PredicatesOfItem => predicates_of,\n     UsedTraitImports => used_trait_imports,\n+    TransFnAttrs => trans_fn_attrs,\n );"}, {"sha": "830121b446fca3e565f0a5921f805dcbf9997289", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -832,7 +832,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n             let generics = self.tcx.generics_of(def_id);\n             let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n+            let needs_inline = types > 0 || tcx.trans_fn_attrs(def_id).requests_inline();\n             let is_const_fn = sig.constness == hir::Constness::Const;\n             let ast = if is_const_fn { Some(body) } else { None };\n             let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n@@ -1123,7 +1123,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n                     let has_tps = generics.ty_params().next().is_some();\n-                    let needs_inline = has_tps || attr::requests_inline(&item.attrs);\n+                    let needs_inline = has_tps || tcx.trans_fn_attrs(def_id).requests_inline();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {\n                         self.encode_optimized_mir(def_id)"}, {"sha": "0f512569adf9757f1bd07d1f7e35056105029c36", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -188,7 +188,7 @@\n //! this is not implemented however: a mono item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc::hir;\n+use rustc::hir::{self, TransFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc::hir::map as hir_map;\n@@ -211,8 +211,6 @@ use monomorphize::item::{MonoItemExt, DefPathBasedNames, InstantiationMode};\n \n use rustc_data_structures::bitvec::BitVector;\n \n-use syntax::attr;\n-\n use std::iter;\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n@@ -985,8 +983,8 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n             MonoItemCollectionMode::Lazy => {\n                 self.entry_fn == Some(def_id) ||\n                 self.tcx.is_reachable_non_generic(def_id) ||\n-                attr::contains_name(&self.tcx.get_attrs(def_id),\n-                                    \"rustc_std_internal_symbol\")\n+                self.tcx.trans_fn_attrs(def_id).flags.contains(\n+                    TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n             }\n         }\n     }"}, {"sha": "38b8ffc6b9c806f6a3b04197b80f575058b26856", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 4, "deletions": 45, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -21,41 +21,14 @@ use rustc::session::config::OptLevel;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use syntax::ast;\n-use syntax::attr::{self, InlineAttr};\n+use syntax::attr::InlineAttr;\n use std::fmt::{self, Write};\n use std::iter;\n use rustc::mir::mono::Linkage;\n use syntax_pos::symbol::Symbol;\n use syntax::codemap::Span;\n pub use rustc::mir::mono::MonoItem;\n \n-pub fn linkage_by_name(name: &str) -> Option<Linkage> {\n-    use rustc::mir::mono::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but whitelist them anyway and trust that\n-    // the user knows what s/he's doing. Who knows, unanticipated use cases\n-    // may pop up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Some(Appending),\n-        \"available_externally\" => Some(AvailableExternally),\n-        \"common\" => Some(Common),\n-        \"extern_weak\" => Some(ExternalWeak),\n-        \"external\" => Some(External),\n-        \"internal\" => Some(Internal),\n-        \"linkonce\" => Some(LinkOnceAny),\n-        \"linkonce_odr\" => Some(LinkOnceODR),\n-        \"private\" => Some(Private),\n-        \"weak\" => Some(WeakAny),\n-        \"weak_odr\" => Some(WeakODR),\n-        _ => None,\n-    }\n-}\n-\n /// Describes how a translation item will be instantiated in object files.\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum InstantiationMode {\n@@ -141,8 +114,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n                 // creating one copy of this `#[inline]` function which may\n                 // conflict with upstream crates as it could be an exported\n                 // symbol.\n-                let attrs = instance.def.attrs(tcx);\n-                match attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs) {\n+                match tcx.trans_fn_attrs(instance.def_id()).inline {\n                     InlineAttr::Always => InstantiationMode::LocalCopy,\n                     _ => {\n                         InstantiationMode::GloballyShared  { may_conflict: true }\n@@ -165,21 +137,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(..) => return None,\n         };\n \n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = linkage_by_name(&name.as_str()) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.hir.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n+        let trans_fn_attrs = tcx.trans_fn_attrs(def_id);\n+        trans_fn_attrs.linkage\n     }\n \n     /// Returns whether this instance is instantiable - whether it has no unsatisfied"}, {"sha": "64c702b99cdb3940350a841bef58b4717fa5ea70", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -11,6 +11,7 @@\n //! Inlining pass for MIR functions\n \n use rustc::hir;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::DefId;\n \n use rustc_data_structures::bitvec::BitVector;\n@@ -206,10 +207,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             return false;\n         }\n \n-        let attrs = tcx.get_attrs(callsite.callee);\n-        let hint = attr::find_inline_attr(None, &attrs[..]);\n+        let trans_fn_attrs = tcx.trans_fn_attrs(callsite.callee);\n \n-        let hinted = match hint {\n+        let hinted = match trans_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we\n             // need to check for first.\n@@ -239,7 +239,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         };\n \n         // Significantly lower the threshold for inlining cold functions\n-        if attr::contains_name(&attrs[..], \"cold\") {\n+        if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n             threshold /= 5;\n         }\n \n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             }\n         }\n \n-        if let attr::InlineAttr::Always = hint {\n+        if let attr::InlineAttr::Always = trans_fn_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n             true\n         } else {"}, {"sha": "d5ec8d1b5526256573cf69552de26dc754f878fd", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 31, "deletions": 108, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -11,19 +11,16 @@\n \n use std::ffi::{CStr, CString};\n \n-use rustc::hir::Unsafety;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::session::config::Sanitizer;\n-use rustc::ty::TyCtxt;\n use rustc::ty::maps::Providers;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n use llvm_util;\n pub use syntax::attr::{self, InlineAttr};\n-use syntax::ast;\n use context::CodegenCx;\n \n /// Mark LLVM function to use provided inline heuristic.\n@@ -102,31 +99,42 @@ pub fn set_probestack(cx: &CodegenCx, llfn: ValueRef) {\n /// Composite function which sets LLVM attributes for function depending on its AST (#[attribute])\n /// attributes.\n pub fn from_fn_attrs(cx: &CodegenCx, llfn: ValueRef, id: DefId) {\n-    use syntax::attr::*;\n-    let attrs = cx.tcx.get_attrs(id);\n-    inline(llfn, find_inline_attr(Some(cx.sess().diagnostic()), &attrs));\n+    let trans_fn_attrs = cx.tcx.trans_fn_attrs(id);\n+\n+    inline(llfn, trans_fn_attrs.inline);\n \n     set_frame_pointer_elimination(cx, llfn);\n     set_probestack(cx, llfn);\n \n-    for attr in attrs.iter() {\n-        if attr.check_name(\"cold\") {\n-            Attribute::Cold.apply_llfn(Function, llfn);\n-        } else if attr.check_name(\"naked\") {\n-            naked(llfn, true);\n-        } else if attr.check_name(\"allocator\") {\n-            Attribute::NoAlias.apply_llfn(\n-                llvm::AttributePlace::ReturnValue, llfn);\n-        } else if attr.check_name(\"unwind\") {\n-            unwind(llfn, true);\n-        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n-            unwind(llfn, false);\n-        }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::COLD) {\n+        Attribute::Cold.apply_llfn(Function, llfn);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::NAKED) {\n+        naked(llfn, true);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::ALLOCATOR) {\n+        Attribute::NoAlias.apply_llfn(\n+            llvm::AttributePlace::ReturnValue, llfn);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::UNWIND) {\n+        unwind(llfn, true);\n+    }\n+    if trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND) {\n+        unwind(llfn, false);\n     }\n \n-    let target_features = cx.tcx.target_features_enabled(id);\n-    if !target_features.is_empty() {\n-        let val = CString::new(target_features.join(\",\")).unwrap();\n+    let features =\n+        trans_fn_attrs.target_features\n+        .iter()\n+        .map(|f| {\n+            let feature = &*f.as_str();\n+            format!(\"+{}\", llvm_util::to_llvm_feature(cx.tcx.sess, feature))\n+        })\n+        .collect::<Vec<String>>()\n+        .join(\",\");\n+\n+    if !features.is_empty() {\n+        let val = CString::new(features).unwrap();\n         llvm::AddFunctionAttrStringValue(\n             llfn, llvm::AttributePlace::Function,\n             cstr(\"target-features\\0\"), &val);\n@@ -145,89 +153,4 @@ pub fn provide(providers: &mut Providers) {\n             .map(|c| c.to_string())\n             .collect())\n     };\n-\n-    providers.target_features_enabled = |tcx, id| {\n-        let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n-        let mut target_features = Vec::new();\n-        for attr in tcx.get_attrs(id).iter() {\n-            if !attr.check_name(\"target_feature\") {\n-                continue\n-            }\n-            if let Some(val) = attr.value_str() {\n-                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n-                    if !feat.is_empty() && !feat.contains('\\0') {\n-                        target_features.push(feat.to_string());\n-                    }\n-                }\n-                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n-                           eventually be removed, use \\\n-                           #[target_feature(enable = \\\"..\\\")] instead\";\n-                tcx.sess.span_warn(attr.span, &msg);\n-                continue\n-            }\n-\n-            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n-                let msg = \"#[target_feature(..)] can only be applied to \\\n-                           `unsafe` function\";\n-                tcx.sess.span_err(attr.span, msg);\n-            }\n-            from_target_feature(tcx, attr, &whitelist, &mut target_features);\n-        }\n-        Lrc::new(target_features)\n-    };\n-}\n-\n-fn from_target_feature(\n-    tcx: TyCtxt,\n-    attr: &ast::Attribute,\n-    whitelist: &FxHashSet<String>,\n-    target_features: &mut Vec<String>,\n-) {\n-    let list = match attr.meta_item_list() {\n-        Some(list) => list,\n-        None => {\n-            let msg = \"#[target_feature] attribute must be of the form \\\n-                       #[target_feature(..)]\";\n-            tcx.sess.span_err(attr.span, &msg);\n-            return\n-        }\n-    };\n-\n-    for item in list {\n-        if !item.check_name(\"enable\") {\n-            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n-                       currently\";\n-            tcx.sess.span_err(item.span, &msg);\n-            continue\n-        }\n-        let value = match item.value_str() {\n-            Some(list) => list,\n-            None => {\n-                let msg = \"#[target_feature] attribute must be of the form \\\n-                           #[target_feature(enable = \\\"..\\\")]\";\n-                tcx.sess.span_err(item.span, &msg);\n-                continue\n-            }\n-        };\n-        let value = value.as_str();\n-        for feature in value.split(',') {\n-            if whitelist.contains(feature) {\n-                let llvm_feature = llvm_util::to_llvm_feature(&tcx.sess, feature);\n-                target_features.push(format!(\"+{}\", llvm_feature));\n-                continue\n-            }\n-\n-            let msg = format!(\"the feature named `{}` is not valid for \\\n-                               this target\", feature);\n-            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n-\n-            if feature.starts_with(\"+\") {\n-                let valid = whitelist.contains(&feature[1..]);\n-                if valid {\n-                    err.help(\"consider removing the leading `+` in the feature name\");\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n }"}, {"sha": "fd79ae7435ed1b74857c187b5aaa5d8fcde9b661", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -13,6 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n+use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::exported_symbols::{SymbolExportLevel, ExportedSymbol, metadata_symbol_name};\n@@ -21,7 +22,6 @@ use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::maps::Providers;\n use rustc::util::nodemap::{FxHashMap, DefIdSet};\n use rustc_allocator::ALLOCATOR_METHODS;\n-use syntax::attr;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n@@ -256,9 +256,10 @@ fn symbol_export_level_provider(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportL\n     // special symbols in the standard library for various plumbing between\n     // core/std/allocators/etc. For example symbols used to hook up allocation\n     // are not considered for export\n-    let is_extern = tcx.contains_extern_indicator(sym_def_id);\n-    let std_internal = attr::contains_name(&tcx.get_attrs(sym_def_id),\n-                                           \"rustc_std_internal_symbol\");\n+    let trans_fn_attrs = tcx.trans_fn_attrs(sym_def_id);\n+    let is_extern = trans_fn_attrs.contains_extern_indicator();\n+    let std_internal = trans_fn_attrs.flags.contains(TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL);\n+\n     if is_extern && !std_internal {\n         SymbolExportLevel::C\n     } else {"}, {"sha": "3708f6f6ec4fcf0124c11a8c762d0d5d592c3335", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -90,7 +90,6 @@ use syntax::ast;\n use mir::operand::OperandValue;\n \n pub use rustc_trans_utils::check_for_rustc_errors_attr;\n-pub use rustc_mir::monomorphize::item::linkage_by_name;\n \n pub struct StatRecorder<'a, 'tcx: 'a> {\n     cx: &'a CodegenCx<'a, 'tcx>,"}, {"sha": "0ce3f729305b41cac5369c25c62cfabecdbe441b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -146,20 +146,12 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-\n-                let g = if let Some(name) =\n-                        attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n+                let g = if let Some(linkage) = cx.tcx.trans_fn_attrs(def_id).linkage {\n                     // If this is a static with a linkage specified, then we need to handle\n                     // it a little specially. The typesystem prevents things like &T and\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::linkage_by_name(&name.as_str()) {\n-                        Some(linkage) => linkage,\n-                        None => {\n-                            cx.sess().span_fatal(span, \"invalid linkage specified\");\n-                        }\n-                    };\n                     let llty2 = match ty.sty {\n                         ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n                         _ => {"}, {"sha": "13fa15faf4123048174da692bd8aa276b75a7a26", "filename": "src/librustc_trans_utils/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a5e9410148dd10586acd50e4e99b515b0e3111a/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a5e9410148dd10586acd50e4e99b515b0e3111a/src%2Flibrustc_trans_utils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fdiagnostics.rs?ref=5a5e9410148dd10586acd50e4e99b515b0e3111a", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-register_long_diagnostics! {\n-\n-E0558: r##\"\n-The `export_name` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#[export_name] // error: export_name attribute has invalid format\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `export_name` attribute expects a string in order to determine the name of\n-the exported symbol. Example:\n-\n-```\n-#[export_name = \"some_function\"] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-}"}, {"sha": "6a3fd21f3a771580390119ac49ff7e9ff7a02a9a", "filename": "src/librustc_trans_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flib.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -37,7 +37,6 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_mir;\n extern crate rustc_incremental;\n-#[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n #[macro_use] extern crate rustc_data_structures;\n@@ -46,7 +45,6 @@ pub extern crate rustc as __rustc;\n \n use rustc::ty::TyCtxt;\n \n-pub mod diagnostics;\n pub mod link;\n pub mod trans_crate;\n pub mod symbol_names;"}, {"sha": "f9f93730255e6e302409d59615671653c1030cbf", "filename": "src/librustc_trans_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Fsymbol_names.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -120,29 +120,6 @@ pub fn provide(providers: &mut Providers) {\n         def_symbol_name,\n         symbol_name,\n \n-        export_name: |tcx, id| {\n-            tcx.get_attrs(id).iter().fold(None, |ia, attr| {\n-                if attr.check_name(\"export_name\") {\n-                    if let s @ Some(_) = attr.value_str() {\n-                        s\n-                    } else {\n-                        struct_span_err!(tcx.sess, attr.span, E0558,\n-                                         \"export_name attribute has invalid format\")\n-                            .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n-                            .emit();\n-                        None\n-                    }\n-                } else {\n-                    ia\n-                }\n-            })\n-        },\n-\n-        contains_extern_indicator: |tcx, id| {\n-            attr::contains_name(&tcx.get_attrs(id), \"no_mangle\") ||\n-                tcx.export_name(id).is_some()\n-        },\n-\n         ..*providers\n     };\n }\n@@ -287,7 +264,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n         return tcx.item_name(def_id).to_string();\n     }\n \n-    if let Some(name) = tcx.export_name(def_id) {\n+    if let Some(name) = tcx.trans_fn_attrs(def_id).export_name {\n         // Use provided name\n         return name.to_string();\n     }"}, {"sha": "0d4811c4b025dfd05c14eeaf3a9b5ac93f6ed70f", "filename": "src/librustc_trans_utils/trans_crate.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_trans_utils%2Ftrans_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Ftrans_crate.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -44,6 +44,7 @@ use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n use rustc_back::target::Target;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_mir::monomorphize::collector;\n use link::{build_link_meta, out_filename};\n \n@@ -200,8 +201,9 @@ impl TransCrate for MetadataOnlyTransCrate {\n \n     fn provide(&self, providers: &mut Providers) {\n         ::symbol_names::provide(providers);\n-        providers.target_features_enabled = |_tcx, _id| {\n-            Lrc::new(Vec::new()) // Just a dummy\n+\n+        providers.target_features_whitelist = |_tcx, _cnum| {\n+            Lrc::new(FxHashSet()) // Just a dummy\n         };\n     }\n     fn provide_extern(&self, _providers: &mut Providers) {}\n@@ -235,12 +237,8 @@ impl TransCrate for MetadataOnlyTransCrate {\n                 MonoItem::Fn(inst) => {\n                     let def_id = inst.def_id();\n                     if def_id.is_local()  {\n-                        let _ = tcx.export_name(def_id);\n-                        let _ = tcx.contains_extern_indicator(def_id);\n                         let _ = inst.def.is_inline(tcx);\n-                        let attrs = inst.def.attrs(tcx);\n-                        let _ =\n-                            ::syntax::attr::find_inline_attr(Some(tcx.sess.diagnostic()), &attrs);\n+                        let _ = tcx.trans_fn_attrs(def_id);\n                     }\n                 }\n                 _ => {}"}, {"sha": "1a7d8bb56780eb7cb7b444e7aa304bcec007648c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 190, "deletions": 2, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -30,25 +30,29 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use middle::resolve_lifetime as rl;\n+use rustc::mir::mono::Linkage;\n use rustc::traits::Reveal;\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n+use rustc::util::nodemap::FxHashSet;\n use util::nodemap::FxHashMap;\n \n use rustc_const_math::ConstInt;\n \n use syntax::{abi, ast};\n+use syntax::ast::MetaItemKind;\n+use syntax::attr::{InlineAttr, list_contains_name, mark_used};\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::{self, map as hir_map};\n+use rustc::hir::{self, map as hir_map, TransFnAttrs, TransFnAttrFlags, Unsafety};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n@@ -71,6 +75,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_trait_ref,\n         impl_polarity,\n         is_foreign_item,\n+        trans_fn_attrs,\n         ..*providers\n     };\n }\n@@ -1723,3 +1728,186 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n     }\n }\n+\n+fn from_target_feature(\n+    tcx: TyCtxt,\n+    attr: &ast::Attribute,\n+    whitelist: &FxHashSet<String>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let list = match attr.meta_item_list() {\n+        Some(list) => list,\n+        None => {\n+            let msg = \"#[target_feature] attribute must be of the form \\\n+                       #[target_feature(..)]\";\n+            tcx.sess.span_err(attr.span, &msg);\n+            return\n+        }\n+    };\n+\n+    for item in list {\n+        if !item.check_name(\"enable\") {\n+            let msg = \"#[target_feature(..)] only accepts sub-keys of `enable` \\\n+                       currently\";\n+            tcx.sess.span_err(item.span, &msg);\n+            continue\n+        }\n+        let value = match item.value_str() {\n+            Some(list) => list,\n+            None => {\n+                let msg = \"#[target_feature] attribute must be of the form \\\n+                           #[target_feature(enable = \\\"..\\\")]\";\n+                tcx.sess.span_err(item.span, &msg);\n+                continue\n+            }\n+        };\n+        let value = value.as_str();\n+        for feature in value.split(',') {\n+            if whitelist.contains(feature) {\n+                target_features.push(Symbol::intern(feature));\n+                continue\n+            }\n+\n+            let msg = format!(\"the feature named `{}` is not valid for \\\n+                               this target\", feature);\n+            let mut err = tcx.sess.struct_span_err(item.span, &msg);\n+\n+            if feature.starts_with(\"+\") {\n+                let valid = whitelist.contains(&feature[1..]);\n+                if valid {\n+                    err.help(\"consider removing the leading `+` in the feature name\");\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+fn linkage_by_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, name: &str) -> Linkage {\n+    use rustc::mir::mono::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but whitelist them anyway and trust that\n+    // the user knows what s/he's doing. Who knows, unanticipated use cases\n+    // may pop up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Appending,\n+        \"available_externally\" => AvailableExternally,\n+        \"common\" => Common,\n+        \"extern_weak\" => ExternalWeak,\n+        \"external\" => External,\n+        \"internal\" => Internal,\n+        \"linkonce\" => LinkOnceAny,\n+        \"linkonce_odr\" => LinkOnceODR,\n+        \"private\" => Private,\n+        \"weak\" => WeakAny,\n+        \"weak_odr\" => WeakODR,\n+        _ => {\n+            let span = tcx.hir.span_if_local(def_id);\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+            } else {\n+                tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+            }\n+        }\n+    }\n+}\n+\n+fn trans_fn_attrs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> TransFnAttrs {\n+    let attrs = tcx.get_attrs(id);\n+\n+    let mut trans_fn_attrs = TransFnAttrs::new();\n+\n+    let whitelist = tcx.target_features_whitelist(LOCAL_CRATE);\n+\n+    for attr in attrs.iter() {\n+        if attr.check_name(\"cold\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::COLD;\n+        } else if attr.check_name(\"allocator\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::ALLOCATOR;\n+        } else if attr.check_name(\"unwind\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::UNWIND;\n+        } else if attr.check_name(\"rustc_allocator_nounwind\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n+        } else if attr.check_name(\"naked\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::NAKED;\n+        } else if attr.check_name(\"no_mangle\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::NO_MANGLE;\n+        } else if attr.check_name(\"rustc_std_internal_symbol\") {\n+            trans_fn_attrs.flags |= TransFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+        } else if attr.check_name(\"inline\") {\n+            trans_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+                if attr.path != \"inline\" {\n+                    return ia;\n+                }\n+                let meta = match attr.meta() {\n+                    Some(meta) => meta.node,\n+                    None => return ia,\n+                };\n+                match meta {\n+                    MetaItemKind::Word => {\n+                        mark_used(attr);\n+                        InlineAttr::Hint\n+                    }\n+                    MetaItemKind::List(ref items) => {\n+                        mark_used(attr);\n+                        if items.len() != 1 {\n+                            span_err!(tcx.sess.diagnostic(), attr.span, E0534,\n+                                        \"expected one argument\");\n+                            InlineAttr::None\n+                        } else if list_contains_name(&items[..], \"always\") {\n+                            InlineAttr::Always\n+                        } else if list_contains_name(&items[..], \"never\") {\n+                            InlineAttr::Never\n+                        } else {\n+                            span_err!(tcx.sess.diagnostic(), items[0].span, E0535,\n+                                        \"invalid argument\");\n+\n+                            InlineAttr::None\n+                        }\n+                    }\n+                    _ => ia,\n+                }\n+            });\n+        } else if attr.check_name(\"export_name\") {\n+            if let s @ Some(_) = attr.value_str() {\n+                trans_fn_attrs.export_name = s;\n+            } else {\n+                struct_span_err!(tcx.sess, attr.span, E0558,\n+                                    \"export_name attribute has invalid format\")\n+                    .span_label(attr.span, \"did you mean #[export_name=\\\"*\\\"]?\")\n+                    .emit();\n+            }\n+        } else if attr.check_name(\"target_feature\") {\n+            if let Some(val) = attr.value_str() {\n+                for feat in val.as_str().split(\",\").map(|f| f.trim()) {\n+                    if !feat.is_empty() && !feat.contains('\\0') {\n+                        trans_fn_attrs.target_features.push(Symbol::intern(feat));\n+                    }\n+                }\n+                let msg = \"#[target_feature = \\\"..\\\"] is deprecated and will \\\n+                           eventually be removed, use \\\n+                           #[target_feature(enable = \\\"..\\\")] instead\";\n+                tcx.sess.span_warn(attr.span, &msg);\n+                continue\n+            }\n+\n+            if tcx.fn_sig(id).unsafety() == Unsafety::Normal {\n+                let msg = \"#[target_feature(..)] can only be applied to \\\n+                           `unsafe` function\";\n+                tcx.sess.span_err(attr.span, msg);\n+            }\n+            from_target_feature(tcx, attr, &whitelist, &mut trans_fn_attrs.target_features);\n+        } else if attr.check_name(\"linkage\") {\n+            if let Some(val) = attr.value_str() {\n+                trans_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n+            }\n+        }\n+    }\n+\n+    trans_fn_attrs\n+}"}, {"sha": "96b2ec745f132266794706278fa2fdf2a48d04eb", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -3705,6 +3705,98 @@ match r {\n ```\n \"##,\n \n+E0534: r##\"\n+The `inline` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline()] // error: expected one argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The parenthesized `inline` attribute requires the parameter to be specified:\n+\n+```\n+#[inline(always)]\n+fn something() {}\n+```\n+\n+or:\n+\n+```\n+#[inline(never)]\n+fn something() {}\n+```\n+\n+Alternatively, a paren-less version of the attribute may be used to hint the\n+compiler about inlining opportunity:\n+\n+```\n+#[inline]\n+fn something() {}\n+```\n+\n+For more information about the inline attribute, read:\n+https://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0535: r##\"\n+An unknown argument was given to the `inline` attribute.\n+\n+Erroneous code example:\n+\n+```ignore (compile_fail not working here; see Issue #43707)\n+#[inline(unknown)] // error: invalid argument\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `inline` attribute only supports two arguments:\n+\n+ * always\n+ * never\n+\n+All other arguments given to the `inline` attribute will return this error.\n+Example:\n+\n+```\n+#[inline(never)] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+For more information about the inline attribute, https:\n+read://doc.rust-lang.org/reference.html#inline-attributes\n+\"##,\n+\n+E0558: r##\"\n+The `export_name` attribute was malformed.\n+\n+Erroneous code example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#[export_name] // error: export_name attribute has invalid format\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\n+The `export_name` attribute expects a string in order to determine the name of\n+the exported symbol. Example:\n+\n+```\n+#[export_name = \"some_function\"] // ok!\n+pub fn something() {}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0559: r##\"\n An unknown field was specified into an enum's structure variant.\n "}, {"sha": "4818248129e70a1659a06b85c3c8c85bef99fd48", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -520,51 +520,14 @@ pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-/// Determine what `#[inline]` attribute is present in `attrs`, if any.\n-pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if attr.path != \"inline\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                mark_used(attr);\n-                InlineAttr::Hint\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n-                    InlineAttr::None\n-                } else if list_contains_name(&items[..], \"always\") {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items[..], \"never\") {\n-                    InlineAttr::Never\n-                } else {\n-                    diagnostic.map(|d| {\n-                        span_err!(d, items[0].span, E0535, \"invalid argument\");\n-                    });\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            _ => ia,\n-        }\n-    })\n-}\n-\n #[derive(Copy, Clone, PartialEq)]\n pub enum UnwindAttr {\n     Allowed,\n@@ -610,13 +573,6 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n     })\n }\n \n-/// True if `#[inline]` or `#[inline(always)]` is present in `attrs`.\n-pub fn requests_inline(attrs: &[Attribute]) -> bool {\n-    match find_inline_attr(None, attrs) {\n-        InlineAttr::Hint | InlineAttr::Always => true,\n-        InlineAttr::None | InlineAttr::Never => false,\n-    }\n-}\n \n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {"}, {"sha": "549ef88afcc63b1811be51180469f24c0d836894", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5bcb9a4104baa7e900507190157f4dbe301cb5a/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=b5bcb9a4104baa7e900507190157f4dbe301cb5a", "patch": "@@ -37,75 +37,6 @@ More details can be found in [RFC 438].\n [RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n \"##,\n \n-E0534: r##\"\n-The `inline` attribute was malformed.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline()] // error: expected one argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The parenthesized `inline` attribute requires the parameter to be specified:\n-\n-```\n-#[inline(always)]\n-fn something() {}\n-```\n-\n-or:\n-\n-```\n-#[inline(never)]\n-fn something() {}\n-```\n-\n-Alternatively, a paren-less version of the attribute may be used to hint the\n-compiler about inlining opportunity:\n-\n-```\n-#[inline]\n-fn something() {}\n-```\n-\n-For more information about the inline attribute, read:\n-https://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n-E0535: r##\"\n-An unknown argument was given to the `inline` attribute.\n-\n-Erroneous code example:\n-\n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline(unknown)] // error: invalid argument\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-The `inline` attribute only supports two arguments:\n-\n- * always\n- * never\n-\n-All other arguments given to the `inline` attribute will return this error.\n-Example:\n-\n-```\n-#[inline(never)] // ok!\n-pub fn something() {}\n-\n-fn main() {}\n-```\n-\n-For more information about the inline attribute, https:\n-read://doc.rust-lang.org/reference.html#inline-attributes\n-\"##,\n-\n E0536: r##\"\n The `not` cfg-predicate was malformed.\n "}]}