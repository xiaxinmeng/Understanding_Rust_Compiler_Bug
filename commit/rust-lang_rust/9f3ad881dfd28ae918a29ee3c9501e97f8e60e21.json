{"sha": "9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmM2FkODgxZGZkMjhhZTkxOGEyOWVlM2M5NTAxZTk3ZjhlNjBlMjE=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-01T04:59:37Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:48:58Z"}, "message": "Extract generator_layout as a method", "tree": {"sha": "e30e541ba74cd4cbb61e3c2a11f81511fc677566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e30e541ba74cd4cbb61e3c2a11f81511fc677566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "html_url": "https://github.com/rust-lang/rust/commit/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c158d1ca0c9cf8c7caab7b5d1d52fbf970ce9c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/c158d1ca0c9cf8c7caab7b5d1d52fbf970ce9c90", "html_url": "https://github.com/rust-lang/rust/commit/c158d1ca0c9cf8c7caab7b5d1d52fbf970ce9c90"}], "stats": {"total": 525, "additions": 271, "deletions": 254}, "files": [{"sha": "caff75a36cd5e3157021e6b502b2a59d9307dee5", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 271, "deletions": 254, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3ad881dfd28ae918a29ee3c9501e97f8e60e21/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9f3ad881dfd28ae918a29ee3c9501e97f8e60e21", "patch": "@@ -14,7 +14,8 @@ use std::ops::Bound;\n \n use crate::hir;\n use crate::ich::StableHashingContext;\n-use crate::mir::GeneratorSavedLocal;\n+use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n+use crate::ty::GeneratorSubsts;\n use crate::ty::subst::Subst;\n use rustc_data_structures::bit_set::BitSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -622,259 +623,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 tcx.intern_layout(unit)\n             }\n \n-            ty::Generator(def_id, ref substs, _) => {\n-                // When laying out generators, we divide our saved local fields\n-                // into two categories: overlap-eligible and overlap-ineligible.\n-                //\n-                // Those fields which are ineligible for overlap go in a\n-                // \"prefix\" at the beginning of the layout, and always have\n-                // space reserved for them.\n-                //\n-                // Overlap-eligible fields are only assigned to one variant, so\n-                // we lay those fields out for each variant and put them right\n-                // after the prefix.\n-                //\n-                // Finally, in the layout details, we point to the fields\n-                // from the variants they are assigned to. It is possible for\n-                // some fields to be included in multiple variants. No field\n-                // ever \"moves around\" in the layout; its offset is always the\n-                // same.\n-                //\n-                // Also included in the layout are the upvars and the\n-                // discriminant. These are included as fields on the \"outer\"\n-                // layout; they are not part of any variant.\n-\n-                let info = tcx.generator_layout(def_id);\n-                let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs.substs) };\n-\n-                #[derive(Clone, Debug, PartialEq)]\n-                enum SavedLocalEligibility {\n-                    Unassigned,\n-                    Assigned(VariantIdx),\n-                    // FIXME: Use newtype_index so we aren't wasting bytes\n-                    Ineligible(Option<u32>),\n-                }\n-                use SavedLocalEligibility::*;\n-\n-                let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n-                    IndexVec::from_elem_n(Unassigned, info.field_tys.len());\n-\n-                // The saved locals not eligible for overlap. These will get\n-                // \"promoted\" to the prefix of our generator.\n-                let mut ineligible_locals = BitSet::new_empty(info.field_tys.len());\n-\n-                // Figure out which of our saved locals are fields in only\n-                // one variant. The rest are deemed ineligible for overlap.\n-                for (variant_index, fields) in info.variant_fields.iter_enumerated() {\n-                    for local in fields {\n-                        match assignments[*local] {\n-                            Unassigned => {\n-                                assignments[*local] = Assigned(variant_index);\n-                            }\n-                            Assigned(idx) => {\n-                                // We've already seen this local at another suspension\n-                                // point, so it is no longer a candidate.\n-                                trace!(\"removing local {:?} in >1 variant ({:?}, {:?})\",\n-                                       local, variant_index, idx);\n-                                ineligible_locals.insert(*local);\n-                                assignments[*local] = Ineligible(None);\n-                            }\n-                            Ineligible(_) => {},\n-                        }\n-                    }\n-                }\n-\n-                // Next, check every pair of eligible locals to see if they\n-                // conflict.\n-                for local_a in info.storage_conflicts.rows() {\n-                    let conflicts_a = info.storage_conflicts.count(local_a);\n-                    if ineligible_locals.contains(local_a) {\n-                        continue;\n-                    }\n-\n-                    for local_b in info.storage_conflicts.iter(local_a) {\n-                        // local_a and local_b are storage live at the same time, therefore they\n-                        // cannot overlap in the generator layout. The only way to guarantee\n-                        // this is if they are in the same variant, or one is ineligible\n-                        // (which means it is stored in every variant).\n-                        if ineligible_locals.contains(local_b) ||\n-                            assignments[local_a] == assignments[local_b]\n-                        {\n-                            continue;\n-                        }\n-\n-                        // If they conflict, we will choose one to make ineligible.\n-                        // This is not always optimal; it's just a greedy heuristic\n-                        // that seems to produce good results most of the time.\n-                        let conflicts_b = info.storage_conflicts.count(local_b);\n-                        let (remove, other) = if conflicts_a > conflicts_b {\n-                            (local_a, local_b)\n-                        } else {\n-                            (local_b, local_a)\n-                        };\n-                        ineligible_locals.insert(remove);\n-                        assignments[remove] = Ineligible(None);\n-                        trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n-                    }\n-                }\n-\n-                // Write down the order of our locals that will be promoted to\n-                // the prefix.\n-                {\n-                    let mut idx = 0u32;\n-                    for local in ineligible_locals.iter() {\n-                        assignments[local] = Ineligible(Some(idx));\n-                        idx += 1;\n-                    }\n-                }\n-                debug!(\"generator saved local assignments: {:?}\", assignments);\n-\n-                // Build a prefix layout, including \"promoting\" all ineligible\n-                // locals as part of the prefix. We compute the layout of all of\n-                // these fields at once to get optimal packing.\n-                let discr_index = substs.prefix_tys(def_id, tcx).count();\n-                let promoted_tys =\n-                    ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n-                let prefix_tys = substs.prefix_tys(def_id, tcx)\n-                    .chain(iter::once(substs.discr_ty(tcx)))\n-                    .chain(promoted_tys);\n-                let prefix = self.univariant_uninterned(\n-                    ty,\n-                    &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(),\n-                    StructKind::AlwaysSized)?;\n-                let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n-\n-                let recompute_memory_index = |offsets: &Vec<u32>| -> Vec<u32> {\n-                    debug!(\"recompute_memory_index({:?})\", offsets);\n-                    let mut inverse_index = (0..offsets.len() as u32).collect::<Vec<_>>();\n-                    inverse_index.sort_unstable_by_key(|i| offsets[*i as usize]);\n-\n-                    let mut index = vec![0; offsets.len()];\n-                    for i in 0..index.len() {\n-                        index[inverse_index[i] as usize] = i as u32;\n-                    }\n-                    debug!(\"recompute_memory_index() => {:?}\", index);\n-                    index\n-                };\n-\n-                // Split the prefix layout into the \"outer\" fields (upvars and\n-                // discriminant) and the \"promoted\" fields. Promoted fields will\n-                // get included in each variant that requested them in\n-                // GeneratorLayout.\n-                debug!(\"prefix = {:#?}\", prefix);\n-                let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n-                    FieldPlacement::Arbitrary { offsets, memory_index } => {\n-                        let (offsets_a, offsets_b) =\n-                            offsets.split_at(discr_index + 1);\n-                        let (memory_index_a, memory_index_b) =\n-                            memory_index.split_at(discr_index + 1);\n-                        let outer_fields = FieldPlacement::Arbitrary {\n-                            offsets: offsets_a.to_vec(),\n-                            memory_index: recompute_memory_index(&memory_index_a.to_vec())\n-                        };\n-                        (outer_fields,\n-                         offsets_b.to_vec(),\n-                         recompute_memory_index(&memory_index_b.to_vec()))\n-                    }\n-                    _ => bug!(),\n-                };\n-\n-                let mut size = prefix.size;\n-                let mut align = prefix.align;\n-                let variants = info.variant_fields.iter_enumerated().map(|(index, variant_fields)| {\n-                    // Only include overlap-eligible fields when we compute our variant layout.\n-                    let variant_only_tys = variant_fields\n-                        .iter()\n-                        .filter(|local| {\n-                            match assignments[**local] {\n-                                Unassigned => bug!(),\n-                                Assigned(v) if v == index => true,\n-                                Assigned(_) => bug!(\"assignment does not match variant\"),\n-                                Ineligible(_) => false,\n-                            }\n-                        })\n-                        .map(|local| subst_field(info.field_tys[*local]));\n-\n-                    let mut variant = self.univariant_uninterned(\n-                        ty,\n-                        &variant_only_tys\n-                            .map(|ty| self.layout_of(ty))\n-                            .collect::<Result<Vec<_>, _>>()?,\n-                        &ReprOptions::default(),\n-                        StructKind::Prefixed(prefix_size, prefix_align.abi))?;\n-                    variant.variants = Variants::Single { index };\n-\n-                    let (offsets, memory_index) = match variant.fields {\n-                        FieldPlacement::Arbitrary { offsets, memory_index } =>\n-                            (offsets, memory_index),\n-                        _ => bug!(),\n-                    };\n-\n-                    // Now, stitch the promoted and variant-only fields back\n-                    // together in the order they are mentioned by our\n-                    // GeneratorLayout.\n-                    let mut next_variant_field = 0;\n-                    let mut combined_offsets = Vec::new();\n-                    let mut combined_memory_index = Vec::new();\n-                    for local in variant_fields.iter() {\n-                        match assignments[*local] {\n-                            Unassigned => bug!(),\n-                            Assigned(_) => {\n-                                combined_offsets.push(offsets[next_variant_field]);\n-                                // Shift memory indices by the number of\n-                                // promoted fields, which all come first. We\n-                                // may not use all promoted fields in our\n-                                // variant but that's okay; we'll renumber them\n-                                // below.\n-                                combined_memory_index.push(\n-                                    promoted_memory_index.len() as u32 +\n-                                    memory_index[next_variant_field]);\n-                                next_variant_field += 1;\n-                            }\n-                            Ineligible(field_idx) => {\n-                                let field_idx = field_idx.unwrap() as usize;\n-                                combined_offsets.push(promoted_offsets[field_idx]);\n-                                combined_memory_index.push(promoted_memory_index[field_idx]);\n-                            }\n-                        }\n-                    }\n-                    variant.fields = FieldPlacement::Arbitrary {\n-                        offsets: combined_offsets,\n-                        memory_index: recompute_memory_index(&combined_memory_index),\n-                    };\n-\n-                    size = size.max(variant.size);\n-                    align = align.max(variant.align);\n-                    Ok(variant)\n-                }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n-\n-                let abi = if prefix.abi.is_uninhabited() ||\n-                             variants.iter().all(|v| v.abi.is_uninhabited()) {\n-                    Abi::Uninhabited\n-                } else {\n-                    Abi::Aggregate { sized: true }\n-                };\n-                let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n-                    Abi::Scalar(s) => s.clone(),\n-                    _ => bug!(),\n-                };\n-\n-                let layout = tcx.intern_layout(LayoutDetails {\n-                    variants: Variants::Multiple {\n-                        discr,\n-                        discr_kind: DiscriminantKind::Tag,\n-                        discr_index,\n-                        variants,\n-                    },\n-                    fields: outer_fields,\n-                    abi,\n-                    size,\n-                    align,\n-                });\n-                debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n-                layout\n-            }\n+            ty::Generator(def_id, substs, _) => self.generator_layout(ty, def_id, &substs)?,\n \n             ty::Closure(def_id, ref substs) => {\n                 let tys = substs.upvar_tys(def_id, tcx);\n@@ -1443,7 +1192,275 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             }\n         })\n     }\n+}\n+\n+/// Overlap eligibility and variant assignment for each GeneratorSavedLocal.\n+#[derive(Clone, Debug, PartialEq)]\n+enum SavedLocalEligibility {\n+    Unassigned,\n+    Assigned(VariantIdx),\n+    // FIXME: Use newtype_index so we aren't wasting bytes\n+    Ineligible(Option<u32>),\n+}\n+\n+// When laying out generators, we divide our saved local fields into two\n+// categories: overlap-eligible and overlap-ineligible.\n+//\n+// Those fields which are ineligible for overlap go in a \"prefix\" at the\n+// beginning of the layout, and always have space reserved for them.\n+//\n+// Overlap-eligible fields are only assigned to one variant, so we lay\n+// those fields out for each variant and put them right after the\n+// prefix.\n+//\n+// Finally, in the layout details, we point to the fields from the\n+// variants they are assigned to. It is possible for some fields to be\n+// included in multiple variants. No field ever \"moves around\" in the\n+// layout; its offset is always the same.\n+//\n+// Also included in the layout are the upvars and the discriminant.\n+// These are included as fields on the \"outer\" layout; they are not part\n+// of any variant.\n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n+    /// Compute the eligibility and assignment of each local.\n+    fn generator_saved_local_eligibility(&self, info: &GeneratorLayout<'tcx>)\n+    -> (BitSet<GeneratorSavedLocal>, IndexVec<GeneratorSavedLocal, SavedLocalEligibility>) {\n+        use SavedLocalEligibility::*;\n+\n+        let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n+            IndexVec::from_elem_n(Unassigned, info.field_tys.len());\n+\n+        // The saved locals not eligible for overlap. These will get\n+        // \"promoted\" to the prefix of our generator.\n+        let mut ineligible_locals = BitSet::new_empty(info.field_tys.len());\n+\n+        // Figure out which of our saved locals are fields in only\n+        // one variant. The rest are deemed ineligible for overlap.\n+        for (variant_index, fields) in info.variant_fields.iter_enumerated() {\n+            for local in fields {\n+                match assignments[*local] {\n+                    Unassigned => {\n+                        assignments[*local] = Assigned(variant_index);\n+                    }\n+                    Assigned(idx) => {\n+                        // We've already seen this local at another suspension\n+                        // point, so it is no longer a candidate.\n+                        trace!(\"removing local {:?} in >1 variant ({:?}, {:?})\",\n+                               local, variant_index, idx);\n+                        ineligible_locals.insert(*local);\n+                        assignments[*local] = Ineligible(None);\n+                    }\n+                    Ineligible(_) => {},\n+                }\n+            }\n+        }\n+\n+        // Next, check every pair of eligible locals to see if they\n+        // conflict.\n+        for local_a in info.storage_conflicts.rows() {\n+            let conflicts_a = info.storage_conflicts.count(local_a);\n+            if ineligible_locals.contains(local_a) {\n+                continue;\n+            }\n+\n+            for local_b in info.storage_conflicts.iter(local_a) {\n+                // local_a and local_b are storage live at the same time, therefore they\n+                // cannot overlap in the generator layout. The only way to guarantee\n+                // this is if they are in the same variant, or one is ineligible\n+                // (which means it is stored in every variant).\n+                if ineligible_locals.contains(local_b) ||\n+                    assignments[local_a] == assignments[local_b]\n+                {\n+                    continue;\n+                }\n+\n+                // If they conflict, we will choose one to make ineligible.\n+                // This is not always optimal; it's just a greedy heuristic that\n+                // seems to produce good results most of the time.\n+                let conflicts_b = info.storage_conflicts.count(local_b);\n+                let (remove, other) = if conflicts_a > conflicts_b {\n+                    (local_a, local_b)\n+                } else {\n+                    (local_b, local_a)\n+                };\n+                ineligible_locals.insert(remove);\n+                assignments[remove] = Ineligible(None);\n+                trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n+            }\n+        }\n+\n+        // Write down the order of our locals that will be promoted to the prefix.\n+        {\n+            let mut idx = 0u32;\n+            for local in ineligible_locals.iter() {\n+                assignments[local] = Ineligible(Some(idx));\n+                idx += 1;\n+            }\n+        }\n+        debug!(\"generator saved local assignments: {:?}\", assignments);\n+\n+        (ineligible_locals, assignments)\n+    }\n+\n+    /// Compute the full generator layout.\n+    fn generator_layout(\n+        &self,\n+        ty: Ty<'tcx>,\n+        def_id: hir::def_id::DefId,\n+        substs: &GeneratorSubsts<'tcx>,\n+    ) -> Result<&'tcx LayoutDetails, LayoutError<'tcx>> {\n+        use SavedLocalEligibility::*;\n+        let tcx = self.tcx;\n+        let recompute_memory_index = |offsets: &Vec<u32>| -> Vec<u32> {\n+            debug!(\"recompute_memory_index({:?})\", offsets);\n+            let mut inverse_index = (0..offsets.len() as u32).collect::<Vec<_>>();\n+            inverse_index.sort_unstable_by_key(|i| offsets[*i as usize]);\n+\n+            let mut index = vec![0; offsets.len()];\n+            for i in 0..index.len() {\n+                index[inverse_index[i] as usize] = i as u32;\n+            }\n+            debug!(\"recompute_memory_index() => {:?}\", index);\n+            index\n+        };\n+        let subst_field = |ty: Ty<'tcx>| { ty.subst(tcx, substs.substs) };\n+\n+        let info = tcx.generator_layout(def_id);\n+        let (ineligible_locals, assignments) = self.generator_saved_local_eligibility(&info);\n+\n+        // Build a prefix layout, including \"promoting\" all ineligible\n+        // locals as part of the prefix. We compute the layout of all of\n+        // these fields at once to get optimal packing.\n+        let discr_index = substs.prefix_tys(def_id, tcx).count();\n+        let promoted_tys =\n+            ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n+        let prefix_tys = substs.prefix_tys(def_id, tcx)\n+            .chain(iter::once(substs.discr_ty(tcx)))\n+            .chain(promoted_tys);\n+        let prefix = self.univariant_uninterned(\n+            ty,\n+            &prefix_tys.map(|ty| self.layout_of(ty)).collect::<Result<Vec<_>, _>>()?,\n+            &ReprOptions::default(),\n+            StructKind::AlwaysSized)?;\n+        let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n+\n+        // Split the prefix layout into the \"outer\" fields (upvars and\n+        // discriminant) and the \"promoted\" fields. Promoted fields will\n+        // get included in each variant that requested them in\n+        // GeneratorLayout.\n+        debug!(\"prefix = {:#?}\", prefix);\n+        let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n+            FieldPlacement::Arbitrary { offsets, memory_index } => {\n+                let (offsets_a, offsets_b) =\n+                    offsets.split_at(discr_index + 1);\n+                let (memory_index_a, memory_index_b) =\n+                    memory_index.split_at(discr_index + 1);\n+                let outer_fields = FieldPlacement::Arbitrary {\n+                    offsets: offsets_a.to_vec(),\n+                    memory_index: recompute_memory_index(&memory_index_a.to_vec())\n+                };\n+                (outer_fields,\n+                 offsets_b.to_vec(),\n+                 recompute_memory_index(&memory_index_b.to_vec()))\n+            }\n+            _ => bug!(),\n+        };\n+\n+        let mut size = prefix.size;\n+        let mut align = prefix.align;\n+        let variants = info.variant_fields.iter_enumerated().map(|(index, variant_fields)| {\n+            // Only include overlap-eligible fields when we compute our variant layout.\n+            let variant_only_tys = variant_fields\n+                .iter()\n+                .filter(|local| {\n+                    match assignments[**local] {\n+                        Unassigned => bug!(),\n+                        Assigned(v) if v == index => true,\n+                        Assigned(_) => bug!(\"assignment does not match variant\"),\n+                        Ineligible(_) => false,\n+                    }\n+                })\n+                .map(|local| subst_field(info.field_tys[*local]));\n+\n+            let mut variant = self.univariant_uninterned(\n+                ty,\n+                &variant_only_tys\n+                    .map(|ty| self.layout_of(ty))\n+                    .collect::<Result<Vec<_>, _>>()?,\n+                &ReprOptions::default(),\n+                StructKind::Prefixed(prefix_size, prefix_align.abi))?;\n+            variant.variants = Variants::Single { index };\n+\n+            let (offsets, memory_index) = match variant.fields {\n+                FieldPlacement::Arbitrary { offsets, memory_index } => (offsets, memory_index),\n+                _ => bug!(),\n+            };\n+\n+            // Now, stitch the promoted and variant-only fields back together in\n+            // the order they are mentioned by our GeneratorLayout.\n+            let mut next_variant_field = 0;\n+            let mut combined_offsets = Vec::new();\n+            let mut combined_memory_index = Vec::new();\n+            for local in variant_fields.iter() {\n+                match assignments[*local] {\n+                    Unassigned => bug!(),\n+                    Assigned(_) => {\n+                        combined_offsets.push(offsets[next_variant_field]);\n+                        // Shift memory indices by the number of promoted\n+                        // fields, which all come first. We may not use all\n+                        // promoted fields in our variant but that's okay; we'll\n+                        // renumber them below.\n+                        combined_memory_index.push(\n+                            promoted_memory_index.len() as u32 +\n+                            memory_index[next_variant_field]);\n+                        next_variant_field += 1;\n+                    }\n+                    Ineligible(field_idx) => {\n+                        let field_idx = field_idx.unwrap() as usize;\n+                        combined_offsets.push(promoted_offsets[field_idx]);\n+                        combined_memory_index.push(promoted_memory_index[field_idx]);\n+                    }\n+                }\n+            }\n+            variant.fields = FieldPlacement::Arbitrary {\n+                offsets: combined_offsets,\n+                memory_index: recompute_memory_index(&combined_memory_index),\n+            };\n+\n+            size = size.max(variant.size);\n+            align = align.max(variant.align);\n+            Ok(variant)\n+        }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+        let abi = if prefix.abi.is_uninhabited() ||\n+                     variants.iter().all(|v| v.abi.is_uninhabited()) {\n+            Abi::Uninhabited\n+        } else {\n+            Abi::Aggregate { sized: true }\n+        };\n+        let discr = match &self.layout_of(substs.discr_ty(tcx))?.abi {\n+            Abi::Scalar(s) => s.clone(),\n+            _ => bug!(),\n+        };\n+\n+        let layout = tcx.intern_layout(LayoutDetails {\n+            variants: Variants::Multiple {\n+                discr,\n+                discr_kind: DiscriminantKind::Tag,\n+                discr_index,\n+                variants,\n+            },\n+            fields: outer_fields,\n+            abi,\n+            size,\n+            align,\n+        });\n+        debug!(\"generator layout ({:?}): {:#?}\", ty, layout);\n+        Ok(layout)\n+    }\n+}\n \n+impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n     /// This is invoked by the `layout_raw` query to record the final\n     /// layout of each type.\n     #[inline(always)]"}]}