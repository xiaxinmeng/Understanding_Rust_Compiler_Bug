{"sha": "47dad31a04724b969d260c32f136bda47fcba63f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZGFkMzFhMDQ3MjRiOTY5ZDI2MGMzMmYxMzZiZGE0N2ZjYmE2M2Y=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-10-27T22:47:29Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-10-27T22:47:29Z"}, "message": "rustc_span: represent line bounds with Range", "tree": {"sha": "e9bad83ce31586656c45896647265eed9b26fe2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9bad83ce31586656c45896647265eed9b26fe2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47dad31a04724b969d260c32f136bda47fcba63f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47dad31a04724b969d260c32f136bda47fcba63f", "html_url": "https://github.com/rust-lang/rust/commit/47dad31a04724b969d260c32f136bda47fcba63f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47dad31a04724b969d260c32f136bda47fcba63f/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df59a44feadad386a8b69cfafaf50605c6af2689", "url": "https://api.github.com/repos/rust-lang/rust/commits/df59a44feadad386a8b69cfafaf50605c6af2689", "html_url": "https://github.com/rust-lang/rust/commit/df59a44feadad386a8b69cfafaf50605c6af2689"}], "stats": {"total": 54, "additions": 24, "deletions": 30}, "files": [{"sha": "15dd00fb483e786c0c896e1fa8fa4fca80beeb2e", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/47dad31a04724b969d260c32f136bda47fcba63f/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dad31a04724b969d260c32f136bda47fcba63f/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=47dad31a04724b969d260c32f136bda47fcba63f", "patch": "@@ -1,13 +1,25 @@\n use crate::source_map::SourceMap;\n use crate::{BytePos, SourceFile};\n use rustc_data_structures::sync::Lrc;\n+use std::ops::Range;\n \n #[derive(Clone)]\n struct CacheEntry {\n     time_stamp: usize,\n     line_number: usize,\n-    line_start: BytePos,\n-    line_end: BytePos,\n+    // The line's byte position range in the `SourceMap`. This range will fail to contain a valid\n+    // position in certain edge cases. Spans often start/end one past something, and when that\n+    // something is the last character of a file (this can happen when a file doesn't end in a\n+    // newline, for example), we'd still like for the position to be considered within the last\n+    // line. However, it isn't according to the exclusive upper bound of this range. We cannot\n+    // change the upper bound to be inclusive, because for most lines, the upper bound is the same\n+    // as the lower bound of the next line, so there would be an ambiguity.\n+    //\n+    // Since the containment aspect of this range is only used to see whether or not the cache\n+    // entry contains a position, the only ramification of the above is that we will get cache\n+    // misses for these rare positions. A line lookup for the position via `SourceMap::lookup_line`\n+    // after a cache miss will produce the last line number, as desired.\n+    line: Range<BytePos>,\n     file: Lrc<SourceFile>,\n     file_index: usize,\n }\n@@ -26,8 +38,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let entry = CacheEntry {\n             time_stamp: 0,\n             line_number: 0,\n-            line_start: BytePos(0),\n-            line_end: BytePos(0),\n+            line: BytePos(0)..BytePos(0),\n             file: first_file,\n             file_index: 0,\n         };\n@@ -47,13 +58,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n \n         // Check if the position is in one of the cached lines\n         for cache_entry in self.line_cache.iter_mut() {\n-            if line_contains((cache_entry.line_start, cache_entry.line_end), pos) {\n+            if cache_entry.line.contains(&pos) {\n                 cache_entry.time_stamp = self.time_stamp;\n \n                 return Some((\n                     cache_entry.file.clone(),\n                     cache_entry.line_number,\n-                    pos - cache_entry.line_start,\n+                    pos - cache_entry.line.start,\n                 ));\n             }\n         }\n@@ -95,30 +106,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let line_bounds = cache_entry.file.line_bounds(line_index);\n \n         cache_entry.line_number = line_index + 1;\n-        cache_entry.line_start = line_bounds.0;\n-        cache_entry.line_end = line_bounds.1;\n+        cache_entry.line = line_bounds;\n         cache_entry.time_stamp = self.time_stamp;\n \n-        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line_start))\n+        Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line.start))\n     }\n }\n \n-#[inline]\n-fn line_contains(line_bounds: (BytePos, BytePos), pos: BytePos) -> bool {\n-    // This condition will be false in one case where we'd rather it wasn't. Spans often start/end\n-    // one past something, and when that something is the last character of a file (this can happen\n-    // when a file doesn't end in a newline, for example), we'd still like for the position to be\n-    // considered within the last line. However, it isn't according to the exclusive upper bound\n-    // below. We cannot change the upper bound to be inclusive, because for most lines, the upper\n-    // bound is the same as the lower bound of the next line, so there would be an ambiguity.\n-    //\n-    // Supposing we only use this function to check whether or not the line cache entry contains\n-    // a position, the only ramification of the above is that we will get cache misses for these\n-    // rare positions. A line lookup for the position via `SourceMap::lookup_line` after a cache\n-    // miss will produce the last line number, as desired.\n-    line_bounds.0 <= pos && pos < line_bounds.1\n-}\n-\n #[inline]\n fn file_contains(file: &SourceFile, pos: BytePos) -> bool {\n     // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position"}, {"sha": "54b0040dc09cda01f9afc22d317b3a48e66a84fa", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47dad31a04724b969d260c32f136bda47fcba63f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dad31a04724b969d260c32f136bda47fcba63f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=47dad31a04724b969d260c32f136bda47fcba63f", "patch": "@@ -52,7 +52,7 @@ use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hash;\n-use std::ops::{Add, Sub};\n+use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n@@ -1426,16 +1426,16 @@ impl SourceFile {\n         if line_index >= 0 { Some(line_index as usize) } else { None }\n     }\n \n-    pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n+    pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {\n         if self.is_empty() {\n-            return (self.start_pos, self.end_pos);\n+            return self.start_pos..self.end_pos;\n         }\n \n         assert!(line_index < self.lines.len());\n         if line_index == (self.lines.len() - 1) {\n-            (self.lines[line_index], self.end_pos)\n+            self.lines[line_index]..self.end_pos\n         } else {\n-            (self.lines[line_index], self.lines[line_index + 1])\n+            self.lines[line_index]..self.lines[line_index + 1]\n         }\n     }\n "}]}