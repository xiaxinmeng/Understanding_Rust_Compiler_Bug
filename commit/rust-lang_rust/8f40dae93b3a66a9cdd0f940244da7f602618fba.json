{"sha": "8f40dae93b3a66a9cdd0f940244da7f602618fba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNDBkYWU5M2IzYTY2YTljZGQwZjk0MDI0NGRhN2Y2MDI2MThmYmE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T23:17:04Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-24T23:17:04Z"}, "message": "Suggest type param trait bound for binop only when appropriate\n\nVerify that the binop trait *is* implemented for the types *if* all the\ninvolved type parameters are replaced with fresh inferred types. When\nthis is the case, it means that the type parameter was indeed missing a\ntrait bound. If this is not the case, provide a generic `note` refering\nto the type that doesn't implement the expected trait.", "tree": {"sha": "16d20d079eca836b0e07fc963bcc2cf16cdb143b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16d20d079eca836b0e07fc963bcc2cf16cdb143b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f40dae93b3a66a9cdd0f940244da7f602618fba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f40dae93b3a66a9cdd0f940244da7f602618fba", "html_url": "https://github.com/rust-lang/rust/commit/8f40dae93b3a66a9cdd0f940244da7f602618fba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f40dae93b3a66a9cdd0f940244da7f602618fba/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "url": "https://api.github.com/repos/rust-lang/rust/commits/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b", "html_url": "https://github.com/rust-lang/rust/commit/09af1845d7b43c0a17c1b98f6be92c2c0fbc202b"}], "stats": {"total": 128, "additions": 78, "deletions": 50}, "files": [{"sha": "e333b706e745da4291f8eea55bcd2e0277e8fbe5", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -8,6 +8,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n+use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n use rustc_middle::ty::{\n     self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n@@ -436,29 +437,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // we don't want the note in the else clause to be emitted\n                     } else if let [ty] = &visitor.0[..] {\n                         if let ty::Param(p) = ty.kind {\n-                            // FIXME: This *guesses* that constraining the type param\n-                            // will make the operation available, but this is only true\n-                            // when the corresponding trait has a blanket\n-                            // implementation, like the following:\n-                            // `impl<'a> PartialEq for &'a [T] where T: PartialEq {}`\n-                            // The correct thing to do would be to verify this\n-                            // projection would hold.\n-                            if *ty != lhs_ty {\n+                            // Check if the method would be found if the type param wasn't\n+                            // involved. If so, it means that adding a trait bound to the param is\n+                            // enough. Otherwise we do not give the suggestion.\n+                            let mut eraser = TypeParamEraser(&self, expr.span);\n+                            let needs_bound = self\n+                                .lookup_op_method(\n+                                    eraser.fold_ty(lhs_ty),\n+                                    &[eraser.fold_ty(rhs_ty)],\n+                                    Op::Binary(op, is_assign),\n+                                )\n+                                .is_ok();\n+                            if needs_bound {\n+                                suggest_constraining_param(\n+                                    self.tcx,\n+                                    self.body_id,\n+                                    &mut err,\n+                                    ty,\n+                                    rhs_ty,\n+                                    missing_trait,\n+                                    p,\n+                                    use_output,\n+                                );\n+                            } else if *ty != lhs_ty {\n+                                // When we know that a missing bound is responsible, we don't show\n+                                // this note as it is redundant.\n                                 err.note(&format!(\n                                     \"the trait `{}` is not implemented for `{}`\",\n                                     missing_trait, lhs_ty\n                                 ));\n                             }\n-                            suggest_constraining_param(\n-                                self.tcx,\n-                                self.body_id,\n-                                &mut err,\n-                                ty,\n-                                rhs_ty,\n-                                missing_trait,\n-                                p,\n-                                use_output,\n-                            );\n                         } else {\n                             bug!(\"type param visitor stored a non type param: {:?}\", ty.kind);\n                         }\n@@ -656,10 +664,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                     err.span_label(\n                         ex.span,\n-                        format!(\n-                            \"cannot apply unary operator `{}`\",\n-                            op.as_str()\n-                        ),\n+                        format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n                     match actual.kind {\n                         Uint(_) if op == hir::UnOp::UnNeg => {\n@@ -954,3 +959,21 @@ impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n         ty.super_visit_with(self)\n     }\n }\n+\n+struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n+\n+impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.0.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.kind {\n+            ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::MiscVariable,\n+                span: self.1,\n+            }),\n+            _ => ty.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "600cacc23aef5d1f24a51fba65c278f40722c621", "filename": "src/test/ui/issues/issue-35668.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35668.stderr?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -6,7 +6,6 @@ LL |     a.iter().map(|a| a*a)\n    |                      |\n    |                      &T\n    |\n-   = note: the trait `std::ops::Mul` is not implemented for `&T`\n help: consider restricting type parameter `T`\n    |\n LL | fn func<'a, T: std::ops::Mul<Output = &T>>(a: &'a [T]) -> impl Iterator<Item=&'a T> {"}, {"sha": "bea1b91558646a3d48283c052ca6b5a55fefa8cb", "filename": "src/test/ui/suggestions/invalid-bin-op.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.rs?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -0,0 +1,7 @@\n+pub fn foo<T>(s: S<T>, t: S<T>) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `S<T>`\n+}\n+\n+struct S<T>(T);\n+\n+fn main() {}"}, {"sha": "7668eddf6070ab102db3cf6fdc4d3c1cc29d86a0", "filename": "src/test/ui/suggestions/invalid-bin-op.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finvalid-bin-op.stderr?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -0,0 +1,13 @@\n+error[E0369]: binary operation `==` cannot be applied to type `S<T>`\n+  --> $DIR/invalid-bin-op.rs:2:15\n+   |\n+LL |     let _ = s == t;\n+   |             - ^^ - S<T>\n+   |             |\n+   |             S<T>\n+   |\n+   = note: the trait `std::cmp::PartialEq` is not implemented for `S<T>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "6b24375e41503cc5cb14801243ec85ad745ce6df", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.fixed", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.fixed?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -1,13 +1,7 @@\n // run-rustfix\n \n-pub fn strip_prefix<'a, T: std::cmp::PartialEq>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n-    let n = prefix.len();\n-    if n <= s.len() {\n-        let (head, tail) = s.split_at(n);\n-        if head == prefix { //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n-            return Some(tail);\n-        }\n-    }\n-    None\n+pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n }\n+\n fn main() {}"}, {"sha": "df47be070c9ea3fa0e03f2edd76d328ef3023eb7", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.rs?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -1,13 +1,7 @@\n // run-rustfix\n \n-pub fn strip_prefix<'a, T>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n-    let n = prefix.len();\n-    if n <= s.len() {\n-        let (head, tail) = s.split_at(n);\n-        if head == prefix { //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n-            return Some(tail);\n-        }\n-    }\n-    None\n+pub fn foo<T>(s: &[T], t: &[T]) {\n+    let _ = s == t; //~ ERROR binary operation `==` cannot be applied to type `&[T]`\n }\n+\n fn main() {}"}, {"sha": "0e0d397d6fc1546df01e12ca9fe47c06046d182d", "filename": "src/test/ui/suggestions/missing-trait-bound-for-op.stderr", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-bound-for-op.stderr?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -1,16 +1,15 @@\n error[E0369]: binary operation `==` cannot be applied to type `&[T]`\n-  --> $DIR/missing-trait-bound-for-op.rs:7:17\n+  --> $DIR/missing-trait-bound-for-op.rs:4:15\n    |\n-LL |         if head == prefix {\n-   |            ---- ^^ ------ &[T]\n-   |            |\n-   |            &[T]\n+LL |     let _ = s == t;\n+   |             - ^^ - &[T]\n+   |             |\n+   |             &[T]\n    |\n-   = note: the trait `std::cmp::PartialEq` is not implemented for `&[T]`\n help: consider restricting type parameter `T`\n    |\n-LL | pub fn strip_prefix<'a, T: std::cmp::PartialEq>(s: &'a [T], prefix: &[T]) -> Option<&'a [T]> {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^\n+LL | pub fn foo<T: std::cmp::PartialEq>(s: &[T], t: &[T]) {\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "507d53dc07c4c9e4d2684db8afee0dfb3be963cf", "filename": "src/test/ui/traits/trait-resolution-in-overloaded-op.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f40dae93b3a66a9cdd0f940244da7f602618fba/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-resolution-in-overloaded-op.stderr?ref=8f40dae93b3a66a9cdd0f940244da7f602618fba", "patch": "@@ -6,7 +6,6 @@ LL |     a * b\n    |     |\n    |     &T\n    |\n-   = note: the trait `std::ops::Mul` is not implemented for `&T`\n help: consider further restricting this bound\n    |\n LL | fn foo<T: MyMul<f64, f64> + std::ops::Mul<Output = f64>>(a: &T, b: f64) -> f64 {"}]}