{"sha": "5aa9f38285b47e2eadaaac0e343da90b922994f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYTlmMzgyODViNDdlMmVhZGFhYWMwZTM0M2RhOTBiOTIyOTk0ZjE=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-04-19T16:36:55Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-05-06T05:21:41Z"}, "message": "core: made the core formatter to use a new flt2dec.\n\nAs a side effect `core::fmt::float` is gone now. This also slightly\nchanges the float output, so this is:\n\n[breaking-change]", "tree": {"sha": "ab7ece9ffcdf1050596a6d5b299b9b2e833e858e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab7ece9ffcdf1050596a6d5b299b9b2e833e858e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aa9f38285b47e2eadaaac0e343da90b922994f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa9f38285b47e2eadaaac0e343da90b922994f1", "html_url": "https://github.com/rust-lang/rust/commit/5aa9f38285b47e2eadaaac0e343da90b922994f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aa9f38285b47e2eadaaac0e343da90b922994f1/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c82da7a54b9efb1a0ccbe11de66c71f547bf7db9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c82da7a54b9efb1a0ccbe11de66c71f547bf7db9", "html_url": "https://github.com/rust-lang/rust/commit/c82da7a54b9efb1a0ccbe11de66c71f547bf7db9"}], "stats": {"total": 457, "additions": 125, "deletions": 332}, "files": [{"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/c82da7a54b9efb1a0ccbe11de66c71f547bf7db9/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c82da7a54b9efb1a0ccbe11de66c71f547bf7db9/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c82da7a54b9efb1a0ccbe11de66c71f547bf7db9", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::ExponentFormat::*;\n-pub use self::SignificantDigits::*;\n-\n-use prelude::*;\n-\n-use char;\n-use fmt;\n-use num::Float;\n-use num::FpCategory as Fp;\n-use ops::{Div, Rem, Mul};\n-use slice;\n-use str;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-pub enum SignificantDigits {\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-#[doc(hidden)]\n-pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n-                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n-    fn from_u32(u: u32) -> Self;\n-    fn to_i32(&self) -> i32;\n-}\n-\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl MyFloat for $t {\n-        fn from_u32(u: u32) -> $t { u as $t }\n-        fn to_i32(&self) -> i32 { *self as i32 }\n-    })*)\n-}\n-doit! { f32 f64 }\n-\n-/// Converts a float number to its string representation.\n-/// This is meant to be a common base implementation for various formatting styles.\n-/// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n-/// to add the right sign, if any.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert (non-negative). Accepts any number that\n-///                     implements the numeric traits.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-/// - `f`             - A closure to invoke with the string representing the\n-///                     float.\n-///\n-/// # Panics\n-///\n-/// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n-    num: T,\n-    digits: SignificantDigits,\n-    exp_format: ExponentFormat,\n-    exp_upper: bool,\n-    f: F\n-) -> U where\n-    F: FnOnce(&str) -> U,\n-{\n-    let _0: T = T::zero();\n-    let _1: T = T::one();\n-    let radix: u32 = 10;\n-    let radix_f = T::from_u32(radix);\n-\n-    assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n-\n-    match num.classify() {\n-        Fp::Nan => return f(\"NaN\"),\n-        Fp::Infinite if num > _0 => {\n-            return f(\"inf\");\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return f(\"-inf\");\n-        }\n-        _ => {}\n-    }\n-\n-    // For an f64 the (decimal) exponent is roughly in the range of [-307, 308], so\n-    // we may have up to that many digits. We err on the side of caution and\n-    // add 50% extra wiggle room.\n-    let mut buf = [0; 462];\n-    let mut end = 0;\n-\n-    let (num, exp) = match exp_format {\n-        ExpDec if num != _0 => {\n-            let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), exp.to_i32())\n-        }\n-        _ => (num, 0)\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        let current_digit = deccum % radix_f;\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_f;\n-        deccum = deccum.trunc();\n-\n-        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-        buf[end] = c.unwrap() as u8;\n-        end += 1;\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigMax(count)   => (true, count + 1, false),\n-        DigExact(count) => (true, count + 1, true)\n-    };\n-\n-    buf[..end].reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = end;\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf[end] = b'.';\n-        end += 1;\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_f;\n-\n-            let current_digit = deccum.trunc();\n-\n-            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-            buf[end] = c.unwrap() as u8;\n-            end += 1;\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf[end - 1]);\n-            end -= 1;\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = end as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        for j in ((i + 1) as usize..end).rev() {\n-                            buf[j + 1] = buf[j];\n-                        }\n-                        buf[(i + 1) as usize] = value2ascii(1);\n-                        end += 1;\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = end - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                end = i + 1;\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = end - 1;\n-        if buf[max_i] == b'.' {\n-            end = max_i;\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => {},\n-        ExpDec => {\n-            buf[end] = if exp_upper { b'E' } else { b'e' };\n-            end += 1;\n-\n-            struct Filler<'a> {\n-                buf: &'a mut [u8],\n-                end: &'a mut usize,\n-            }\n-\n-            impl<'a> fmt::Write for Filler<'a> {\n-                fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(s.as_bytes(),\n-                                              &mut self.buf[(*self.end)..]);\n-                    *self.end += s.len();\n-                    Ok(())\n-                }\n-            }\n-\n-            let mut filler = Filler { buf: &mut buf, end: &mut end };\n-            let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n-        }\n-    }\n-\n-    f(unsafe { str::from_utf8_unchecked(&buf[..end]) })\n-}"}, {"sha": "a87f6619fe8772e7e36127d9b06f705856e0e8ac", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 125, "deletions": 43, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/5aa9f38285b47e2eadaaac0e343da90b922994f1/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aa9f38285b47e2eadaaac0e343da90b922994f1/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5aa9f38285b47e2eadaaac0e343da90b922994f1", "patch": "@@ -17,9 +17,9 @@ use prelude::*;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use marker::PhantomData;\n use mem;\n+use num::flt2dec;\n use ops::Deref;\n use result;\n-use num::Float;\n use slice;\n use str;\n use self::rt::v1::Alignment;\n@@ -31,7 +31,6 @@ pub use self::num::RadixFmt;\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n \n mod num;\n-mod float;\n mod builders;\n \n #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n@@ -604,6 +603,83 @@ impl<'a> Formatter<'a> {\n         Ok(())\n     }\n \n+    /// Takes the formatted parts and applies the padding.\n+    /// Assumes that the caller already has rendered the parts with required precision,\n+    /// so that `self.precision` can be ignored.\n+    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        if let Some(mut width) = self.width {\n+            // for the sign-aware zero padding, we render the sign first and\n+            // behave as if we had no sign from the beginning.\n+            let mut formatted = formatted.clone();\n+            let mut align = self.align;\n+            let old_fill = self.fill;\n+            if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 {\n+                // a sign always goes first\n+                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n+                try!(self.buf.write_str(sign));\n+\n+                // remove the sign from the formatted parts\n+                formatted.sign = b\"\";\n+                width = if width < sign.len() { 0 } else { width - sign.len() };\n+                align = Alignment::Right;\n+                self.fill = '0';\n+            }\n+\n+            // remaining parts go through the ordinary padding process.\n+            let len = formatted.len();\n+            let ret = if width <= len { // no padding\n+                self.write_formatted_parts(&formatted)\n+            } else {\n+                self.with_padding(width - len, align, |f| {\n+                    f.write_formatted_parts(&formatted)\n+                })\n+            };\n+            self.fill = old_fill;\n+            ret\n+        } else {\n+            // this is the common case and we take a shortcut\n+            self.write_formatted_parts(formatted)\n+        }\n+    }\n+\n+    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result {\n+            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n+        }\n+\n+        if !formatted.sign.is_empty() {\n+            try!(write_bytes(self.buf, formatted.sign));\n+        }\n+        for part in formatted.parts {\n+            match *part {\n+                flt2dec::Part::Zero(mut nzeroes) => {\n+                    const ZEROES: &'static str = // 64 zeroes\n+                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n+                    while nzeroes > ZEROES.len() {\n+                        try!(self.buf.write_str(ZEROES));\n+                        nzeroes -= ZEROES.len();\n+                    }\n+                    if nzeroes > 0 {\n+                        try!(self.buf.write_str(&ZEROES[..nzeroes]));\n+                    }\n+                }\n+                flt2dec::Part::Num(mut v) => {\n+                    let mut s = [0; 5];\n+                    let len = part.len();\n+                    for c in s[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                    try!(write_bytes(self.buf, &s[..len]));\n+                }\n+                flt2dec::Part::Copy(buf) => {\n+                    try!(write_bytes(self.buf, buf));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -918,73 +994,79 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n-                                             post: F) -> Result\n-        where F : FnOnce(&str) -> Result {\n-    let digits = match precision {\n-        Some(i) => float::DigExact(i),\n-        None => float::DigMax(6),\n+fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match (force_sign, negative_zero) {\n+        (false, false) => flt2dec::Sign::Minus,\n+        (false, true)  => flt2dec::Sign::MinusRaw,\n+        (true,  false) => flt2dec::Sign::MinusPlus,\n+        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+    };\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                    precision, false, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                 0, false, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n+}\n+\n+// Common code of floating point LowerExp and UpperExp.\n+fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match force_sign {\n+        false => flt2dec::Sign::Minus,\n+        true  => flt2dec::Sign::MinusPlus,\n     };\n-    float::float_to_str_bytes_common(num.abs(),\n-                                     digits,\n-                                     float::ExpNone,\n-                                     false,\n-                                     post)\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n+        flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                  precision + 1, upper, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                     (0, 0), upper, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n macro_rules! floating { ($ty:ident) => {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // is_positive() counts -0.0 as negative\n-                fmt.pad_integral(self.is_nan() || self.is_positive(), \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, true)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // simple comparison counts -0.0 as positive\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             false,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             true,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, true)\n         }\n     }\n } }"}]}