{"sha": "dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNmRiMTRlMWNkNjAwMTJmMjViZTRmZDhkMmViOTZlYTViNGJiNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T12:24:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T12:24:25Z"}, "message": "Auto merge of #61210 - Centril:rollup-ofr6h5b, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #61077 (Don't arena-allocate static symbols.)\n - #61102 (Move path for iterate)\n - #61120 (Make eval_place iterate instead of recurse)\n - #61205 (docs: fix typo #61197)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "073b67d138399a8e9557e33ebd52bdbec9242d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073b67d138399a8e9557e33ebd52bdbec9242d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "html_url": "https://github.com/rust-lang/rust/commit/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "566f3d7b0833f06ba12280aa6ef8802732fff5c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/566f3d7b0833f06ba12280aa6ef8802732fff5c0", "html_url": "https://github.com/rust-lang/rust/commit/566f3d7b0833f06ba12280aa6ef8802732fff5c0"}, {"sha": "e9933ee099042d005cdba395c1027802ba40cae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9933ee099042d005cdba395c1027802ba40cae9", "html_url": "https://github.com/rust-lang/rust/commit/e9933ee099042d005cdba395c1027802ba40cae9"}], "stats": {"total": 220, "additions": 109, "deletions": 111}, "files": [{"sha": "80ac405eb2f2a72d9d6bbcac0e1b15ce35e027c7", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "patch": "@@ -202,7 +202,7 @@ mod bar {\n Now we'll have a `Re-exports` line, and `Bar` will not link to anywhere.\n \n One special case: In Rust 2018 and later, if you `pub use` one of your dependencies, `rustdoc` will\n-not eagerly inline it as a module unless you add `#[doc(inline)}`.\n+not eagerly inline it as a module unless you add `#[doc(inline)]`.\n \n ## `#[doc(hidden)]`\n "}, {"sha": "ab0a2d87302c8fab064cecb9a3fde0f2f1dda68d", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 73, "deletions": 68, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "patch": "@@ -95,82 +95,87 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                      -> Result<MovePathIndex, MoveError<'tcx>>\n     {\n         debug!(\"lookup({:?})\", place);\n-        match *place {\n-            Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Base(PlaceBase::Static(..)) => {\n-                Err(MoveError::cannot_move_out_of(self.loc, Static))\n-            }\n-            Place::Projection(ref proj) => {\n-                self.move_path_for_projection(place, proj)\n+        place.iterate(|place_base, place_projection| {\n+            let mut base = match place_base {\n+                PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[*local],\n+                PlaceBase::Static(..) => {\n+                    return Err(MoveError::cannot_move_out_of(self.loc, Static));\n+                }\n+            };\n+\n+            for proj in place_projection {\n+                let mir = self.builder.mir;\n+                let tcx = self.builder.tcx;\n+                let place_ty = proj.base.ty(mir, tcx).ty;\n+                match place_ty.sty {\n+                    ty::Ref(..) | ty::RawPtr(..) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            BorrowedContent {\n+                                target_place: Place::Projection(Box::new(proj.clone())),\n+                            })),\n+                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                        return Err(MoveError::cannot_move_out_of(self.loc,\n+                                                                 InteriorOfTypeWithDestructor {\n+                            container_ty: place_ty\n+                        })),\n+                    // move out of union - always move the entire union\n+                    ty::Adt(adt, _) if adt.is_union() =>\n+                        return Err(MoveError::UnionMove { path: base }),\n+                    ty::Slice(_) =>\n+                        return Err(MoveError::cannot_move_out_of(\n+                            self.loc,\n+                            InteriorOfSliceOrArray {\n+                                ty: place_ty, is_index: match proj.elem {\n+                                    ProjectionElem::Index(..) => true,\n+                                    _ => false\n+                                },\n+                            })),\n+                    ty::Array(..) => match proj.elem {\n+                        ProjectionElem::Index(..) =>\n+                            return Err(MoveError::cannot_move_out_of(\n+                                self.loc,\n+                                InteriorOfSliceOrArray {\n+                                    ty: place_ty, is_index: true\n+                                })),\n+                        _ => {\n+                            // FIXME: still badly broken\n+                        }\n+                    },\n+                    _ => {}\n+                };\n+\n+                base = match self\n+                    .builder\n+                    .data\n+                    .rev_lookup\n+                    .projections\n+                    .entry((base, proj.elem.lift()))\n+                {\n+                    Entry::Occupied(ent) => *ent.get(),\n+                    Entry::Vacant(ent) => {\n+                        let path = MoveDataBuilder::new_move_path(\n+                            &mut self.builder.data.move_paths,\n+                            &mut self.builder.data.path_map,\n+                            &mut self.builder.data.init_path_map,\n+                            Some(base),\n+                            Place::Projection(Box::new(proj.clone())),\n+                        );\n+                        ent.insert(path);\n+                        path\n+                    }\n+                };\n             }\n-        }\n+\n+            Ok(base)\n+        })\n     }\n \n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n         let _ = self.move_path_for(place);\n     }\n-\n-    fn move_path_for_projection(&mut self,\n-                                place: &Place<'tcx>,\n-                                proj: &Projection<'tcx>)\n-                                -> Result<MovePathIndex, MoveError<'tcx>>\n-    {\n-        let base = self.move_path_for(&proj.base)?;\n-        let mir = self.builder.mir;\n-        let tcx = self.builder.tcx;\n-        let place_ty = proj.base.ty(mir, tcx).ty;\n-        match place_ty.sty {\n-            ty::Ref(..) | ty::RawPtr(..) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    BorrowedContent { target_place: place.clone() })),\n-            ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() =>\n-                return Err(MoveError::cannot_move_out_of(self.loc,\n-                                                         InteriorOfTypeWithDestructor {\n-                    container_ty: place_ty\n-                })),\n-            // move out of union - always move the entire union\n-            ty::Adt(adt, _) if adt.is_union() =>\n-                return Err(MoveError::UnionMove { path: base }),\n-            ty::Slice(_) =>\n-                return Err(MoveError::cannot_move_out_of(\n-                    self.loc,\n-                    InteriorOfSliceOrArray {\n-                        ty: place_ty, is_index: match proj.elem {\n-                            ProjectionElem::Index(..) => true,\n-                            _ => false\n-                        },\n-                    })),\n-            ty::Array(..) => match proj.elem {\n-                ProjectionElem::Index(..) =>\n-                    return Err(MoveError::cannot_move_out_of(\n-                        self.loc,\n-                        InteriorOfSliceOrArray {\n-                            ty: place_ty, is_index: true\n-                        })),\n-                _ => {\n-                    // FIXME: still badly broken\n-                }\n-            },\n-            _ => {}\n-        };\n-        match self.builder.data.rev_lookup.projections.entry((base, proj.elem.lift())) {\n-            Entry::Occupied(ent) => Ok(*ent.get()),\n-            Entry::Vacant(ent) => {\n-                let path = MoveDataBuilder::new_move_path(\n-                    &mut self.builder.data.move_paths,\n-                    &mut self.builder.data.path_map,\n-                    &mut self.builder.data.init_path_map,\n-                    Some(base),\n-                    place.clone()\n-                );\n-                ent.insert(path);\n-                Ok(path)\n-            }\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {"}, {"sha": "57d5ab71ecafd3922a6dda794f2bb5505ff87454", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "patch": "@@ -607,42 +607,42 @@ where\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n-        mir_place: &mir::Place<'tcx>\n+        mir_place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n-        let place = match mir_place {\n-            Base(PlaceBase::Local(mir::RETURN_PLACE)) => match self.frame().return_place {\n-                Some(return_place) =>\n-                    // We use our layout to verify our assumption; caller will validate\n-                    // their layout on return.\n-                    PlaceTy {\n-                        place: *return_place,\n-                        layout: self.layout_of(self.monomorphize(self.frame().mir.return_ty())?)?,\n+\n+        mir_place.iterate(|place_base, place_projection| {\n+            let mut place = match place_base {\n+                PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+                    Some(return_place) => {\n+                        // We use our layout to verify our assumption; caller will validate\n+                        // their layout on return.\n+                        PlaceTy {\n+                            place: *return_place,\n+                            layout: self\n+                                .layout_of(self.monomorphize(self.frame().mir.return_ty())?)?,\n+                        }\n+                    }\n+                    None => return err!(InvalidNullPointerUsage),\n+                },\n+                PlaceBase::Local(local) => PlaceTy {\n+                    // This works even for dead/uninitialized locals; we check further when writing\n+                    place: Place::Local {\n+                        frame: self.cur_frame(),\n+                        local: *local,\n                     },\n-                None => return err!(InvalidNullPointerUsage),\n-            },\n-            Base(PlaceBase::Local(local)) => PlaceTy {\n-                // This works even for dead/uninitialized locals; we check further when writing\n-                place: Place::Local {\n-                    frame: self.cur_frame(),\n-                    local: *local,\n+                    layout: self.layout_of_local(self.frame(), *local, None)?,\n                 },\n-                layout: self.layout_of_local(self.frame(), *local, None)?,\n-            },\n-\n-            Projection(proj) => {\n-                let place = self.eval_place(&proj.base)?;\n-                self.place_projection(place, &proj.elem)?\n-            }\n+                PlaceBase::Static(place_static) => self.eval_static_to_mplace(place_static)?.into(),\n+            };\n \n-            Base(PlaceBase::Static(place_static)) => {\n-                self.eval_static_to_mplace(place_static)?.into()\n+            for proj in place_projection {\n+                place = self.place_projection(place, &proj.elem)?\n             }\n-        };\n \n-        self.dump_place(place.place);\n-        Ok(place)\n+            self.dump_place(place.place);\n+            Ok(place)\n+        })\n     }\n \n     /// Write a scalar to a place"}, {"sha": "26422e891c53643846c5a095479022c6113982d5", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=dc6db14e1cd60012f25be4fd8d2eb96ea5b4bb68", "patch": "@@ -866,20 +866,13 @@ pub struct Interner {\n }\n \n impl Interner {\n-    fn prefill(init: &[&str]) -> Self {\n-        let mut this = Interner::default();\n-        this.names.reserve(init.len());\n-        this.strings.reserve(init.len());\n-\n-        // We can't allocate empty strings in the arena, so handle this here.\n-        assert!(kw::Invalid.as_u32() == 0 && init[0].is_empty());\n-        this.names.insert(\"\", kw::Invalid);\n-        this.strings.push(\"\");\n-\n-        for string in &init[1..] {\n-            this.intern(string);\n+    fn prefill(init: &[&'static str]) -> Self {\n+        let symbols = (0 .. init.len() as u32).map(Symbol::new);\n+        Interner {\n+            strings: init.to_vec(),\n+            names: init.iter().copied().zip(symbols).collect(),\n+            ..Default::default()\n         }\n-        this\n     }\n \n     pub fn intern(&mut self, string: &str) -> Symbol {"}]}