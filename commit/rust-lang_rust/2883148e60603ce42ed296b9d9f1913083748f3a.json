{"sha": "2883148e60603ce42ed296b9d9f1913083748f3a", "node_id": "C_kwDOAAsO6NoAKDI4ODMxNDhlNjA2MDNjZTQyZWQyOTZiOWQ5ZjE5MTMwODM3NDhmM2E", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2022-10-27T23:06:01Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-01-15T01:35:48Z"}, "message": "Special case deriving `PartialOrd` for certain enum layouts", "tree": {"sha": "36d6931538c17e172e13fbd1f0a594fd5248e78a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36d6931538c17e172e13fbd1f0a594fd5248e78a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2883148e60603ce42ed296b9d9f1913083748f3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2883148e60603ce42ed296b9d9f1913083748f3a", "html_url": "https://github.com/rust-lang/rust/commit/2883148e60603ce42ed296b9d9f1913083748f3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2883148e60603ce42ed296b9d9f1913083748f3a/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afaf3e07aaa7ca9873bdb439caec53faffa4230c", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaf3e07aaa7ca9873bdb439caec53faffa4230c", "html_url": "https://github.com/rust-lang/rust/commit/afaf3e07aaa7ca9873bdb439caec53faffa4230c"}], "stats": {"total": 133, "additions": 96, "deletions": 37}, "files": [{"sha": "be247d415c7fede890dfc61d38f6ffbc1389e6d7", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2883148e60603ce42ed296b9d9f1913083748f3a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2883148e60603ce42ed296b9d9f1913083748f3a/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=2883148e60603ce42ed296b9d9f1913083748f3a", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_std, pathvec_std};\n-use rustc_ast::MetaItem;\n+use rustc_ast::{ExprKind, ItemKind, MetaItem, PatKind};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -21,6 +21,27 @@ pub fn expand_deriving_partial_ord(\n \n     let attrs = thin_vec![cx.attr_word(sym::inline, span)];\n \n+    // Order in which to perform matching\n+    let tag_then_data = if let Annotatable::Item(item) = item\n+        && let ItemKind::Enum(def, _) = &item.kind {\n+            let dataful: Vec<bool> = def.variants.iter().map(|v| !v.data.fields().is_empty()).collect();\n+            match dataful.iter().filter(|&&b| b).count() {\n+                // No data, placing the tag check first makes codegen simpler\n+                0 => true,\n+                1..=2 => false,\n+                _ => {\n+                    (0..dataful.len()-1).any(|i| {\n+                        if dataful[i] && let Some(idx) = dataful[i+1..].iter().position(|v| *v) {\n+                            idx >= 2\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                }\n+            }\n+        } else {\n+            true\n+        };\n     let partial_cmp_def = MethodDef {\n         name: sym::partial_cmp,\n         generics: Bounds::empty(),\n@@ -30,7 +51,7 @@ pub fn expand_deriving_partial_ord(\n         attributes: attrs,\n         unify_fieldless_variants: true,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-            cs_partial_cmp(cx, span, substr)\n+            cs_partial_cmp(cx, span, substr, tag_then_data)\n         })),\n     };\n \n@@ -47,7 +68,12 @@ pub fn expand_deriving_partial_ord(\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n+fn cs_partial_cmp(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    substr: &Substructure<'_>,\n+    tag_then_data: bool,\n+) -> BlockOrExpr {\n     let test_id = Ident::new(sym::cmp, span);\n     let equal_path = cx.path_global(span, cx.std_path(&[sym::cmp, sym::Ordering, sym::Equal]));\n     let partial_cmp_path = cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n@@ -74,12 +100,50 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 let args = vec![field.self_expr.clone(), other_expr.clone()];\n                 cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n-            CsFold::Combine(span, expr1, expr2) => {\n-                let eq_arm =\n-                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n-                let neq_arm =\n-                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+            CsFold::Combine(span, mut expr1, expr2) => {\n+                // When the item is an enum, this expands to\n+                // ```\n+                // match (expr2) {\n+                //     Some(Ordering::Equal) => expr1,\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // where `expr2` is `partial_cmp(self_tag, other_tag)`, and `expr1` is a `match`\n+                //  against the enum variants. This means that we begin by comparing the enum tags,\n+                // before either inspecting their contents (if they match), or returning\n+                // the `cmp::Ordering` of comparing the enum tags.\n+                // ```\n+                // match partial_cmp(self_tag, other_tag) {\n+                //     Some(Ordering::Equal) => match (self, other)  {\n+                //         (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //         (Self::B(self_0), Self::B(other_0)) => partial_cmp(self_0, other_0),\n+                //         _ => Some(Ordering::Equal)\n+                //     }\n+                //     cmp => cmp\n+                // }\n+                // ```\n+                // If we have any certain enum layouts, flipping this results in better codegen\n+                // ```\n+                // match (self, other) {\n+                //     (Self::A(self_0), Self::A(other_0)) => partial_cmp(self_0, other_0),\n+                //     _ => partial_cmp(self_tag, other_tag)\n+                // }\n+                // ```\n+                // Reference: https://github.com/rust-lang/rust/pull/103659#issuecomment-1328126354\n+\n+                if !tag_then_data\n+                    && let ExprKind::Match(_, arms) = &mut expr1.kind\n+                    && let Some(last) = arms.last_mut()\n+                    && let PatKind::Wild = last.pat.kind {\n+                        last.body = expr2;\n+                        expr1\n+                } else {\n+                    let eq_arm =\n+                        cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                    let neq_arm =\n+                        cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                    cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n+                }\n             }\n             CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n         },"}, {"sha": "49671be18c587877c819ed2afab037e00035b709", "filename": "tests/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2883148e60603ce42ed296b9d9f1913083748f3a/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2883148e60603ce42ed296b9d9f1913083748f3a/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=2883148e60603ce42ed296b9d9f1913083748f3a", "patch": "@@ -888,23 +888,20 @@ impl ::core::cmp::PartialOrd for Mixed {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n-            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match (self, other) {\n-                    (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n-                        d1: __arg1_0, d2: __arg1_1 }) =>\n-                        match ::core::cmp::PartialOrd::partial_cmp(__self_0,\n-                                __arg1_0) {\n-                            ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n-                                => ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1),\n-                            cmp => cmp,\n-                        },\n-                    _ =>\n-                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n+        match (self, other) {\n+            (Mixed::R(__self_0), Mixed::R(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                d1: __arg1_0, d2: __arg1_1 }) =>\n+                match ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)\n+                    {\n+                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n+                        => ::core::cmp::PartialOrd::partial_cmp(__self_1, __arg1_1),\n+                    cmp => cmp,\n                 },\n-            cmp => cmp,\n+            _ =>\n+                ::core::cmp::PartialOrd::partial_cmp(&__self_tag,\n+                    &__arg1_tag),\n         }\n     }\n }\n@@ -1018,18 +1015,16 @@ impl ::core::cmp::PartialOrd for Fielded {\n         -> ::core::option::Option<::core::cmp::Ordering> {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n         let __arg1_tag = ::core::intrinsics::discriminant_value(other);\n-        match ::core::cmp::PartialOrd::partial_cmp(&__self_tag, &__arg1_tag) {\n-            ::core::option::Option::Some(::core::cmp::Ordering::Equal) =>\n-                match (self, other) {\n-                    (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n-                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n-                    _ => unsafe { ::core::intrinsics::unreachable() }\n-                },\n-            cmp => cmp,\n+        match (self, other) {\n+            (Fielded::X(__self_0), Fielded::X(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Fielded::Y(__self_0), Fielded::Y(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            (Fielded::Z(__self_0), Fielded::Z(__arg1_0)) =>\n+                ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),\n+            _ =>\n+                ::core::cmp::PartialOrd::partial_cmp(&__self_tag,\n+                    &__arg1_tag),\n         }\n     }\n }"}]}