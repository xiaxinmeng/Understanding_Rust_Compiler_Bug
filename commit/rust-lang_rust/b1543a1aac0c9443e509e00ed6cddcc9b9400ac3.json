{"sha": "b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNTQzYTFhYWMwYzk0NDNlNTA5ZTAwZWQ2Y2RkY2M5Yjk0MDBhYzM=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-31T16:15:54Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-02T10:00:55Z"}, "message": "Make the rendering process less pass-aware\n\nInstead of hardcoding knowledge about the strip-private pass into the\nrendering process we represent (some) stripped items as `ItemEnum::StrippedItem`.\n\nRustdoc will, for example, generate redirect pages for public items\ncontained in private modules which have been re-exported to somewhere\nexternally reachable - this will now not only work for the `strip-private`\npass, but for other passes as well, such as the `strip-hidden` pass.", "tree": {"sha": "4c9a10f50e88de9245f67df87d721045a0f79136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c9a10f50e88de9245f67df87d721045a0f79136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "html_url": "https://github.com/rust-lang/rust/commit/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4583dc9b13f8a46b10bcc8eb4483080b9736cdd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4583dc9b13f8a46b10bcc8eb4483080b9736cdd2", "html_url": "https://github.com/rust-lang/rust/commit/4583dc9b13f8a46b10bcc8eb4483080b9736cdd2"}], "stats": {"total": 390, "additions": 244, "deletions": 146}, "files": [{"sha": "9c60b90a1fcf5f5ac382fad6a84fbfd5db5940ad", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -53,6 +53,7 @@ use std::env::current_dir;\n use core::DocContext;\n use doctree;\n use visit_ast;\n+use html::item_type::ItemType;\n \n /// A stable identifier to the particular version of JSON output.\n /// Increment this when the `Crate` and related structures change.\n@@ -273,36 +274,40 @@ impl Item {\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n-            ModuleItem(Module { items: _, is_crate: true }) => true,\n-            _ => false\n+            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n+            ModuleItem(Module { is_crate: true, ..}) => true,\n+            _ => false,\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        match self.inner { ModuleItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        match self.inner { TraitItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        match self.inner { StructItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        match self.inner { EnumItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        match self.inner { FunctionItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        match self.inner { AssociatedTypeItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        match self.inner { AssociatedConstItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        match self.inner { MethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        match self.inner { TyMethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::TyMethod\n+    }\n+    pub fn is_stripped(&self) -> bool {\n+        match self.inner { StrippedItem(..) => true, _ => false }\n     }\n \n     pub fn stability_class(&self) -> String {\n@@ -352,6 +357,8 @@ pub enum ItemEnum {\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n+    /// An item that has been stripped by a rustdoc pass\n+    StrippedItem(Box<ItemEnum>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "5595c749256dfc7971a46edbd2b42c3b36806b7d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -10,28 +10,50 @@\n \n use clean::*;\n \n+pub enum FoldItem {\n+    Retain(Item),\n+    Strip(Item),\n+    Erase,\n+}\n+\n+impl FoldItem {\n+    pub fn fold(self) -> Option<Item> {\n+        match self {\n+            FoldItem::Erase => None,\n+            FoldItem::Retain(i) => Some(i),\n+            FoldItem::Strip(item@ Item { inner: StrippedItem(..), .. } ) => Some(item),\n+            FoldItem::Strip(mut i) => {\n+                i.inner = StrippedItem(box i.inner);\n+                Some(i)\n+            }\n+        }\n+    }\n+}\n+\n pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }\n \n     /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n-        let inner = match inner {\n+    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n+        match inner {\n+            StrippedItem(..) => unreachable!(),\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n             StructItem(mut i) => {\n                 let num_fields = i.fields.len();\n                 i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.fields_stripped |= num_fields != i.fields.len();\n+                i.fields_stripped |= num_fields != i.fields.len() ||\n+                                     i.fields.iter().any(|f| f.is_stripped());\n                 StructItem(i)\n             },\n-            ModuleItem(i) => {\n-                ModuleItem(self.fold_mod(i))\n-            },\n             EnumItem(mut i) => {\n                 let num_variants = i.variants.len();\n                 i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.variants_stripped |= num_variants != i.variants.len();\n+                i.variants_stripped |= num_variants != i.variants.len() ||\n+                                       i.variants.iter().any(|f| f.is_stripped());\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n@@ -48,13 +70,24 @@ pub trait DocFolder : Sized {\n                     StructVariant(mut j) => {\n                         let num_fields = j.fields.len();\n                         j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        j.fields_stripped |= num_fields != j.fields.len();\n+                        j.fields_stripped |= num_fields != j.fields.len() ||\n+                                             j.fields.iter().any(|f| f.is_stripped());\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n                     _ => VariantItem(i2)\n                 }\n             },\n             x => x\n+        }\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+\n+        let inner = match inner {\n+            StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n+            _ => self.fold_inner_recur(inner),\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n@@ -70,9 +103,8 @@ pub trait DocFolder : Sized {\n     }\n \n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = c.module.and_then(|module| {\n-            self.fold_item(module)\n-        });\n+        c.module = c.module.and_then(|module| self.fold_item(module));\n+\n         c.external_traits = c.external_traits.into_iter().map(|(k, mut v)| {\n             v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n             (k, v)"}, {"sha": "74f7b099044f16b3700faf88061e6567ae82cb87", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -44,7 +44,12 @@ pub enum ItemType {\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n-        match item.inner {\n+        let inner = match item.inner {\n+            clean::StrippedItem(box ref item) => item,\n+            ref inner@_ => inner,\n+        };\n+\n+        match *inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n             clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n             clean::ImportItem(..)          => ItemType::Import,\n@@ -67,6 +72,7 @@ impl ItemType {\n             clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n+            clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n "}, {"sha": "782b3cc52e82d684fe4258ec7597ae9129140ed4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 84, "deletions": 100, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -245,8 +245,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    privmod: bool,\n-    remove_priv: bool,\n+    stripped_mod: bool,\n     access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n@@ -492,8 +491,7 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n-        remove_priv: cx.passes.contains(\"strip-private\"),\n-        privmod: false,\n+        stripped_mod: false,\n         access_levels: access_levels,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n@@ -874,7 +872,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                 }\n             };\n         }\n-\n         self.fold_item_recur(item)\n     }\n }\n@@ -938,14 +935,15 @@ impl<'a> SourceCollector<'a> {\n \n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If this is a private module, we don't want it in the search index.\n-        let orig_privmod = match item.inner {\n-            clean::ModuleItem(..) => {\n-                let prev = self.privmod;\n-                self.privmod = prev || (self.remove_priv && item.visibility != Some(hir::Public));\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                let prev = self.stripped_mod;\n+                self.stripped_mod = true;\n                 prev\n             }\n-            _ => self.privmod,\n+            _ => self.stripped_mod,\n         };\n \n         // Register any generics to their corresponding string. This is used\n@@ -983,6 +981,7 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssociatedConstItem(..) |\n                 clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n                     // skip associated items in trait impls\n@@ -1027,14 +1026,15 @@ impl DocFolder for Cache {\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                (parent, Some(path)) if is_method || (!self.stripped_mod && !hidden_field) => {\n                     // Needed to determine `self` type.\n                     let parent_basename = self.parent_stack.first().and_then(|parent| {\n                         match self.paths.get(parent) {\n                             Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n                             _ => None\n                         }\n                     });\n+                    debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n@@ -1051,7 +1051,7 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n+                (Some(parent), None) if is_method || (!self.stripped_mod && !hidden_field)=> {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n@@ -1075,7 +1075,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) if !self.privmod => {\n+            clean::ForeignFunctionItem(..) if !self.stripped_mod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -1093,7 +1093,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) if !self.privmod => {\n+            clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, ItemType::Enum));\n@@ -1176,7 +1176,7 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.privmod = orig_privmod;\n+        self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;\n     }\n@@ -1233,15 +1233,12 @@ impl Context {\n \n         // render the crate documentation\n         let mut work = vec!((self, item));\n-        loop {\n-            match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n-                    work.push((cx.clone(), item));\n-                })?,\n-                None => break,\n-            }\n-        }\n \n+        while let Some((mut cx, item)) = work.pop() {\n+            cx.item(item, |cx, item| {\n+                work.push((cx.clone(), item))\n+            })?\n+        }\n         Ok(())\n     }\n \n@@ -1296,87 +1293,80 @@ impl Context {\n                 layout::render(&mut writer, &cx.layout, &page,\n                                &Sidebar{ cx: cx, item: it },\n                                &Item{ cx: cx, item: it })?;\n+\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n-                match cache().paths.get(&it.def_id) {\n-                    Some(&(ref names, _)) => {\n-                        for name in &names[..names.len() - 1] {\n-                            url.push_str(name);\n-                            url.push_str(\"/\");\n-                        }\n-                        url.push_str(&item_path(it));\n-                        layout::redirect(&mut writer, &url)?;\n+                if let Some(&(ref names, _)) = cache().paths.get(&it.def_id) {\n+                    for name in &names[..names.len() - 1] {\n+                        url.push_str(name);\n+                        url.push_str(\"/\");\n                     }\n-                    None => {}\n+                    url.push_str(&item_path(it));\n+                    layout::redirect(&mut writer, &url)?;\n                 }\n             }\n             writer.flush()\n         }\n \n-        // Private modules may survive the strip-private pass if they\n-        // contain impls for public types. These modules can also\n+        // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n+        // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n         //\n         // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally (a\n-        // flag on the context).\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.ignore_private_item(&item);\n+            self.render_redirect_pages = self.maybe_ignore_item(&item);\n         }\n \n-        match item.inner {\n+        if item.is_mod() {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n-            clean::ModuleItem(..) => {\n-                let name = item.name.as_ref().unwrap().to_string();\n-                let mut item = Some(item);\n-                self.recurse(name, |this| {\n-                    let item = item.take().unwrap();\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                    try_err!(render(dst, this, &item, false), &joint_dst);\n-\n-                    let m = match item.inner {\n-                        clean::ModuleItem(m) => m,\n-                        _ => unreachable!()\n-                    };\n-\n-                    // render sidebar-items.js used throughout this module\n-                    {\n-                        let items = this.build_sidebar_items(&m);\n-                        let js_dst = this.dst.join(\"sidebar-items.js\");\n-                        let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                        try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    }\n+            let name = item.name.as_ref().unwrap().to_string();\n+            let mut item = Some(item);\n+            self.recurse(name, |this| {\n+                let item = item.take().unwrap();\n+                let joint_dst = this.dst.join(\"index.html\");\n+                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                try_err!(render(dst, this, &item, false), &joint_dst);\n \n-                    for item in m.items {\n-                        f(this,item);\n-                    }\n-                    Ok(())\n-                })\n-            }\n+                let m = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) |\n+                    clean::ModuleItem(m) => m,\n+                    _ => unreachable!()\n+                };\n \n-            // Things which don't have names (like impls) don't get special\n-            // pages dedicated to them.\n-            _ if item.name.is_some() => {\n-                let joint_dst = self.dst.join(&item_path(&item));\n+                // render sidebar-items.js used throughout this module\n+                {\n+                    let items = this.build_sidebar_items(&m);\n+                    let js_dst = this.dst.join(\"sidebar-items.js\");\n+                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n+                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                                    as_json(&items)), &js_dst);\n+                }\n \n-                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                try_err!(render(dst, self, &item, true), &joint_dst);\n+                for item in m.items {\n+                    f(this,item);\n+                }\n                 Ok(())\n-            }\n+            })\n+        } else if item.name.is_some() {\n+            let joint_dst = self.dst.join(&item_path(&item));\n \n-            _ => Ok(())\n+            let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+            try_err!(render(dst, self, &item, true), &joint_dst);\n+            Ok(())\n+        } else {\n+            Ok(())\n         }\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.ignore_private_item(item) { continue }\n+            if self.maybe_ignore_item(item) { continue }\n \n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n@@ -1394,27 +1384,18 @@ impl Context {\n         return map;\n     }\n \n-    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n+            clean::StrippedItem(..) => true,\n             clean::ModuleItem(ref m) => {\n-                (m.items.is_empty() &&\n-                 it.doc_value().is_none() &&\n-                 it.visibility != Some(hir::Public)) ||\n-                (self.passes.contains(\"strip-private\") && it.visibility != Some(hir::Public))\n-            }\n-            clean::PrimitiveItem(..) => it.visibility != Some(hir::Public),\n+                it.doc_value().is_none() && m.items.is_empty() && it.visibility != Some(hir::Public)\n+            },\n             _ => false,\n         }\n     }\n }\n \n impl<'a> Item<'a> {\n-    fn ismodule(&self) -> bool {\n-        match self.item.inner {\n-            clean::ModuleItem(..) => true, _ => false\n-        }\n-    }\n-\n     /// Generate a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1495,6 +1476,7 @@ impl<'a> Item<'a> {\n \n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n@@ -1516,7 +1498,7 @@ impl<'a> fmt::Display for Item<'a> {\n         };\n         if !is_primitive {\n             let cur = &self.cx.current;\n-            let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n+            let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                        repeat(\"../\").take(cur.len() - i - 1)\n@@ -1575,15 +1557,12 @@ impl<'a> fmt::Display for Item<'a> {\n }\n \n fn item_path(item: &clean::Item) -> String {\n-    match item.inner {\n-        clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n-        }\n-        _ => {\n-            format!(\"{}.{}.html\",\n-                    shortty(item).to_static_str(),\n-                    *item.name.as_ref().unwrap())\n-        }\n+    if item.is_mod() {\n+        format!(\"{}/index.html\", item.name.as_ref().unwrap())\n+    } else {\n+        format!(\"{}.{}.html\",\n+                shortty(item).to_static_str(),\n+                *item.name.as_ref().unwrap())\n     }\n }\n \n@@ -1626,7 +1605,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n-        !cx.ignore_private_item(&items[*i])\n+        !cx.maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1670,6 +1649,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     let mut curty = None;\n     for &idx in &indices {\n         let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n \n         let myty = Some(shortty(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n@@ -2146,6 +2128,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n+        clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n@@ -2540,6 +2523,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 assoc_type(w, item, bounds, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n+            clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n "}, {"sha": "06d84fc8822ed70c17c23f12898a42d27f9ca743", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -21,6 +21,7 @@ use clean::Item;\n use plugins;\n use fold;\n use fold::DocFolder;\n+use fold::FoldItem::Strip;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n@@ -45,12 +46,10 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                                 ..i\n                             });\n                         }\n-                        _ => {\n-                            return None;\n-                        }\n+                        clean::ModuleItem(..) => return Strip(i).fold(),\n+                        _ => return None,\n                     }\n                 }\n-\n                 self.fold_item_recur(i)\n             }\n         }\n@@ -125,6 +124,7 @@ struct Stripper<'a> {\n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n+            clean::StrippedItem(..) => return Some(i),\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n@@ -153,8 +153,11 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n \n-            // handled below\n-            clean::ModuleItem(..) => {}\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(hir::Public) {\n+                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                }\n+            }\n \n             // trait impls for private items should be stripped\n             clean::ImplItem(clean::Impl{\n@@ -165,7 +168,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(_) => {}\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n             clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n \n@@ -187,7 +190,6 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-\n             // Struct variant fields have inherited visibility\n             clean::VariantItem(clean::Variant {\n                 kind: clean::StructVariant(..)\n@@ -202,19 +204,17 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules/impls have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                _ => {\n-                    self.retained.insert(i.def_id);\n-                    Some(i)\n-                }\n+        i.and_then(|i| { match i.inner {\n+            // emptied modules/impls have no need to exist\n+            clean::ModuleItem(ref m)\n+                if m.items.is_empty() &&\n+                   i.doc_value().is_none() => None,\n+            clean::ImplItem(ref i) if i.items.is_empty() => None,\n+            _ => {\n+                self.retained.insert(i.def_id);\n+                Some(i)\n             }\n-        })\n+        }})\n     }\n }\n "}, {"sha": "5bd3b9c4f59e706448321db39f9bc58d32ec38e9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -431,7 +431,7 @@ impl Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n             },\n-            testfn: testing::DynTestFn(Box::new(move|| {\n+            testfn: testing::DynTestFn(box move|| {\n                 runtest(&test,\n                         &cratename,\n                         cfgs,\n@@ -442,7 +442,7 @@ impl Collector {\n                         as_test_harness,\n                         compile_fail,\n                         &opts);\n-            }))\n+            })\n         });\n     }\n "}, {"sha": "2b061e3997d844b99bb4458e52fdf685da49739c", "filename": "src/test/auxiliary/reexp_stripped.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use private::Quz;\n+pub use hidden::Bar;\n+\n+mod private {\n+    pub struct Quz;\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Bar;\n+}"}, {"sha": "98e66e8c024bd3a49d48e574aa265db506cdba6b", "filename": "src/test/rustdoc/redirect.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Ftest%2Frustdoc%2Fredirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1543a1aac0c9443e509e00ed6cddcc9b9400ac3/src%2Ftest%2Frustdoc%2Fredirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fredirect.rs?ref=b1543a1aac0c9443e509e00ed6cddcc9b9400ac3", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reexp_stripped.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate reexp_stripped;\n+\n+pub trait Foo {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Bar'\n+// @has - '//code/a' 'Bar'\n+// @has reexp_stripped/hidden/struct.Bar.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Bar.html'\n+// @has 'reexp_stripped/struct.Bar.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Bar;\n+impl Foo for Bar {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Quz'\n+// @has - '//code/a' 'Quz'\n+// @has reexp_stripped/private/struct.Quz.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Quz.html'\n+// @has 'reexp_stripped/struct.Quz.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Quz;\n+impl Foo for Quz {}\n+\n+mod private_no_inline {\n+    pub struct Qux;\n+    impl ::Foo for Qux {}\n+}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use private_no_inline::Qux'\n+// @!has - '//code/a' 'Qux'\n+#[doc(no_inline)]\n+pub use private_no_inline::Qux;"}]}