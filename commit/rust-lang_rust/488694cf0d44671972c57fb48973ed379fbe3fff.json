{"sha": "488694cf0d44671972c57fb48973ed379fbe3fff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ODY5NGNmMGQ0NDY3MTk3MmM1N2ZiNDg5NzNlZDM3OWZiZTNmZmY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T04:00:47Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract namespace.rs", "tree": {"sha": "2aba1f6bc0fc41d2ddd4cd7683900a3c83693291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aba1f6bc0fc41d2ddd4cd7683900a3c83693291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/488694cf0d44671972c57fb48973ed379fbe3fff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/488694cf0d44671972c57fb48973ed379fbe3fff", "html_url": "https://github.com/rust-lang/rust/commit/488694cf0d44671972c57fb48973ed379fbe3fff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/488694cf0d44671972c57fb48973ed379fbe3fff/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b53de17752a11c52679dca46e8a4b4ea3fe1354", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b53de17752a11c52679dca46e8a4b4ea3fe1354", "html_url": "https://github.com/rust-lang/rust/commit/5b53de17752a11c52679dca46e8a4b4ea3fe1354"}], "stats": {"total": 256, "additions": 139, "deletions": 117}, "files": [{"sha": "ea0bbfd73ae25875f53772542b623a3b8f95060a", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 116, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=488694cf0d44671972c57fb48973ed379fbe3fff", "patch": "@@ -14,11 +14,13 @@ mod doc;\n pub mod gdb;\n mod utils;\n mod create;\n+mod namespace;\n \n use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                   assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n                   contains_nodebug_attribute, create_scope_map};\n use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n+use self::namespace::{namespace_for_item, NamespaceTreeNode, crate_root_namespace};\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n@@ -51,7 +53,7 @@ use std::cell::{Cell, RefCell};\n use std::ffi::CString;\n use std::path::Path;\n use std::ptr;\n-use std::rc::{Rc, Weak};\n+use std::rc::Rc;\n use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap, ast_util, ast_map};\n@@ -3103,118 +3105,3 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         output.push('>');\n     }\n }\n-\n-\n-//=-----------------------------------------------------------------------------\n-// Namespace Handling\n-//=-----------------------------------------------------------------------------\n-\n-struct NamespaceTreeNode {\n-    name: ast::Name,\n-    scope: DIScope,\n-    parent: Option<Weak<NamespaceTreeNode>>,\n-}\n-\n-impl NamespaceTreeNode {\n-    fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n-        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n-            match node.parent {\n-                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n-                None => {}\n-            }\n-            let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.len()));\n-            output.push_str(&string);\n-        }\n-\n-        let mut name = String::from_str(\"_ZN\");\n-        fill_nested(self, &mut name);\n-        name.push_str(&format!(\"{}\", item_name.len()));\n-        name.push_str(item_name);\n-        name.push('E');\n-        name\n-    }\n-}\n-\n-fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    &cx.link_meta().crate_name\n-}\n-\n-fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n-    ty::with_path(cx.tcx(), def_id, |path| {\n-        // prepend crate name if not already present\n-        let krate = if def_id.krate == ast::LOCAL_CRATE {\n-            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n-            Some(ast_map::PathMod(crate_namespace_name))\n-        } else {\n-            None\n-        };\n-        let mut path = krate.into_iter().chain(path).peekable();\n-\n-        let mut current_key = Vec::new();\n-        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n-\n-        // Create/Lookup namespace for each element of the path.\n-        loop {\n-            // Emulate a for loop so we can use peek below.\n-            let path_element = match path.next() {\n-                Some(e) => e,\n-                None => break\n-            };\n-            // Ignore the name of the item (the last path element).\n-            if path.peek().is_none() {\n-                break;\n-            }\n-\n-            let name = path_element.name();\n-            current_key.push(name);\n-\n-            let existing_node = debug_context(cx).namespace_map.borrow()\n-                                                 .get(&current_key).cloned();\n-            let current_node = match existing_node {\n-                Some(existing_node) => existing_node,\n-                None => {\n-                    // create and insert\n-                    let parent_scope = match parent_node {\n-                        Some(ref node) => node.scope,\n-                        None => ptr::null_mut()\n-                    };\n-                    let namespace_name = token::get_name(name);\n-                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n-                    let scope = unsafe {\n-                        llvm::LLVMDIBuilderCreateNameSpace(\n-                            DIB(cx),\n-                            parent_scope,\n-                            namespace_name.as_ptr(),\n-                            // cannot reconstruct file ...\n-                            ptr::null_mut(),\n-                            // ... or line information, but that's not so important.\n-                            0)\n-                    };\n-\n-                    let node = Rc::new(NamespaceTreeNode {\n-                        name: name,\n-                        scope: scope,\n-                        parent: parent_node.map(|parent| parent.downgrade()),\n-                    });\n-\n-                    debug_context(cx).namespace_map.borrow_mut()\n-                                     .insert(current_key.clone(), node.clone());\n-\n-                    node\n-                }\n-            };\n-\n-            parent_node = Some(current_node);\n-        }\n-\n-        match parent_node {\n-            Some(node) => node,\n-            None => {\n-                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n-                                       path too short for {:?}\",\n-                                      def_id));\n-            }\n-        }\n-    })\n-}"}, {"sha": "1300a20391834c1fa47f249591e1c9804ba0a8e5", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=488694cf0d44671972c57fb48973ed379fbe3fff", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Namespace Handling\n+\n+use super::utils::{DIB, debug_context};\n+\n+use llvm;\n+use llvm::debuginfo::DIScope;\n+use trans::common::CrateContext;\n+use middle::ty::{self, ClosureTyper};\n+\n+use std::ffi::CString;\n+use std::ptr;\n+use std::rc::{Rc, Weak};\n+use syntax::{ast, ast_map};\n+use syntax::parse::token;\n+\n+pub struct NamespaceTreeNode {\n+    pub name: ast::Name,\n+    pub scope: DIScope,\n+    pub parent: Option<Weak<NamespaceTreeNode>>,\n+}\n+\n+impl NamespaceTreeNode {\n+    pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n+            match node.parent {\n+                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                None => {}\n+            }\n+            let string = token::get_name(node.name);\n+            output.push_str(&format!(\"{}\", string.len()));\n+            output.push_str(&string);\n+        }\n+\n+        let mut name = String::from_str(\"_ZN\");\n+        fill_nested(self, &mut name);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n+        name.push_str(item_name);\n+        name.push('E');\n+        name\n+    }\n+}\n+\n+pub fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n+    &cx.link_meta().crate_name\n+}\n+\n+pub fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n+        // prepend crate name if not already present\n+        let krate = if def_id.krate == ast::LOCAL_CRATE {\n+            let crate_namespace_name = token::intern(crate_root_namespace(cx));\n+            Some(ast_map::PathMod(crate_namespace_name))\n+        } else {\n+            None\n+        };\n+        let mut path = krate.into_iter().chain(path).peekable();\n+\n+        let mut current_key = Vec::new();\n+        let mut parent_node: Option<Rc<NamespaceTreeNode>> = None;\n+\n+        // Create/Lookup namespace for each element of the path.\n+        loop {\n+            // Emulate a for loop so we can use peek below.\n+            let path_element = match path.next() {\n+                Some(e) => e,\n+                None => break\n+            };\n+            // Ignore the name of the item (the last path element).\n+            if path.peek().is_none() {\n+                break;\n+            }\n+\n+            let name = path_element.name();\n+            current_key.push(name);\n+\n+            let existing_node = debug_context(cx).namespace_map.borrow()\n+                                                 .get(&current_key).cloned();\n+            let current_node = match existing_node {\n+                Some(existing_node) => existing_node,\n+                None => {\n+                    // create and insert\n+                    let parent_scope = match parent_node {\n+                        Some(ref node) => node.scope,\n+                        None => ptr::null_mut()\n+                    };\n+                    let namespace_name = token::get_name(name);\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n+                    let scope = unsafe {\n+                        llvm::LLVMDIBuilderCreateNameSpace(\n+                            DIB(cx),\n+                            parent_scope,\n+                            namespace_name.as_ptr(),\n+                            // cannot reconstruct file ...\n+                            ptr::null_mut(),\n+                            // ... or line information, but that's not so important.\n+                            0)\n+                    };\n+\n+                    let node = Rc::new(NamespaceTreeNode {\n+                        name: name,\n+                        scope: scope,\n+                        parent: parent_node.map(|parent| parent.downgrade()),\n+                    });\n+\n+                    debug_context(cx).namespace_map.borrow_mut()\n+                                     .insert(current_key.clone(), node.clone());\n+\n+                    node\n+                }\n+            };\n+\n+            parent_node = Some(current_node);\n+        }\n+\n+        match parent_node {\n+            Some(node) => node,\n+            None => {\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n+                                       path too short for {:?}\",\n+                                      def_id));\n+            }\n+        }\n+    })\n+}"}, {"sha": "858fb2be4f7424911f2eaab5cc8c1f0437ca11fa", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/488694cf0d44671972c57fb48973ed379fbe3fff/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=488694cf0d44671972c57fb48973ed379fbe3fff", "patch": "@@ -10,7 +10,8 @@\n \n // Utility Functions.\n \n-use super::{FunctionDebugContext, CrateDebugContext, namespace_for_item, file_metadata};\n+use super::{FunctionDebugContext, CrateDebugContext, file_metadata};\n+use super::namespace::namespace_for_item;\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram, DIBuilderRef};"}]}