{"sha": "3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYzJjYTdlNGY4NTA3ZjgyYTRjMzU3ZWUxOTMwMDE2NmJjZDgwOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-20T14:32:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-20T14:32:26Z"}, "message": "Auto merge of #53162 - QuietMisdreavus:crouching-impl-hidden-trait, r=GuillaumeGomez\n\nrustdoc: collect trait impls as an early pass\n\nFixes https://github.com/rust-lang/rust/issues/52545, fixes https://github.com/rust-lang/rust/issues/41480, fixes https://github.com/rust-lang/rust/issues/36922\n\nRight now, rustdoc pulls all its impl information by scanning a crate's HIR for any items it finds. However, it doesn't recurse into anything other than modules, preventing it from seeing trait impls that may be inside things like functions or consts. Thanks to https://github.com/rust-lang/rust/pull/53002, now these items actually *exist* for rustdoc to see, but they still weren't getting collected for display.\n\nBut there was a secret. Whenever we pull in an item from another crate, we don't have any of its impls in the local HIR, so instead we ask the compiler for *everything* and filter out after the fact. This process is only triggered if there's a cross-crate re-export in the crate being documented, which can sometimes leave this info out of the docs. This PR instead moves this collection into an early pass, which occurs immediately after crate cleaning, so that that collection occurs regardless. In addition, by including the HIR's own `trait_impls` in addition to the existing `all_trait_implementations` calls, we can collect all these tricky trait impls without having to scan for them!", "tree": {"sha": "6b4effbd3416da0ca63c9883f6b31a9664de75c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b4effbd3416da0ca63c9883f6b31a9664de75c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "html_url": "https://github.com/rust-lang/rust/commit/3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f4c500b46603386e940f116b469c7adc043a6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f4c500b46603386e940f116b469c7adc043a6d", "html_url": "https://github.com/rust-lang/rust/commit/f7f4c500b46603386e940f116b469c7adc043a6d"}, {"sha": "110657711605c439b0f175a8ba674c89f9d86e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/110657711605c439b0f175a8ba674c89f9d86e81", "html_url": "https://github.com/rust-lang/rust/commit/110657711605c439b0f175a8ba674c89f9d86e81"}], "stats": {"total": 864, "additions": 643, "deletions": 221}, "files": [{"sha": "377cfe748685fc10dded77c62f73ecd2f68eae42", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -2443,6 +2443,7 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"minifier 0.0.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tempfile 3.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "6e35755d9a4ec228d93024ef5f4c56fe123309d5", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -709,17 +709,22 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// Returns the DefId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        let id = match self.walk_parent_nodes(id, |node| match *node {\n+        self.local_def_id(self.get_module_parent_node(id))\n+    }\n+\n+    /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n+    /// module parent is in this map.\n+    pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n+        match self.walk_parent_nodes(id, |node| match *node {\n             Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        };\n-        self.local_def_id(id)\n+        }\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block."}, {"sha": "845bfad7807d32734be3695cd9af68e3221b66d6", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -11,3 +11,4 @@ path = \"lib.rs\"\n pulldown-cmark = { version = \"0.1.2\", default-features = false }\n minifier = \"0.0.19\"\n tempfile = \"3\"\n+parking_lot = \"0.6.4\""}, {"sha": "34c4c70159f3abf36611b782a622c81104317a02", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> BlanketImplFinder <'a, 'tcx, 'rcx, 'cstore> {\n         let real_name = name.clone().map(|name| Ident::from_str(&name));\n         let param_env = self.cx.tcx.param_env(def_id);\n         for &trait_def_id in self.cx.all_traits.iter() {\n-            if !self.cx.access_levels.borrow().is_doc_reachable(trait_def_id) ||\n+            if !self.cx.renderinfo.borrow().access_levels.is_doc_reachable(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()\n                       .get(&(def_id, trait_def_id))"}, {"sha": "1ea130cf16ae2f4e8e4cc29679883da520c85e99", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 81, "deletions": 111, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -29,8 +29,6 @@ use clean::{\n     self,\n     GetDefId,\n     ToSource,\n-    get_auto_traits_with_def_id,\n-    get_blanket_impls_with_def_id,\n };\n \n use super::Clean;\n@@ -56,7 +54,7 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n     let inner = match def {\n         Def::Trait(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, did, false));\n+            ret.extend(build_impls(cx, did));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Def::Fn(did) => {\n@@ -65,27 +63,27 @@ pub fn try_inline(cx: &DocContext, def: Def, name: ast::Name, visited: &mut FxHa\n         }\n         Def::Struct(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, did, true));\n+            ret.extend(build_impls(cx, did));\n             clean::StructItem(build_struct(cx, did))\n         }\n         Def::Union(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, did, true));\n+            ret.extend(build_impls(cx, did));\n             clean::UnionItem(build_union(cx, did))\n         }\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, did, false));\n+            ret.extend(build_impls(cx, did));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, did, true));\n+            ret.extend(build_impls(cx, did));\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Def::ForeignTy(did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, did, false));\n+            ret.extend(build_impls(cx, did));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -159,12 +157,11 @@ pub fn load_attrs(cx: &DocContext, did: DefId) -> clean::Attributes {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n+    let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n     if did.is_local() {\n-        debug!(\"record_extern_fqn(did={:?}, kind+{:?}): def_id is local, aborting\", did, kind);\n-        return;\n+        crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n     }\n \n-    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n     let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n         // extern blocks have an empty name\n         let s = elem.data.to_string();\n@@ -179,7 +176,12 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     } else {\n         once(crate_name).chain(relative).collect()\n     };\n-    cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n+\n+    if did.is_local() {\n+        cx.renderinfo.borrow_mut().exact_paths.insert(did, fqn);\n+    } else {\n+        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n+    }\n }\n \n pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n@@ -271,93 +273,14 @@ fn build_type_alias(cx: &DocContext, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext, did: DefId, auto_traits: bool) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n     for &did in tcx.inherent_impls(did).iter() {\n         build_impl(cx, did, &mut impls);\n     }\n \n-    if auto_traits {\n-        let auto_impls = get_auto_traits_with_def_id(cx, did);\n-        {\n-            let mut renderinfo = cx.renderinfo.borrow_mut();\n-            let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-                .filter(|i| renderinfo.inlined.insert(i.def_id)).collect();\n-\n-            impls.extend(new_impls);\n-        }\n-        impls.extend(get_blanket_impls_with_def_id(cx, did));\n-    }\n-\n-    // If this is the first time we've inlined something from another crate, then\n-    // we inline *all* impls from all the crates into this crate. Note that there's\n-    // currently no way for us to filter this based on type, and we likely need\n-    // many impls for a variety of reasons.\n-    //\n-    // Primarily, the impls will be used to populate the documentation for this\n-    // type being inlined, but impls can also be used when generating\n-    // documentation for primitives (no way to find those specifically).\n-    if cx.populated_all_crate_impls.get() {\n-        return impls;\n-    }\n-\n-    cx.populated_all_crate_impls.set(true);\n-\n-    for &cnum in tcx.crates().iter() {\n-        for did in tcx.all_trait_implementations(cnum).iter() {\n-            build_impl(cx, *did, &mut impls);\n-        }\n-    }\n-\n-    // Also try to inline primitive impls from other crates.\n-    let lang_items = tcx.lang_items();\n-    let primitive_impls = [\n-        lang_items.isize_impl(),\n-        lang_items.i8_impl(),\n-        lang_items.i16_impl(),\n-        lang_items.i32_impl(),\n-        lang_items.i64_impl(),\n-        lang_items.i128_impl(),\n-        lang_items.usize_impl(),\n-        lang_items.u8_impl(),\n-        lang_items.u16_impl(),\n-        lang_items.u32_impl(),\n-        lang_items.u64_impl(),\n-        lang_items.u128_impl(),\n-        lang_items.f32_impl(),\n-        lang_items.f64_impl(),\n-        lang_items.f32_runtime_impl(),\n-        lang_items.f64_runtime_impl(),\n-        lang_items.char_impl(),\n-        lang_items.str_impl(),\n-        lang_items.slice_impl(),\n-        lang_items.slice_u8_impl(),\n-        lang_items.str_alloc_impl(),\n-        lang_items.slice_alloc_impl(),\n-        lang_items.slice_u8_alloc_impl(),\n-        lang_items.const_ptr_impl(),\n-        lang_items.mut_ptr_impl(),\n-    ];\n-\n-    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n-        if !def_id.is_local() {\n-            build_impl(cx, def_id, &mut impls);\n-\n-            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n-            let mut renderinfo = cx.renderinfo.borrow_mut();\n-\n-            let new_impls: Vec<clean::Item> = auto_impls.into_iter()\n-                .chain(blanket_impls.into_iter())\n-                .filter(|i| renderinfo.inlined.insert(i.def_id))\n-                .collect();\n-\n-            impls.extend(new_impls);\n-        }\n-    }\n-\n     impls\n }\n \n@@ -372,30 +295,60 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     // Only inline impl if the implemented trait is\n     // reachable in rustdoc generated documentation\n-    if let Some(traitref) = associated_trait {\n-        if !cx.access_levels.borrow().is_doc_reachable(traitref.def_id) {\n-            return\n+    if !did.is_local() {\n+        if let Some(traitref) = associated_trait {\n+            if !cx.renderinfo.borrow().access_levels.is_doc_reachable(traitref.def_id) {\n+                return\n+            }\n         }\n     }\n \n-    let for_ = tcx.type_of(did).clean(cx);\n+    let for_ = if let Some(nodeid) = tcx.hir.as_local_node_id(did) {\n+        match tcx.hir.expect_item(nodeid).node {\n+            hir::ItemKind::Impl(.., ref t, _) => {\n+                t.clean(cx)\n+            }\n+            _ => panic!(\"did given to build_impl was not an impl\"),\n+        }\n+    } else {\n+        tcx.type_of(did).clean(cx)\n+    };\n \n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n-    if let Some(did) = for_.def_id() {\n-        if !cx.access_levels.borrow().is_doc_reachable(did) {\n-            return\n+    if !did.is_local() {\n+        if let Some(did) = for_.def_id() {\n+            if !cx.renderinfo.borrow().access_levels.is_doc_reachable(did) {\n+                return\n+            }\n         }\n     }\n \n     let predicates = tcx.predicates_of(did);\n-    let trait_items = tcx.associated_items(did).filter_map(|item| {\n-        if associated_trait.is_some() || item.vis == ty::Visibility::Public {\n-            Some(item.clean(cx))\n-        } else {\n-            None\n+    let (trait_items, generics) = if let Some(nodeid) = tcx.hir.as_local_node_id(did) {\n+        match tcx.hir.expect_item(nodeid).node {\n+            hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n+                (\n+                    item_ids.iter()\n+                            .map(|ii| tcx.hir.impl_item(ii.id).clean(cx))\n+                            .collect::<Vec<_>>(),\n+                    gen.clean(cx),\n+                )\n+            }\n+            _ => panic!(\"did given to build_impl was not an impl\"),\n         }\n-    }).collect::<Vec<_>>();\n+    } else {\n+        (\n+            tcx.associated_items(did).filter_map(|item| {\n+                if associated_trait.is_some() || item.vis == ty::Visibility::Public {\n+                    Some(item.clean(cx))\n+                } else {\n+                    None\n+                }\n+            }).collect::<Vec<_>>(),\n+            (tcx.generics_of(did), &predicates).clean(cx),\n+        )\n+    };\n     let polarity = tcx.impl_polarity(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| {\n         match bound {\n@@ -417,10 +370,12 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n            .collect()\n     }).unwrap_or(FxHashSet());\n \n+    debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n+\n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n-            generics: (tcx.generics_of(did), &predicates).clean(cx),\n+            generics,\n             provided_trait_methods: provided,\n             trait_,\n             for_,\n@@ -465,7 +420,11 @@ fn build_module(cx: &DocContext, did: DefId, visited: &mut FxHashSet<DefId>) ->\n }\n \n pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    cx.tcx.rendered_const(did)\n+    if let Some(node_id) = cx.tcx.hir.as_local_node_id(did) {\n+        cx.tcx.hir.node_to_pretty_string(node_id)\n+    } else {\n+        cx.tcx.rendered_const(did)\n+    }\n }\n \n fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n@@ -576,16 +535,27 @@ fn separate_supertrait_bounds(mut g: clean::Generics)\n }\n \n pub fn record_extern_trait(cx: &DocContext, did: DefId) {\n-    if cx.external_traits.borrow().contains_key(&did) ||\n-        cx.active_extern_traits.borrow().contains(&did)\n-    {\n+    if did.is_local() {\n         return;\n     }\n \n+    {\n+        let external_traits = cx.external_traits.lock();\n+        if external_traits.borrow().contains_key(&did) ||\n+            cx.active_extern_traits.borrow().contains(&did)\n+        {\n+            return;\n+        }\n+    }\n+\n     cx.active_extern_traits.borrow_mut().push(did);\n \n+    debug!(\"record_extern_trait: {:?}\", did);\n     let trait_ = build_external_trait(cx, did);\n \n-    cx.external_traits.borrow_mut().insert(did, trait_);\n+    {\n+        let external_traits = cx.external_traits.lock();\n+        external_traits.borrow_mut().insert(did, trait_);\n+    }\n     cx.active_extern_traits.borrow_mut().remove_item(&did);\n }"}, {"sha": "a982933f6c1a26a594bb4fd80846462671d36d03", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -28,7 +28,6 @@ use syntax::symbol::InternedString;\n use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use rustc::mir::interpret::ConstValue;\n-use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n@@ -56,6 +55,8 @@ use std::cell::RefCell;\n use std::sync::Arc;\n use std::u32;\n \n+use parking_lot::ReentrantMutex;\n+\n use core::{self, DocContext};\n use doctree;\n use visit_ast;\n@@ -135,10 +136,9 @@ pub struct Crate {\n     pub module: Option<Item>,\n     pub externs: Vec<(CrateNum, ExternalCrate)>,\n     pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n-    pub access_levels: Arc<AccessLevels<DefId>>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: FxHashMap<DefId, Trait>,\n+    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, Trait>>>>,\n     pub masked_crates: FxHashSet<CrateNum>,\n }\n \n@@ -209,18 +209,14 @@ impl<'a, 'tcx, 'rcx, 'cstore> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tc\n             }));\n         }\n \n-        let mut access_levels = cx.access_levels.borrow_mut();\n-        let mut external_traits = cx.external_traits.borrow_mut();\n-\n         Crate {\n             name,\n             version: None,\n             src,\n             module: Some(module),\n             externs,\n             primitives,\n-            access_levels: Arc::new(mem::replace(&mut access_levels, Default::default())),\n-            external_traits: mem::replace(&mut external_traits, Default::default()),\n+            external_traits: cx.external_traits.clone(),\n             masked_crates,\n         }\n     }\n@@ -579,9 +575,9 @@ impl Clean<Item> for doctree::Module {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.structs.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.unions.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.enums.iter().flat_map(|x| x.clean(cx)));\n+        items.extend(self.structs.iter().map(|x| x.clean(cx)));\n+        items.extend(self.unions.iter().map(|x| x.clean(cx)));\n+        items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n@@ -2436,7 +2432,7 @@ impl Clean<Type> for hir::Ty {\n                 if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n                     if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                        if !cx.access_levels.borrow().is_exported(def_id) {\n+                        if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n                             alias = Some(&cx.tcx.hir.expect_item(node_id).node);\n                         }\n                     }\n@@ -2816,14 +2812,10 @@ pub struct Union {\n     pub fields_stripped: bool,\n }\n \n-impl Clean<Vec<Item>> for doctree::Struct {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n-        let name = self.name.clean(cx);\n-        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n-        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n-\n-        ret.push(Item {\n-            name: Some(name),\n+impl Clean<Item> for doctree::Struct {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2836,20 +2828,14 @@ impl Clean<Vec<Item>> for doctree::Struct {\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        });\n-\n-        ret\n+        }\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::Union {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n-        let name = self.name.clean(cx);\n-        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n-        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n-\n-        ret.push(Item {\n-            name: Some(name),\n+impl Clean<Item> for doctree::Union {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2862,9 +2848,7 @@ impl Clean<Vec<Item>> for doctree::Union {\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        });\n-\n-        ret\n+        }\n     }\n }\n \n@@ -2895,14 +2879,10 @@ pub struct Enum {\n     pub variants_stripped: bool,\n }\n \n-impl Clean<Vec<Item>> for doctree::Enum {\n-    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n-        let name = self.name.clean(cx);\n-        let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n-        ret.extend(get_blanket_impls_with_node_id(cx, self.id, name.clone()));\n-\n-        ret.push(Item {\n-            name: Some(name),\n+impl Clean<Item> for doctree::Enum {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2914,9 +2894,7 @@ impl Clean<Vec<Item>> for doctree::Enum {\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n-        });\n-\n-        ret\n+        }\n     }\n }\n \n@@ -3445,11 +3423,7 @@ fn build_deref_target_impls(cx: &DocContext,\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                // We set the last parameter to false to avoid looking for auto-impls for traits\n-                // and therefore avoid an ICE.\n-                // The reason behind this is that auto-traits don't propagate through Deref so\n-                // we're not supposed to synthesise impls for them.\n-                ret.extend(inline::build_impls(cx, did, false));\n+                ret.extend(inline::build_impls(cx, did));\n                 continue\n             }\n             _ => match target.primitive_type() {"}, {"sha": "e8f1733e532de7125db292e8c224e571d8960812", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -26,7 +26,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, Ident, NodeId};\n use syntax::source_map;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -36,11 +36,13 @@ use syntax::symbol::keywords;\n use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n+use parking_lot::ReentrantMutex;\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::RefCell;\n use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n use std::rc::Rc;\n+use std::sync::Arc;\n use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n@@ -60,16 +62,13 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n     /// The stack of module NodeIds up till this point\n     pub crate_name: Option<String>,\n     pub cstore: Rc<CStore>,\n-    pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n-    /// Later on moved into `clean::Crate`\n-    pub access_levels: RefCell<AccessLevels<DefId>>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n-    pub external_traits: RefCell<FxHashMap<DefId, clean::Trait>>,\n+    pub external_traits: Arc<ReentrantMutex<RefCell<FxHashMap<DefId, clean::Trait>>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n     pub active_extern_traits: RefCell<Vec<DefId>>,\n@@ -164,6 +163,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         def_id.clone()\n     }\n \n+    /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n+    /// (This avoids a slice-index-out-of-bounds panic.)\n+    pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n+        if self.all_fake_def_ids.borrow().contains(&def_id) {\n+            None\n+        } else {\n+            self.tcx.hir.as_local_node_id(def_id)\n+        }\n+    }\n+\n     pub fn get_real_ty<F>(&self,\n                           def_id: DefId,\n                           def_ctor: &F,\n@@ -509,16 +518,17 @@ pub fn run_core(search_paths: SearchPaths,\n                 clean::path_to_def(&tcx, &[\"core\", \"marker\", \"Send\"])\n             };\n \n+            let mut renderinfo = RenderInfo::default();\n+            renderinfo.access_levels = access_levels;\n+\n             let ctxt = DocContext {\n                 tcx,\n                 resolver: &resolver,\n                 crate_name,\n                 cstore: cstore.clone(),\n-                populated_all_crate_impls: Cell::new(false),\n-                access_levels: RefCell::new(access_levels),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n-                renderinfo: Default::default(),\n+                renderinfo: RefCell::new(renderinfo),\n                 ty_substs: Default::default(),\n                 lt_substs: Default::default(),\n                 impl_trait_bounds: Default::default(),"}, {"sha": "b8e27c531708379d2851156e2616f51e31afb8f7", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::mem;\n-\n use clean::*;\n \n pub struct StripItem(pub Item);\n@@ -116,11 +114,14 @@ pub trait DocFolder : Sized {\n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n         c.module = c.module.take().and_then(|module| self.fold_item(module));\n \n-        let traits = mem::replace(&mut c.external_traits, Default::default());\n-        c.external_traits.extend(traits.into_iter().map(|(k, mut v)| {\n-            v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n-            (k, v)\n-        }));\n+        {\n+            let guard = c.external_traits.lock();\n+            let traits = guard.replace(Default::default());\n+            guard.borrow_mut().extend(traits.into_iter().map(|(k, mut v)| {\n+                v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n+                (k, v)\n+            }));\n+        }\n         c\n     }\n }"}, {"sha": "3e1720f8b8ab2a639c74fbaf5ee4ed07ed689664", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -313,7 +313,7 @@ pub struct Cache {\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from crateanalysis.\n-    pub access_levels: Arc<AccessLevels<DefId>>,\n+    pub access_levels: AccessLevels<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n     pub crate_version: Option<String>,\n@@ -337,6 +337,15 @@ pub struct Cache {\n     // and their parent id here and indexes them at the end of crate parsing.\n     orphan_impl_items: Vec<(DefId, clean::Item)>,\n \n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n     aliases: FxHashMap<String, Vec<IndexItem>>,\n@@ -350,6 +359,7 @@ pub struct RenderInfo {\n     pub external_paths: ::core::ExternalPaths,\n     pub external_typarams: FxHashMap<DefId, String>,\n     pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+    pub access_levels: AccessLevels<DefId>,\n     pub deref_trait_did: Option<DefId>,\n     pub deref_mut_trait_did: Option<DefId>,\n     pub owned_box_did: Option<DefId>,\n@@ -569,6 +579,7 @@ pub fn run(mut krate: clean::Crate,\n         external_paths,\n         external_typarams,\n         exact_paths,\n+        access_levels,\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n@@ -591,10 +602,11 @@ pub fn run(mut krate: clean::Crate,\n         extern_locations: FxHashMap(),\n         primitive_locations: FxHashMap(),\n         stripped_mod: false,\n-        access_levels: krate.access_levels.clone(),\n+        access_levels,\n         crate_version: krate.version.take(),\n         orphan_impl_items: Vec::new(),\n-        traits: mem::replace(&mut krate.external_traits, FxHashMap()),\n+        orphan_trait_impls: Vec::new(),\n+        traits: krate.external_traits.lock().replace(FxHashMap()),\n         deref_trait_did,\n         deref_mut_trait_did,\n         owned_box_did,\n@@ -636,6 +648,14 @@ pub fn run(mut krate: clean::Crate,\n     cache.stack.push(krate.name.clone());\n     krate = cache.fold_crate(krate);\n \n+    for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+        if cache.traits.contains_key(&trait_did) {\n+            for did in dids {\n+                cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n+            }\n+        }\n+    }\n+\n     // Build our search index\n     let index = build_index(&krate, &mut cache);\n \n@@ -1223,6 +1243,10 @@ impl<'a> SourceCollector<'a> {\n \n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n         // If this is a stripped module,\n         // we don't want it or its children in the search index.\n         let orig_stripped_mod = match item.inner {\n@@ -1453,10 +1477,16 @@ impl DocFolder for Cache {\n                 } else {\n                     unreachable!()\n                 };\n-                for did in dids {\n-                    self.impls.entry(did).or_default().push(Impl {\n-                        impl_item: item.clone(),\n-                    });\n+                let impl_item = Impl {\n+                    impl_item: item,\n+                };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().unwrap();\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n                 None\n             } else {"}, {"sha": "5607c97a49689d578f275b08302853e40be58a88", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -24,6 +24,7 @@\n #![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)]\n+#![feature(drain_filter)]\n \n #![recursion_limit=\"256\"]\n \n@@ -48,6 +49,7 @@ extern crate rustc_errors as errors;\n extern crate pulldown_cmark;\n extern crate tempfile;\n extern crate minifier;\n+extern crate parking_lot;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "7b2eb2259d6791bac9976858dd2b34d86f1c38ff", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -69,16 +69,21 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n     /// Resolve a given string as a path, along with whether or not it is\n     /// in the value namespace. Also returns an optional URL fragment in the case\n     /// of variants and methods\n-    fn resolve(&self, path_str: &str, is_val: bool, current_item: &Option<String>)\n+    fn resolve(&self,\n+               path_str: &str,\n+               is_val: bool,\n+               current_item: &Option<String>,\n+               parent_id: Option<NodeId>)\n         -> Result<(Def, Option<String>), ()>\n     {\n         let cx = self.cx;\n \n         // In case we're in a module, try to resolve the relative\n         // path\n-        if let Some(id) = self.mod_ids.last() {\n+        if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n+            // FIXME: `with_scope` requires the NodeId of a module\n             let result = cx.resolver.borrow_mut()\n-                                    .with_scope(*id,\n+                                    .with_scope(id,\n                 |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP,\n                                                     &path_str, is_val)\n@@ -129,8 +134,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> LinkCollector<'a, 'tcx, 'rcx, 'cstore> {\n                 }\n             }\n \n+            // FIXME: `with_scope` requires the NodeId of a module\n             let ty = cx.resolver.borrow_mut()\n-                                .with_scope(*id,\n+                                .with_scope(id,\n                 |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             })?;\n@@ -218,6 +224,20 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n             None\n         };\n \n+        // FIXME: get the resolver to work with non-local resolve scopes\n+        let parent_node = self.cx.as_local_node_id(item.def_id).and_then(|node_id| {\n+            // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n+            // current resolve() implementation\n+            match self.cx.tcx.hir.get_module_parent_node(node_id) {\n+                id if id != node_id => Some(id),\n+                _ => None,\n+            }\n+        });\n+\n+        if parent_node.is_some() {\n+            debug!(\"got parent node for {} {:?}, id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n         let current_item = match item.inner {\n             ModuleItem(..) => {\n                 if item.attrs.inner_docs {\n@@ -227,10 +247,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                         None\n                     }\n                 } else {\n-                    match self.mod_ids.last() {\n-                        Some(parent) if *parent != NodeId::new(0) => {\n+                    match parent_node.or(self.mod_ids.last().cloned()) {\n+                        Some(parent) if parent != NodeId::new(0) => {\n                             //FIXME: can we pull the parent module's name from elsewhere?\n-                            Some(self.cx.tcx.hir.name(*parent).to_string())\n+                            Some(self.cx.tcx.hir.name(parent).to_string())\n                         }\n                         _ => None,\n                     }\n@@ -294,7 +314,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n \n                 match kind {\n                     PathKind::Value => {\n-                        if let Ok(def) = self.resolve(path_str, true, &current_item) {\n+                        if let Ok(def) = self.resolve(path_str, true, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -305,7 +325,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                         }\n                     }\n                     PathKind::Type => {\n-                        if let Ok(def) = self.resolve(path_str, false, &current_item) {\n+                        if let Ok(def) = self.resolve(path_str, false, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -316,16 +336,18 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                     PathKind::Unknown => {\n                         // try everything!\n                         if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                            if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                            if let Ok(type_def) =\n+                                self.resolve(path_str, false, &current_item, parent_node)\n+                            {\n                                 let (type_kind, article, type_disambig)\n                                     = type_ns_kind(type_def.0, path_str);\n                                 ambiguity_error(cx, &item.attrs, path_str,\n                                                 article, type_kind, &type_disambig,\n                                                 \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                                 continue;\n-                            } else if let Ok(value_def) = self.resolve(path_str,\n-                                                                       true,\n-                                                                       &current_item) {\n+                            } else if let Ok(value_def) =\n+                                self.resolve(path_str, true, &current_item, parent_node)\n+                            {\n                                 let (value_kind, value_disambig)\n                                     = value_ns_kind(value_def.0, path_str)\n                                         .expect(\"struct and mod cases should have been \\\n@@ -335,12 +357,16 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                                                 \"a\", \"macro\", &format!(\"macro@{}\", path_str));\n                             }\n                             (macro_def, None)\n-                        } else if let Ok(type_def) = self.resolve(path_str, false, &current_item) {\n+                        } else if let Ok(type_def) =\n+                            self.resolve(path_str, false, &current_item, parent_node)\n+                        {\n                             // It is imperative we search for not-a-value first\n                             // Otherwise we will find struct ctors for when we are looking\n                             // for structs, and the link won't work.\n                             // if there is something in both namespaces\n-                            if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                            if let Ok(value_def) =\n+                                self.resolve(path_str, true, &current_item, parent_node)\n+                            {\n                                 let kind = value_ns_kind(value_def.0, path_str);\n                                 if let Some((value_kind, value_disambig)) = kind {\n                                     let (type_kind, article, type_disambig)\n@@ -352,7 +378,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n                                 }\n                             }\n                             type_def\n-                        } else if let Ok(value_def) = self.resolve(path_str, true, &current_item) {\n+                        } else if let Ok(value_def) =\n+                            self.resolve(path_str, true, &current_item, parent_node)\n+                        {\n                             value_def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);"}, {"sha": "70e1a9b0ebc9d9f40f0414bbdb366df3275a21c5", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,219 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clean::*;\n+\n+use rustc::util::nodemap::FxHashSet;\n+use rustc::hir::def_id::DefId;\n+\n+use super::Pass;\n+use core::DocContext;\n+use fold::DocFolder;\n+\n+pub const COLLECT_TRAIT_IMPLS: Pass =\n+    Pass::early(\"collect-trait-impls\", collect_trait_impls,\n+                \"retrieves trait impls for items in the crate\");\n+\n+pub fn collect_trait_impls(krate: Crate, cx: &DocContext) -> Crate {\n+    let mut synth = SyntheticImplCollector::new(cx);\n+    let mut krate = synth.fold_crate(krate);\n+\n+    let prims: FxHashSet<PrimitiveType> =\n+        krate.primitives.iter().map(|p| p.1).collect();\n+\n+    let crate_items = {\n+        let mut coll = ItemCollector::new();\n+        krate = coll.fold_crate(krate);\n+        coll.items\n+    };\n+\n+    let mut new_items = Vec::new();\n+\n+    for &cnum in cx.tcx.crates().iter() {\n+        for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n+            inline::build_impl(cx, did, &mut new_items);\n+        }\n+    }\n+\n+    // Also try to inline primitive impls from other crates.\n+    let lang_items = cx.tcx.lang_items();\n+    let primitive_impls = [\n+        lang_items.isize_impl(),\n+        lang_items.i8_impl(),\n+        lang_items.i16_impl(),\n+        lang_items.i32_impl(),\n+        lang_items.i64_impl(),\n+        lang_items.i128_impl(),\n+        lang_items.usize_impl(),\n+        lang_items.u8_impl(),\n+        lang_items.u16_impl(),\n+        lang_items.u32_impl(),\n+        lang_items.u64_impl(),\n+        lang_items.u128_impl(),\n+        lang_items.f32_impl(),\n+        lang_items.f64_impl(),\n+        lang_items.f32_runtime_impl(),\n+        lang_items.f64_runtime_impl(),\n+        lang_items.char_impl(),\n+        lang_items.str_impl(),\n+        lang_items.slice_impl(),\n+        lang_items.slice_u8_impl(),\n+        lang_items.str_alloc_impl(),\n+        lang_items.slice_alloc_impl(),\n+        lang_items.slice_u8_alloc_impl(),\n+        lang_items.const_ptr_impl(),\n+        lang_items.mut_ptr_impl(),\n+    ];\n+\n+    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+        if !def_id.is_local() {\n+            inline::build_impl(cx, def_id, &mut new_items);\n+\n+            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n+            let mut renderinfo = cx.renderinfo.borrow_mut();\n+\n+            let new_impls: Vec<Item> = auto_impls.into_iter()\n+                .chain(blanket_impls.into_iter())\n+                .filter(|i| renderinfo.inlined.insert(i.def_id))\n+                .collect();\n+\n+            new_items.extend(new_impls);\n+        }\n+    }\n+\n+    let mut cleaner = BadImplStripper {\n+        prims,\n+        items: crate_items,\n+    };\n+\n+    // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n+    for it in &new_items {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.inner {\n+            if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+                let target = items.iter().filter_map(|item| {\n+                    match item.inner {\n+                        TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    }\n+                }).next().expect(\"Deref impl without Target type\");\n+\n+                if let Some(prim) = target.primitive_type() {\n+                    cleaner.prims.insert(prim);\n+                } else if let Some(did) = target.def_id() {\n+                    cleaner.items.insert(did);\n+                }\n+            }\n+        }\n+    }\n+\n+    new_items.retain(|it| {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.inner {\n+            cleaner.keep_item(for_) ||\n+                trait_.as_ref().map_or(false, |t| cleaner.keep_item(t)) ||\n+                blanket_impl.is_some()\n+        } else {\n+            true\n+        }\n+    });\n+\n+    // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n+    // doesn't work with it anyway, so pull them from the HIR map instead\n+    for &trait_did in cx.all_traits.iter() {\n+        for &impl_node in cx.tcx.hir.trait_impls(trait_did) {\n+            let impl_did = cx.tcx.hir.local_def_id(impl_node);\n+            inline::build_impl(cx, impl_did, &mut new_items);\n+        }\n+    }\n+\n+    if let Some(ref mut it) = krate.module {\n+        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n+            items.extend(synth.impls);\n+            items.extend(new_items);\n+        } else {\n+            panic!(\"collect-trait-impls can't run\");\n+        }\n+    } else {\n+        panic!(\"collect-trait-impls can't run\");\n+    }\n+\n+    krate\n+}\n+\n+struct SyntheticImplCollector<'a, 'tcx: 'a, 'rcx: 'a, 'cstore: 'rcx> {\n+    cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>,\n+    impls: Vec<Item>,\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> SyntheticImplCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx, 'cstore>) -> Self {\n+        SyntheticImplCollector {\n+            cx,\n+            impls: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for SyntheticImplCollector<'a, 'tcx, 'rcx, 'cstore> {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        if i.is_struct() || i.is_enum() || i.is_union() {\n+            if let (Some(node_id), Some(name)) =\n+                (self.cx.tcx.hir.as_local_node_id(i.def_id), i.name.clone())\n+            {\n+                self.impls.extend(get_auto_traits_with_node_id(self.cx, node_id, name.clone()));\n+                self.impls.extend(get_blanket_impls_with_node_id(self.cx, node_id, name));\n+            } else {\n+                self.impls.extend(get_auto_traits_with_def_id(self.cx, i.def_id));\n+                self.impls.extend(get_blanket_impls_with_def_id(self.cx, i.def_id));\n+            }\n+        }\n+\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+#[derive(Default)]\n+struct ItemCollector {\n+    items: FxHashSet<DefId>,\n+}\n+\n+impl ItemCollector {\n+    fn new() -> Self {\n+        Self::default()\n+    }\n+}\n+\n+impl DocFolder for ItemCollector {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        self.items.insert(i.def_id);\n+\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+struct BadImplStripper {\n+    prims: FxHashSet<PrimitiveType>,\n+    items: FxHashSet<DefId>,\n+}\n+\n+impl BadImplStripper {\n+    fn keep_item(&self, ty: &Type) -> bool {\n+        if let Generic(_) = ty {\n+            // keep impls made on generics\n+            true\n+        } else if let Some(prim) = ty.primitive_type() {\n+            self.prims.contains(&prim)\n+        } else if let Some(did) = ty.def_id() {\n+            self.items.contains(&did)\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "24fec62dd573a3876b8e5d153e6dc32128a6cb14", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -43,6 +43,9 @@ pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n mod collect_intra_doc_links;\n pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n+mod collect_trait_impls;\n+pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+\n /// Represents a single pass.\n #[derive(Copy, Clone)]\n pub enum Pass {\n@@ -132,10 +135,12 @@ pub const PASSES: &'static [Pass] = &[\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n     COLLECT_INTRA_DOC_LINKS,\n+    COLLECT_TRAIT_IMPLS,\n ];\n \n /// The list of passes run by default.\n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collect-intra-doc-links\",\n@@ -146,6 +151,7 @@ pub const DEFAULT_PASSES: &'static [&'static str] = &[\n \n /// The list of default passes run with `--document-private-items` is passed to rustdoc.\n pub const DEFAULT_PRIVATE_PASSES: &'static [&'static str] = &[\n+    \"collect-trait-impls\",\n     \"strip-priv-imports\",\n     \"collect-intra-doc-links\",\n     \"collapse-docs\",\n@@ -189,6 +195,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n                 // items to the `retained` set.\n+                debug!(\"Stripper: recursing into stripped {} {:?}\", i.type_(), i.name);\n                 let old = mem::replace(&mut self.update_retained, false);\n                 let ret = self.fold_item_recur(i);\n                 self.update_retained = old;\n@@ -212,6 +219,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             | clean::ForeignTypeItem => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n+                        debug!(\"Stripper: stripping {} {:?}\", i.type_(), i.name);\n                         return None;\n                     }\n                 }\n@@ -225,6 +233,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             clean::ModuleItem(..) => {\n                 if i.def_id.is_local() && i.visibility != Some(clean::Public) {\n+                    debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n                     self.update_retained = old;\n@@ -296,18 +305,22 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n             }\n             if let Some(did) = imp.for_.def_id() {\n                 if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped type; removing\");\n                     return None;\n                 }\n             }\n             if let Some(did) = imp.trait_.def_id() {\n                 if did.is_local() && !self.retained.contains(&did) {\n+                    debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;\n                 }\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n                     if let Some(did) = typaram.def_id() {\n                         if did.is_local() && !self.retained.contains(&did) {\n+                            debug!(\"ImplStripper: stripped item in trait's generics; \\\n+                                    removing impl\");\n                             return None;\n                         }\n                     }"}, {"sha": "24dd4cc13bfe88b782e3232c61bb03eda691a5a9", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -35,7 +35,9 @@ pub fn strip_hidden(krate: clean::Crate, _: &DocContext) -> clean::Crate {\n \n     // strip all impls referencing stripped items\n     let mut stripper = ImplStripper { retained: &retained };\n-    stripper.fold_crate(krate)\n+    let krate = stripper.fold_crate(krate);\n+\n+    krate\n }\n \n struct Stripper<'a> {\n@@ -46,7 +48,7 @@ struct Stripper<'a> {\n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.attrs.lists(\"doc\").has_word(\"hidden\") {\n-            debug!(\"found one in strip_hidden; removing\");\n+            debug!(\"strip_hidden: stripping {} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n             match i.inner {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {"}, {"sha": "46d0034497e28b39f811ee394158b42477ebaae0", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -22,10 +22,10 @@ pub const STRIP_PRIVATE: Pass =\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, _: &DocContext) -> clean::Crate {\n+pub fn strip_private(mut krate: clean::Crate, cx: &DocContext) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet();\n-    let access_levels = krate.access_levels.clone();\n+    let access_levels = cx.renderinfo.borrow().access_levels.clone();\n \n     // strip all private items\n     {"}, {"sha": "0e12fd34eb7d84b99bc36723133f8a46b4684fc4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -269,7 +269,10 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 Def::Enum(did) |\n                 Def::ForeignTy(did) |\n                 Def::TyAlias(did) if !self_is_hidden => {\n-                    self.cx.access_levels.borrow_mut().map.insert(did, AccessLevel::Public);\n+                    self.cx.renderinfo\n+                        .borrow_mut()\n+                        .access_levels.map\n+                        .insert(did, AccessLevel::Public);\n                 },\n                 Def::Mod(did) => if !self_is_hidden {\n                     ::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n@@ -284,7 +287,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n             Some(n) => n, None => return false\n         };\n \n-        let is_private = !self.cx.access_levels.borrow().is_public(def_did);\n+        let is_private = !self.cx.renderinfo.borrow().access_levels.is_public(def_did);\n         let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n \n         // Only inline if requested or if the item would otherwise be stripped\n@@ -510,9 +513,9 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                           ref tr,\n                           ref ty,\n                           ref item_ids) => {\n-                // Don't duplicate impls when inlining, we'll pick them up\n-                // regardless of where they're located.\n-                if !self.inlining {\n+                // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n+                // them up regardless of where they're located.\n+                if !self.inlining && tr.is_none() {\n                     let items = item_ids.iter()\n                                         .map(|ii| self.cx.tcx.hir.impl_item(ii.id).clone())\n                                         .collect();"}, {"sha": "fd81f937f30c70e27bda1290311f3a2dc2bf372f", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> LibEmbargoVisitor<'a, 'tcx, 'rcx, 'cstore> {\n     ) -> LibEmbargoVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         LibEmbargoVisitor {\n             cx,\n-            access_levels: cx.access_levels.borrow_mut(),\n+            access_levels: RefMut::map(cx.renderinfo.borrow_mut(), |ri| &mut ri.access_levels),\n             prev_level: Some(AccessLevel::Public),\n             visited_mods: FxHashSet()\n         }"}, {"sha": "01a4a410b03fb81fa7a86d9b3a55bfb904d26276", "filename": "src/test/rustdoc/doc-proc-macro.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fdoc-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fdoc-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-proc-macro.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-stage1\n+\n // Issue #52129: ICE when trying to document the `quote` proc-macro from proc_macro\n \n // As of this writing, we don't currently attempt to document proc-macros. However, we shouldn't"}, {"sha": "7457a5d4899fe4ad759b104479a9c7520758a200", "filename": "src/test/rustdoc/inline_cross/auxiliary/trait-vis.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Ftrait-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Ftrait-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Ftrait-vis.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"inner\"]\n+\n+pub struct SomeStruct;\n+\n+fn asdf() {\n+    const _FOO: () = {\n+        impl Clone for SomeStruct {\n+            fn clone(&self) -> Self {\n+                SomeStruct\n+            }\n+        }\n+    };\n+}"}, {"sha": "5b5410b1da44d6226ca318402c9d9a2c6eba2455", "filename": "src/test/rustdoc/inline_cross/trait-vis.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Ftrait-vis.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:trait-vis.rs\n+\n+extern crate inner;\n+\n+// @has trait_vis/struct.SomeStruct.html\n+// @has - '//code' 'impl Clone for SomeStruct'\n+pub use inner::SomeStruct;"}, {"sha": "73b1cc2ce8f2dee2738263aae738c8843f83bb2b", "filename": "src/test/rustdoc/inline_local/trait-vis.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_local%2Ftrait-vis.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait ThisTrait {}\n+\n+mod asdf {\n+    use ThisTrait;\n+\n+    pub struct SomeStruct;\n+\n+    impl ThisTrait for SomeStruct {}\n+\n+    trait PrivateTrait {}\n+\n+    impl PrivateTrait for SomeStruct {}\n+}\n+\n+// @has trait_vis/struct.SomeStruct.html\n+// @has - '//code' 'impl ThisTrait for SomeStruct'\n+// !@has - '//code' 'impl PrivateTrait for SomeStruct'\n+pub use asdf::SomeStruct;"}, {"sha": "8c01941234ec058311967b92b012620303c52c39", "filename": "src/test/rustdoc/intra-link-in-bodies.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-in-bodies.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// we need to make sure that intra-doc links on trait impls get resolved in the right scope\n+\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+pub mod inner {\n+    pub struct SomethingOutOfScope;\n+}\n+\n+pub mod other {\n+    use inner::SomethingOutOfScope;\n+    use SomeTrait;\n+\n+    pub struct OtherStruct;\n+\n+    /// Let's link to [SomethingOutOfScope] while we're at it.\n+    impl SomeTrait for OtherStruct {}\n+}\n+\n+pub trait SomeTrait {}\n+\n+pub struct SomeStruct;\n+\n+fn __implementation_details() {\n+    use inner::SomethingOutOfScope;\n+\n+    // FIXME: intra-links resolve in their nearest module scope, not their actual scope in cases\n+    // like this\n+    // Let's link to [SomethingOutOfScope] while we're at it.\n+    impl SomeTrait for SomeStruct {}\n+}"}, {"sha": "a771b1b15ce4d66543d91a2296147c1cd62f318e", "filename": "src/test/rustdoc/primitive-generic-impl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fprimitive-generic-impl.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -10,9 +10,6 @@\n \n #![crate_name = \"foo\"]\n \n-// we need to reexport something from libstd so that `all_trait_implementations` is called.\n-pub use std::string::String;\n-\n include!(\"primitive/primitive-generic-impl.rs\");\n \n // @has foo/primitive.i32.html '//h3[@id=\"impl-ToString\"]//code' 'impl<T> ToString for T'"}, {"sha": "ac3be7e61e9a0177ef673d022db54df71378312f", "filename": "src/test/rustdoc/traits-in-bodies-private.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Ftraits-in-bodies-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Ftraits-in-bodies-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftraits-in-bodies-private.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// when implementing the fix for traits-in-bodies, there was an ICE when documenting private items\n+// and a trait was defined in non-module scope\n+\n+// compile-flags:--document-private-items\n+\n+// @has traits_in_bodies_private/struct.SomeStruct.html\n+// @!has - '//code' 'impl HiddenTrait for SomeStruct'\n+pub struct SomeStruct;\n+\n+fn __implementation_details() {\n+    trait HiddenTrait {}\n+    impl HiddenTrait for SomeStruct {}\n+}"}, {"sha": "a1d4019bba2bfe7e0dcc9fa7f63870f3ca5e4615", "filename": "src/test/rustdoc/traits-in-bodies.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bc2ca7e4f8507f82a4c357ee19300166bcd8099/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs?ref=3bc2ca7e4f8507f82a4c357ee19300166bcd8099", "patch": "@@ -11,11 +11,10 @@\n //prior to fixing `everybody_loops` to preserve items, rustdoc would crash on this file, as it\n //didn't see that `SomeStruct` implemented `Clone`\n \n-//FIXME(misdreavus): whenever rustdoc shows traits impl'd inside bodies, make sure this test\n-//reflects that\n-\n pub struct Bounded<T: Clone>(T);\n \n+// @has traits_in_bodies/struct.SomeStruct.html\n+// @has - '//code' 'impl Clone for SomeStruct'\n pub struct SomeStruct;\n \n fn asdf() -> Bounded<SomeStruct> {\n@@ -27,3 +26,37 @@ fn asdf() -> Bounded<SomeStruct> {\n \n     Bounded(SomeStruct)\n }\n+\n+// @has traits_in_bodies/struct.Point.html\n+// @has - '//code' 'impl Copy for Point'\n+#[derive(Clone)]\n+pub struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+const _FOO: () = {\n+    impl Copy for Point {}\n+    ()\n+};\n+\n+// @has traits_in_bodies/struct.Inception.html\n+// @has - '//code' 'impl Clone for Inception'\n+pub struct Inception;\n+\n+static _BAR: usize = {\n+    trait HiddenTrait {\n+        fn hidden_fn(&self) {\n+            for _ in 0..5 {\n+                impl Clone for Inception {\n+                    fn clone(&self) -> Self {\n+                        // we need to go deeper\n+                        Inception\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    5\n+};"}]}