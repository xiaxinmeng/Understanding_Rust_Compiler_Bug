{"sha": "fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZWI1YmEzMDQzYmJkMTczYmQ1YjczMDhlOThkZGU3MjNmNjZkNWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-08T03:24:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-08T03:24:25Z"}, "message": "Upgrade libuv to f1859eb841be2fe48512bc10e64556383f408b01", "tree": {"sha": "0b47bce82a9a3a4ac6a05e2b9d3668e6d03f567e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b47bce82a9a3a4ac6a05e2b9d3668e6d03f567e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "html_url": "https://github.com/rust-lang/rust/commit/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06d14f3a1cef79977da60c392b1c52d4ab87e2c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/06d14f3a1cef79977da60c392b1c52d4ab87e2c7", "html_url": "https://github.com/rust-lang/rust/commit/06d14f3a1cef79977da60c392b1c52d4ab87e2c7"}], "stats": {"total": 1956, "additions": 1610, "deletions": 346}, "files": [{"sha": "6c607bb378687a81db548c36ec798e36c92367e0", "filename": "mk/libuv/ia32/mac/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -50,9 +50,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -64,6 +66,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\"}, {"sha": "5fe962a4c1c51c4869b1b223c0b38859665c92fa", "filename": "mk/libuv/ia32/mac/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -89,6 +89,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\"}, {"sha": "e3a114bb50a524852ca1391d7ada41fc9cacc19f", "filename": "mk/libuv/ia32/unix/src/rt/libuv/run-benchmarks.target.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -8,7 +8,7 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n-CFLAGS_Default := \n+CFLAGS_Default := -pthread\n \n # Flags passed to only C files.\n CFLAGS_C_Default := \n@@ -61,7 +61,7 @@ $(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n \n # End of this set of suffix rules\n ### Rules for final target.\n-LDFLAGS_Default := -pthread\n+LDFLAGS_Default := \n \n LIBS := -lrt\n "}, {"sha": "4fc85cca20ce6cdf7df3a64d36b979149cd71e20", "filename": "mk/libuv/ia32/unix/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -8,7 +8,7 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n-CFLAGS_Default := \n+CFLAGS_Default := -pthread\n \n # Flags passed to only C files.\n CFLAGS_C_Default := \n@@ -40,9 +40,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -54,6 +56,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\\n@@ -92,7 +95,7 @@ $(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n \n # End of this set of suffix rules\n ### Rules for final target.\n-LDFLAGS_Default := -pthread\n+LDFLAGS_Default := \n \n LIBS := -lrt\n "}, {"sha": "fa9767329bd0599086f4c694f5c799573f434295", "filename": "mk/libuv/ia32/unix/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -11,7 +11,8 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_CONFIG_H=\"config_linux.h\"'\n \n # Flags passed to all source files.\n-CFLAGS_Default := -g \\\n+CFLAGS_Default := -pthread \\\n+\t-g \\\n \t--std=gnu89 \\\n \t-pedantic \\\n \t-Wall \\\n@@ -84,6 +85,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\"}, {"sha": "85403f2be5065e1a96f3fa5212c857aec38d6f99", "filename": "mk/libuv/ia32/win/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -37,9 +37,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -51,6 +53,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\"}, {"sha": "1291a82204322e17ba0bb34378e6149408d5e506", "filename": "mk/libuv/ia32/win/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fia32%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -71,6 +71,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/async.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/cares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/core.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs-event.o \\"}, {"sha": "ab3921dd98b3aa2e89952a93bcf2c99ee43ce88d", "filename": "mk/libuv/x86_64/mac/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -50,9 +50,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -64,6 +66,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\"}, {"sha": "a751e1d37e8062e5c69c1fed9b0d6400f1662d3a", "filename": "mk/libuv/x86_64/mac/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Fmac%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -89,6 +89,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\"}, {"sha": "e3a114bb50a524852ca1391d7ada41fc9cacc19f", "filename": "mk/libuv/x86_64/unix/src/rt/libuv/run-benchmarks.target.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-benchmarks.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -8,7 +8,7 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n-CFLAGS_Default := \n+CFLAGS_Default := -pthread\n \n # Flags passed to only C files.\n CFLAGS_C_Default := \n@@ -61,7 +61,7 @@ $(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n \n # End of this set of suffix rules\n ### Rules for final target.\n-LDFLAGS_Default := -pthread\n+LDFLAGS_Default := \n \n LIBS := -lrt\n "}, {"sha": "4fc85cca20ce6cdf7df3a64d36b979149cd71e20", "filename": "mk/libuv/x86_64/unix/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -8,7 +8,7 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_STACKSIZE=262144'\n \n # Flags passed to all source files.\n-CFLAGS_Default := \n+CFLAGS_Default := -pthread\n \n # Flags passed to only C files.\n CFLAGS_C_Default := \n@@ -40,9 +40,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -54,6 +56,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\\n@@ -92,7 +95,7 @@ $(obj).$(TOOLSET)/$(TARGET)/%.o: $(obj)/%.c FORCE_DO_CMD\n \n # End of this set of suffix rules\n ### Rules for final target.\n-LDFLAGS_Default := -pthread\n+LDFLAGS_Default := \n \n LIBS := -lrt\n "}, {"sha": "fa9767329bd0599086f4c694f5c799573f434295", "filename": "mk/libuv/x86_64/unix/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Funix%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -11,7 +11,8 @@ DEFS_Default := '-D_LARGEFILE_SOURCE' \\\n \t'-DEIO_CONFIG_H=\"config_linux.h\"'\n \n # Flags passed to all source files.\n-CFLAGS_Default := -g \\\n+CFLAGS_Default := -pthread \\\n+\t-g \\\n \t--std=gnu89 \\\n \t-pedantic \\\n \t-Wall \\\n@@ -84,6 +85,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/tty.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/stream.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/cares.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/process.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/unix/eio/eio.o \\"}, {"sha": "85403f2be5065e1a96f3fa5212c857aec38d6f99", "filename": "mk/libuv/x86_64/win/src/rt/libuv/run-tests.target.mk", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Frun-tests.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -37,9 +37,11 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-idle.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ipc.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-loop-handles.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-multiple-listen.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pass-always.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ping-pong.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-bind-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-pipe-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-ref.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-shutdown-eof.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-spawn.o \\\n@@ -51,6 +53,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/test/blackhole-server.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-connect6-error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-error.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-write-to-half-open-connection.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-tcp-writealot.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-threadpool.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/test/test-timer-again.o \\"}, {"sha": "1291a82204322e17ba0bb34378e6149408d5e506", "filename": "mk/libuv/x86_64/win/src/rt/libuv/uv.target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Flibuv%2Fx86_64%2Fwin%2Fsrc%2Frt%2Flibuv%2Fuv.target.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -71,6 +71,7 @@ OBJS := $(obj).target/$(TARGET)/src/rt/libuv/src/uv-common.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/async.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/cares.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/core.o \\\n+\t$(obj).target/$(TARGET)/src/rt/libuv/src/win/dl.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/error.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs.o \\\n \t$(obj).target/$(TARGET)/src/rt/libuv/src/win/fs-event.o \\"}, {"sha": "9224a1d40ec2f24a75a5d44c22b2eec13fee943f", "filename": "src/etc/gyp-uv", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Fetc%2Fgyp-uv", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Fetc%2Fgyp-uv", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgyp-uv?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -40,17 +40,17 @@ do\n \n     # Comment out the gyp auto regeneration\n     for os in mac unix win; do\n-        sed -i \"\" \\\n+        sed -i \\\n             -e 's/^\\(Makefile: $(srcdir)\\/src\\/rt\\/libuv\\/uv\\.gyp\\)/#\\1/' \\\n             mk/libuv/$ARCH/$os/Makefile\n \n-        sed -i \"\" \\\n+        sed -i \\\n             -e 's/^\\(\t$(call do_cmd,regen_makefile)\\)/#\\1/' \\\n             mk/libuv/$ARCH/$os/Makefile\n     done\n done\n \n # On Mac, GYP hardcodes a -arch i386 into the output. Fix that.\n-sed -i \"\" \\\n+sed -i \\\n     -e 's/-arch i386/-arch x86_64/' \\\n     mk/libuv/x86_64/mac/src/rt/libuv/*.mk"}, {"sha": "da019e866114b0a3df4d35796ab318e02db81a7d", "filename": "src/rt/libuv/build/gcc_version.py", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,20 @@\n+#!/usr/bin/env python\n+\n+import os\n+import re\n+import subprocess\n+import sys\n+\n+\n+def DoMain(*args):\n+  cc = os.environ.get('CC', 'gcc')\n+  stdin, stderr = os.pipe()\n+  subprocess.call([cc, '-v'], stderr=stderr)\n+  output = os.read(stdin, 4096)\n+  match = re.search(\"\\ngcc version (\\d+\\.\\d+\\.\\d+)\", output)\n+  if match:\n+    print(match.group(1))\n+\n+\n+if __name__ == '__main__':\n+  DoMain(*sys.argv)"}, {"sha": "e0eb76d267bd475d0f8d1fb98fe250e2f0f24c59", "filename": "src/rt/libuv/common.gypi", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fcommon.gypi", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fcommon.gypi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fcommon.gypi?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -114,9 +114,11 @@\n         ],\n       }],\n       [ 'OS==\"linux\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"solaris\"', {\n-        'cflags': [ '-Wall', '-pthread', ],\n+        'variables': {\n+          'gcc_version%': '<!(python build/gcc_version.py)>)',\n+        },\n+        'cflags': [ '-Wall' ],\n         'cflags_cc': [ '-fno-rtti', '-fno-exceptions' ],\n-        'ldflags': [ '-pthread', ],\n         'conditions': [\n           [ 'host_arch != target_arch and target_arch==\"ia32\"', {\n             'cflags': [ '-m32' ],\n@@ -125,7 +127,14 @@\n           [ 'OS==\"linux\"', {\n             'cflags': [ '-ansi' ],\n           }],\n-          [ 'visibility==\"hidden\"', {\n+          [ 'OS==\"solaris\"', {\n+            'cflags': [ '-pthreads' ],\n+            'ldflags': [ '-pthreads' ],\n+          }, {\n+            'cflags': [ '-pthread' ],\n+            'ldflags': [ '-pthread' ],\n+          }],\n+          [ 'visibility==\"hidden\" and gcc_version >= \"4.0.0\"', {\n             'cflags': [ '-fvisibility=hidden' ],\n           }],\n         ],\n@@ -143,7 +152,6 @@\n           'GCC_INLINES_ARE_PRIVATE_EXTERN': 'YES',\n           'GCC_SYMBOLS_PRIVATE_EXTERN': 'YES',      # -fvisibility=hidden\n           'GCC_THREADSAFE_STATICS': 'NO',           # -fno-threadsafe-statics\n-          'GCC_VERSION': '4.2',\n           'GCC_WARN_ABOUT_MISSING_NEWLINE': 'YES',  # -Wnewline-eof\n           'MACOSX_DEPLOYMENT_TARGET': '10.4',       # -mmacosx-version-min=10.4\n           'PREBINDING': 'NO',                       # No -Wl,-prebind"}, {"sha": "9524061b1c509aebefdd827c798639e140f44b19", "filename": "src/rt/libuv/config-unix.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -28,6 +28,7 @@ CPPFLAGS += -D_LARGEFILE_SOURCE\n CPPFLAGS += -D_FILE_OFFSET_BITS=64\n \n OBJS += src/unix/core.o\n+OBJS += src/unix/dl.o\n OBJS += src/unix/fs.o\n OBJS += src/unix/cares.o\n OBJS += src/unix/udp.o"}, {"sha": "b07781f4068b123e19dbade66098882409a5dd15", "filename": "src/rt/libuv/include/uv-private/uv-unix.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -43,6 +43,10 @@ typedef struct {\n \n typedef int uv_file;\n \n+/* Platform-specific definitions for uv_dlopen support. */\n+typedef void* uv_lib_t;\n+#define UV_DYNAMIC /* empty */\n+\n #define UV_LOOP_PRIVATE_FIELDS \\\n   ares_channel channel; \\\n   /* \\\n@@ -195,6 +199,16 @@ typedef int uv_file;\n   uv_fs_event_cb cb; \\\n   int fflags; \\\n \n+#elif defined(__sun)\n+\n+#include <sys/port.h>\n+#include <port.h>\n+\n+#define UV_FS_EVENT_PRIVATE_FIELDS \\\n+  ev_io event_watcher; \\\n+  uv_fs_event_cb cb; \\\n+  file_obj_t fo; \\\n+\n #else\n \n /* Stub for platforms where the file watcher isn't implemented yet. */"}, {"sha": "5d461090f159dc6ffdb85a7401c74b98de3f14b7", "filename": "src/rt/libuv/include/uv-private/uv-win.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -137,6 +137,10 @@ typedef struct uv_buf_t {\n \n typedef int uv_file;\n \n+/* Platform-specific definitions for uv_dlopen support. */\n+typedef HMODULE uv_lib_t;\n+#define UV_DYNAMIC FAR WINAPI\n+\n RB_HEAD(uv_timer_tree_s, uv_timer_s);\n \n #define UV_LOOP_PRIVATE_FIELDS                                                \\\n@@ -243,6 +247,7 @@ RB_HEAD(uv_timer_tree_s, uv_timer_s);\n \n #define uv_tcp_server_fields              \\\n   uv_tcp_accept_t* accept_reqs;           \\\n+  unsigned int processed_accepts;         \\\n   uv_tcp_accept_t* pending_accepts;       \\\n   LPFN_ACCEPTEX func_acceptex;\n "}, {"sha": "88afed448d9a4ab41e7c147ce3a6e174e451396c", "filename": "src/rt/libuv/include/uv.h", "status": "modified", "additions": 228, "deletions": 142, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -27,10 +27,29 @@\n extern \"C\" {\n #endif\n \n+#ifdef _WIN32\n+  /* Windows - set up dll import/export decorators. */\n+# if defined(BUILDING_UV_SHARED)\n+    /* Building shared library. Export everything from c-ares as well. */\n+#   define UV_EXTERN __declspec(dllexport)\n+#   define CARES_BUILDING_LIBRARY 1\n+# elif defined(USING_UV_SHARED)\n+    /* Using shared library. Use shared c-ares as well. */\n+#   define UV_EXTERN __declspec(dllimport)\n+# else\n+    /* Building static library. Build c-ares statically as well. */\n+#   define UV_EXTERN /* nothing */\n+#   define CARES_STATICLIB 1\n+# endif\n+#else\n+  /* Unix. TODO: symbol hiding */\n+# define UV_EXTERN /* nothing */\n+#endif\n+\n+\n #define UV_VERSION_MAJOR 0\n #define UV_VERSION_MINOR 1\n \n-#define CARES_STATICLIB 1\n \n #include <stdint.h> /* int64_t */\n #include <sys/types.h> /* size_t */\n@@ -52,7 +71,8 @@ typedef enum {\n   UV_UNKNOWN = -1,\n   UV_OK = 0,\n   UV_EOF,\n-  UV_EACCESS,\n+  UV_EADDRINFO,\n+  UV_EACCES,\n   UV_EAGAIN,\n   UV_EADDRINUSE,\n   UV_EADDRNOTAVAIL,\n@@ -77,6 +97,7 @@ typedef enum {\n   UV_ENOBUFS,\n   UV_ENOMEM,\n   UV_ENOTDIR,\n+  UV_EISDIR,\n   UV_ENONET,\n   UV_ENOPROTOOPT,\n   UV_ENOTCONN,\n@@ -170,30 +191,30 @@ typedef struct uv_work_s uv_work_t;\n  * All callbacks in libuv are made asynchronously. That is they are never\n  * made by the function that takes them as a parameter.\n  */\n-uv_loop_t* uv_loop_new();\n-void uv_loop_delete(uv_loop_t*);\n+UV_EXTERN uv_loop_t* uv_loop_new(void);\n+UV_EXTERN void uv_loop_delete(uv_loop_t*);\n \n \n /*\n  * Returns the default loop.\n  */\n-uv_loop_t* uv_default_loop();\n+UV_EXTERN uv_loop_t* uv_default_loop(void);\n \n /*\n  * This function starts the event loop. It blocks until the reference count\n  * of the loop drops to zero.\n  */\n-int uv_run(uv_loop_t*);\n+UV_EXTERN int uv_run (uv_loop_t*);\n \n /*\n  * Manually modify the event loop's reference count. Useful if the user wants\n  * to have a handle or timeout that doesn't keep the loop alive.\n  */\n-void uv_ref(uv_loop_t*);\n-void uv_unref(uv_loop_t*);\n+UV_EXTERN void uv_ref(uv_loop_t*);\n+UV_EXTERN void uv_unref(uv_loop_t*);\n \n-void uv_update_time(uv_loop_t*);\n-int64_t uv_now(uv_loop_t*);\n+UV_EXTERN void uv_update_time(uv_loop_t*);\n+UV_EXTERN int64_t uv_now(uv_loop_t*);\n \n \n /*\n@@ -260,9 +281,9 @@ struct uv_err_s {\n  * On error the user should then call uv_last_error() to determine\n  * the error code.\n  */\n-uv_err_t uv_last_error(uv_loop_t*);\n-char* uv_strerror(uv_err_t err);\n-const char* uv_err_name(uv_err_t err);\n+UV_EXTERN uv_err_t uv_last_error(uv_loop_t*);\n+UV_EXTERN const char* uv_strerror(uv_err_t err);\n+UV_EXTERN const char* uv_err_name(uv_err_t err);\n \n \n #define UV_REQ_FIELDS \\\n@@ -291,7 +312,8 @@ UV_PRIVATE_REQ_TYPES\n  * initialized stream. req should be an uninitalized shutdown request\n  * struct. The cb is a called after shutdown is complete.\n  */\n-int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb);\n+UV_EXTERN int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle,\n+    uv_shutdown_cb cb);\n \n struct uv_shutdown_s {\n   UV_REQ_FIELDS\n@@ -320,7 +342,7 @@ struct uv_handle_s {\n  * Returns 1 if the prepare/check/idle handle has been started, 0 otherwise.\n  * For other handle types this always returns 1.\n  */\n-int uv_is_active(uv_handle_t* handle);\n+UV_EXTERN int uv_is_active(uv_handle_t* handle);\n \n /*\n  * Request handle to be closed. close_cb will be called asynchronously after\n@@ -330,7 +352,7 @@ int uv_is_active(uv_handle_t* handle);\n  * close_cb will still be deferred to the next iteration of the event loop.\n  * It gives you a chance to free up any resources associated with the handle.\n  */\n-void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n+UV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n \n \n /*\n@@ -339,7 +361,7 @@ void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n  * base and len members of the uv_buf_t struct. The user is responsible for\n  * freeing base after the uv_buf_t is done. Return struct passed by value.\n  */\n-uv_buf_t uv_buf_init(char* base, size_t len);\n+UV_EXTERN uv_buf_t uv_buf_init(char* base, size_t len);\n \n \n #define UV_STREAM_FIELDS \\\n@@ -364,7 +386,7 @@ struct uv_stream_s {\n   UV_STREAM_FIELDS\n };\n \n-int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n+UV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n \n /*\n  * This call is used in conjunction with uv_listen() to accept incoming\n@@ -377,7 +399,7 @@ int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n  * once, it may fail. It is suggested to only call uv_accept once per\n  * uv_connection_cb call.\n  */\n-int uv_accept(uv_stream_t* server, uv_stream_t* client);\n+UV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n \n /*\n  * Read data from an incoming stream. The callback will be made several\n@@ -389,15 +411,17 @@ int uv_accept(uv_stream_t* server, uv_stream_t* client);\n  * eof; it happens when libuv requested a buffer through the alloc callback\n  * but then decided that it didn't need that buffer.\n  */\n-int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read_cb read_cb);\n+UV_EXTERN int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n+    uv_read_cb read_cb);\n \n-int uv_read_stop(uv_stream_t*);\n+UV_EXTERN int uv_read_stop(uv_stream_t*);\n \n /*\n  * Extended read methods for receiving handles over a pipe. The pipe must be\n  * initialized with ipc == 1.\n  */\n-int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read2_cb read_cb);\n+UV_EXTERN int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n+    uv_read2_cb read_cb);\n \n \n /*\n@@ -418,11 +442,11 @@ int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb, uv_read2_cb read_cb);\n  *   uv_write(req, stream, b, 2);\n  *\n  */\n-int uv_write(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n-    uv_write_cb cb);\n+UV_EXTERN int uv_write(uv_write_t* req, uv_stream_t* handle,\n+    uv_buf_t bufs[], int bufcnt, uv_write_cb cb);\n \n-int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[], int bufcnt,\n-    uv_stream_t* send_handle, uv_write_cb cb);\n+UV_EXTERN int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[],\n+    int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);\n \n /* uv_write_t is a subclass of uv_req_t */\n struct uv_write_s {\n@@ -446,31 +470,44 @@ struct uv_tcp_s {\n   UV_TCP_PRIVATE_FIELDS\n };\n \n-int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n+UV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n \n /* Enable/disable Nagle's algorithm. */\n-int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\n+UV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\n \n /* Enable/disable TCP keep-alive.\n  *\n  * `ms` is the initial delay in seconds, ignored when `enable` is zero.\n  */\n-int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay);\n+UV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle, int enable,\n+    unsigned int delay);\n \n-int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n-int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n-int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name, int* namelen);\n-int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name, int* namelen);\n+/*\n+ * This setting applies to Windows only.\n+ * Enable/disable simultaneous asynchronous accept requests that are\n+ * queued by the operating system when listening for new tcp connections.\n+ * This setting is used to tune a tcp server for the desired performance.\n+ * Having simultaneous accepts can significantly improve the rate of\n+ * accepting connections (which is why it is enabled by default).\n+ */\n+UV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n+\n+UV_EXTERN int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n+UV_EXTERN int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n+UV_EXTERN int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n+    int* namelen);\n+UV_EXTERN int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n+    int* namelen);\n \n /*\n  * uv_tcp_connect, uv_tcp_connect6\n  * These functions establish IPv4 and IPv6 TCP connections. Provide an\n  * initialized TCP handle and an uninitialized uv_connect_t*. The callback\n  * will be made when the connection is estabished.\n  */\n-int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n+UV_EXTERN int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n     struct sockaddr_in address, uv_connect_cb cb);\n-int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n+UV_EXTERN int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n     struct sockaddr_in6 address, uv_connect_cb cb);\n \n /* uv_connect_t is a subclass of uv_req_t */\n@@ -537,7 +574,7 @@ struct uv_udp_send_s {\n  * Initialize a new UDP handle. The actual socket is created lazily.\n  * Returns 0 on success.\n  */\n-int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n+UV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n \n /*\n  * Bind to a IPv4 address and port.\n@@ -550,7 +587,8 @@ int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags);\n+UV_EXTERN int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n+    unsigned flags);\n \n /*\n  * Bind to a IPv6 address and port.\n@@ -563,23 +601,27 @@ int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr, unsigned flags);\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr, unsigned flags);\n-int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name, int* namelen);\n+UV_EXTERN int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n+    unsigned flags);\n+UV_EXTERN int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n+    int* namelen);\n \n /*\n  * Set membership for a multicast address\n  *\n  * Arguments:\n- *  handle              UDP handle. Should have been initialized with `uv_udp_init`.\n+ *  handle              UDP handle. Should have been initialized with\n+ *                      `uv_udp_init`.\n  *  multicast_addr      multicast address to set membership for\n  *  interface_addr      interface address\n  *  membership          Should be UV_JOIN_GROUP or UV_LEAVE_GROUP\n  *\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,\n-  const char* interface_addr, uv_membership membership);\n+UV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n+    const char* multicast_addr, const char* interface_addr,\n+    uv_membership membership);\n \n /*\n  * Send data. If the socket has not previously been bound with `uv_udp_bind`\n@@ -597,8 +639,9 @@ int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr,\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n-    int bufcnt, struct sockaddr_in addr, uv_udp_send_cb send_cb);\n+UV_EXTERN int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle,\n+    uv_buf_t bufs[], int bufcnt, struct sockaddr_in addr,\n+    uv_udp_send_cb send_cb);\n \n /*\n  * Send data. If the socket has not previously been bound with `uv_udp_bind6`,\n@@ -615,8 +658,9 @@ int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n-    int bufcnt, struct sockaddr_in6 addr, uv_udp_send_cb send_cb);\n+UV_EXTERN int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle,\n+    uv_buf_t bufs[], int bufcnt, struct sockaddr_in6 addr,\n+    uv_udp_send_cb send_cb);\n \n /*\n  * Receive data. If the socket has not previously been bound with `uv_udp_bind`\n@@ -631,7 +675,7 @@ int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t bufs[],\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n+UV_EXTERN int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n     uv_udp_recv_cb recv_cb);\n \n /*\n@@ -643,7 +687,7 @@ int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n  * Returns:\n  *  0 on success, -1 on error.\n  */\n-int uv_udp_recv_stop(uv_udp_t* handle);\n+UV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\n \n \n /*\n@@ -668,31 +712,31 @@ struct uv_tty_s {\n  *\n  * TTY streams which are not readable have blocking writes.\n  */\n-int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\n+UV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\n \n /*\n  * Set mode. 0 for normal, 1 for raw.\n  */\n-int uv_tty_set_mode(uv_tty_t*, int mode);\n+UV_EXTERN int uv_tty_set_mode(uv_tty_t*, int mode);\n \n /*\n  * To be called when the program exits. Resets TTY settings to default\n  * values for the next process to take over.\n  */\n-void uv_tty_reset_mode();\n+UV_EXTERN void uv_tty_reset_mode();\n \n /*\n  * Gets the current Window size. On success zero is returned.\n  */\n-int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n+UV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n \n /*\n  * Used to detect what type of stream should be used with a given file\n  * descriptor. Usually this will be used during initialization to guess the\n  * type of the stdio streams.\n  * For isatty() functionality use this function and test for UV_TTY.\n  */\n-uv_handle_type uv_guess_handle(uv_file file);\n+UV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n \n /*\n  * uv_pipe_t is a subclass of uv_stream_t\n@@ -711,16 +755,16 @@ struct uv_pipe_s {\n  * Initialize a pipe. The last argument is a boolean to indicate if\n  * this pipe will be used for handle passing between processes.\n  */\n-int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\n+UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\n \n /*\n  * Opens an existing file descriptor or HANDLE as a pipe.\n  */\n-void uv_pipe_open(uv_pipe_t*, uv_file file);\n+UV_EXTERN void uv_pipe_open(uv_pipe_t*, uv_file file);\n \n-int uv_pipe_bind(uv_pipe_t* handle, const char* name);\n+UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\n \n-int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n+UV_EXTERN void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n     const char* name, uv_connect_cb cb);\n \n \n@@ -736,11 +780,11 @@ struct uv_prepare_s {\n   UV_PREPARE_PRIVATE_FIELDS\n };\n \n-int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\n+UV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\n \n-int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n+UV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n \n-int uv_prepare_stop(uv_prepare_t* prepare);\n+UV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n \n \n /*\n@@ -754,11 +798,11 @@ struct uv_check_s {\n   UV_CHECK_PRIVATE_FIELDS\n };\n \n-int uv_check_init(uv_loop_t*, uv_check_t* check);\n+UV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\n \n-int uv_check_start(uv_check_t* check, uv_check_cb cb);\n+UV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\n \n-int uv_check_stop(uv_check_t* check);\n+UV_EXTERN int uv_check_stop(uv_check_t* check);\n \n \n /*\n@@ -774,11 +818,11 @@ struct uv_idle_s {\n   UV_IDLE_PRIVATE_FIELDS\n };\n \n-int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\n+UV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\n \n-int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n+UV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n \n-int uv_idle_stop(uv_idle_t* idle);\n+UV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n \n \n /*\n@@ -796,14 +840,15 @@ struct uv_async_s {\n   UV_ASYNC_PRIVATE_FIELDS\n };\n \n-int uv_async_init(uv_loop_t*, uv_async_t* async, uv_async_cb async_cb);\n+UV_EXTERN int uv_async_init(uv_loop_t*, uv_async_t* async,\n+    uv_async_cb async_cb);\n \n /*\n  * This can be called from other threads to wake up a libuv thread.\n  *\n  * libuv is single threaded at the moment.\n  */\n-int uv_async_send(uv_async_t* async);\n+UV_EXTERN int uv_async_send(uv_async_t* async);\n \n \n /*\n@@ -817,39 +862,37 @@ struct uv_timer_s {\n   UV_TIMER_PRIVATE_FIELDS\n };\n \n-int uv_timer_init(uv_loop_t*, uv_timer_t* timer);\n+UV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* timer);\n \n-int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb, int64_t timeout,\n-    int64_t repeat);\n+UV_EXTERN int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb,\n+    int64_t timeout, int64_t repeat);\n \n-int uv_timer_stop(uv_timer_t* timer);\n+UV_EXTERN int uv_timer_stop(uv_timer_t* timer);\n \n /*\n  * Stop the timer, and if it is repeating restart it using the repeat value\n  * as the timeout. If the timer has never been started before it returns -1 and\n  * sets the error to UV_EINVAL.\n  */\n-int uv_timer_again(uv_timer_t* timer);\n+UV_EXTERN int uv_timer_again(uv_timer_t* timer);\n \n /*\n  * Set the repeat value. Note that if the repeat value is set from a timer\n  * callback it does not immediately take effect. If the timer was nonrepeating\n  * before, it will have been stopped. If it was repeating, then the old repeat\n  * value will have been used to schedule the next timeout.\n  */\n-void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);\n+UV_EXTERN void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);\n \n-int64_t uv_timer_get_repeat(uv_timer_t* timer);\n+UV_EXTERN int64_t uv_timer_get_repeat(uv_timer_t* timer);\n \n \n /* c-ares integration initialize and terminate */\n-int uv_ares_init_options(uv_loop_t*,\n-                         ares_channel *channelptr,\n-                         struct ares_options *options,\n-                         int optmask);\n+UV_EXTERN  int uv_ares_init_options(uv_loop_t*,\n+    ares_channel *channelptr, struct ares_options *options, int optmask);\n \n /* TODO remove the loop argument from this function? */\n-void uv_ares_destroy(uv_loop_t*, ares_channel channel);\n+UV_EXTERN void uv_ares_destroy(uv_loop_t*, ares_channel channel);\n \n \n /*\n@@ -877,14 +920,11 @@ struct uv_getaddrinfo_s {\n  *\n  * On error NXDOMAIN the status code will be non-zero and UV_ENOENT returned.\n  */\n- int uv_getaddrinfo(uv_loop_t*,\n-                    uv_getaddrinfo_t* handle,\n-                    uv_getaddrinfo_cb getaddrinfo_cb,\n-                    const char* node,\n-                    const char* service,\n-                    const struct addrinfo* hints);\n+UV_EXTERN int uv_getaddrinfo(uv_loop_t*, uv_getaddrinfo_t* handle,\n+    uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service,\n+    const struct addrinfo* hints);\n \n-void uv_freeaddrinfo(struct addrinfo* ai);\n+UV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n \n /* uv_spawn() options */\n typedef struct uv_process_options_s {\n@@ -934,13 +974,18 @@ struct uv_process_s {\n };\n \n /* Initializes uv_process_t and starts the process. */\n-int uv_spawn(uv_loop_t*, uv_process_t*, uv_process_options_t options);\n+UV_EXTERN int uv_spawn(uv_loop_t*, uv_process_t*,\n+    uv_process_options_t options);\n \n /*\n  * Kills the process with the specified signal. The user must still\n  * call uv_close on the process.\n  */\n-int uv_process_kill(uv_process_t*, int signum);\n+UV_EXTERN int uv_process_kill(uv_process_t*, int signum);\n+\n+\n+/* Kills the process with the specified signal. */\n+UV_EXTERN uv_err_t uv_kill(int pid, int signum);\n \n \n /*\n@@ -955,8 +1000,8 @@ struct uv_work_s {\n };\n \n /* Queues a work request to execute asynchronously on the thread pool. */\n-int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb,\n-    uv_after_work_cb after_work_cb);\n+UV_EXTERN int uv_queue_work(uv_loop_t* loop, uv_work_t* req,\n+    uv_work_cb work_cb, uv_after_work_cb after_work_cb);\n \n \n \n@@ -1018,58 +1063,66 @@ struct uv_fs_s {\n   UV_FS_PRIVATE_FIELDS\n };\n \n-void uv_fs_req_cleanup(uv_fs_t* req);\n+UV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\n \n-int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    uv_fs_cb cb);\n \n-int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n-    int mode, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    int flags, int mode, uv_fs_cb cb);\n \n-int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n-    size_t length, off_t offset, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    void* buf, size_t length, off_t offset, uv_fs_cb cb);\n \n-int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    uv_fs_cb cb);\n+\n+UV_EXTERN int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    void* buf, size_t length, off_t offset, uv_fs_cb cb);\n \n-int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, void* buf,\n-    size_t length, off_t offset, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    int mode, uv_fs_cb cb);\n \n-int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n+UV_EXTERN int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb);\n \n-int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req,\n+    const char* path, int flags, uv_fs_cb cb);\n \n-int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n+UV_EXTERN int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb);\n \n-int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n-\n-int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    uv_fs_cb cb);\n \n-int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+UV_EXTERN int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, uv_fs_cb cb);\n \n-int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    uv_fs_cb cb);\n \n-int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    uv_fs_cb cb);\n \n-int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+UV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n     off_t offset, uv_fs_cb cb);\n \n-int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n+UV_EXTERN int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n     uv_file in_fd, off_t in_offset, size_t length, uv_fs_cb cb);\n \n-int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode,\n-    uv_fs_cb cb);\n+UV_EXTERN int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    int mode, uv_fs_cb cb);\n \n-int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime,\n-    double mtime, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    double atime, double mtime, uv_fs_cb cb);\n \n-int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime,\n-    double mtime, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    double atime, double mtime, uv_fs_cb cb);\n \n-int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    uv_fs_cb cb);\n \n-int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+UV_EXTERN int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, uv_fs_cb cb);\n \n /*\n@@ -1078,20 +1131,20 @@ int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n  */\n #define UV_FS_SYMLINK_DIR          0x0001\n \n-int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+UV_EXTERN int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     const char* new_path, int flags, uv_fs_cb cb);\n \n-int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+UV_EXTERN int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n     uv_fs_cb cb);\n \n-int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode,\n-    uv_fs_cb cb);\n+UV_EXTERN int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    int mode, uv_fs_cb cb);\n \n-int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, int uid,\n-    int gid, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path,\n+    int uid, int gid, uv_fs_cb cb);\n \n-int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, int uid,\n-    int gid, uv_fs_cb cb);\n+UV_EXTERN int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n+    int uid, int gid, uv_fs_cb cb);\n \n \n enum uv_fs_event {\n@@ -1112,32 +1165,52 @@ struct uv_fs_event_s {\n  * See: http://en.wikipedia.org/wiki/Load_(computing)\n  * (Returns [0,0,0] for windows and cygwin)\n  */\n-void uv_loadavg(double avg[3]);\n+UV_EXTERN void uv_loadavg(double avg[3]);\n+\n \n /*\n-* If filename is a directory then we will watch for all events in that\n-* directory. If filename is a file - we will only get events from that\n-* file. Subdirectories are not watched.\n-*/\n-int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n-    const char* filename, uv_fs_event_cb cb);\n+ * Flags to be passed to uv_fs_event_init.\n+ */\n+enum uv_fs_event_flags {\n+  /*\n+   * By default, if the fs event watcher is given a directory name, we will\n+   * watch for all events in that directory. This flags overrides this behavior\n+   * and makes fs_event report only changes to the directory entry itself. This\n+   * flag does not affect individual files watched.\n+   * This flag is currently not implemented yet on any backend.\n+   */\n+ UV_FS_EVENT_WATCH_ENTRY = 1,\n+\n+  /*\n+   * By default uv_fs_event will try to use a kernel interface such as inotify\n+   * or kqueue to detect events. This may not work on remote filesystems such\n+   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n+   * regular interval.\n+   * This flag is currently not implemented yet on any backend.\n+   */\n+  UV_FS_EVENT_STAT = 2\n+};\n+\n+\n+UV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n+    const char* filename, uv_fs_event_cb cb, int flags);\n \n /* Utility */\n \n /* Convert string ip addresses to binary structures */\n-struct sockaddr_in uv_ip4_addr(const char* ip, int port);\n-struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n+UV_EXTERN struct sockaddr_in uv_ip4_addr(const char* ip, int port);\n+UV_EXTERN struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n \n /* Convert binary addresses to strings */\n-int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);\n-int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n+UV_EXTERN int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);\n+UV_EXTERN int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n \n /* Gets the executable path */\n-int uv_exepath(char* buffer, size_t* size);\n+UV_EXTERN int uv_exepath(char* buffer, size_t* size);\n \n /* Gets memory info in bytes */\n-uint64_t uv_get_free_memory(void);\n-uint64_t uv_get_total_memory(void);\n+UV_EXTERN uint64_t uv_get_free_memory(void);\n+UV_EXTERN uint64_t uv_get_total_memory(void);\n \n /*\n  * Returns the current high-resolution real time. This is expressed in\n@@ -1148,7 +1221,20 @@ uint64_t uv_get_total_memory(void);\n  * Note not every platform can support nanosecond resolution; however, this\n  * value will always be in nanoseconds.\n  */\n-extern uint64_t uv_hrtime(void);\n+UV_EXTERN extern uint64_t uv_hrtime(void);\n+\n+\n+/*\n+ * Opens a shared library. The filename is in utf-8. On success, -1 is\n+ * and the variable pointed by library receives a handle to the library.\n+ */\n+UV_EXTERN uv_err_t uv_dlopen(const char* filename, uv_lib_t* library);\n+UV_EXTERN uv_err_t uv_dlclose(uv_lib_t library);\n+\n+/*\n+ * Retrieves a data pointer from a dynamic library.\n+ */\n+UV_EXTERN uv_err_t uv_dlsym(uv_lib_t library, const char* name, void** ptr);\n \n \n /* the presence of these unions force similar struct layout */"}, {"sha": "6ded638093f8f71ad5f262c889fc7b7f2872bd66", "filename": "src/rt/libuv/src/ares/config_win32/ares_config.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -4,9 +4,6 @@\n /* when building c-ares library */\n #define CARES_BUILDING_LIBRARY 1\n \n-/* when not building a shared library */\n-#define CARES_STATICLIB 1\n-\n /* Copyright (C) 2004 - 2008 by Daniel Stenberg et al\n  *\n  * Permission to use, copy, modify, and distribute this software and its"}, {"sha": "19d5b91501869c51cc61b287dd43b51b5e138359", "filename": "src/rt/libuv/src/unix/core.c", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -38,18 +38,22 @@\n #include <limits.h> /* PATH_MAX */\n #include <sys/uio.h> /* writev */\n \n+#ifdef __linux__\n+# include <sys/ioctl.h>\n+#endif\n+\n #ifdef __sun\n # include <sys/types.h>\n # include <sys/wait.h>\n #endif\n \n-#if defined(__APPLE__)\n-#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n+#ifdef __APPLE__\n+# include <mach-o/dyld.h> /* _NSGetExecutablePath */\n #endif\n \n-#if defined(__FreeBSD__)\n-#include <sys/sysctl.h>\n-#include <sys/wait.h>\n+#ifdef __FreeBSD__\n+# include <sys/sysctl.h>\n+# include <sys/wait.h>\n #endif\n \n static uv_loop_t default_loop_struct;\n@@ -154,7 +158,7 @@ void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n }\n \n \n-uv_loop_t* uv_loop_new() {\n+uv_loop_t* uv_loop_new(void) {\n   uv_loop_t* loop = calloc(1, sizeof(uv_loop_t));\n   loop->ev = ev_loop_new(0);\n   ev_set_userdata(loop->ev, loop);\n@@ -169,7 +173,7 @@ void uv_loop_delete(uv_loop_t* loop) {\n }\n \n \n-uv_loop_t* uv_default_loop() {\n+uv_loop_t* uv_default_loop(void) {\n   if (!default_loop_ptr) {\n     default_loop_ptr = &default_loop_struct;\n #if HAVE_KQUEUE\n@@ -593,9 +597,17 @@ static int uv_getaddrinfo_done(eio_req* req) {\n   free(handle->service);\n   free(handle->hostname);\n \n-  if (handle->retcode != 0) {\n-    /* TODO how to display gai error strings? */\n-    uv__set_sys_error(handle->loop, handle->retcode);\n+  if (handle->retcode == 0) {\n+    /* OK */\n+#if EAI_NODATA /* FreeBSD deprecated EAI_NODATA */\n+  } else if (handle->retcode == EAI_NONAME || handle->retcode == EAI_NODATA) {\n+#else\n+  } else if (handle->retcode == EAI_NONAME) {\n+#endif\n+    uv__set_sys_error(handle->loop, ENOENT); /* FIXME compatibility hack */\n+  } else {\n+    handle->loop->last_err.code = UV_EADDRINFO;\n+    handle->loop->last_err.sys_errno_ = handle->retcode;\n   }\n \n   handle->cb(handle, handle->retcode, res);\n@@ -734,6 +746,9 @@ int uv__close(int fd) {\n \n \n int uv__nonblock(int fd, int set) {\n+#if FIONBIO\n+  return ioctl(fd, FIONBIO, &set);\n+#else\n   int flags;\n \n   if ((flags = fcntl(fd, F_GETFL)) == -1) {\n@@ -751,10 +766,17 @@ int uv__nonblock(int fd, int set) {\n   }\n \n   return 0;\n+#endif\n }\n \n \n int uv__cloexec(int fd, int set) {\n+#if __linux__\n+  /* Linux knows only FD_CLOEXEC so we can safely omit the fcntl(F_GETFD)\n+   * syscall. CHECKME: That's probably true for other Unices as well.\n+   */\n+  return fcntl(fd, F_SETFD, set ? FD_CLOEXEC : 0);\n+#else\n   int flags;\n \n   if ((flags = fcntl(fd, F_GETFD)) == -1) {\n@@ -772,6 +794,7 @@ int uv__cloexec(int fd, int set) {\n   }\n \n   return 0;\n+#endif\n }\n \n "}, {"sha": "024e7d5bf9bcac6a07e2b6c5d98f05881d58d6d7", "filename": "src/rt/libuv/src/unix/cygwin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -69,7 +69,8 @@ uint64_t uv_get_total_memory(void) {\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n-                     uv_fs_event_cb cb) {\n+                     uv_fs_event_cb cb,\n+                     int flags) {\n   uv__set_sys_error(loop, ENOSYS);\n   return -1;\n }"}, {"sha": "6c4ddff89e6aaef0d1b7f0eace3cab3b4eb47f78", "filename": "src/rt/libuv/src/unix/dl.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,57 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+\n+\n+uv_err_t uv_dlopen(const char* filename, uv_lib_t* library) {\n+  void* handle = dlopen(filename, RTLD_LAZY);\n+  if (handle == NULL) {\n+    return uv__new_sys_error(errno);\n+  }\n+\n+  *library = handle;\n+  return uv_ok_;\n+}\n+\n+\n+uv_err_t uv_dlclose(uv_lib_t library) {\n+  if (dlclose(library) != 0) {\n+    return uv__new_sys_error(errno);\n+  }\n+\n+  return uv_ok_;\n+}\n+\n+\n+uv_err_t uv_dlsym(uv_lib_t library, const char* name, void** ptr) {\n+  void* address = dlsym(library, name);\n+  if (address == NULL) {\n+    return uv__new_sys_error(errno);\n+  }\n+\n+  *ptr = (void*) address;\n+  return uv_ok_;\n+}"}, {"sha": "ac8bdd72cc8c20e7b722c60dca7f477027790aa6", "filename": "src/rt/libuv/src/unix/error.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -59,8 +59,10 @@ void uv_fatal_error(const int errorno, const char* syscall) {\n static int uv__translate_lib_error(int code) {\n   switch (code) {\n     case UV_ENOSYS: return ENOSYS;\n+    case UV_ENOTSOCK: return ENOTSOCK;\n     case UV_ENOENT: return ENOENT;\n-    case UV_EACCESS: return EACCES;\n+    case UV_EACCES: return EACCES;\n+    case UV_EAFNOSUPPORT: return EAFNOSUPPORT;\n     case UV_EBADF: return EBADF;\n     case UV_EPIPE: return EPIPE;\n     case UV_EAGAIN: return EAGAIN;\n@@ -73,8 +75,10 @@ static int uv__translate_lib_error(int code) {\n     case UV_EADDRINUSE: return EADDRINUSE;\n     case UV_EADDRNOTAVAIL: return EADDRNOTAVAIL;\n     case UV_ENOTDIR: return ENOTDIR;\n+    case UV_EISDIR: return EISDIR;\n     case UV_ENOTCONN: return ENOTCONN;\n     case UV_EEXIST: return EEXIST;\n+    case UV_EHOSTUNREACH: return EHOSTUNREACH;\n     default: return -1;\n   }\n \n@@ -87,8 +91,10 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n   switch (sys_errno) {\n     case 0: return UV_OK;\n     case ENOSYS: return UV_ENOSYS;\n+    case ENOTSOCK: return UV_ENOTSOCK;\n     case ENOENT: return UV_ENOENT;\n-    case EACCES: return UV_EACCESS;\n+    case EACCES: return UV_EACCES;\n+    case EAFNOSUPPORT: return UV_EAFNOSUPPORT;\n     case EBADF: return UV_EBADF;\n     case EPIPE: return UV_EPIPE;\n     case EAGAIN: return UV_EAGAIN;\n@@ -101,8 +107,10 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n     case EADDRINUSE: return UV_EADDRINUSE;\n     case EADDRNOTAVAIL: return UV_EADDRNOTAVAIL;\n     case ENOTDIR: return UV_ENOTDIR;\n+    case EISDIR: return UV_EISDIR;\n     case ENOTCONN: return UV_ENOTCONN;\n     case EEXIST: return UV_EEXIST;\n+    case EHOSTUNREACH: return UV_EHOSTUNREACH;\n     case EAI_NONAME: return UV_ENOENT;\n     default: return UV_UNKNOWN;\n   }\n@@ -116,14 +124,17 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n  *  a) rely on what the system provides us\n  *  b) reverse-map the error codes\n  */\n-char* uv_strerror(uv_err_t err) {\n+const char* uv_strerror(uv_err_t err) {\n   int errorno;\n \n   if (err.sys_errno_)\n     errorno = err.sys_errno_;\n   else\n     errorno = uv__translate_lib_error(err.code);\n \n+  if (err.code == UV_EADDRINFO)\n+    return gai_strerror(errorno);\n+\n   if (errorno == -1)\n     return \"Unknown error\";\n   else"}, {"sha": "e8101e562f1f7e00dbf0b040373ed2d0a942bf4d", "filename": "src/rt/libuv/src/unix/ev/ev_epoll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -225,7 +225,7 @@ epoll_init (EV_P_ int flags)\n #ifdef EPOLL_CLOEXEC\n   backend_fd = epoll_create1 (EPOLL_CLOEXEC);\n \n-  if (backend_fd <= 0)\n+  if (backend_fd < 0)\n #endif\n     backend_fd = epoll_create (256);\n "}, {"sha": "00180cd41d36dd32225e30912fe565360aa7c7ff", "filename": "src/rt/libuv/src/unix/kqueue.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -86,9 +86,13 @@ void uv__kqueue_hack(EV_P_ int fflags, ev_io *w) {\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n-                     uv_fs_event_cb cb) {\n+                     uv_fs_event_cb cb,\n+                     int flags) {\n   int fd;\n \n+  /* We don't support any flags yet. */\n+  assert(!flags);\n+\n   if (cb == NULL) {\n     uv__set_sys_error(loop, EINVAL);\n     return -1;\n@@ -122,7 +126,8 @@ void uv__fs_event_destroy(uv_fs_event_t* handle) {\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n-                     uv_fs_event_cb cb) {\n+                     uv_fs_event_cb cb,\n+                     int flags) {\n   uv__set_sys_error(loop, ENOSYS);\n   return -1;\n }"}, {"sha": "f91839f7f920d205d42d39f26ff3560e240cd970", "filename": "src/rt/libuv/src/unix/linux.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -156,10 +156,14 @@ static void uv__inotify_read(EV_P_ ev_io* w, int revents) {\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n-                     uv_fs_event_cb cb) {\n-  int flags;\n+                     uv_fs_event_cb cb,\n+                     int flags) {\n+  int events;\n   int fd;\n \n+  /* We don't support any flags yet. */\n+  assert(!flags);\n+\n   /*\n    * TODO share a single inotify fd across the event loop?\n    * We'll run into fs.inotify.max_user_instances if we\n@@ -170,15 +174,15 @@ int uv_fs_event_init(uv_loop_t* loop,\n     return -1;\n   }\n \n-  flags = IN_ATTRIB\n-        | IN_CREATE\n-        | IN_MODIFY\n-        | IN_DELETE\n-        | IN_DELETE_SELF\n-        | IN_MOVED_FROM\n-        | IN_MOVED_TO;\n+  events = IN_ATTRIB\n+         | IN_CREATE\n+         | IN_MODIFY\n+         | IN_DELETE\n+         | IN_DELETE_SELF\n+         | IN_MOVED_FROM\n+         | IN_MOVED_TO;\n \n-  if (inotify_add_watch(fd, filename, flags) == -1) {\n+  if (inotify_add_watch(fd, filename, events) == -1) {\n     uv__set_sys_error(loop, errno);\n     uv__close(fd);\n     return -1;"}, {"sha": "87959a6e5da957884a3602ecfaf1e688f3c646d6", "filename": "src/rt/libuv/src/unix/pipe.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -177,7 +177,7 @@ void uv_pipe_open(uv_pipe_t* handle, uv_file fd) {\n }\n \n \n-int uv_pipe_connect(uv_connect_t* req,\n+void uv_pipe_connect(uv_connect_t* req,\n                     uv_pipe_t* handle,\n                     const char* name,\n                     uv_connect_cb cb) {\n@@ -209,7 +209,7 @@ int uv_pipe_connect(uv_connect_t* req,\n   while (r == -1 && errno == EINTR);\n \n   if (r == -1) {\n-    uv__set_sys_error(handle->loop, errno);\n+    status = errno;\n     uv__close(sockfd);\n     goto out;\n   }\n@@ -237,7 +237,6 @@ int uv_pipe_connect(uv_connect_t* req,\n    * return 0 and let the callback handle errors.\n    */\n   errno = saved_errno;\n-  return 0;\n }\n \n "}, {"sha": "555be5a6e56f5b634e4282be730d4adecb58c229", "filename": "src/rt/libuv/src/unix/process.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -300,3 +300,14 @@ int uv_process_kill(uv_process_t* process, int signum) {\n     return 0;\n   }\n }\n+\n+\n+uv_err_t uv_kill(int pid, int signum) {\n+  int r = kill(pid, signum);\n+\n+  if (r) {\n+    return uv__new_sys_error(errno);\n+  } else {\n+    return uv_ok_;\n+  }\n+}"}, {"sha": "3cdeaa8cf7b22f46f9518a6721c9661e68971149", "filename": "src/rt/libuv/src/unix/stream.c", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -62,6 +62,7 @@ void uv__stream_init(uv_loop_t* loop,\n   stream->accepted_fd = -1;\n   stream->fd = -1;\n   stream->delayed_error = 0;\n+  stream->blocking = 0;\n   ngx_queue_init(&stream->write_queue);\n   ngx_queue_init(&stream->write_completed_queue);\n   stream->write_queue_size = 0;\n@@ -340,9 +341,9 @@ static void uv__write(uv_stream_t* stream) {\n   int iovcnt;\n   ssize_t n;\n \n-  assert(stream->fd >= 0);\n+start:\n \n-  /* TODO: should probably while(1) here until EAGAIN */\n+  assert(stream->fd >= 0);\n \n   /* Get the request at the head of the queue. */\n   req = uv_write_queue_head(stream);\n@@ -353,14 +354,16 @@ static void uv__write(uv_stream_t* stream) {\n \n   assert(req->handle == stream);\n \n-  /* Cast to iovec. We had to have our own uv_buf_t instead of iovec\n+  /*\n+   * Cast to iovec. We had to have our own uv_buf_t instead of iovec\n    * because Windows's WSABUF is not an iovec.\n    */\n   assert(sizeof(uv_buf_t) == sizeof(struct iovec));\n   iov = (struct iovec*) &(req->bufs[req->write_index]);\n   iovcnt = req->bufcnt - req->write_index;\n \n-  /* Now do the actual writev. Note that we've been updating the pointers\n+  /*\n+   * Now do the actual writev. Note that we've been updating the pointers\n    * inside the iov each time we write. So there is no need to offset it.\n    */\n \n@@ -409,6 +412,9 @@ static void uv__write(uv_stream_t* stream) {\n       stream->write_queue_size -= uv__write_req_size(req);\n       uv__write_req_finish(req);\n       return;\n+    } else if (stream->blocking) {\n+      /* If this is a blocking stream, try again. */\n+      goto start;\n     }\n   } else {\n     /* Successful write */\n@@ -426,8 +432,17 @@ static void uv__write(uv_stream_t* stream) {\n         stream->write_queue_size -= n;\n         n = 0;\n \n-        /* There is more to write. Break and ensure the watcher is pending. */\n-        break;\n+        /* There is more to write. */\n+        if (stream->blocking) {\n+          /*\n+           * If we're blocking then we should not be enabling the write\n+           * watcher - instead we need to try again.\n+           */\n+          goto start;\n+        } else {\n+          /* Break loop and ensure the watcher is pending. */\n+          break;\n+        }\n \n       } else {\n         /* Finished writing the buf at index req->write_index. */\n@@ -453,6 +468,9 @@ static void uv__write(uv_stream_t* stream) {\n   /* Either we've counted n down to zero or we've got EAGAIN. */\n   assert(n == 0 || n == -1);\n \n+  /* Only non-blocking streams should use the write_watcher. */\n+  assert(!stream->blocking);\n+\n   /* We're not done. */\n   ev_io_start(stream->loop->ev, &stream->write_watcher);\n }\n@@ -862,6 +880,13 @@ int uv_write2(uv_write_t* req, uv_stream_t* stream, uv_buf_t bufs[], int bufcnt,\n   if (empty_queue) {\n     uv__write(stream);\n   } else {\n+    /*\n+     * blocking streams should never have anything in the queue.\n+     * if this assert fires then somehow the blocking stream isn't being\n+     * sufficently flushed in uv__write.\n+     */\n+    assert(!stream->blocking);\n+\n     ev_io_start(stream->loop->ev, &stream->write_watcher);\n   }\n "}, {"sha": "f53122079865ea88e760ae69e80649097a026f53", "filename": "src/rt/libuv/src/unix/sunos.c", "status": "modified", "additions": 85, "deletions": 5, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -23,13 +23,17 @@\n \n #include <stdio.h>\n #include <stdint.h>\n+#include <stdlib.h>\n+#include <string.h>\n #include <assert.h>\n #include <errno.h>\n \n-#include <sys/time.h>\n #include <sys/loadavg.h>\n+#include <sys/time.h>\n+#include <sys/port.h>\n #include <unistd.h>\n #include <kstat.h>\n+#include <port.h>\n \n \n uint64_t uv_hrtime() {\n@@ -81,15 +85,91 @@ void uv_loadavg(double avg[3]) {\n }\n \n \n+static void uv__fs_event_rearm(uv_fs_event_t *handle) {\n+  if (port_associate(handle->fd,\n+                     PORT_SOURCE_FILE,\n+                     (uintptr_t) &handle->fo,\n+                     FILE_ATTRIB | FILE_MODIFIED,\n+                     NULL) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+  }\n+}\n+\n+\n+static void uv__fs_event_read(EV_P_ ev_io* w, int revents) {\n+  uv_fs_event_t *handle;\n+  timespec_t timeout;\n+  port_event_t pe;\n+  int events;\n+  int r;\n+\n+  handle = container_of(w, uv_fs_event_t, event_watcher);\n+\n+  do {\n+    /* TODO use port_getn() */\n+    do {\n+      memset(&timeout, 0, sizeof timeout);\n+      r = port_get(handle->fd, &pe, &timeout);\n+    }\n+    while (r == -1 && errno == EINTR);\n+\n+    if (r == -1 && errno == ETIME)\n+      break;\n+\n+    assert((r == 0) && \"unexpected port_get() error\");\n+\n+    events = 0;\n+    if (pe.portev_events & (FILE_ATTRIB | FILE_MODIFIED))\n+      events |= UV_CHANGE;\n+    if (pe.portev_events & ~(FILE_ATTRIB | FILE_MODIFIED))\n+      events |= UV_RENAME;\n+    assert(events != 0);\n+\n+    handle->cb(handle, NULL, events, 0);\n+  }\n+  while (handle->fd != -1);\n+\n+  if (handle->fd != -1)\n+    uv__fs_event_rearm(handle);\n+}\n+\n+\n int uv_fs_event_init(uv_loop_t* loop,\n                      uv_fs_event_t* handle,\n                      const char* filename,\n-                     uv_fs_event_cb cb) {\n-  uv__set_sys_error(loop, ENOSYS);\n-  return -1;\n+                     uv_fs_event_cb cb,\n+                     int flags) {\n+  int portfd;\n+\n+  /* We don't support any flags yet. */\n+  assert(!flags);\n+\n+  if ((portfd = port_create()) == -1) {\n+    uv__set_sys_error(loop, errno);\n+    return -1;\n+  }\n+\n+  uv__handle_init(loop, (uv_handle_t*)handle, UV_FS_EVENT);\n+  handle->filename = strdup(filename);\n+  handle->fd = portfd;\n+  handle->cb = cb;\n+\n+  memset(&handle->fo, 0, sizeof handle->fo);\n+  handle->fo.fo_name = handle->filename;\n+  uv__fs_event_rearm(handle);\n+\n+  ev_io_init(&handle->event_watcher, uv__fs_event_read, portfd, EV_READ);\n+  ev_io_start(loop->ev, &handle->event_watcher);\n+\n+  return 0;\n }\n \n \n void uv__fs_event_destroy(uv_fs_event_t* handle) {\n-  assert(0 && \"implement me\");\n+  ev_io_stop(handle->loop->ev, &handle->event_watcher);\n+  uv__close(handle->fd);\n+  handle->fd = -1;\n+  free(handle->filename);\n+  handle->filename = NULL;\n+  handle->fo.fo_name = NULL;\n }"}, {"sha": "ee94ab3ed84e8200209a67430f75e7f404cca8cf", "filename": "src/rt/libuv/src/unix/tcp.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -319,3 +319,8 @@ int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n \n   return 0;\n }\n+\n+\n+int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {\n+  return 0;\n+}"}, {"sha": "de77f5c46abb878f0b6146a4967d9c8fc3b3b9e6", "filename": "src/rt/libuv/src/unix/tty.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -41,7 +41,6 @@ int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n     uv__stream_open((uv_stream_t*)tty, fd, UV_READABLE);\n   } else {\n     /* Note: writable tty we set to blocking mode. */\n-    uv__nonblock(fd, 0);\n     uv__stream_open((uv_stream_t*)tty, fd, UV_WRITABLE);\n     tty->blocking = 1;\n   }"}, {"sha": "599d6257890e3644a18c712ffd3368654ce22db3", "filename": "src/rt/libuv/src/uv-common.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -48,12 +48,16 @@ uv_buf_t uv_buf_init(char* base, size_t len) {\n }\n \n \n+const uv_err_t uv_ok_ = { UV_OK, 0 };\n+\n+\n const char* uv_err_name(uv_err_t err) {\n   switch (err.code) {\n     case UV_UNKNOWN: return \"UNKNOWN\";\n     case UV_OK: return \"OK\";\n     case UV_EOF: return \"EOF\";\n-    case UV_EACCESS: return \"EACCESS\";\n+    case UV_EADDRINFO: return \"EADDRINFO\";\n+    case UV_EACCES: return \"EACCES\";\n     case UV_EAGAIN: return \"EAGAIN\";\n     case UV_EADDRINUSE: return \"EADDRINUSE\";\n     case UV_EADDRNOTAVAIL: return \"EADDRNOTAVAIL\";\n@@ -71,6 +75,7 @@ const char* uv_err_name(uv_err_t err) {\n     case UV_EINVAL: return \"EINVAL\";\n     case UV_EISCONN: return \"EISCONN\";\n     case UV_EMFILE: return \"EMFILE\";\n+    case UV_EMSGSIZE: return \"EMSGSIZE\";\n     case UV_ENETDOWN: return \"ENETDOWN\";\n     case UV_ENETUNREACH: return \"ENETUNREACH\";\n     case UV_ENFILE: return \"ENFILE\";\n@@ -89,6 +94,12 @@ const char* uv_err_name(uv_err_t err) {\n     case UV_EPROTONOSUPPORT: return \"EPROTONOSUPPORT\";\n     case UV_EPROTOTYPE: return \"EPROTOTYPE\";\n     case UV_ETIMEDOUT: return \"ETIMEDOUT\";\n+    case UV_ECHARSET: return \"ECHARSET\";\n+    case UV_EAIFAMNOSUPPORT: return \"EAIFAMNOSUPPORT\";\n+    case UV_EAINONAME: return \"EAINONAME\";\n+    case UV_EAISERVICE: return \"EAISERVICE\";\n+    case UV_EAISOCKTYPE: return \"EAISOCKTYPE\";\n+    case UV_ESHUTDOWN: return \"ESHUTDOWN\";\n     case UV_EEXIST: return \"EEXIST\";\n     default:\n       assert(0);\n@@ -115,6 +126,14 @@ void uv__set_artificial_error(uv_loop_t* loop, uv_err_code code) {\n }\n \n \n+uv_err_t uv__new_sys_error(int sys_error) {\n+  uv_err_t error;\n+  error.code = uv_translate_sys_error(sys_error);\n+  error.sys_errno_ = sys_error;\n+  return error;\n+}\n+\n+\n uv_err_t uv_last_error(uv_loop_t* loop) {\n   return loop->last_err;\n }"}, {"sha": "eecb1304386ec7e677a3c742bfe7e0c8a8832d06", "filename": "src/rt/libuv/src/uv-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -48,10 +48,13 @@ void uv_add_ares_handle(uv_loop_t* loop, uv_ares_task_t* handle);\n \n int uv_ares_handles_empty(uv_loop_t* loop);\n \n+extern const uv_err_t uv_ok_;\n+\n uv_err_code uv_translate_sys_error(int sys_errno);\n void uv__set_error(uv_loop_t* loop, uv_err_code code, int sys_error);\n void uv__set_sys_error(uv_loop_t* loop, int sys_error);\n void uv__set_artificial_error(uv_loop_t* loop, uv_err_code code);\n+uv_err_t uv__new_sys_error(int sys_error);\n \n int uv__tcp_bind(uv_tcp_t* handle, struct sockaddr_in addr);\n int uv__tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6 addr);"}, {"sha": "4914fb4190de1adc19d895d7e452774e2de9178c", "filename": "src/rt/libuv/src/win/core.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -40,6 +40,10 @@ static uv_once_t uv_default_loop_init_guard_ = UV_ONCE_INIT;\n \n \n static void uv_init(void) {\n+  /* Tell Windows that we will handle critical errors. */\n+  SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX |\n+    SEM_NOOPENFILEERRORBOX);\n+\n   /* Initialize winsock */\n   uv_winsock_init();\n \n@@ -95,12 +99,23 @@ static void uv_default_loop_init(void) {\n }\n \n \n-uv_loop_t* uv_default_loop() {\n+uv_loop_t* uv_default_loop(void) {\n   uv_once(&uv_default_loop_init_guard_, uv_default_loop_init);\n   return &uv_default_loop_;\n }\n \n \n+uv_loop_t* uv_loop_new(void) {\n+  assert(0 && \"implement me\");\n+  return NULL;\n+}\n+\n+\n+void uv_loop_delete(uv_loop_t* loop) {\n+  assert(0 && \"implement me\");\n+}\n+\n+\n void uv_ref(uv_loop_t* loop) {\n   loop->refs++;\n }\n@@ -147,7 +162,7 @@ static void uv_poll_ex(uv_loop_t* loop, int block) {\n   BOOL success;\n   DWORD timeout;\n   uv_req_t* req;\n-  OVERLAPPED_ENTRY overlappeds[64];\n+  OVERLAPPED_ENTRY overlappeds[128];\n   ULONG count;\n   ULONG i;\n "}, {"sha": "37cdc131a1a9269689b981d6a17d305bdaca86d4", "filename": "src/rt/libuv/src/win/dl.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"internal.h\"\n+\n+\n+uv_err_t uv_dlopen(const char* filename, uv_lib_t* library) {\n+  wchar_t filename_w[32768];\n+  HMODULE handle;\n+\n+  if (!uv_utf8_to_utf16(filename,\n+                        filename_w,\n+                        sizeof(filename_w) / sizeof(wchar_t))) {\n+    return uv__new_sys_error(GetLastError());\n+  }\n+\n+  handle = LoadLibraryW(filename_w);\n+  if (handle == NULL) {\n+    return uv__new_sys_error(GetLastError());\n+  }\n+\n+  *library = handle;\n+  return uv_ok_;\n+}\n+\n+\n+uv_err_t uv_dlclose(uv_lib_t library) {\n+  if (!FreeLibrary(library)) {\n+    return uv__new_sys_error(GetLastError());\n+  }\n+\n+  return uv_ok_;\n+}\n+\n+\n+uv_err_t uv_dlsym(uv_lib_t library, const char* name, void** ptr) {\n+  FARPROC proc = GetProcAddress(library, name);\n+  if (proc == NULL) {\n+    return uv__new_sys_error(GetLastError());\n+  }\n+\n+  *ptr = (void*) proc;\n+  return uv_ok_;\n+}"}, {"sha": "1317ce5b6cc7ca2eefff2efad51869bdccacbf9e", "filename": "src/rt/libuv/src/win/error.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -30,9 +30,6 @@\n #include \"internal.h\"\n \n \n-const uv_err_t uv_ok_ = { UV_OK, ERROR_SUCCESS };\n-\n-\n /*\n  * Display an error message and abort the event loop.\n  */\n@@ -70,7 +67,7 @@ void uv_fatal_error(const int errorno, const char* syscall) {\n /* TODO: thread safety */\n static char* last_err_str_ = NULL;\n \n-char* uv_strerror(uv_err_t err) {\n+const char* uv_strerror(uv_err_t err) {\n   if (last_err_str_ != NULL) {\n     LocalFree(last_err_str_);\n   }\n@@ -93,8 +90,8 @@ uv_err_code uv_translate_sys_error(int sys_errno) {\n     case ERROR_SUCCESS:                     return UV_OK;\n     case ERROR_FILE_NOT_FOUND:              return UV_ENOENT;\n     case ERROR_PATH_NOT_FOUND:              return UV_ENOENT;\n-    case ERROR_NOACCESS:                    return UV_EACCESS;\n-    case WSAEACCES:                         return UV_EACCESS;\n+    case ERROR_NOACCESS:                    return UV_EACCES;\n+    case WSAEACCES:                         return UV_EACCES;\n     case ERROR_ADDRESS_ALREADY_ASSOCIATED:  return UV_EADDRINUSE;\n     case WSAEADDRINUSE:                     return UV_EADDRINUSE;\n     case WSAEADDRNOTAVAIL:                  return UV_EADDRNOTAVAIL;"}, {"sha": "b2f6583a408bc1186a0628efcdff6ee354debfd5", "filename": "src/rt/libuv/src/win/fs-event.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -133,12 +133,15 @@ static int uv_split_path(const wchar_t* filename, wchar_t** dir,\n \n \n int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n-    const char* filename, uv_fs_event_cb cb) {\n+    const char* filename, uv_fs_event_cb cb, int flags) {\n   int name_size;\n   DWORD attr, last_error;\n   wchar_t* dir = NULL, *dir_to_watch, *filenamew;\n   wchar_t short_path[MAX_PATH];\n \n+  /* We don't support any flags yet. */\n+  assert(!flags);\n+\n   uv_fs_event_init_handle(loop, handle, filename, cb);\n \n   /* Convert name to UTF16. */\n@@ -353,7 +356,9 @@ void uv_process_fs_event_req(uv_loop_t* loop, uv_req_t* req,\n         offset = file_info->NextEntryOffset;\n       } while(offset);\n     } else {\n-      handle->cb(handle, NULL, UV_CHANGE, 0);\n+      if (!(handle->flags & UV_HANDLE_CLOSING)) {\n+        handle->cb(handle, NULL, UV_CHANGE, 0);\n+      }\n     }\n   } else {\n     uv__set_sys_error(loop, GET_REQ_ERROR(req));"}, {"sha": "09ff145ce27a913c838680a2702f37a4e6aec08c", "filename": "src/rt/libuv/src/win/fs.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -173,19 +173,24 @@ void fs__open(uv_fs_t* req, const wchar_t* path, int flags, int mode) {\n   /* convert flags and mode to CreateFile parameters */\n   switch (flags & (_O_RDONLY | _O_WRONLY | _O_RDWR)) {\n   case _O_RDONLY:\n-    access = GENERIC_READ;\n+    access = FILE_GENERIC_READ;\n     break;\n   case _O_WRONLY:\n-    access = GENERIC_WRITE;\n+    access = FILE_GENERIC_WRITE;\n     break;\n   case _O_RDWR:\n-    access = GENERIC_READ | GENERIC_WRITE;\n+    access = FILE_GENERIC_READ | FILE_GENERIC_WRITE;\n     break;\n   default:\n     result  = -1;\n     goto end;\n   }\n \n+  if (flags & _O_APPEND) {\n+    access &= ~FILE_WRITE_DATA;\n+    access |= FILE_APPEND_DATA;\n+  }\n+\n   /*\n    * Here is where we deviate significantly from what CRT's _open()\n    * does. We indiscriminately use all the sharing modes, to match"}, {"sha": "deb8972c5a870ca099b36ab8f5f6e1ed3f0f36df", "filename": "src/rt/libuv/src/win/internal.h", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -44,30 +44,35 @@ void uv_process_timers(uv_loop_t* loop);\n  */\n \n /* Private uv_handle flags */\n-#define UV_HANDLE_CLOSING                 0x000001\n-#define UV_HANDLE_CLOSED                  0x000002\n-#define UV_HANDLE_BOUND                   0x000004\n-#define UV_HANDLE_LISTENING               0x000008\n-#define UV_HANDLE_CONNECTION              0x000010\n-#define UV_HANDLE_CONNECTED               0x000020\n-#define UV_HANDLE_READING                 0x000040\n-#define UV_HANDLE_ACTIVE                  0x000040\n-#define UV_HANDLE_EOF                     0x000080\n-#define UV_HANDLE_SHUTTING                0x000100\n-#define UV_HANDLE_SHUT                    0x000200\n-#define UV_HANDLE_ENDGAME_QUEUED          0x000400\n-#define UV_HANDLE_BIND_ERROR              0x001000\n-#define UV_HANDLE_IPV6                    0x002000\n-#define UV_HANDLE_PIPESERVER              0x004000\n-#define UV_HANDLE_READ_PENDING            0x008000\n-#define UV_HANDLE_UV_ALLOCED              0x010000\n-#define UV_HANDLE_SYNC_BYPASS_IOCP        0x020000\n-#define UV_HANDLE_ZERO_READ               0x040000\n-#define UV_HANDLE_TTY_RAW                 0x080000\n-#define UV_HANDLE_EMULATE_IOCP            0x100000\n-#define UV_HANDLE_NON_OVERLAPPED_PIPE     0x200000\n-#define UV_HANDLE_TTY_SAVED_POSITION      0x400000\n-#define UV_HANDLE_TTY_SAVED_ATTRIBUTES    0x800000\n+#define UV_HANDLE_CLOSING                       0x00000001\n+#define UV_HANDLE_CLOSED                        0x00000002\n+#define UV_HANDLE_BOUND                         0x00000004\n+#define UV_HANDLE_LISTENING                     0x00000008\n+#define UV_HANDLE_CONNECTION                    0x00000010\n+#define UV_HANDLE_CONNECTED                     0x00000020\n+#define UV_HANDLE_READING                       0x00000040\n+#define UV_HANDLE_ACTIVE                        0x00000040\n+#define UV_HANDLE_EOF                           0x00000080\n+#define UV_HANDLE_SHUTTING                      0x00000100\n+#define UV_HANDLE_SHUT                          0x00000200\n+#define UV_HANDLE_ENDGAME_QUEUED                0x00000400\n+#define UV_HANDLE_BIND_ERROR                    0x00001000\n+#define UV_HANDLE_IPV6                          0x00002000\n+#define UV_HANDLE_PIPESERVER                    0x00004000\n+#define UV_HANDLE_READ_PENDING                  0x00008000\n+#define UV_HANDLE_UV_ALLOCED                    0x00010000\n+#define UV_HANDLE_SYNC_BYPASS_IOCP              0x00020000\n+#define UV_HANDLE_ZERO_READ                     0x00040000\n+#define UV_HANDLE_TTY_RAW                       0x00080000\n+#define UV_HANDLE_EMULATE_IOCP                  0x00100000\n+#define UV_HANDLE_NON_OVERLAPPED_PIPE           0x00200000\n+#define UV_HANDLE_TTY_SAVED_POSITION            0x00400000\n+#define UV_HANDLE_TTY_SAVED_ATTRIBUTES          0x00800000\n+#define UV_HANDLE_SHARED_TCP_SERVER             0x01000000\n+#define UV_HANDLE_TCP_NODELAY                   0x02000000\n+#define UV_HANDLE_TCP_KEEPALIVE                 0x04000000\n+#define UV_HANDLE_TCP_SINGLE_ACCEPT             0x08000000\n+#define UV_HANDLE_TCP_ACCEPT_STATE_CHANGING     0x10000000\n \n void uv_want_endgame(uv_loop_t* loop, uv_handle_t* handle);\n void uv_process_endgames(uv_loop_t* loop);\n@@ -140,6 +145,9 @@ void uv_tcp_endgame(uv_loop_t* loop, uv_tcp_t* handle);\n \n int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info);\n \n+int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,\n+    LPWSAPROTOCOL_INFOW protocol_info);\n+\n \n /*\n  * UDP\n@@ -278,11 +286,6 @@ void uv_fs_event_endgame(uv_loop_t* loop, uv_fs_event_t* handle);\n int uv_parent_pid();\n \n \n-/*\n- * Error handling\n- */\n-extern const uv_err_t uv_ok_;\n-\n void uv_fatal_error(const int errorno, const char* syscall);\n \n uv_err_code uv_translate_sys_error(int sys_errno);"}, {"sha": "bd187da5f5d9e241ed0f9bef6fa2b3305658d462", "filename": "src/rt/libuv/src/win/pipe.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -362,7 +362,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n     if (errno == ERROR_ACCESS_DENIED) {\n       uv__set_error(loop, UV_EADDRINUSE, errno);\n     } else if (errno == ERROR_PATH_NOT_FOUND || errno == ERROR_INVALID_NAME) {\n-      uv__set_error(loop, UV_EACCESS, errno);\n+      uv__set_error(loop, UV_EACCES, errno);\n     } else {\n       uv__set_sys_error(loop, errno);\n     }\n@@ -443,7 +443,7 @@ static DWORD WINAPI pipe_connect_thread_proc(void* parameter) {\n }\n \n \n-int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n+void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n     const char* name, uv_connect_cb cb) {\n   uv_loop_t* loop = handle->loop;\n   int errno, nameSize;\n@@ -488,7 +488,7 @@ int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n \n       handle->reqs_pending++;\n \n-      return 0;\n+      return;\n     }\n \n     errno = GetLastError();\n@@ -505,7 +505,7 @@ int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n   SET_REQ_SUCCESS(req);\n   uv_insert_pending_req(loop, (uv_req_t*) req);\n   handle->reqs_pending++;\n-  return 0;\n+  return;\n \n error:\n   if (handle->name) {\n@@ -516,8 +516,12 @@ int uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n   if (pipeHandle != INVALID_HANDLE_VALUE) {\n     CloseHandle(pipeHandle);\n   }\n-  uv__set_sys_error(loop, errno);\n-  return -1;\n+\n+  /* Make this req pending reporting an error. */\n+  SET_REQ_ERROR(req, errno);\n+  uv_insert_pending_req(loop, (uv_req_t*) req);\n+  handle->reqs_pending++;\n+  return;\n }\n \n \n@@ -956,7 +960,9 @@ static int uv_pipe_write_impl(uv_loop_t* loop, uv_write_t* req,\n     return -1;\n   }\n \n-  if (send_handle && send_handle->type != UV_TCP) {\n+  /* Only TCP server handles are supported for sharing. */\n+  if (send_handle && (send_handle->type != UV_TCP ||\n+      send_handle->flags & UV_HANDLE_CONNECTION)) {\n     uv__set_artificial_error(loop, UV_ENOTSUP);\n     return -1;\n   }\n@@ -989,9 +995,9 @@ static int uv_pipe_write_impl(uv_loop_t* loop, uv_write_t* req,\n     /* Use the IPC framing protocol. */\n     if (send_handle) {\n       tcp_send_handle = (uv_tcp_t*)send_handle;\n-      if (WSADuplicateSocketW(tcp_send_handle->socket, handle->ipc_pid,\n+\n+      if (uv_tcp_duplicate_socket(tcp_send_handle, handle->ipc_pid,\n           &ipc_frame.socket_info)) {\n-        uv__set_sys_error(loop, WSAGetLastError());\n         return -1;\n       }\n       ipc_frame.header.flags |= UV_IPC_UV_STREAM;"}, {"sha": "fd8018febcb09d03d5734bbe0ce9bb1179fa6099", "filename": "src/rt/libuv/src/win/process.c", "status": "modified", "additions": 71, "deletions": 24, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -26,8 +26,11 @@\n #include <stdio.h>\n #include <assert.h>\n #include <stdlib.h>\n+#include <signal.h>\n #include <windows.h>\n \n+#define SIGKILL         9\n+\n typedef struct env_var {\n   const char* narrow;\n   const wchar_t* wide;\n@@ -265,6 +268,8 @@ static wchar_t* search_path(const wchar_t *file,\n   wchar_t* result = NULL;\n   wchar_t *file_name_start;\n   wchar_t *dot;\n+  const wchar_t *dir_start, *dir_end, *dir_path;\n+  int dir_len;\n   int name_has_ext;\n \n   int file_len = wcslen(file);\n@@ -302,8 +307,7 @@ static wchar_t* search_path(const wchar_t *file,\n         name_has_ext);\n \n   } else {\n-    const wchar_t *dir_start,\n-                *dir_end = path;\n+    dir_end = path;\n \n     /* The file is really only a name; look in cwd first, then scan path */\n     result = path_search_walk_ext(L\"\", 0,\n@@ -335,7 +339,20 @@ static wchar_t* search_path(const wchar_t *file,\n         continue;\n       }\n \n-      result = path_search_walk_ext(dir_start, dir_end - dir_start,\n+      dir_path = dir_start;\n+      dir_len = dir_end - dir_start;\n+\n+      /* Adjust if the path is quoted. */\n+      if (dir_path[0] == '\"' || dir_path[0] == '\\'') {\n+        ++dir_path;\n+        --dir_len;\n+      }\n+\n+      if (dir_path[dir_len - 1] == '\"' || dir_path[dir_len - 1] == '\\'') {\n+        --dir_len;\n+      }\n+\n+      result = path_search_walk_ext(dir_path, dir_len,\n                                     file, file_len,\n                                     cwd, cwd_len,\n                                     name_has_ext);\n@@ -1052,35 +1069,65 @@ int uv_spawn(uv_loop_t* loop, uv_process_t* process,\n }\n \n \n-int uv_process_kill(uv_process_t* process, int signum) {\n+static uv_err_t uv__kill(HANDLE process_handle, int signum) {\n   DWORD status;\n+  uv_err_t err;\n+\n+  if (signum == SIGTERM || signum == SIGKILL || signum == SIGINT) {\n+    /* Kill the process. On Windows, killed processes normally return 1. */\n+    if (TerminateProcess(process_handle, 1)) {\n+      err = uv_ok_;\n+    } else {\n+      err = uv__new_sys_error(GetLastError());\n+    }\n+  } else if (signum == 0) {\n+    /* Health check: is the process still alive? */\n+    if (GetExitCodeProcess(process_handle, &status) &&\n+        status == STILL_ACTIVE) {\n+      err =  uv_ok_;\n+    } else {\n+      err = uv__new_sys_error(GetLastError());\n+    }\n+  } else {\n+    err.code = UV_ENOSYS;\n+  }\n+\n+  return err;\n+}\n+\n+\n+int uv_process_kill(uv_process_t* process, int signum) {\n+  uv_err_t err;\n \n   if (process->process_handle == INVALID_HANDLE_VALUE) {\n     uv__set_artificial_error(process->loop, UV_EINVAL);\n     return -1;\n   }\n \n-  if (signum) {\n-    /* Kill the process. On Windows, killed processes normally return 1. */\n-    if (TerminateProcess(process->process_handle, 1)) {\n-        process->exit_signal = signum;\n-        return 0;\n-    }\n-    else {\n-      uv__set_sys_error(process->loop, GetLastError());\n-      return -1;\n-    }\n+  err = uv__kill(process->process_handle, signum);\n+\n+  if (err.code != UV_OK) {\n+    uv__set_error(process->loop, err.code, err.sys_errno_);\n+    return -1;\n   }\n-  else {\n-    /* Health check: is the process still alive? */\n-    if (GetExitCodeProcess(process->process_handle, &status) && status == STILL_ACTIVE) {\n-      return 0;\n-    }\n-    else {\n-      uv__set_artificial_error(process->loop, UV_EINVAL);\n-      return -1;\n-    }\n+\n+  process->exit_signal = signum;\n+\n+  return 0;\n+}\n+\n+\n+uv_err_t uv_kill(int pid, int signum) {\n+  uv_err_t err;\n+  HANDLE process_handle = OpenProcess(PROCESS_TERMINATE |\n+    PROCESS_QUERY_INFORMATION, FALSE, pid);\n+\n+  if (process_handle == INVALID_HANDLE_VALUE) {\n+    return uv__new_sys_error(GetLastError());\n   }\n \n-  assert(0 && \"unreachable\");\n+  err = uv__kill(process_handle, signum);\n+  CloseHandle(process_handle);\n+\n+  return err;\n }"}, {"sha": "f57c825d15ebb6836fa97e2700124cd2ae5d2c75", "filename": "src/rt/libuv/src/win/tcp.c", "status": "modified", "additions": 212, "deletions": 38, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -46,6 +46,42 @@ static char uv_zero_[] = \"\";\n static unsigned int active_tcp_streams = 0;\n \n \n+static int uv__tcp_nodelay(uv_tcp_t* handle, SOCKET socket, int enable) {\n+  if (setsockopt(socket,\n+                 IPPROTO_TCP,\n+                 TCP_NODELAY,\n+                 (const char*)&enable,\n+                 sizeof enable) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+\n+static int uv__tcp_keepalive(uv_tcp_t* handle, SOCKET socket, int enable, unsigned int delay) {\n+  if (setsockopt(socket,\n+                 SOL_SOCKET,\n+                 SO_KEEPALIVE,\n+                 (const char*)&enable,\n+                 sizeof enable) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+\n+  if (enable && setsockopt(socket,\n+                           IPPROTO_TCP,\n+                           TCP_KEEPALIVE,\n+                           (const char*)&delay,\n+                           sizeof delay) == -1) {\n+    uv__set_sys_error(handle->loop, errno);\n+    return -1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n static int uv_tcp_set_socket(uv_loop_t* loop, uv_tcp_t* handle,\n     SOCKET socket, int imported) {\n   DWORD yes = 1;\n@@ -89,6 +125,17 @@ static int uv_tcp_set_socket(uv_loop_t* loop, uv_tcp_t* handle,\n     }\n   }\n \n+  if ((handle->flags & UV_HANDLE_TCP_NODELAY) &&\n+      uv__tcp_nodelay(handle, socket, 1)) {\n+    return -1;\n+  }\n+\n+  /* TODO: Use stored delay. */\n+  if ((handle->flags & UV_HANDLE_TCP_KEEPALIVE) &&\n+      uv__tcp_keepalive(handle, socket, 1, 60)) {\n+    return -1;\n+  }\n+\n   handle->socket = socket;\n \n   return 0;\n@@ -105,6 +152,7 @@ int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n   handle->reqs_pending = 0;\n   handle->func_acceptex = NULL;\n   handle->func_connectex = NULL;\n+  handle->processed_accepts = 0;\n \n   loop->counters.tcp_init++;\n \n@@ -392,7 +440,7 @@ static void uv_tcp_queue_read(uv_loop_t* loop, uv_tcp_t* handle) {\n \n int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n   uv_loop_t* loop = handle->loop;\n-  unsigned int i;\n+  unsigned int i, simultaneous_accepts;\n   uv_tcp_accept_t* req;\n \n   assert(backlog > 0);\n@@ -402,13 +450,6 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n     return -1;\n   }\n \n-  if (handle->flags & UV_HANDLE_LISTENING ||\n-      handle->flags & UV_HANDLE_READING) {\n-    /* Already listening. */\n-    uv__set_sys_error(loop, WSAEALREADY);\n-    return -1;\n-  }\n-\n   if (!(handle->flags & UV_HANDLE_BOUND) &&\n       uv_tcp_bind(handle, uv_addr_ip4_any_) < 0)\n     return -1;\n@@ -420,39 +461,44 @@ int uv_tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {\n     }\n   }\n \n-  if (listen(handle->socket, backlog) == SOCKET_ERROR) {\n+  if (!(handle->flags & UV_HANDLE_SHARED_TCP_SERVER) &&\n+      listen(handle->socket, backlog) == SOCKET_ERROR) {\n     uv__set_sys_error(loop, WSAGetLastError());\n     return -1;\n   }\n \n   handle->flags |= UV_HANDLE_LISTENING;\n   handle->connection_cb = cb;\n \n-  assert(!handle->accept_reqs);\n-  handle->accept_reqs = (uv_tcp_accept_t*)\n-    malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));\n-  if (!handle->accept_reqs) {\n-    uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n-  }\n+  simultaneous_accepts = handle->flags & UV_HANDLE_TCP_SINGLE_ACCEPT ? 1\n+    : uv_simultaneous_server_accepts;\n \n-  for (i = 0; i < uv_simultaneous_server_accepts; i++) {\n-    req = &handle->accept_reqs[i];\n-    uv_req_init(loop, (uv_req_t*)req);\n-    req->type = UV_ACCEPT;\n-    req->accept_socket = INVALID_SOCKET;\n-    req->data = handle;\n+  if(!handle->accept_reqs) {\n+    handle->accept_reqs = (uv_tcp_accept_t*)\n+      malloc(simultaneous_accepts * sizeof(uv_tcp_accept_t));\n+    if (!handle->accept_reqs) {\n+      uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");\n+    }\n \n-    req->wait_handle = INVALID_HANDLE_VALUE;\n-    if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n-      req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n-      if (!req->event_handle) {\n-        uv_fatal_error(GetLastError(), \"CreateEvent\");\n+    for (i = 0; i < simultaneous_accepts; i++) {\n+      req = &handle->accept_reqs[i];\n+      uv_req_init(loop, (uv_req_t*)req);\n+      req->type = UV_ACCEPT;\n+      req->accept_socket = INVALID_SOCKET;\n+      req->data = handle;\n+\n+      req->wait_handle = INVALID_HANDLE_VALUE;\n+      if (handle->flags & UV_HANDLE_EMULATE_IOCP) {\n+        req->event_handle = CreateEvent(NULL, 0, 0, NULL);\n+        if (!req->event_handle) {\n+          uv_fatal_error(GetLastError(), \"CreateEvent\");\n+        }\n+      } else {\n+        req->event_handle = NULL;\n       }\n-    } else {\n-      req->event_handle = NULL;\n-    }\n \n-    uv_tcp_queue_accept(handle, req);\n+      uv_tcp_queue_accept(handle, req);\n+    }\n   }\n \n   return 0;\n@@ -491,7 +537,26 @@ int uv_tcp_accept(uv_tcp_t* server, uv_tcp_t* client) {\n   req->accept_socket = INVALID_SOCKET;\n \n   if (!(server->flags & UV_HANDLE_CLOSING)) {\n-    uv_tcp_queue_accept(server, req);\n+    /* Check if we're in a middle of changing the number of pending accepts. */\n+    if (!(server->flags & UV_HANDLE_TCP_ACCEPT_STATE_CHANGING)) {\n+      uv_tcp_queue_accept(server, req);\n+    } else {\n+      /* We better be switching to a single pending accept. */\n+      assert(server->flags & UV_HANDLE_TCP_SINGLE_ACCEPT);\n+\n+      server->processed_accepts++;\n+\n+      if (server->processed_accepts >= uv_simultaneous_server_accepts) {\n+        server->processed_accepts = 0;\n+        /* \n+         * All previously queued accept requests are now processed.\n+         * We now switch to queueing just a single accept.\n+         */\n+        uv_tcp_queue_accept(server, &server->accept_reqs[0]);\n+        server->flags &= ~UV_HANDLE_TCP_ACCEPT_STATE_CHANGING;\n+        server->flags |= UV_HANDLE_TCP_SINGLE_ACCEPT;\n+      }\n+    }\n   }\n \n   active_tcp_streams++;\n@@ -759,9 +824,19 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n     /* An error occurred doing the read. */\n     if ((handle->flags & UV_HANDLE_READING)) {\n       handle->flags &= ~UV_HANDLE_READING;\n-      uv__set_sys_error(loop, GET_REQ_SOCK_ERROR(req));\n       buf = (handle->flags & UV_HANDLE_ZERO_READ) ?\n             uv_buf_init(NULL, 0) : handle->read_buffer;\n+\n+      err = GET_REQ_SOCK_ERROR(req);\n+\n+      if (err == WSAECONNABORTED) {\n+        /* Treat WSAECONNABORTED as connection closed. */\n+        handle->flags |= UV_HANDLE_EOF;\n+        uv__set_error(loop, UV_EOF, ERROR_SUCCESS);\n+      } else {\n+        uv__set_sys_error(loop, err);\n+      }\n+\n       handle->read_cb((uv_stream_t*)handle, -1, buf);\n     }\n   } else {\n@@ -822,8 +897,14 @@ void uv_process_tcp_read_req(uv_loop_t* loop, uv_tcp_t* handle,\n           uv__set_sys_error(loop, WSAEWOULDBLOCK);\n           handle->read_cb((uv_stream_t*)handle, 0, buf);\n         } else {\n-          /* Ouch! serious error. */\n-          uv__set_sys_error(loop, err);\n+          if (err == WSAECONNABORTED) {\n+            /* Treat WSAECONNABORTED as connection closed. */\n+            handle->flags |= UV_HANDLE_EOF;\n+            uv__set_error(loop, UV_EOF, ERROR_SUCCESS);\n+          } else {\n+            /* Ouch! serious error. */\n+            uv__set_sys_error(loop, err);\n+          }\n           handle->flags &= ~UV_HANDLE_READING;\n           handle->read_cb((uv_stream_t*)handle, -1, buf);\n         }\n@@ -953,18 +1034,111 @@ int uv_tcp_import(uv_tcp_t* tcp, WSAPROTOCOL_INFOW* socket_protocol_info) {\n   }\n \n   tcp->flags |= UV_HANDLE_BOUND;\n+  tcp->flags |= UV_HANDLE_SHARED_TCP_SERVER;\n \n   return uv_tcp_set_socket(tcp->loop, tcp, socket, 1);\n }\n \n \n int uv_tcp_nodelay(uv_tcp_t* handle, int enable) {\n-  uv__set_artificial_error(handle->loop, UV_ENOSYS);\n-  return -1;\n+  if (handle->socket != INVALID_SOCKET &&\n+      uv__tcp_nodelay(handle, handle->socket, enable)) {\n+    return -1;\n+  }\n+\n+  if (enable) {\n+    handle->flags |= UV_HANDLE_TCP_NODELAY;\n+  } else {\n+    handle->flags &= ~UV_HANDLE_TCP_NODELAY;\n+  }\n+\n+  return 0;\n }\n \n \n int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {\n-  uv__set_artificial_error(handle->loop, UV_ENOSYS);\n-  return -1;\n+  if (handle->socket != INVALID_SOCKET &&\n+      uv__tcp_keepalive(handle, handle->socket, enable, delay)) {\n+    return -1;\n+  }\n+\n+  if (enable) {\n+    handle->flags |= UV_HANDLE_TCP_KEEPALIVE;\n+  } else {\n+    handle->flags &= ~UV_HANDLE_TCP_KEEPALIVE;\n+  }\n+\n+  /* TODO: Store delay if handle->socket isn't created yet. */\n+\n+  return 0;\n+}\n+\n+\n+\n+int uv_tcp_duplicate_socket(uv_tcp_t* handle, int pid,\n+    LPWSAPROTOCOL_INFOW protocol_info) {\n+  assert(!(handle->flags & UV_HANDLE_CONNECTION));\n+\n+  /* \n+   * We're about to share the socket with another process.  Because\n+   * this is a listening socket, we assume that the other process will\n+   * be accepting conections on it.  So, before sharing the socket\n+   * with another process, we call listen here in the parent process.\n+   * This needs to be modified if the socket is shared with\n+   * another process for anything other than accepting connections.\n+   */\n+\n+  if (!(handle->flags & UV_HANDLE_LISTENING)) {\n+    if (!(handle->flags & UV_HANDLE_BOUND)) {\n+      uv__set_artificial_error(handle->loop, UV_EINVAL);\n+      return -1;\n+    }\n+    if (listen(handle->socket, SOMAXCONN) == SOCKET_ERROR) {\n+      uv__set_sys_error(handle->loop, WSAGetLastError());\n+      return -1;\n+    }\n+\n+    handle->flags |= UV_HANDLE_SHARED_TCP_SERVER;\n+  }\n+\n+  if (WSADuplicateSocketW(handle->socket, pid, protocol_info)) {\n+    uv__set_sys_error(handle->loop, WSAGetLastError());\n+    return -1;\n+  }\n+\n+  return 0;\n }\n+\n+\n+int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {\n+  if (handle->flags & UV_HANDLE_CONNECTION) {\n+    uv__set_artificial_error(handle->loop, UV_EINVAL);\n+    return -1;\n+  }\n+\n+  /* Check if we're already in the desired mode. */\n+  if ((enable && !(handle->flags & UV_HANDLE_TCP_SINGLE_ACCEPT)) ||\n+      (!enable && handle->flags & UV_HANDLE_TCP_SINGLE_ACCEPT)) {\n+    return 0;\n+  }\n+\n+  /* Don't allow switching from single pending accept to many. */\n+  if (enable) {\n+    uv__set_artificial_error(handle->loop, UV_ENOTSUP);\n+    return -1;\n+  }\n+\n+  /* Check if we're in a middle of changing the number of pending accepts. */\n+  if (handle->flags & UV_HANDLE_TCP_ACCEPT_STATE_CHANGING) {\n+    return 0;\n+  }\n+\n+  handle->flags |= UV_HANDLE_TCP_SINGLE_ACCEPT;\n+\n+  /* Flip the changing flag if we have already queueed multiple accepts. */\n+  if (handle->flags & UV_HANDLE_LISTENING) {\n+    handle->flags |= UV_HANDLE_TCP_ACCEPT_STATE_CHANGING;\n+  }\n+\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "433ce47670127358bbf5fbfe23e364613ebb5925", "filename": "src/rt/libuv/src/win/winsock.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -37,6 +37,10 @@\n # define SO_UPDATE_CONNECT_CONTEXT 0x7010\n #endif\n \n+#ifndef TCP_KEEPALIVE\n+# define TCP_KEEPALIVE 3\n+#endif\n+\n #ifndef IPV6_V6ONLY\n   #define IPV6_V6ONLY 27\n #endif"}, {"sha": "92a536db77f5b9c10923442006dd54aaec705e85", "filename": "src/rt/libuv/test/benchmark-pound.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -225,12 +225,7 @@ static void pipe_make_connect(conn_rec* p) {\n   r = uv_pipe_init(loop, (uv_pipe_t*)&p->stream, 0);\n   ASSERT(r == 0);\n \n-  r = uv_pipe_connect(&((pipe_conn_rec*)p)->conn_req, (uv_pipe_t*)&p->stream, TEST_PIPENAME, connect_cb);\n-  if (r) {\n-    fprintf(stderr, \"uv_tcp_connect error %s\\n\",\n-        uv_err_name(uv_last_error(loop)));\n-    ASSERT(0);\n-  }\n+  uv_pipe_connect(&((pipe_conn_rec*)p)->conn_req, (uv_pipe_t*)&p->stream, TEST_PIPENAME, connect_cb);\n \n #if DEBUG\n   printf(\"make connect %d\\n\", p->i);"}, {"sha": "52f295727c446dc0dbc414d9e273bcc99fd5e22a", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -257,8 +257,7 @@ static void maybe_connect_some() {\n       ASSERT(r == 0);\n \n       req = (uv_connect_t*) req_alloc();\n-      r = uv_pipe_connect(req, pipe, TEST_PIPENAME, connect_cb);\n-      ASSERT(r == 0);\n+      uv_pipe_connect(req, pipe, TEST_PIPENAME, connect_cb);\n     }\n   }\n }"}, {"sha": "1d8b0bcf5062ebc7555029bf425529b7c81269bb", "filename": "src/rt/libuv/test/run-tests.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -112,7 +112,7 @@ static void ipc_on_connection(uv_stream_t* server, int status) {\n }\n \n \n-static int ipc_helper() {\n+static int ipc_helper(int listen_after_write) {\n   /*\n    * This is launched from test-ipc.c. stdin is a duplex channel that we\n    * over which a handle will be transmitted. In this initial version only\n@@ -135,14 +135,21 @@ static int ipc_helper() {\n   r = uv_tcp_bind(&tcp_server, uv_ip4_addr(\"0.0.0.0\", TEST_PORT));\n   ASSERT(r == 0);\n \n-  r = uv_listen((uv_stream_t*)&tcp_server, 12, ipc_on_connection);\n-  ASSERT(r == 0);\n+  if (!listen_after_write) {\n+    r = uv_listen((uv_stream_t*)&tcp_server, 12, ipc_on_connection);\n+    ASSERT(r == 0);\n+  }\n \n   buf = uv_buf_init(\"hello\\n\", 6);\n   r = uv_write2(&write_req, (uv_stream_t*)&channel, &buf, 1,\n       (uv_stream_t*)&tcp_server, NULL);\n   ASSERT(r == 0);\n \n+  if (listen_after_write) {\n+    r = uv_listen((uv_stream_t*)&tcp_server, 12, ipc_on_connection);\n+    ASSERT(r == 0);\n+  }\n+\n   r = uv_run(uv_default_loop());\n   ASSERT(r == 0);\n \n@@ -251,8 +258,12 @@ static int maybe_run_test(int argc, char **argv) {\n     return 0;\n   }\n \n-  if (strcmp(argv[1], \"ipc_helper\") == 0) {\n-    return ipc_helper();\n+  if (strcmp(argv[1], \"ipc_helper_listen_before_write\") == 0) {\n+    return ipc_helper(0);\n+  }\n+\n+  if (strcmp(argv[1], \"ipc_helper_listen_after_write\") == 0) {\n+    return ipc_helper(1);\n   }\n \n   if (strcmp(argv[1], \"stdio_over_pipes_helper\") == 0) {"}, {"sha": "c1f23fe996a959aca8cbd8bad26ea582a518865d", "filename": "src/rt/libuv/test/test-fs-event.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -144,7 +144,7 @@ TEST_IMPL(fs_event_watch_dir) {\n   uv_fs_rmdir(loop, &fs_req, \"watch_dir\", NULL);\n   create_dir(loop, \"watch_dir\");\n \n-  r = uv_fs_event_init(loop, &fs_event, \"watch_dir\", fs_event_cb_dir);\n+  r = uv_fs_event_init(loop, &fs_event, \"watch_dir\", fs_event_cb_dir, 0);\n   ASSERT(r != -1);\n   r = uv_timer_init(loop, &timer);\n   ASSERT(r != -1);\n@@ -178,7 +178,7 @@ TEST_IMPL(fs_event_watch_file) {\n   create_file(loop, \"watch_dir/file1\");\n   create_file(loop, \"watch_dir/file2\");\n \n-  r = uv_fs_event_init(loop, &fs_event, \"watch_dir/file2\", fs_event_cb_file);\n+  r = uv_fs_event_init(loop, &fs_event, \"watch_dir/file2\", fs_event_cb_file, 0);\n   ASSERT(r != -1);\n   r = uv_timer_init(loop, &timer);\n   ASSERT(r != -1);\n@@ -212,7 +212,7 @@ TEST_IMPL(fs_event_watch_file_current_dir) {\n   create_file(loop, \"watch_file\");\n \n   r = uv_fs_event_init(loop, &fs_event, \"watch_file\",\n-    fs_event_cb_file_current_dir);\n+    fs_event_cb_file_current_dir, 0);\n   ASSERT(r != -1);\n \n   r = uv_timer_init(loop, &timer);\n@@ -235,3 +235,36 @@ TEST_IMPL(fs_event_watch_file_current_dir) {\n   r = uv_fs_unlink(loop, &fs_req, \"watch_file\", NULL);\n   return 0;\n }\n+\n+\n+TEST_IMPL(fs_event_no_callback_on_close) {\n+  uv_fs_t fs_req;\n+  uv_loop_t* loop = uv_default_loop();\n+  int r;\n+\n+  /* Setup */\n+  uv_fs_unlink(loop, &fs_req, \"watch_dir/file1\", NULL);\n+  uv_fs_rmdir(loop, &fs_req, \"watch_dir\", NULL);\n+  create_dir(loop, \"watch_dir\");\n+  create_file(loop, \"watch_dir/file1\");\n+\n+  r = uv_fs_event_init(loop,\n+                       &fs_event,\n+                       \"watch_dir/file1\",\n+                       fs_event_cb_file,\n+                       0);\n+  ASSERT(r != -1);\n+\n+  uv_close((uv_handle_t*)&fs_event, close_cb);\n+\n+  uv_run(loop);\n+\n+  ASSERT(fs_event_cb_called == 0);\n+  ASSERT(close_cb_called == 1);\n+\n+  /* Cleanup */\n+  r = uv_fs_unlink(loop, &fs_req, \"watch_dir/file1\", NULL);\n+  r = uv_fs_rmdir(loop, &fs_req, \"watch_dir\", NULL);\n+\n+  return 0;\n+}\n\\ No newline at end of file"}, {"sha": "28b914a770ba9f4fccbad6c0b8b602c2998eb69f", "filename": "src/rt/libuv/test/test-fs.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -1408,3 +1408,71 @@ TEST_IMPL(fs_open_dir) {\n \n   return 0;\n }\n+\n+\n+TEST_IMPL(fs_file_open_append) {\n+  int r;\n+\n+  /* Setup. */\n+  unlink(\"test_file\");\n+\n+  loop = uv_default_loop();\n+\n+  r = uv_fs_open(loop, &open_req1, \"test_file\", O_WRONLY | O_CREAT,\n+      S_IWRITE | S_IREAD, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(open_req1.result != -1);\n+  uv_fs_req_cleanup(&open_req1);\n+\n+  r = uv_fs_write(loop, &write_req, open_req1.result, test_buf,\n+      sizeof(test_buf), -1, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(write_req.result != -1);\n+  uv_fs_req_cleanup(&write_req);\n+\n+  r = uv_fs_close(loop, &close_req, open_req1.result, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(close_req.result != -1);\n+  uv_fs_req_cleanup(&close_req);\n+\n+  r = uv_fs_open(loop, &open_req1, \"test_file\", O_RDWR | O_APPEND, 0, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(open_req1.result != -1);\n+  uv_fs_req_cleanup(&open_req1);\n+\n+  r = uv_fs_write(loop, &write_req, open_req1.result, test_buf,\n+      sizeof(test_buf), -1, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(write_req.result != -1);\n+  uv_fs_req_cleanup(&write_req);\n+\n+  r = uv_fs_close(loop, &close_req, open_req1.result, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(close_req.result != -1);\n+  uv_fs_req_cleanup(&close_req);\n+\n+  r = uv_fs_open(loop, &open_req1, \"test_file\", O_RDONLY, S_IREAD, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(open_req1.result != -1);\n+  uv_fs_req_cleanup(&open_req1);\n+\n+  r = uv_fs_read(loop, &read_req, open_req1.result, buf, sizeof(buf), -1,\n+      NULL);\n+  printf(\"read = %d\\n\", r);\n+  ASSERT(r == 26);\n+  ASSERT(read_req.result == 26);\n+  ASSERT(memcmp(buf,\n+                \"test-buffer\\n\\0test-buffer\\n\\0\",\n+                sizeof(\"test-buffer\\n\\0test-buffer\\n\\0\") - 1) == 0);\n+  uv_fs_req_cleanup(&read_req);\n+\n+  r = uv_fs_close(loop, &close_req, open_req1.result, NULL);\n+  ASSERT(r != -1);\n+  ASSERT(close_req.result != -1);\n+  uv_fs_req_cleanup(&close_req);\n+\n+  /* Cleanup */\n+  unlink(\"test_file\");\n+\n+  return 0;\n+}"}, {"sha": "0908879510fa6619262225b84896d7f1ab533fec", "filename": "src/rt/libuv/test/test-ipc.c", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -184,7 +184,7 @@ static void on_read(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,\n }\n \n \n-TEST_IMPL(ipc) {\n+int run_ipc_test(const char* helper) {\n   int r;\n   uv_process_options_t options;\n   uv_process_t process;\n@@ -199,7 +199,7 @@ TEST_IMPL(ipc) {\n   ASSERT(r == 0);\n   exepath[exepath_size] = '\\0';\n   args[0] = exepath;\n-  args[1] = \"ipc_helper\";\n+  args[1] = (char*)helper;\n   args[2] = NULL;\n   options.file = exepath;\n   options.args = args;\n@@ -220,3 +220,59 @@ TEST_IMPL(ipc) {\n   ASSERT(exit_cb_called == 1);\n   return 0;\n }\n+\n+\n+TEST_IMPL(ipc_listen_before_write) {\n+  return run_ipc_test(\"ipc_helper_listen_before_write\");\n+}\n+\n+\n+TEST_IMPL(ipc_listen_after_write) {\n+  return run_ipc_test(\"ipc_helper_listen_after_write\");\n+}\n+\n+\n+#ifdef _WIN32\n+TEST_IMPL(listen_with_simultaneous_accepts) {\n+  uv_tcp_t server;\n+  int r;\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+\n+  r = uv_tcp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&server, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_simultaneous_accepts(&server, 1);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&server, SOMAXCONN, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(server.reqs_pending == 32);\n+\n+  return 0;\n+}\n+\n+\n+TEST_IMPL(listen_no_simultaneous_accepts) {\n+  uv_tcp_t server;\n+  int r;\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+\n+  r = uv_tcp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&server, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_simultaneous_accepts(&server, 0);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&server, SOMAXCONN, NULL);\n+  ASSERT(r == 0);\n+  ASSERT(server.reqs_pending == 1);\n+\n+  return 0;\n+}\n+#endif"}, {"sha": "9051fdb35ce6cc0b7a2b34437b1bd0ed58a63401", "filename": "src/rt/libuv/test/test-list.h", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -21,13 +21,15 @@\n \n TEST_DECLARE   (tty)\n TEST_DECLARE   (stdio_over_pipes)\n-TEST_DECLARE   (ipc)\n+TEST_DECLARE   (ipc_listen_before_write)\n+TEST_DECLARE   (ipc_listen_after_write)\n TEST_DECLARE   (tcp_ping_pong)\n TEST_DECLARE   (tcp_ping_pong_v6)\n TEST_DECLARE   (tcp_ref)\n TEST_DECLARE   (tcp_ref2)\n TEST_DECLARE   (pipe_ping_pong)\n TEST_DECLARE   (delayed_accept)\n+TEST_DECLARE   (multiple_listen)\n TEST_DECLARE   (tcp_writealot)\n TEST_DECLARE   (tcp_bind_error_addrinuse)\n TEST_DECLARE   (tcp_bind_error_addrnotavail_1)\n@@ -39,6 +41,7 @@ TEST_DECLARE   (tcp_listen_without_bind)\n TEST_DECLARE   (tcp_close)\n TEST_DECLARE   (tcp_flags)\n TEST_DECLARE   (tcp_write_error)\n+TEST_DECLARE   (tcp_write_to_half_open_connection)\n TEST_DECLARE   (tcp_bind6_error_addrinuse)\n TEST_DECLARE   (tcp_bind6_error_addrnotavail)\n TEST_DECLARE   (tcp_bind6_error_fault)\n@@ -53,6 +56,7 @@ TEST_DECLARE   (pipe_bind_error_addrinuse)\n TEST_DECLARE   (pipe_bind_error_addrnotavail)\n TEST_DECLARE   (pipe_bind_error_inval)\n TEST_DECLARE   (pipe_listen_without_bind)\n+TEST_DECLARE   (pipe_connect_bad_name)\n TEST_DECLARE   (connection_fail)\n TEST_DECLARE   (connection_fail_doesnt_auto_close)\n TEST_DECLARE   (shutdown_eof)\n@@ -87,6 +91,7 @@ TEST_DECLARE   (spawn_stdout)\n TEST_DECLARE   (spawn_stdin)\n TEST_DECLARE   (spawn_and_kill)\n TEST_DECLARE   (spawn_and_ping)\n+TEST_DECLARE   (kill)\n TEST_DECLARE   (fs_file_noent)\n TEST_DECLARE   (fs_file_async)\n TEST_DECLARE   (fs_file_sync)\n@@ -99,10 +104,12 @@ TEST_DECLARE   (fs_link)\n TEST_DECLARE   (fs_symlink)\n TEST_DECLARE   (fs_utime)\n TEST_DECLARE   (fs_futime)\n+TEST_DECLARE   (fs_file_open_append)\n TEST_DECLARE   (fs_stat_missing_path)\n TEST_DECLARE   (fs_event_watch_dir)\n TEST_DECLARE   (fs_event_watch_file)\n TEST_DECLARE   (fs_event_watch_file_current_dir)\n+TEST_DECLARE   (fs_event_no_callback_on_close)\n TEST_DECLARE   (fs_readdir_empty_dir)\n TEST_DECLARE   (fs_readdir_file)\n TEST_DECLARE   (fs_open_dir)\n@@ -111,17 +118,21 @@ TEST_DECLARE   (threadpool_queue_work_simple)\n TEST_DECLARE   (spawn_detect_pipe_name_collisions_on_windows)\n TEST_DECLARE   (argument_escaping)\n TEST_DECLARE   (environment_creation)\n+TEST_DECLARE   (listen_with_simultaneous_accepts)\n+TEST_DECLARE   (listen_no_simultaneous_accepts)\n #endif\n HELPER_DECLARE (tcp4_echo_server)\n HELPER_DECLARE (tcp6_echo_server)\n HELPER_DECLARE (pipe_echo_server)\n \n \n TASK_LIST_START\n+  TEST_ENTRY  (pipe_connect_bad_name)\n+\n   TEST_ENTRY  (tty)\n   TEST_ENTRY  (stdio_over_pipes)\n-  TEST_ENTRY  (ipc)\n-\n+  TEST_ENTRY  (ipc_listen_before_write)\n+  TEST_ENTRY  (ipc_listen_after_write)\n \n   TEST_ENTRY  (tcp_ref)\n \n@@ -138,6 +149,7 @@ TASK_LIST_START\n   TEST_HELPER (pipe_ping_pong, pipe_echo_server)\n \n   TEST_ENTRY  (delayed_accept)\n+  TEST_ENTRY  (multiple_listen)\n \n   TEST_ENTRY  (tcp_writealot)\n   TEST_HELPER (tcp_writealot, tcp4_echo_server)\n@@ -152,6 +164,7 @@ TASK_LIST_START\n   TEST_ENTRY  (tcp_close)\n   TEST_ENTRY  (tcp_flags)\n   TEST_ENTRY  (tcp_write_error)\n+  TEST_ENTRY  (tcp_write_to_half_open_connection)\n \n   TEST_ENTRY  (tcp_bind6_error_addrinuse)\n   TEST_ENTRY  (tcp_bind6_error_addrnotavail)\n@@ -222,10 +235,13 @@ TASK_LIST_START\n   TEST_ENTRY  (spawn_stdin)\n   TEST_ENTRY  (spawn_and_kill)\n   TEST_ENTRY  (spawn_and_ping)\n+  TEST_ENTRY  (kill)\n #ifdef _WIN32\n   TEST_ENTRY  (spawn_detect_pipe_name_collisions_on_windows)\n   TEST_ENTRY  (argument_escaping)\n   TEST_ENTRY  (environment_creation)\n+  TEST_ENTRY  (listen_with_simultaneous_accepts)\n+  TEST_ENTRY  (listen_no_simultaneous_accepts)\n #endif\n \n   TEST_ENTRY  (fs_file_noent)\n@@ -240,9 +256,11 @@ TASK_LIST_START\n   TEST_ENTRY  (fs_futime)\n   TEST_ENTRY  (fs_symlink)\n   TEST_ENTRY  (fs_stat_missing_path)\n+  TEST_ENTRY  (fs_file_open_append)\n   TEST_ENTRY  (fs_event_watch_dir)\n   TEST_ENTRY  (fs_event_watch_file)\n   TEST_ENTRY  (fs_event_watch_file_current_dir)\n+  TEST_ENTRY  (fs_event_no_callback_on_close)\n   TEST_ENTRY  (fs_readdir_empty_dir)\n   TEST_ENTRY  (fs_readdir_file)\n   TEST_ENTRY  (fs_open_dir)"}, {"sha": "0b5c887d69c5c67fb9a9784edc5ef871ed4abe92", "filename": "src/rt/libuv/test/test-multiple-listen.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,102 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static int connection_cb_called = 0;\n+static int close_cb_called = 0;\n+static int connect_cb_called = 0;\n+static uv_tcp_t server;\n+static uv_tcp_t client;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+static void connection_cb(uv_stream_t* tcp, int status) {\n+  ASSERT(status == 0);\n+  uv_close((uv_handle_t*)&server, close_cb);\n+  connection_cb_called++;\n+}\n+\n+\n+static void start_server() {\n+  struct sockaddr_in addr = uv_ip4_addr(\"0.0.0.0\", TEST_PORT);\n+  int r;\n+\n+  r = uv_tcp_init(uv_default_loop(), &server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&server, addr);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&server, 128, connection_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&server, 128, connection_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static void connect_cb(uv_connect_t* req, int status) {\n+  ASSERT(req != NULL);\n+  ASSERT(status == 0);\n+  free(req);\n+  uv_close((uv_handle_t*)&client, close_cb);\n+  connect_cb_called++;\n+}\n+\n+\n+static void client_connect() {\n+  struct sockaddr_in addr = uv_ip4_addr(\"127.0.0.1\", TEST_PORT);\n+  uv_connect_t* connect_req = malloc(sizeof *connect_req);\n+  int r;\n+\n+  ASSERT(connect_req != NULL);\n+\n+  r = uv_tcp_init(uv_default_loop(), &client);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_connect(connect_req, &client, addr, connect_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+\n+TEST_IMPL(multiple_listen) {\n+  start_server();\n+\n+  client_connect();\n+\n+  uv_run(uv_default_loop());\n+\n+  ASSERT(connection_cb_called == 1);\n+  ASSERT(connect_cb_called == 1);\n+  ASSERT(close_cb_called == 2);\n+\n+  return 0;\n+}"}, {"sha": "b73b4ce4d8ede652edfc430e238bed81983fbbd0", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -211,9 +211,8 @@ static void pipe_pinger_new() {\n   /* We are never doing multiple reads/connects at a time anyway. */\n   /* so these handles can be pre-initialized. */\n \n-  r = uv_pipe_connect(&pinger->connect_req, &pinger->stream.pipe, TEST_PIPENAME,\n+  uv_pipe_connect(&pinger->connect_req, &pinger->stream.pipe, TEST_PIPENAME,\n       pinger_on_connect);\n-  ASSERT(!r);\n \n   /* Synchronous connect callbacks are not allowed. */\n   ASSERT(pinger_on_connect_count == 0);"}, {"sha": "b84d20f1eaf4be694bc8bca54b6ed2a27e31ae45", "filename": "src/rt/libuv/test/test-pipe-bind-error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -84,7 +84,7 @@ TEST_IMPL(pipe_bind_error_addrnotavail) {\n   r = uv_pipe_bind(&server, BAD_PIPENAME);\n \n   ASSERT(r == -1);\n-  ASSERT(uv_last_error(uv_default_loop()).code == UV_EACCESS);\n+  ASSERT(uv_last_error(uv_default_loop()).code == UV_EACCES);\n \n   uv_close((uv_handle_t*)&server, close_cb);\n "}, {"sha": "2faa446148eff32380a1a1b7819f543a7420edbd", "filename": "src/rt/libuv/test/test-pipe-connect-error.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,68 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\n+#ifdef _WIN32\n+# define BAD_PIPENAME \"bad-pipe\"\n+#else\n+# define BAD_PIPENAME \"/path/to/unix/socket/that/really/should/not/be/there\"\n+#endif\n+\n+\n+static int close_cb_called = 0;\n+static int connect_cb_called = 0;\n+\n+\n+static void close_cb(uv_handle_t* handle) {\n+  ASSERT(handle != NULL);\n+  close_cb_called++;\n+}\n+\n+\n+static void connect_cb(uv_connect_t* connect_req, int status) {\n+  ASSERT(status == -1);\n+  ASSERT(uv_last_error(uv_default_loop()).code == UV_ENOENT);\n+  uv_close((uv_handle_t*)connect_req->handle, close_cb);\n+  connect_cb_called++;\n+}\n+\n+\n+TEST_IMPL(pipe_connect_bad_name) {\n+  uv_pipe_t client;\n+  uv_connect_t req;\n+  int r;\n+\n+  r = uv_pipe_init(uv_default_loop(), &client, 0);\n+  ASSERT(r == 0);\n+  uv_pipe_connect(&req, &client, BAD_PIPENAME, connect_cb);\n+\n+  uv_run(uv_default_loop());\n+\n+  ASSERT(close_cb_called == 1);\n+  ASSERT(connect_cb_called == 1);\n+\n+  return 0;\n+}"}, {"sha": "192644bad2618d6b798995dc34c0c396b3e240e3", "filename": "src/rt/libuv/test/test-spawn.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -33,6 +33,7 @@ static uv_process_options_t options;\n static char exepath[1024];\n static size_t exepath_size = 1024;\n static char* args[3];\n+static int no_term_signal;\n \n #define OUTPUT_SIZE 1024\n static char output[OUTPUT_SIZE];\n@@ -55,15 +56,23 @@ static void exit_cb(uv_process_t* process, int exit_status, int term_signal) {\n \n \n static void kill_cb(uv_process_t* process, int exit_status, int term_signal) {\n+  uv_err_t err;\n+\n   printf(\"exit_cb\\n\");\n   exit_cb_called++;\n #ifdef _WIN32\n   ASSERT(exit_status == 1);\n #else\n   ASSERT(exit_status == 0);\n #endif\n-  ASSERT(term_signal == 15);\n+  ASSERT(no_term_signal || term_signal == 15);\n   uv_close((uv_handle_t*)process, close_cb);\n+\n+  /* Sending signum == 0 should check if the\n+   * child process is still alive, not kill it.\n+   */\n+  err = uv_kill(process->pid, 0);\n+  ASSERT(err.code != UV_OK);\n }\n \n \n@@ -261,6 +270,39 @@ TEST_IMPL(spawn_and_ping) {\n }\n \n \n+TEST_IMPL(kill) {\n+  int r;\n+  uv_err_t err;\n+\n+#ifdef _WIN32\n+  no_term_signal = 1;\n+#endif\n+\n+  init_process_options(\"spawn_helper4\", kill_cb);\n+\n+  r = uv_spawn(uv_default_loop(), &process, options);\n+  ASSERT(r == 0);\n+\n+  /* Sending signum == 0 should check if the\n+   * child process is still alive, not kill it.\n+   */\n+  err = uv_kill(process.pid, 0);\n+  ASSERT(err.code == UV_OK);\n+\n+  /* Kill the process. */\n+  err = uv_kill(process.pid, /* SIGTERM */ 15);\n+  ASSERT(err.code == UV_OK);\n+\n+  r = uv_run(uv_default_loop());\n+  ASSERT(r == 0);\n+\n+  ASSERT(exit_cb_called == 1);\n+  ASSERT(close_cb_called == 1);\n+\n+  return 0;\n+}\n+\n+\n #ifdef _WIN32\n TEST_IMPL(spawn_detect_pipe_name_collisions_on_windows) {\n   int r;"}, {"sha": "7c0a692bf9273b754b77101242f711cd75e0c2bc", "filename": "src/rt/libuv/test/test-stdio-over-pipes.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -22,6 +22,9 @@\n #include \"uv.h\"\n #include \"task.h\"\n \n+#include <stdlib.h>\n+#include <string.h>\n+\n \n static char exepath[1024];\n static size_t exepath_size = 1024;"}, {"sha": "9e7f553ad24ad7316ba37271db834786628ae920", "filename": "src/rt/libuv/test/test-tcp-write-to-half-open-connection.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -0,0 +1,139 @@\n+/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to\n+ * deal in the Software without restriction, including without limitation the\n+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n+ * sell copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n+ * IN THE SOFTWARE.\n+ */\n+\n+#include \"uv.h\"\n+#include \"task.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static void connection_cb(uv_stream_t* server, int status);\n+static void connect_cb(uv_connect_t* req, int status);\n+static void write_cb(uv_write_t* req, int status);\n+static void read_cb(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n+static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size);\n+\n+static uv_tcp_t tcp_server;\n+static uv_tcp_t tcp_client;\n+static uv_tcp_t tcp_peer; /* client socket as accept()-ed by server */\n+static uv_connect_t connect_req;\n+static uv_write_t write_req;\n+\n+static int write_cb_called;\n+static int read_cb_called;\n+static int read_eof_cb_called;\n+\n+\n+static void connection_cb(uv_stream_t* server, int status) {\n+  int r;\n+  uv_buf_t buf;\n+\n+  ASSERT(server == (uv_stream_t*)&tcp_server);\n+  ASSERT(status == 0);\n+\n+  r = uv_tcp_init(server->loop, &tcp_peer);\n+  ASSERT(r == 0);\n+\n+  r = uv_accept(server, (uv_stream_t*)&tcp_peer);\n+  ASSERT(r == 0);\n+\n+  r = uv_read_start((uv_stream_t*)&tcp_peer, alloc_cb, read_cb);\n+  ASSERT(r == 0);\n+\n+  buf.base = \"hello\\n\";\n+  buf.len = 6;\n+\n+  r = uv_write(&write_req, (uv_stream_t*)&tcp_peer, &buf, 1, write_cb);\n+  ASSERT(r == 0);\n+}\n+\n+\n+static uv_buf_t alloc_cb(uv_handle_t* handle, size_t suggested_size) {\n+  static char slab[1024];\n+  return uv_buf_init(slab, sizeof slab);\n+}\n+\n+\n+static void read_cb(uv_stream_t* stream, ssize_t nread, uv_buf_t buf) {\n+  if (nread == -1) {\n+    fprintf(stderr, \"read_cb error: %s\\n\", uv_err_name(uv_last_error(stream->loop)));\n+    ASSERT(uv_last_error(stream->loop).code == UV_EOF);\n+\n+    uv_close((uv_handle_t*)&tcp_server, NULL);\n+    uv_close((uv_handle_t*)&tcp_peer, NULL);\n+\n+    read_eof_cb_called++;\n+  }\n+\n+  read_cb_called++;\n+}\n+\n+\n+static void connect_cb(uv_connect_t* req, int status) {\n+  ASSERT(req == &connect_req);\n+  ASSERT(status == 0);\n+\n+  /* Close the client. */\n+  uv_close((uv_handle_t*)&tcp_client, NULL);\n+}\n+\n+\n+static void write_cb(uv_write_t* req, int status) {\n+  ASSERT(status == 0);\n+  write_cb_called++;\n+}\n+\n+\n+TEST_IMPL(tcp_write_to_half_open_connection) {\n+  uv_loop_t* loop;\n+  int r;\n+\n+  loop = uv_default_loop();\n+  ASSERT(loop != NULL);\n+\n+  r = uv_tcp_init(loop, &tcp_server);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_bind(&tcp_server, uv_ip4_addr(\"127.0.0.1\", TEST_PORT));\n+  ASSERT(r == 0);\n+\n+  r = uv_listen((uv_stream_t*)&tcp_server, 1, connection_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_init(loop, &tcp_client);\n+  ASSERT(r == 0);\n+\n+  r = uv_tcp_connect(&connect_req,\n+                     &tcp_client,\n+                     uv_ip4_addr(\"127.0.0.1\", TEST_PORT),\n+                     connect_cb);\n+  ASSERT(r == 0);\n+\n+  r = uv_run(loop);\n+  ASSERT(r == 0);\n+\n+  ASSERT(write_cb_called > 0);\n+  ASSERT(read_cb_called > 0);\n+  ASSERT(read_eof_cb_called > 0);\n+\n+  return 0;\n+}"}, {"sha": "83129b5c956b21014e1663cafd2764ae6a0368ab", "filename": "src/rt/libuv/uv.gyp", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fuv.gyp", "raw_url": "https://github.com/rust-lang/rust/raw/fdeb5ba3043bbd173bd5b7308e98dde723f66d5c/src%2Frt%2Flibuv%2Fuv.gyp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv.gyp?ref=fdeb5ba3043bbd173bd5b7308e98dde723f66d5c", "patch": "@@ -8,6 +8,15 @@\n           '_GNU_SOURCE',\n           'EIO_STACKSIZE=262144'\n         ],\n+        'conditions': [\n+          ['OS==\"solaris\"', {\n+            'cflags': ['-pthreads'],\n+            'ldlags': ['-pthreads'],\n+          }, {\n+            'cflags': ['-pthread'],\n+            'ldlags': ['-pthread'],\n+          }],\n+        ],\n       }],\n     ],\n   },\n@@ -29,6 +38,7 @@\n         'HAVE_CONFIG_H'\n       ],\n       'sources': [\n+        'common.gypi',\n         'include/ares.h',\n         'include/ares_version.h',\n         'include/uv.h',\n@@ -120,6 +130,7 @@\n             'src/win/async.c',\n             'src/win/cares.c',\n             'src/win/core.c',\n+            'src/win/dl.c',\n             'src/win/error.c',\n             'src/win/fs.c',\n             'src/win/fs-event.c',\n@@ -172,6 +183,7 @@\n             'src/unix/tty.c',\n             'src/unix/stream.c',\n             'src/unix/cares.c',\n+            'src/unix/dl.c',\n             'src/unix/error.c',\n             'src/unix/process.c',\n             'src/unix/internal.h',\n@@ -280,9 +292,11 @@\n         'test/test-ipc.c',\n         'test/test-list.h',\n         'test/test-loop-handles.c',\n+        'test/test-multiple-listen.c',\n         'test/test-pass-always.c',\n         'test/test-ping-pong.c',\n         'test/test-pipe-bind-error.c',\n+        'test/test-pipe-connect-error.c',\n         'test/test-ref.c',\n         'test/test-shutdown-eof.c',\n         'test/test-spawn.c',\n@@ -294,6 +308,7 @@\n         'test/test-tcp-connect-error.c',\n         'test/test-tcp-connect6-error.c',\n         'test/test-tcp-write-error.c',\n+        'test/test-tcp-write-to-half-open-connection.c',\n         'test/test-tcp-writealot.c',\n         'test/test-threadpool.c',\n         'test/test-timer-again.c',\n@@ -313,11 +328,10 @@\n           'libraries': [ 'ws2_32.lib' ]\n         }, { # POSIX\n           'defines': [ '_GNU_SOURCE' ],\n-          'ldflags': [ '-pthread' ],\n           'sources': [\n             'test/runner-unix.c',\n             'test/runner-unix.h',\n-          ]\n+          ],\n         }],\n         [ 'OS==\"solaris\"', { # make test-fs.c compile, needs _POSIX_C_SOURCE\n           'defines': [\n@@ -365,7 +379,6 @@\n           'libraries': [ 'ws2_32.lib' ]\n         }, { # POSIX\n           'defines': [ '_GNU_SOURCE' ],\n-          'ldflags': [ '-pthread' ],\n           'sources': [\n             'test/runner-unix.c',\n             'test/runner-unix.h',"}]}