{"sha": "4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMTlkNTk1NGE0NjY1YTdhODU3MmY5NTkyZjg1NWY2OGNmMGYyYzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-30T16:05:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-30T16:05:07Z"}, "message": "Merge #5146\n\n5146: Simplify most of the inlay hints tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "b505a45efca93c959720ae0aecca78eca0f2ad62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b505a45efca93c959720ae0aecca78eca0f2ad62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+2KzCRBK7hj4Ov3rIwAAdHIIAG0gwH7aGbqEDD42TLsB3ikR\nOXneNa5IouXZbmb+s1mMeW4mAR+zzxteM7jSlJOugRm+cBJ+ocDlWw26pgiFwyBs\nZNqefMAJY4sPDFNOvGcPEi7/PZsqjv17oKY3MS9od13AMcefbxFblypM1rdRRObD\ngQo9legYdcHR9xOcTDMzIlRv9tgjt129Gw+dfAGRrM/iA6quOLhc/gaz19rGapY+\n99QaeIdQjCevgDx3RkO5IXJjYWlcUywZY3cRObTJDXNXiXa0Io0M2WslOU7idgZ1\noU+MbwkyTUEklGmNWuQ1zF2fgn9G+CT8e12WZs5wtGUjPptcCvDhmi8INM+tYWA=\n=ZCQa\n-----END PGP SIGNATURE-----\n", "payload": "tree b505a45efca93c959720ae0aecca78eca0f2ad62\nparent 0954d31beeb924510769fe8e201386a7cc3621f8\nparent 442c13ba176a40491deb7f9d2a2e1e24eca29f63\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593533107 +0000\ncommitter GitHub <noreply@github.com> 1593533107 +0000\n\nMerge #5146\n\n5146: Simplify most of the inlay hints tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "html_url": "https://github.com/rust-lang/rust/commit/4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a19d5954a4665a7a8572f9592f855f68cf0f2c6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0954d31beeb924510769fe8e201386a7cc3621f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0954d31beeb924510769fe8e201386a7cc3621f8", "html_url": "https://github.com/rust-lang/rust/commit/0954d31beeb924510769fe8e201386a7cc3621f8"}, {"sha": "442c13ba176a40491deb7f9d2a2e1e24eca29f63", "url": "https://api.github.com/repos/rust-lang/rust/commits/442c13ba176a40491deb7f9d2a2e1e24eca29f63", "html_url": "https://github.com/rust-lang/rust/commit/442c13ba176a40491deb7f9d2a2e1e24eca29f63"}], "stats": {"total": 830, "additions": 199, "deletions": 631}, "files": [{"sha": "64980a832fa288e6ff0da2d6f93dfec421d6129a", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 177, "deletions": 623, "changes": 800, "blob_url": "https://github.com/rust-lang/rust/blob/4a19d5954a4665a7a8572f9592f855f68cf0f2c6/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a19d5954a4665a7a8572f9592f855f68cf0f2c6/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "patch": "@@ -3,7 +3,7 @@ use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, ArgListOwner, AstNode, TypeAscriptionOwner},\n-    match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, TextRange,\n+    match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, TextRange, T,\n };\n \n use crate::{FileId, FunctionSignature};\n@@ -112,7 +112,7 @@ fn get_chaining_hints(\n     // Ignoring extra whitespace and comments\n     let next = tokens.next()?.kind();\n     let next_next = tokens.next()?.kind();\n-    if next == SyntaxKind::WHITESPACE && next_next == SyntaxKind::DOT {\n+    if next == SyntaxKind::WHITESPACE && next_next == T![.] {\n         let ty = sema.type_of_expr(&expr)?;\n         if ty.is_unknown() {\n             return None;\n@@ -345,655 +345,288 @@ fn get_fn_signature(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<\n \n #[cfg(test)]\n mod tests {\n-    use crate::inlay_hints::InlayHintsConfig;\n     use insta::assert_debug_snapshot;\n+    use test_utils::extract_annotations;\n \n-    use crate::mock_analysis::single_file;\n+    use crate::{inlay_hints::InlayHintsConfig, mock_analysis::single_file};\n+\n+    fn check(ra_fixture: &str) {\n+        check_with_config(ra_fixture, InlayHintsConfig::default());\n+    }\n+\n+    fn check_with_config(ra_fixture: &str, config: InlayHintsConfig) {\n+        let (analysis, file_id) = single_file(ra_fixture);\n+        let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+        let inlay_hints = analysis.inlay_hints(file_id, &config).unwrap();\n+        let actual =\n+            inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n+        assert_eq!(expected, actual);\n+    }\n \n     #[test]\n     fn param_hints_only() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n-            fn foo(a: i32, b: i32) -> i32 { a + b }\n-            fn main() {\n-                let _x = foo(4, 4);\n-            }\"#,\n-        );\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig{ parameter_hints: true, type_hints: false, chaining_hints: false, max_length: None}).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 69..70,\n-                kind: ParameterHint,\n-                label: \"a\",\n-            },\n-            InlayHint {\n-                range: 72..73,\n-                kind: ParameterHint,\n-                label: \"b\",\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(\n+        4,\n+      //^ a\n+        4,\n+      //^ b\n+    );\n+}\"#,\n+            InlayHintsConfig {\n+                parameter_hints: true,\n+                type_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n             },\n-        ]\n-        \"###);\n+        );\n     }\n \n     #[test]\n     fn hints_disabled() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n-            fn foo(a: i32, b: i32) -> i32 { a + b }\n-            fn main() {\n-                let _x = foo(4, 4);\n-            }\"#,\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(4, 4);\n+}\"#,\n+            InlayHintsConfig {\n+                type_hints: false,\n+                parameter_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n         );\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig{ type_hints: false, parameter_hints: false, chaining_hints: false, max_length: None}).unwrap(), @r###\"[]\"###);\n     }\n \n     #[test]\n     fn type_hints_only() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n-            fn foo(a: i32, b: i32) -> i32 { a + b }\n-            fn main() {\n-                let _x = foo(4, 4);\n-            }\"#,\n-        );\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig{ type_hints: true, parameter_hints: false, chaining_hints: false, max_length: None}).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 60..62,\n-                kind: TypeHint,\n-                label: \"i32\",\n+fn foo(a: i32, b: i32) -> i32 { a + b }\n+fn main() {\n+    let _x = foo(4, 4);\n+      //^^ i32\n+}\"#,\n+            InlayHintsConfig {\n+                type_hints: true,\n+                parameter_hints: false,\n+                chaining_hints: false,\n+                max_length: None,\n             },\n-        ]\n-        \"###);\n+        );\n     }\n+\n     #[test]\n     fn default_generic_types_should_not_be_displayed() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n-struct Test<K, T = u8> {\n-    k: K,\n-    t: T,\n-}\n+struct Test<K, T = u8> { k: K, t: T }\n \n fn main() {\n     let zz = Test { t: 23u8, k: 33 };\n+      //^^ Test<i32>\n     let zz_ref = &zz;\n+      //^^^^^^ &Test<i32>\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 68..70,\n-                kind: TypeHint,\n-                label: \"Test<i32>\",\n-            },\n-            InlayHint {\n-                range: 106..112,\n-                kind: TypeHint,\n-                label: \"&Test<i32>\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn let_statement() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n #[derive(PartialEq)]\n-enum CustomOption<T> {\n-    None,\n-    Some(T),\n-}\n+enum Option<T> { None, Some(T) }\n \n #[derive(PartialEq)]\n-struct Test {\n-    a: CustomOption<u32>,\n-    b: u8,\n-}\n+struct Test { a: Option<u32>, b: u8 }\n \n fn main() {\n     struct InnerStruct {}\n \n     let test = 54;\n+      //^^^^ i32\n     let test: i32 = 33;\n     let mut test = 33;\n+      //^^^^^^^^ i32\n     let _ = 22;\n     let test = \"test\";\n+      //^^^^ &str\n     let test = InnerStruct {};\n \n-    let test = vec![222];\n-    let test: Vec<_> = (0..3).collect();\n-    let test = (0..3).collect::<Vec<i128>>();\n-    let test = (0..3).collect::<Vec<_>>();\n-\n-    let mut test = Vec::new();\n-    test.push(333);\n+    let test = unresolved();\n \n     let test = (42, 'a');\n-    let (a, (b, c, (d, e), f)) = (2, (3, 4, (6.6, 7.7), 5));\n+      //^^^^ (i32, char)\n+    let (a,    (b,     (c,)) = (2, (3, (9.2,));\n+       //^ i32  ^ i32   ^ f64\n     let &x = &92;\n+       //^ i32\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 192..196,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 235..243,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 274..278,\n-                kind: TypeHint,\n-                label: \"&str\",\n-            },\n-            InlayHint {\n-                range: 538..542,\n-                kind: TypeHint,\n-                label: \"(i32, char)\",\n-            },\n-            InlayHint {\n-                range: 565..566,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 569..570,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 572..573,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 576..577,\n-                kind: TypeHint,\n-                label: \"f64\",\n-            },\n-            InlayHint {\n-                range: 579..580,\n-                kind: TypeHint,\n-                label: \"f64\",\n-            },\n-            InlayHint {\n-                range: 583..584,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 626..627,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn closure_parameters() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n fn main() {\n     let mut start = 0;\n-    (0..2).for_each(|increment| {\n-        start += increment;\n-    });\n+      //^^^^^^^^^ i32\n+    (0..2).for_each(|increment| { start += increment; });\n+                   //^^^^^^^^^ i32\n \n-    let multiply = |a, b, c, d| a * b * c * d;\n-    let _: i32 = multiply(1, 2, 3, 4);\n+    let multiply =\n+      //^^^^^^^^ |\u2026| -> i32\n+      | a,     b| a * b\n+      //^ i32  ^ i32\n+    ;\n+\n+    let _: i32 = multiply(1, 2);\n     let multiply_ref = &multiply;\n+      //^^^^^^^^^^^^ &|\u2026| -> i32\n \n     let return_42 = || 42;\n+      //^^^^^^^^^ || -> i32\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 20..29,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 56..65,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 114..122,\n-                kind: TypeHint,\n-                label: \"|\u2026| -> i32\",\n-            },\n-            InlayHint {\n-                range: 126..127,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 129..130,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 132..133,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 135..136,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 200..212,\n-                kind: TypeHint,\n-                label: \"&|\u2026| -> i32\",\n-            },\n-            InlayHint {\n-                range: 235..244,\n-                kind: TypeHint,\n-                label: \"|| -> i32\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn for_expression() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n fn main() {\n     let mut start = 0;\n-    for increment in 0..2 {\n-        start += increment;\n-    }\n+      //^^^^^^^^^ i32\n+    for increment in 0..2 { start += increment; }\n+      //^^^^^^^^^ i32\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 20..29,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 43..52,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn if_expr() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n-#[derive(PartialEq)]\n-enum CustomOption<T> {\n-    None,\n-    Some(T),\n-}\n-\n-#[derive(PartialEq)]\n-struct Test {\n-    a: CustomOption<u32>,\n-    b: u8,\n-}\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n \n-use CustomOption::*;\n+struct Test { a: Option<u32>, b: u8 }\n \n fn main() {\n     let test = Some(Test { a: Some(3), b: 1 });\n+      //^^^^ Option<Test>\n     if let None = &test {};\n     if let test = &test {};\n+         //^^^^ &Option<Test>\n     if let Some(test) = &test {};\n-    if let Some(Test { a, b }) = &test {};\n-    if let Some(Test { a: x, b: y }) = &test {};\n-    if let Some(Test { a: Some(x), b: y }) = &test {};\n-    if let Some(Test { a: None, b: y }) = &test {};\n+              //^^^^ &Test\n+    if let Some(Test { a,             b }) = &test {};\n+                     //^ &Option<u32> ^ &u8\n+    if let Some(Test { a: x,             b: y }) = &test {};\n+                        //^ &Option<u32>    ^ &u8\n+    if let Some(Test { a: Some(x),  b: y }) = &test {};\n+                             //^ &u32  ^ &u8\n+    if let Some(Test { a: None,  b: y }) = &test {};\n+                                  //^ &u8\n     if let Some(Test { b: y, .. }) = &test {};\n-\n+                        //^ &u8\n     if test == None {}\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 187..191,\n-                kind: TypeHint,\n-                label: \"CustomOption<Test>\",\n-            },\n-            InlayHint {\n-                range: 266..270,\n-                kind: TypeHint,\n-                label: \"&CustomOption<Test>\",\n-            },\n-            InlayHint {\n-                range: 299..303,\n-                kind: TypeHint,\n-                label: \"&Test\",\n-            },\n-            InlayHint {\n-                range: 340..341,\n-                kind: TypeHint,\n-                label: \"&CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 343..344,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 386..387,\n-                kind: TypeHint,\n-                label: \"&CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 392..393,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 440..441,\n-                kind: TypeHint,\n-                label: \"&u32\",\n-            },\n-            InlayHint {\n-                range: 447..448,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 499..500,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 542..543,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn while_expr() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n-#[derive(PartialEq)]\n-enum CustomOption<T> {\n-    None,\n-    Some(T),\n-}\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n \n-#[derive(PartialEq)]\n-struct Test {\n-    a: CustomOption<u32>,\n-    b: u8,\n-}\n-\n-use CustomOption::*;\n+struct Test { a: Option<u32>, b: u8 }\n \n fn main() {\n     let test = Some(Test { a: Some(3), b: 1 });\n-    while let None = &test {};\n-    while let test = &test {};\n-    while let Some(test) = &test {};\n-    while let Some(Test { a, b }) = &test {};\n-    while let Some(Test { a: x, b: y }) = &test {};\n-    while let Some(Test { a: Some(x), b: y }) = &test {};\n-    while let Some(Test { a: None, b: y }) = &test {};\n-    while let Some(Test { b: y, .. }) = &test {};\n-\n-    while test == None {}\n+      //^^^^ Option<Test>\n+    while let Some(Test { a: Some(x),  b: y }) = &test {};\n+                                //^ &u32  ^ &u8\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 187..191,\n-                kind: TypeHint,\n-                label: \"CustomOption<Test>\",\n-            },\n-            InlayHint {\n-                range: 272..276,\n-                kind: TypeHint,\n-                label: \"&CustomOption<Test>\",\n-            },\n-            InlayHint {\n-                range: 308..312,\n-                kind: TypeHint,\n-                label: \"&Test\",\n-            },\n-            InlayHint {\n-                range: 352..353,\n-                kind: TypeHint,\n-                label: \"&CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 355..356,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 401..402,\n-                kind: TypeHint,\n-                label: \"&CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 407..408,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 458..459,\n-                kind: TypeHint,\n-                label: \"&u32\",\n-            },\n-            InlayHint {\n-                range: 465..466,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 520..521,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-            InlayHint {\n-                range: 566..567,\n-                kind: TypeHint,\n-                label: \"&u8\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn match_arm_list() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n-#[derive(PartialEq)]\n-enum CustomOption<T> {\n-    None,\n-    Some(T),\n-}\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n \n-#[derive(PartialEq)]\n-struct Test {\n-    a: CustomOption<u32>,\n-    b: u8,\n-}\n-\n-use CustomOption::*;\n+struct Test { a: Option<u32>, b: u8 }\n \n fn main() {\n     match Some(Test { a: Some(3), b: 1 }) {\n         None => (),\n         test => (),\n-        Some(test) => (),\n-        Some(Test { a, b }) => (),\n-        Some(Test { a: x, b: y }) => (),\n+      //^^^^ Option<Test>\n         Some(Test { a: Some(x), b: y }) => (),\n-        Some(Test { a: None, b: y }) => (),\n-        Some(Test { b: y, .. }) => (),\n+                          //^ u32  ^ u8\n         _ => {}\n     }\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 251..255,\n-                kind: TypeHint,\n-                label: \"CustomOption<Test>\",\n-            },\n-            InlayHint {\n-                range: 276..280,\n-                kind: TypeHint,\n-                label: \"Test\",\n-            },\n-            InlayHint {\n-                range: 309..310,\n-                kind: TypeHint,\n-                label: \"CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 312..313,\n-                kind: TypeHint,\n-                label: \"u8\",\n-            },\n-            InlayHint {\n-                range: 347..348,\n-                kind: TypeHint,\n-                label: \"CustomOption<u32>\",\n-            },\n-            InlayHint {\n-                range: 353..354,\n-                kind: TypeHint,\n-                label: \"u8\",\n-            },\n-            InlayHint {\n-                range: 393..394,\n-                kind: TypeHint,\n-                label: \"u32\",\n-            },\n-            InlayHint {\n-                range: 400..401,\n-                kind: TypeHint,\n-                label: \"u8\",\n-            },\n-            InlayHint {\n-                range: 444..445,\n-                kind: TypeHint,\n-                label: \"u8\",\n-            },\n-            InlayHint {\n-                range: 479..480,\n-                kind: TypeHint,\n-                label: \"u8\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn hint_truncation() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n struct Smol<T>(T);\n \n struct VeryLongOuterName<T>(T);\n \n fn main() {\n     let a = Smol(0u32);\n+      //^ Smol<u32>\n     let b = VeryLongOuterName(0usize);\n+      //^ VeryLongOuterName<\u2026>\n     let c = Smol(Smol(0u32))\n+      //^ Smol<Smol<\u2026>>\n }\"#,\n-        );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig { max_length: Some(8), ..Default::default() }).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 73..74,\n-                kind: TypeHint,\n-                label: \"Smol<u32>\",\n-            },\n-            InlayHint {\n-                range: 97..98,\n-                kind: TypeHint,\n-                label: \"VeryLongOuterName<\u2026>\",\n-            },\n-            InlayHint {\n-                range: 136..137,\n-                kind: TypeHint,\n-                label: \"Smol<Smol<\u2026>>\",\n-            },\n-        ]\n-        \"###\n+            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n         );\n     }\n \n     #[test]\n     fn function_call_parameter_hint() {\n-        let (analysis, file_id) = single_file(\n+        check(\n             r#\"\n-enum CustomOption<T> {\n-    None,\n-    Some(T),\n-}\n-use CustomOption::*;\n+enum Option<T> { None, Some(T) }\n+use Option::*;\n \n struct FileId {}\n struct SmolStr {}\n \n-impl From<&str> for SmolStr {\n-    fn from(_: &str) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n struct TextRange {}\n struct SyntaxKind {}\n struct NavigationTarget {}\n \n struct Test {}\n \n impl Test {\n-    fn method(&self, mut param: i32) -> i32 {\n-        param * 2\n-    }\n+    fn method(&self, mut param: i32) -> i32 { param * 2 }\n \n     fn from_syntax(\n         file_id: FileId,\n         name: SmolStr,\n-        focus_range: CustomOption<TextRange>,\n+        focus_range: Option<TextRange>,\n         full_range: TextRange,\n         kind: SyntaxKind,\n-        docs: CustomOption<String>,\n-        description: CustomOption<String>,\n+        docs: Option<String>,\n     ) -> NavigationTarget {\n         NavigationTarget {}\n     }\n@@ -1005,108 +638,35 @@ fn test_func(mut foo: i32, bar: i32, msg: &str, _: i32, last: i32) -> i32 {\n \n fn main() {\n     let not_literal = 1;\n-    let _: i32 = test_func(1, 2, \"hello\", 3, not_literal);\n+      //^^^^^^^^^^^ i32\n+    let _: i32 = test_func(1,    2,      \"hello\", 3,  not_literal);\n+                         //^ foo ^ bar   ^^^^^^^ msg  ^^^^^^^^^^^ last\n     let t: Test = Test {};\n     t.method(123);\n-    Test::method(&t, 3456);\n-\n+           //^^^ param\n+    Test::method(&t,      3456);\n+               //^^ &self ^^^^ param\n     Test::from_syntax(\n         FileId {},\n+      //^^^^^^^^^ file_id\n         \"impl\".into(),\n+      //^^^^^^^^^^^^^ name\n         None,\n+      //^^^^ focus_range\n         TextRange {},\n+      //^^^^^^^^^^^^ full_range\n         SyntaxKind {},\n+      //^^^^^^^^^^^^^ kind\n         None,\n-        None,\n+      //^^^^ docs\n     );\n }\"#,\n         );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig::default()).unwrap(), @r###\"\n-        [\n-            InlayHint {\n-                range: 797..808,\n-                kind: TypeHint,\n-                label: \"i32\",\n-            },\n-            InlayHint {\n-                range: 841..842,\n-                kind: ParameterHint,\n-                label: \"foo\",\n-            },\n-            InlayHint {\n-                range: 844..845,\n-                kind: ParameterHint,\n-                label: \"bar\",\n-            },\n-            InlayHint {\n-                range: 847..854,\n-                kind: ParameterHint,\n-                label: \"msg\",\n-            },\n-            InlayHint {\n-                range: 859..870,\n-                kind: ParameterHint,\n-                label: \"last\",\n-            },\n-            InlayHint {\n-                range: 913..916,\n-                kind: ParameterHint,\n-                label: \"param\",\n-            },\n-            InlayHint {\n-                range: 936..938,\n-                kind: ParameterHint,\n-                label: \"&self\",\n-            },\n-            InlayHint {\n-                range: 940..944,\n-                kind: ParameterHint,\n-                label: \"param\",\n-            },\n-            InlayHint {\n-                range: 979..988,\n-                kind: ParameterHint,\n-                label: \"file_id\",\n-            },\n-            InlayHint {\n-                range: 998..1011,\n-                kind: ParameterHint,\n-                label: \"name\",\n-            },\n-            InlayHint {\n-                range: 1021..1025,\n-                kind: ParameterHint,\n-                label: \"focus_range\",\n-            },\n-            InlayHint {\n-                range: 1035..1047,\n-                kind: ParameterHint,\n-                label: \"full_range\",\n-            },\n-            InlayHint {\n-                range: 1057..1070,\n-                kind: ParameterHint,\n-                label: \"kind\",\n-            },\n-            InlayHint {\n-                range: 1080..1084,\n-                kind: ParameterHint,\n-                label: \"docs\",\n-            },\n-            InlayHint {\n-                range: 1094..1098,\n-                kind: ParameterHint,\n-                label: \"description\",\n-            },\n-        ]\n-        \"###\n-        );\n     }\n \n     #[test]\n     fn omitted_parameters_hints_heuristics() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n fn map(f: i32) {}\n fn filter(predicate: i32) {}\n@@ -1187,23 +747,16 @@ fn main() {\n     let _: f64 = a.div_euclid(b);\n     let _: f64 = a.abs_sub(b);\n }\"#,\n-        );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig { max_length: Some(8), ..Default::default() }).unwrap(), @r###\"\n-        []\n-        \"###\n+            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n         );\n     }\n \n     #[test]\n     fn unit_structs_have_no_type_hints() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n-enum CustomResult<T, E> {\n-    Ok(T),\n-    Err(E),\n-}\n-use CustomResult::*;\n+enum Result<T, E> { Ok(T), Err(E) }\n+use Result::*;\n \n struct SyntheticSyntax;\n \n@@ -1213,11 +766,7 @@ fn main() {\n         Err(SyntheticSyntax) => (),\n     }\n }\"#,\n-        );\n-\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig { max_length: Some(8), ..Default::default() }).unwrap(), @r###\"\n-        []\n-        \"###\n+            InlayHintsConfig { max_length: Some(8), ..Default::default() },\n         );\n     }\n \n@@ -1255,42 +804,47 @@ fn main() {\n \n     #[test]\n     fn chaining_hints_without_newlines() {\n-        let (analysis, file_id) = single_file(\n+        check_with_config(\n             r#\"\n-            struct A(B);\n-            impl A { fn into_b(self) -> B { self.0 } }\n-            struct B(C);\n-            impl B { fn into_c(self) -> C { self.0 } }\n-            struct C;\n+struct A(B);\n+impl A { fn into_b(self) -> B { self.0 } }\n+struct B(C);\n+impl B { fn into_c(self) -> C { self.0 } }\n+struct C;\n \n-            fn main() {\n-                let c = A(B(C)).into_b().into_c();\n-            }\"#,\n+fn main() {\n+    let c = A(B(C)).into_b().into_c();\n+}\"#,\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n         );\n-        assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"[]\"###);\n     }\n \n     #[test]\n     fn struct_access_chaining_hints() {\n         let (analysis, file_id) = single_file(\n             r#\"\n-            struct A { pub b: B }\n-            struct B { pub c: C }\n-            struct C(pub bool);\n-            struct D;\n+struct A { pub b: B }\n+struct B { pub c: C }\n+struct C(pub bool);\n+struct D;\n \n-            impl D {\n-                fn foo(&self) -> i32 { 42 }\n-            }\n+impl D {\n+    fn foo(&self) -> i32 { 42 }\n+}\n \n-            fn main() {\n-                let x = A { b: B { c: C(true) } }\n-                    .b\n-                    .c\n-                    .0;\n-                let x = D\n-                    .foo();\n-            }\"#,\n+fn main() {\n+    let x = A { b: B { c: C(true) } }\n+        .b\n+        .c\n+        .0;\n+    let x = D\n+        .foo();\n+}\"#,\n         );\n         assert_debug_snapshot!(analysis.inlay_hints(file_id, &InlayHintsConfig{ parameter_hints: false, type_hints: false, chaining_hints: true, max_length: None}).unwrap(), @r###\"\n         ["}, {"sha": "e32a0a0c318aea86867429bb46dc4c235cf39481", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4a19d5954a4665a7a8572f9592f855f68cf0f2c6/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a19d5954a4665a7a8572f9592f855f68cf0f2c6/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=4a19d5954a4665a7a8572f9592f855f68cf0f2c6", "patch": "@@ -11,7 +11,7 @@ pub mod mark;\n mod fixture;\n \n use std::{\n-    convert::TryInto,\n+    convert::{TryFrom, TryInto},\n     env, fs,\n     path::{Path, PathBuf},\n };\n@@ -169,24 +169,38 @@ pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     for line in lines_with_ends(text) {\n         if let Some(idx) = line.find(\"//^\") {\n             let offset = prev_line_start.unwrap() + TextSize::of(&line[..idx + \"//\".len()]);\n-            let marker_and_data = &line[idx + \"//\".len()..];\n-            let len = marker_and_data.chars().take_while(|&it| it == '^').count();\n-            let data = marker_and_data[len..].trim().to_string();\n-            res.push((TextRange::at(offset, len.try_into().unwrap()), data))\n+            for (line_range, text) in extract_line_annotations(&line[idx + \"//\".len()..]) {\n+                res.push((line_range + offset, text))\n+            }\n         }\n         prev_line_start = Some(line_start);\n         line_start += TextSize::of(line);\n     }\n     res\n }\n \n+fn extract_line_annotations(mut line: &str) -> Vec<(TextRange, String)> {\n+    let mut res = Vec::new();\n+    let mut offset: TextSize = 0.into();\n+    while !line.is_empty() {\n+        let len = line.chars().take_while(|&it| it == '^').count();\n+        assert!(len > 0);\n+        let range = TextRange::at(offset, len.try_into().unwrap());\n+        let next = line[len..].find('^').map_or(line.len(), |it| it + len);\n+        res.push((range, line[len..][..next - len].trim().to_string()));\n+        line = &line[next..];\n+        offset += TextSize::try_from(next).unwrap();\n+    }\n+    res\n+}\n+\n #[test]\n fn test_extract_annotations() {\n     let text = stdx::trim_indent(\n         r#\"\n fn main() {\n-    let x = 92;\n-      //^ def\n+    let (x,     y) = (9, 2);\n+       //^ def  ^ def\n     zoo + 1\n } //^^^ i32\n     \"#,\n@@ -195,7 +209,7 @@ fn main() {\n         .into_iter()\n         .map(|(range, ann)| (&text[range], ann))\n         .collect::<Vec<_>>();\n-    assert_eq!(res, vec![(\"x\", \"def\".into()), (\"zoo\", \"i32\".into()),]);\n+    assert_eq!(res, vec![(\"x\", \"def\".into()), (\"y\", \"def\".into()), (\"zoo\", \"i32\".into()),]);\n }\n \n // Comparison functionality borrowed from cargo:"}]}