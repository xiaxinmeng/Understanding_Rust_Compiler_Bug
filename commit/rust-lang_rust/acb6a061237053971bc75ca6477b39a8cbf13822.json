{"sha": "acb6a061237053971bc75ca6477b39a8cbf13822", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYjZhMDYxMjM3MDUzOTcxYmM3NWNhNjQ3N2IzOWE4Y2JmMTM4MjI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-28T20:04:39Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-30T19:39:33Z"}, "message": "Fix various Chalk lowering bugs\n\n- Add more well-known traits\n- Use the correct binders when lowering trait objects\n- Use correct substs when lowering trait objects\n- Use the correct binders for opaque_ty_data\n- Lower negative impls with the correct polarity\n- Supply associated type values\n- Use `predicates_defined_on` for where clauses", "tree": {"sha": "a8f43f0a93258fc05549b2c944aeb1b2d3530bbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8f43f0a93258fc05549b2c944aeb1b2d3530bbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acb6a061237053971bc75ca6477b39a8cbf13822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acb6a061237053971bc75ca6477b39a8cbf13822", "html_url": "https://github.com/rust-lang/rust/commit/acb6a061237053971bc75ca6477b39a8cbf13822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acb6a061237053971bc75ca6477b39a8cbf13822/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "299a65ff71413de0fc26d880219402ceb7fa1bcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/299a65ff71413de0fc26d880219402ceb7fa1bcb", "html_url": "https://github.com/rust-lang/rust/commit/299a65ff71413de0fc26d880219402ceb7fa1bcb"}], "stats": {"total": 203, "additions": 161, "deletions": 42}, "files": [{"sha": "c5a46b1003dfaaf44d11710cc435dbb639f8898a", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 94, "deletions": 36, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/acb6a061237053971bc75ca6477b39a8cbf13822/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb6a061237053971bc75ca6477b39a8cbf13822/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=acb6a061237053971bc75ca6477b39a8cbf13822", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.interner.tcx.predicates_of(def_id).predicates;\n+        let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n         predicates\n@@ -118,34 +118,27 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known = if self.interner.tcx.lang_items().sized_trait() == Some(def_id) {\n+        let lang_items = self.interner.tcx.lang_items();\n+        let well_known = if lang_items.sized_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-        } else if self.interner.tcx.lang_items().copy_trait() == Some(def_id) {\n+        } else if lang_items.copy_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-        } else if self.interner.tcx.lang_items().clone_trait() == Some(def_id) {\n+        } else if lang_items.clone_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-        } else if self.interner.tcx.lang_items().drop_trait() == Some(def_id) {\n+        } else if lang_items.drop_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-        } else if self.interner.tcx.lang_items().fn_trait() == Some(def_id) {\n+        } else if lang_items.fn_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_once_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_once_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_mut_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_mut_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unsize)\n+        } else if lang_items.unpin_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unpin)\n+        } else if lang_items.coerce_unsized_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::CoerceUnsized)\n         } else {\n             None\n         };\n@@ -281,11 +274,20 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             where_clauses,\n         };\n \n+        let associated_ty_value_ids: Vec<_> = self\n+            .interner\n+            .tcx\n+            .associated_items(def_id)\n+            .in_definition_order()\n+            .filter(|i| i.kind == AssocKind::Type)\n+            .map(|i| chalk_solve::rust_ir::AssociatedTyValueId(i.def_id))\n+            .collect();\n+\n         Arc::new(chalk_solve::rust_ir::ImplDatum {\n-            polarity: chalk_solve::rust_ir::Polarity::Positive,\n+            polarity: self.interner.tcx.impl_polarity(def_id).lower_into(&self.interner),\n             binders: chalk_ir::Binders::new(binders, value),\n             impl_type: chalk_solve::rust_ir::ImplType::Local,\n-            associated_ty_value_ids: vec![],\n+            associated_ty_value_ids,\n         })\n     }\n \n@@ -406,24 +408,38 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let impl_id = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => def_id,\n-            _ => unimplemented!(\"Not possible??\"),\n+        let (impl_id, trait_id) = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => (def_id, def_id),\n+            AssocItemContainer::ImplContainer(def_id) => {\n+                (def_id, self.interner.tcx.impl_trait_ref(def_id).unwrap().def_id)\n+            }\n         };\n         match assoc_item.kind {\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n+\n+        let trait_item = self\n+            .interner\n+            .tcx\n+            .associated_items(trait_id)\n+            .find_by_name_and_kind(self.interner.tcx, assoc_item.ident, assoc_item.kind, trait_id)\n+            .unwrap();\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let ty = self.interner.tcx.type_of(def_id);\n+        let ty = self\n+            .interner\n+            .tcx\n+            .type_of(def_id)\n+            .subst(self.interner.tcx, bound_vars)\n+            .lower_into(&self.interner);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n-            associated_ty_id: chalk_ir::AssocTypeId(def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(trait_item.def_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n-                chalk_solve::rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+                chalk_solve::rust_ir::AssociatedTyValueBound { ty },\n             ),\n         })\n     }\n@@ -443,19 +459,61 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n-        let binders = binders_for(&self.interner, bound_vars);\n+        let bound_vars = ty::fold::shift_vars(\n+            self.interner.tcx,\n+            &bound_vars_for_item(self.interner.tcx, opaque_ty_id.0),\n+            1,\n+        );\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n-        let bounds = self.bounds_for(opaque_ty_id.0, bound_vars);\n+\n+        let identity_substs = InternalSubsts::identity_for_item(self.interner.tcx, opaque_ty_id.0);\n+\n+        let bounds =\n+            self.interner\n+                .tcx\n+                .explicit_item_bounds(opaque_ty_id.0)\n+                .iter()\n+                .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n+                .map(|bound| {\n+                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n+                        tcx: self.interner.tcx,\n+                        ty_op: |ty| {\n+                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                    return self.interner.tcx.mk_ty(ty::Bound(\n+                                        ty::INNERMOST,\n+                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                    ));\n+                                }\n+                            }\n+                            ty\n+                        },\n+                        lt_op: |lt| lt,\n+                        ct_op: |ct| ct,\n+                    })\n+                })\n+                .filter_map(|bound| {\n+                    LowerInto::<\n+                    Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n+                >::lower_into(bound, &self.interner)\n+                })\n+                .collect();\n+\n+        // Binder for the bound variable representing the concrete impl Trait type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            &self.interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(binders.clone(), bounds),\n-            where_clauses: chalk_ir::Binders::new(binders, where_clauses),\n+            bounds: chalk_ir::Binders::new(existential_binder.clone(), bounds),\n+            where_clauses: chalk_ir::Binders::new(existential_binder, where_clauses),\n         };\n \n+        let binders = binders_for(&self.interner, bound_vars);\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n-            bound: chalk_ir::Binders::empty(&self.interner, value),\n+            bound: chalk_ir::Binders::new(binders, value),\n         })\n     }\n "}, {"sha": "81e7fa4aa3082c893cf56dc96a495189af6cc76e", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/acb6a061237053971bc75ca6477b39a8cbf13822/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb6a061237053971bc75ca6477b39a8cbf13822/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=acb6a061237053971bc75ca6477b39a8cbf13822", "patch": "@@ -638,8 +638,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n+        // `Self` has one binder:\n+        // Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n+        // The return type has two:\n+        // Binders<&[Binders<WhereClause<I>>]>\n+        // This means that any variables that are escaping `self` need to be\n+        // shifted in by one so that they are still escaping.\n+        let shifted_predicates = ty::fold::shift_vars(interner.tcx, &self, 1);\n+\n         let (predicates, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self);\n+            collect_bound_vars(interner, interner.tcx, &shifted_predicates);\n         let self_ty = interner.tcx.mk_ty(ty::Bound(\n             // This is going to be wrapped in a binder\n             ty::DebruijnIndex::from_usize(1),\n@@ -648,7 +656,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n             ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n                 chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::empty(interner),\n+                    binders.clone(),\n                     chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                         trait_id: chalk_ir::TraitId(def_id),\n                         substitution: interner\n@@ -659,25 +667,34 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                 )\n             }\n             ty::ExistentialPredicate::Projection(predicate) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq {\n                     alias: chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n                         associated_ty_id: chalk_ir::AssocTypeId(predicate.item_def_id),\n-                        substitution: predicate.substs.lower_into(interner),\n+                        substitution: interner\n+                            .tcx\n+                            .mk_substs_trait(self_ty, predicate.substs)\n+                            .lower_into(interner),\n                     }),\n                     ty: predicate.ty.lower_into(interner),\n                 }),\n             ),\n             ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                     trait_id: chalk_ir::TraitId(def_id),\n                     substitution: interner.tcx.mk_substs_trait(self_ty, &[]).lower_into(interner),\n                 }),\n             ),\n         });\n+\n+        // Binder for the bound variable representing the concrete underlying type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n         let value = chalk_ir::QuantifiedWhereClauses::from_iter(interner, where_clauses);\n-        chalk_ir::Binders::new(binders, value)\n+        chalk_ir::Binders::new(existential_binder, value)\n     }\n }\n \n@@ -750,6 +767,17 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::TraitBound<RustInterner<'tcx>>>\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::Polarity> for ty::ImplPolarity {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> chalk_solve::rust_ir::Polarity {\n+        match self {\n+            ty::ImplPolarity::Positive => chalk_solve::rust_ir::Polarity::Positive,\n+            ty::ImplPolarity::Negative => chalk_solve::rust_ir::Polarity::Negative,\n+            // FIXME(chalk) reservation impls\n+            ty::ImplPolarity::Reservation => chalk_solve::rust_ir::Polarity::Negative,\n+        }\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>>>\n     for ty::ProjectionPredicate<'tcx>\n {"}, {"sha": "a20acce4c76b2e64e986ddff4dbc8c93ad1bb5be", "filename": "src/test/ui/chalkify/arithmetic.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acb6a061237053971bc75ca6477b39a8cbf13822/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb6a061237053971bc75ca6477b39a8cbf13822/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs?ref=acb6a061237053971bc75ca6477b39a8cbf13822", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    1 + 2;\n+    3 * 6;\n+    2 - 5;\n+    17 / 6;\n+    23 % 11;\n+    4 & 6;\n+    7 | 15;\n+    4 << 7;\n+    123 >> 3;\n+    1 == 2;\n+    5 != 5;\n+    6 < 2;\n+    7 > 11;\n+    3 <= 1;\n+    9 >= 14;\n+}"}, {"sha": "13d9e6a6578856fd89c5a359bcf2f4434280ce0c", "filename": "src/test/ui/chalkify/trait-objects.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/acb6a061237053971bc75ca6477b39a8cbf13822/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb6a061237053971bc75ca6477b39a8cbf13822/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs?ref=acb6a061237053971bc75ca6477b39a8cbf13822", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+use std::fmt::Display;\n+\n+fn main() {\n+    let d: &dyn Display = &mut 3;\n+    // FIXME(chalk) should be able to call d.to_string() as well, but doing so\n+    // requires Chalk to be able to prove trait object well-formed goals.\n+    (&d).to_string();\n+    let f: &dyn Fn(i32) -> _ = &|x| x + x;\n+    f(2);\n+}"}]}