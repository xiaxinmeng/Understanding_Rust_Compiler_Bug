{"sha": "3427a412722016c237b473790da63d89a164217c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MjdhNDEyNzIyMDE2YzIzN2I0NzM3OTBkYTYzZDg5YTE2NDIxN2M=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T00:18:42Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-13T00:18:53Z"}, "message": "stdlib: Add interior vector methods to sha1", "tree": {"sha": "7468dd8e47bbdc77b0d21444c3d1acf4ff938ff3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7468dd8e47bbdc77b0d21444c3d1acf4ff938ff3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3427a412722016c237b473790da63d89a164217c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3427a412722016c237b473790da63d89a164217c", "html_url": "https://github.com/rust-lang/rust/commit/3427a412722016c237b473790da63d89a164217c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3427a412722016c237b473790da63d89a164217c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "032c4deefee8afcb55fb4ce0e82090776d297b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/032c4deefee8afcb55fb4ce0e82090776d297b50", "html_url": "https://github.com/rust-lang/rust/commit/032c4deefee8afcb55fb4ce0e82090776d297b50"}], "stats": {"total": 49, "additions": 32, "deletions": 17}, "files": [{"sha": "9ff775c3d4a51f55133c9e2b0448faf3bfe5ce80", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3427a412722016c237b473790da63d89a164217c/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3427a412722016c237b473790da63d89a164217c/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=3427a412722016c237b473790da63d89a164217c", "patch": "@@ -14,6 +14,8 @@ type sha1 =\n             // Provide message input as bytes\n             fn input(&vec[u8]) ;\n \n+            fn input_ivec(&u8[]);\n+\n             // Provide message input as string\n             fn input_str(&str) ;\n \n@@ -22,6 +24,8 @@ type sha1 =\n             // until reset is called\n             fn result() -> vec[u8] ;\n \n+            fn result_ivec() -> u8[];\n+\n             // Same as above, just a hex-string version.\n             fn result_str() -> str ;\n \n@@ -50,15 +54,15 @@ const u32 k3 = 0xCA62C1D6u32;\n // Builds a sha1 object\n fn mk_sha1() -> sha1 {\n     type sha1state =\n-        rec(vec[mutable u32] h,\n+        rec(u32[mutable] h,\n             mutable u32 len_low,\n             mutable u32 len_high,\n-            vec[mutable u8] msg_block,\n+            u8[mutable] msg_block,\n             mutable uint msg_block_idx,\n             mutable bool computed,\n-            vec[mutable u32] work_buf);\n+            u32[mutable] work_buf);\n \n-    fn add_input(&sha1state st, &vec[u8] msg) {\n+    fn add_input(&sha1state st, &u8[] msg) {\n         // FIXME: Should be typestate precondition\n \n         assert (!st.computed);\n@@ -80,8 +84,8 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n         // FIXME: Make precondition\n \n-        assert (vec::len(st.h) == digest_buf_len);\n-        assert (vec::len(st.work_buf) == work_buf_len);\n+        assert (ivec::len(st.h) == digest_buf_len);\n+        assert (ivec::len(st.work_buf) == work_buf_len);\n         let int t; // Loop counter\n \n         auto w = st.work_buf;\n@@ -160,15 +164,15 @@ fn mk_sha1() -> sha1 {\n     fn circular_shift(u32 bits, u32 word) -> u32 {\n         ret word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(&sha1state st) -> vec[u8] {\n+    fn mk_result(&sha1state st) -> u8[] {\n         if (!st.computed) { pad_msg(st); st.computed = true; }\n-        let vec[u8] rs = [];\n+        let u8[] rs = ~[];\n         for (u32 hpart in st.h) {\n             auto a = hpart >> 24u32 & 0xFFu32 as u8;\n             auto b = hpart >> 16u32 & 0xFFu32 as u8;\n             auto c = hpart >> 8u32 & 0xFFu32 as u8;\n             auto d = hpart & 0xFFu32 as u8;\n-            rs += [a, b, c, d];\n+            rs += ~[a, b, c, d];\n         }\n         ret rs;\n     }\n@@ -185,7 +189,7 @@ fn mk_sha1() -> sha1 {\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n \n-        assert (vec::len(st.msg_block) == msg_block_len);\n+        assert (ivec::len(st.msg_block) == msg_block_len);\n         /*\n          * Check to see if the current message block is too small to hold\n          * the initial padding bits and length.  If so, we will pad the\n@@ -224,7 +228,7 @@ fn mk_sha1() -> sha1 {\n         fn reset() {\n             // FIXME: Should be typestate precondition\n \n-            assert (vec::len(st.h) == digest_buf_len);\n+            assert (ivec::len(st.h) == digest_buf_len);\n             st.len_low = 0u32;\n             st.len_high = 0u32;\n             st.msg_block_idx = 0u;\n@@ -235,9 +239,20 @@ fn mk_sha1() -> sha1 {\n             st.h.(4) = 0xC3D2E1F0u32;\n             st.computed = false;\n         }\n-        fn input(&vec[u8] msg) { add_input(st, msg); }\n-        fn input_str(&str msg) { add_input(st, str::bytes(msg)); }\n-        fn result() -> vec[u8] { ret mk_result(st); }\n+        fn input(&vec[u8] msg) {\n+            auto m = ~[];\n+            for (u8 b in msg) { m += ~[b]; }\n+            add_input(st, m);\n+        }\n+        fn input_ivec(&u8[] msg) { add_input(st, msg); }\n+        fn input_str(&str msg) { add_input(st, str::bytes_ivec(msg)); }\n+        fn result() -> vec[u8] {\n+            auto rivec = mk_result(st);\n+            auto rvec = [];\n+            for (u8 b in rivec) { rvec += [b]; }\n+            ret rvec;\n+        }\n+        fn result_ivec() -> u8[] { ret mk_result(st); }\n         fn result_str() -> str {\n             auto r = mk_result(st);\n             auto s = \"\";\n@@ -246,13 +261,13 @@ fn mk_sha1() -> sha1 {\n         }\n     }\n     auto st =\n-        rec(h=vec::init_elt_mut[u32](0u32, digest_buf_len),\n+        rec(h=ivec::init_elt_mut[u32](0u32, digest_buf_len),\n             mutable len_low=0u32,\n             mutable len_high=0u32,\n-            msg_block=vec::init_elt_mut[u8](0u8, msg_block_len),\n+            msg_block=ivec::init_elt_mut[u8](0u8, msg_block_len),\n             mutable msg_block_idx=0u,\n             mutable computed=false,\n-            work_buf=vec::init_elt_mut[u32](0u32, work_buf_len));\n+            work_buf=ivec::init_elt_mut[u32](0u32, work_buf_len));\n     auto sh = sha1(st);\n     sh.reset();\n     ret sh;"}]}