{"sha": "b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YWIyYzdmMWNmMzFhNjQyYzgyNjA0N2VkMTAyNWY0ZmMxM2Q4Nzk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-14T19:00:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-14T19:07:57Z"}, "message": "split MaybeUninit into several features, expand docs a bit", "tree": {"sha": "db4477f64816879f5c98e617cb376e8fe7d467df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db4477f64816879f5c98e617cb376e8fe7d467df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "html_url": "https://github.com/rust-lang/rust/commit/b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e54494727855cd14229f5d456591ed2a2f027c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/e54494727855cd14229f5d456591ed2a2f027c46", "html_url": "https://github.com/rust-lang/rust/commit/e54494727855cd14229f5d456591ed2a2f027c46"}], "stats": {"total": 88, "additions": 55, "deletions": 33}, "files": [{"sha": "fc1c18789247104ad53c992d9fa3e216d6fe2ca1", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "patch": "@@ -453,7 +453,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.as_ptr()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -1143,7 +1143,7 @@ impl<BorrowType, K, V>\n         NodeRef {\n             height: self.node.height - 1,\n             node: unsafe {\n-                self.node.as_internal().edges.get_unchecked(self.idx).get_ref().as_ptr()\n+                (&*self.node.as_internal().edges.get_unchecked(self.idx).as_ptr()).as_ptr()\n             },\n             root: self.node.root,\n             _marker: PhantomData"}, {"sha": "2f23a697a58c1a9f478595d1434fcc572cc8dc0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "patch": "@@ -112,7 +112,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n "}, {"sha": "2c0d0dd149072dfe90a61600707b9a64961f3607", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "patch": "@@ -122,7 +122,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit)]\n+#![feature(maybe_uninit, maybe_uninit_slice)]\n #![feature(unrestricted_attribute_tokens)]\n \n #[prelude_import]"}, {"sha": "02f8065eb210d71cdec1d6993ff82f485fd6bcdd", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "patch": "@@ -563,11 +563,11 @@ macro_rules! unimplemented {\n \n /// A macro to create an array of [`MaybeUninit`]\n ///\n-/// This macro constructs and uninitialized array of the type `[MaybeUninit<K>; N]`.\n+/// This macro constructs an uninitialized array of the type `[MaybeUninit<K>; N]`.\n ///\n /// [`MaybeUninit`]: mem/union.MaybeUninit.html\n #[macro_export]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n macro_rules! uninitialized_array {\n     // This `into_initialized` is safe because an array of `MaybeUninit` does not\n     // require initialization."}, {"sha": "c4443a25d8c2de0cdbbe8bba6ca19c589b9102c1", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ab2c7f1cf31a642c826047ed1025f4fc13d879/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b5ab2c7f1cf31a642c826047ed1025f4fc13d879", "patch": "@@ -1045,17 +1045,34 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// use std::mem;\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().into_initialized() }; // undefined behavior!\n /// ```\n ///\n /// This is exploited by the compiler for various optimizations, such as eliding\n /// run-time checks and optimizing `enum` layout.\n ///\n-/// Not initializing memory at all (instead of zero--initializing it) causes the same\n+/// Not initializing memory at all (instead of zero-initializing it) causes the same\n /// issue: after all, the initial value of the variable might just happen to be\n-/// one that violates the invariant.\n+/// one that violates the invariant. Moreover, uninitialized memory is special\n+/// in that the compiler knows that it does not have a fixed value. This makes\n+/// it undefined behavior to have uninitialized data in a variable even if that\n+/// variable has otherwise no restrictions about which values are valid:\n+///\n+/// ```rust,no_run\n+/// #![feature(maybe_uninit)]\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // equivalent code with `MaybeUninit`\n+/// let x: i32 = unsafe { MaybeUninit::uninitialized().into_initialized() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n ///\n /// `MaybeUninit` serves to enable unsafe code to deal with uninitialized data:\n /// it is a signal to the compiler indicating that the data here might *not*\n@@ -1065,7 +1082,8 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n-/// // Create an explicitly uninitialized reference.\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninitialized();\n /// // Set it to a valid value.\n /// x.set(&0);\n@@ -1075,6 +1093,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// ```\n ///\n /// The compiler then knows to not optimize this code.\n+// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n #[allow(missing_debug_implementations)]\n #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n // NOTE after stabilizing `MaybeUninit` proceed to deprecate `mem::{uninitialized,zeroed}`\n@@ -1134,14 +1153,31 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n+    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n     /// Extracts the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_initialized(self) -> T {\n@@ -1162,8 +1198,9 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -1174,41 +1211,26 @@ impl<T> MaybeUninit<T> {\n     /// # Unsafety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n-    /// state, otherwise this will immediately cause undefined behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Get sa mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference will be undefined behavior unless the `MaybeUninit` is initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}]}