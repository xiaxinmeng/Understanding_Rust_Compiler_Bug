{"sha": "5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMmE2YzczY2E1YjBlMDgyYzNmYjJhM2VlZTQwZTE4MDI5MzU1Zjk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-05T23:31:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-05T23:31:35Z"}, "message": "Use uniform pair representation of functions everywhere, including static functions.", "tree": {"sha": "6318714f17b5298e3c81729dc988b028f928c7e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6318714f17b5298e3c81729dc988b028f928c7e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "html_url": "https://github.com/rust-lang/rust/commit/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fca7d61dd83dbef35f386a96929a6139a0531a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fca7d61dd83dbef35f386a96929a6139a0531a8", "html_url": "https://github.com/rust-lang/rust/commit/4fca7d61dd83dbef35f386a96929a6139a0531a8"}], "stats": {"total": 170, "additions": 132, "deletions": 38}, "files": [{"sha": "624c56f93c4f7649b9ceb7609726dec9dfac8986", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "patch": "@@ -42,6 +42,25 @@ const uint LLVMColdCallConv = 9u;\n const uint LLVMX86StdcallCallConv = 64u;\n const uint LLVMX86FastcallCallConv = 65u;\n \n+\n+const uint LLVMExternalLinkage = 0u;\n+const uint LLVMAvailableExternallyLinkage = 1u;\n+const uint LLVMLinkOnceAnyLinkage = 2u;\n+const uint LLVMLinkOnceODRLinkage = 3u;\n+const uint LLVMWeakAnyLinkage = 4u;\n+const uint LLVMWeakODRLinkage = 5u;\n+const uint LLVMAppendingLinkage = 6u;\n+const uint LLVMInternalLinkage = 7u;\n+const uint LLVMPrivateLinkage = 8u;\n+const uint LLVMDLLImportLinkage = 9u;\n+const uint LLVMDLLExportLinkage = 10u;\n+const uint LLVMExternalWeakLinkage = 11u;\n+const uint LLVMGhostLinkage = 12u;\n+const uint LLVMCommonLinkage = 13u;\n+const uint LLVMLinkerPrivateLinkage = 14u;\n+const uint LLVMLinkerPrivateWeakLinkage = 15u;\n+\n+\n // Consts for the LLVM IntPredicate type, pre-cast to uint.\n // FIXME: as above.\n "}, {"sha": "75a75b3fe6bf24f9734614cfb525e76f3ba42eae", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 113, "deletions": 38, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5d2a6c73ca5b0e082c3fb2a3eee40e18029355f9", "patch": "@@ -67,6 +67,8 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id, @tag_info] tags,\n+                            hashmap[ast.def_id, ValueRef] fn_pairs,\n+                            hashmap[ast.def_id,()] obj_methods,\n                             hashmap[@ty.t, ValueRef] tydescs,\n                             vec[ast.obj_field] obj_fields,\n                             @glue_fns glues,\n@@ -193,7 +195,7 @@ fn T_fn(vec[TypeRef] inputs, TypeRef output) -> TypeRef {\n                               False);\n }\n \n-fn T_closure(TypeRef tfn) -> TypeRef {\n+fn T_fn_pair(TypeRef tfn) -> TypeRef {\n     ret T_struct(vec(T_ptr(tfn),\n                      T_ptr(T_box(T_nil()))));\n }\n@@ -389,7 +391,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             ret T_struct(tys);\n         }\n         case (ty.ty_fn(?args, ?out)) {\n-            ret type_of_fn(cx, args, out);\n+            ret T_fn_pair(type_of_fn(cx, args, out));\n         }\n         case (ty.ty_obj(?meths)) {\n             auto th = mk_type_handle();\n@@ -500,6 +502,8 @@ fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n                                 _str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, sc);\n     llvm.LLVMSetGlobalConstant(g, True);\n+    llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+                        as llvm.Linkage);\n     ret g;\n }\n \n@@ -679,6 +683,8 @@ fn make_tydesc(@crate_ctxt cx, @ty.t t) {\n     auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(tydesc), _str.buf(name));\n     llvm.LLVMSetInitializer(gvar, tydesc);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n+    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n+                        as llvm.Linkage);\n     cx.tydescs.insert(t, gvar);\n }\n \n@@ -1725,17 +1731,22 @@ fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n-                    check (cx.fcx.ccx.item_ids.contains_key(did));\n-                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(did));\n+                    check (cx.fcx.ccx.fn_pairs.contains_key(did));\n+                    ret lval_val(cx, cx.fcx.ccx.fn_pairs.get(did));\n                 }\n                 case (ast.def_obj(?did)) {\n-                    check (cx.fcx.ccx.item_ids.contains_key(did));\n-                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(did));\n+                    check (cx.fcx.ccx.fn_pairs.contains_key(did));\n+                    ret lval_val(cx, cx.fcx.ccx.fn_pairs.get(did));\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     check (cx.fcx.ccx.tags.contains_key(tid));\n-                    check (cx.fcx.ccx.item_ids.contains_key(vid));\n-                    ret lval_val(cx, cx.fcx.ccx.item_ids.get(vid));\n+                    if (cx.fcx.ccx.fn_pairs.contains_key(vid)) {\n+                        ret lval_val(cx, cx.fcx.ccx.fn_pairs.get(vid));\n+                    } else {\n+                        // Nullary variants are just scalar constants.\n+                        check (cx.fcx.ccx.item_ids.contains_key(vid));\n+                        ret lval_val(cx, cx.fcx.ccx.item_ids.get(vid));\n+                    }\n                 }\n                 case (_) {\n                     cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n@@ -1942,7 +1953,7 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n                      &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto bcx = f_res.res.bcx;\n-    auto pair_t = T_closure(node_type(cx.fcx.ccx, ann));\n+    auto pair_t = node_type(cx.fcx.ccx, ann);\n     auto pair_v = bcx.build.Alloca(pair_t);\n     if (f_res.is_mem) {\n         cx.fcx.ccx.sess.unimpl(\"re-binding existing function\");\n@@ -1959,19 +1970,18 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                      vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n-    if (f_res.is_mem) {\n-        alt (f_res.llobj) {\n-            case (some[ValueRef](_)) {\n-                // It's a vtbl entry.\n-                faddr = f_res.res.bcx.build.Load(faddr);\n-            }\n-            case (none[ValueRef]) {\n-                // It's a closure.\n-                auto bcx = f_res.res.bcx;\n-                faddr = bcx.build.GEP(faddr, vec(C_int(0),\n-                                                 C_int(abi.fn_field_code)));\n-                faddr = bcx.build.Load(faddr);\n-            }\n+\n+    alt (f_res.llobj) {\n+        case (some[ValueRef](_)) {\n+            // It's a vtbl entry.\n+            faddr = f_res.res.bcx.build.Load(faddr);\n+        }\n+        case (none[ValueRef]) {\n+            // It's a closure.\n+            auto bcx = f_res.res.bcx;\n+            faddr = bcx.build.GEP(faddr, vec(C_int(0),\n+                                             C_int(abi.fn_field_code)));\n+            faddr = bcx.build.Load(faddr);\n         }\n     }\n     auto fn_ty = ty.expr_ty(f);\n@@ -2701,6 +2711,8 @@ impure fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n                                    _str.buf(\"_rust_vtbl\" + \".\" + cx.path));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n+    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n+                        as llvm.Linkage);\n     ret gvar;\n }\n \n@@ -2818,15 +2830,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                            id=varg.id));\n     }\n \n-    auto var_ty = ty.ann_to_type(variant.ann);\n-    auto llfnty = type_of(cx, var_ty);\n-\n-    let str s = cx.names.next(\"_rust_tag\") + \".\" + cx.path;\n-    let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfnty);\n-    cx.item_ids.insert(variant.id, llfn);\n-\n+    check (cx.item_ids.contains_key(variant.id));\n     let ValueRef llfndecl = cx.item_ids.get(variant.id);\n-    cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n     create_llargs_for_fn_args(fcx, none[TypeRef], ret_ty_of_fn(variant.ann),\n@@ -2907,25 +2912,59 @@ impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n     }\n }\n \n+fn decl_fn_and_pair(@crate_ctxt cx,\n+                    str kind,\n+                    str name,\n+                    &ast.ann ann,\n+                    ast.def_id id) {\n+\n+    // Bit of a kludge: pick the fn typeref out of the pair.\n+    auto llpairty = node_type(cx, ann);\n+    let vec[TypeRef] pair_tys = vec(T_nil(), T_nil());\n+    llvm.LLVMGetStructElementTypes(llpairty,\n+                                   _vec.buf[TypeRef](pair_tys));\n+    auto llfty = llvm.LLVMGetElementType(pair_tys.(0));\n+\n+    // Declare the function itself.\n+    let str s = cx.names.next(\"_rust_\" + kind) + \".\" + name;\n+    let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfty);\n+\n+    // Declare the global constant pair that points to it.\n+    let str ps = cx.names.next(\"_rust_\" + kind + \"_pair\") + \".\" + name;\n+    let ValueRef gvar = llvm.LLVMAddGlobal(cx.llmod, llpairty,\n+                                           _str.buf(ps));\n+    auto pair = C_struct(vec(llfn,\n+                             C_null(T_ptr(T_box(T_nil())))));\n+\n+    llvm.LLVMSetInitializer(gvar, pair);\n+    llvm.LLVMSetGlobalConstant(gvar, True);\n+    llvm.LLVMSetLinkage(gvar,\n+                        lib.llvm.LLVMPrivateLinkage\n+                        as llvm.Linkage);\n+\n+    cx.item_ids.insert(id, llfn);\n+    cx.fn_pairs.insert(id, gvar);\n+}\n+\n \n fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n             // TODO: type-params\n             cx.items.insert(fid, i);\n-            auto llty = node_type(cx, ann);\n-            let str s = cx.names.next(\"_rust_fn\") + \".\" + name;\n-            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llty);\n-            cx.item_ids.insert(fid, llfn);\n+            if (! cx.obj_methods.contains_key(fid)) {\n+                decl_fn_and_pair(cx, \"fn\", name, ann, fid);\n+            }\n         }\n \n         case (ast.item_obj(?name, ?ob, _, ?oid, ?ann)) {\n             // TODO: type-params\n             cx.items.insert(oid, i);\n-            auto llty = node_type(cx, ann);\n-            let str s = cx.names.next(\"_rust_obj_ctor\") + \".\" + name;\n-            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llty);\n-            cx.item_ids.insert(oid, llfn);\n+            decl_fn_and_pair(cx, \"obj_ctor\", name, ann, oid);\n+            for (@ast.method m in ob.methods) {\n+                cx.obj_methods.insert(m.node.id, ());\n+            }\n         }\n \n         case (ast.item_const(?name, _, _, ?cid, _)) {\n@@ -2963,6 +3002,36 @@ fn collect_items(@crate_ctxt cx, @ast.crate crate) {\n     fold.fold_crate[@crate_ctxt](cx, fld, crate);\n }\n \n+fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+\n+    alt (i.node) {\n+\n+        case (ast.item_tag(_, ?variants, _, _)) {\n+            for (ast.variant variant in variants) {\n+                if (_vec.len[ast.variant_arg](variant.args) != 0u) {\n+                    decl_fn_and_pair(cx, \"tag\", variant.name,\n+                                     variant.ann, variant.id);\n+                }\n+            }\n+        }\n+\n+        case (_) { /* fall through */ }\n+    }\n+    ret cx;\n+}\n+\n+fn collect_tag_ctors(@crate_ctxt cx, @ast.crate crate) {\n+\n+    let fold.ast_fold[@crate_ctxt] fld =\n+        fold.new_identity_fold[@crate_ctxt]();\n+\n+    fld = @rec( update_env_for_item = bind collect_tag_ctor(_,_)\n+                with *fld );\n+\n+    fold.fold_crate[@crate_ctxt](cx, fld, crate);\n+}\n+\n+\n // The tag type resolution pass, which determines all the LLVM types that\n // correspond to each tag type in the crate.\n \n@@ -3048,6 +3117,9 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                                                        _str.buf(\"tag\"));\n                         llvm.LLVMSetInitializer(gvar, val);\n                         llvm.LLVMSetGlobalConstant(gvar, True);\n+                        llvm.LLVMSetLinkage(gvar,\n+                                            lib.llvm.LLVMPrivateLinkage\n+                                            as llvm.Linkage);\n                         cx.item_ids.insert(variant_info._0, gvar);\n                     }\n                     case (n_ary) {\n@@ -3281,6 +3353,8 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    tags = new_def_hash[@tag_info](),\n+                   fn_pairs = new_def_hash[ValueRef](),\n+                   obj_methods = new_def_hash[()](),\n                    tydescs = tydescs,\n                    obj_fields = obj_fields,\n                    glues = glues,\n@@ -3291,6 +3365,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n \n     collect_items(cx, crate);\n     resolve_tag_types(cx, crate);\n+    collect_tag_ctors(cx, crate);\n     trans_constants(cx, crate);\n \n     trans_mod(cx, crate.node.module);"}]}