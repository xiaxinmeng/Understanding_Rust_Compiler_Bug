{"sha": "e7738ca38b78239d6971af2d3c782bbb88f9a563", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NzM4Y2EzOGI3ODIzOWQ2OTcxYWYyZDNjNzgyYmJiODhmOWE1NjM=", "commit": {"author": {"name": "Ted Horst", "email": "ted.horst@earthlink.net", "date": "2012-02-04T01:46:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-04T04:49:13Z"}, "message": "add mandelbrot image generator from shootout", "tree": {"sha": "46f219a1448ea7a183348cd84f159afba8b9491f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46f219a1448ea7a183348cd84f159afba8b9491f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7738ca38b78239d6971af2d3c782bbb88f9a563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7738ca38b78239d6971af2d3c782bbb88f9a563", "html_url": "https://github.com/rust-lang/rust/commit/e7738ca38b78239d6971af2d3c782bbb88f9a563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7738ca38b78239d6971af2d3c782bbb88f9a563/comments", "author": {"login": "tedhorst", "id": 113629, "node_id": "MDQ6VXNlcjExMzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/113629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedhorst", "html_url": "https://github.com/tedhorst", "followers_url": "https://api.github.com/users/tedhorst/followers", "following_url": "https://api.github.com/users/tedhorst/following{/other_user}", "gists_url": "https://api.github.com/users/tedhorst/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedhorst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedhorst/subscriptions", "organizations_url": "https://api.github.com/users/tedhorst/orgs", "repos_url": "https://api.github.com/users/tedhorst/repos", "events_url": "https://api.github.com/users/tedhorst/events{/privacy}", "received_events_url": "https://api.github.com/users/tedhorst/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc624bc08df5cbb2a507231fe2c91cc56647ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc624bc08df5cbb2a507231fe2c91cc56647ac0", "html_url": "https://github.com/rust-lang/rust/commit/8fc624bc08df5cbb2a507231fe2c91cc56647ac0"}], "stats": {"total": 143, "additions": 143, "deletions": 0}, "files": [{"sha": "2fab8685c2cc009360892d3e07cf292668971360", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/e7738ca38b78239d6971af2d3c782bbb88f9a563/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7738ca38b78239d6971af2d3c782bbb88f9a563/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=e7738ca38b78239d6971af2d3c782bbb88f9a563", "patch": "@@ -0,0 +1,143 @@\n+//  based on:\n+//  http://shootout.alioth.debian.org/u64q/program.php?test=mandelbrot&lang=python3&id=2\n+//\n+//  takes 2 optional numeric args: square image size and yield frequency\n+//  in the shootout, they use 16000 as image size\n+//  yield frequency doesn't seem to have much effect\n+//\n+//  writes pbm image to stdout\n+\n+use std;\n+import std::io::writer_util;\n+\n+type cmplx = {re: f64, im: f64};\n+type line = {i: uint, b: [u8]};\n+\n+impl arith for cmplx {\n+\tfn *(x: cmplx) -> cmplx {\n+\t\t{re: self.re*x.re - self.im*x.im, im: self.re*x.im + self.im*x.re}\n+\t}\n+\n+\tfn +(x: cmplx) -> cmplx {\n+\t\t{re: self.re + x.re, im: self.im + x.im}\n+\t}\n+}\n+\n+pure fn cabs(x: cmplx) -> f64\n+{\n+\tx.re*x.re + x.im*x.im\n+}\n+\n+fn mb(x: cmplx) -> bool\n+{\n+\tlet z = {re: 0., im: 0.};\n+\tlet i = 0;\n+\tlet in = true;\n+\twhile i < 50 {\n+\t\tz = z*z + x;\n+\t\tif cabs(z) >= 4. {\n+\t\t\tin = false;\n+\t\t\tbreak;\n+\t\t}\n+\t\ti += 1;\n+\t}\n+\tin\n+}\n+\n+fn fillbyte(x: cmplx, incr: f64) -> u8 {\n+\tlet rv = 0_u8;\n+\tlet i = 0_u8;\n+\twhile i < 8_u8 {\n+\t\tlet z = {re: x.re + (i as f64)*incr, im: x.im};\n+\t\tif mb(z) {\n+\t\t\trv += 1_u8 << (7_u8 - i);\n+\t\t}\n+\t\ti += 1_u8;\n+\t}\n+\trv\n+}\n+\n+fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n+{\n+\tlet crv = [];\n+\tlet incr = 2./(size as f64);\n+\tlet y = incr*(i as f64) - 1.;\n+\tlet xincr = 8.*incr;\n+\tuint::range(0_u, size/8_u) {\n+\t\t|j|\n+\t\tlet x = {re: xincr*(j as f64) - 1.5, im: y};\n+\t\tcrv += [fillbyte(x, incr)];\n+\t};\n+\tcomm::send(ch, {i:i, b:crv});\n+}\n+\n+fn writer(writech: comm::chan<comm::chan<line>>, size: uint)\n+{\n+\tlet p: comm::port<line> = comm::port();\n+\tlet ch = comm::chan(p);\n+\tcomm::send(writech, ch);\n+\tlet cout = std::io::stdout();\n+\tcout.write_line(\"P4\");\n+\tcout.write_line(#fmt(\"%u %u\", size, size));\n+\tlet lines = std::map::new_uint_hash();\n+\tlet done = 0_u;\n+\tlet i = 0_u;\n+\twhile i < size {\n+\t\tlet aline = comm::recv(p);\n+\t\tif aline.i == done {\n+\t\t\t#debug(\"W %u\", aline.i);\n+\t\t\tcout.write(aline.b);\n+\t\t\tdone += 1_u;\n+\t\t\tlet prev = done;\n+\t\t\twhile prev <= i {\n+\t\t\t\tif lines.contains_key(prev) {\n+\t\t\t\t\t#debug(\"WS %u\", prev);\n+\t\t\t\t\tcout.write(lines.get(prev));\n+\t\t\t\t\tdone += 1_u;\n+\t\t\t\t\tlines.remove(prev);\n+\t\t\t\t\tprev += 1_u;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\t\n+\t\t}\n+\t\telse {\n+\t\t\t#debug(\"S %u\", aline.i);\n+\t\t\tlines.insert(aline.i, aline.b);\n+\t\t};\n+\t\ti += 1_u;\n+\t}\n+}\n+\n+fn main(argv: [str])\n+{\n+\tlet size = if vec::len(argv) < 2_u {\n+\t\t80u\n+\t}\n+\telse {\n+\t\tuint::from_str(argv[1])\n+\t};\n+\tlet yieldevery = if vec::len(argv) < 3_u {\n+\t\t10_u\n+\t}\n+\telse {\n+\t\tuint::from_str(argv[2])\n+\t};\n+\tlet writep = comm::port();\n+\tlet writech = comm::chan(writep);\n+\ttask::spawn {\n+\t\t|| writer(writech, size);\n+\t};\n+\tlet ch = comm::recv(writep);\n+\tuint::range(0_u, size) {\n+\t\t|j| task::spawn {\n+\t\t\t|| chanmb(j, size, ch);\n+\t\t};\n+\t\tif j % yieldevery == 0_u {\n+\t\t\t#debug(\"Y %u\", j);\n+\t\t\ttask::yield();\n+\t\t};\n+\t};\n+}"}]}