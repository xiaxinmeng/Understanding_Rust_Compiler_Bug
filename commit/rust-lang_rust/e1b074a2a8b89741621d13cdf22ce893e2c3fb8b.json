{"sha": "e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "node_id": "C_kwDOAAsO6NoAKGUxYjA3NGEyYThiODk3NDE2MjFkMTNjZGYyMmNlODkzZTJjM2ZiOGI", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2022-04-24T14:44:09Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2022-04-25T07:14:44Z"}, "message": "Recover most `impl Trait` and `dyn Trait` lifetime bound suggestions under NLL", "tree": {"sha": "bcdbf307a1edc972f6916cf123d4a59bca174024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcdbf307a1edc972f6916cf123d4a59bca174024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "html_url": "https://github.com/rust-lang/rust/commit/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fedbe5dabc815bd710217221bfebad1ff9f37a43", "url": "https://api.github.com/repos/rust-lang/rust/commits/fedbe5dabc815bd710217221bfebad1ff9f37a43", "html_url": "https://github.com/rust-lang/rust/commit/fedbe5dabc815bd710217221bfebad1ff9f37a43"}], "stats": {"total": 392, "additions": 244, "deletions": 148}, "files": [{"sha": "b5ee4a5edce7d6e3ef60a36a91a8124699c137ac", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 42, "deletions": 77, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -1,17 +1,17 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::{\n-    error_reporting::nice_region_error::NiceRegionError,\n-    error_reporting::unexpected_hidden_region_diagnostic, NllRegionVariableOrigin,\n-    RelateParamBound,\n+    error_reporting::nice_region_error::{self, find_param_with_region, NiceRegionError},\n+    error_reporting::unexpected_hidden_region_diagnostic,\n+    NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n-use rustc_middle::ty::subst::{InternalSubsts, Subst};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::{kw, sym};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n \n use crate::borrowck_errors;\n \n@@ -651,82 +651,47 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         fr_name: RegionName,\n         outlived_fr: RegionVid,\n     ) {\n-        if let (Some(f), Some(ty::ReStatic)) =\n-            (self.to_error_region(fr), self.to_error_region(outlived_fr).as_deref())\n+        if let (Some(f), Some(outlived_f)) =\n+            (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some(&ty::Opaque(did, substs)) = self\n+            if *outlived_f != ty::ReStatic {\n+                return;\n+            }\n+\n+            let fn_returns = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n-                .map(|r| r.def_id)\n-                .and_then(|id| self.infcx.tcx.return_type_impl_trait(id))\n-                .map(|(ty, _)| ty.kind())\n-            {\n-                // Check whether or not the impl trait return type is intended to capture\n-                // data with the static lifetime.\n-                //\n-                // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n-                let has_static_predicate = {\n-                    let bounds = self.infcx.tcx.explicit_item_bounds(did);\n-\n-                    let mut found = false;\n-                    for (bound, _) in bounds {\n-                        if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            bound.kind().skip_binder()\n-                        {\n-                            let r = r.subst(self.infcx.tcx, substs);\n-                            if r.is_static() {\n-                                found = true;\n-                                break;\n-                            } else {\n-                                // If there's already a lifetime bound, don't\n-                                // suggest anything.\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    found\n-                };\n+                .map(|r| self.infcx.tcx.return_type_impl_or_dyn_traits(r.def_id))\n+                .unwrap_or_default();\n \n-                debug!(\n-                    \"add_static_impl_trait_suggestion: has_static_predicate={:?}\",\n-                    has_static_predicate\n-                );\n-                let static_str = kw::StaticLifetime;\n-                // If there is a static predicate, then the only sensible suggestion is to replace\n-                // fr with `'static`.\n-                if has_static_predicate {\n-                    diag.help(&format!(\"consider replacing `{fr_name}` with `{static_str}`\"));\n-                } else {\n-                    // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = self.infcx.tcx.def_span(did);\n-                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestable_fr_name = if fr_name.was_named() {\n-                            fr_name.to_string()\n-                        } else {\n-                            \"'_\".to_string()\n-                        };\n-                        let span = if snippet.ends_with(';') {\n-                            // `type X = impl Trait;`\n-                            span.with_hi(span.hi() - BytePos(1))\n-                        } else {\n-                            span\n-                        };\n-                        let suggestion = format!(\" + {suggestable_fr_name}\");\n-                        let span = span.shrink_to_hi();\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"to allow this `impl Trait` to capture borrowed data with lifetime \\\n-                                 `{fr_name}`, add `{suggestable_fr_name}` as a bound\",\n-                            ),\n-                            suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n+            if fn_returns.is_empty() {\n+                return;\n             }\n+\n+            let param = if let Some(param) = find_param_with_region(self.infcx.tcx, f, outlived_f) {\n+                param\n+            } else {\n+                return;\n+            };\n+\n+            let lifetime = if f.has_name() { fr_name.to_string() } else { \"'_\".to_string() };\n+\n+            let arg = match param.param.pat.simple_ident() {\n+                Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                None => \"the argument\".to_string(),\n+            };\n+            let captures = format!(\"captures data from {}\", arg);\n+\n+            return nice_region_error::suggest_new_region_bound(\n+                self.infcx.tcx,\n+                diag,\n+                fn_returns,\n+                lifetime,\n+                Some(arg),\n+                captures,\n+                Some((param.param_ty_span, param.param_ty.to_string())),\n+            );\n         }\n     }\n }"}, {"sha": "79f852d8a95e739e0ed1c10a4c11ff4c5b2cf4f0", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -15,6 +15,7 @@ mod trait_impl_difference;\n mod util;\n \n pub use static_impl_trait::suggest_new_region_bound;\n+pub use util::find_param_with_region;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {"}, {"sha": "7d3ed2ed38a307b6ff8c1b01b7cd40c5f88a2ebc", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -2,14 +2,15 @@\n //! anonymous regions.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n+use crate::infer::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::{self, Binder, DefIdTree, Region, Ty, TypeFoldable};\n use rustc_span::Span;\n \n /// Information about the anonymous region we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousParamInfo<'tcx> {\n+pub struct AnonymousParamInfo<'tcx> {\n     /// The parameter corresponding to the anonymous region.\n     pub param: &'tcx hir::Param<'tcx>,\n     /// The type corresponding to the anonymous region parameter.\n@@ -22,76 +23,83 @@ pub(super) struct AnonymousParamInfo<'tcx> {\n     pub is_first: bool,\n }\n \n+// This method walks the Type of the function body parameters using\n+// `fold_regions()` function and returns the\n+// &hir::Param of the function parameter corresponding to the anonymous\n+// region and the Ty corresponding to the named region.\n+// Currently only the case where the function declaration consists of\n+// one named region and one anonymous region is handled.\n+// Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n+// Here, we would return the hir::Param for y, we return the type &'a\n+// i32, which is the type of y but with the anonymous region replaced\n+// with 'a, the corresponding bound region and is_first which is true if\n+// the hir::Param is the first parameter in the function declaration.\n+pub fn find_param_with_region<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    anon_region: Region<'tcx>,\n+    replace_region: Region<'tcx>,\n+) -> Option<AnonymousParamInfo<'tcx>> {\n+    let (id, bound_region) = match *anon_region {\n+        ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n+        ty::ReEarlyBound(ebr) => {\n+            (tcx.parent(ebr.def_id).unwrap(), ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name))\n+        }\n+        _ => return None, // not a free region\n+    };\n+\n+    let hir = &tcx.hir();\n+    let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n+    let body_id = hir.maybe_body_owned_by(hir_id)?;\n+    let body = hir.body(body_id);\n+    let owner_id = hir.body_owner(body_id);\n+    let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n+    let poly_fn_sig = tcx.fn_sig(id);\n+    let fn_sig = tcx.liberate_late_bound_regions(id, poly_fn_sig);\n+    body.params\n+        .iter()\n+        .take(if fn_sig.c_variadic {\n+            fn_sig.inputs().len()\n+        } else {\n+            assert_eq!(fn_sig.inputs().len(), body.params.len());\n+            body.params.len()\n+        })\n+        .enumerate()\n+        .find_map(|(index, param)| {\n+            // May return None; sometimes the tables are not yet populated.\n+            let ty = fn_sig.inputs()[index];\n+            let mut found_anon_region = false;\n+            let new_param_ty = tcx.fold_regions(ty, &mut false, |r, _| {\n+                if r == anon_region {\n+                    found_anon_region = true;\n+                    replace_region\n+                } else {\n+                    r\n+                }\n+            });\n+            if found_anon_region {\n+                let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                let param_ty_span = hir.span(ty_hir_id);\n+                let is_first = index == 0;\n+                Some(AnonymousParamInfo {\n+                    param,\n+                    param_ty: new_param_ty,\n+                    param_ty_span,\n+                    bound_region,\n+                    is_first,\n+                })\n+            } else {\n+                None\n+            }\n+        })\n+}\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body parameters using\n-    // `fold_regions()` function and returns the\n-    // &hir::Param of the function parameter corresponding to the anonymous\n-    // region and the Ty corresponding to the named region.\n-    // Currently only the case where the function declaration consists of\n-    // one named region and one anonymous region is handled.\n-    // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Param for y, we return the type &'a\n-    // i32, which is the type of y but with the anonymous region replaced\n-    // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Param is the first parameter in the function declaration.\n     pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n     ) -> Option<AnonymousParamInfo<'_>> {\n-        let (id, bound_region) = match *anon_region {\n-            ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n-            ty::ReEarlyBound(ebr) => (\n-                self.tcx().parent(ebr.def_id).unwrap(),\n-                ty::BoundRegionKind::BrNamed(ebr.def_id, ebr.name),\n-            ),\n-            _ => return None, // not a free region\n-        };\n-\n-        let hir = &self.tcx().hir();\n-        let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n-        let body_id = hir.maybe_body_owned_by(hir_id)?;\n-        let body = hir.body(body_id);\n-        let owner_id = hir.body_owner(body_id);\n-        let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n-        let poly_fn_sig = self.tcx().fn_sig(id);\n-        let fn_sig = self.tcx().liberate_late_bound_regions(id, poly_fn_sig);\n-        body.params\n-            .iter()\n-            .take(if fn_sig.c_variadic {\n-                fn_sig.inputs().len()\n-            } else {\n-                assert_eq!(fn_sig.inputs().len(), body.params.len());\n-                body.params.len()\n-            })\n-            .enumerate()\n-            .find_map(|(index, param)| {\n-                // May return None; sometimes the tables are not yet populated.\n-                let ty = fn_sig.inputs()[index];\n-                let mut found_anon_region = false;\n-                let new_param_ty = self.tcx().fold_regions(ty, &mut false, |r, _| {\n-                    if r == anon_region {\n-                        found_anon_region = true;\n-                        replace_region\n-                    } else {\n-                        r\n-                    }\n-                });\n-                if found_anon_region {\n-                    let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                    let param_ty_span = hir.span(ty_hir_id);\n-                    let is_first = index == 0;\n-                    Some(AnonymousParamInfo {\n-                        param,\n-                        param_ty: new_param_ty,\n-                        param_ty_span,\n-                        bound_region,\n-                        is_first,\n-                    })\n-                } else {\n-                    None\n-                }\n-            })\n+        find_param_with_region(self.tcx(), anon_region, replace_region)\n     }\n \n     // Here, we check for the case where the anonymous region"}, {"sha": "66cffa9e36c0ddcea71577acfe208186ba921fe5", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -24,10 +24,14 @@ LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send\n LL |     x\n    |     ^ returning this value requires that `'b` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, add `'b` as a bound\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n    |                                                                                  ++++\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'b` lifetime bound\n+   |\n+LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a + 'b> {\n+   |                                                                                 ++++\n \n error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:20:5"}, {"sha": "5a190649b63191436cd3db3ab939f774f32e4e34", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -32,15 +32,29 @@ LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               |\n    |               let's call the lifetime of this reference `'1`\n    |\n-   = help: consider replacing `'1` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n+   |                                    ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn elided2(x: &'static i32) -> impl Copy + 'static { x }\n+   |               ~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:11:55\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n    |\n-   = help: consider replacing `'a` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n+   |                                             ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn explicit2<'a>(x: &'static i32) -> impl Copy + 'static { x }\n+   |                     ~~~~~~~~~~~~\n \n error[E0621]: explicit lifetime required in the type of `x`\n   --> $DIR/must_outlive_least_region_or_bound.rs:13:41\n@@ -57,14 +71,30 @@ LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n    |               -                                       ^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n    |               |\n    |               let's call the lifetime of this reference `'1`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ++++\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ++++\n \n error: lifetime may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:29:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n    |\n-   = help: consider replacing `'a` with `'static`\n+help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n+   |                                                           ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x }\n+   |                      ~~~~~~~~~~~~\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/must_outlive_least_region_or_bound.rs:34:5"}, {"sha": "9d9f32a97c065a0f29a86308087bfae20c36e374", "filename": "src/test/ui/issues/issue-16922.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -5,6 +5,11 @@ LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n    |                       - let's call the lifetime of this reference `'1`\n LL |     Box::new(value) as Box<dyn Any>\n    |     ^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `value`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n+   |                                          ++++\n \n error: aborting due to previous error\n "}, {"sha": "8d02ef71d1bc6c3636e906620b1debf76b8b0d06", "filename": "src/test/ui/nll/mir_check_cast_unsize.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -5,6 +5,11 @@ LL | fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n    |        -- lifetime `'a` defined here\n LL |     x\n    |     ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'a` lifetime bound\n+   |\n+LL | fn bar<'a>(x: &'a u32) -> &'static dyn Debug + 'a {\n+   |                                              ++++\n \n error: aborting due to previous error\n "}, {"sha": "43695a7511d275b711eee07a87e59b51086c17c1", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -6,6 +6,11 @@ LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n ...\n LL |     ss.r\n    |     ^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `ss`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n+   |                                                   ++++\n \n error[E0507]: cannot move out of `ss.r` which is behind a mutable reference\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5"}, {"sha": "724b06ce8b168563f110d8b80f4f4edd4d90eebb", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -5,6 +5,15 @@ LL | fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n    |         - let's call the lifetime of this reference `'1`\n LL |     let x: Box<dyn Foo + 'static> = Box::new(v);\n    |            ^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn a(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn a(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ~~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:19:5\n@@ -13,6 +22,15 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n    |         - let's call the lifetime of this reference `'1`\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn b(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                                 ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn b(v: &'static [u8]) -> Box<dyn Foo + 'static> {\n+   |         ~~~~~~~~~~~~~\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:27:5\n@@ -22,6 +40,11 @@ LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n ...\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `v`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                               ++++\n \n error: lifetime may not live long enough\n   --> $DIR/region-object-lifetime-in-coercion.rs:33:5"}, {"sha": "473c99b672fb692125395e117e4bcd0241a2385f", "filename": "src/test/ui/regions/regions-close-object-into-object-2.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -5,6 +5,15 @@ LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'static> {\n    |      -- lifetime `'a` defined here\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn g<'a, T: 'static>(v: Box<dyn A<T> + 'a>) -> Box<dyn X + 'a> {\n+   |                                                            ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn g<'a, T: 'static>(v: Box<(dyn A<T> + 'static)>) -> Box<dyn X + 'static> {\n+   |                         ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0515]: cannot return value referencing local data `*v`\n   --> $DIR/regions-close-object-into-object-2.rs:13:5"}, {"sha": "05ddc09b2d0b7a31a37969a18b48a571e671075f", "filename": "src/test/ui/regions/regions-close-object-into-object-4.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -29,6 +29,15 @@ LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'static> {\n    |      -- lifetime `'a` defined here\n LL |     Box::new(B(&*v)) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `v`\n+   |\n+LL | fn i<'a, T, U>(v: Box<dyn A<U>+'a>) -> Box<dyn X + 'a> {\n+   |                                                    ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn i<'a, T, U>(v: Box<(dyn A<U> + 'static)>) -> Box<dyn X + 'static> {\n+   |                   ~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error[E0515]: cannot return value referencing local data `*v`\n   --> $DIR/regions-close-object-into-object-4.rs:13:5"}, {"sha": "ce4d2d4d111c3dc7d4c2745dfa53e155119e6a5b", "filename": "src/test/ui/regions/regions-proc-bound-capture.nll.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-proc-bound-capture.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -6,6 +6,15 @@ LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n LL |     // This is illegal, because the region bound on `proc` is 'static.\n LL |     Box::new(move || { *x })\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: consider changing the trait object's explicit `'static` bound to the lifetime of argument `x`\n+   |\n+LL | fn static_proc(x: &isize) -> Box<dyn FnMut() -> (isize) + '_> {\n+   |                                                           ~~\n+help: alternatively, add an explicit `'static` bound to this reference\n+   |\n+LL | fn static_proc(x: &'static isize) -> Box<dyn FnMut() -> (isize) + 'static> {\n+   |                   ~~~~~~~~~~~~~~\n \n error: aborting due to previous error\n "}, {"sha": "6c65e4f0175428e10640dac31ffcac1d78bb3785", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.nll.stderr", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -9,10 +9,14 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'1` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n    |                                                          ++++\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> {\n+   |                                                        ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:39:9\n@@ -24,6 +28,11 @@ LL | |             current: None,\n LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n+   |                                                        ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:50:9\n@@ -35,6 +44,11 @@ LL | |             current: None,\n LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n+   |                                                               ++++\n \n error: lifetime may not live long enough\n   --> $DIR/trait-object-nested-in-impl-trait.rs:61:9\n@@ -47,10 +61,14 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n    |\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n    |                                                                 ++++\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> {\n+   |                                                               ++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "0ffb77cf02164355c14f61d30aeeefcf98b4d8c7", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1b074a2a8b89741621d13cdf22ce893e2c3fb8b/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=e1b074a2a8b89741621d13cdf22ce893e2c3fb8b", "patch": "@@ -6,6 +6,11 @@ LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n    |     ^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n+   |\n+help: to declare that the trait object captures data from argument `items`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n+   |                                                   ++++\n \n error: aborting due to previous error\n "}]}