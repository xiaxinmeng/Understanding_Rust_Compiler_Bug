{"sha": "39715ce26f03eef6f370afe16b7727c606026024", "node_id": "C_kwDOAAsO6NoAKDM5NzE1Y2UyNmYwM2VlZjZmMzcwYWZlMTZiNzcyN2M2MDYwMjYwMjQ", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-20T19:25:39Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-04-20T19:25:39Z"}, "message": "Add RA_UNSTABLE_SYSROOT_HACK", "tree": {"sha": "f29af6d8067fd94a29ec2b4e81d79fe7d0365e51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f29af6d8067fd94a29ec2b4e81d79fe7d0365e51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39715ce26f03eef6f370afe16b7727c606026024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39715ce26f03eef6f370afe16b7727c606026024", "html_url": "https://github.com/rust-lang/rust/commit/39715ce26f03eef6f370afe16b7727c606026024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39715ce26f03eef6f370afe16b7727c606026024/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b54e3976213f2e5930100a7bf8ee31c2d3ac599", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b54e3976213f2e5930100a7bf8ee31c2d3ac599", "html_url": "https://github.com/rust-lang/rust/commit/9b54e3976213f2e5930100a7bf8ee31c2d3ac599"}], "stats": {"total": 212, "additions": 174, "deletions": 38}, "files": [{"sha": "80da41222a150ff03e6978b061996186630b55e1", "filename": "crates/base-db/src/input.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase-db%2Fsrc%2Finput.rs?ref=39715ce26f03eef6f370afe16b7727c606026024", "patch": "@@ -386,24 +386,64 @@ impl CrateGraph {\n         self.arena.alloc(data)\n     }\n \n+    /// Remove the crate from crate graph. If any crates depend on this crate, the dependency would be replaced\n+    /// with the second input.\n+    pub fn remove_and_replace(\n+        &mut self,\n+        id: CrateId,\n+        replace_with: CrateId,\n+    ) -> Result<(), CyclicDependenciesError> {\n+        for (x, data) in self.arena.iter() {\n+            if x == id {\n+                continue;\n+            }\n+            for edge in &data.dependencies {\n+                if edge.crate_id == id {\n+                    self.check_cycle_after_dependency(edge.crate_id, replace_with)?;\n+                }\n+            }\n+        }\n+        // if everything was ok, start to replace\n+        for (x, data) in self.arena.iter_mut() {\n+            if x == id {\n+                continue;\n+            }\n+            for edge in &mut data.dependencies {\n+                if edge.crate_id == id {\n+                    edge.crate_id = replace_with;\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     pub fn add_dep(\n         &mut self,\n         from: CrateId,\n         dep: Dependency,\n     ) -> Result<(), CyclicDependenciesError> {\n         let _p = profile::span(\"add_dep\");\n \n-        // Check if adding a dep from `from` to `to` creates a cycle. To figure\n-        // that out, look for a  path in the *opposite* direction, from `to` to\n-        // `from`.\n-        if let Some(path) = self.find_path(&mut FxHashSet::default(), dep.crate_id, from) {\n+        self.check_cycle_after_dependency(from, dep.crate_id)?;\n+\n+        self.arena[from].add_dep(dep);\n+        Ok(())\n+    }\n+\n+    /// Check if adding a dep from `from` to `to` creates a cycle. To figure\n+    /// that out, look for a  path in the *opposite* direction, from `to` to\n+    /// `from`.\n+    fn check_cycle_after_dependency(\n+        &self,\n+        from: CrateId,\n+        to: CrateId,\n+    ) -> Result<(), CyclicDependenciesError> {\n+        if let Some(path) = self.find_path(&mut FxHashSet::default(), to, from) {\n             let path = path.into_iter().map(|it| (it, self[it].display_name.clone())).collect();\n             let err = CyclicDependenciesError { path };\n-            assert!(err.from().0 == from && err.to().0 == dep.crate_id);\n+            assert!(err.from().0 == from && err.to().0 == to);\n             return Err(err);\n         }\n-\n-        self.arena[from].add_dep(dep);\n         Ok(())\n     }\n "}, {"sha": "e3a2de927c9856822324a4c12d06214fba195509", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=39715ce26f03eef6f370afe16b7727c606026024", "patch": "@@ -12,13 +12,15 @@ use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n \n-use crate::{utf8_stdout, ManifestPath};\n+use crate::{utf8_stdout, CargoConfig, CargoWorkspace, ManifestPath};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Sysroot {\n     root: AbsPathBuf,\n     src_root: AbsPathBuf,\n     crates: Arena<SysrootCrateData>,\n+    /// Stores the result of `cargo metadata` of the `RA_UNSTABLE_SYSROOT_HACK` workspace.\n+    pub hack_cargo_workspace: Option<CargoWorkspace>,\n }\n \n pub(crate) type SysrootCrate = Idx<SysrootCrateData>;\n@@ -125,9 +127,31 @@ impl Sysroot {\n         Ok(Sysroot::load(sysroot_dir, sysroot_src_dir))\n     }\n \n-    pub fn load(sysroot_dir: AbsPathBuf, sysroot_src_dir: AbsPathBuf) -> Sysroot {\n-        let mut sysroot =\n-            Sysroot { root: sysroot_dir, src_root: sysroot_src_dir, crates: Arena::default() };\n+    pub fn load(sysroot_dir: AbsPathBuf, mut sysroot_src_dir: AbsPathBuf) -> Sysroot {\n+        // FIXME: Remove this `hack_cargo_workspace` field completely once we support sysroot dependencies\n+        let hack_cargo_workspace = if let Ok(path) = std::env::var(\"RA_UNSTABLE_SYSROOT_HACK\") {\n+            let cargo_toml = ManifestPath::try_from(\n+                AbsPathBuf::try_from(&*format!(\"{path}/Cargo.toml\")).unwrap(),\n+            )\n+            .unwrap();\n+            sysroot_src_dir = AbsPathBuf::try_from(&*path).unwrap().join(\"library\");\n+            CargoWorkspace::fetch_metadata(\n+                &cargo_toml,\n+                &AbsPathBuf::try_from(\"/\").unwrap(),\n+                &CargoConfig::default(),\n+                &|_| (),\n+            )\n+            .map(CargoWorkspace::new)\n+            .ok()\n+        } else {\n+            None\n+        };\n+        let mut sysroot = Sysroot {\n+            root: sysroot_dir,\n+            src_root: sysroot_src_dir,\n+            crates: Arena::default(),\n+            hack_cargo_workspace,\n+        };\n \n         for path in SYSROOT_CRATES.trim().lines() {\n             let name = path.split('/').last().unwrap();"}, {"sha": "d69ff98f5d6d4ebe45b315a172f87df81a88dec6", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 99, "deletions": 27, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39715ce26f03eef6f370afe16b7727c606026024/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=39715ce26f03eef6f370afe16b7727c606026024", "patch": "@@ -622,6 +622,7 @@ impl ProjectWorkspace {\n                 sysroot.as_ref().ok(),\n                 rustc_cfg.clone(),\n                 cfg_overrides,\n+                None,\n                 build_scripts,\n                 match target_layout.as_ref() {\n                     Ok(it) => Ok(Arc::from(it.as_str())),\n@@ -821,6 +822,8 @@ fn cargo_to_crate_graph(\n     sysroot: Option<&Sysroot>,\n     rustc_cfg: Vec<CfgFlag>,\n     override_cfg: &CfgOverrides,\n+    // Don't compute cfg and use this if present\n+    forced_cfg: Option<CfgOptions>,\n     build_scripts: &WorkspaceBuildScripts,\n     target_layout: TargetLayoutLoadResult,\n     channel: Option<ReleaseChannel>,\n@@ -858,7 +861,7 @@ fn cargo_to_crate_graph(\n     for pkg in cargo.packages() {\n         has_private |= cargo[pkg].metadata.rustc_private;\n \n-        let cfg_options = {\n+        let cfg_options = forced_cfg.clone().unwrap_or_else(|| {\n             let mut cfg_options = cfg_options.clone();\n \n             // Add test cfg for local crates\n@@ -882,7 +885,7 @@ fn cargo_to_crate_graph(\n                 cfg_options.apply_diff(overrides.clone());\n             };\n             cfg_options\n-        };\n+        });\n \n         let mut lib_tgt = None;\n         for &tgt in cargo[pkg].targets.iter() {\n@@ -1280,31 +1283,43 @@ fn sysroot_to_crate_graph(\n ) -> (SysrootPublicDeps, Option<CrateId>) {\n     let _p = profile::span(\"sysroot_to_crate_graph\");\n     let mut cfg_options = CfgOptions::default();\n-    cfg_options.extend(rustc_cfg);\n-    let sysroot_crates: FxHashMap<SysrootCrate, CrateId> = sysroot\n-        .crates()\n-        .filter_map(|krate| {\n-            let file_id = load(&sysroot[krate].root)?;\n-\n-            let env = Env::default();\n-            let display_name = CrateDisplayName::from_canonical_name(sysroot[krate].name.clone());\n-            let crate_id = crate_graph.add_crate_root(\n-                file_id,\n-                Edition::CURRENT,\n-                Some(display_name),\n-                None,\n-                cfg_options.clone(),\n-                None,\n-                env,\n-                false,\n-                CrateOrigin::Lang(LangCrateOrigin::from(&*sysroot[krate].name)),\n-                target_layout.clone(),\n-                channel,\n-            );\n-            Some((krate, crate_id))\n-        })\n-        .collect();\n-\n+    cfg_options.extend(rustc_cfg.clone());\n+    let sysroot_crates: FxHashMap<SysrootCrate, CrateId> = match &sysroot.hack_cargo_workspace {\n+        Some(cargo) => handle_hack_cargo_workspace(\n+            load,\n+            cargo,\n+            rustc_cfg,\n+            cfg_options,\n+            target_layout,\n+            channel,\n+            crate_graph,\n+            sysroot,\n+        ),\n+        None => sysroot\n+            .crates()\n+            .filter_map(|krate| {\n+                let file_id = load(&sysroot[krate].root)?;\n+\n+                let env = Env::default();\n+                let display_name =\n+                    CrateDisplayName::from_canonical_name(sysroot[krate].name.clone());\n+                let crate_id = crate_graph.add_crate_root(\n+                    file_id,\n+                    Edition::CURRENT,\n+                    Some(display_name),\n+                    None,\n+                    cfg_options.clone(),\n+                    None,\n+                    env,\n+                    false,\n+                    CrateOrigin::Lang(LangCrateOrigin::from(&*sysroot[krate].name)),\n+                    target_layout.clone(),\n+                    channel,\n+                );\n+                Some((krate, crate_id))\n+            })\n+            .collect(),\n+    };\n     for from in sysroot.crates() {\n         for &to in sysroot[from].deps.iter() {\n             let name = CrateName::new(&sysroot[to].name).unwrap();\n@@ -1325,6 +1340,63 @@ fn sysroot_to_crate_graph(\n     (public_deps, libproc_macro)\n }\n \n+fn handle_hack_cargo_workspace(\n+    load: &mut dyn FnMut(&AbsPath) -> Option<FileId>,\n+    cargo: &CargoWorkspace,\n+    rustc_cfg: Vec<CfgFlag>,\n+    cfg_options: CfgOptions,\n+    target_layout: Result<Arc<str>, Arc<str>>,\n+    channel: Option<ReleaseChannel>,\n+    crate_graph: &mut CrateGraph,\n+    sysroot: &Sysroot,\n+) -> FxHashMap<SysrootCrate, CrateId> {\n+    let (cg, mut pm) = cargo_to_crate_graph(\n+        load,\n+        None,\n+        cargo,\n+        None,\n+        rustc_cfg,\n+        &CfgOverrides::default(),\n+        Some(cfg_options),\n+        &WorkspaceBuildScripts::default(),\n+        target_layout,\n+        channel,\n+    );\n+    crate_graph.extend(cg, &mut pm);\n+    for crate_name in [\"std\", \"alloc\", \"core\"] {\n+        let original = crate_graph\n+            .iter()\n+            .find(|x| {\n+                crate_graph[*x]\n+                    .display_name\n+                    .as_ref()\n+                    .map(|x| x.canonical_name() == crate_name)\n+                    .unwrap_or(false)\n+            })\n+            .unwrap();\n+        let fake_crate_name = format!(\"rustc-std-workspace-{}\", crate_name);\n+        let fake = crate_graph\n+            .iter()\n+            .find(|x| {\n+                crate_graph[*x]\n+                    .display_name\n+                    .as_ref()\n+                    .map(|x| x.canonical_name() == fake_crate_name)\n+                    .unwrap_or(false)\n+            })\n+            .unwrap();\n+        crate_graph.remove_and_replace(fake, original).unwrap();\n+    }\n+    sysroot\n+        .crates()\n+        .filter_map(|krate| {\n+            let file_id = load(&sysroot[krate].root)?;\n+            let crate_id = crate_graph.crate_id_for_crate_root(file_id)?;\n+            Some((krate, crate_id))\n+        })\n+        .collect()\n+}\n+\n fn add_dep(graph: &mut CrateGraph, from: CrateId, name: CrateName, to: CrateId) {\n     add_dep_inner(graph, from, Dependency::new(name, to))\n }"}]}