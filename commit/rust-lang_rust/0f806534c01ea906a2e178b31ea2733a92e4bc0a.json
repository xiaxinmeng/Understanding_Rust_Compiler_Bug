{"sha": "0f806534c01ea906a2e178b31ea2733a92e4bc0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmODA2NTM0YzAxZWE5MDZhMmUxNzhiMzFlYTI3MzNhOTJlNGJjMGE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-22T21:19:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-22T21:19:24Z"}, "message": "Rollup merge of #71400 - dtolnay:isavailable, r=petrochenkov\n\nproc_macro::is_available()\n\nThis PR adds `proc_macro::is_available() -> bool` to determine whether proc_macro has been made accessible to the currently running program.\n\nThe proc_macro crate is only intended for use inside the implementation of procedural macros. All the functions in the crate panic if invoked from outside of a procedural macro, such as from a build script or unit test or ordinary Rust binary.\n\nUnfortunately those panics made it impossible for libraries that are designed to support both macro and non-macro use cases (e.g. Syn) to be used from binaries that are compiled with panic=abort. In panic=unwind mode we're able to attempt a proc macro call inside catch_unwind and use libproc_macro's result if it succeeds, otherwise fall back to a non-macro alternative implementation. But in panic=abort there was no way to determine which implementation needs to be used.\n\nr? @eddyb\nattn: @petrochenkov @adetaylor\nref: https://github.com/dtolnay/cxx/issues/130", "tree": {"sha": "4e9e25f2d3c3a1d755c7852e9393dc24e4871d82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e9e25f2d3c3a1d755c7852e9393dc24e4871d82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f806534c01ea906a2e178b31ea2733a92e4bc0a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeoLTcCRBK7hj4Ov3rIwAAdHIIAATu5ScAga3Z2rHYLyzqWP1e\nsNZGvzWz+ZXQBJrjElTmJvycRMXHeeu6/Y7bBFAcUnT3w2vw7uBoZU1Xzfymn/TL\nvGlLldciD82QbQs1wpPBKdO+Spiu1MLU6fl8DTXV6sGKF8y0Uo0Mod39IxrBz/I1\nZOPWt4Eut39TKESz+JWRbMufFRCqKZ1S7oGUlcdcfkJrwKnsyi8t93Yi5gny1u2W\nylK6c3R3dYjh/CI34SZBBzsXHk6EnB1WoadDcS3PYDuSOvWNnEMOR9IJ++fr5IeF\nOksRXdS0HDoNPOJmbojsjYkfZOgY35GFj+PXrbYec98PxC1eePfajMIwgQPFgRc=\n=3yQj\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e9e25f2d3c3a1d755c7852e9393dc24e4871d82\nparent 16be619c6aec0db952be61ebb45c63a1ebe4b1a5\nparent 3bd742ff4e61f6752d76a75f53c140170a117554\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587590364 +0200\ncommitter GitHub <noreply@github.com> 1587590364 +0200\n\nRollup merge of #71400 - dtolnay:isavailable, r=petrochenkov\n\nproc_macro::is_available()\n\nThis PR adds `proc_macro::is_available() -> bool` to determine whether proc_macro has been made accessible to the currently running program.\n\nThe proc_macro crate is only intended for use inside the implementation of procedural macros. All the functions in the crate panic if invoked from outside of a procedural macro, such as from a build script or unit test or ordinary Rust binary.\n\nUnfortunately those panics made it impossible for libraries that are designed to support both macro and non-macro use cases (e.g. Syn) to be used from binaries that are compiled with panic=abort. In panic=unwind mode we're able to attempt a proc macro call inside catch_unwind and use libproc_macro's result if it succeeds, otherwise fall back to a non-macro alternative implementation. But in panic=abort there was no way to determine which implementation needs to be used.\n\nr? @eddyb\nattn: @petrochenkov @adetaylor\nref: https://github.com/dtolnay/cxx/issues/130\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f806534c01ea906a2e178b31ea2733a92e4bc0a", "html_url": "https://github.com/rust-lang/rust/commit/0f806534c01ea906a2e178b31ea2733a92e4bc0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f806534c01ea906a2e178b31ea2733a92e4bc0a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16be619c6aec0db952be61ebb45c63a1ebe4b1a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/16be619c6aec0db952be61ebb45c63a1ebe4b1a5", "html_url": "https://github.com/rust-lang/rust/commit/16be619c6aec0db952be61ebb45c63a1ebe4b1a5"}, {"sha": "3bd742ff4e61f6752d76a75f53c140170a117554", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd742ff4e61f6752d76a75f53c140170a117554", "html_url": "https://github.com/rust-lang/rust/commit/3bd742ff4e61f6752d76a75f53c140170a117554"}], "stats": {"total": 56, "additions": 56, "deletions": 0}, "files": [{"sha": "d2222d12623f9b8cd81778e2177cb7e4cc205c6d", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=0f806534c01ea906a2e178b31ea2733a92e4bc0a", "patch": "@@ -290,6 +290,13 @@ impl BridgeState<'_> {\n }\n \n impl Bridge<'_> {\n+    pub(crate) fn is_available() -> bool {\n+        BridgeState::with(|state| match state {\n+            BridgeState::Connected(_) | BridgeState::InUse => true,\n+            BridgeState::NotConnected => false,\n+        })\n+    }\n+\n     fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n         // Hide the default panic output within `proc_macro` expansions.\n         // NB. the server can't do this because it may use a different libstd."}, {"sha": "3cbe852de7b5a4722d6c0d7a91dbf972d613a9e5", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=0f806534c01ea906a2e178b31ea2733a92e4bc0a", "patch": "@@ -45,6 +45,24 @@ use std::path::PathBuf;\n use std::str::FromStr;\n use std::{error, fmt, iter, mem};\n \n+/// Determines whether proc_macro has been made accessible to the currently\n+/// running program.\n+///\n+/// The proc_macro crate is only intended for use inside the implementation of\n+/// procedural macros. All the functions in this crate panic if invoked from\n+/// outside of a procedural macro, such as from a build script or unit test or\n+/// ordinary Rust binary.\n+///\n+/// With consideration for Rust libraries that are designed to support both\n+/// macro and non-macro use cases, `proc_macro::is_available()` provides a\n+/// non-panicking way to detect whether the infrastructure required to use the\n+/// API of proc_macro is presently available. Returns true if invoked from\n+/// inside of a procedural macro, false if invoked from any other binary.\n+#[unstable(feature = \"proc_macro_is_available\", issue = \"71436\")]\n+pub fn is_available() -> bool {\n+    bridge::Bridge::is_available()\n+}\n+\n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n /// The type provide interfaces for iterating over those token trees and, conversely,"}, {"sha": "0caf186db1d5fac483284bcb1435303ca0560378", "filename": "src/test/ui/proc-macro/auxiliary/is-available.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fis-available.rs?ref=0f806534c01ea906a2e178b31ea2733a92e4bc0a", "patch": "@@ -0,0 +1,14 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{Literal, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn from_inside_proc_macro(_input: TokenStream) -> TokenStream {\n+    proc_macro::is_available().to_string().parse().unwrap()\n+}"}, {"sha": "943d9fe797a6ec80ee30cd587dcb16a8850c6c8a", "filename": "src/test/ui/proc-macro/is-available.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f806534c01ea906a2e178b31ea2733a92e4bc0a/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fis-available.rs?ref=0f806534c01ea906a2e178b31ea2733a92e4bc0a", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(proc_macro_hygiene, proc_macro_is_available)]\n+\n+extern crate proc_macro;\n+\n+// aux-build:is-available.rs\n+extern crate is_available;\n+\n+fn main() {\n+    let a = proc_macro::is_available();\n+    let b = is_available::from_inside_proc_macro!();\n+    let c = proc_macro::is_available();\n+    assert!(!a);\n+    assert!(b);\n+    assert!(!c);\n+}"}]}