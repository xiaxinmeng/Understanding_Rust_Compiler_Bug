{"sha": "140b6cb1bab5bc6f4e3a06db320daba2322e177b", "node_id": "C_kwDOAAsO6NoAKDE0MGI2Y2IxYmFiNWJjNmY0ZTNhMDZkYjMyMGRhYmEyMzIyZTE3N2I", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-06T22:15:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-06T22:15:21Z"}, "message": "Rollup merge of #92607 - petrochenkov:doctrscope2, r=cjgillot\n\nrustc_metadata: Some minor cleanups and optimizations\n\nMostly extracted from https://github.com/rust-lang/rust/pull/88679 (which is otherwise a rustdoc PR).\nr? ``@cjgillot``", "tree": {"sha": "55135125898c15d4b1e68710c960146496b007e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55135125898c15d4b1e68710c960146496b007e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/140b6cb1bab5bc6f4e3a06db320daba2322e177b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh12n5CRBK7hj4Ov3rIwAAlzkIAA95bEYKQ54lQlVVb7QKLc8e\nxXkCrpu2fBDFeqv7O3iRpaEI6lBpawT1QysjMPnv+XJA0n02uztug2wufuWqgb7E\n0FBHzvRvNPyPZj1WKTNbdn6K2JO5u8x3oq+0UGsx1USn8ukXN4xzf+Vrr+FDLenw\neXPNCDP+uzzylR8O0sQX+UemeBqNhUBmrPv/ofZnIhlWnLqOpeqUpkN4E6iO2MyR\nQJObhXEQh4laO6h935NDDdJo7PZbsIfUdGz2Oqlg2wk214NTVVRMO/ATexqBfnKa\nv7xFPbhFckBDhe4i/Eygge3mcF09XTa6VTgc26mcDfr91z+8oPZkIyQrAx/o43s=\n=MtVv\n-----END PGP SIGNATURE-----\n", "payload": "tree 55135125898c15d4b1e68710c960146496b007e5\nparent 0c9cf9a9ea10fdabf4b0866ccb2870bf6fdcc28f\nparent 1b88007af03bc7e15cd82f780f38c13a5dae2363\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641507321 +0100\ncommitter GitHub <noreply@github.com> 1641507321 +0100\n\nRollup merge of #92607 - petrochenkov:doctrscope2, r=cjgillot\n\nrustc_metadata: Some minor cleanups and optimizations\n\nMostly extracted from https://github.com/rust-lang/rust/pull/88679 (which is otherwise a rustdoc PR).\nr? ``@cjgillot``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/140b6cb1bab5bc6f4e3a06db320daba2322e177b", "html_url": "https://github.com/rust-lang/rust/commit/140b6cb1bab5bc6f4e3a06db320daba2322e177b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/140b6cb1bab5bc6f4e3a06db320daba2322e177b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c9cf9a9ea10fdabf4b0866ccb2870bf6fdcc28f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9cf9a9ea10fdabf4b0866ccb2870bf6fdcc28f", "html_url": "https://github.com/rust-lang/rust/commit/0c9cf9a9ea10fdabf4b0866ccb2870bf6fdcc28f"}, {"sha": "1b88007af03bc7e15cd82f780f38c13a5dae2363", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b88007af03bc7e15cd82f780f38c13a5dae2363", "html_url": "https://github.com/rust-lang/rust/commit/1b88007af03bc7e15cd82f780f38c13a5dae2363"}], "stats": {"total": 196, "additions": 97, "deletions": 99}, "files": [{"sha": "bb9a58a0b62aa48dfe897ef9f2dba7dc5f2c7825", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 64, "deletions": 71, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::{self, Ty, TyCtxt, Visibility};\n use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::cstore::{\n@@ -92,8 +93,7 @@ crate struct CrateMetadata {\n     /// Trait impl data.\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n-    trait_impls:\n-        FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>>,\n+    trait_impls: FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<SimplifiedType>)]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n@@ -722,25 +722,24 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn try_item_ident(&self, item_index: DefIndex, sess: &Session) -> Result<Ident, String> {\n-        let name = self\n-            .def_key(item_index)\n-            .disambiguated_data\n-            .data\n-            .get_opt_name()\n-            .ok_or_else(|| format!(\"Missing opt name for {:?}\", item_index))?;\n-        let span = self\n-            .root\n-            .tables\n-            .ident_span\n-            .get(self, item_index)\n-            .ok_or_else(|| format!(\"Missing ident span for {:?} ({:?})\", name, item_index))?\n-            .decode((self, sess));\n-        Ok(Ident::new(name, span))\n+    fn opt_item_ident(&self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n+        let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n+        let span = match self.root.tables.ident_span.get(self, item_index) {\n+            Some(lazy_span) => lazy_span.decode((self, sess)),\n+            None => {\n+                // FIXME: this weird case of a name with no span is specific to `extern crate`\n+                // items, which are supposed to be treated like `use` items and only be encoded\n+                // to metadata as `Export`s, return `None` because that's what all the callers\n+                // expect in this case.\n+                assert_eq!(self.def_kind(item_index), DefKind::ExternCrate);\n+                return None;\n+            }\n+        };\n+        Some(Ident::new(name, span))\n     }\n \n     fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n-        self.try_item_ident(item_index, sess).unwrap()\n+        self.opt_item_ident(item_index, sess).expect(\"no encoded ident for item\")\n     }\n \n     fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n@@ -1102,27 +1101,19 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         // Iterate over all children.\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             for child_index in children.decode((self, sess)) {\n-                // FIXME: Merge with the logic below.\n-                if let None | Some(EntryKind::ForeignMod | EntryKind::Impl(_)) =\n-                    self.maybe_kind(child_index)\n-                {\n-                    continue;\n-                }\n-\n-                let def_key = self.def_key(child_index);\n-                if def_key.disambiguated_data.data.get_opt_name().is_some() {\n-                    let span = self.get_span(child_index, sess);\n+                if let Some(ident) = self.opt_item_ident(child_index, sess) {\n                     let kind = self.def_kind(child_index);\n-                    let ident = self.item_ident(child_index, sess);\n-                    let vis = self.get_visibility(child_index);\n+                    if matches!(kind, DefKind::Macro(..)) {\n+                        // FIXME: Macros are currently encoded twice, once as items and once as\n+                        // reexports. We ignore the items here and only use the reexports.\n+                        continue;\n+                    }\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n+                    let vis = self.get_visibility(child_index);\n+                    let span = self.get_span(child_index, sess);\n \n-                    // FIXME: Macros are currently encoded twice, once as items and once as\n-                    // reexports. We ignore the items here and only use the reexports.\n-                    if !matches!(kind, DefKind::Macro(..)) {\n-                        callback(Export { res, ident, vis, span });\n-                    }\n+                    callback(Export { ident, res, vis, span });\n \n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n@@ -1309,24 +1300,26 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_item_attrs(\n         &'a self,\n-        node_id: DefIndex,\n+        id: DefIndex,\n         sess: &'a Session,\n     ) -> impl Iterator<Item = ast::Attribute> + 'a {\n-        // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n-        // we assume that someone passing in a tuple struct ctor is actually wanting to\n-        // look at the definition\n-        let def_key = self.def_key(node_id);\n-        let item_id = if def_key.disambiguated_data.data == DefPathData::Ctor {\n-            def_key.parent.unwrap()\n-        } else {\n-            node_id\n-        };\n-\n         self.root\n             .tables\n             .attributes\n-            .get(self, item_id)\n-            .unwrap_or_else(Lazy::empty)\n+            .get(self, id)\n+            .unwrap_or_else(|| {\n+                // Structure and variant constructors don't have any attributes encoded for them,\n+                // but we assume that someone passing a constructor ID actually wants to look at\n+                // the attributes on the corresponding struct or variant.\n+                let def_key = self.def_key(id);\n+                assert_eq!(def_key.disambiguated_data.data, DefPathData::Ctor);\n+                let parent_id = def_key.parent.expect(\"no parent for a constructor\");\n+                self.root\n+                    .tables\n+                    .attributes\n+                    .get(self, parent_id)\n+                    .expect(\"no encoded attributes for a structure or variant\")\n+            })\n             .decode((self, sess))\n     }\n \n@@ -1372,39 +1365,39 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.traits.decode(self).map(|index| self.local_def_id(index))\n     }\n \n-    fn get_implementations_for_trait(\n+    fn get_trait_impls(&'a self) -> impl Iterator<Item = (DefId, Option<SimplifiedType>)> + 'a {\n+        self.trait_impls.values().flat_map(move |impls| {\n+            impls\n+                .decode(self)\n+                .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n+        })\n+    }\n+\n+    fn get_implementations_of_trait(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        filter: Option<DefId>,\n-    ) -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n+        trait_def_id: DefId,\n+    ) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n         if self.root.is_proc_macro_crate() {\n             // proc-macro crates export no trait impls.\n             return &[];\n         }\n \n-        if let Some(def_id) = filter {\n-            // Do a reverse lookup beforehand to avoid touching the crate_num\n-            // hash map in the loop below.\n-            let filter = match self.reverse_translate_def_id(def_id) {\n-                Some(def_id) => (def_id.krate.as_u32(), def_id.index),\n-                None => return &[],\n-            };\n+        // Do a reverse lookup beforehand to avoid touching the crate_num\n+        // hash map in the loop below.\n+        let key = match self.reverse_translate_def_id(trait_def_id) {\n+            Some(def_id) => (def_id.krate.as_u32(), def_id.index),\n+            None => return &[],\n+        };\n \n-            if let Some(impls) = self.trait_impls.get(&filter) {\n-                tcx.arena.alloc_from_iter(\n-                    impls.decode(self).map(|(idx, simplified_self_ty)| {\n-                        (self.local_def_id(idx), simplified_self_ty)\n-                    }),\n-                )\n-            } else {\n-                &[]\n-            }\n-        } else {\n-            tcx.arena.alloc_from_iter(self.trait_impls.values().flat_map(|impls| {\n+        if let Some(impls) = self.trait_impls.get(&key) {\n+            tcx.arena.alloc_from_iter(\n                 impls\n                     .decode(self)\n-                    .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty))\n-            }))\n+                    .map(|(idx, simplified_self_ty)| (self.local_def_id(idx), simplified_self_ty)),\n+            )\n+        } else {\n+            &[]\n         }\n     }\n "}, {"sha": "aac0aa61ea65eccaf291b6c67c86160e9ca6b09b", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -133,9 +133,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generator_kind => { cdata.generator_kind(def_id.index) }\n     opt_def_kind => { Some(cdata.def_kind(def_id.index)) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    def_ident_span => {\n-        cdata.try_item_ident(def_id.index, &tcx.sess).ok().map(|ident| ident.span)\n-    }\n+    def_ident_span => { cdata.opt_item_ident(def_id.index, &tcx.sess).map(|ident| ident.span) }\n     lookup_stability => {\n         cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n     }\n@@ -145,9 +143,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     lookup_deprecation_entry => {\n         cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n     }\n-    item_attrs => { tcx.arena.alloc_from_iter(\n-        cdata.get_item_attrs(def_id.index, tcx.sess)\n-    ) }\n+    item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n     fn_arg_names => { cdata.get_fn_param_names(tcx, def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n@@ -196,14 +192,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extra_filename => { cdata.root.extra_filename.clone() }\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n+    all_trait_implementations => { tcx.arena.alloc_from_iter(cdata.get_trait_impls()) }\n \n-    implementations_of_trait => {\n-        cdata.get_implementations_for_trait(tcx, Some(other))\n-    }\n-\n-    all_trait_implementations => {\n-        cdata.get_implementations_for_trait(tcx, None)\n-    }\n+    implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n     dep_kind => {\n@@ -470,7 +461,7 @@ impl CStore {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n \n-    pub fn item_attrs(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n+    pub fn item_attrs_untracked(&self, def_id: DefId, sess: &Session) -> Vec<ast::Attribute> {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess).collect()\n     }\n "}, {"sha": "12d66f4fc45f36eabcea41a7b4cacc0ab9b3b813", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -26,7 +26,7 @@ use rustc_middle::mir::interpret;\n use rustc_middle::thir;\n use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::TyEncoder;\n-use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n+use rustc_middle::ty::fast_reject::{self, SimplifiedType, SimplifyParams, StripReferences};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n@@ -2055,7 +2055,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n struct ImplsVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    impls: FxHashMap<DefId, Vec<(DefIndex, Option<fast_reject::SimplifiedType>)>>,\n+    impls: FxHashMap<DefId, Vec<(DefIndex, Option<SimplifiedType>)>>,\n }\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplsVisitor<'tcx> {"}, {"sha": "4076e0b9e0fed83e6db7e7d9000aeb7c5cb4a1e5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n use rustc_middle::thir;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n use rustc_serialize::opaque::Encoder;\n@@ -261,7 +262,7 @@ crate struct CrateDep {\n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct TraitImpls {\n     trait_id: (u32, DefIndex),\n-    impls: Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>,\n+    impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n }\n \n /// Define `LazyTables` and `TableBuilders` at the same time."}, {"sha": "b3db2e6340024529a8b8e25e18cd90a0f1e034eb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -1411,16 +1411,14 @@ rustc_queries! {\n \n     /// Given a crate and a trait, look up all impls of that trait in the crate.\n     /// Return `(impl_id, self_ty)`.\n-    query implementations_of_trait(_: (CrateNum, DefId))\n-        -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n+    query implementations_of_trait(_: (CrateNum, DefId)) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n         desc { \"looking up implementations of a trait in a crate\" }\n         separate_provide_extern\n     }\n \n     /// Given a crate, look up all trait impls in that crate.\n     /// Return `(impl_id, self_ty)`.\n-    query all_trait_implementations(_: CrateNum)\n-        -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n+    query all_trait_implementations(_: CrateNum) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n         desc { \"looking up all (?) trait implementations\" }\n         separate_provide_extern\n     }"}, {"sha": "daf9156a15f347f047500450a608ca88dec54013", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -143,6 +143,18 @@ pub fn simplify_type(\n }\n \n impl<D: Copy + Debug + Ord + Eq> SimplifiedTypeGen<D> {\n+    pub fn def(self) -> Option<D> {\n+        match self {\n+            AdtSimplifiedType(d)\n+            | ForeignSimplifiedType(d)\n+            | TraitSimplifiedType(d)\n+            | ClosureSimplifiedType(d)\n+            | GeneratorSimplifiedType(d)\n+            | OpaqueSimplifiedType(d) => Some(d),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n     where\n         F: Fn(D) -> U,"}, {"sha": "3af1b3a04402466c98444f4e37deb36323a6decb", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -28,6 +28,7 @@ use crate::traits::query::{\n };\n use crate::traits::specialization_graph;\n use crate::traits::{self, ImplSource};\n+use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};"}, {"sha": "34d059f4ec849c28625f05730bf0cf5fb56891d4", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::specialization_graph;\n-use crate::ty::fast_reject::{self, SimplifyParams, StripReferences};\n+use crate::ty::fast_reject::{self, SimplifiedType, SimplifyParams, StripReferences};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ty, TyCtxt};\n use rustc_hir as hir;\n@@ -68,7 +68,7 @@ pub enum TraitSpecializationKind {\n pub struct TraitImpls {\n     blanket_impls: Vec<DefId>,\n     /// Impls indexed by their simplified self type, for fast lookup.\n-    non_blanket_impls: FxIndexMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+    non_blanket_impls: FxIndexMap<SimplifiedType, Vec<DefId>>,\n }\n \n impl TraitImpls {"}, {"sha": "4feeae5cab1ded3c12fefa1e327e220330038133", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -895,17 +895,19 @@ impl<'a> Resolver<'a> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs(did, this.session).iter().any(\n-                                        |attr| {\n+                                    && this\n+                                        .cstore()\n+                                        .item_attrs_untracked(did, this.session)\n+                                        .iter()\n+                                        .any(|attr| {\n                                             if attr.has_name(sym::rustc_diagnostic_item) {\n                                                 [sym::TryInto, sym::TryFrom, sym::FromIterator]\n                                                     .map(|x| Some(x))\n                                                     .contains(&attr.value_str())\n                                             } else {\n                                                 false\n                                             }\n-                                        },\n-                                    );\n+                                        });\n \n                                 requires_note.then(|| {\n                                     format!("}, {"sha": "b46a93c06734bf0e2ecab496b9532df74d47803b", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/140b6cb1bab5bc6f4e3a06db320daba2322e177b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=140b6cb1bab5bc6f4e3a06db320daba2322e177b", "patch": "@@ -3420,7 +3420,7 @@ impl<'a> Resolver<'a> {\n \n                 let attr = self\n                     .cstore()\n-                    .item_attrs(def_id, self.session)\n+                    .item_attrs_untracked(def_id, self.session)\n                     .into_iter()\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();"}]}