{"sha": "b1d74306579f310b33afd21c8a853afdc53d1fd2", "node_id": "C_kwDOAAsO6NoAKGIxZDc0MzA2NTc5ZjMxMGIzM2FmZDIxYzhhODUzYWZkYzUzZDFmZDI", "commit": {"author": {"name": "akida31", "email": "akida3@protonmail.com", "date": "2022-10-11T14:20:52Z"}, "committer": {"name": "akida31", "email": "akida3@protonmail.com", "date": "2022-12-13T15:28:34Z"}, "message": "move changes to an extra function", "tree": {"sha": "1ff092daa9bd20c5027a5b5444062b5da834d3ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ff092daa9bd20c5027a5b5444062b5da834d3ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d74306579f310b33afd21c8a853afdc53d1fd2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ20GAFrM+jef+hIIAuGvLD2ft8kFAmOYmiIACgkQAuGvLD2f\nt8kmXA//QbYyPXBE1raVz0WwRmOAHV4pSyj5NkRXzwG4mZO9SNQCMy87l/0PJ+nD\nljHQ+aQsh5CohphUD77hhXUlaJHEdVbwtzh3WI4IzPweZPGM02lQn7hn2fbv8ii1\nWKayhkaJfCXMk86ES+2dT5H6tfJnxzMFikdp/RT45efh8vQ4y1qmKJoAk2kMZFq3\njGCONA58APsC/tp7pgyCo7tItOzqRjO8FPr5TlB5bitgtgkaw4mk+DLZAfvpDApN\nUV76XNXRPCouISOidam8LlhBEJxRcaQIh99Ada2OF2YAAuS85OdsKkdp6nWHO5Nv\n+BMKYiZ1dDo9iUgv60Ji8mZlcQuBobf/eX+UaiFXSUniavM2ZLKRztp3h0mAhZN6\n6EZ3OCgv+RQsbw4cmNIUhHJEDX6PHmf8N699u9UsJme8vKsKLNBQOWAorNBq5/qK\nq+ks12gvYkXVIqR1IrV0Gju0KNcvTz4xuqyeuwQVA9JlUEfX4dvYkGbfa4tMH7jb\nV3vLq9t0iVfRv5wGkayNs+57tWPWJxVKcCn3QS4rlLrJ+NeZJBb+R2wjFGH5dbnw\nt2kL/WVnZoG2daEiT+mVebj7ZwGxB+zMpKqYhNKyzzYbQfuA0/M2u+9sDhBuGRJR\nVXYOxxVuEXl2I5nVCwJGtAigSpQVF9pL9qWO7wACekSmuEYjKVY=\n=D6Df\n-----END PGP SIGNATURE-----", "payload": "tree 1ff092daa9bd20c5027a5b5444062b5da834d3ed\nparent e326e8c885e70040fc5f3012fa6126853cfd080f\nauthor akida31 <akida3@protonmail.com> 1665498052 +0200\ncommitter akida31 <akida3@protonmail.com> 1670945314 +0100\n\nmove changes to an extra function\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d74306579f310b33afd21c8a853afdc53d1fd2", "html_url": "https://github.com/rust-lang/rust/commit/b1d74306579f310b33afd21c8a853afdc53d1fd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d74306579f310b33afd21c8a853afdc53d1fd2/comments", "author": {"login": "Akida31", "id": 47895118, "node_id": "MDQ6VXNlcjQ3ODk1MTE4", "avatar_url": "https://avatars.githubusercontent.com/u/47895118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Akida31", "html_url": "https://github.com/Akida31", "followers_url": "https://api.github.com/users/Akida31/followers", "following_url": "https://api.github.com/users/Akida31/following{/other_user}", "gists_url": "https://api.github.com/users/Akida31/gists{/gist_id}", "starred_url": "https://api.github.com/users/Akida31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Akida31/subscriptions", "organizations_url": "https://api.github.com/users/Akida31/orgs", "repos_url": "https://api.github.com/users/Akida31/repos", "events_url": "https://api.github.com/users/Akida31/events{/privacy}", "received_events_url": "https://api.github.com/users/Akida31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Akida31", "id": 47895118, "node_id": "MDQ6VXNlcjQ3ODk1MTE4", "avatar_url": "https://avatars.githubusercontent.com/u/47895118?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Akida31", "html_url": "https://github.com/Akida31", "followers_url": "https://api.github.com/users/Akida31/followers", "following_url": "https://api.github.com/users/Akida31/following{/other_user}", "gists_url": "https://api.github.com/users/Akida31/gists{/gist_id}", "starred_url": "https://api.github.com/users/Akida31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Akida31/subscriptions", "organizations_url": "https://api.github.com/users/Akida31/orgs", "repos_url": "https://api.github.com/users/Akida31/repos", "events_url": "https://api.github.com/users/Akida31/events{/privacy}", "received_events_url": "https://api.github.com/users/Akida31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e326e8c885e70040fc5f3012fa6126853cfd080f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e326e8c885e70040fc5f3012fa6126853cfd080f", "html_url": "https://github.com/rust-lang/rust/commit/e326e8c885e70040fc5f3012fa6126853cfd080f"}], "stats": {"total": 142, "additions": 76, "deletions": 66}, "files": [{"sha": "f9a63841a70ba4b2e6bd09024555b22eedb8592e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 76, "deletions": 66, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b1d74306579f310b33afd21c8a853afdc53d1fd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d74306579f310b33afd21c8a853afdc53d1fd2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b1d74306579f310b33afd21c8a853afdc53d1fd2", "patch": "@@ -1758,73 +1758,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         self.note_conflicting_closure_bounds(cause, &mut err);\n \n-        let found_args = match found.kind() {\n-            ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n-            kind => {\n-                span_bug!(span, \"found was converted to a FnPtr above but is now {:?}\", kind)\n-            }\n-        };\n-        let expected_args = match expected.kind() {\n-            ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n-            kind => {\n-                span_bug!(span, \"expected was converted to a FnPtr above but is now {:?}\", kind)\n-            }\n-        };\n-\n         if let Some(found_node) = found_node {\n-            let fn_decl = match found_node {\n-                Node::Expr(expr) => match &expr.kind {\n-                    hir::ExprKind::Closure(hir::Closure { fn_decl, .. }) => fn_decl,\n-                    kind => {\n-                        span_bug!(found_span, \"expression must be a closure but is {:?}\", kind)\n-                    }\n-                },\n-                Node::Item(item) => match &item.kind {\n-                    hir::ItemKind::Fn(signature, _generics, _body) => signature.decl,\n-                    kind => {\n-                        span_bug!(found_span, \"item must be a function but is {:?}\", kind)\n-                    }\n-                },\n-                node => {\n-                    span_bug!(found_span, \"node must be a expr or item but is {:?}\", node)\n-                }\n-            };\n-\n-            let arg_spans = fn_decl.inputs.iter().map(|ty| ty.span);\n-\n-            fn get_deref_type_and_refs(mut ty: Ty<'_>) -> (Ty<'_>, usize) {\n-                let mut refs = 0;\n-\n-                while let ty::Ref(_, new_ty, _) = ty.kind() {\n-                    ty = *new_ty;\n-                    refs += 1;\n-                }\n-\n-                (ty, refs)\n-            }\n-\n-            for ((found_arg, expected_arg), arg_span) in\n-                found_args.zip(expected_args).zip(arg_spans)\n-            {\n-                let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n-                let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n-\n-                if found_ty == expected_ty {\n-                    let hint = if found_refs < expected_refs {\n-                        \"consider borrowing here:\"\n-                    } else if found_refs == expected_refs {\n-                        continue;\n-                    } else {\n-                        \"consider removing the borrow:\"\n-                    };\n-                    err.span_suggestion_verbose(\n-                        arg_span,\n-                        hint,\n-                        expected_arg.to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-            }\n+            hint_missing_borrow(span, found_span, found, expected, found_node, &mut err);\n         }\n \n         err\n@@ -3455,6 +3390,81 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     }\n }\n \n+/// Add a hint to add a missing borrow or remove an unnecessary one.\n+fn hint_missing_borrow<'tcx>(\n+    span: Span,\n+    found_span: Span,\n+    found: Ty<'tcx>,\n+    expected: Ty<'tcx>,\n+    found_node: Node<'_>,\n+    err: &mut Diagnostic,\n+) {\n+    let found_args = match found.kind() {\n+        ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n+        kind => {\n+            span_bug!(span, \"found was converted to a FnPtr above but is now {:?}\", kind)\n+        }\n+    };\n+    let expected_args = match expected.kind() {\n+        ty::FnPtr(f) => f.inputs().skip_binder().iter(),\n+        kind => {\n+            span_bug!(span, \"expected was converted to a FnPtr above but is now {:?}\", kind)\n+        }\n+    };\n+\n+    let fn_decl = match found_node {\n+        Node::Expr(expr) => match &expr.kind {\n+            hir::ExprKind::Closure(hir::Closure { fn_decl, .. }) => fn_decl,\n+            kind => {\n+                span_bug!(found_span, \"expression must be a closure but is {:?}\", kind)\n+            }\n+        },\n+        Node::Item(item) => match &item.kind {\n+            hir::ItemKind::Fn(signature, _generics, _body) => signature.decl,\n+            kind => {\n+                span_bug!(found_span, \"item must be a function but is {:?}\", kind)\n+            }\n+        },\n+        node => {\n+            span_bug!(found_span, \"node must be a expr or item but is {:?}\", node)\n+        }\n+    };\n+\n+    let arg_spans = fn_decl.inputs.iter().map(|ty| ty.span);\n+\n+    fn get_deref_type_and_refs<'tcx>(mut ty: Ty<'tcx>) -> (Ty<'tcx>, usize) {\n+        let mut refs = 0;\n+\n+        while let ty::Ref(_, new_ty, _) = ty.kind() {\n+            ty = *new_ty;\n+            refs += 1;\n+        }\n+\n+        (ty, refs)\n+    }\n+\n+    for ((found_arg, expected_arg), arg_span) in found_args.zip(expected_args).zip(arg_spans) {\n+        let (found_ty, found_refs) = get_deref_type_and_refs(*found_arg);\n+        let (expected_ty, expected_refs) = get_deref_type_and_refs(*expected_arg);\n+\n+        if found_ty == expected_ty {\n+            let hint = if found_refs < expected_refs {\n+                \"consider borrowing here:\"\n+            } else if found_refs == expected_refs {\n+                continue;\n+            } else {\n+                \"consider removing the borrow:\"\n+            };\n+            err.span_suggestion_verbose(\n+                arg_span,\n+                hint,\n+                expected_arg.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}\n+\n /// Collect all the returned expressions within the input expression.\n /// Used to point at the return spans when we want to suggest some change to them.\n #[derive(Default)]"}]}