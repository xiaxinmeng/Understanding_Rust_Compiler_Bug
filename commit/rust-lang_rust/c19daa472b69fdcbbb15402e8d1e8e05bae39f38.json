{"sha": "c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "node_id": "C_kwDOAAsO6NoAKGMxOWRhYTQ3MmI2OWZkY2JiYjE1NDAyZThkMWU4ZTA1YmFlMzlmMzg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-25T20:56:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-26T07:44:10Z"}, "message": "make invalid_value lint a bit smarter around enums", "tree": {"sha": "fc592cc8e6edd8569da64bb5ee112d7d79724a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc592cc8e6edd8569da64bb5ee112d7d79724a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "html_url": "https://github.com/rust-lang/rust/commit/c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fafbb006ee98635874f73e480655912b465e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fafbb006ee98635874f73e480655912b465e65", "html_url": "https://github.com/rust-lang/rust/commit/f3fafbb006ee98635874f73e480655912b465e65"}], "stats": {"total": 425, "additions": 298, "deletions": 127}, "files": [{"sha": "529e709c5db30fe39aa3da4b4d65cd709374d380", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 109, "deletions": 51, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -46,8 +46,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -2425,12 +2424,56 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n-        /// Test if this enum has several actually \"existing\" variants.\n-        /// Zero-sized uninhabited variants do not always have a tag assigned and thus do not \"exist\".\n-        fn is_multi_variant<'tcx>(adt: ty::AdtDef<'tcx>) -> bool {\n-            // As an approximation, we only count dataless variants. Those are definitely inhabited.\n-            let existing_variants = adt.variants().iter().filter(|v| v.fields.is_empty()).count();\n-            existing_variants > 1\n+        /// Determines whether the given type is inhabited. `None` means that we don't know.\n+        fn ty_inhabited(ty: Ty<'_>) -> Option<bool> {\n+            use rustc_type_ir::sty::TyKind::*;\n+            match ty.kind() {\n+                Never => Some(false),\n+                Int(_) | Uint(_) | Float(_) | Bool | Char | RawPtr(_) => Some(true),\n+                // Fallback for more complicated types. (Note that `&!` might be considered\n+                // uninhabited so references are \"complicated\", too.)\n+                _ => None,\n+            }\n+        }\n+        /// Determines whether a product type formed from a list of types is inhabited.\n+        fn tys_inhabited<'tcx>(tys: impl Iterator<Item = Ty<'tcx>>) -> Option<bool> {\n+            let mut definitely_inhabited = true; // with no fields, we are definitely inhabited.\n+            for ty in tys {\n+                match ty_inhabited(ty) {\n+                    // If any type is uninhabited, the product is uninhabited.\n+                    Some(false) => return Some(false),\n+                    // Otherwise go searching for a `None`.\n+                    None => {\n+                        // We don't know.\n+                        definitely_inhabited = false;\n+                    }\n+                    Some(true) => {}\n+                }\n+            }\n+            if definitely_inhabited { Some(true) } else { None }\n+        }\n+\n+        fn variant_find_init_error<'tcx>(\n+            cx: &LateContext<'tcx>,\n+            variant: &VariantDef,\n+            substs: ty::SubstsRef<'tcx>,\n+            descr: &str,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n+            variant.fields.iter().find_map(|field| {\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n+                    if span.is_none() {\n+                        // Point to this field, should be helpful for figuring\n+                        // out where the source of the error is.\n+                        let span = cx.tcx.def_span(field.did);\n+                        write!(&mut msg, \" (in this {descr})\").unwrap();\n+                        (msg, Some(span))\n+                    } else {\n+                        // Just forward.\n+                        (msg, span)\n+                    }\n+                })\n+            })\n         }\n \n         /// Return `Some` only if we are sure this type does *not*\n@@ -2468,14 +2511,15 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 RawPtr(_) if init == InitKind::Uninit => {\n                     Some((\"raw pointers must not be uninitialized\".to_string(), None))\n                 }\n-                // Recurse and checks for some compound types.\n+                // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n                     // First check if this ADT has a layout attribute (like `NonNull` and friends).\n                     use std::ops::Bound;\n                     match cx.tcx.layout_scalar_valid_range(adt_def.did()) {\n                         // We exploit here that `layout_scalar_valid_range` will never\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n+                        // We don't add a span since users cannot declare such types anyway.\n                         (Bound::Included(lo), _) if lo > 0 => {\n                             return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n@@ -2492,50 +2536,64 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         }\n                         _ => {}\n                     }\n-                    // Now, recurse.\n-                    match adt_def.variants().len() {\n-                        0 => Some((\"enums with no variants have no valid value\".to_string(), None)),\n-                        1 => {\n-                            // Struct, or enum with exactly one variant.\n-                            // Proceed recursively, check all fields.\n-                            let variant = &adt_def.variant(VariantIdx::from_u32(0));\n-                            variant.fields.iter().find_map(|field| {\n-                                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(\n-                                    |(mut msg, span)| {\n-                                        if span.is_none() {\n-                                            // Point to this field, should be helpful for figuring\n-                                            // out where the source of the error is.\n-                                            let span = cx.tcx.def_span(field.did);\n-                                            write!(\n-                                                &mut msg,\n-                                                \" (in this {} field)\",\n-                                                adt_def.descr()\n-                                            )\n-                                            .unwrap();\n-                                            (msg, Some(span))\n-                                        } else {\n-                                            // Just forward.\n-                                            (msg, span)\n-                                        }\n-                                    },\n-                                )\n-                            })\n-                        }\n-                        // Multi-variant enum.\n-                        _ => {\n-                            if init == InitKind::Uninit && is_multi_variant(*adt_def) {\n-                                let span = cx.tcx.def_span(adt_def.did());\n-                                Some((\n-                                    \"enums have to be initialized to a variant\".to_string(),\n-                                    Some(span),\n-                                ))\n-                            } else {\n-                                // In principle, for zero-initialization we could figure out which variant corresponds\n-                                // to tag 0, and check that... but for now we just accept all zero-initializations.\n-                                None\n-                            }\n+                    // Handle structs.\n+                    if adt_def.is_struct() {\n+                        return variant_find_init_error(\n+                            cx,\n+                            adt_def.non_enum_variant(),\n+                            substs,\n+                            \"struct field\",\n+                            init,\n+                        );\n+                    }\n+                    // And now, enums.\n+                    let span = cx.tcx.def_span(adt_def.did());\n+                    let mut potential_variants = adt_def.variants().iter().filter_map(|variant| {\n+                        let inhabited = tys_inhabited(\n+                            variant.fields.iter().map(|field| field.ty(cx.tcx, substs)),\n+                        );\n+                        let definitely_inhabited = match inhabited {\n+                            // Entirely skip uninhbaited variants.\n+                            Some(false) => return None,\n+                            // Forward the others, but remember which ones are definitely inhabited.\n+                            Some(true) => true,\n+                            None => false,\n+                        };\n+                        Some((variant, definitely_inhabited))\n+                    });\n+                    let Some(first_variant) = potential_variants.next() else {\n+                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                    };\n+                    // So we have at least one potentially inhabited variant. Might we have two?\n+                    let Some(second_variant) = potential_variants.next() else {\n+                        // There is only one potentially inhabited variant. So we can recursively check that variant!\n+                        return variant_find_init_error(\n+                            cx,\n+                            &first_variant.0,\n+                            substs,\n+                            \"field of the only potentially inhabited enum variant\",\n+                            init,\n+                        );\n+                    };\n+                    // So we have at least two potentially inhabited variants.\n+                    // If we can prove that we have at least two *definitely* inhabited variants,\n+                    // then we have a tag and hence leaving this uninit is definitely disallowed.\n+                    // (Leaving it zeroed could be okay, depending on which variant is encoded as zero tag.)\n+                    if init == InitKind::Uninit {\n+                        let definitely_inhabited = (first_variant.1 as usize)\n+                            + (second_variant.1 as usize)\n+                            + potential_variants\n+                                .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n+                                .count();\n+                        if definitely_inhabited > 1 {\n+                            return Some((\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n+                                Some(span),\n+                            ));\n                         }\n                     }\n+                    // We couldn't find anything wrong here.\n+                    None\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields."}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "b568518b4499dae0a7a6fc6f6fc00c9e774d6ca7", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -40,11 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums with no variants have no valid value (in this struct field)\n-  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |\n-LL |     pub struct Empty(Void);\n-   |                      ^^^^\n+LL |     enum Void {}\n+   |     ^^^^^^^^^\n \n error: aborting due to 2 previous errors; 2 warnings emitted\n "}, {"sha": "c37a472ffe10f20ab7f308a41879d0a18c88025a", "filename": "src/test/ui/lint/invalid_value.rs", "status": "renamed", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.rs?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -34,6 +34,16 @@ enum OneFruit {\n     Banana,\n }\n \n+enum OneFruitNonZero {\n+    Apple(!),\n+    Banana(NonZeroU32),\n+}\n+\n+enum TwoUninhabited {\n+    A(!),\n+    B(!),\n+}\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -84,6 +94,12 @@ fn main() {\n         let _val: [fn(); 2] = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: [fn(); 2] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        let _val: TwoUninhabited = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: TwoUninhabited = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: OneFruitNonZero = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: OneFruitNonZero = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n         // Things that can be zero, but not uninit.\n         let _val: bool = mem::zeroed();\n         let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n@@ -112,6 +128,16 @@ fn main() {\n         let _val: *const [()] = mem::zeroed();\n         let _val: *const [()] = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        // Things where 0 is okay due to rustc implementation details,\n+        // but that are not guaranteed to keep working.\n+        let _val: Result<i32, i32> = mem::zeroed();\n+        let _val: Result<i32, i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Some things that happen to work due to rustc implementation details,\n+        // but are not guaranteed to keep working.\n+        let _val: OneFruit = mem::zeroed();\n+        let _val: OneFruit = mem::uninitialized();\n+\n         // Transmute-from-0\n         let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n         let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n@@ -129,9 +155,5 @@ fn main() {\n         let _val: bool = MaybeUninit::zeroed().assume_init();\n         let _val: [bool; 0] = MaybeUninit::uninit().assume_init();\n         let _val: [!; 0] = MaybeUninit::zeroed().assume_init();\n-\n-        // Some things that happen to work due to rustc implementation details,\n-        // but are not guaranteed to keep working.\n-        let _val: OneFruit = mem::uninitialized();\n     }\n }", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.rs"}, {"sha": "750b3c76c44c2a82618a072b9f6f474f04d168e5", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "renamed", "additions": 145, "deletions": 62, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -1,5 +1,5 @@\n error: the type `&T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:40:32\n+  --> $DIR/invalid_value.rs:50:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -8,14 +8,14 @@ LL |         let _val: &'static T = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: the lint level is defined here\n-  --> $DIR/uninitialized-zeroed.rs:6:9\n+  --> $DIR/invalid_value.rs:6:9\n    |\n LL | #![deny(invalid_value)]\n    |         ^^^^^^^^^^^^^\n    = note: references must be non-null\n \n error: the type `&T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:41:32\n+  --> $DIR/invalid_value.rs:51:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:43:38\n+  --> $DIR/invalid_value.rs:53:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:44:38\n+  --> $DIR/invalid_value.rs:54:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:51:23\n+  --> $DIR/invalid_value.rs:61:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:52:23\n+  --> $DIR/invalid_value.rs:62:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:54:30\n+  --> $DIR/invalid_value.rs:64:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: the `!` type has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:55:30\n+  --> $DIR/invalid_value.rs:65:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,29 +100,37 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:57:26\n+  --> $DIR/invalid_value.rs:67:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:58:26\n+  --> $DIR/invalid_value.rs:68:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n    |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:12:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:60:34\n+  --> $DIR/invalid_value.rs:70:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +141,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: references must be non-null\n \n error: the type `&i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:61:34\n+  --> $DIR/invalid_value.rs:71:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +152,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: references must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:63:25\n+  --> $DIR/invalid_value.rs:73:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +161,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:64:25\n+  --> $DIR/invalid_value.rs:74:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +176,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:12\n+  --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:66:26\n+  --> $DIR/invalid_value.rs:76:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +193,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:67:26\n+  --> $DIR/invalid_value.rs:77:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +204,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:69:32\n+  --> $DIR/invalid_value.rs:79:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +213,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:70:32\n+  --> $DIR/invalid_value.rs:80:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,43 +228,43 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:72:36\n+  --> $DIR/invalid_value.rs:82:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:73:36\n+  --> $DIR/invalid_value.rs:83:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:18:28\n+note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:75:42\n+  --> $DIR/invalid_value.rs:85:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +273,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:76:42\n+  --> $DIR/invalid_value.rs:86:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,13 +288,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: references must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:15:16\n+  --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:78:34\n+  --> $DIR/invalid_value.rs:88:34\n    |\n LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -297,7 +305,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:79:34\n+  --> $DIR/invalid_value.rs:89:34\n    |\n LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +316,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `*const dyn Send` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:81:37\n+  --> $DIR/invalid_value.rs:91:37\n    |\n LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n@@ -319,7 +327,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `*const dyn Send` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:82:37\n+  --> $DIR/invalid_value.rs:92:37\n    |\n LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n@@ -330,7 +338,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    = note: the vtable of a wide raw pointer must be non-null\n \n error: the type `[fn(); 2]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:84:31\n+  --> $DIR/invalid_value.rs:94:31\n    |\n LL |         let _val: [fn(); 2] = mem::zeroed();\n    |                               ^^^^^^^^^^^^^\n@@ -341,7 +349,7 @@ LL |         let _val: [fn(); 2] = mem::zeroed();\n    = note: function pointers must be non-null\n \n error: the type `[fn(); 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:85:31\n+  --> $DIR/invalid_value.rs:95:31\n    |\n LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -351,8 +359,68 @@ LL |         let _val: [fn(); 2] = mem::uninitialized();\n    |\n    = note: function pointers must be non-null\n \n+error: the type `TwoUninhabited` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:97:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::zeroed();\n+   |                                    ^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `TwoUninhabited` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:98:36\n+   |\n+LL |         let _val: TwoUninhabited = mem::uninitialized();\n+   |                                    ^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/invalid_value.rs:42:1\n+   |\n+LL | enum TwoUninhabited {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit zero-initialization\n+  --> $DIR/invalid_value.rs:100:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::zeroed();\n+   |                                     ^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n+error: the type `OneFruitNonZero` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:101:37\n+   |\n+LL |         let _val: OneFruitNonZero = mem::uninitialized();\n+   |                                     ^^^^^^^^^^^^^^^^^^^^\n+   |                                     |\n+   |                                     this code causes undefined behavior when executed\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+  --> $DIR/invalid_value.rs:39:12\n+   |\n+LL |     Banana(NonZeroU32),\n+   |            ^^^^^^^^^^\n+\n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:89:26\n+  --> $DIR/invalid_value.rs:105:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -363,7 +431,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:92:32\n+  --> $DIR/invalid_value.rs:108:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -372,13 +440,13 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: characters must be a valid Unicode codepoint (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:17:18\n+  --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:95:28\n+  --> $DIR/invalid_value.rs:111:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -389,22 +457,22 @@ LL |         let _val: NonBig = mem::uninitialized();\n    = note: `NonBig` must be initialized inside its custom valid range\n \n error: the type `Fruit` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:98:27\n+  --> $DIR/invalid_value.rs:114:27\n    |\n LL |         let _val: Fruit = mem::uninitialized();\n    |                           ^^^^^^^^^^^^^^^^^^^^\n    |                           |\n    |                           this code causes undefined behavior when executed\n    |                           help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: enums have to be initialized to a variant\n-  --> $DIR/uninitialized-zeroed.rs:26:1\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $DIR/invalid_value.rs:26:1\n    |\n LL | enum Fruit {\n    | ^^^^^^^^^^\n \n error: the type `[bool; 2]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:101:31\n+  --> $DIR/invalid_value.rs:117:31\n    |\n LL |         let _val: [bool; 2] = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -415,7 +483,7 @@ LL |         let _val: [bool; 2] = mem::uninitialized();\n    = note: booleans must be either `true` or `false`\n \n error: the type `i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:104:25\n+  --> $DIR/invalid_value.rs:120:25\n    |\n LL |         let _val: i32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -426,7 +494,7 @@ LL |         let _val: i32 = mem::uninitialized();\n    = note: integers must not be uninitialized\n \n error: the type `f32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:107:25\n+  --> $DIR/invalid_value.rs:123:25\n    |\n LL |         let _val: f32 = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -437,7 +505,7 @@ LL |         let _val: f32 = mem::uninitialized();\n    = note: floats must not be uninitialized\n \n error: the type `*const ()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:110:31\n+  --> $DIR/invalid_value.rs:126:31\n    |\n LL |         let _val: *const () = mem::uninitialized();\n    |                               ^^^^^^^^^^^^^^^^^^^^\n@@ -448,7 +516,7 @@ LL |         let _val: *const () = mem::uninitialized();\n    = note: raw pointers must not be uninitialized\n \n error: the type `*const [()]` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:113:33\n+  --> $DIR/invalid_value.rs:129:33\n    |\n LL |         let _val: *const [()] = mem::uninitialized();\n    |                                 ^^^^^^^^^^^^^^^^^^^^\n@@ -458,8 +526,23 @@ LL |         let _val: *const [()] = mem::uninitialized();\n    |\n    = note: raw pointers must not be uninitialized\n \n+error: the type `Result<i32, i32>` does not permit being left uninitialized\n+  --> $DIR/invalid_value.rs:134:38\n+   |\n+LL |         let _val: Result<i32, i32> = mem::uninitialized();\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+   |                                      |\n+   |                                      this code causes undefined behavior when executed\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+   |\n+note: enums with multiple inhabited variants have to be initialized to a variant\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n+   |\n+LL | pub enum Result<T, E> {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+\n error: the type `&i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:116:34\n+  --> $DIR/invalid_value.rs:142:34\n    |\n LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n@@ -470,7 +553,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    = note: references must be non-null\n \n error: the type `&[i32]` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:117:36\n+  --> $DIR/invalid_value.rs:143:36\n    |\n LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -481,7 +564,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    = note: references must be non-null\n \n error: the type `NonZeroU32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:118:32\n+  --> $DIR/invalid_value.rs:144:32\n    |\n LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n@@ -492,7 +575,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:121:34\n+  --> $DIR/invalid_value.rs:147:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -503,7 +586,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `NonNull<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:122:34\n+  --> $DIR/invalid_value.rs:148:34\n    |\n LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -514,7 +597,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    = note: `std::ptr::NonNull<i32>` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:123:26\n+  --> $DIR/invalid_value.rs:149:26\n    |\n LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -524,5 +607,5 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |\n    = note: booleans must be either `true` or `false`\n \n-error: aborting due to 43 previous errors\n+error: aborting due to 48 previous errors\n ", "previous_filename": "src/test/ui/lint/uninitialized-zeroed.stderr"}, {"sha": "6d37de8ff3f688a2ed52643f785ce9ee7e096b47", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c19daa472b69fdcbbb15402e8d1e8e05bae39f38/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=c19daa472b69fdcbbb15402e8d1e8e05bae39f38", "patch": "@@ -59,7 +59,11 @@ LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n    |                               help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: `#[warn(invalid_value)]` on by default\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/uninhabited-static.rs:16:32\n@@ -76,7 +80,11 @@ LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-   = note: enums with no variants have no valid value\n+note: enums with no inhabited variants have no valid value\n+  --> $DIR/uninhabited-static.rs:4:1\n+   |\n+LL | enum Void {}\n+   | ^^^^^^^^^\n \n error: aborting due to 6 previous errors; 2 warnings emitted\n "}]}