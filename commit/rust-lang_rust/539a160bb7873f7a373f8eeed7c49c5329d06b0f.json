{"sha": "539a160bb7873f7a373f8eeed7c49c5329d06b0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOWExNjBiYjc4NzNmN2EzNzNmOGVlZWQ3YzQ5YzUzMjlkMDZiMGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-07-24T20:49:24Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-07-24T20:49:24Z"}, "message": "Merge pull request #3003 from elliottslaughter/free-cant-fail\n\nDon't emit invoke instructions inside landing pads.", "tree": {"sha": "bcded698973a5c10264e182c0e29a13046ffa9dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcded698973a5c10264e182c0e29a13046ffa9dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/539a160bb7873f7a373f8eeed7c49c5329d06b0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/539a160bb7873f7a373f8eeed7c49c5329d06b0f", "html_url": "https://github.com/rust-lang/rust/commit/539a160bb7873f7a373f8eeed7c49c5329d06b0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/539a160bb7873f7a373f8eeed7c49c5329d06b0f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8868b222c32c5093c6066771ad2aaddc6a22da88", "url": "https://api.github.com/repos/rust-lang/rust/commits/8868b222c32c5093c6066771ad2aaddc6a22da88", "html_url": "https://github.com/rust-lang/rust/commit/8868b222c32c5093c6066771ad2aaddc6a22da88"}, {"sha": "c341eb90522294dda6dbce646d1c0a7170a48bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c341eb90522294dda6dbce646d1c0a7170a48bfc", "html_url": "https://github.com/rust-lang/rust/commit/c341eb90522294dda6dbce646d1c0a7170a48bfc"}], "stats": {"total": 61, "additions": 40, "deletions": 21}, "files": [{"sha": "8990891112dae17d13b53d4eef0dbcf1abe672d6", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=539a160bb7873f7a373f8eeed7c49c5329d06b0f", "patch": "@@ -37,6 +37,9 @@ fn rt_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     ret rustrt::rust_upcall_exchange_malloc(td, size);\n }\n \n+// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n+// inside a landing pad may corrupt the state of the exception handler. If a\n+// problem occurs, call exit instead.\n #[rt(exchange_free)]\n fn rt_exchange_free(ptr: *c_char) {\n     rustrt::rust_upcall_exchange_free(ptr);\n@@ -47,6 +50,9 @@ fn rt_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     ret rustrt::rust_upcall_malloc(td, size);\n }\n \n+// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n+// inside a landing pad may corrupt the state of the exception handler. If a\n+// problem occurs, call exit instead.\n #[rt(free)]\n fn rt_free(ptr: *c_char) {\n     rustrt::rust_upcall_free(ptr);"}, {"sha": "beae7d59b7c0be5b24b8e470c7024ae0b6ad620a", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=539a160bb7873f7a373f8eeed7c49c5329d06b0f", "patch": "@@ -276,7 +276,7 @@ fn alloca_zeroed(cx: block, t: TypeRef) -> ValueRef {\n fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"alloca\");\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n-    let initcx = raw_block(cx.fcx, cx.fcx.llstaticallocas);\n+    let initcx = raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n     let p = Alloca(initcx, t);\n     if zero { Store(initcx, C_null(t), p); }\n     ret p;\n@@ -294,7 +294,7 @@ fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) -> block {\n fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(~\"arrayalloca\");\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n-    ret ArrayAlloca(raw_block(cx.fcx, cx.fcx.llstaticallocas), t, v);\n+    ret ArrayAlloca(raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n }\n \n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n@@ -3228,6 +3228,11 @@ fn need_invoke(bcx: block) -> bool {\n         ret false;\n     }\n \n+    // Avoid using invoke if we are already inside a landing pad.\n+    if bcx.is_lpad {\n+        ret false;\n+    }\n+\n     if have_cached_lpad(bcx) {\n         ret true;\n     }\n@@ -3291,7 +3296,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n         alt copy inf.landing_pad {\n           some(target) { cached = some(target); }\n           none {\n-            pad_bcx = sub_block(bcx, ~\"unwind\");\n+            pad_bcx = lpad_block(bcx, ~\"unwind\");\n             inf.landing_pad = some(pad_bcx.llbb);\n           }\n         }\n@@ -4107,15 +4112,16 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n // You probably don't want to use this one. See the\n // next three functions instead.\n fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n-             name: ~str, opt_node_info: option<node_info>) -> block {\n+             is_lpad: bool, name: ~str, opt_node_info: option<node_info>)\n+    -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n         cx.ccx.names(name)\n     } else { ~\"\" };\n     let llbb: BasicBlockRef = str::as_c_str(s, |buf| {\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n-    let bcx = mk_block(llbb, parent, kind, opt_node_info, cx);\n+    let bcx = mk_block(llbb, parent, kind, is_lpad, opt_node_info, cx);\n     do option::iter(parent) |cx| {\n         if cx.unreachable { Unreachable(bcx); }\n     };\n@@ -4129,14 +4135,14 @@ fn simple_block_scope() -> block_kind {\n \n // Use this when you're at the top block of a function or the like.\n fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n-    ret new_block(fcx, none, simple_block_scope(),\n+    ret new_block(fcx, none, simple_block_scope(), false,\n                   ~\"function top level\", opt_node_info);\n }\n \n fn scope_block(bcx: block,\n                opt_node_info: option<node_info>,\n                n: ~str) -> block {\n-    ret new_block(bcx.fcx, some(bcx), simple_block_scope(),\n+    ret new_block(bcx.fcx, some(bcx), simple_block_scope(), bcx.is_lpad,\n                   n, opt_node_info);\n }\n \n@@ -4147,17 +4153,21 @@ fn loop_scope_block(bcx: block, loop_break: block, n: ~str,\n         mut cleanups: ~[],\n         mut cleanup_paths: ~[],\n         mut landing_pad: none\n-    }), n, opt_node_info);\n+    }), bcx.is_lpad, n, opt_node_info);\n }\n \n+// Use this when creating a block for the inside of a landing pad.\n+fn lpad_block(bcx: block, n: ~str) -> block {\n+    new_block(bcx.fcx, some(bcx), block_non_scope, true, n, none)\n+}\n \n // Use this when you're making a general CFG BB within a scope.\n fn sub_block(bcx: block, n: ~str) -> block {\n-    new_block(bcx.fcx, some(bcx), block_non_scope, n, none)\n+    new_block(bcx.fcx, some(bcx), block_non_scope, bcx.is_lpad, n, none)\n }\n \n-fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n-    mk_block(llbb, none, block_non_scope, none, fcx)\n+fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n+    mk_block(llbb, none, block_non_scope, is_lpad, none, fcx)\n }\n \n \n@@ -4475,14 +4485,14 @@ fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: ~[ast::arg],\n fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(~\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n-    let ret_cx = raw_block(fcx, fcx.llreturn);\n+    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n     RetVoid(ret_cx);\n }\n \n fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(~\"tie_up_header_blocks\");\n-    Br(raw_block(fcx, fcx.llstaticallocas), fcx.llloadenv);\n-    Br(raw_block(fcx, fcx.llloadenv), lltop);\n+    Br(raw_block(fcx, false, fcx.llstaticallocas), fcx.llloadenv);\n+    Br(raw_block(fcx, false, fcx.llloadenv), lltop);\n }\n \n enum self_arg { impl_self(ty::t), no_self, }"}, {"sha": "5cfc1d98ec6e287d3b49751c5854261190abbe6e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=539a160bb7873f7a373f8eeed7c49c5329d06b0f", "patch": "@@ -319,7 +319,7 @@ fn load_environment(fcx: fn_ctxt,\n                     load_ret_handle: bool,\n                     ck: ty::closure_kind) {\n     let _icx = fcx.insn_ctxt(~\"closure::load_environment\");\n-    let bcx = raw_block(fcx, fcx.llloadenv);\n+    let bcx = raw_block(fcx, false, fcx.llloadenv);\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);"}, {"sha": "fbea25964e68f46b0980f2cf688c4da094e07d01", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=539a160bb7873f7a373f8eeed7c49c5329d06b0f", "patch": "@@ -393,17 +393,19 @@ class block_ {\n     let parent: option<block>;\n     // The 'kind' of basic block this is.\n     let kind: block_kind;\n+    // Is this block part of a landing pad?\n+    let is_lpad: bool;\n     // info about the AST node this block originated from, if any\n     let node_info: option<node_info>;\n     // The function context for the function to which this block is\n     // attached.\n     let fcx: fn_ctxt;\n     new(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n-        node_info: option<node_info>, fcx: fn_ctxt) {\n+        is_lpad: bool, node_info: option<node_info>, fcx: fn_ctxt) {\n         // sigh\n         self.llbb = llbb; self.terminated = false; self.unreachable = false;\n-        self.parent = parent; self.kind = kind; self.node_info = node_info;\n-        self.fcx = fcx;\n+        self.parent = parent; self.kind = kind; self.is_lpad = is_lpad;\n+        self.node_info = node_info; self.fcx = fcx;\n     }\n }\n \n@@ -412,8 +414,9 @@ class block_ {\n enum block = @block_;\n \n fn mk_block(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n-         node_info: option<node_info>, fcx: fn_ctxt) -> block {\n-   block(@block_(llbb, parent, kind, node_info, fcx))\n+            is_lpad: bool, node_info: option<node_info>, fcx: fn_ctxt)\n+    -> block {\n+    block(@block_(llbb, parent, kind, is_lpad, node_info, fcx))\n }\n \n // First two args are retptr, env"}, {"sha": "747549e78b82436a58ef5fb959bb835721550be2", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539a160bb7873f7a373f8eeed7c49c5329d06b0f/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=539a160bb7873f7a373f8eeed7c49c5329d06b0f", "patch": "@@ -537,7 +537,7 @@ fn build_wrap_fn_(ccx: @crate_ctxt,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Make sure our standard return block (that we didn't use) is terminated\n-    let ret_cx = raw_block(fcx, fcx.llreturn);\n+    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n     Unreachable(ret_cx);\n }\n "}]}