{"sha": "faf84263f2acd638801069beea0d4b9dd662c111", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZjg0MjYzZjJhY2Q2Mzg4MDEwNjliZWVhMGQ0YjlkZDY2MmMxMTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-11-21T20:47:14Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-08-20T21:27:50Z"}, "message": "create `Coercion` obligations given 2 unbound type variables\n\nMotivation: in upcoming commits, we are going to create a graph of the\ncoercion relationships between variables. We want to\ndistinguish *coercion* specifically from other sorts of subtyping, as\nit indicates values flowing from one place to another via assignment.", "tree": {"sha": "a741cbec1b5d8b91f868880d677e582e3c2ac4d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a741cbec1b5d8b91f868880d677e582e3c2ac4d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faf84263f2acd638801069beea0d4b9dd662c111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faf84263f2acd638801069beea0d4b9dd662c111", "html_url": "https://github.com/rust-lang/rust/commit/faf84263f2acd638801069beea0d4b9dd662c111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faf84263f2acd638801069beea0d4b9dd662c111/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "020655b90da83b0a037a9d3c987be17f04eedbc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/020655b90da83b0a037a9d3c987be17f04eedbc4", "html_url": "https://github.com/rust-lang/rust/commit/020655b90da83b0a037a9d3c987be17f04eedbc4"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "0b4df8e6d3cdd5d55bef2c4f4ebfcaf9cd14342b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/faf84263f2acd638801069beea0d4b9dd662c111/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faf84263f2acd638801069beea0d4b9dd662c111/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=faf84263f2acd638801069beea0d4b9dd662c111", "patch": "@@ -42,6 +42,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -50,7 +51,7 @@ use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TypeAndMut};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, Span};\n@@ -172,7 +173,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     kind: TypeVariableOriginKind::AdjustmentType,\n                     span: self.cause.span,\n                 });\n-                self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n+                self.coerce_from_inference_variable(diverging_ty, b, simple(Adjust::NeverToAny))\n             } else {\n                 success(simple(Adjust::NeverToAny)(b), b, vec![])\n             };\n@@ -182,7 +183,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // we have no information about the source type. This will always\n         // ultimately fall back to some form of subtyping.\n         if a.is_ty_var() {\n-            return self.coerce_from_inference_variable(a, b);\n+            return self.coerce_from_inference_variable(a, b, identity);\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -245,11 +246,53 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     /// Coercing *from* an inference variable. In this case, we have no information\n     /// about the source type, so we can't really do a true coercion and we always\n     /// fall back to subtyping (`unify_and`).\n-    fn coerce_from_inference_variable(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn coerce_from_inference_variable(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        make_adjustments: impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n+    ) -> CoerceResult<'tcx> {\n+        debug!(\"coerce_from_inference_variable(a={:?}, b={:?})\", a, b);\n         assert!(a.is_ty_var() && self.infcx.shallow_resolve(a) == a);\n         assert!(self.infcx.shallow_resolve(b) == b);\n \n-        self.unify_and(a, b, identity)\n+        if b.is_ty_var() {\n+            // Two unresolved type variables: create a `Coerce` predicate.\n+            let target_ty = if self.use_lub {\n+                self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::LatticeVariable,\n+                    span: self.cause.span,\n+                })\n+            } else {\n+                b\n+            };\n+\n+            let mut obligations = Vec::with_capacity(2);\n+            for &source_ty in &[a, b] {\n+                if source_ty != target_ty {\n+                    obligations.push(Obligation::new(\n+                        self.cause.clone(),\n+                        self.param_env,\n+                        ty::PredicateKind::Coerce(ty::CoercePredicate {\n+                            a: source_ty,\n+                            b: target_ty,\n+                        })\n+                        .to_predicate(self.tcx()),\n+                    ));\n+                }\n+            }\n+\n+            debug!(\n+                \"coerce_from_inference_variable: two inference variables, target_ty={:?}, obligations={:?}\",\n+                target_ty, obligations\n+            );\n+            let adjustments = make_adjustments(target_ty);\n+            InferResult::Ok(InferOk { value: (adjustments, target_ty), obligations })\n+        } else {\n+            // One unresolved type variable: just apply subtyping, we may be able\n+            // to do something useful.\n+            self.unify_and(a, b, make_adjustments)\n+        }\n     }\n \n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`."}]}