{"sha": "f4ee40ead271bffc1a251f03ccd60de4250f72e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZWU0MGVhZDI3MWJmZmMxYTI1MWYwM2NjZDYwZGU0MjUwZjcyZTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-05-25T21:42:22Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-05-26T09:33:53Z"}, "message": "Use lookup_locally_or_in_crate_store more often", "tree": {"sha": "e85ad3b1955498822e61bdddfdc6d3ef2bf1b9b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85ad3b1955498822e61bdddfdc6d3ef2bf1b9b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4ee40ead271bffc1a251f03ccd60de4250f72e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ee40ead271bffc1a251f03ccd60de4250f72e3", "html_url": "https://github.com/rust-lang/rust/commit/f4ee40ead271bffc1a251f03ccd60de4250f72e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4ee40ead271bffc1a251f03ccd60de4250f72e3/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7711002bb3eed4ecbc8c8da63c97681fd1588e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7711002bb3eed4ecbc8c8da63c97681fd1588e6", "html_url": "https://github.com/rust-lang/rust/commit/c7711002bb3eed4ecbc8c8da63c97681fd1588e6"}], "stats": {"total": 142, "additions": 54, "deletions": 88}, "files": [{"sha": "0908ffd249fe40ba880dffd64649d1a39caa5ed4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f4ee40ead271bffc1a251f03ccd60de4250f72e3", "patch": "@@ -1215,11 +1215,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n+          let trait_ref = ty::impl_trait_ref(tcx, local_def(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n-      ast::ItemImpl(unsafety, polarity, _, ref opt_trait, ref ty, ref ast_items) => {\n+      ast::ItemImpl(unsafety, polarity, _, _, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1269,8 +1269,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if opt_trait.is_some() {\n-            let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n+        if let Some(trait_ref) = ty::impl_trait_ref(tcx, local_def(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());"}, {"sha": "4a95320b3f7ffc5e5b65ad85ea12f8ce80b40d2e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 41, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f4ee40ead271bffc1a251f03ccd60de4250f72e3", "patch": "@@ -650,9 +650,7 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n-\n-    pub impl_trait_refs: RefCell<NodeMap<TraitRef<'tcx>>>,\n+    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n@@ -675,7 +673,6 @@ pub struct ctxt<'tcx> {\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n-    pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n@@ -2741,7 +2738,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         def_map: def_map,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n-        impl_trait_refs: RefCell::new(NodeMap()),\n+        impl_trait_refs: RefCell::new(DefIdMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         super_predicates: RefCell::new(DefIdMap()),\n@@ -2750,14 +2747,12 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n         rcache: RefCell::new(FnvHashMap()),\n-        short_names_cache: RefCell::new(FnvHashMap()),\n         tc_cache: RefCell::new(FnvHashMap()),\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n         enum_var_cache: RefCell::new(DefIdMap()),\n         impl_or_trait_items: RefCell::new(DefIdMap()),\n         trait_item_def_ids: RefCell::new(DefIdMap()),\n         trait_items_cache: RefCell::new(DefIdMap()),\n-        impl_trait_cache: RefCell::new(DefIdMap()),\n         ty_param_defs: RefCell::new(NodeMap()),\n         adjustments: RefCell::new(NodeMap()),\n         normalized_cache: RefCell::new(FnvHashMap()),\n@@ -4464,16 +4459,6 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n     }\n }\n \n-pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n-                                  -> ty::TraitRef<'tcx> {\n-    match cx.impl_trait_refs.borrow().get(&id) {\n-        Some(ty) => *ty,\n-        None => cx.sess.bug(\n-            &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n-                    cx.map.node_to_string(id)))\n-    }\n-}\n-\n pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     match node_id_to_type_opt(cx, id) {\n        Some(ty) => ty,\n@@ -5268,12 +5253,12 @@ pub fn associated_consts<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n /// the future).\n fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n                                           def_id: ast::DefId,\n-                                          map: &mut DefIdMap<V>,\n+                                          map: &RefCell<DefIdMap<V>>,\n                                           load_external: F) -> V where\n     V: Clone,\n     F: FnOnce() -> V,\n {\n-    match map.get(&def_id).cloned() {\n+    match map.borrow().get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n     }\n@@ -5282,7 +5267,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n         panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n-    map.insert(def_id, v.clone());\n+    map.borrow_mut().insert(def_id, v.clone());\n     v\n }\n \n@@ -5348,13 +5333,9 @@ pub fn custom_coerce_unsized_kind<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n \n pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 -> ImplOrTraitItem<'tcx> {\n-    lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n-                                     id,\n-                                     &mut *cx.impl_or_trait_items\n-                                             .borrow_mut(),\n-                                     || {\n-        csearch::get_impl_or_trait_item(cx, id)\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"impl_or_trait_items\", id, &cx.impl_or_trait_items,\n+        || csearch::get_impl_or_trait_item(cx, id))\n }\n \n /// Returns the parameter index that the given associated type corresponds to.\n@@ -5881,37 +5862,35 @@ pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n                               did: ast::DefId)\n                               -> TypeScheme<'tcx> {\n     lookup_locally_or_in_crate_store(\n-        \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n+        \"tcache\", did, &cx.tcache,\n         || csearch::get_type(cx, did))\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                               -> &'tcx TraitDef<'tcx> {\n-    memoized(&cx.trait_defs, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"trait_defs\", did, &cx.trait_defs,\n+        || cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n+    )\n }\n \n /// Given the did of an item, returns its full set of predicates.\n pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                 -> GenericPredicates<'tcx>\n {\n-    memoized(&cx.predicates, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        csearch::get_predicates(cx, did)\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"predicates\", did, &cx.predicates,\n+        || csearch::get_predicates(cx, did))\n }\n \n /// Given the did of a trait, returns its superpredicates.\n pub fn lookup_super_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                      -> GenericPredicates<'tcx>\n {\n-    memoized(&cx.super_predicates, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        csearch::get_super_predicates(cx, did)\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"super_predicates\", did, &cx.super_predicates,\n+        || csearch::get_super_predicates(cx, did))\n }\n \n pub fn predicates<'tcx>(\n@@ -6281,7 +6260,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n-        \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n+        \"item_variance_map\", item_id, &tcx.item_variance_map,\n         || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n "}, {"sha": "8ec406ff41b92b4f5a3ed7f62f111cbc6de93c5f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=f4ee40ead271bffc1a251f03ccd60de4250f72e3", "patch": "@@ -81,7 +81,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ty::impl_id_to_trait_ref(ccx.tcx, item.id);\n+                let trait_ref = ty::impl_trait_ref(ccx.tcx,\n+                                                   local_def(item.id)).unwrap();\n                 ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}"}, {"sha": "622c116cdb9bafddb6fc673ee25b665cea631684", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f4ee40ead271bffc1a251f03ccd60de4250f72e3", "patch": "@@ -36,7 +36,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n use syntax::ast::{Item, ItemImpl};\n-use syntax::ast::{LOCAL_CRATE, TraitRef};\n+use syntax::ast::{LOCAL_CRATE};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n@@ -100,11 +100,8 @@ struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-\n-        //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n-\n-        if let ItemImpl(_, _, _, ref opt_trait, _, _) = item.node {\n-            self.cc.check_implementation(item, opt_trait.as_ref())\n+        if let ItemImpl(..) = item.node {\n+            self.cc.check_implementation(item)\n         }\n \n         visit::walk_item(self, item);\n@@ -141,7 +138,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.check_implementations_of_coerce_unsized();\n     }\n \n-    fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n+    fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n         let self_type = ty::lookup_item_type(tcx, impl_did);\n@@ -151,8 +148,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        if opt_trait.is_some() {\n-            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx, item.id);\n+        if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n+                                                    impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n@@ -161,22 +158,13 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                  item.span,\n                                                  trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n-        }\n-\n-        // Add the implementation to the mapping from implementation to base\n-        // type def ID, if there is a base type for this implementation and\n-        // the implementation does not have any associated traits.\n-        match get_base_type_def_id(&self.inference_context,\n-                                   item.span,\n-                                   self_type.ty) {\n-            None => {\n-                // Nothing to do.\n-            }\n-            Some(base_type_def_id) => {\n-                // FIXME: Gather up default methods?\n-                if opt_trait.is_none() {\n-                    self.add_inherent_impl(base_type_def_id, impl_did);\n-                }\n+        } else {\n+            // Add the implementation to the mapping from implementation to base\n+            // type def ID, if there is a base type for this implementation and\n+            // the implementation does not have any associated traits.\n+            if let Some(base_type_def_id) = get_base_type_def_id(\n+                    &self.inference_context, item.span, self_type.ty) {\n+                self.add_inherent_impl(base_type_def_id, impl_did);\n             }\n         }\n \n@@ -267,7 +255,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n+            ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n@@ -287,10 +275,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }).collect();\n \n-                if opt_trait.is_some() {\n-                    let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n-                                                             item.id);\n-\n+                if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n+                                                            local_def(item.id)) {\n                     self.instantiate_default_methods(local_def(item.id),\n                                                      &trait_ref,\n                                                      &mut items);\n@@ -453,8 +439,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n \n             let source = ty::lookup_item_type(tcx, impl_did).ty;\n-            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n-                                                     impl_did.node);\n+            let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n+                                               impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n                    source.repr(tcx), target.repr(tcx));"}, {"sha": "2fba967b3b237780a43665900393a73a090c7ffe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4ee40ead271bffc1a251f03ccd60de4250f72e3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f4ee40ead271bffc1a251f03ccd60de4250f72e3", "patch": "@@ -820,15 +820,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n+            tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), Some(trait_ref));\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n@@ -926,14 +925,16 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n \n-            if let Some(ref ast_trait_ref) = *opt_trait_ref {\n-                let trait_ref =\n-                    astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                        &ExplicitRscope,\n-                                                        ast_trait_ref,\n-                                                        Some(selfty));\n-\n-                tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n+            if let &Some(ref ast_trait_ref) = opt_trait_ref {\n+                tcx.impl_trait_refs.borrow_mut().insert(\n+                    local_def(it.id),\n+                    Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                             &ExplicitRscope,\n+                                                             ast_trait_ref,\n+                                                             Some(selfty)))\n+                        );\n+            } else {\n+                tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), None);\n             }\n \n             enforce_impl_params_are_constrained(tcx,"}]}