{"sha": "14ff6411f0018c58de6a323dc8fb8bc46fc44356", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0ZmY2NDExZjAwMThjNThkZTZhMzIzZGM4ZmI4YmM0NmZjNDQzNTY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-15T13:12:49Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-15T13:12:49Z"}, "message": "make sure ByVal pointers act just like ByRef to a pointer", "tree": {"sha": "1790d0f0bde67aa30f011a39a2671154a64cc208", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1790d0f0bde67aa30f011a39a2671154a64cc208"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14ff6411f0018c58de6a323dc8fb8bc46fc44356", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYKwnRAAoJEFbW7qD8Z6xGeTAP/0ONpactk9GH+3IXp+iVRgws\nsK0y5TMbbeUCCqSCcvHG2tFd+HSihv2tMRSebBkeWjbcZXzSyduyt+wE0g550Qqp\nK0jVSHfs3mCiR+q8tNOK6vo5tPOoCj+6INmVwk6PzUXscEmCChR27Giog4jiog4E\nBGQ24+Vjccmh9stCXnIe+6y2tjYWyNq4tuzPAXxY88OnTuSswu7i8HnMJ21R1OwN\n7kmxxGig9Xv4sZEbUSdG4E52Jrpxkfp7vgF4Q4Jtx1UaKXpD/2dblovbwmCdd8b4\nwphAjn1H2Yd2EhLUZUFNNfevan09PvCsmyfN8uh9sQ4sJsNUJOdkuK8Dzjfs+RIJ\ndoSO7fAu779eQiXIVVXFjg3YElZU9Jrvv3ylWLFt5xOFpCKCiKxePiDKpSbI9NVB\nZLxRslXettanC8Gq67gFmmBYxqQJpvXapq4lyCSRffgBZVmFbmZWeEUIYOAHDNww\nCPFoWEOsYEyZ2XXjsOMxpZ0E4IArfoXlAhToAON3DhyFw9o5Bwyc5xdcadYg1Oqt\nixrurpsdIqfSUMxRVvtGjPE8QSBA1IlrL5pNl4n2Vtakj6RFNFnmWkEiLXIjFnTq\n16CyTZYYNamY4S6rjnvG9aVc+Nzi9FZnaBF1pmm7VRGOGo5Sv8dNPuyyq7wU7hIu\n/LoQtX6KgNhPByB4RjF8\n=Yiyg\n-----END PGP SIGNATURE-----", "payload": "tree 1790d0f0bde67aa30f011a39a2671154a64cc208\nparent 4a39c228df089e32cebea1b1aec8cd9694089574\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479215569 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479215569 +0100\n\nmake sure ByVal pointers act just like ByRef to a pointer"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14ff6411f0018c58de6a323dc8fb8bc46fc44356", "html_url": "https://github.com/rust-lang/rust/commit/14ff6411f0018c58de6a323dc8fb8bc46fc44356", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14ff6411f0018c58de6a323dc8fb8bc46fc44356/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a39c228df089e32cebea1b1aec8cd9694089574", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a39c228df089e32cebea1b1aec8cd9694089574", "html_url": "https://github.com/rust-lang/rust/commit/4a39c228df089e32cebea1b1aec8cd9694089574"}], "stats": {"total": 165, "additions": 77, "deletions": 88}, "files": [{"sha": "217a10a4c7bccb60d8fd53d49d3cceafddc49d26", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -21,10 +21,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.bits, ty, false),\n \n-            FnPtr | Ptr => {\n-                let ptr = val.expect_ptr(\"FnPtr- or Ptr-tagged PrimVal had no relocation\");\n-                self.cast_ptr(ptr, ty)\n-            }\n+            FnPtr | Ptr => self.cast_ptr(val.to_ptr(), ty),\n         }\n     }\n "}, {"sha": "791466f6908bfe402c2d7474eeb37b095ce466c6", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -963,33 +963,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Deref => {\n-                use interpreter::value::Value::*;\n+                let val = self.eval_and_read_lvalue(&proj.base)?;\n \n-                let val = match self.eval_and_read_lvalue(&proj.base)? {\n-                    ByRef(ptr) => self.read_value(ptr, base_ty)?,\n-                    v => v,\n+                let pointee_type = match base_ty.sty {\n+                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n+                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+                    ty::TyBox(ty) => ty,\n+                    _ => bug!(\"can only deref pointer types\"),\n                 };\n \n-                match val {\n-                    ByValPair(ptr, vtable)\n-                        if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n-                    => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        let vtable = vtable.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::Vtable(vtable))\n-                    }\n-\n-                    ByValPair(ptr, n) if ptr.try_as_ptr().is_some() => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::Length(n.expect_uint(\"slice length\")))\n-                    }\n+                trace!(\"deref to {} on {:?}\", pointee_type, val);\n \n-                    ByVal(ptr) if ptr.try_as_ptr().is_some() => {\n-                        let ptr = ptr.try_as_ptr().unwrap();\n-                        (ptr, LvalueExtra::None)\n-                    }\n-\n-                    _ => bug!(\"can't deref non pointer types\"),\n+                match self.tcx.struct_tail(pointee_type).sty {\n+                    ty::TyTrait(_) => {\n+                        let (ptr, vtable) = val.expect_ptr_vtable_pair(&self.memory)?;\n+                        (ptr, LvalueExtra::Vtable(vtable))\n+                    },\n+                    ty::TyStr | ty::TySlice(_) => {\n+                        let (ptr, len) = val.expect_slice(&self.memory)?;\n+                        (ptr, LvalueExtra::Length(len))\n+                    },\n+                    _ => (val.read_ptr(&self.memory)?, LvalueExtra::None),\n                 }\n             }\n "}, {"sha": "bc258574665d1e870615f7b750a09efc490f787e", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -124,15 +124,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"drop_in_place\" => {\n                 let ty = substs.type_at(0);\n+                trace!(\"drop in place on {}\", ty);\n                 let ptr_ty = self.tcx.mk_mut_ptr(ty);\n                 let lvalue = match self.follow_by_ref_value(arg_vals[0], ptr_ty)? {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value returned ByRef\"),\n-                    Value::ByVal(ptr) => Lvalue::from_ptr(ptr.expect_ptr(\"drop_in_place first arg not a pointer\")),\n+                    Value::ByVal(value) => Lvalue::from_ptr(value.to_ptr()),\n                     Value::ByValPair(ptr, extra) => Lvalue::Ptr {\n-                        ptr: ptr.expect_ptr(\"drop_in_place first arg not a pointer\"),\n-                        extra: match extra.try_as_ptr() {\n-                            Some(vtable) => LvalueExtra::Vtable(vtable),\n-                            None => LvalueExtra::Length(extra.expect_uint(\"either pointer or not, but not neither\")),\n+                        ptr: ptr.to_ptr(),\n+                        extra: match self.tcx.struct_tail(ty).sty {\n+                            ty::TyTrait(_) => LvalueExtra::Vtable(extra.to_ptr()),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ptr_ty),\n                         },\n                     },\n                 };\n@@ -440,7 +442,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\") as u64;\n-                    let len = value.expect_slice_len(&self.memory)?;\n+                    let (_, len) = value.expect_slice(&self.memory)?;\n                     let align = self.type_align(elem_ty);\n                     Ok((len * elem_size, align as u64))\n                 }"}, {"sha": "fbd9e76a07f2418cdbe02eb24c51830c655cf4ae", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -85,8 +85,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n-                        let fn_ptr = self.eval_operand_to_primval(func)?\n-                            .expect_fn_ptr(\"TyFnPtr callee did not evaluate to FnPtr\");\n+                        let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr();\n                         let (def_id, substs, fn_ty) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n                             return Err(EvalError::FunctionPointerTyMismatch(fn_ty, bare_fn_ty));\n@@ -542,14 +541,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n                     Value::ByVal(ptr) => {\n                         assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.expect_ptr(\"value of Box type must be a pointer\");\n+                        let contents_ptr = ptr.to_ptr();\n                         self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n                     },\n                     Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.expect_ptr(\"value of Box type must be a pointer\");\n-                        let extra = match extra.try_as_ptr() {\n-                            Some(vtable) => LvalueExtra::Vtable(vtable),\n-                            None => LvalueExtra::Length(extra.expect_uint(\"slice length\")),\n+                        let ptr = prim_ptr.to_ptr();\n+                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n+                            ty::TyTrait(_) => LvalueExtra::Vtable(extra.to_ptr()),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.try_as_uint()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n                         };\n                         self.drop(\n                             Lvalue::Ptr {"}, {"sha": "fa89d02ad77d12dc151cff4248a99c5813d307bc", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -22,10 +22,7 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n-\n-            ByVal(ptr) | ByValPair(ptr, _) => {\n-                Ok(ptr.try_as_ptr().expect(\"unimplemented: `read_ptr` on non-ptr primval\"))\n-            }\n+            ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.to_ptr()),\n         }\n     }\n \n@@ -35,29 +32,29 @@ impl<'a, 'tcx: 'a> Value {\n     ) -> EvalResult<'tcx, (Pointer, Pointer)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => {\n-                let ptr = mem.read_ptr(ptr)?;\n-                let vtable = mem.read_ptr(ptr.offset(mem.pointer_size() as isize))?;\n+            ByRef(ref_ptr) => {\n+                let ptr = mem.read_ptr(ref_ptr)?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size() as isize))?;\n                 Ok((ptr, vtable))\n             }\n \n-            ByValPair(ptr, vtable)\n-                if ptr.try_as_ptr().is_some() && vtable.try_as_ptr().is_some()\n-            => {\n-                let ptr = ptr.try_as_ptr().unwrap();\n-                let vtable = vtable.try_as_ptr().unwrap();\n-                Ok((ptr, vtable))\n-            }\n+            ByValPair(ptr, vtable) => Ok((ptr.to_ptr(), vtable.to_ptr())),\n \n             _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n         }\n     }\n \n-    pub(super) fn expect_slice_len(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, u64> {\n+    pub(super) fn expect_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n-            ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n-            ByValPair(_, val) if val.kind.is_int() => Ok(val.bits),\n+            ByRef(ref_ptr) => {\n+                let ptr = mem.read_ptr(ref_ptr)?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size() as isize))?;\n+                Ok((ptr, len))\n+            },\n+            ByValPair(ptr, val) => {\n+                Ok((ptr.to_ptr(), val.try_as_uint()?))\n+            },\n             _ => unimplemented!(),\n         }\n     }"}, {"sha": "348437f50b6460e232b246afa17804225d4f60d2", "filename": "src/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -533,8 +533,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_primval(&mut self, dest: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        if let Some(ptr) = val.try_as_ptr() {\n-            return self.write_ptr(dest, ptr);\n+        if let Some(alloc_id) = val.relocation {\n+            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits as usize));\n         }\n \n         use primval::PrimValKind::*;"}, {"sha": "15cc88ca4cf9ec53d3fb93fafb9b8462842349a2", "filename": "src/primval.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -137,15 +137,19 @@ impl PrimVal {\n         bits_to_f64(self.bits)\n     }\n \n-    pub fn try_as_ptr(self) -> Option<Pointer> {\n+    pub fn to_ptr(self) -> Pointer {\n         self.relocation.map(|alloc_id| {\n             Pointer::new(alloc_id, self.bits as usize)\n-        })\n+        }).unwrap_or_else(|| Pointer::from_int(self.bits as usize))\n+    }\n+\n+    pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {\n+        self.to_ptr().to_int().map(|val| val as u64)\n     }\n \n     pub fn expect_uint(self, error_msg: &str) -> u64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as u64\n+        if let Ok(int) = self.try_as_uint() {\n+            return int;\n         }\n \n         use self::PrimValKind::*;\n@@ -156,8 +160,8 @@ impl PrimVal {\n     }\n \n     pub fn expect_int(self, error_msg: &str) -> i64 {\n-        if let Some(ptr) = self.try_as_ptr() {\n-            return ptr.to_int().expect(\"non abstract ptr\") as i64\n+        if let Ok(int) = self.try_as_uint() {\n+            return int as i64;\n         }\n \n         use self::PrimValKind::*;\n@@ -188,15 +192,6 @@ impl PrimVal {\n             _ => bug!(\"{}\", error_msg),\n         }\n     }\n-\n-    pub fn expect_ptr(self, error_msg: &str) -> Pointer {\n-        self.try_as_ptr().expect(error_msg)\n-    }\n-\n-    /// FIXME(solson): Refactored into a duplicate of `expect_ptr`. Investigate removal.\n-    pub fn expect_fn_ptr(self, error_msg: &str) -> Pointer {\n-        self.try_as_ptr().expect(error_msg)\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -277,19 +272,13 @@ pub fn binary_op<'tcx>(\n     use rustc::mir::BinOp::*;\n     use self::PrimValKind::*;\n \n-    match (left.try_as_ptr(), right.try_as_ptr()) {\n-        (Some(left_ptr), Some(right_ptr)) => {\n-            if left_ptr.alloc_id != right_ptr.alloc_id {\n-                return Ok((unrelated_ptr_ops(bin_op)?, false));\n-            }\n-\n-            // If the pointers are into the same allocation, fall through to the more general match\n-            // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n-            // in this case.\n-        }\n-\n-        (None, None) => {}\n-        _ => return Err(EvalError::ReadPointerAsBytes),\n+    // If the pointers are into the same allocation, fall through to the more general match\n+    // later, which will do comparisons on the `bits` fields, which are the pointer offsets\n+    // in this case.\n+    let left_ptr = left.to_ptr();\n+    let right_ptr = right.to_ptr();\n+    if left_ptr.alloc_id != right_ptr.alloc_id {\n+        return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n     }\n \n     let (l, r) = (left.bits, right.bits);\n@@ -376,12 +365,15 @@ pub fn binary_op<'tcx>(\n     Ok((val, false))\n }\n \n-fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp) -> EvalResult<'tcx, PrimVal> {\n+fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {\n     use rustc::mir::BinOp::*;\n     match bin_op {\n         Eq => Ok(PrimVal::from_bool(false)),\n         Ne => Ok(PrimVal::from_bool(true)),\n         Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n+        _ if left.to_int().is_ok() ^ right.to_int().is_ok() => {\n+            Err(EvalError::ReadPointerAsBytes)\n+        },\n         _ => bug!(),\n     }\n }"}, {"sha": "dc39f7dda1b638dac4136c1ba8fa2e82ff4f53ca", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14ff6411f0018c58de6a323dc8fb8bc46fc44356/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff6411f0018c58de6a323dc8fb8bc46fc44356/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=14ff6411f0018c58de6a323dc8fb8bc46fc44356", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let g = unsafe {\n+        std::mem::transmute::<usize, fn(i32)>(42)\n+    };\n+\n+    g(42) //~ ERROR tried to use an integer pointer or a dangling pointer as a function pointer\n+}"}]}