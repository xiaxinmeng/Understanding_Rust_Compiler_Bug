{"sha": "4dc67c5e6af76eab83b93e5b494d3073d78229db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYzY3YzVlNmFmNzZlYWI4M2I5M2U1YjQ5NGQzMDczZDc4MjI5ZGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-16T01:04:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-16T19:22:56Z"}, "message": "rustc: Implement intra-crate static methods on anonymous trait implementations.", "tree": {"sha": "5827467fdcef1642e2cd9eeb95c0d2fcd38b12f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5827467fdcef1642e2cd9eeb95c0d2fcd38b12f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dc67c5e6af76eab83b93e5b494d3073d78229db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc67c5e6af76eab83b93e5b494d3073d78229db", "html_url": "https://github.com/rust-lang/rust/commit/4dc67c5e6af76eab83b93e5b494d3073d78229db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dc67c5e6af76eab83b93e5b494d3073d78229db/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b38092e9a2b5965ab8b8e73580e4d39ed701330a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b38092e9a2b5965ab8b8e73580e4d39ed701330a", "html_url": "https://github.com/rust-lang/rust/commit/b38092e9a2b5965ab8b8e73580e4d39ed701330a"}], "stats": {"total": 421, "additions": 312, "deletions": 109}, "files": [{"sha": "f522cca7a9957ec5f712eb1bbae4ae4ecf7ec458", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 297, "deletions": 109, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/4dc67c5e6af76eab83b93e5b494d3073d78229db/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc67c5e6af76eab83b93e5b494d3073d78229db/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=4dc67c5e6af76eab83b93e5b494d3073d78229db", "patch": "@@ -9,9 +9,8 @@ use syntax::ast::{_mod, add, arm};\n use syntax::ast::{bind_by_ref, bind_by_implicit_ref, bind_by_value};\n use syntax::ast::{bitand, bitor, bitxor};\n use syntax::ast::{blk, bound_const, bound_copy, bound_owned, bound_send};\n-use syntax::ast::{bound_trait, binding_mode,\n-                     capture_clause, class_ctor, class_dtor};\n-use syntax::ast::{crate, crate_num, decl_item};\n+use syntax::ast::{bound_trait, binding_mode, capture_clause, class_ctor};\n+use syntax::ast::{class_dtor, crate, crate_num, decl_item};\n use syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n use syntax::ast::{def_foreign_mod, def_id, def_label, def_local, def_mod};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n@@ -294,6 +293,35 @@ enum EnumVariantOrConstResolution {\n     EnumVariantOrConstNotFound\n }\n \n+// Specifies how duplicates should be handled when adding a child item if\n+// another item exists with the same name in some namespace.\n+enum DuplicateCheckingMode {\n+    ForbidDuplicateModules,\n+    ForbidDuplicateTypes,\n+    ForbidDuplicateValues,\n+    ForbidDuplicateTypesAndValues,\n+    OverwriteDuplicates\n+}\n+\n+impl DuplicateCheckingMode : cmp::Eq {\n+    pure fn eq(other: &DuplicateCheckingMode) -> bool {\n+        (self as uint) == (*other as uint)\n+    }\n+    pure fn ne(other: &DuplicateCheckingMode) -> bool { !self.eq(other) }\n+}\n+\n+// Returns the namespace associated with the given duplicate checking mode,\n+// or fails for OverwriteDuplicates. This is used for error messages.\n+fn namespace_for_duplicate_checking_mode(mode: DuplicateCheckingMode) ->\n+        Namespace {\n+    match mode {\n+        ForbidDuplicateModules | ForbidDuplicateTypes |\n+        ForbidDuplicateTypesAndValues => TypeNS,\n+        ForbidDuplicateValues => ValueNS,\n+        OverwriteDuplicates => fail ~\"OverwriteDuplicates has no namespace\"\n+    }\n+}\n+\n /// One local scope.\n struct Rib {\n     bindings: HashMap<ident,def_like>,\n@@ -490,9 +518,10 @@ impl Privacy : cmp::Eq {\n }\n \n // Records a possibly-private type definition.\n-enum TypeNsDef {\n-    ModuleDef(Privacy, @Module),\n-    TypeDef(Privacy, def)\n+struct TypeNsDef {\n+    mut privacy: Privacy,\n+    mut module_def: Option<@Module>,\n+    mut type_def: Option<def>\n }\n \n // Records a possibly-private value definition.\n@@ -508,7 +537,7 @@ struct NameBindings {\n     mut value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n \n     // For error reporting\n-    // XXX: Merge me into TypeDef and ValueDef.\n+    // FIXME (#3783): Merge me into TypeNsDef and ValueNsDef.\n     mut type_span: Option<span>,\n     mut value_span: Option<span>,\n }\n@@ -521,16 +550,46 @@ impl NameBindings {\n                      def_id: Option<def_id>,\n                      legacy_exports: bool,\n                      sp: span) {\n-        if self.type_def.is_none() {\n-            let module_ = @Module(parent_link, def_id, legacy_exports);\n-            self.type_def = Some(ModuleDef(privacy, module_));\n-            self.type_span = Some(sp);\n+        // Merges the module with the existing type def or creates a new one.\n+        let module_ = @Module(parent_link, def_id, legacy_exports);\n+        match self.type_def {\n+            None => {\n+                self.type_def = Some(TypeNsDef {\n+                    privacy: privacy,\n+                    module_def: Some(module_),\n+                    type_def: None\n+                });\n+            }\n+            Some(copy type_def) => {\n+                self.type_def = Some(TypeNsDef {\n+                    privacy: privacy,\n+                    module_def: Some(module_),\n+                    .. type_def\n+                });\n+            }\n         }\n+        self.type_span = Some(sp);\n     }\n \n     /// Records a type definition.\n     fn define_type(privacy: Privacy, def: def, sp: span) {\n-        self.type_def = Some(TypeDef(privacy, def));\n+        // Merges the type with the existing type def or creates a new one.\n+        match self.type_def {\n+            None => {\n+                self.type_def = Some(TypeNsDef {\n+                    privacy: privacy,\n+                    module_def: None,\n+                    type_def: Some(def)\n+                });\n+            }\n+            Some(copy type_def) => {\n+                self.type_def = Some(TypeNsDef {\n+                    privacy: privacy,\n+                    type_def: Some(def),\n+                    .. type_def\n+                });\n+            }\n+        }\n         self.type_span = Some(sp);\n     }\n \n@@ -543,8 +602,8 @@ impl NameBindings {\n     /// Returns the module node if applicable.\n     fn get_module_if_available() -> Option<@Module> {\n         match self.type_def {\n-            Some(ModuleDef(_, module_)) => return Some(module_),\n-            None | Some(TypeDef(_, _))  => return None,\n+            Some(type_def) => type_def.module_def,\n+            None => None\n         }\n     }\n \n@@ -553,12 +612,12 @@ impl NameBindings {\n      * definition.\n      */\n     fn get_module() -> @Module {\n-        match self.type_def {\n-            None | Some(TypeDef(*)) => {\n+        match self.get_module_if_available() {\n+            None => {\n                 fail ~\"get_module called on a node with no module \\\n                        definition!\"\n             }\n-            Some(ModuleDef(_, module_)) => module_\n+            Some(module_def) => module_def\n         }\n     }\n \n@@ -574,10 +633,23 @@ impl NameBindings {\n             TypeNS => {\n                 match self.type_def {\n                     None => None,\n-                    Some(ModuleDef(_, module_)) => {\n-                        module_.def_id.map(|def_id| def_mod(*def_id))\n+                    Some(type_def) => {\n+                        // FIXME (#3784): This is reallllly questionable.\n+                        // Perhaps the right thing to do is to merge def_mod\n+                        // and def_ty.\n+                        match type_def.type_def {\n+                            Some(type_def) => Some(type_def),\n+                            None => {\n+                                match type_def.module_def {\n+                                    Some(module_def) => {\n+                                        module_def.def_id.map(|def_id|\n+                                            def_mod(*def_id))\n+                                    }\n+                                    None => None\n+                                }\n+                            }\n+                        }\n                     }\n-                    Some(TypeDef(_, def)) => Some(def)\n                 }\n             }\n             ValueNS => {\n@@ -594,8 +666,7 @@ impl NameBindings {\n             TypeNS => {\n                 match self.type_def {\n                     None => None,\n-                    Some(ModuleDef(privacy, _)) | Some(TypeDef(privacy, _)) =>\n-                        Some(privacy)\n+                    Some(type_def) => Some(type_def.privacy)\n                 }\n             }\n             ValueNS => {\n@@ -882,9 +953,7 @@ impl Resolver {\n      */\n     fn add_child(name: ident,\n                  reduced_graph_parent: ReducedGraphParent,\n-                 // Pass in the namespaces for the child item so that we can\n-                 // check for duplicate items in the same namespace\n-                 ns: ~[Namespace],\n+                 duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: span)\n               -> (@NameBindings, ReducedGraphParent) {\n@@ -904,29 +973,67 @@ impl Resolver {\n         let new_parent = ModuleReducedGraphParent(module_);\n         match module_.children.find(name) {\n             None => {\n-              let child = @NameBindings();\n-              module_.children.insert(name, child);\n-              return (child, new_parent);\n+                let child = @NameBindings();\n+                module_.children.insert(name, child);\n+                return (child, new_parent);\n             }\n             Some(child) => {\n-              // We don't want to complain if the multiple definitions\n-              // are in different namespaces.\n-              match ns.find(|n| child.defined_in_namespace(n)) {\n-                Some(ns) => {\n-                  self.session.span_err(sp,\n-                       fmt!(\"Duplicate definition of %s %s\",\n-                            namespace_to_str(ns),\n-                            self.session.str_of(name)));\n-                  do child.span_for_namespace(ns).iter() |sp| {\n-                      self.session.span_note(*sp,\n-                           fmt!(\"First definition of %s %s here:\",\n-                                namespace_to_str(ns),\n-                                self.session.str_of(name)));\n-                  }\n+                // Enforce the duplicate checking mode. If we're requesting\n+                // duplicate module checking, check that there isn't a module\n+                // in the module with the same name. If we're requesting\n+                // duplicate type checking, check that there isn't a type in\n+                // the module with the same name. If we're requesting\n+                // duplicate value checking, check that there isn't a value in\n+                // the module with the same name. If we're requesting\n+                // duplicate type checking and duplicate value checking, check\n+                // that there isn't a duplicate type and a duplicate value\n+                // with the same name. If no duplicate checking was requested\n+                // at all, do nothing.\n+\n+                let mut is_duplicate = false;\n+                match duplicate_checking_mode {\n+                    ForbidDuplicateModules => {\n+                        is_duplicate =\n+                            child.get_module_if_available().is_some();\n+                    }\n+                    ForbidDuplicateTypes => {\n+                        match child.def_for_namespace(TypeNS) {\n+                            Some(def_mod(_)) | None => {}\n+                            Some(_) => is_duplicate = true\n+                        }\n+                    }\n+                    ForbidDuplicateValues => {\n+                        is_duplicate = child.defined_in_namespace(ValueNS);\n+                    }\n+                    ForbidDuplicateTypesAndValues => {\n+                        match child.def_for_namespace(TypeNS) {\n+                            Some(def_mod(_)) | None => {}\n+                            Some(_) => is_duplicate = true\n+                        };\n+                        if child.defined_in_namespace(ValueNS) {\n+                            is_duplicate = true;\n+                        }\n+                    }\n+                    OverwriteDuplicates => {}\n+                }\n+                if duplicate_checking_mode != OverwriteDuplicates &&\n+                        is_duplicate {\n+                    // Return an error here by looking up the namespace that\n+                    // had the duplicate.\n+                    let ns = namespace_for_duplicate_checking_mode(\n+                        duplicate_checking_mode);\n+                    self.session.span_err(sp,\n+                        fmt!(\"duplicate definition of %s %s\",\n+                             namespace_to_str(ns),\n+                             self.session.str_of(name)));\n+                    do child.span_for_namespace(ns).iter() |sp| {\n+                        self.session.span_note(*sp,\n+                             fmt!(\"first definition of %s %s here:\",\n+                                  namespace_to_str(ns),\n+                                  self.session.str_of(name)));\n+                    }\n                 }\n-                _ => {}\n-              }\n-              return (child, new_parent);\n+                return (child, new_parent);\n             }\n         }\n     }\n@@ -987,7 +1094,7 @@ impl Resolver {\n             item_mod(module_) => {\n                 let legacy = has_legacy_export_attr(item.attrs);\n                 let (name_bindings, new_parent) =\n-                    self.add_child(ident, parent, ~[TypeNS], sp);\n+                    self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(new_parent, ident);\n                 let def_id = { crate: 0, node: item.id };\n@@ -999,12 +1106,14 @@ impl Resolver {\n \n                 visit_mod(module_, sp, item.id, new_parent, visitor);\n             }\n+\n             item_foreign_mod(fm) => {\n                 let legacy = has_legacy_export_attr(item.attrs);\n                 let new_parent = match fm.sort {\n                     named => {\n                         let (name_bindings, new_parent) =\n-                            self.add_child(ident, parent, ~[TypeNS], sp);\n+                            self.add_child(ident, parent,\n+                                           ForbidDuplicateModules, sp);\n \n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n@@ -1028,15 +1137,15 @@ impl Resolver {\n \n             // These items live in the value namespace.\n             item_const(*) => {\n-              let (name_bindings, _) = self.add_child(ident, parent,\n-                                                      ~[ValueNS], sp);\n+                let (name_bindings, _) =\n+                    self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n                 (*name_bindings).define_value\n                     (privacy, def_const(local_def(item.id)), sp);\n             }\n             item_fn(_, purity, _, _) => {\n-              let (name_bindings, new_parent) = self.add_child(ident, parent,\n-                                                        ~[ValueNS], sp);\n+              let (name_bindings, new_parent) =\n+                self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n                 let def = def_fn(local_def(item.id), purity);\n                 (*name_bindings).define_value(privacy, def, sp);\n@@ -1045,17 +1154,16 @@ impl Resolver {\n \n             // These items live in the type namespace.\n             item_ty(*) => {\n-              let (name_bindings, _) = self.add_child(ident, parent,\n-                                                      ~[TypeNS], sp);\n+                let (name_bindings, _) =\n+                    self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 (*name_bindings).define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n             }\n \n             item_enum(enum_definition, _) => {\n-\n-              let (name_bindings, new_parent) = self.add_child(ident, parent,\n-                                                               ~[TypeNS], sp);\n+                let (name_bindings, new_parent) =\n+                    self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 (*name_bindings).define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n@@ -1072,7 +1180,7 @@ impl Resolver {\n             // These items live in both the type and value namespaces.\n             item_class(*) => {\n                 let (name_bindings, new_parent) =\n-                    self.add_child(ident, parent, ~[TypeNS], sp);\n+                    self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 (*name_bindings).define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n@@ -1083,13 +1191,75 @@ impl Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(*) => {\n+            item_impl(_, trait_ref_opt, ty, methods) => {\n+                // If this implements an anonymous trait and it has static\n+                // methods, then add all the static methods within to a new\n+                // module, if the type was defined within this module.\n+                //\n+                // FIXME (#3785): This is quite unsatisfactory. Perhaps we\n+                // should modify anonymous traits to only be implementable in\n+                // the same module that declared the type.\n+\n+                // Bail out early if there are no static methods.\n+                let mut has_static_methods = false;\n+                for methods.each |method| {\n+                    match method.self_ty.node {\n+                        sty_static => has_static_methods = true,\n+                        _ => {}\n+                    }\n+                }\n+\n+                // If there are static methods, then create the module\n+                // and add them.\n+                match (trait_ref_opt, ty) {\n+                    (None, @{ id: _, node: ty_path(path, _), span: _ }) if\n+                            has_static_methods && path.idents.len() == 1 => {\n+                        // Create the module.\n+                        let name = path_to_ident(path);\n+                        let (name_bindings, new_parent) =\n+                            self.add_child(name,\n+                                           parent,\n+                                           ForbidDuplicateModules,\n+                                           sp);\n+\n+                        let parent_link = self.get_parent_link(new_parent,\n+                                                               ident);\n+                        let def_id = local_def(item.id);\n+                        name_bindings.define_module(privacy, parent_link,\n+                                                    Some(def_id), false, sp);\n+\n+                        let new_parent = ModuleReducedGraphParent(\n+                            name_bindings.get_module());\n+\n+                        // For each static method...\n+                        for methods.each |method| {\n+                            match method.self_ty.node {\n+                                sty_static => {\n+                                    // Add the static method to the module.\n+                                    let ident = method.ident;\n+                                    let (method_name_bindings, _) =\n+                                        self.add_child(ident,\n+                                                       new_parent,\n+                                                       ForbidDuplicateValues,\n+                                                       method.span);\n+                                    let def = def_fn(local_def(method.id),\n+                                                     method.purity);\n+                                    method_name_bindings.define_value(\n+                                        Public, def, method.span);\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n                 visit_item(item, parent, visitor);\n             }\n \n             item_trait(_, _, methods) => {\n-              let (name_bindings, new_parent) = self.add_child(ident, parent,\n-                                                               ~[TypeNS], sp);\n+                let (name_bindings, new_parent) =\n+                    self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n                 // Add the names of all the methods to the trait info.\n                 let method_names = @HashMap();\n@@ -1103,8 +1273,8 @@ impl Resolver {\n                       sty_static => {\n                         // which parent to use??\n                         let (method_name_bindings, _) =\n-                            self.add_child(ident, new_parent, ~[ValueNS],\n-                                           ty_m.span);\n+                            self.add_child(ident, new_parent,\n+                                           ForbidDuplicateValues, ty_m.span);\n                         let def = def_static_method(local_def(ty_m.id),\n                                                     local_def(item.id),\n                                                     ty_m.purity);\n@@ -1142,7 +1312,7 @@ impl Resolver {\n                                        &&visitor: vt<ReducedGraphParent>) {\n \n         let ident = variant.node.name;\n-        let (child, _) = self.add_child(ident, parent, ~[ValueNS],\n+        let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                         variant.span);\n \n         let privacy;\n@@ -1324,7 +1494,7 @@ impl Resolver {\n                 match find_use_stmt_cnum(self.session.cstore, node_id) {\n                     Some(crate_id) => {\n                         let (child_name_bindings, new_parent) =\n-                            self.add_child(name, parent, ~[TypeNS],\n+                            self.add_child(name, parent, ForbidDuplicateTypes,\n                                            view_item.span);\n \n                         let def_id = { crate: crate_id, node: 0 };\n@@ -1355,7 +1525,8 @@ impl Resolver {\n \n         let name = foreign_item.ident;\n         let (name_bindings, new_parent) =\n-            self.add_child(name, parent, ~[ValueNS], foreign_item.span);\n+            self.add_child(name, parent, ForbidDuplicateValues,\n+                           foreign_item.span);\n \n         match foreign_item.node {\n             foreign_item_fn(_, purity, type_parameters) => {\n@@ -1408,7 +1579,13 @@ impl Resolver {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n             match copy child_name_bindings.type_def {\n-              None => {\n+              Some(TypeNsDef { module_def: Some(copy module_def), _ }) => {\n+                debug!(\"(building reduced graph for external crate) \\\n+                        already created module\");\n+                module_def.def_id = Some(def_id);\n+                modules.insert(def_id, module_def);\n+              }\n+              Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         %s\", final_ident);\n@@ -1451,16 +1628,6 @@ impl Resolver {\n                   }\n                 }\n               }\n-              Some(ModuleDef(_, module_)) => {\n-                debug!(\"(building reduced graph for \\\n-                        external crate) already created \\\n-                        module\");\n-                module_.def_id = Some(def_id);\n-                modules.insert(def_id, module_);\n-              }\n-              Some(TypeDef(*)) => {\n-                self.session.bug(~\"external module def overwriting type def\");\n-              }\n             }\n           }\n           def_fn(*) | def_static_method(*) | def_const(*) |\n@@ -1476,8 +1643,7 @@ impl Resolver {\n             // If this is a trait, add all the method names\n             // to the trait info.\n \n-            match get_method_names_if_trait(self.session.cstore,\n-                                            def_id) {\n+            match get_method_names_if_trait(self.session.cstore, def_id) {\n               None => {\n                 // Nothing to do.\n               }\n@@ -1547,8 +1713,8 @@ impl Resolver {\n                 let (child_name_bindings, new_parent) =\n                     self.add_child(ident,\n                                    ModuleReducedGraphParent(current_module),\n-                                   // May want a better span\n-                                   ~[], dummy_sp());\n+                                   OverwriteDuplicates,\n+                                   dummy_sp());\n \n                 // Define or reuse the module node.\n                 match child_name_bindings.type_def {\n@@ -1572,7 +1738,8 @@ impl Resolver {\n             let (child_name_bindings, new_parent) =\n                 self.add_child(final_ident,\n                                ModuleReducedGraphParent(current_module),\n-                              ~[], dummy_sp());\n+                               OverwriteDuplicates,\n+                               dummy_sp());\n \n             match path_entry.def_like {\n                 dl_def(def) => {\n@@ -1582,12 +1749,12 @@ impl Resolver {\n                                              final_ident, new_parent);\n                 }\n                 dl_impl(_) => {\n-                    // Because of the infelicitous way the metadata is\n-                    // written, we can't process this impl now. We'll get it\n-                    // later.\n-\n+                    // We only process static methods of impls here.\n                     debug!(\"(building reduced graph for external crate) \\\n-                            ignoring impl %s\", final_ident_str);\n+                            processing impl %s\", final_ident_str);\n+\n+                    // FIXME (#3786): Cross-crate static methods in anonymous\n+                    // traits.\n                 }\n                 dl_field => {\n                     debug!(\"(building reduced graph for external crate) \\\n@@ -2310,18 +2477,34 @@ impl Resolver {\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n+                    // Check to see whether there are type bindings, and, if\n+                    // so, whether there is a module within.\n                     match target.bindings.type_def {\n-                        None | Some(TypeDef(*)) => {\n-                            // Not a module.\n+                        Some(copy type_def) => {\n+                            match type_def.module_def {\n+                                None => {\n+                                    // Not a module.\n+                                    self.session.span_err(span,\n+                                                          fmt!(\"not a \\\n+                                                                module: %s\",\n+                                                               self.session.\n+                                                                   str_of(\n+                                                                    name)));\n+                                    return Failed;\n+                                }\n+                                Some(copy module_def) => {\n+                                    search_module = module_def;\n+                                }\n+                            }\n+                        }\n+                        None => {\n+                            // There are no type bindings at all.\n                             self.session.span_err(span,\n                                                   fmt!(\"not a module: %s\",\n-                                                       self.session.\n-                                                           str_of(name)));\n+                                                       self.session.str_of(\n+                                                            name)));\n                             return Failed;\n                         }\n-                        Some(ModuleDef(_, copy module_)) => {\n-                            search_module = module_;\n-                        }\n                     }\n                 }\n             }\n@@ -2469,14 +2652,24 @@ impl Resolver {\n         match self.resolve_item_in_lexical_scope(module_, name, TypeNS) {\n             Success(target) => {\n                 match target.bindings.type_def {\n-                    None | Some(TypeDef(*)) => {\n+                    Some(type_def) => {\n+                        match type_def.module_def {\n+                            None => {\n+                                error!(\"!!! (resolving module in lexical \\\n+                                        scope) module wasn't actually a \\\n+                                        module!\");\n+                                return Failed;\n+                            }\n+                            Some(module_def) => {\n+                                return Success(module_def);\n+                            }\n+                        }\n+                    }\n+                    None => {\n                         error!(\"!!! (resolving module in lexical scope) module\n                                 wasn't actually a module!\");\n                         return Failed;\n                     }\n-                    Some(ModuleDef(_, module_)) => {\n-                        return Success(module_);\n-                    }\n                 }\n             }\n             Indeterminate => {\n@@ -3403,7 +3596,6 @@ impl Resolver {\n                         self_binding: SelfBinding,\n                         capture_clause: CaptureClause,\n                         visitor: ResolveVisitor) {\n-\n         // Check each element of the capture clause.\n         match capture_clause {\n             NoCaptureClause => {\n@@ -3495,7 +3687,6 @@ impl Resolver {\n \n     fn resolve_type_parameters(type_parameters: ~[ty_param],\n                                visitor: ResolveVisitor) {\n-\n         for type_parameters.each |type_parameter| {\n             for type_parameter.bounds.each |bound| {\n                 match *bound {\n@@ -3517,7 +3708,6 @@ impl Resolver {\n                      methods: ~[@method],\n                      optional_destructor: Option<class_dtor>,\n                      visitor: ResolveVisitor) {\n-\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = (*type_parameters).len();\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n@@ -3619,23 +3809,21 @@ impl Resolver {\n                               self_type: @Ty,\n                               methods: ~[@method],\n                               visitor: ResolveVisitor) {\n-\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = type_parameters.len();\n         let borrowed_type_parameters: &~[ty_param] = &type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (borrowed_type_parameters, id, 0u,\n                                          NormalRibKind)) {\n-\n             // Resolve the type parameters.\n             self.resolve_type_parameters(type_parameters, visitor);\n \n             // Resolve the trait reference, if necessary.\n             let original_trait_refs = self.current_trait_refs;\n             match opt_trait_reference {\n-              Some(trait_reference) => {\n-                let new_trait_refs = @DVec();\n-                match self.resolve_path(\n+                Some(trait_reference) => {\n+                    let new_trait_refs = @DVec();\n+                    match self.resolve_path(\n                         trait_reference.path, TypeNS, true, visitor) {\n                         None => {\n                             self.session.span_err(span,\n@@ -3649,10 +3837,10 @@ impl Resolver {\n                             (*new_trait_refs).push(def_id_of_def(def));\n                         }\n                     }\n-                // Record the current set of trait references.\n-                self.current_trait_refs = Some(new_trait_refs);\n-            }\n-            None => ()\n+                    // Record the current set of trait references.\n+                    self.current_trait_refs = Some(new_trait_refs);\n+                }\n+                None => ()\n             }\n \n             // Resolve the self type."}, {"sha": "6c4e9abc5ff7dc989ec35019d080df194e670fe9", "filename": "src/test/run-pass/anon-trait-static-method.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4dc67c5e6af76eab83b93e5b494d3073d78229db/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dc67c5e6af76eab83b93e5b494d3073d78229db/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-trait-static-method.rs?ref=4dc67c5e6af76eab83b93e5b494d3073d78229db", "patch": "@@ -0,0 +1,15 @@\n+struct Foo {\n+    x: int\n+}\n+\n+impl Foo {\n+    static fn new() -> Foo {\n+        Foo { x: 3 }\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo::new();\n+    io::println(x.x.to_str());\n+}\n+"}]}