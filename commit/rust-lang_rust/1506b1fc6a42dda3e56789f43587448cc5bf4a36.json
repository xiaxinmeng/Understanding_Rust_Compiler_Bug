{"sha": "1506b1fc6a42dda3e56789f43587448cc5bf4a36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MDZiMWZjNmE0MmRkYTNlNTY3ODlmNDM1ODc0NDhjYzViZjRhMzY=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-02-24T09:40:36Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T08:03:13Z"}, "message": "perf: Reduce snapshot/rollback overhead\n\nBy merging the undo_log of all structures part of the snapshot the cost\nof creating a snapshot becomes much cheaper. Since snapshots with no or\nfew changes are so frequent this ends up mattering more than the slight\noverhead of dispatching on the variants that map to each field.", "tree": {"sha": "b469970b042b8c02f779c0010790bdde9db253e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b469970b042b8c02f779c0010790bdde9db253e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1506b1fc6a42dda3e56789f43587448cc5bf4a36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1506b1fc6a42dda3e56789f43587448cc5bf4a36", "html_url": "https://github.com/rust-lang/rust/commit/1506b1fc6a42dda3e56789f43587448cc5bf4a36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1506b1fc6a42dda3e56789f43587448cc5bf4a36/comments", "author": null, "committer": null, "parents": [{"sha": "61621e2667869a9c6cc153d10f84b8850fd64494", "url": "https://api.github.com/repos/rust-lang/rust/commits/61621e2667869a9c6cc153d10f84b8850fd64494", "html_url": "https://github.com/rust-lang/rust/commit/61621e2667869a9c6cc153d10f84b8850fd64494"}], "stats": {"total": 710, "additions": 519, "deletions": 191}, "files": [{"sha": "6f442e8d2b9ceca061428eba90029de97b669d6c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -987,8 +987,7 @@ dependencies = [\n [[package]]\n name = \"ena\"\n version = \"0.13.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8944dc8fa28ce4a38f778bd46bf7d923fe73eed5a439398507246c8e017e6f36\"\n+source = \"git+https://github.com/Marwes/ena?branch=detach_undo_log#9b977ea7f209a35f46d65d33cdd74b8f4931fb8a\"\n dependencies = [\n  \"log\",\n ]"}, {"sha": "9b143dcc8d89a1153c3154cea25843b7e29c54c6", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -65,5 +65,7 @@ rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n+ena = { version = \"0.13.1\", git = \"https://github.com/Marwes/ena\", branch = \"detach_undo_log\" }\n+\n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "a7bee8a067c29e9acfabf59b03dda443f3046722", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -84,6 +84,7 @@ pub mod sync;\n pub mod thin_vec;\n pub mod tiny_list;\n pub mod transitive_relation;\n+pub use ena::undo_log;\n pub use ena::unify;\n mod atomic_ref;\n pub mod fingerprint;"}, {"sha": "d4af470499670423307089a4771808979a13022e", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -76,7 +76,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.inner\n                     .borrow_mut()\n-                    .int_unification_table\n+                    .int_unification_table()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n@@ -98,7 +98,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n                 self.inner\n                     .borrow_mut()\n-                    .float_unification_table\n+                    .float_unification_table()\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n@@ -133,8 +133,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, a);\n-        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, b);\n+        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), a);\n+        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table(), b);\n \n         let a_is_expected = relation.a_is_expected();\n \n@@ -145,7 +145,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             ) => {\n                 self.inner\n                     .borrow_mut()\n-                    .const_unification_table\n+                    .const_unification_table()\n                     .unify_var_var(a_vid, b_vid)\n                     .map_err(|e| const_unification_error(a_is_expected, e))?;\n                 return Ok(a);\n@@ -179,7 +179,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .const_unification_table\n+            .const_unification_table()\n             .unify_var_value(\n                 vid,\n                 ConstVarValue {\n@@ -202,7 +202,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .int_unification_table\n+            .int_unification_table()\n             .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n@@ -219,7 +219,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         self.inner\n             .borrow_mut()\n-            .float_unification_table\n+            .float_unification_table()\n             .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n@@ -266,7 +266,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.inner.borrow_mut().type_variables.probe(b_vid).is_unknown());\n+        debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -286,7 +286,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n             a_ty, dir, b_vid, b_ty\n         );\n-        self.infcx.inner.borrow_mut().type_variables.instantiate(b_vid, b_ty);\n+        self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(\n@@ -344,7 +344,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n-        let for_universe = match self.infcx.inner.borrow_mut().type_variables.probe(for_vid) {\n+        let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n                 panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n@@ -356,7 +356,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n             needs_wf: false,\n@@ -508,14 +508,14 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // us from creating infinitely sized types.\n         match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n-                let vid = self.infcx.inner.borrow_mut().type_variables.root_var(vid);\n-                let sub_vid = self.infcx.inner.borrow_mut().type_variables.sub_root_var(vid);\n+                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n-                    let probe = self.infcx.inner.borrow_mut().type_variables.probe(vid);\n+                    let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n                     match probe {\n                         TypeVariableValue::Known { value: u } => {\n                             debug!(\"generalize: known value {:?}\", u);\n@@ -542,12 +542,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                             }\n \n                             let origin =\n-                                *self.infcx.inner.borrow_mut().type_variables.var_origin(vid);\n-                            let new_var_id = self.infcx.inner.borrow_mut().type_variables.new_var(\n-                                self.for_universe,\n-                                false,\n-                                origin,\n-                            );\n+                                *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n+                            let new_var_id = self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables()\n+                                .new_var(self.for_universe, false, origin);\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -618,7 +619,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         match c.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n                     ConstVariableValue::Known { value: u } => self.relate(&u, &u),"}, {"sha": "d054070e292fa2ec7c09d118529c3ebe770b5d56", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -72,14 +72,14 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n-                infcx.inner.borrow_mut().type_variables.equate(a_id, b_id);\n+                infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {"}, {"sha": "d8133c58df7eb4d37d4d1a5d79cd309e208e3399", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n                                         .infcx\n                                         .inner\n                                         .borrow_mut()\n-                                        .type_variables\n+                                        .type_variables()\n                                         .sub_unified(a_vid, b_vid),\n                                     _ => false,\n                                 }\n@@ -194,7 +194,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n-            let ty_vars = &self.inner.borrow().type_variables;\n+            let mut inner = self.inner.borrow_mut();\n+            let ty_vars = &inner.type_variables();\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n                 let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n@@ -248,7 +249,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let ty_vars = &self.inner.borrow().type_variables;\n+            let mut inner = self.inner.borrow_mut();\n+            let ty_vars = inner.type_variables();\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n                 if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {"}, {"sha": "47346c3a85665e438bf0135de3944db62d11407e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -147,15 +147,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n-                    .int_unification_table\n+                    .int_unification_table()\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 self.infcx\n                     .inner\n                     .borrow_mut()\n-                    .float_unification_table\n+                    .float_unification_table()\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                     .infcx\n                     .inner\n                     .borrow_mut()\n-                    .const_unification_table\n+                    .const_unification_table()\n                     .probe_value(v)\n                     .val\n                     .known();"}, {"sha": "0046dba0b0467df1f7b7572707f410e2c062ae23", "filename": "src/librustc_infer/infer/fudge.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffudge.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -3,18 +3,30 @@ use rustc_middle::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt,\n \n use super::type_variable::TypeVariableOrigin;\n use super::InferCtxt;\n-use super::{ConstVariableOrigin, RegionVariableOrigin};\n+use super::{ConstVariableOrigin, RegionVariableOrigin, UnificationTable};\n \n+use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n use ut::UnifyKey;\n \n use std::ops::Range;\n \n+fn vars_since_snapshot<'tcx, T>(\n+    table: &mut UnificationTable<'_, 'tcx, T>,\n+    snapshot: usize,\n+) -> Range<T>\n+where\n+    T: UnifyKey,\n+    super::UndoLog<'tcx>: From<sv::UndoLog<ut::Delegate<T>>>,\n+{\n+    T::from_index(snapshot as u32)..T::from_index(table.len() as u32)\n+}\n+\n fn const_vars_since_snapshot<'tcx>(\n-    table: &mut ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>,\n-    snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n+    table: &mut UnificationTable<'_, 'tcx, ConstVid<'tcx>>,\n+    snapshot: usize,\n ) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n-    let range = table.vars_since_snapshot(snapshot);\n+    let range = vars_since_snapshot(table, snapshot);\n     (\n         range.start..range.end,\n         (range.start.index..range.end.index)\n@@ -83,17 +95,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     let mut inner = self.inner.borrow_mut();\n                     let type_vars =\n-                        inner.type_variables.vars_since_snapshot(&snapshot.type_snapshot);\n-                    let int_vars =\n-                        inner.int_unification_table.vars_since_snapshot(&snapshot.int_snapshot);\n-                    let float_vars =\n-                        inner.float_unification_table.vars_since_snapshot(&snapshot.float_snapshot);\n+                        inner.type_variables().vars_since_snapshot(&snapshot.type_snapshot);\n+                    let int_vars = vars_since_snapshot(\n+                        &mut inner.int_unification_table(),\n+                        snapshot.int_snapshot,\n+                    );\n+                    let float_vars = vars_since_snapshot(\n+                        &mut inner.float_unification_table(),\n+                        snapshot.float_snapshot,\n+                    );\n                     let region_vars = inner\n                         .unwrap_region_constraints()\n                         .vars_since_snapshot(&snapshot.region_constraints_snapshot);\n                     let const_vars = const_vars_since_snapshot(\n-                        &mut inner.const_unification_table,\n-                        &snapshot.const_snapshot,\n+                        &mut inner.const_unification_table(),\n+                        snapshot.const_snapshot,\n                     );\n \n                     let fudger = InferenceFudger {\n@@ -161,7 +177,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     // that it is unbound, so we can just return\n                     // it.\n                     debug_assert!(\n-                        self.infcx.inner.borrow_mut().type_variables.probe(vid).is_unknown()\n+                        self.infcx.inner.borrow_mut().type_variables().probe(vid).is_unknown()\n                     );\n                     ty\n                 }"}, {"sha": "1bf43e74dcd840202ff13ebc01be285145d7dd53", "filename": "src/librustc_infer/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flattice.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -56,8 +56,8 @@ where\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-    let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+    let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+    let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n     match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to"}, {"sha": "6d76f15998ae8d8d9296f367c6c665b9e9f6cb4b", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 278, "deletions": 57, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -10,7 +10,9 @@ use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::undo_log::{Rollback, Snapshots, UndoLogs};\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n@@ -36,6 +38,7 @@ use rustc_span::Span;\n use std::cell::{Cell, Ref, RefCell};\n use std::collections::BTreeMap;\n use std::fmt;\n+use std::marker::PhantomData;\n \n use self::combine::CombineFields;\n use self::free_regions::RegionRelations;\n@@ -141,16 +144,17 @@ pub struct InferCtxtInner<'tcx> {\n     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n     /// that might instantiate a general type variable have an order,\n     /// represented by its upper and lower bounds.\n-    type_variables: type_variable::TypeVariableTable<'tcx>,\n+    type_variables: type_variable::TypeVariableStorage<'tcx>,\n+    undo_log: Logs<'tcx>,\n \n     /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+    const_unification_table: ut::UnificationStorage<ty::ConstVid<'tcx>>,\n \n     /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+    int_unification_table: ut::UnificationStorage<ty::IntVid>,\n \n     /// Map from floating variable to the kind of float it represents.\n-    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+    float_unification_table: ut::UnificationStorage<ty::FloatVid>,\n \n     /// Tracks the set of region variables and the constraints between them.\n     /// This is initially `Some(_)` but when\n@@ -197,20 +201,220 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     fn new() -> InferCtxtInner<'tcx> {\n         InferCtxtInner {\n             projection_cache: Default::default(),\n-            type_variables: type_variable::TypeVariableTable::new(),\n-            const_unification_table: ut::UnificationTable::new(),\n-            int_unification_table: ut::UnificationTable::new(),\n-            float_unification_table: ut::UnificationTable::new(),\n+            type_variables: type_variable::TypeVariableStorage::new(),\n+            undo_log: Logs::default(),\n+            const_unification_table: ut::UnificationStorage::new(),\n+            int_unification_table: ut::UnificationStorage::new(),\n+            float_unification_table: ut::UnificationStorage::new(),\n             region_constraints: Some(RegionConstraintCollector::new()),\n             region_obligations: vec![],\n         }\n     }\n \n+    fn type_variables(&mut self) -> type_variable::TypeVariableTable<'tcx, '_> {\n+        self.type_variables.with_log(&mut self.undo_log)\n+    }\n+\n+    fn int_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<ty::IntVid, &mut ut::UnificationStorage<ty::IntVid>, &mut Logs<'tcx>>,\n+    > {\n+        ut::UnificationTable::with_log(&mut self.int_unification_table, &mut self.undo_log)\n+    }\n+\n+    fn float_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<ty::FloatVid, &mut ut::UnificationStorage<ty::FloatVid>, &mut Logs<'tcx>>,\n+    > {\n+        ut::UnificationTable::with_log(&mut self.float_unification_table, &mut self.undo_log)\n+    }\n+\n+    fn const_unification_table(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<\n+            ty::ConstVid<'tcx>,\n+            &mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n+            &mut Logs<'tcx>,\n+        >,\n+    > {\n+        ut::UnificationTable::with_log(&mut self.const_unification_table, &mut self.undo_log)\n+    }\n+\n     pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n         self.region_constraints.as_mut().expect(\"region constraints already solved\")\n     }\n }\n \n+pub struct Snapshot<'tcx> {\n+    undo_len: usize,\n+    _marker: PhantomData<&'tcx ()>,\n+}\n+\n+pub(crate) enum UndoLog<'tcx> {\n+    TypeVariables(type_variable::UndoLog<'tcx>),\n+    ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n+    IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n+    FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::EqRelation(l))\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::TyVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::TyVid>>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::SubRelation(l))\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<type_variable::Delegate>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<type_variable::Delegate>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::Values(l))\n+    }\n+}\n+\n+impl<'tcx> From<type_variable::Instantiate> for UndoLog<'tcx> {\n+    fn from(l: type_variable::Instantiate) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::from(l))\n+    }\n+}\n+\n+impl From<type_variable::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(t: type_variable::UndoLog<'tcx>) -> Self {\n+        Self::TypeVariables(t)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>) -> Self {\n+        Self::ConstUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::IntVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::IntVid>>) -> Self {\n+        Self::IntUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::FloatVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::FloatVid>>) -> Self {\n+        Self::FloatUnificationTable(l)\n+    }\n+}\n+\n+pub(crate) type UnificationTable<'a, 'tcx, T> =\n+    ut::UnificationTable<ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut Logs<'tcx>>>;\n+\n+struct RollbackView<'tcx, 'a> {\n+    type_variables: type_variable::RollbackView<'tcx, 'a>,\n+    const_unification_table: &'a mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n+    int_unification_table: &'a mut ut::UnificationStorage<ty::IntVid>,\n+    float_unification_table: &'a mut ut::UnificationStorage<ty::FloatVid>,\n+}\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        match undo {\n+            UndoLog::TypeVariables(undo) => self.type_variables.reverse(undo),\n+            UndoLog::ConstUnificationTable(undo) => self.const_unification_table.reverse(undo),\n+            UndoLog::IntUnificationTable(undo) => self.int_unification_table.reverse(undo),\n+            UndoLog::FloatUnificationTable(undo) => self.float_unification_table.reverse(undo),\n+        }\n+    }\n+}\n+\n+pub(crate) struct Logs<'tcx> {\n+    logs: Vec<UndoLog<'tcx>>,\n+    num_open_snapshots: usize,\n+}\n+\n+impl Default for Logs<'_> {\n+    fn default() -> Self {\n+        Self { logs: Default::default(), num_open_snapshots: Default::default() }\n+    }\n+}\n+\n+impl<'tcx, T> UndoLogs<T> for Logs<'tcx>\n+where\n+    UndoLog<'tcx>: From<T>,\n+{\n+    fn num_open_snapshots(&self) -> usize {\n+        self.num_open_snapshots\n+    }\n+    fn push(&mut self, undo: T) {\n+        if self.in_snapshot() {\n+            self.logs.push(undo.into())\n+        }\n+    }\n+    fn extend<J>(&mut self, undos: J)\n+    where\n+        Self: Sized,\n+        J: IntoIterator<Item = T>,\n+    {\n+        if self.in_snapshot() {\n+            self.logs.extend(undos.into_iter().map(UndoLog::from))\n+        }\n+    }\n+}\n+\n+impl<'tcx> Snapshots<UndoLog<'tcx>> for Logs<'tcx> {\n+    type Snapshot = Snapshot<'tcx>;\n+    fn actions_since_snapshot(&self, snapshot: &Self::Snapshot) -> &[UndoLog<'tcx>] {\n+        &self.logs[snapshot.undo_len..]\n+    }\n+\n+    fn start_snapshot(&mut self) -> Self::Snapshot {\n+        unreachable!()\n+    }\n+\n+    fn rollback_to(&mut self, values: &mut impl Rollback<UndoLog<'tcx>>, snapshot: Self::Snapshot) {\n+        debug!(\"rollback_to({})\", snapshot.undo_len);\n+        self.assert_open_snapshot(&snapshot);\n+\n+        while self.logs.len() > snapshot.undo_len {\n+            values.reverse(self.logs.pop().unwrap());\n+        }\n+\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.logs.clear();\n+        }\n+\n+        self.num_open_snapshots -= 1;\n+    }\n+\n+    fn commit(&mut self, snapshot: Self::Snapshot) {\n+        debug!(\"commit({})\", snapshot.undo_len);\n+\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.logs.clear();\n+        }\n+\n+        self.num_open_snapshots -= 1;\n+    }\n+}\n+\n+impl<'tcx> Logs<'tcx> {\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n+        // Failures here may indicate a failure to follow a stack discipline.\n+        assert!(self.logs.len() >= snapshot.undo_len);\n+        assert!(self.num_open_snapshots > 0);\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -644,10 +848,11 @@ impl<'tcx> InferOk<'tcx, ()> {\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n+    undo_snapshot: Snapshot<'tcx>,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n-    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n-    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n+    const_snapshot: usize,\n+    int_snapshot: usize,\n+    float_snapshot: usize,\n     region_constraints_snapshot: RegionSnapshot,\n     region_obligations_snapshot: usize,\n     universe: ty::UniverseIndex,\n@@ -667,7 +872,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n         match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n             _ => false,\n         }\n     }\n@@ -681,14 +886,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().int_unification_table().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().float_unification_table().probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -703,21 +908,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // FIXME(const_generics): should there be an equivalent function for const variables?\n \n         let mut vars: Vec<Ty<'_>> = inner\n-            .type_variables\n+            .type_variables()\n             .unsolved_variables()\n             .into_iter()\n             .map(|t| self.tcx.mk_ty_var(t))\n             .collect();\n         vars.extend(\n-            (0..inner.int_unification_table.len())\n+            (0..inner.int_unification_table().len())\n                 .map(|i| ty::IntVid { index: i as u32 })\n-                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .filter(|&vid| inner.int_unification_table().probe_value(vid).is_none())\n                 .map(|v| self.tcx.mk_int_var(v)),\n         );\n         vars.extend(\n-            (0..inner.float_unification_table.len())\n+            (0..inner.float_unification_table().len())\n                 .map(|i| ty::FloatVid { index: i as u32 })\n-                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .filter(|&vid| inner.float_unification_table().probe_value(vid).is_none())\n                 .map(|v| self.tcx.mk_float_var(v)),\n         );\n         vars\n@@ -769,12 +974,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let in_snapshot = self.in_snapshot.replace(true);\n \n         let mut inner = self.inner.borrow_mut();\n+\n+        inner.undo_log.num_open_snapshots += 1;\n+        let undo_snapshot = Snapshot { undo_len: inner.undo_log.logs.len(), _marker: PhantomData };\n         CombinedSnapshot {\n             projection_cache_snapshot: inner.projection_cache.snapshot(),\n-            type_snapshot: inner.type_variables.snapshot(),\n-            const_snapshot: inner.const_unification_table.snapshot(),\n-            int_snapshot: inner.int_unification_table.snapshot(),\n-            float_snapshot: inner.float_unification_table.snapshot(),\n+            undo_snapshot,\n+            type_snapshot: inner.type_variables().snapshot(),\n+            const_snapshot: inner.const_unification_table().len(),\n+            int_snapshot: inner.int_unification_table().len(),\n+            float_snapshot: inner.float_unification_table().len(),\n             region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n             region_obligations_snapshot: inner.region_obligations.len(),\n             universe: self.universe(),\n@@ -790,10 +999,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n+            undo_snapshot,\n+            type_snapshot: _,\n+            const_snapshot: _,\n+            int_snapshot: _,\n+            float_snapshot: _,\n             region_constraints_snapshot,\n             region_obligations_snapshot,\n             universe,\n@@ -807,11 +1017,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.skip_leak_check.set(was_skip_leak_check);\n \n         let mut inner = self.inner.borrow_mut();\n+        let inner = &mut *inner;\n+        let InferCtxtInner {\n+            type_variables,\n+            const_unification_table,\n+            int_unification_table,\n+            float_unification_table,\n+            ..\n+        } = inner;\n+        inner.undo_log.rollback_to(\n+            &mut RollbackView {\n+                type_variables: type_variable::RollbackView::from(type_variables),\n+                const_unification_table,\n+                int_unification_table,\n+                float_unification_table,\n+            },\n+            undo_snapshot,\n+        );\n         inner.projection_cache.rollback_to(projection_cache_snapshot);\n-        inner.type_variables.rollback_to(type_snapshot);\n-        inner.const_unification_table.rollback_to(const_snapshot);\n-        inner.int_unification_table.rollback_to(int_snapshot);\n-        inner.float_unification_table.rollback_to(float_snapshot);\n         inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n         inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n@@ -820,10 +1043,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot {\n             projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n+            undo_snapshot,\n+            type_snapshot: _,\n+            const_snapshot: _,\n+            int_snapshot: _,\n+            float_snapshot: _,\n             region_constraints_snapshot,\n             region_obligations_snapshot: _,\n             universe: _,\n@@ -836,11 +1060,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.skip_leak_check.set(was_skip_leak_check);\n \n         let mut inner = self.inner.borrow_mut();\n+        inner.undo_log.commit(undo_snapshot);\n         inner.projection_cache.commit(projection_cache_snapshot);\n-        inner.type_variables.commit(type_snapshot);\n-        inner.const_unification_table.commit(const_snapshot);\n-        inner.int_unification_table.commit(int_snapshot);\n-        inner.float_unification_table.commit(float_snapshot);\n         inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n     }\n \n@@ -1032,7 +1253,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n+        self.inner.borrow_mut().type_variables().new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -1044,7 +1265,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables().new_var(universe, false, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n@@ -1069,28 +1290,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let vid = self\n             .inner\n             .borrow_mut()\n-            .const_unification_table\n+            .const_unification_table()\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+        self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {\n             origin,\n             val: ConstVariableValue::Unknown { universe: self.universe() },\n         })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n-        self.inner.borrow_mut().int_unification_table.new_key(None)\n+        self.inner.borrow_mut().int_unification_table().new_key(None)\n     }\n \n     pub fn next_int_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_int_var(self.next_int_var_id())\n     }\n \n     fn next_float_var_id(&self) -> FloatVid {\n-        self.inner.borrow_mut().float_unification_table.new_key(None)\n+        self.inner.borrow_mut().float_unification_table().new_key(None)\n     }\n \n     pub fn next_float_var(&self) -> Ty<'tcx> {\n@@ -1161,7 +1382,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n+                let ty_var_id = self.inner.borrow_mut().type_variables().new_var(\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n@@ -1181,7 +1402,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     span,\n                 };\n                 let const_var_id =\n-                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+                    self.inner.borrow_mut().const_unification_table().new_key(ConstVarValue {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n@@ -1335,7 +1556,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n         use self::type_variable::TypeVariableValue;\n \n-        match self.inner.borrow_mut().type_variables.probe(vid) {\n+        match self.inner.borrow_mut().type_variables().probe(vid) {\n             TypeVariableValue::Known { value } => Ok(value),\n             TypeVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1357,7 +1578,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.inner.borrow_mut().type_variables.root_var(var)\n+        self.inner.borrow_mut().type_variables().root_var(var)\n     }\n \n     /// Where possible, replaces type/const variables in\n@@ -1395,7 +1616,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n+        match self.inner.borrow_mut().const_unification_table().probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1576,22 +1797,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 //\n                 // Note: if these two lines are combined into one we get\n                 // dynamic borrow errors on `self.inner`.\n-                let known = self.inner.borrow_mut().type_variables.probe(v).known();\n+                let known = self.inner.borrow_mut().type_variables().probe(v).known();\n                 known.map(|t| self.shallow_resolve_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n                 .inner\n                 .borrow_mut()\n-                .int_unification_table\n+                .int_unification_table()\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n                 .inner\n                 .borrow_mut()\n-                .float_unification_table\n+                .float_unification_table()\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.tcx))\n                 .unwrap_or(typ),\n@@ -1617,7 +1838,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 // If `inlined_probe` returns a `Known` value, it never equals\n                 // `ty::Infer(ty::TyVar(v))`.\n-                match self.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                match self.inner.borrow_mut().type_variables().inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1627,15 +1848,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n-                self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+                self.inner.borrow_mut().int_unification_table().inlined_probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::TyFloat(v) => {\n                 // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+                self.inner.borrow_mut().float_unification_table().probe_value(v).is_some()\n             }\n \n             TyOrConstInferVar::Const(v) => {\n@@ -1718,7 +1939,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n             self.infcx\n                 .inner\n                 .borrow_mut()\n-                .const_unification_table\n+                .const_unification_table()\n                 .probe_value(*vid)\n                 .val\n                 .known()"}, {"sha": "7aea26987a29f237d89b5bd093f99de5d4d8c9db", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -311,7 +311,7 @@ where\n         match value_ty.kind {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n-                self.infcx.inner.borrow_mut().type_variables.equate(vid, value_vid);\n+                self.infcx.inner.borrow_mut().type_variables().equate(vid, value_vid);\n                 return Ok(value_ty);\n             }\n \n@@ -332,7 +332,7 @@ where\n             assert!(!generalized_ty.has_infer_types_or_consts());\n         }\n \n-        self.infcx.inner.borrow_mut().type_variables.instantiate(vid, generalized_ty);\n+        self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -362,7 +362,7 @@ where\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n             universe,\n         };\n \n@@ -859,7 +859,8 @@ where\n             }\n \n             ty::Infer(ty::TyVar(vid)) => {\n-                let variables = &mut self.infcx.inner.borrow_mut().type_variables;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variables = &mut inner.type_variables();\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n@@ -961,7 +962,8 @@ where\n                 bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n             }\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n                     Some(u) => self.relate(&u, &u),"}, {"sha": "e28cf49c7f2538f2facd4caad8c2670ae27d0b10", "filename": "src/librustc_infer/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -123,7 +123,8 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let ty_vars = &self.infcx.inner.borrow().type_variables;\n+                    let mut inner = self.infcx.inner.borrow_mut();\n+                    let ty_vars = &inner.type_variables();\n                     if let TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n                         span,"}, {"sha": "0abcc15d6fcd8b7f633a6f5fb5fbe0535b4bf746", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -80,8 +80,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n-        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -95,7 +95,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 // have to record in the `type_variables` tracker that\n                 // the two variables are equal modulo subtyping, which\n                 // is important to the occurs check later on.\n-                infcx.inner.borrow_mut().type_variables.sub(a_vid, b_vid);\n+                infcx.inner.borrow_mut().type_variables().sub(a_vid, b_vid);\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,"}, {"sha": "47f7d7641369383c4624f0d07435f46322e5b0a2", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "modified", "additions": 147, "deletions": 72, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -3,19 +3,76 @@ use rustc_middle::ty::{self, Ty, TyVid};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n+use crate::infer::Logs;\n+\n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n use std::cmp;\n use std::marker::PhantomData;\n use std::ops::Range;\n \n-pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<Delegate>,\n+use rustc_data_structures::undo_log::{Rollback, Snapshots, UndoLogs};\n+\n+pub(crate) enum UndoLog<'tcx> {\n+    EqRelation(sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>),\n+    SubRelation(sv::UndoLog<ut::Delegate<ty::TyVid>>),\n+    Values(sv::UndoLog<Delegate>),\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<TyVidEqKey<'tcx>>>) -> Self {\n+        UndoLog::EqRelation(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::TyVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::TyVid>>) -> Self {\n+        UndoLog::SubRelation(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<Delegate>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<Delegate>) -> Self {\n+        UndoLog::Values(l)\n+    }\n+}\n+\n+impl<'tcx> From<Instantiate> for UndoLog<'tcx> {\n+    fn from(l: Instantiate) -> Self {\n+        UndoLog::Values(sv::UndoLog::Other(l))\n+    }\n+}\n+\n+pub(crate) struct RollbackView<'tcx, 'a> {\n+    pub(crate) eq_relations: &'a mut ut::UnificationStorage<TyVidEqKey<'tcx>>,\n+    pub(crate) sub_relations: &'a mut ut::UnificationStorage<ty::TyVid>,\n+    pub(crate) values: &'a mut Vec<TypeVariableData>,\n+}\n+\n+impl<'tcx, 'a> From<&'a mut TypeVariableStorage<'tcx>> for RollbackView<'tcx, 'a> {\n+    fn from(l: &'a mut TypeVariableStorage<'tcx>) -> Self {\n+        let TypeVariableStorage { eq_relations, sub_relations, values } = l;\n+        Self { eq_relations, sub_relations, values }\n+    }\n+}\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        match undo {\n+            UndoLog::EqRelation(undo) => self.eq_relations.reverse(undo),\n+            UndoLog::SubRelation(undo) => self.sub_relations.reverse(undo),\n+            UndoLog::Values(undo) => self.values.reverse(undo),\n+        }\n+    }\n+}\n+\n+pub struct TypeVariableStorage<'tcx> {\n+    values: Vec<TypeVariableData>,\n \n     /// Two variables are unified in `eq_relations` when we have a\n     /// constraint `?X == ?Y`. This table also stores, for each key,\n     /// the known value.\n-    eq_relations: ut::UnificationTable<ut::InPlace<TyVidEqKey<'tcx>>>,\n+    eq_relations: ut::UnificationStorage<TyVidEqKey<'tcx>>,\n \n     /// Two variables are unified in `sub_relations` when we have a\n     /// constraint `?X <: ?Y` *or* a constraint `?Y <: ?X`. This second\n@@ -34,7 +91,17 @@ pub struct TypeVariableTable<'tcx> {\n     /// This is reasonable because, in Rust, subtypes have the same\n     /// \"skeleton\" and hence there is no possible type such that\n     /// (e.g.)  `Box<?3> <: ?3` for any `?3`.\n-    sub_relations: ut::UnificationTable<ut::InPlace<ty::TyVid>>,\n+    sub_relations: ut::UnificationStorage<ty::TyVid>,\n+}\n+\n+pub struct TypeVariableTable<'tcx, 'a> {\n+    values: &'a mut Vec<TypeVariableData>,\n+\n+    eq_relations: &'a mut ut::UnificationStorage<TyVidEqKey<'tcx>>,\n+\n+    sub_relations: &'a mut ut::UnificationStorage<ty::TyVid>,\n+\n+    undo_log: &'a mut Logs<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -62,7 +129,7 @@ pub enum TypeVariableOriginKind {\n     LatticeVariable,\n }\n \n-struct TypeVariableData {\n+pub(crate) struct TypeVariableData {\n     origin: TypeVariableOrigin,\n     diverging: bool,\n }\n@@ -92,40 +159,49 @@ impl<'tcx> TypeVariableValue<'tcx> {\n }\n \n pub struct Snapshot<'tcx> {\n-    snapshot: sv::Snapshot,\n-    eq_snapshot: ut::Snapshot<ut::InPlace<TyVidEqKey<'tcx>>>,\n-    sub_snapshot: ut::Snapshot<ut::InPlace<ty::TyVid>>,\n+    value_count: u32,\n+    _marker: PhantomData<&'tcx ()>,\n }\n \n-struct Instantiate {\n+pub(crate) struct Instantiate {\n     vid: ty::TyVid,\n }\n \n-struct Delegate;\n+pub(crate) struct Delegate;\n \n-impl<'tcx> TypeVariableTable<'tcx> {\n-    pub fn new() -> TypeVariableTable<'tcx> {\n-        TypeVariableTable {\n-            values: sv::SnapshotVec::new(),\n-            eq_relations: ut::UnificationTable::new(),\n-            sub_relations: ut::UnificationTable::new(),\n+impl<'tcx> TypeVariableStorage<'tcx> {\n+    pub fn new() -> TypeVariableStorage<'tcx> {\n+        TypeVariableStorage {\n+            values: Vec::new(),\n+            eq_relations: ut::UnificationStorage::new(),\n+            sub_relations: ut::UnificationStorage::new(),\n         }\n     }\n \n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut Logs<'tcx>,\n+    ) -> TypeVariableTable<'tcx, 'a> {\n+        let TypeVariableStorage { values, eq_relations, sub_relations } = self;\n+        TypeVariableTable { values, eq_relations, sub_relations, undo_log }\n+    }\n+}\n+\n+impl<'tcx> TypeVariableTable<'tcx, '_> {\n     /// Returns the diverges flag given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_diverges(&self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as usize).diverging\n+        self.values.get(vid.index as usize).unwrap().diverging\n     }\n \n     /// Returns the origin that was given when `vid` was created.\n     ///\n     /// Note that this function does not return care whether\n     /// `vid` has been unified with something else or not.\n     pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n-        &self.values.get(vid.index as usize).origin\n+        &self.values.get(vid.index as usize).unwrap().origin\n     }\n \n     /// Records that `a == b`, depending on `dir`.\n@@ -134,8 +210,8 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n         debug_assert!(self.probe(a).is_unknown());\n         debug_assert!(self.probe(b).is_unknown());\n-        self.eq_relations.union(a, b);\n-        self.sub_relations.union(a, b);\n+        self.eq_relations().union(a, b);\n+        self.sub_relations().union(a, b);\n     }\n \n     /// Records that `a <: b`, depending on `dir`.\n@@ -144,7 +220,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn sub(&mut self, a: ty::TyVid, b: ty::TyVid) {\n         debug_assert!(self.probe(a).is_unknown());\n         debug_assert!(self.probe(b).is_unknown());\n-        self.sub_relations.union(a, b);\n+        self.sub_relations().union(a, b);\n     }\n \n     /// Instantiates `vid` with the type `ty`.\n@@ -154,18 +230,18 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         let vid = self.root_var(vid);\n         debug_assert!(self.probe(vid).is_unknown());\n         debug_assert!(\n-            self.eq_relations.probe_value(vid).is_unknown(),\n+            self.eq_relations().probe_value(vid).is_unknown(),\n             \"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n             vid,\n             ty,\n-            self.eq_relations.probe_value(vid)\n+            self.eq_relations().probe_value(vid)\n         );\n-        self.eq_relations.union_value(vid, TypeVariableValue::Known { value: ty });\n+        self.eq_relations().union_value(vid, TypeVariableValue::Known { value: ty });\n \n         // Hack: we only need this so that `types_escaping_snapshot`\n         // can see what has been unified; see the Delegate impl for\n         // more details.\n-        self.values.record(Instantiate { vid });\n+        self.undo_log.push(Instantiate { vid });\n     }\n \n     /// Creates a new type variable.\n@@ -184,12 +260,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         diverging: bool,\n         origin: TypeVariableOrigin,\n     ) -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+        let eq_key = self.eq_relations().new_key(TypeVariableValue::Unknown { universe });\n \n-        let sub_key = self.sub_relations.new_key(());\n+        let sub_key = self.sub_relations().new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n \n-        let index = self.values.push(TypeVariableData { origin, diverging });\n+        let index = self.values().push(TypeVariableData { origin, diverging });\n         assert_eq!(eq_key.vid.index, index as u32);\n \n         debug!(\n@@ -211,7 +287,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// algorithm), so `root_var(a) == root_var(b)` implies that `a ==\n     /// b` (transitively).\n     pub fn root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.eq_relations.find(vid).vid\n+        self.eq_relations().find(vid).vid\n     }\n \n     /// Returns the \"root\" variable of `vid` in the `sub_relations`\n@@ -222,7 +298,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     ///     exists X. (a <: X || X <: a) && (b <: X || X <: b)\n     pub fn sub_root_var(&mut self, vid: ty::TyVid) -> ty::TyVid {\n-        self.sub_relations.find(vid)\n+        self.sub_relations().find(vid)\n     }\n \n     /// Returns `true` if `a` and `b` have same \"sub-root\" (i.e., exists some\n@@ -240,7 +316,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// An always-inlined variant of `probe`, for very hot call sites.\n     #[inline(always)]\n     pub fn inlined_probe(&mut self, vid: ty::TyVid) -> TypeVariableValue<'tcx> {\n-        self.eq_relations.inlined_probe_value(vid)\n+        self.eq_relations().inlined_probe_value(vid)\n     }\n \n     /// If `t` is a type-inference variable, and it has been\n@@ -261,52 +337,44 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// (`rollback_to()`). Nested snapshots are permitted, but must\n     /// be processed in a stack-like fashion.\n     pub fn snapshot(&mut self) -> Snapshot<'tcx> {\n-        Snapshot {\n-            snapshot: self.values.start_snapshot(),\n-            eq_snapshot: self.eq_relations.snapshot(),\n-            sub_snapshot: self.sub_relations.snapshot(),\n-        }\n+        Snapshot { value_count: self.eq_relations().len() as u32, _marker: PhantomData }\n     }\n \n-    /// Undoes all changes since the snapshot was created. Any\n-    /// snapshots created since that point must already have been\n-    /// committed or rolled back.\n-    pub fn rollback_to(&mut self, s: Snapshot<'tcx>) {\n-        debug!(\"rollback_to{:?}\", {\n-            for action in self.values.actions_since_snapshot(&s.snapshot) {\n-                if let sv::UndoLog::NewElem(index) = *action {\n-                    debug!(\"inference variable _#{}t popped\", index)\n-                }\n-            }\n-        });\n+    fn values(&mut self) -> sv::SnapshotVec<Delegate, &mut Vec<TypeVariableData>, &mut Logs<'tcx>> {\n+        sv::SnapshotVec::with_log(self.values, self.undo_log)\n+    }\n \n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.rollback_to(snapshot);\n-        self.eq_relations.rollback_to(eq_snapshot);\n-        self.sub_relations.rollback_to(sub_snapshot);\n+    fn eq_relations(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<\n+            TyVidEqKey<'tcx>,\n+            &mut ut::UnificationStorage<TyVidEqKey<'tcx>>,\n+            &mut Logs<'tcx>,\n+        >,\n+    > {\n+        ut::UnificationTable::with_log(self.eq_relations, self.undo_log)\n     }\n \n-    /// Commits all changes since the snapshot was created, making\n-    /// them permanent (unless this snapshot was created within\n-    /// another snapshot). Any snapshots created since that point\n-    /// must already have been committed or rolled back.\n-    pub fn commit(&mut self, s: Snapshot<'tcx>) {\n-        let Snapshot { snapshot, eq_snapshot, sub_snapshot } = s;\n-        self.values.commit(snapshot);\n-        self.eq_relations.commit(eq_snapshot);\n-        self.sub_relations.commit(sub_snapshot);\n+    fn sub_relations(\n+        &mut self,\n+    ) -> ut::UnificationTable<\n+        ut::InPlace<ty::TyVid, &mut ut::UnificationStorage<ty::TyVid>, &mut Logs<'tcx>>,\n+    > {\n+        ut::UnificationTable::with_log(self.sub_relations, self.undo_log)\n     }\n \n     /// Returns a range of the type variables created during the snapshot.\n     pub fn vars_since_snapshot(\n         &mut self,\n         s: &Snapshot<'tcx>,\n     ) -> (Range<TyVid>, Vec<TypeVariableOrigin>) {\n-        let range = self.eq_relations.vars_since_snapshot(&s.eq_snapshot);\n+        let range =\n+            TyVid { index: s.value_count }..TyVid { index: self.eq_relations().len() as u32 };\n         (\n-            range.start.vid..range.end.vid,\n-            (range.start.vid.index..range.end.vid.index)\n-                .map(|index| self.values.get(index as usize).origin)\n+            range.start..range.end,\n+            (range.start.index..range.end.index)\n+                .map(|index| self.values.get(index as usize).unwrap().origin)\n                 .collect(),\n         )\n     }\n@@ -317,14 +385,15 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     /// a type variable `V0`, then we started the snapshot, then we\n     /// created a type variable `V1`, unified `V0` with `T0`, and\n     /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, s: &Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n+    pub fn types_escaping_snapshot(&mut self, s: &super::Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n         let mut new_elem_threshold = u32::MAX;\n         let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n         debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for action in actions_since_snapshot {\n-            match *action {\n-                sv::UndoLog::NewElem(index) => {\n+        for i in 0..actions_since_snapshot.len() {\n+            let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n+            match actions_since_snapshot[i] {\n+                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::NewElem(index))) => {\n                     // if any new variables were created during the\n                     // snapshot, remember the lower index (which will\n                     // always be the first one we see). Note that this\n@@ -334,11 +403,17 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n+                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::Other(\n+                    Instantiate { vid, .. },\n+                ))) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n-                        let escaping_type = match self.eq_relations.probe_value(vid) {\n+                        let mut eq_relations = ut::UnificationTable::with_log(\n+                            &mut *self.eq_relations,\n+                            &mut *self.undo_log,\n+                        );\n+                        let escaping_type = match eq_relations.probe_value(vid) {\n                             TypeVariableValue::Unknown { .. } => bug!(),\n                             TypeVariableValue::Known { value } => value,\n                         };\n@@ -395,7 +470,7 @@ impl sv::SnapshotVecDelegate for Delegate {\n /// for the `eq_relations`; they carry a `TypeVariableValue` along\n /// with them.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-struct TyVidEqKey<'tcx> {\n+pub(crate) struct TyVidEqKey<'tcx> {\n     vid: ty::TyVid,\n \n     // in the table, we map each ty-vid to one of these:"}, {"sha": "2580ac6bebd86cbfa437c0671aaf433c9b6b46ba", "filename": "src/librustc_middle/infer/unify_key.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1506b1fc6a42dda3e56789f43587448cc5bf4a36/src%2Flibrustc_middle%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Funify_key.rs?ref=1506b1fc6a42dda3e56789f43587448cc5bf4a36", "patch": "@@ -1,6 +1,9 @@\n use crate::ty::{self, FloatVarValue, InferConst, IntVarValue, Ty, TyCtxt};\n-use rustc_data_structures::unify::InPlace;\n-use rustc_data_structures::unify::{EqUnifyValue, NoError, UnificationTable, UnifyKey, UnifyValue};\n+use rustc_data_structures::snapshot_vec;\n+use rustc_data_structures::undo_log::UndoLogs;\n+use rustc_data_structures::unify::{\n+    self, EqUnifyValue, InPlace, NoError, UnificationTable, UnifyKey, UnifyValue,\n+};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -212,10 +215,14 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n \n impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n-pub fn replace_if_possible(\n-    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>>>,\n+pub fn replace_if_possible<V, L>(\n+    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>, V, L>>,\n     c: &'tcx ty::Const<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n+) -> &'tcx ty::Const<'tcx>\n+where\n+    V: snapshot_vec::VecLike<unify::Delegate<ty::ConstVid<'tcx>>>,\n+    L: UndoLogs<snapshot_vec::UndoLog<unify::Delegate<ty::ConstVid<'tcx>>>>,\n+{\n     if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {\n         match table.probe_value(*vid).val.known() {\n             Some(c) => c,"}]}