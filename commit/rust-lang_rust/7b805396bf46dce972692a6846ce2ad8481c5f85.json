{"sha": "7b805396bf46dce972692a6846ce2ad8481c5f85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiODA1Mzk2YmY0NmRjZTk3MjY5MmE2ODQ2Y2UyYWQ4NDgxYzVmODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T13:11:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-08T13:11:43Z"}, "message": "Auto merge of #72010 - Dylan-DPC:rollup-prdj0pk, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #71989 (Use a single enum for the kind of a const context)\n - #71993 (Remove old `util/liveness.rs` module)\n - #71999 (Add myself to mailmap.)\n - #72001 (Adjust cfg(version) to lang team decision)\n - #72007 (Fix some tests failing in `--pass check` mode)\n - #72008 (Add const-generics test)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "da21217d9b268425e249c329ad841a5e8ac0b48f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da21217d9b268425e249c329ad841a5e8ac0b48f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b805396bf46dce972692a6846ce2ad8481c5f85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b805396bf46dce972692a6846ce2ad8481c5f85", "html_url": "https://github.com/rust-lang/rust/commit/7b805396bf46dce972692a6846ce2ad8481c5f85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b805396bf46dce972692a6846ce2ad8481c5f85/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "html_url": "https://github.com/rust-lang/rust/commit/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2"}, {"sha": "678954000a2ebd22e5e4a2541bbf893c32441a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/678954000a2ebd22e5e4a2541bbf893c32441a1c", "html_url": "https://github.com/rust-lang/rust/commit/678954000a2ebd22e5e4a2541bbf893c32441a1c"}], "stats": {"total": 711, "additions": 235, "deletions": 476}, "files": [{"sha": "680aa04078f97f1fa8e853c81833ee899f9dc550", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -49,6 +49,7 @@ Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@user\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n+Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>"}, {"sha": "863f2b7337b2588aa7f31db1693496f9468d8121", "filename": "src/librustc_attr/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_attr%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_attr%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuild.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -1,4 +1,5 @@\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n-    println!(\"cargo:rerun-if-env-changed=CFG_VERSION\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE\");\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE_CHANNEL\");\n }"}, {"sha": "a592bbc2bf91880da7737b718c952f7a375eb8f0", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -652,9 +652,12 @@ pub fn eval_condition(\n                     return false;\n                 }\n             };\n-            let version = Version::parse(env!(\"CFG_VERSION\")).unwrap();\n+            let channel = env!(\"CFG_RELEASE_CHANNEL\");\n+            let nightly = channel == \"nightly\" || channel == \"dev\";\n+            let rustc_version = Version::parse(env!(\"CFG_RELEASE\")).unwrap();\n \n-            version >= min_version\n+            // See https://github.com/rust-lang/rust/issues/64796#issuecomment-625474439 for details\n+            if nightly { rustc_version > min_version } else { rustc_version >= min_version }\n         }\n         ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {"}, {"sha": "75a5c198ec7851d5c3e6e357b0311d2d44b90b58", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -1291,6 +1291,53 @@ impl BodyOwnerKind {\n     }\n }\n \n+/// The kind of an item that requires const-checking.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum ConstContext {\n+    /// A `const fn`.\n+    ConstFn,\n+\n+    /// A `static` or `static mut`.\n+    Static(Mutability),\n+\n+    /// A `const`, associated `const`, or other const context.\n+    ///\n+    /// Other contexts include:\n+    /// - Array length expressions\n+    /// - Enum discriminants\n+    /// - Const generics\n+    ///\n+    /// For the most part, other contexts are treated just like a regular `const`, so they are\n+    /// lumped into the same category.\n+    Const,\n+}\n+\n+impl ConstContext {\n+    /// A description of this const context that can appear between backticks in an error message.\n+    ///\n+    /// E.g. `const` or `static mut`.\n+    pub fn keyword_name(self) -> &'static str {\n+        match self {\n+            Self::Const => \"const\",\n+            Self::Static(Mutability::Not) => \"static\",\n+            Self::Static(Mutability::Mut) => \"static mut\",\n+            Self::ConstFn => \"const fn\",\n+        }\n+    }\n+}\n+\n+/// A colloquial, trivially pluralizable description of this const context for use in error\n+/// messages.\n+impl fmt::Display for ConstContext {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Self::Const => write!(f, \"constant\"),\n+            Self::Static(_) => write!(f, \"static\"),\n+            Self::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n+\n /// A literal.\n pub type Lit = Spanned<LitKind>;\n "}, {"sha": "235d1d80192c883805d9cfefe229f0b201049757", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -408,6 +408,9 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n+    ///\n+    /// Panics if `LocalDefId` does not have an associated body.\n     pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Const(..), .. })\n@@ -424,6 +427,23 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Returns the `ConstContext` of the body associated with this `LocalDefId`.\n+    ///\n+    /// Panics if `LocalDefId` does not have an associated body.\n+    pub fn body_const_context(&self, did: LocalDefId) -> Option<ConstContext> {\n+        let hir_id = self.local_def_id_to_hir_id(did);\n+        let ccx = match self.body_owner_kind(hir_id) {\n+            BodyOwnerKind::Const => ConstContext::Const,\n+            BodyOwnerKind::Static(mt) => ConstContext::Static(mt),\n+\n+            BodyOwnerKind::Fn if self.tcx.is_constructor(did.to_def_id()) => return None,\n+            BodyOwnerKind::Fn if self.tcx.is_const_fn_raw(did.to_def_id()) => ConstContext::ConstFn,\n+            BodyOwnerKind::Fn | BodyOwnerKind::Closure => return None,\n+        };\n+\n+        Some(ccx)\n+    }\n+\n     pub fn ty_param_owner(&self, id: HirId) -> HirId {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => id,"}, {"sha": "689ec249a2fb4f5c708fc3ffa1e244483a3fe97c", "filename": "src/librustc_mir/borrow_check/def_use.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdef_use.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -0,0 +1,78 @@\n+use rustc_middle::mir::visit::{\n+    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext,\n+};\n+\n+#[derive(Eq, PartialEq, Clone)]\n+pub enum DefUse {\n+    Def,\n+    Use,\n+    Drop,\n+}\n+\n+pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n+    match context {\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DEFS\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::Store) |\n+\n+        // This is potentially both a def and a use...\n+        PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n+\n+        // We let Call define the result in both the success and\n+        // unwind cases. This is not really correct, however it\n+        // does not seem to be observable due to the way that we\n+        // generate MIR. To do things properly, we would apply\n+        // the def in call only to the input from the success\n+        // path and not the unwind path. -nmatsakis\n+        PlaceContext::MutatingUse(MutatingUseContext::Call) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Yield) |\n+\n+        // Storage live and storage dead aren't proper defines, but we can ignore\n+        // values that come before them.\n+        PlaceContext::NonUse(NonUseContext::StorageLive) |\n+        PlaceContext::NonUse(NonUseContext::StorageDead) => Some(DefUse::Def),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // REGULAR USES\n+        //\n+        // These are uses that occur *outside* of a drop. For the\n+        // purposes of NLL, these are special in that **all** the\n+        // lifetimes appearing in the variable must be live for each regular use.\n+\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n+\n+        // Borrows only consider their local used at the point of the borrow.\n+        // This won't affect the results since we use this analysis for generators\n+        // and we only care about the result at suspension points. Borrows cannot\n+        // cross suspension points so this behavior is unproblematic.\n+        PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n+        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n+        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n+        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n+            Some(DefUse::Use),\n+\n+        ///////////////////////////////////////////////////////////////////////////\n+        // DROP USES\n+        //\n+        // These are uses that occur in a DROP (a MIR drop, not a\n+        // call to `std::mem::drop()`). For the purposes of NLL,\n+        // uses in drop are special because `#[may_dangle]`\n+        // attributes can affect whether lifetimes must be live.\n+\n+        PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n+            Some(DefUse::Drop),\n+\n+        // Debug info is neither def nor use.\n+        PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n+    }\n+}"}, {"sha": "8d8cdfb52934c3502927d63926a6df09d56fade1", "filename": "src/librustc_mir/borrow_check/diagnostics/find_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Ffind_use.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -2,10 +2,10 @@ use std::collections::VecDeque;\n use std::rc::Rc;\n \n use crate::borrow_check::{\n+    def_use::{self, DefUse},\n     nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n-use crate::util::liveness::{self, DefUse};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n@@ -117,7 +117,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'tcx> {\n         });\n \n         if found_it {\n-            self.def_use_result = match liveness::categorize(context) {\n+            self.def_use_result = match def_use::categorize(context) {\n                 Some(DefUse::Def) => Some(DefUseResult::Def),\n                 Some(DefUse::Use) => Some(DefUseResult::UseLive { local }),\n                 Some(DefUse::Drop) => Some(DefUseResult::UseDrop { local }),"}, {"sha": "457f0f8444b8c7af35b6c790fe77dcc792174960", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -51,6 +51,7 @@ use self::path_utils::*;\n mod borrow_set;\n mod constraint_generation;\n mod constraints;\n+mod def_use;\n mod diagnostics;\n mod facts;\n mod invalidation;"}, {"sha": "995e3a60a0c76fa8c6e2083a10a93bfbc93577d6", "filename": "src/librustc_mir/borrow_check/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -3,8 +3,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n \n-use crate::util::liveness::{categorize, DefUse};\n-\n+use crate::borrow_check::def_use::{self, DefUse};\n use crate::borrow_check::region_infer::values::{PointIndex, RegionValueElements};\n \n /// A map that cross references each local with the locations where it\n@@ -160,7 +159,7 @@ impl LocalUseMapBuild<'_> {\n impl Visitor<'tcx> for LocalUseMapBuild<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n         if self.locals_with_use_data[local] {\n-            match categorize(context) {\n+            match def_use::categorize(context) {\n                 Some(DefUse::Def) => self.insert_def(local, location),\n                 Some(DefUse::Use) => self.insert_use(local, location),\n                 Some(DefUse::Drop) => self.insert_drop(local, location),"}, {"sha": "d285098c52ad2097c9aca8d8296b61533b153a6d", "filename": "src/librustc_mir/borrow_check/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -1,7 +1,7 @@\n+use crate::borrow_check::def_use::{self, DefUse};\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{LookupResult, MoveData};\n-use crate::util::liveness::{categorize, DefUse};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Place};\n use rustc_middle::ty::subst::GenericArg;\n@@ -56,7 +56,7 @@ impl UseFactsExtractor<'_> {\n \n impl Visitor<'tcx> for UseFactsExtractor<'_> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n-        match categorize(context) {\n+        match def_use::categorize(context) {\n             Some(DefUse::Def) => self.insert_def(local, location),\n             Some(DefUse::Use) => self.insert_use(local, location),\n             Some(DefUse::Drop) => self.insert_drop_use(local, location),"}, {"sha": "d24faacd3779e5423ceeb684cb1a5e1c4565e8af", "filename": "src/librustc_mir/dataflow/impls/liveness.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fliveness.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -6,6 +6,13 @@ use crate::dataflow::{AnalysisDomain, Backward, BottomValue, GenKill, GenKillAna\n \n /// A [live-variable dataflow analysis][liveness].\n ///\n+/// This analysis considers references as being used only at the point of the\n+/// borrow. In other words, this analysis does not track uses because of references that already\n+/// exist. See [this `mir-datalow` test][flow-test] for an example. You almost never want to use\n+/// this analysis without also looking at the results of [`MaybeBorrowedLocals`].\n+///\n+/// [`MaybeBorrowedLocals`]: ../struct.MaybeBorrowedLocals.html\n+/// [flow-test]: https://github.com/rust-lang/rust/blob/a08c47310c7d49cbdc5d7afb38408ba519967ecd/src/test/ui/mir-dataflow/liveness-ptr.rs\n /// [liveness]: https://en.wikipedia.org/wiki/Live_variable_analysis\n pub struct MaybeLiveLocals;\n "}, {"sha": "7c439f80ef6add339b216b83d56e5bc700237551", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -9,8 +9,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n \n-use std::fmt;\n-\n pub use self::qualifs::Qualif;\n \n mod ops;\n@@ -25,7 +23,7 @@ pub struct ConstCx<'mir, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub def_id: DefId,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    pub const_kind: Option<ConstKind>,\n+    pub const_kind: Option<hir::ConstContext>,\n }\n \n impl ConstCx<'mir, 'tcx> {\n@@ -40,78 +38,18 @@ impl ConstCx<'mir, 'tcx> {\n         body: &'mir mir::Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let const_kind = ConstKind::for_item(tcx, def_id);\n-\n+        let const_kind = tcx.hir().body_const_context(def_id);\n         ConstCx { body, tcx, def_id: def_id.to_def_id(), param_env, const_kind }\n     }\n \n     /// Returns the kind of const context this `Item` represents (`const`, `static`, etc.).\n     ///\n     /// Panics if this `Item` is not const.\n-    pub fn const_kind(&self) -> ConstKind {\n+    pub fn const_kind(&self) -> hir::ConstContext {\n         self.const_kind.expect(\"`const_kind` must not be called on a non-const fn\")\n     }\n }\n \n-/// The kinds of items which require compile-time evaluation.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum ConstKind {\n-    /// A `static` item.\n-    Static,\n-    /// A `static mut` item.\n-    StaticMut,\n-    /// A `const fn` item.\n-    ConstFn,\n-    /// A `const` item or an anonymous constant (e.g. in array lengths).\n-    Const,\n-}\n-\n-impl ConstKind {\n-    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n-    /// does not require validation (e.g. a non-const `fn`).\n-    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Option<Self> {\n-        use hir::BodyOwnerKind as HirKind;\n-\n-        let hir_id = tcx.hir().as_local_hir_id(def_id);\n-\n-        let mode = match tcx.hir().body_owner_kind(hir_id) {\n-            HirKind::Closure => return None,\n-\n-            // Note: this is deliberately checking for `is_const_fn_raw`, as the `is_const_fn`\n-            // checks take into account the `rustc_const_unstable` attribute combined with enabled\n-            // feature gates. Otherwise, const qualification would _not check_ whether this\n-            // function body follows the `const fn` rules, as an unstable `const fn` would\n-            // be considered \"not const\". More details are available in issue #67053.\n-            HirKind::Fn if tcx.is_const_fn_raw(def_id) => ConstKind::ConstFn,\n-            HirKind::Fn => return None,\n-\n-            HirKind::Const => ConstKind::Const,\n-\n-            HirKind::Static(hir::Mutability::Not) => ConstKind::Static,\n-            HirKind::Static(hir::Mutability::Mut) => ConstKind::StaticMut,\n-        };\n-\n-        Some(mode)\n-    }\n-\n-    pub fn is_static(self) -> bool {\n-        match self {\n-            ConstKind::Static | ConstKind::StaticMut => true,\n-            ConstKind::ConstFn | ConstKind::Const => false,\n-        }\n-    }\n-}\n-\n-impl fmt::Display for ConstKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ConstKind::Const => write!(f, \"constant\"),\n-            ConstKind::Static | ConstKind::StaticMut => write!(f, \"static\"),\n-            ConstKind::ConstFn => write!(f, \"constant function\"),\n-        }\n-    }\n-}\n-\n /// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()"}, {"sha": "28743ee8e363696ee33d9076d28907d940de3314", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -1,13 +1,14 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n \n-use super::{ConstCx, ConstKind};\n+use super::ConstCx;\n \n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n@@ -326,7 +327,7 @@ impl NonConstOp for RawPtrToIntCast {\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n     fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        ccx.const_kind().is_static()\n+        matches!(ccx.const_kind(), hir::ConstContext::Static(_))\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -374,7 +375,7 @@ pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n     fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n         // Union accesses are stable in all contexts except `const fn`.\n-        ccx.const_kind() != ConstKind::ConstFn\n+        ccx.const_kind() != hir::ConstContext::ConstFn\n             || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n     }\n "}, {"sha": "896ce981f92274520bcc18255dfab355a4a13d26", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -1,7 +1,7 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n use rustc_errors::struct_span_err;\n-use rustc_hir::lang_items;\n+use rustc_hir::{self as hir, lang_items};\n use rustc_hir::{def_id::DefId, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n@@ -18,7 +18,7 @@ use std::ops::Deref;\n use super::ops::{self, NonConstOp};\n use super::qualifs::{self, CustomEq, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n-use super::{is_lang_panic_fn, ConstCx, ConstKind, Qualif};\n+use super::{is_lang_panic_fn, ConstCx, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::impls::MaybeMutBorrowedLocals;\n use crate::dataflow::{self, Analysis};\n@@ -145,17 +145,13 @@ impl Qualifs<'mir, 'tcx> {\n             // We don't care whether a `const fn` returns a value that is not structurally\n             // matchable. Functions calls are opaque and always use type-based qualification, so\n             // this value should never be used.\n-            ConstKind::ConstFn => true,\n+            hir::ConstContext::ConstFn => true,\n \n             // If we know that all values of the return type are structurally matchable, there's no\n             // need to run dataflow.\n-            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut\n-                if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) =>\n-            {\n-                false\n-            }\n+            _ if !CustomEq::in_any_value_of_ty(ccx, ccx.body.return_ty()) => false,\n \n-            ConstKind::Const | ConstKind::Static | ConstKind::StaticMut => {\n+            hir::ConstContext::Const | hir::ConstContext::Static(_) => {\n                 let mut cursor = FlowSensitiveAnalysis::new(CustomEq, ccx)\n                     .into_engine(ccx.tcx, &ccx.body, ccx.def_id)\n                     .iterate_to_fixpoint()\n@@ -198,7 +194,7 @@ impl Validator<'mir, 'tcx> {\n     pub fn check_body(&mut self) {\n         let ConstCx { tcx, body, def_id, const_kind, .. } = *self.ccx;\n \n-        let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n+        let use_min_const_fn_checks = (const_kind == Some(hir::ConstContext::ConstFn)\n             && crate::const_eval::is_min_const_fn(tcx, def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n@@ -222,8 +218,9 @@ impl Validator<'mir, 'tcx> {\n         self.visit_body(&body);\n \n         // Ensure that the end result is `Sync` in a non-thread local `static`.\n-        let should_check_for_sync =\n-            const_kind == Some(ConstKind::Static) && !tcx.is_thread_local_static(def_id);\n+        let should_check_for_sync = const_kind\n+            == Some(hir::ConstContext::Static(hir::Mutability::Not))\n+            && !tcx.is_thread_local_static(def_id);\n \n         if should_check_for_sync {\n             let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n@@ -351,7 +348,9 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                 let ty = place.ty(self.body, self.tcx).ty;\n                 let is_allowed = match ty.kind {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n-                    ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut => {\n+                    ty::Array(..) | ty::Slice(_)\n+                        if self.const_kind() == hir::ConstContext::Static(hir::Mutability::Mut) =>\n+                    {\n                         true\n                     }\n "}, {"sha": "02356a43699e3e7684619349fc408f0bae26182b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -182,7 +182,7 @@ pub fn run_passes(\n }\n \n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n-    let const_kind = check_consts::ConstKind::for_item(tcx, def_id.expect_local());\n+    let const_kind = tcx.hir().body_const_context(def_id.expect_local());\n \n     // No need to const-check a non-const `fn`.\n     if const_kind.is_none() {"}, {"sha": "467e4188814aa87319ca151bcfbfe14037769861", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -13,6 +13,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc_ast::ast::LitKind;\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::traversal::ReversePostorder;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -30,7 +31,7 @@ use std::cell::Cell;\n use std::{cmp, iter, mem};\n \n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx, ConstKind};\n+use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstCx};\n use crate::transform::{MirPass, MirSource};\n \n /// A `MirPass` for promotion.\n@@ -352,7 +353,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             // In theory, any zero-sized value could be borrowed\n                             // mutably without consequences. However, only &mut []\n                             // is allowed right now, and only in functions.\n-                            if self.const_kind == Some(ConstKind::StaticMut) {\n+                            if self.const_kind\n+                                == Some(hir::ConstContext::Static(hir::Mutability::Mut))\n+                            {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n                                 match ty.kind {\n                                     ty::Array(..) | ty::Slice(_) => {}\n@@ -517,7 +520,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 if let Some(def_id) = c.check_static_ptr(self.tcx) {\n                     // Only allow statics (not consts) to refer to other statics.\n                     // FIXME(eddyb) does this matter at all for promotion?\n-                    let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                    let is_static = matches!(self.const_kind, Some(hir::ConstContext::Static(_)));\n                     if !is_static {\n                         return Err(Unpromotable);\n                     }\n@@ -607,7 +610,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n                     // is allowed right now, and only in functions.\n-                    if self.const_kind == Some(ConstKind::StaticMut) {\n+                    if self.const_kind == Some(hir::ConstContext::Static(hir::Mutability::Mut)) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n                         match ty.kind {\n                             ty::Array(..) | ty::Slice(_) => {}"}, {"sha": "c261219cc73cc40ad0681fedc16cb35d69e3f7e5", "filename": "src/librustc_mir/util/liveness.rs", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "patch": "@@ -1,326 +0,0 @@\n-//! Liveness analysis which computes liveness of MIR local variables at the boundary of basic\n-//! blocks.\n-//!\n-//! This analysis considers references as being used only at the point of the\n-//! borrow. This means that this does not track uses because of references that\n-//! already exist:\n-//!\n-//! ```rust\n-//! fn foo() {\n-//!     x = 0;\n-//!     // `x` is live here ...\n-//!     GLOBAL = &x: *const u32;\n-//!     // ... but not here, even while it can be accessed through `GLOBAL`.\n-//!     foo();\n-//!     x = 1;\n-//!     // `x` is live again here, because it is assigned to `OTHER_GLOBAL`.\n-//!     OTHER_GLOBAL = &x: *const u32;\n-//!     // ...\n-//! }\n-//! ```\n-//!\n-//! This means that users of this analysis still have to check whether\n-//! pre-existing references can be used to access the value (e.g., at movable\n-//! generator yield points, all pre-existing references are invalidated, so this\n-//! doesn't matter).\n-\n-use crate::transform::MirSource;\n-use crate::util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::mir::visit::{\n-    MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext, Visitor,\n-};\n-use rustc_middle::mir::Local;\n-use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, TyCtxt};\n-use std::fs;\n-use std::io::{self, BufWriter, Write};\n-use std::path::{Path, PathBuf};\n-\n-pub type LiveVarSet = BitSet<Local>;\n-\n-/// This gives the result of the liveness analysis at the boundary of\n-/// basic blocks.\n-///\n-/// The `V` type defines the set of variables that we computed\n-/// liveness for. This is often `Local`, in which case we computed\n-/// liveness for all variables -- but it can also be some other type,\n-/// which indicates a subset of the variables within the graph.\n-pub struct LivenessResult {\n-    /// Live variables on exit to each basic block. This is equal to\n-    /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LiveVarSet>,\n-}\n-\n-/// Computes which local variables are live within the given function\n-/// `mir`, including drops.\n-pub fn liveness_of_locals(body: &Body<'_>) -> LivenessResult {\n-    let num_live_vars = body.local_decls.len();\n-\n-    let def_use: IndexVec<_, DefsUses> =\n-        body.basic_blocks().iter().map(|b| block(b, num_live_vars)).collect();\n-\n-    let mut outs: IndexVec<_, LiveVarSet> =\n-        body.basic_blocks().indices().map(|_| LiveVarSet::new_empty(num_live_vars)).collect();\n-\n-    let mut bits = LiveVarSet::new_empty(num_live_vars);\n-\n-    // The dirty queue contains the set of basic blocks whose entry sets have changed since they\n-    // were last processed. At the start of the analysis, we initialize the queue in post-order to\n-    // make it more likely that the entry set for a given basic block will have the effects of all\n-    // its successors in the CFG applied before it is processed.\n-    //\n-    // FIXME(ecstaticmorse): Reverse post-order on the reverse CFG may generate a better iteration\n-    // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n-    // any benefits. Benchmark this and find out.\n-    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_none(body.basic_blocks().len());\n-    for (bb, _) in traversal::postorder(&body) {\n-        dirty_queue.insert(bb);\n-    }\n-\n-    // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n-    // be processed after the ones added above.\n-    for bb in body.basic_blocks().indices() {\n-        dirty_queue.insert(bb);\n-    }\n-\n-    let predecessors = body.predecessors();\n-\n-    while let Some(bb) = dirty_queue.pop() {\n-        // bits = use \u222a (bits - def)\n-        bits.overwrite(&outs[bb]);\n-        def_use[bb].apply(&mut bits);\n-\n-        // `bits` now contains the live variables on entry. Therefore,\n-        // add `bits` to the `out` set for each predecessor; if those\n-        // bits were not already present, then enqueue the predecessor\n-        // as dirty.\n-        //\n-        // (note that `union` returns true if the `self` set changed)\n-        for &pred_bb in &predecessors[bb] {\n-            if outs[pred_bb].union(&bits) {\n-                dirty_queue.insert(pred_bb);\n-            }\n-        }\n-    }\n-\n-    LivenessResult { outs }\n-}\n-\n-#[derive(Eq, PartialEq, Clone)]\n-pub enum DefUse {\n-    Def,\n-    Use,\n-    Drop,\n-}\n-\n-pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n-    match context {\n-        ///////////////////////////////////////////////////////////////////////////\n-        // DEFS\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::Store) |\n-\n-        // This is potentially both a def and a use...\n-        PlaceContext::MutatingUse(MutatingUseContext::AsmOutput) |\n-\n-        // We let Call define the result in both the success and\n-        // unwind cases. This is not really correct, however it\n-        // does not seem to be observable due to the way that we\n-        // generate MIR. To do things properly, we would apply\n-        // the def in call only to the input from the success\n-        // path and not the unwind path. -nmatsakis\n-        PlaceContext::MutatingUse(MutatingUseContext::Call) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Yield) |\n-\n-        // Storage live and storage dead aren't proper defines, but we can ignore\n-        // values that come before them.\n-        PlaceContext::NonUse(NonUseContext::StorageLive) |\n-        PlaceContext::NonUse(NonUseContext::StorageDead) => Some(DefUse::Def),\n-\n-        ///////////////////////////////////////////////////////////////////////////\n-        // REGULAR USES\n-        //\n-        // These are uses that occur *outside* of a drop. For the\n-        // purposes of NLL, these are special in that **all** the\n-        // lifetimes appearing in the variable must be live for each regular use.\n-\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Projection) |\n-\n-        // Borrows only consider their local used at the point of the borrow.\n-        // This won't affect the results since we use this analysis for generators\n-        // and we only care about the result at suspension points. Borrows cannot\n-        // cross suspension points so this behavior is unproblematic.\n-        PlaceContext::MutatingUse(MutatingUseContext::Borrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::SharedBorrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n-        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n-        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n-        PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n-            Some(DefUse::Use),\n-\n-        ///////////////////////////////////////////////////////////////////////////\n-        // DROP USES\n-        //\n-        // These are uses that occur in a DROP (a MIR drop, not a\n-        // call to `std::mem::drop()`). For the purposes of NLL,\n-        // uses in drop are special because `#[may_dangle]`\n-        // attributes can affect whether lifetimes must be live.\n-\n-        PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n-            Some(DefUse::Drop),\n-\n-        // Debug info is neither def nor use.\n-        PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n-    }\n-}\n-\n-struct DefsUsesVisitor {\n-    defs_uses: DefsUses,\n-}\n-\n-#[derive(Eq, PartialEq, Clone)]\n-struct DefsUses {\n-    defs: LiveVarSet,\n-    uses: LiveVarSet,\n-}\n-\n-impl DefsUses {\n-    fn apply(&self, bits: &mut LiveVarSet) -> bool {\n-        bits.subtract(&self.defs) | bits.union(&self.uses)\n-    }\n-\n-    fn add_def(&mut self, index: Local) {\n-        // If it was used already in the block, remove that use\n-        // now that we found a definition.\n-        //\n-        // Example:\n-        //\n-        //     // Defs = {X}, Uses = {}\n-        //     X = 5\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        self.uses.remove(index);\n-        self.defs.insert(index);\n-    }\n-\n-    fn add_use(&mut self, index: Local) {\n-        // Inverse of above.\n-        //\n-        // Example:\n-        //\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        //     // Defs = {X}, Uses = {}\n-        //     X = 5\n-        //     // Defs = {}, Uses = {X}\n-        //     use(X)\n-        self.defs.remove(index);\n-        self.uses.insert(index);\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for DefsUsesVisitor {\n-    fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n-        match categorize(context) {\n-            Some(DefUse::Def) => self.defs_uses.add_def(local),\n-            Some(DefUse::Use | DefUse::Drop) => self.defs_uses.add_use(local),\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn block(b: &BasicBlockData<'_>, locals: usize) -> DefsUses {\n-    let mut visitor = DefsUsesVisitor {\n-        defs_uses: DefsUses {\n-            defs: LiveVarSet::new_empty(locals),\n-            uses: LiveVarSet::new_empty(locals),\n-        },\n-    };\n-\n-    let dummy_location = Location { block: BasicBlock::new(0), statement_index: 0 };\n-\n-    // Visit the various parts of the basic block in reverse. If we go\n-    // forward, the logic in `add_def` and `add_use` would be wrong.\n-    visitor.visit_terminator(b.terminator(), dummy_location);\n-    for statement in b.statements.iter().rev() {\n-        visitor.visit_statement(statement, dummy_location);\n-    }\n-\n-    visitor.defs_uses\n-}\n-\n-pub fn dump_mir<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pass_name: &str,\n-    source: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    result: &LivenessResult,\n-) {\n-    if !dump_enabled(tcx, pass_name, source.def_id()) {\n-        return;\n-    }\n-    let node_path = ty::print::with_forced_impl_filename_line(|| {\n-        // see notes on #41697 below\n-        tcx.def_path_str(source.def_id())\n-    });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, body, result);\n-}\n-\n-fn dump_matched_mir_node<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    pass_name: &str,\n-    node_path: &str,\n-    source: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    result: &LivenessResult,\n-) {\n-    let mut file_path = PathBuf::new();\n-    file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n-    let item_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n-    let file_name = format!(\"rustc.node{}{}-liveness.mir\", item_id, pass_name);\n-    file_path.push(&file_name);\n-    let _ = fs::File::create(&file_path).and_then(|file| {\n-        let mut file = BufWriter::new(file);\n-        writeln!(file, \"// MIR local liveness analysis for `{}`\", node_path)?;\n-        writeln!(file, \"// source = {:?}\", source)?;\n-        writeln!(file, \"// pass_name = {}\", pass_name)?;\n-        writeln!(file)?;\n-        write_mir_fn(tcx, source, body, &mut file, result)?;\n-        Ok(())\n-    });\n-}\n-\n-pub fn write_mir_fn<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    src: MirSource<'tcx>,\n-    body: &Body<'tcx>,\n-    w: &mut dyn Write,\n-    result: &LivenessResult,\n-) -> io::Result<()> {\n-    write_mir_intro(tcx, src, body, w)?;\n-    for block in body.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet>| {\n-            let live: Vec<String> =\n-                result[block].iter().map(|local| format!(\"{:?}\", local)).collect();\n-            writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n-        };\n-        write_basic_block(tcx, block, body, &mut |_, _| Ok(()), w)?;\n-        print(w, \"   \", &result.outs)?;\n-        if block.index() + 1 != body.basic_blocks().len() {\n-            writeln!(w)?;\n-        }\n-    }\n-\n-    writeln!(w, \"}}\")?;\n-    Ok(())\n-}"}, {"sha": "8bbe207c077ee23e7957c3c1134557111508d453", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -8,7 +8,6 @@ pub mod storage;\n mod alignment;\n pub mod collect_writes;\n mod graphviz;\n-pub mod liveness;\n pub(crate) mod pretty;\n \n pub use self::aggregate::expand_aggregate;"}, {"sha": "94f9c619a3a26493a5ad649406a1a723bb4b4861", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 7, "deletions": 48, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -7,7 +7,6 @@\n //! errors. We still look for those primitives in the MIR const-checker to ensure nothing slips\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n-use rustc_ast::ast::Mutability;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -19,8 +18,6 @@ use rustc_session::config::nightly_options;\n use rustc_session::parse::feature_err;\n use rustc_span::{sym, Span, Symbol};\n \n-use std::fmt;\n-\n /// An expression that is not *always* legal in a const context.\n #[derive(Clone, Copy)]\n enum NonConstExpr {\n@@ -65,46 +62,6 @@ impl NonConstExpr {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum ConstKind {\n-    Static,\n-    StaticMut,\n-    ConstFn,\n-    Const,\n-    AnonConst,\n-}\n-\n-impl ConstKind {\n-    fn for_body(body: &hir::Body<'_>, tcx: TyCtxt<'_>) -> Option<Self> {\n-        let owner = tcx.hir().body_owner(body.id());\n-        let const_kind = match tcx.hir().body_owner_kind(owner) {\n-            hir::BodyOwnerKind::Const => Self::Const,\n-            hir::BodyOwnerKind::Static(Mutability::Mut) => Self::StaticMut,\n-            hir::BodyOwnerKind::Static(Mutability::Not) => Self::Static,\n-\n-            hir::BodyOwnerKind::Fn if tcx.is_const_fn_raw(tcx.hir().local_def_id(owner)) => {\n-                Self::ConstFn\n-            }\n-            hir::BodyOwnerKind::Fn | hir::BodyOwnerKind::Closure => return None,\n-        };\n-\n-        Some(const_kind)\n-    }\n-}\n-\n-impl fmt::Display for ConstKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let s = match self {\n-            Self::Static => \"static\",\n-            Self::StaticMut => \"static mut\",\n-            Self::Const | Self::AnonConst => \"const\",\n-            Self::ConstFn => \"const fn\",\n-        };\n-\n-        write!(f, \"{}\", s)\n-    }\n-}\n-\n fn check_mod_const_bodies(tcx: TyCtxt<'_>, module_def_id: DefId) {\n     let mut vis = CheckConstVisitor::new(tcx);\n     tcx.hir().visit_item_likes_in_module(module_def_id, &mut vis.as_deep_visitor());\n@@ -117,7 +74,7 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n #[derive(Copy, Clone)]\n struct CheckConstVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    const_kind: Option<ConstKind>,\n+    const_kind: Option<hir::ConstContext>,\n }\n \n impl<'tcx> CheckConstVisitor<'tcx> {\n@@ -147,7 +104,8 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n         let const_kind = self\n             .const_kind\n             .expect(\"`const_check_violated` may only be called inside a const context\");\n-        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind);\n+\n+        let msg = format!(\"{} is not allowed in a `{}`\", expr.name(), const_kind.keyword_name());\n \n         let required_gates = required_gates.unwrap_or(&[]);\n         let missing_gates: Vec<_> =\n@@ -191,7 +149,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n     }\n \n     /// Saves the parent `const_kind` before calling `f` and restores it afterwards.\n-    fn recurse_into(&mut self, kind: Option<ConstKind>, f: impl FnOnce(&mut Self)) {\n+    fn recurse_into(&mut self, kind: Option<hir::ConstContext>, f: impl FnOnce(&mut Self)) {\n         let parent_kind = self.const_kind;\n         self.const_kind = kind;\n         f(self);\n@@ -207,12 +165,13 @@ impl<'tcx> Visitor<'tcx> for CheckConstVisitor<'tcx> {\n     }\n \n     fn visit_anon_const(&mut self, anon: &'tcx hir::AnonConst) {\n-        let kind = Some(ConstKind::AnonConst);\n+        let kind = Some(hir::ConstContext::Const);\n         self.recurse_into(kind, |this| intravisit::walk_anon_const(this, anon));\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        let kind = ConstKind::for_body(body, self.tcx);\n+        let owner = self.tcx.hir().body_owner_def_id(body.id());\n+        let kind = self.tcx.hir().body_const_context(owner);\n         self.recurse_into(kind, |this| intravisit::walk_body(this, body));\n     }\n "}, {"sha": "b60d7e89651425bf14d471b4947d4eea577b7da9", "filename": "src/test/ui/const-generics/trait-const-args.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Fconst-generics%2Ftrait-const-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Fconst-generics%2Ftrait-const-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftrait-const-args.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(const_generics)]\n+\n+struct Const<const N: usize>;\n+trait Foo<const N: usize> {}\n+\n+impl<const N: usize> Foo<N> for Const<N> {}\n+\n+fn foo_impl(_: impl Foo<3>) {}\n+\n+fn foo_explicit<T: Foo<3>>(_: T) {}\n+\n+fn foo_where<T>(_: T)\n+where\n+    T: Foo<3>,\n+{\n+}\n+\n+fn main() {\n+    foo_impl(Const);\n+    foo_impl(Const::<3>);\n+\n+    foo_explicit(Const);\n+    foo_explicit(Const::<3>);\n+\n+    foo_where(Const);\n+    foo_where(Const::<3>);\n+}"}, {"sha": "8dbfeff7972fbb9ac8efb58781df5448383d5d96", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.noopt.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.noopt.stderr?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -5,7 +5,7 @@ LL |     const N: i32 = T::N << 42;\n    |                    ^^^^^^^^^^ attempt to shift left with overflow\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-exceeding-bitshifts.rs:8:9\n+  --> $DIR/lint-exceeding-bitshifts.rs:9:9\n    |\n LL | #![warn(arithmetic_overflow, const_err)]\n    |         ^^^^^^^^^^^^^^^^^^^"}, {"sha": "8dbfeff7972fbb9ac8efb58781df5448383d5d96", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.opt.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt.stderr?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -5,7 +5,7 @@ LL |     const N: i32 = T::N << 42;\n    |                    ^^^^^^^^^^ attempt to shift left with overflow\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-exceeding-bitshifts.rs:8:9\n+  --> $DIR/lint-exceeding-bitshifts.rs:9:9\n    |\n LL | #![warn(arithmetic_overflow, const_err)]\n    |         ^^^^^^^^^^^^^^^^^^^"}, {"sha": "8dbfeff7972fbb9ac8efb58781df5448383d5d96", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.opt_with_overflow_checks.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.opt_with_overflow_checks.stderr?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -5,7 +5,7 @@ LL |     const N: i32 = T::N << 42;\n    |                    ^^^^^^^^^^ attempt to shift left with overflow\n    |\n note: the lint level is defined here\n-  --> $DIR/lint-exceeding-bitshifts.rs:8:9\n+  --> $DIR/lint-exceeding-bitshifts.rs:9:9\n    |\n LL | #![warn(arithmetic_overflow, const_err)]\n    |         ^^^^^^^^^^^^^^^^^^^"}, {"sha": "4d56d103a8343c95c5a9777fd3f53d174d61e0ab", "filename": "src/test/ui/lint/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b805396bf46dce972692a6846ce2ad8481c5f85/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-exceeding-bitshifts.rs?ref=7b805396bf46dce972692a6846ce2ad8481c5f85", "patch": "@@ -3,11 +3,11 @@\n //[opt]compile-flags: -O\n //[opt_with_overflow_checks]compile-flags: -C overflow-checks=on -O\n // build-pass\n+// ignore-pass (test emits codegen-time warnings and verifies that they are not errors)\n \n #![crate_type=\"lib\"]\n #![warn(arithmetic_overflow, const_err)]\n-#![allow(unused_variables)]\n-#![allow(dead_code)]\n+\n \n pub trait Foo {\n     const N: i32;"}]}