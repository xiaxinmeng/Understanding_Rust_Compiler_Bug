{"sha": "0d9afcd9b9f881545c8b722855f7e39361495d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOWFmY2Q5YjlmODgxNTQ1YzhiNzIyODU1ZjdlMzkzNjE0OTVkMjc=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-05T17:00:48Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-11T22:13:52Z"}, "message": "Merge core::unicode::str into core::str\n\nAnd the UnicodeStr trait into StrExt", "tree": {"sha": "79a181ea1964b4c054e97ee107b58f3b7488b8a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79a181ea1964b4c054e97ee107b58f3b7488b8a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d9afcd9b9f881545c8b722855f7e39361495d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9afcd9b9f881545c8b722855f7e39361495d27", "html_url": "https://github.com/rust-lang/rust/commit/0d9afcd9b9f881545c8b722855f7e39361495d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d9afcd9b9f881545c8b722855f7e39361495d27/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33358dc3c5c1f5d627544075de6ff37b9e328efa", "url": "https://api.github.com/repos/rust-lang/rust/commits/33358dc3c5c1f5d627544075de6ff37b9e328efa", "html_url": "https://github.com/rust-lang/rust/commit/33358dc3c5c1f5d627544075de6ff37b9e328efa"}], "stats": {"total": 380, "additions": 182, "deletions": 198}, "files": [{"sha": "0b961c2c1861285f89a5fecead61c64630715307", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=0d9afcd9b9f881545c8b722855f7e39361495d27", "patch": "@@ -45,7 +45,7 @@ use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n use core::iter::FusedIterator;\n-use core::unicode::str::{UnicodeStr, Utf16Encoder};\n+use core::unicode::Utf16Encoder;\n \n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n@@ -74,7 +74,7 @@ pub use core::str::{from_utf8, from_utf8_mut, Chars, CharIndices, Bytes};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{from_utf8_unchecked, from_utf8_unchecked_mut, ParseBoolError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::unicode::str::SplitWhitespace;\n+pub use core::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n \n@@ -800,7 +800,7 @@ impl str {\n     #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n     #[inline]\n     pub fn split_whitespace(&self) -> SplitWhitespace {\n-        UnicodeStr::split_whitespace(self)\n+        StrExt::split_whitespace(self)\n     }\n \n     /// An iterator over the lines of a string, as string slices.\n@@ -1570,7 +1570,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim(&self) -> &str {\n-        UnicodeStr::trim(self)\n+        StrExt::trim(self)\n     }\n \n     /// Returns a string slice with leading whitespace removed.\n@@ -1606,7 +1606,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self)\n+        StrExt::trim_left(self)\n     }\n \n     /// Returns a string slice with trailing whitespace removed.\n@@ -1642,7 +1642,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self)\n+        StrExt::trim_right(self)\n     }\n \n     /// Returns a string slice with all prefixes and suffixes that match a\n@@ -2141,7 +2141,7 @@ impl str {\n     #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n     #[inline]\n     pub fn is_whitespace(&self) -> bool {\n-        UnicodeStr::is_whitespace(self)\n+        StrExt::is_whitespace(self)\n     }\n \n     /// Returns true if this `str` is entirely alphanumeric, and false otherwise.\n@@ -2160,7 +2160,7 @@ impl str {\n     #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n-        UnicodeStr::is_alphanumeric(self)\n+        StrExt::is_alphanumeric(self)\n     }\n \n     /// Checks if all characters in this string are within the ASCII range."}, {"sha": "2df8ca63a3eeb4b5a570afe3c4ccf49285f9f925", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=0d9afcd9b9f881545c8b722855f7e39361495d27", "patch": "@@ -1204,7 +1204,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    use core::unicode::str::Utf16Encoder;\n+    use core::unicode::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n                [0xE9, 0xD83D, 0xDCA9])\n }"}, {"sha": "f1fe23092de93924f2c1549758bcb84462cfc08b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0d9afcd9b9f881545c8b722855f7e39361495d27", "patch": "@@ -19,7 +19,7 @@ use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n \n use char;\n use fmt;\n-use iter::{Map, Cloned, FusedIterator, TrustedLen};\n+use iter::{Map, Cloned, FusedIterator, TrustedLen, Filter};\n use iter_private::TrustedRandomAccess;\n use slice::{self, SliceIndex};\n use mem;\n@@ -2216,6 +2216,18 @@ pub trait StrExt {\n     fn is_empty(&self) -> bool;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n+    #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    fn is_whitespace(&self) -> bool;\n+    #[stable(feature = \"unicode_methods_on_intrinsics\", since = \"1.27.0\")]\n+    fn is_alphanumeric(&self) -> bool;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim(&self) -> &str;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim_left(&self) -> &str;\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn trim_right(&self) -> &str;\n }\n \n // truncate `&str` to length at most equal to `max`\n@@ -2536,6 +2548,36 @@ impl StrExt for str {\n \n     #[inline]\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n+\n+    #[inline]\n+    fn split_whitespace(&self) -> SplitWhitespace {\n+        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(&self) -> bool {\n+        self.chars().all(|c| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_alphanumeric(&self) -> bool {\n+        self.chars().all(|c| c.is_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn trim(&self) -> &str {\n+        self.trim_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_left(&self) -> &str {\n+        self.trim_left_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    #[inline]\n+    fn trim_right(&self) -> &str {\n+        self.trim_right_matches(|c: char| c.is_whitespace())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2551,3 +2593,75 @@ impl<'a> Default for &'a str {\n     /// Creates an empty str\n     fn default() -> &'a str { \"\" }\n }\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n+/// [`str`]: ../../std/primitive.str.html\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitWhitespace<'a> {\n+    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n+}\n+\n+#[derive(Clone)]\n+struct IsWhitespace;\n+\n+impl FnOnce<(char, )> for IsWhitespace {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl FnMut<(char, )> for IsWhitespace {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n+        arg.0.is_whitespace()\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct IsNotEmpty;\n+\n+impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n+    type Output = bool;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n+        self.call_mut(arg)\n+    }\n+}\n+\n+impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n+        !arg.0.is_empty()\n+    }\n+}\n+\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> Iterator for SplitWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+}\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a> FusedIterator for SplitWhitespace<'a> {}"}, {"sha": "3413476fd2288bb9b83fb3b9678e0188f8647d0c", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9afcd9b9f881545c8b722855f7e39361495d27/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=0d9afcd9b9f881545c8b722855f7e39361495d27", "patch": "@@ -15,8 +15,6 @@ mod bool_trie;\n pub(crate) mod tables;\n pub(crate) mod version;\n \n-pub mod str;\n-\n // For use in liballoc, not re-exported in libstd.\n pub mod derived_property {\n     pub use unicode::tables::derived_property::{Case_Ignorable, Cased};\n@@ -26,3 +24,61 @@ pub mod derived_property {\n pub mod property {\n     pub use unicode::tables::property::Pattern_White_Space;\n }\n+\n+use iter::FusedIterator;\n+\n+/// Iterator adaptor for encoding `char`s to UTF-16.\n+#[derive(Clone)]\n+#[allow(missing_debug_implementations)]\n+pub struct Utf16Encoder<I> {\n+    chars: I,\n+    extra: u16,\n+}\n+\n+impl<I> Utf16Encoder<I> {\n+    /// Create a UTF-16 encoder from any `char` iterator.\n+    pub fn new(chars: I) -> Utf16Encoder<I>\n+        where I: Iterator<Item = char>\n+    {\n+        Utf16Encoder {\n+            chars,\n+            extra: 0,\n+        }\n+    }\n+}\n+\n+impl<I> Iterator for Utf16Encoder<I>\n+    where I: Iterator<Item = char>\n+{\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+impl<I> FusedIterator for Utf16Encoder<I>\n+    where I: FusedIterator<Item = char> {}"}, {"sha": "0882984e0774c580b18cdb826dbcda35e9f599c1", "filename": "src/libcore/unicode/str.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/33358dc3c5c1f5d627544075de6ff37b9e328efa/src%2Flibcore%2Funicode%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33358dc3c5c1f5d627544075de6ff37b9e328efa/src%2Flibcore%2Funicode%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fstr.rs?ref=33358dc3c5c1f5d627544075de6ff37b9e328efa", "patch": "@@ -1,186 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Unicode-intensive string manipulations.\n-\n-use char;\n-use iter::{Filter, FusedIterator};\n-use str::Split;\n-\n-/// An iterator over the non-whitespace substrings of a string,\n-/// separated by any amount of whitespace.\n-///\n-/// This struct is created by the [`split_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_whitespace`]: ../../std/primitive.str.html#method.split_whitespace\n-/// [`str`]: ../../std/primitive.str.html\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitWhitespace<'a> {\n-    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n-}\n-\n-/// Methods for Unicode string slices\n-#[allow(missing_docs)] // docs in liballoc\n-pub trait UnicodeStr {\n-    fn split_whitespace<'a>(&'a self) -> SplitWhitespace<'a>;\n-    fn is_whitespace(&self) -> bool;\n-    fn is_alphanumeric(&self) -> bool;\n-    fn trim(&self) -> &str;\n-    fn trim_left(&self) -> &str;\n-    fn trim_right(&self) -> &str;\n-}\n-\n-impl UnicodeStr for str {\n-    #[inline]\n-    fn split_whitespace(&self) -> SplitWhitespace {\n-        SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n-    }\n-\n-    #[inline]\n-    fn is_whitespace(&self) -> bool {\n-        self.chars().all(|c| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_alphanumeric(&self) -> bool {\n-        self.chars().all(|c| c.is_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn trim(&self) -> &str {\n-        self.trim_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_left(&self) -> &str {\n-        self.trim_left_matches(|c: char| c.is_whitespace())\n-    }\n-\n-    #[inline]\n-    fn trim_right(&self) -> &str {\n-        self.trim_right_matches(|c: char| c.is_whitespace())\n-    }\n-}\n-\n-/// Iterator adaptor for encoding `char`s to UTF-16.\n-#[derive(Clone)]\n-#[allow(missing_debug_implementations)]\n-pub struct Utf16Encoder<I> {\n-    chars: I,\n-    extra: u16,\n-}\n-\n-impl<I> Utf16Encoder<I> {\n-    /// Create a UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I>\n-        where I: Iterator<Item = char>\n-    {\n-        Utf16Encoder {\n-            chars,\n-            extra: 0,\n-        }\n-    }\n-}\n-\n-impl<I> Iterator for Utf16Encoder<I>\n-    where I: Iterator<Item = char>\n-{\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(&mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-impl<I> FusedIterator for Utf16Encoder<I>\n-    where I: FusedIterator<Item = char> {}\n-\n-#[derive(Clone)]\n-struct IsWhitespace;\n-\n-impl FnOnce<(char, )> for IsWhitespace {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (char, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl FnMut<(char, )> for IsWhitespace {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (char, )) -> bool {\n-        arg.0.is_whitespace()\n-    }\n-}\n-\n-#[derive(Clone)]\n-struct IsNotEmpty;\n-\n-impl<'a, 'b> FnOnce<(&'a &'b str, )> for IsNotEmpty {\n-    type Output = bool;\n-\n-    #[inline]\n-    extern \"rust-call\" fn call_once(mut self, arg: (&&str, )) -> bool {\n-        self.call_mut(arg)\n-    }\n-}\n-\n-impl<'a, 'b> FnMut<(&'a &'b str, )> for IsNotEmpty {\n-    #[inline]\n-    extern \"rust-call\" fn call_mut(&mut self, arg: (&&str, )) -> bool {\n-        !arg.0.is_empty()\n-    }\n-}\n-\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> Iterator for SplitWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-}\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for SplitWhitespace<'a> {}"}]}