{"sha": "5af80d83726e01fe54e569d77fee6a504d1d4bd2", "node_id": "C_kwDOAAsO6NoAKDVhZjgwZDgzNzI2ZTAxZmU1NGU1NjlkNzdmZWU2YTUwNGQxZDRiZDI", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T13:08:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-10T13:10:35Z"}, "message": "internal: move derived tests to the unified macro infra", "tree": {"sha": "eacfee18fd086159ec6c99f10350d64e0ca6df07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eacfee18fd086159ec6c99f10350d64e0ca6df07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5af80d83726e01fe54e569d77fee6a504d1d4bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5af80d83726e01fe54e569d77fee6a504d1d4bd2", "html_url": "https://github.com/rust-lang/rust/commit/5af80d83726e01fe54e569d77fee6a504d1d4bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5af80d83726e01fe54e569d77fee6a504d1d4bd2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55d8be5a241518e9d58ee62e2947781d7bbd763c", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d8be5a241518e9d58ee62e2947781d7bbd763c", "html_url": "https://github.com/rust-lang/rust/commit/55d8be5a241518e9d58ee62e2947781d7bbd763c"}], "stats": {"total": 225, "additions": 98, "deletions": 127}, "files": [{"sha": "5f8bf44cc93ba5c3a0a5722dd5ad9a2be48a887d", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=5af80d83726e01fe54e569d77fee6a504d1d4bd2", "patch": "@@ -11,6 +11,7 @@\n \n mod mbe;\n mod builtin_fn_macro;\n+mod builtin_derive_macro;\n \n use std::{iter, ops::Range};\n \n@@ -26,7 +27,8 @@ use syntax::{\n };\n \n use crate::{\n-    db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, test_db::TestDB, AsMacroCall,\n+    db::DefDatabase, nameres::ModuleSource, resolver::HasResolver, src::HasSource, test_db::TestDB,\n+    AsMacroCall, Lookup,\n };\n \n #[track_caller]\n@@ -43,6 +45,21 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n         ModuleSource::Module(_) | ModuleSource::BlockExpr(_) => panic!(),\n     };\n \n+    // What we want to do is to replace all macros (fn-like, derive, attr) with\n+    // their expansions. Turns out, we don't actually store enough information\n+    // to do this precisely though! Specifically, if a macro expands to nothing,\n+    // it leaves zero traces in def-map, so we can't get its expansion after the\n+    // fact.\n+    //\n+    // This is the usual\n+    // <https://github.com/rust-analyzer/rust-analyzer/issues/3407>\n+    // resolve/record tension!\n+    //\n+    // So here we try to do a resolve, which is necessary a heuristic. For macro\n+    // calls, we use `as_call_id_with_errors`. For derives, we look at the impls\n+    // in the module and assume that, if impls's source is a different\n+    // `HirFileId`, than it came from macro expansion.\n+\n     let mut expansions = Vec::new();\n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n@@ -63,6 +80,7 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n     }\n \n     let mut expanded_text = source_file.to_string();\n+\n     for (call, exp) in expansions.into_iter().rev() {\n         let mut tree = false;\n         let mut expect_errors = false;\n@@ -106,6 +124,14 @@ fn check(ra_fixture: &str, mut expect: Expect) {\n         expanded_text.replace_range(range, &expn_text)\n     }\n \n+    for impl_id in def_map[local_id].scope.impls() {\n+        let src = impl_id.lookup(&db).source(&db);\n+        if src.file_id.is_builtin_derive(&db).is_some() {\n+            let pp = pretty_print_macro_expansion(src.value.syntax().clone());\n+            format_to!(expanded_text, \"\\n{}\", pp)\n+        }\n+    }\n+\n     expect.indent(false);\n     expect.assert_eq(&expanded_text);\n }"}, {"sha": "177409dc3803f23860b5f71a5750d353ec2f2fba", "filename": "crates/hir_def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=5af80d83726e01fe54e569d77fee6a504d1d4bd2", "patch": "@@ -0,0 +1,70 @@\n+//! Tests for `builtin_derive_macro.rs` from `hir_expand`.\n+\n+use expect_test::expect;\n+\n+use crate::macro_expansion_tests::check;\n+\n+#[test]\n+fn test_copy_expand_simple() {\n+    check(\n+        r#\"\n+//- minicore: derive, copy\n+#[derive(Copy)]\n+struct Foo;\n+\"#,\n+        expect![[r##\"\n+#[derive(Copy)]\n+struct Foo;\n+\n+impl < > core::marker::Copy for Foo< > {}\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_copy_expand_with_type_params() {\n+    check(\n+        r#\"\n+//- minicore: derive, copy\n+#[derive(Copy)]\n+struct Foo<A, B>;\n+\"#,\n+        expect![[r##\"\n+#[derive(Copy)]\n+struct Foo<A, B>;\n+\n+impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_copy_expand_with_lifetimes() {\n+    // We currently just ignore lifetimes\n+    check(\n+        r#\"\n+//- minicore: derive, copy\n+#[derive(Copy)]\n+struct Foo<A, B, 'a, 'b>;\n+\"#,\n+        expect![[r##\"\n+#[derive(Copy)]\n+struct Foo<A, B, 'a, 'b>;\n+\n+impl <T0: core::marker::Copy, T1: core::marker::Copy> core::marker::Copy for Foo<T0, T1> {}\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_clone_expand() {\n+    check(\n+        r#\"\n+//- minicore: derive, clone\n+#[derive(Clone)]\n+struct Foo<A, B>;\n+\"#,\n+        expect![[r##\"\n+#[derive(Clone)]\n+struct Foo<A, B>;\n+\n+impl <T0: core::clone::Clone, T1: core::clone::Clone> core::clone::Clone for Foo<T0, T1> {}\"##]],\n+    );\n+}"}, {"sha": "06039e95c5f059bad1ed3bc931c2987a1b2731a8", "filename": "crates/hir_def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=5af80d83726e01fe54e569d77fee6a504d1d4bd2", "patch": "@@ -1,4 +1,4 @@\n-//! Tests for builtin macros (see `builtin_macro.rs` in `hir_expand`).\n+//! Tests for `builtin_fn_macro.rs` from `hir_expand`.\n \n use expect_test::expect;\n "}, {"sha": "d4fcf42dd3f483572f335b116581b455a72d2529", "filename": "crates/hir_expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5af80d83726e01fe54e569d77fee6a504d1d4bd2/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=5af80d83726e01fe54e569d77fee6a504d1d4bd2", "patch": "@@ -258,128 +258,3 @@ fn partial_ord_expand(\n     let krate = find_builtin_crate(db, id);\n     expand_simple_derive(tt, quote! { #krate::cmp::PartialOrd })\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use base_db::{fixture::WithFixture, CrateId, SourceDatabase};\n-    use expect_test::{expect, Expect};\n-    use name::AsName;\n-\n-    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n-\n-    use super::*;\n-\n-    fn expand_builtin_derive(ra_fixture: &str) -> String {\n-        let fixture = format!(\n-            r#\"//- /main.rs crate:main deps:core\n-$0\n-{}\n-//- /lib.rs crate:core\n-// empty\n-\"#,\n-            ra_fixture\n-        );\n-\n-        let (db, file_pos) = TestDB::with_position(&fixture);\n-        let file_id = file_pos.file_id;\n-        let ast_id_map = db.ast_id_map(file_id.into());\n-        let parsed = db.parse(file_id);\n-        let macros: Vec<_> =\n-            parsed.syntax_node().descendants().filter_map(ast::Macro::cast).collect();\n-        let items: Vec<_> = parsed\n-            .syntax_node()\n-            .descendants()\n-            .filter(|node| !ast::Macro::can_cast(node.kind()))\n-            .filter_map(ast::Item::cast)\n-            .collect();\n-\n-        assert_eq!(macros.len(), 1, \"test must contain exactly 1 macro definition\");\n-        assert_eq!(items.len(), 1, \"test must contain exactly 1 item\");\n-\n-        let macro_ast_id = AstId::new(file_id.into(), ast_id_map.ast_id(&macros[0]));\n-        let name = match &macros[0] {\n-            ast::Macro::MacroRules(rules) => rules.name().unwrap().as_name(),\n-            ast::Macro::MacroDef(def) => def.name().unwrap().as_name(),\n-        };\n-\n-        let expander = BuiltinDeriveExpander::find_by_name(&name).unwrap();\n-\n-        let ast_id = AstId::new(file_id.into(), ast_id_map.ast_id(&items[0]));\n-\n-        let loc = MacroCallLoc {\n-            def: MacroDefId {\n-                krate: CrateId(0),\n-                kind: MacroDefKind::BuiltInDerive(expander, macro_ast_id),\n-                local_inner: false,\n-            },\n-            krate: CrateId(0),\n-            eager: None,\n-            kind: MacroCallKind::Derive {\n-                ast_id,\n-                derive_name: name.to_string(),\n-                derive_attr_index: 0,\n-            },\n-        };\n-\n-        let id: MacroCallId = db.intern_macro(loc);\n-        let parsed = db.parse_or_expand(id.as_file()).unwrap();\n-\n-        // FIXME text() for syntax nodes parsed from token tree looks weird\n-        // because there's no whitespace, see below\n-        parsed.text().to_string()\n-    }\n-\n-    fn check_derive(ra_fixture: &str, expected: Expect) {\n-        let expanded = expand_builtin_derive(ra_fixture);\n-        expected.assert_eq(&expanded);\n-    }\n-\n-    #[test]\n-    fn test_copy_expand_simple() {\n-        check_derive(\n-            r#\"\n-            macro Copy {}\n-            #[derive(Copy)]\n-            struct Foo;\n-            \"#,\n-            expect![[\"impl< >core::marker::CopyforFoo< >{}\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_copy_expand_with_type_params() {\n-        check_derive(\n-            r#\"\n-            macro Copy {}\n-            #[derive(Copy)]\n-            struct Foo<A, B>;\n-            \"#,\n-            expect![[\"impl<T0:core::marker::Copy,T1:core::marker::Copy>core::marker::CopyforFoo<T0,T1>{}\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_copy_expand_with_lifetimes() {\n-        check_derive(\n-            r#\"\n-            macro Copy {}\n-            #[derive(Copy)]\n-            struct Foo<A, B, 'a, 'b>;\n-            \"#,\n-            // We currently just ignore lifetimes\n-            expect![[\"impl<T0:core::marker::Copy,T1:core::marker::Copy>core::marker::CopyforFoo<T0,T1>{}\"]],\n-        );\n-    }\n-\n-    #[test]\n-    fn test_clone_expand() {\n-        check_derive(\n-            r#\"\n-            macro Clone {}\n-            #[derive(Clone)]\n-            struct Foo<A, B>;\n-            \"#,\n-            expect![[\"impl<T0:core::clone::Clone,T1:core::clone::Clone>core::clone::CloneforFoo<T0,T1>{}\"]],\n-        );\n-    }\n-}"}]}