{"sha": "f1d61837d1cf058cfbd0902b0bf79a2657b81187", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDYxODM3ZDFjZjA1OGNmYmQwOTAyYjBiZjc5YTI2NTdiODExODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T22:17:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T22:17:46Z"}, "message": "Auto merge of #55912 - kennytm:rollup, r=kennytm\n\nRollup of 20 pull requests\n\nSuccessful merges:\n\n - #55136 (Remove short doc where it starts with a codeblock)\n - #55711 (Format BtreeMap::range_mut example)\n - #55722 (impl_stable_hash_for: support enums and tuple structs with generic parameters)\n - #55754 (Avoid converting bytes to UTF-8 strings to print, just pass bytes to stdout/err)\n - #55804 (rustdoc: don't inline `pub use some_crate` unless directly asked to)\n - #55805 (Move `static_assert!` into librustc_data_structures)\n - #55837 (Make PhantomData #[structural_match])\n - #55840 (Fix TLS errors when downloading stage0)\n - #55843 (add FromIterator<A> to Box<[A]>)\n - #55858 (Small fixes on code blocks in rustdoc)\n - #55863 (Fix a typo in std::panic)\n - #55870 (Fix typos.)\n - #55874 (string: Add documentation for `From` impls)\n - #55879 (save-analysis: Don't panic for macro-generated use globs)\n - #55882 (Reference count `crate_inherent_impls`s return value.)\n - #55888 (miri: for uniformity, also move memory_deallocated to AllocationExtra)\n - #55889 (global allocators: add a few comments)\n - #55896 (Document optimizations enabled by FusedIterator)\n - #55905 (Change `Lit::short_name` to `Lit::literal_name`.)\n - #55908 (Fix their/there grammar nit)", "tree": {"sha": "21c9d58f3ee5f7799f5079b0527013712b52e7b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c9d58f3ee5f7799f5079b0527013712b52e7b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d61837d1cf058cfbd0902b0bf79a2657b81187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d61837d1cf058cfbd0902b0bf79a2657b81187", "html_url": "https://github.com/rust-lang/rust/commit/f1d61837d1cf058cfbd0902b0bf79a2657b81187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d61837d1cf058cfbd0902b0bf79a2657b81187/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fefb67669f00c25b476e7a80c9c9300a987d517", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fefb67669f00c25b476e7a80c9c9300a987d517", "html_url": "https://github.com/rust-lang/rust/commit/9fefb67669f00c25b476e7a80c9c9300a987d517"}, {"sha": "7921572acf98d573464eae4aad73112a0d3d6f82", "url": "https://api.github.com/repos/rust-lang/rust/commits/7921572acf98d573464eae4aad73112a0d3d6f82", "html_url": "https://github.com/rust-lang/rust/commit/7921572acf98d573464eae4aad73112a0d3d6f82"}], "stats": {"total": 1112, "additions": 603, "deletions": 509}, "files": [{"sha": "a4f89960a0bfdc06e1cf37f98551459998b894b2", "filename": "src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -5,7 +5,7 @@ This directory contains the source code of the rust project, including:\n \n For more information on how various parts of the compiler work, see the [rustc guide].\n \n-Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n+There is also useful content in the following READMEs, which are gradually being moved over to the guide:\n - https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n - https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n - https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints"}, {"sha": "cd48e6aa4c4ba36c1ff14711ec602d416de8141c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -79,8 +79,8 @@ def _download(path, url, probably_big, verbose, exception):\n     # see http://serverfault.com/questions/301128/how-to-download\n     if sys.platform == 'win32':\n         run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n-             \"(New-Object System.Net.WebClient)\"\n-             \".DownloadFile('{}', '{}')\".format(url, path)],\n+             \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n+             \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\".format(url, path)],\n             verbose=verbose,\n             exception=exception)\n     else:"}, {"sha": "c8689f7814086c927f87aaff77454cca2a6ee420", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -203,7 +203,7 @@ impl Step for StdLink {\n \n     /// Link all libstd rlibs/dylibs into the sysroot location.\n     ///\n-    /// Links those artifacts generated by `compiler` to a the `stage` compiler's\n+    /// Links those artifacts generated by `compiler` to the `stage` compiler's\n     /// sysroot for the specified `host` and `target`.\n     ///\n     /// Note that this assumes that `compiler` has already generated the libstd"}, {"sha": "61e5b3d0133ff6980bd886d17070197b34f3eace", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -186,6 +186,9 @@ mod bar {\n \n Now we'll have a `Re-exports` line, and `Bar` will not link to anywhere.\n \n+One special case: In Rust 2018 and later, if you `pub use` one of your dependencies, `rustdoc` will\n+not eagerly inline it as a module unless you add `#[doc(inline)}`.\n+\n ## `#[doc(hidden)]`\n \n Any item annotated with `#[doc(hidden)]` will not appear in the documentation, unless"}, {"sha": "b0220c84ef2fa78216a1e20a967c993003789bda", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -12,7 +12,7 @@\n # containing LLDB commands (one command per line), this script will execute the commands one after\n # the other.\n # LLDB also has the -s and -S commandline options which also execute a list of commands from a text\n-# file. However, this command are execute `immediately`: a the command of a `run` or `continue`\n+# file. However, this command are execute `immediately`: the command of a `run` or `continue`\n # command will be executed immediately after the `run` or `continue`, without waiting for the next\n # breakpoint to be hit. This a command sequence like the following will not yield reliable results:\n #"}, {"sha": "1a8a081e16fadc105ae6c1b46221f66f4673b149", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -21,6 +21,10 @@ use core::usize;\n pub use core::alloc::*;\n \n extern \"Rust\" {\n+    // These are the magic symbols to call the global allocator.  rustc generates\n+    // them from the `#[global_allocator]` attribute if there is one, or uses the\n+    // default implementations in libstd (`__rdl_alloc` etc in `src/libstd/alloc.rs`)\n+    // otherwise.\n     #[allocator]\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc(size: usize, align: usize) -> *mut u8;"}, {"sha": "63b262d1f3d986ac22aa793a2270c1b735e11a3e", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -73,14 +73,15 @@ use core::convert::From;\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n-use core::iter::FusedIterator;\n+use core::iter::{Iterator, FromIterator, FusedIterator};\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::pin::Pin;\n use core::ops::{CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{LocalWaker, Poll};\n \n+use vec::Vec;\n use raw_vec::RawVec;\n use str::from_boxed_utf8_unchecked;\n \n@@ -699,6 +700,13 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n \n+#[stable(feature = \"boxed_slice_from_iter\", since = \"1.32.0\")]\n+impl<A> FromIterator<A> for Box<[A]> {\n+    fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self {\n+        iter.into_iter().collect::<Vec<_>>().into_boxed_slice()\n+    }\n+}\n+\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {"}, {"sha": "f340ea01c5f07d0b6d8bc35865985d621ea4a50a", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -140,3 +140,11 @@ fn str_slice() {\n     let boxed: Box<str> = Box::from(s);\n     assert_eq!(&*boxed, s)\n }\n+\n+#[test]\n+fn boxed_slice_from_iter() {\n+    let iter = 0..100;\n+    let boxed: Box<[u32]> = iter.collect();\n+    assert_eq!(boxed.len(), 100);\n+    assert_eq!(boxed[7], 7);\n+}"}, {"sha": "49e488702b4b9538e7f650d3ec99af540ff09045", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -853,9 +853,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     /// use std::collections::BTreeMap;\n     ///\n-    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"].iter()\n-    ///                                                                       .map(|&s| (s, 0))\n-    ///                                                                       .collect();\n+    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"]\n+    ///     .iter()\n+    ///     .map(|&s| (s, 0))\n+    ///     .collect();\n     /// for (_, balance) in map.range_mut(\"B\"..\"Cheryl\") {\n     ///     *balance += 100;\n     /// }"}, {"sha": "2beb3240aaca0d24b90553b965b35360287deb31", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -2206,13 +2206,40 @@ impl<'a> From<&'a str> for String {\n #[cfg(not(test))]\n #[stable(feature = \"string_from_box\", since = \"1.18.0\")]\n impl From<Box<str>> for String {\n+    /// Converts the given boxed `str` slice to a `String`.\n+    /// It is notable that the `str` slice is owned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s1: String = String::from(\"hello world\");\n+    /// let s2: Box<str> = s1.into_boxed_str();\n+    /// let s3: String = String::from(s2);\n+    ///\n+    /// assert_eq!(\"hello world\", s3)\n+    /// ```\n     fn from(s: Box<str>) -> String {\n         s.into_string()\n     }\n }\n \n #[stable(feature = \"box_from_str\", since = \"1.20.0\")]\n impl From<String> for Box<str> {\n+    /// Converts the given `String` to a boxed `str` slice that is owned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s1: String = String::from(\"hello world\");\n+    /// let s2: Box<str> = Box::from(s1);\n+    /// let s3: String = String::from(s2);\n+    ///\n+    /// assert_eq!(\"hello world\", s3)\n+    /// ```\n     fn from(s: String) -> Box<str> {\n         s.into_boxed_str()\n     }\n@@ -2272,6 +2299,20 @@ impl<'a> FromIterator<String> for Cow<'a, str> {\n \n #[stable(feature = \"from_string_for_vec_u8\", since = \"1.14.0\")]\n impl From<String> for Vec<u8> {\n+    /// Converts the given `String` to a vector `Vec` that holds values of type `u8`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s1 = String::from(\"hello world\");\n+    /// let v1 = Vec::from(s1);\n+    ///\n+    /// for b in v1 {\n+    ///     println!(\"{}\", b);\n+    /// }\n+    /// ```\n     fn from(string: String) -> Vec<u8> {\n         string.into_bytes()\n     }"}, {"sha": "d2c5a3bed2869aa137a91b7af1dc225ced0a29d2", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -960,7 +960,7 @@ impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n ///\n /// Calling next on a fused iterator that has returned `None` once is guaranteed\n /// to return [`None`] again. This trait should be implemented by all iterators\n-/// that behave this way because it allows for some significant optimizations.\n+/// that behave this way because it allows optimizing [`Iterator::fuse`].\n ///\n /// Note: In general, you should not use `FusedIterator` in generic bounds if\n /// you need a fused iterator. Instead, you should just call [`Iterator::fuse`]"}, {"sha": "5872ac815c25941a67ed8e3cf75a6188c5ef63df", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -128,6 +128,7 @@\n #![feature(const_transmute)]\n #![feature(reverse_bits)]\n #![feature(non_exhaustive)]\n+#![feature(structural_match)]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "3bcdfabbb245e6f29c4882fddeeb674329ee914b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -578,6 +578,7 @@ macro_rules! impls{\n ///\n /// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n+#[structural_match]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n "}, {"sha": "a316093825ad75db5082612a33049346c27bcdd8", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -1896,7 +1896,7 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             // is_char_boundary checks that the index is in [0, .len()]\n-            // canot reuse `get` as above, because of NLL trouble\n+            // cannot reuse `get` as above, because of NLL trouble\n             if self.start <= self.end &&\n                slice.is_char_boundary(self.start) &&\n                slice.is_char_boundary(self.end) {"}, {"sha": "c42c19e82c7c8a23f8faef1902c8c8a25fe646e7", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 17, "deletions": 54, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -37,68 +37,31 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, details, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::BorrowKind {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::BorrowKind::Shared |\n-            mir::BorrowKind::Shallow |\n-            mir::BorrowKind::Unique => {}\n-            mir::BorrowKind::Mut { allow_two_phase_borrow } => {\n-                allow_two_phase_borrow.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-\n-impl<'a> HashStable<StableHashingContext<'a>>\n-for mir::UnsafetyViolationKind {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            mir::UnsafetyViolationKind::General => {}\n-            mir::UnsafetyViolationKind::MinConstFn => {}\n-            mir::UnsafetyViolationKind::ExternStatic(lint_node_id) |\n-            mir::UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n-                lint_node_id.hash_stable(hcx, hasher);\n-            }\n+impl_stable_hash_for!(enum mir::BorrowKind {\n+    Shared,\n+    Shallow,\n+    Unique,\n+    Mut { allow_two_phase_borrow },\n+});\n \n-        }\n-    }\n-}\n+impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n+    General,\n+    MinConstFn,\n+    ExternStatic(lint_node_id),\n+    BorrowPacked(lint_node_id),\n+});\n \n impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n     kind,\n     source_info\n });\n \n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for mir::ClearCrossCrate<T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::ClearCrossCrate::Clear => {}\n-            mir::ClearCrossCrate::Set(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<T> for enum mir::ClearCrossCrate<T> [ mir::ClearCrossCrate ] {\n+        Clear,\n+        Set(value),\n     }\n-}\n+);\n \n impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n     #[inline]"}, {"sha": "f3a62975dd9f4547eb254960fc8d605c5ffa9a36", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 125, "deletions": 301, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -224,20 +224,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ty::UpvarCapture<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::UpvarCapture::ByValue => {}\n-            ty::UpvarCapture::ByRef(ref up_var_borrow) => {\n-                up_var_borrow.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n+impl_stable_hash_for!(impl<'gcx> for enum ty::UpvarCapture<'gcx> [ ty::UpvarCapture ] {\n+    ByValue,\n+    ByRef(up_var_borrow),\n+});\n \n impl_stable_hash_for!(struct ty::GenSig<'tcx> {\n     yield_ty,\n@@ -272,64 +262,23 @@ impl_stable_hash_for!(enum ty::Visibility {\n impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n-\n-impl<'a, 'gcx, A, B> HashStable<StableHashingContext<'a>>\n-for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a>>,\n-          B: HashStable<StableHashingContext<'a>>,\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::OutlivesPredicate(ref a, ref b) = *self;\n-        a.hash_stable(hcx, hasher);\n-        b.hash_stable(hcx, hasher);\n-    }\n-}\n-\n+impl_stable_hash_for!(impl<A, B> for tuple_struct ty::OutlivesPredicate<A, B> { a, b });\n impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty });\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::Predicate<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::Predicate::Trait(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::Subtype(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::RegionOutlives(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::TypeOutlives(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::Projection(ref pred) => {\n-                pred.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::WellFormed(ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ObjectSafe(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ClosureKind(def_id, closure_substs, closure_kind) => {\n-                def_id.hash_stable(hcx, hasher);\n-                closure_substs.hash_stable(hcx, hasher);\n-                closure_kind.hash_stable(hcx, hasher);\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx> for enum ty::Predicate<'tcx> [ ty::Predicate ] {\n+        Trait(pred),\n+        Subtype(pred),\n+        RegionOutlives(pred),\n+        TypeOutlives(pred),\n+        Projection(pred),\n+        WellFormed(ty),\n+        ObjectSafe(def_id),\n+        ClosureKind(def_id, closure_substs, closure_kind),\n+        ConstEvaluatable(def_id, substs),\n     }\n-}\n+);\n \n impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -358,70 +307,39 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis,\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::ConstValue<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::ConstValue::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Unevaluated(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-            Scalar(val) => {\n-                val.hash_stable(hcx, hasher);\n-            }\n-            ScalarPair(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            ByRef(id, alloc, offset) => {\n-                id.hash_stable(hcx, hasher);\n-                alloc.hash_stable(hcx, hasher);\n-                offset.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n+        Unevaluated(def_id, substs),\n+        Scalar(val),\n+        ScalarPair(a, b),\n+        ByRef(id, alloc, offset),\n     }\n-}\n+);\n \n-impl<'a, Tag> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::Pointer<Tag>\n-where Tag: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ::mir::interpret::Pointer { alloc_id, offset, tag } = self;\n-        alloc_id.hash_stable(hcx, hasher);\n-        offset.hash_stable(hcx, hasher);\n-        tag.hash_stable(hcx, hasher);\n+impl_stable_hash_for! {\n+    impl<Tag> for struct mir::interpret::Pointer<Tag> {\n+        alloc_id,\n+        offset,\n+        tag,\n     }\n }\n \n-impl<'a, Tag> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::Scalar<Tag>\n-where Tag: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::Scalar::*;\n+impl_stable_hash_for!(\n+    impl<Tag> for enum mir::interpret::Scalar<Tag> [ mir::interpret::Scalar ] {\n+        Bits { bits, size },\n+        Ptr(ptr),\n+    }\n+);\n \n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Bits { bits, size } => {\n-                bits.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-            },\n-            Ptr(ptr) => ptr.hash_stable(hcx, hasher),\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx, M> for enum mir::interpret::AllocType<'tcx, M> [ mir::interpret::AllocType ] {\n+        Function(instance),\n+        Static(def_id),\n+        Memory(mem),\n     }\n-}\n+);\n \n+// AllocIds get resolved to whatever they point to (to be stable)\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -437,23 +355,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-impl<'a, 'gcx, M: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n-for mir::interpret::AllocType<'gcx, M> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::AllocType::*;\n-\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Function(instance) => instance.hash_stable(hcx, hasher),\n-            Static(def_id) => def_id.hash_stable(hcx, hasher),\n-            Memory(ref mem) => mem.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n+// Allocations treat their relocations specially\n impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n@@ -485,7 +387,7 @@ impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n     TooGeneric\n });\n \n-impl_stable_hash_for!(struct ::mir::interpret::FrameInfo {\n+impl_stable_hash_for!(struct mir::interpret::FrameInfo {\n     span,\n     lint_root,\n     location\n@@ -499,124 +401,75 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n-impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::EvalErrorKind<'gcx, O> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use mir::interpret::EvalErrorKind::*;\n-\n-        mem::discriminant(&self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            FunctionArgCountMismatch |\n-            DanglingPointerDeref |\n-            DoubleFree |\n-            InvalidMemoryAccess |\n-            InvalidFunctionPointer |\n-            InvalidBool |\n-            InvalidNullPointerUsage |\n-            ReadPointerAsBytes |\n-            ReadBytesAsPointer |\n-            ReadForeignStatic |\n-            InvalidPointerMath |\n-            DeadLocal |\n-            StackFrameLimitReached |\n-            OutOfTls |\n-            TlsOutOfBounds |\n-            CalledClosureAsFunction |\n-            VtableForArgumentlessMethod |\n-            ModifiedConstantMemory |\n-            AssumptionNotHeld |\n-            InlineAsm |\n-            ReallocateNonBasePtr |\n-            DeallocateNonBasePtr |\n-            HeapAllocZeroBytes |\n-            Unreachable |\n-            ReadFromReturnPointer |\n-            UnimplementedTraitSelection |\n-            TypeckError |\n-            TooGeneric |\n-            DerefFunctionPointer |\n-            ExecuteMemory |\n-            OverflowNeg |\n-            RemainderByZero |\n-            DivisionByZero |\n-            GeneratorResumedAfterReturn |\n-            GeneratorResumedAfterPanic |\n-            ReferencedConstant |\n-            InfiniteLoop => {}\n-            ReadUndefBytes(offset) => offset.hash_stable(hcx, hasher),\n-            InvalidDiscriminant(val) => val.hash_stable(hcx, hasher),\n-            Panic { ref msg, ref file, line, col } => {\n-                msg.hash_stable(hcx, hasher);\n-                file.hash_stable(hcx, hasher);\n-                line.hash_stable(hcx, hasher);\n-                col.hash_stable(hcx, hasher);\n-            },\n-            MachineError(ref err) => err.hash_stable(hcx, hasher),\n-            FunctionAbiMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            FunctionArgMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            FunctionRetMismatch(a, b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            NoMirFor(ref s) => s.hash_stable(hcx, hasher),\n-            UnterminatedCString(ptr) => ptr.hash_stable(hcx, hasher),\n-            PointerOutOfBounds {\n-                ptr,\n-                access,\n-                allocation_size,\n-            } => {\n-                ptr.hash_stable(hcx, hasher);\n-                access.hash_stable(hcx, hasher);\n-                allocation_size.hash_stable(hcx, hasher)\n-            },\n-            InvalidBoolOp(bop) => bop.hash_stable(hcx, hasher),\n-            Unimplemented(ref s) => s.hash_stable(hcx, hasher),\n-            BoundsCheck { ref len, ref index } => {\n-                len.hash_stable(hcx, hasher);\n-                index.hash_stable(hcx, hasher)\n-            },\n-            Intrinsic(ref s) => s.hash_stable(hcx, hasher),\n-            InvalidChar(c) => c.hash_stable(hcx, hasher),\n-            AbiViolation(ref s) => s.hash_stable(hcx, hasher),\n-            AlignmentCheckFailed {\n-                required,\n-                has,\n-            } => {\n-                required.hash_stable(hcx, hasher);\n-                has.hash_stable(hcx, hasher)\n-            },\n-            ValidationFailure(ref s) => s.hash_stable(hcx, hasher),\n-            TypeNotPrimitive(ty) => ty.hash_stable(hcx, hasher),\n-            ReallocatedWrongMemoryKind(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            DeallocatedWrongMemoryKind(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher)\n-            },\n-            IncorrectAllocationInformation(a, b, c, d) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-                c.hash_stable(hcx, hasher);\n-                d.hash_stable(hcx, hasher)\n-            },\n-            Layout(lay) => lay.hash_stable(hcx, hasher),\n-            HeapAllocNonPowerOfTwoAlignment(n) => n.hash_stable(hcx, hasher),\n-            PathNotFound(ref v) => v.hash_stable(hcx, hasher),\n-            Overflow(op) => op.hash_stable(hcx, hasher),\n-        }\n+impl_stable_hash_for!(\n+    impl<'tcx, O> for enum mir::interpret::EvalErrorKind<'tcx, O>\n+        [ mir::interpret::EvalErrorKind ]\n+    {\n+        FunctionArgCountMismatch,\n+        DanglingPointerDeref,\n+        DoubleFree,\n+        InvalidMemoryAccess,\n+        InvalidFunctionPointer,\n+        InvalidBool,\n+        InvalidNullPointerUsage,\n+        ReadPointerAsBytes,\n+        ReadBytesAsPointer,\n+        ReadForeignStatic,\n+        InvalidPointerMath,\n+        DeadLocal,\n+        StackFrameLimitReached,\n+        OutOfTls,\n+        TlsOutOfBounds,\n+        CalledClosureAsFunction,\n+        VtableForArgumentlessMethod,\n+        ModifiedConstantMemory,\n+        AssumptionNotHeld,\n+        InlineAsm,\n+        ReallocateNonBasePtr,\n+        DeallocateNonBasePtr,\n+        HeapAllocZeroBytes,\n+        Unreachable,\n+        ReadFromReturnPointer,\n+        UnimplementedTraitSelection,\n+        TypeckError,\n+        TooGeneric,\n+        DerefFunctionPointer,\n+        ExecuteMemory,\n+        OverflowNeg,\n+        RemainderByZero,\n+        DivisionByZero,\n+        GeneratorResumedAfterReturn,\n+        GeneratorResumedAfterPanic,\n+        ReferencedConstant,\n+        InfiniteLoop,\n+        ReadUndefBytes(offset),\n+        InvalidDiscriminant(val),\n+        Panic { msg, file, line, col },\n+        MachineError(err),\n+        FunctionAbiMismatch(a, b),\n+        FunctionArgMismatch(a, b),\n+        FunctionRetMismatch(a, b),\n+        NoMirFor(s),\n+        UnterminatedCString(ptr),\n+        PointerOutOfBounds { ptr, access, allocation_size },\n+        InvalidBoolOp(bop),\n+        Unimplemented(s),\n+        BoundsCheck { len, index },\n+        Intrinsic(s),\n+        InvalidChar(c),\n+        AbiViolation(s),\n+        AlignmentCheckFailed { required, has },\n+        ValidationFailure(s),\n+        TypeNotPrimitive(ty),\n+        ReallocatedWrongMemoryKind(a, b),\n+        DeallocatedWrongMemoryKind(a, b),\n+        IncorrectAllocationInformation(a, b, c, d),\n+        Layout(lay),\n+        HeapAllocNonPowerOfTwoAlignment(n),\n+        PathNotFound(v),\n+        Overflow(op),\n     }\n-}\n+);\n \n impl_stable_hash_for!(enum mir::interpret::Lock {\n     NoLock,\n@@ -663,47 +516,18 @@ impl_stable_hash_for!(struct ty::GenericParamDef {\n     kind\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::GenericParamDefKind {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            ty::GenericParamDefKind::Lifetime => {}\n-            ty::GenericParamDefKind::Type {\n-                has_default,\n-                ref object_lifetime_default,\n-                ref synthetic,\n-            } => {\n-                has_default.hash_stable(hcx, hasher);\n-                object_lifetime_default.hash_stable(hcx, hasher);\n-                synthetic.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n-for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a>>\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        use middle::resolve_lifetime::Set1;\n+impl_stable_hash_for!(enum ty::GenericParamDefKind {\n+    Lifetime,\n+    Type { has_default, object_lifetime_default, synthetic },\n+});\n \n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            Set1::Empty |\n-            Set1::Many => {\n-                // Nothing to do.\n-            }\n-            Set1::One(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(\n+    impl<T> for enum ::middle::resolve_lifetime::Set1<T> [ ::middle::resolve_lifetime::Set1 ] {\n+        Empty,\n+        Many,\n+        One(value),\n     }\n-}\n+);\n \n impl_stable_hash_for!(enum ::middle::resolve_lifetime::LifetimeDefOrigin {\n     ExplicitOrElided,\n@@ -1250,7 +1074,7 @@ impl_stable_hash_for!(\n );\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct infer::canonical::CanonicalVarValues<'tcx> {\n+    struct infer::canonical::CanonicalVarValues<'tcx> {\n         var_values\n     }\n );\n@@ -1369,7 +1193,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n }\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct traits::ProgramClause<'tcx> {\n+    struct traits::ProgramClause<'tcx> {\n         goal, hypotheses, category\n     }\n );\n@@ -1404,7 +1228,7 @@ impl_stable_hash_for!(struct ty::subst::UserSubsts<'tcx> { substs, user_self_ty\n impl_stable_hash_for!(struct ty::subst::UserSelfTy<'tcx> { impl_def_id, self_ty });\n \n impl_stable_hash_for!(\n-    impl<'tcx> for struct traits::Environment<'tcx> {\n+    struct traits::Environment<'tcx> {\n         clauses,\n     }\n );"}, {"sha": "0114f9e9321e1878e54b0f96a7195665d4eeab52", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -132,7 +132,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// See the `region_obligations` field of `InferCtxt` for some\n     /// comments about how this function fits into the overall expected\n-    /// flow of the the inferencer. The key point is that it is\n+    /// flow of the inferencer. The key point is that it is\n     /// invoked after all type-inference variables have been bound --\n     /// towards the end of regionck. This also ensures that the\n     /// region-bound-pairs are available (see comments above regarding"}, {"sha": "50375435eb9203b588e2eb34cf11256a4195691e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -62,16 +62,6 @@ macro_rules! span_bug {\n     })\n }\n \n-#[macro_export]\n-macro_rules! static_assert {\n-    ($name:ident: $test:expr) => {\n-        // Use the bool to access an array such that if the bool is false, the access\n-        // is out-of-bounds.\n-        #[allow(dead_code)]\n-        static $name: () = [()][!$test as usize];\n-    }\n-}\n-\n #[macro_export]\n macro_rules! __impl_stable_hash_field {\n     ($field:ident, $ctx:expr, $hasher:expr) => ($field.hash_stable($ctx, $hasher));\n@@ -81,6 +71,7 @@ macro_rules! __impl_stable_hash_field {\n \n #[macro_export]\n macro_rules! impl_stable_hash_for {\n+    // Enums\n     // FIXME(mark-i-m): Some of these should be `?` rather than `*`. See the git blame and change\n     // them back when `?` is supported again.\n     (enum $enum_name:path {\n@@ -91,12 +82,37 @@ macro_rules! impl_stable_hash_for {\n            $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n         ),* $(,)*\n     }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n+        impl_stable_hash_for!(\n+            impl<> for enum $enum_name [ $enum_name ] { $( $variant\n+                $( ( $($field $(-> $delegate)*),* ) )*\n+                $( { $($named_field $(-> $named_delegate)*),* } )*\n+            ),* }\n+        );\n+    };\n+    // We want to use the enum name both in the `impl ... for $enum_name` as well as for\n+    // importing all the variants. Unfortunately it seems we have to take the name\n+    // twice for this purpose\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+        for enum $enum_name:path\n+        [ $enum_path:path ]\n+    {\n+        $( $variant:ident\n+           // this incorrectly allows specifying both tuple-like and struct-like fields, as in `Variant(a,b){c,d}`,\n+           // when it should be only one or the other\n+           $( ( $($field:ident $(-> $delegate:tt)*),* ) )*\n+           $( { $($named_field:ident $(-> $named_delegate:tt)*),* } )*\n+        ),* $(,)*\n+    }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>\n+            for $enum_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                use $enum_name::*;\n+                use $enum_path::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n \n                 match *self {\n@@ -110,9 +126,20 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+    // Structs\n     // FIXME(mark-i-m): same here.\n     (struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n+        impl_stable_hash_for!(\n+            impl<'tcx> for struct $struct_name { $($field $(-> $delegate)*),* }\n+        );\n+    };\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*> for struct $struct_name:path {\n+        $($field:ident $(-> $delegate:tt)*),* $(,)*\n+    }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n+            ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n+            where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n+        {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n@@ -125,36 +152,27 @@ macro_rules! impl_stable_hash_for {\n             }\n         }\n     };\n+    // Tuple structs\n+    // We cannot use normale parentheses here, the parser won't allow it\n     // FIXME(mark-i-m): same here.\n     (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n-        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n-            #[inline]\n-            fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n-                                                  __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                let $struct_name (\n-                    $(ref $field),*\n-                ) = *self;\n-\n-                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n-            }\n-        }\n+        impl_stable_hash_for!(\n+            impl<'tcx> for tuple_struct $struct_name { $($field $(-> $delegate)*),* }\n+        );\n     };\n-\n-    (impl<$tcx:lifetime $(, $lt:lifetime $(: $lt_bound:lifetime)*)* $(, $T:ident)*> for struct $struct_name:path {\n-        $($field:ident $(-> $delegate:tt)*),* $(,)*\n-    }) => {\n-        impl<'a, $tcx, $($lt $(: $lt_bound)*,)* $($T,)*>\n+    (impl<$($lt:lifetime $(: $lt_bound:lifetime)* ),* $(,)* $($T:ident),* $(,)*>\n+     for tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)*),*  $(,)* }) => {\n+        impl<'a, $($lt $(: $lt_bound)*,)* $($T,)*>\n             ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name\n             where $($T: ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>>),*\n         {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n                                                   __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n-                let $struct_name {\n+                let $struct_name (\n                     $(ref $field),*\n-                } = *self;\n+                ) = *self;\n \n                 $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)*) );*\n             }"}, {"sha": "cc92b63256c1ff7c6b8e3259f29da401dd59bac8", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -65,6 +65,17 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Default + Clone {\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n+\n+    /// Hook for performing extra checks on a memory deallocation.\n+    /// `size` will be the size of the allocation.\n+    #[inline]\n+    fn memory_deallocated(\n+        _alloc: &mut Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n }\n \n impl AllocationExtra<()> for () {}"}, {"sha": "548d0e0c7905f096c399543439c5441896f12f12", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -1720,14 +1720,14 @@ pub struct Statement<'tcx> {\n     pub kind: StatementKind<'tcx>,\n }\n \n+// `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_STATEMENT: mem::size_of::<Statement<'_>>() == 56);\n+\n impl<'tcx> Statement<'tcx> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_nop(&mut self) {\n-        // `Statement` contributes significantly to peak memory usage. Make\n-        // sure it doesn't get bigger.\n-        static_assert!(STATEMENT_IS_AT_MOST_56_BYTES: mem::size_of::<Statement<'_>>() <= 56);\n-\n         self.kind = StatementKind::Nop\n     }\n \n@@ -2617,7 +2617,7 @@ pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const<'_>) -> fmt::Resu\n             _ => {}\n         }\n     }\n-    // print function definitons\n+    // print function definitions\n     if let FnDef(did, _) = ty.sty {\n         return write!(f, \"{}\", item_path_str(did));\n     }"}, {"sha": "f3a0b7de903744eed856192dda2a88f301c05295", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         //\n         // It does the actual traversal of the graph, while the `next` method on the iterator\n         // just pops off of the stack. `visit_stack` is a stack containing pairs of nodes and\n-        // iterators over the sucessors of those nodes. Each iteration attempts to get the next\n+        // iterators over the successors of those nodes. Each iteration attempts to get the next\n         // node from the top of the stack, then pushes that node and an iterator over the\n         // successors to the top of the stack. This loop only grows `visit_stack`, stopping when\n         // we reach a child that has no children that we haven't already visited.\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         // The state of the stack starts out with just the root node (`A` in this case);\n         //     [(A, [B, C])]\n         //\n-        // When the first call to `traverse_sucessor` happens, the following happens:\n+        // When the first call to `traverse_successor` happens, the following happens:\n         //\n         //     [(B, [D]),  // `B` taken from the successors of `A`, pushed to the\n         //                 // top of the stack along with the successors of `B`"}, {"sha": "cdfe8f53b854b96774f75a92b0c0bfcda80097e1", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -823,12 +823,6 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n-        // Ensure our type representation does not grow\n-        #[cfg(target_pointer_width = \"64\")]\n-        static_assert!(ASSERT_TY_KIND: ::std::mem::size_of::<ty::TyKind<'_>>() <= 24);\n-        #[cfg(target_pointer_width = \"64\")]\n-        static_assert!(ASSERT_TYS: ::std::mem::size_of::<ty::TyS<'_>>() <= 32);\n-\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n             if let Some(r) = interners.region.borrow().get(&r) {"}, {"sha": "8197136d189aec581ca0d286c1bdb0c66a24d7d3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -515,6 +515,10 @@ pub struct TyS<'tcx> {\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n+// `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_TY_S: ::std::mem::size_of::<TyS<'_>>() == 32);\n+\n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n         self.sty.cmp(&other.sty)"}, {"sha": "c82a44011db6c95d00b0323ad8734a8b97c94405", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -291,7 +291,8 @@ define_queries! { <'tcx>\n         /// Gets a complete map from all types to their inherent impls.\n         /// Not meant to be used directly outside of coherence.\n         /// (Defined only for LOCAL_CRATE)\n-        [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum) -> CrateInherentImpls,\n+        [] fn crate_inherent_impls: crate_inherent_impls_dep_node(CrateNum)\n+            -> Lrc<CrateInherentImpls>,\n \n         /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n         /// Not meant to be used directly outside of coherence."}, {"sha": "efee39a1d63f95070fd2d1b8f256a512cd379688", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -100,7 +100,7 @@ pub(super) struct JobOwner<'a, 'tcx: 'a, Q: QueryDescription<'tcx> + 'a> {\n }\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n-    /// Either gets a JobOwner corresponding the the query, allowing us to\n+    /// Either gets a JobOwner corresponding the query, allowing us to\n     /// start executing the query, or it returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Try to read a node index for the node dep_node.\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n-    /// the a node index can be found for that node.\n+    /// a node index can be found for that node.\n     pub(super) fn try_mark_green_and_read(self, dep_node: &DepNode) -> Option<DepNodeIndex> {\n         match self.dep_graph.node_color(dep_node) {\n             Some(DepNodeColor::Green(dep_node_index)) => {"}, {"sha": "bd3a34cae90f4330c4aaf2cfa8c5bfe245dd1d5c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -211,6 +211,10 @@ pub enum TyKind<'tcx> {\n     Error,\n }\n \n+// `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_TY_KIND: ::std::mem::size_of::<TyKind<'_>>() == 24);\n+\n /// A closure can be modeled as a struct that looks like:\n ///\n ///     struct Closure<'l0...'li, T0...Tj, CK, CS, U0...Uk> {"}, {"sha": "adcb9857ee3c259f6e2f44e61970a314a204ee55", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -895,7 +895,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n             }\n \n             // The intermediate result of the multiplication has \"2 * S::PRECISION\"\n-            // signicant bit; adjust the addend to be consistent with mul result.\n+            // significant bit; adjust the addend to be consistent with mul result.\n             let mut ext_addend_sig = [addend.sig[0], 0];\n \n             // Extend the addend significand to ext_precision - 1. This guarantees\n@@ -920,7 +920,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n \n         // Convert the result having \"2 * S::PRECISION\" significant-bits back to the one\n         // having \"S::PRECISION\" significant-bits. First, move the radix point from\n-        // poision \"2*S::PRECISION - 1\" to \"S::PRECISION - 1\". The exponent need to be\n+        // position \"2*S::PRECISION - 1\" to \"S::PRECISION - 1\". The exponent need to be\n         // adjusted by \"2*S::PRECISION - 1\" - \"S::PRECISION - 1\" = \"S::PRECISION\".\n         self.exp -= S::PRECISION as ExpInt + 1;\n "}, {"sha": "267d7e0d54b637c267054d7336401dcf0d61a3f3", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -184,7 +184,7 @@ const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n ];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective\n-/// primtives may be documented.\n+/// primitives may be documented.\n ///\n /// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n /// iterator!"}, {"sha": "e9ac92da684352a21b89c83594f73e356351129a", "filename": "src/librustc_codegen_utils/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_codegen_utils%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_codegen_utils%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flinker.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -613,7 +613,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n         // from the CodeView line tables in the object files.\n         self.cmd.arg(\"/DEBUG\");\n \n-        // This will cause the Microsoft linker to embed .natvis info into the the PDB file\n+        // This will cause the Microsoft linker to embed .natvis info into the PDB file\n         let sysroot = self.sess.sysroot();\n         let natvis_dir_path = sysroot.join(\"lib\\\\rustlib\\\\etc\");\n         if let Ok(natvis_dir) = fs::read_dir(&natvis_dir_path) {"}, {"sha": "135abebdacb7acacb4499d1bc0c1176a2decf11f", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -57,6 +57,7 @@ extern crate rustc_cratesio_shim;\n \n pub use rustc_serialize::hex::ToHex;\n \n+pub mod macros;\n pub mod svh;\n pub mod base_n;\n pub mod bit_set;"}, {"sha": "3cc91b0e93f0430b23b956e191fa1875cb0b8abc", "filename": "src/librustc_data_structures/macros.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_data_structures%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_data_structures%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fmacros.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A simple static assertion macro. The first argument should be a unique\n+/// ALL_CAPS identifier that describes the condition.\n+#[macro_export]\n+macro_rules! static_assert {\n+    ($name:ident: $test:expr) => {\n+        // Use the bool to access an array such that if the bool is false, the access\n+        // is out-of-bounds.\n+        #[allow(dead_code)]\n+        static $name: () = [()][!$test as usize];\n+    }\n+}"}, {"sha": "2a8a0baf571b04475d654067ba82b23ae584c2e0", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -490,7 +490,7 @@ fn create_dir(sess: &Session, path: &Path, dir_tag: &str) -> Result<(),()> {\n     }\n }\n \n-/// Allocate a the lock-file and lock it.\n+/// Allocate the lock-file and lock it.\n fn lock_directory(sess: &Session,\n                   session_dir: &Path)\n                   -> Result<(flock::Lock, PathBuf), ()> {"}, {"sha": "b3e159dd84457c14b2a35ca5d7821a84024195eb", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -11,7 +11,7 @@\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n-/// Maps between a MIR Location, which identifies the a particular\n+/// Maps between a MIR Location, which identifies a particular\n /// statement within a basic block, to a \"rich location\", which\n /// identifies at a finer granularity. In particular, we distinguish\n /// the *start* of a statement and the *mid-point*. The mid-point is"}, {"sha": "2b7ef38d3edf940bfd4298619a703229eeb99dcf", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -112,7 +112,7 @@ impl RegionValueElements {\n         } = self.to_location(index);\n         if statement_index == 0 {\n             // If this is a basic block head, then the predecessors are\n-            // the the terminators of other basic blocks\n+            // the terminators of other basic blocks\n             stack.extend(\n                 mir.predecessors_for(block)\n                     .iter()"}, {"sha": "1efd7ca7f89738f658a42727d8df56f71f627b2d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -17,7 +17,7 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, layout::{Size, TyLayout}, query::TyCtxtAt};\n+use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n@@ -174,16 +174,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Hook for performing extra checks when memory gets deallocated.\n-    #[inline]\n-    fn memory_deallocated(\n-        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n-        _ptr: Pointer<Self::PointerTag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n     /// Add the tag for a newly allocated pointer.\n     fn tag_new_allocation(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,"}, {"sha": "e125927e7d2732ea8c0c97d1c7b4746371076065", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -225,7 +225,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         // Let the machine take some extra action\n         let size = Size::from_bytes(alloc.bytes.len() as u64);\n-        M::memory_deallocated(&mut alloc, ptr, size)?;\n+        AllocationExtra::memory_deallocated(&mut alloc, ptr, size)?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert("}, {"sha": "0c0f50c1fd70907fee7e855b88f8cc90b499649a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -1254,21 +1254,25 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     Vec::new()\n                 };\n \n-                let sub_span =\n-                    self.span.sub_span_of_token(use_tree.span, token::BinOp(token::Star));\n-                if !self.span.filter_generated(use_tree.span) {\n-                    let span =\n-                        self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n-                    self.dumper.import(&access, Import {\n-                        kind: ImportKind::GlobUse,\n-                        ref_id: None,\n-                        span,\n-                        alias_span: None,\n-                        name: \"*\".to_owned(),\n-                        value: names.join(\", \"),\n-                        parent,\n-                    });\n-                    self.write_sub_paths(&path);\n+                // Otherwise it's a span with wrong macro expansion info, which\n+                // we don't want to track anyway, since it's probably macro-internal `use`\n+                if let Some(sub_span) =\n+                    self.span.sub_span_of_token(use_tree.span, token::BinOp(token::Star))\n+                {\n+                    if !self.span.filter_generated(use_tree.span) {\n+                        let span = self.span_from_span(sub_span);\n+\n+                        self.dumper.import(&access, Import {\n+                            kind: ImportKind::GlobUse,\n+                            ref_id: None,\n+                            span,\n+                            alias_span: None,\n+                            name: \"*\".to_owned(),\n+                            value: names.join(\", \"),\n+                            parent,\n+                        });\n+                        self.write_sub_paths(&path);\n+                    }\n                 }\n             }\n             ast::UseTreeKind::Nested(ref nested_items) => {"}, {"sha": "e3a6f92d79e5b74ed9002313c656e86a09a54225", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -550,7 +550,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// current expression. As each subpart is processed, they may set\n     /// the flag to `Always` etc.  Finally, at the end, we take the\n     /// result and \"union\" it with the original value, so that when we\n-    /// return the flag indicates if any subpart of the the parent\n+    /// return the flag indicates if any subpart of the parent\n     /// expression (up to and including this part) has diverged.  So,\n     /// if you read it after evaluating a subexpression `X`, the value\n     /// you get indicates whether any subexpression that was"}, {"sha": "370f8857f1400926a45775992fbf01dee13826e2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -31,7 +31,7 @@ use syntax_pos::Span;\n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       crate_num: CrateNum)\n-                                      -> CrateInherentImpls {\n+                                      -> Lrc<CrateInherentImpls> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n@@ -42,7 +42,7 @@ pub fn crate_inherent_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     };\n     krate.visit_all_item_likes(&mut collect);\n-    collect.impls_map\n+    Lrc::new(collect.impls_map)\n }\n \n /// On-demand query: yields a vector of the inherent impls for a specific type."}, {"sha": "931ba21f6e4bd8ef66182e089e81b7bbc2c91a41", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -3502,13 +3502,16 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n+        let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),\n                 None => false,\n             }\n         });\n+        // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n+        // crate in Rust 2018+\n+        let please_inline = self.attrs.lists(\"doc\").has_word(\"inline\");\n         let path = self.path.clean(cx);\n         let inner = if self.glob {\n             if !denied {\n@@ -3521,6 +3524,16 @@ impl Clean<Vec<Item>> for doctree::Import {\n             Import::Glob(resolve_use_source(cx, path))\n         } else {\n             let name = self.name;\n+            if !please_inline {\n+                match path.def {\n+                    Def::Mod(did) => if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                        // were specifically asked for it\n+                        denied = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n             if !denied {\n                 let mut visited = FxHashSet::default();\n                 if let Some(items) = inline::try_inline(cx, path.def, name, &mut visited) {"}, {"sha": "00ca4fed2f4a008e73eb1ecf23cf73d446884c30", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -399,7 +399,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> SummaryLine<'a, I> {\n fn check_if_allowed_tag(t: &Tag) -> bool {\n     match *t {\n         Tag::Paragraph\n-        | Tag::CodeBlock(_)\n         | Tag::Item\n         | Tag::Emphasis\n         | Tag::Strong\n@@ -420,29 +419,36 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n         if !self.started {\n             self.started = true;\n         }\n-        let event = self.inner.next();\n-        let mut is_start = true;\n-        let is_allowed_tag = match event {\n-            Some(Event::Start(ref c)) => {\n-                self.depth += 1;\n-                check_if_allowed_tag(c)\n-            }\n-            Some(Event::End(ref c)) => {\n-                self.depth -= 1;\n-                is_start = false;\n-                check_if_allowed_tag(c)\n-            }\n-            _ => true,\n-        };\n-        if is_allowed_tag == false {\n-            if is_start {\n-                Some(Event::Start(Tag::Paragraph))\n+        while let Some(event) = self.inner.next() {\n+            let mut is_start = true;\n+            let is_allowed_tag = match event {\n+                Event::Start(Tag::CodeBlock(_)) | Event::End(Tag::CodeBlock(_)) => {\n+                    return None;\n+                }\n+                Event::Start(ref c) => {\n+                    self.depth += 1;\n+                    check_if_allowed_tag(c)\n+                }\n+                Event::End(ref c) => {\n+                    self.depth -= 1;\n+                    is_start = false;\n+                    check_if_allowed_tag(c)\n+                }\n+                _ => {\n+                    true\n+                }\n+            };\n+            return if is_allowed_tag == false {\n+                if is_start {\n+                    Some(Event::Start(Tag::Paragraph))\n+                } else {\n+                    Some(Event::End(Tag::Paragraph))\n+                }\n             } else {\n-                Some(Event::End(Tag::Paragraph))\n-            }\n-        } else {\n-            event\n+                Some(event)\n+            };\n         }\n+        None\n     }\n }\n "}, {"sha": "b46efb20d8f6b2164c3538dfbcd21420a5a456eb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -2584,24 +2584,39 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                     _ => \"\",\n                 };\n \n+                let stab = myitem.stability_class();\n+                let add = if stab.is_some() {\n+                    \" \"\n+                } else {\n+                    \"\"\n+                };\n+\n                 let doc_value = myitem.doc_value().unwrap_or(\"\");\n-                write!(w, \"\n-                       <tr class='{stab} module-item'>\n-                           <td><a class=\\\"{class}\\\" href=\\\"{href}\\\"\n-                                  title='{title_type} {title}'>{name}</a>{unsafety_flag}</td>\n-                           <td class='docblock-short'>\n-                               {stab_docs} {docs}\n-                           </td>\n+                write!(w, \"\\\n+                       <tr class='{stab}{add}module-item'>\\\n+                           <td><a class=\\\"{class}\\\" href=\\\"{href}\\\" \\\n+                                  title='{title}'>{name}</a>{unsafety_flag}</td>\\\n+                           <td class='docblock-short'>{stab_docs}{docs}\\\n+                           </td>\\\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n                        docs = MarkdownSummaryLine(doc_value, &myitem.links()),\n                        class = myitem.type_(),\n-                       stab = myitem.stability_class().unwrap_or(String::new()),\n+                       add = add,\n+                       stab = stab.unwrap_or_else(|| String::new()),\n                        unsafety_flag = unsafety_flag,\n                        href = item_path(myitem.type_(), myitem.name.as_ref().unwrap()),\n-                       title_type = myitem.type_(),\n-                       title = full_path(cx, myitem))?;\n+                       title = [full_path(cx, myitem), myitem.type_().to_string()]\n+                                .iter()\n+                                .filter_map(|s| if !s.is_empty() {\n+                                    Some(s.as_str())\n+                                } else {\n+                                    None\n+                                })\n+                                .collect::<Vec<_>>()\n+                                .join(\" \"),\n+                      )?;\n             }\n         }\n     }"}, {"sha": "55415e973c50ae0d0fc6775caac07debdb60d7bc", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -2262,17 +2262,17 @@\n     onEach(document.getElementsByClassName('rust-example-rendered'), function(e) {\n         if (hasClass(e, 'compile_fail')) {\n             e.addEventListener(\"mouseover\", function(event) {\n-                e.previousElementSibling.childNodes[0].style.color = '#f00';\n+                this.parentElement.previousElementSibling.childNodes[0].style.color = '#f00';\n             });\n             e.addEventListener(\"mouseout\", function(event) {\n-                e.previousElementSibling.childNodes[0].style.color = '';\n+                this.parentElement.previousElementSibling.childNodes[0].style.color = '';\n             });\n         } else if (hasClass(e, 'ignore')) {\n             e.addEventListener(\"mouseover\", function(event) {\n-                e.previousElementSibling.childNodes[0].style.color = '#ff9200';\n+                this.parentElement.previousElementSibling.childNodes[0].style.color = '#ff9200';\n             });\n             e.addEventListener(\"mouseout\", function(event) {\n-                e.previousElementSibling.childNodes[0].style.color = '';\n+                this.parentElement.previousElementSibling.childNodes[0].style.color = '';\n             });\n         }\n         lineNumbersFunc(e);"}, {"sha": "0f9104f91b4c028c94a34542303bdd15c9121417", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -284,6 +284,7 @@ nav.sub {\n \n body:not(.source) .example-wrap {\n \tdisplay: inline-flex;\n+\tmargin-bottom: 10px;\n }\n \n .example-wrap {\n@@ -303,6 +304,10 @@ body:not(.source) .example-wrap > pre.rust {\n \twidth: 100%;\n }\n \n+body:not(.source) .example-wrap > pre {\n+\tmargin: 0;\n+}\n+\n #search {\n \tmargin-left: 230px;\n \tposition: relative;"}, {"sha": "9c0573964702e7425428534f0d5aad79fe150add", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -142,6 +142,7 @@ pub use alloc_crate::alloc::*;\n #[derive(Debug, Copy, Clone)]\n pub struct System;\n \n+// The Alloc impl just forwards to the GlobalAlloc impl, which is in `std::sys::*::alloc`.\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n@@ -226,6 +227,10 @@ pub fn rust_oom(layout: Layout) -> ! {\n #[unstable(feature = \"alloc_internals\", issue = \"0\")]\n pub mod __default_lib_allocator {\n     use super::{System, Layout, GlobalAlloc};\n+    // These magic symbol names are used as a fallback for implementing the\n+    // `__rust_alloc` etc symbols (see `src/liballoc/alloc.rs) when there is\n+    // no `#[global_allocator]` attribute.\n+\n     // for symbol names src/librustc/middle/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n "}, {"sha": "15fbb10592133f38112e8a022deaae6fff760a40", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -16,7 +16,7 @@\n \n /// The entry point for panic of Rust threads.\n ///\n-/// This allows a program to to terminate immediately and provide feedback\n+/// This allows a program to terminate immediately and provide feedback\n /// to the caller of the program. `panic!` should be used when a program reaches\n /// an unrecoverable problem.\n ///"}, {"sha": "327ad7f64c23f299bc36b0d38563f2996547281c", "filename": "src/libstd/process.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -764,14 +764,15 @@ impl Command {\n     ///\n     /// ```should_panic\n     /// use std::process::Command;\n+    /// use std::io::{self, Write};\n     /// let output = Command::new(\"/bin/cat\")\n     ///                      .arg(\"file.txt\")\n     ///                      .output()\n     ///                      .expect(\"failed to execute process\");\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n-    /// println!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+    /// io::stdout().write_all(&output.stdout).unwrap();\n+    /// io::stderr().write_all(&output.stderr).unwrap();\n     ///\n     /// assert!(output.status.success());\n     /// ```\n@@ -951,14 +952,16 @@ impl Stdio {\n     ///\n     /// ```no_run\n     /// use std::process::{Command, Stdio};\n+    /// use std::io::{self, Write};\n     ///\n     /// let output = Command::new(\"rev\")\n     ///     .stdin(Stdio::inherit())\n     ///     .stdout(Stdio::piped())\n     ///     .output()\n     ///     .expect(\"Failed to execute command\");\n     ///\n-    /// println!(\"You piped in the reverse of: {}\", String::from_utf8_lossy(&output.stdout));\n+    /// print!(\"You piped in the reverse of: \");\n+    /// io::stdout().write_all(&output.stdout).unwrap();\n     /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn inherit() -> Stdio { Stdio(imp::Stdio::Inherit) }"}, {"sha": "808e19d6f120f0f069f6fb5bc7a940fbffaf2db9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -20,6 +20,8 @@ use print::pprust;\n use ptr::P;\n use rustc_data_structures::indexed_vec;\n use rustc_data_structures::indexed_vec::Idx;\n+#[cfg(target_arch = \"x86_64\")]\n+use rustc_data_structures::static_assert;\n use rustc_target::spec::abi::Abi;\n use source_map::{dummy_spanned, respan, Spanned};\n use symbol::{keywords, Symbol};\n@@ -924,6 +926,10 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n+// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert!(MEM_SIZE_OF_EXPR: std::mem::size_of::<Expr>() == 88);\n+\n impl Expr {\n     /// Whether this expression would be valid somewhere that expects a value, for example, an `if`\n     /// condition."}, {"sha": "f31d80acbfa4ef217b30586a553021142ce5b50d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -122,7 +122,7 @@ impl<'tt> TokenTreeOrTokenTreeSlice<'tt> {\n         }\n     }\n \n-    /// The the `index`-th token tree of `self`.\n+    /// The `index`-th token tree of `self`.\n     fn get_tt(&self, index: usize) -> TokenTree {\n         match *self {\n             TtSeq(ref v) => v[index].clone(),"}, {"sha": "218486748315d6bf88da9b88757233d9a0b1d726", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -496,7 +496,7 @@ where\n                         return (None, KleeneOp::ZeroOrMore);\n                     }\n \n-                    // #2 is a Kleene op, which is the the only valid option\n+                    // #2 is a Kleene op, which is the only valid option\n                     Ok(Ok((op, _))) => {\n                         // Warn that `?` as a separator will be deprecated\n                         sess.buffer_lint("}, {"sha": "d90ec4ea081b233d80e54888834971a40529dd49", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -1956,7 +1956,7 @@ impl<'a> Parser<'a> {\n \n                 if suffix_illegal {\n                     let sp = self.span;\n-                    self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n+                    self.expect_no_suffix(sp, lit.literal_name(), suf)\n                 }\n \n                 result.unwrap()"}, {"sha": "1c6fc1ac1853f1c3007baae3493d7e7343de22d1", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -79,14 +79,14 @@ pub enum Lit {\n }\n \n impl Lit {\n-    crate fn short_name(&self) -> &'static str {\n+    crate fn literal_name(&self) -> &'static str {\n         match *self {\n-            Byte(_) => \"byte\",\n-            Char(_) => \"char\",\n-            Integer(_) => \"integer\",\n-            Float(_) => \"float\",\n-            Str_(_) | StrRaw(..) => \"string\",\n-            ByteStr(_) | ByteStrRaw(..) => \"byte string\"\n+            Byte(_) => \"byte literal\",\n+            Char(_) => \"char literal\",\n+            Integer(_) => \"integer literal\",\n+            Float(_) => \"float literal\",\n+            Str_(_) | StrRaw(..) => \"string literal\",\n+            ByteStr(_) | ByteStrRaw(..) => \"byte string literal\"\n         }\n     }\n "}, {"sha": "e519d48ac1d4d98fee30da05119d8534fce44902", "filename": "src/test/run-pass-fulldeps/dropck_tarena_sound_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frun-pass-fulldeps%2Fdropck_tarena_sound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frun-pass-fulldeps%2Fdropck_tarena_sound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fdropck_tarena_sound_drop.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -31,7 +31,7 @@ struct CheckId<T:HasId> { v: T }\n // In the code below, the impl of HasId for `&'a usize` does not\n // actually access the borrowed data, but the point is that the\n // interface to CheckId does not (and cannot) know that, and therefore\n-// when encountering the a value V of type CheckId<S>, we must\n+// when encountering a value V of type CheckId<S>, we must\n // conservatively force the type S to strictly outlive V.\n impl<T:HasId> Drop for CheckId<T> {\n     fn drop(&mut self) {"}, {"sha": "f82dafa25172090462eb371f810c91ead8f92a6d", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -20,8 +20,8 @@ pub struct Portable;\n // @has doc_cfg/unix_only/index.html \\\n //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n //  'This is supported on Unix only.'\n-// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n-// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n+// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n+// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n // @count - '//*[@class=\"stab portability\"]' 3\n #[doc(cfg(unix))]\n pub mod unix_only {\n@@ -52,7 +52,7 @@ pub mod unix_only {\n \n // the portability header is different on the module view versus the full view\n // @has doc_cfg/index.html\n-// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n+// @matches - '//*[@class=\"module-item\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n \n // @has doc_cfg/fn.uses_target_feature.html\n // @has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\"}, {"sha": "55202de1981beb35ac88d83d45b193f3c1e6e057", "filename": "src/test/rustdoc/inline_cross/auxiliary/use_crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod asdf {\n+    pub struct SomeStruct;\n+}\n+\n+pub trait SomeTrait {}"}, {"sha": "1f11cbc4da718d0b83b4aac58f4674eda631d40f", "filename": "src/test/rustdoc/inline_cross/auxiliary/use_crate_2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fuse_crate_2.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct SomethingElse;"}, {"sha": "a98704446ee76c52b85b6303075a58bcd9ac871d", "filename": "src/test/rustdoc/inline_cross/use_crate.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fuse_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Finline_cross%2Fuse_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fuse_crate.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:use_crate.rs\n+// aux-build:use_crate_2.rs\n+// build-aux-docs\n+// edition:2018\n+// compile-flags:--extern use_crate --extern use_crate_2 -Z unstable-options\n+\n+// During the buildup to Rust 2018, rustdoc would eagerly inline `pub use some_crate;` as if it\n+// were a module, so we changed it to make `pub use`ing crate roots remain as a `pub use` statement\n+// in docs... unless you added `#[doc(inline)]`.\n+\n+#![crate_name = \"local\"]\n+\n+// @!has-dir local/use_crate\n+// @has local/index.html\n+// @has - '//code' 'pub use use_crate'\n+pub use use_crate;\n+\n+// @has-dir local/asdf\n+// @has local/asdf/index.html\n+// @has local/index.html '//a/@href' 'asdf/index.html'\n+pub use use_crate::asdf;\n+\n+// @has-dir local/use_crate_2\n+// @has local/use_crate_2/index.html\n+// @has local/index.html '//a/@href' 'use_crate_2/index.html'\n+#[doc(inline)]\n+pub use use_crate_2;"}, {"sha": "060b349c251774d1d0ed43832ded6e44b96d7c03", "filename": "src/test/rustdoc/short-docblock-codeblock.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fshort-docblock-codeblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fshort-docblock-codeblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fshort-docblock-codeblock.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/index.html '//*[@class=\"module-item\"]//td[@class=\"docblock-short\"]' \"\"\n+// @!has foo/index.html '//*[@id=\"module-item\"]//td[@class=\"docblock-short\"]' \"Some text.\"\n+// @!has foo/index.html '//*[@id=\"module-item\"]//td[@class=\"docblock-short\"]' \"let x = 12;\"\n+\n+/// ```\n+/// let x = 12;\n+/// ```\n+///\n+/// Some text.\n+pub fn foo() {}"}, {"sha": "6cc7f1743ad07c440f9d63070ef479e4fcb0bac6", "filename": "src/test/rustdoc/src-links-external.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsrc-links-external.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -18,6 +18,7 @@\n extern crate src_links_external;\n \n // @has foo/bar/index.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'\n+#[doc(inline)]\n pub use src_links_external as bar;\n \n // @has foo/bar/struct.Foo.html '//a/@href' '../../src/src_links_external/src-links-external.rs.html#11'"}, {"sha": "c23b43dfff706e5d91fd1056a08600ce90c1c665", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-proc_macro_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-proc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-proc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-proc_macro_derive.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -13,7 +13,7 @@\n // not descend further into the mod for other occurrences of the same\n // error.\n //\n-// This file sits on its own because the the \"weird\" occurrences here\n+// This file sits on its own because the \"weird\" occurrences here\n // signal errors, making it incompatible with the \"warnings only\"\n // nature of issue-43106-gating-of-builtin-attrs.rs\n "}, {"sha": "af025b9bbbf76c0fc4e2aac1bcf37078fd50b579", "filename": "src/test/ui/rfc1445/phantom-data-is-structurally-matchable.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fphantom-data-is-structurally-matchable.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -0,0 +1,53 @@\n+// run-pass\n+\n+// This file checks that `PhantomData` is considered structurally matchable.\n+\n+use std::marker::PhantomData;\n+\n+fn main() {\n+    let mut count = 0;\n+\n+    // A type which is not structurally matchable:\n+    struct NotSM;\n+\n+    // And one that is:\n+    #[derive(PartialEq, Eq)]\n+    struct SM;\n+\n+    // Check that SM is #[structural_match]:\n+    const CSM: SM = SM;\n+    match SM {\n+        CSM => count += 1,\n+    };\n+\n+    // Check that PhantomData<T> is #[structural_match] even if T is not.\n+    const CPD1: PhantomData<NotSM> = PhantomData;\n+    match PhantomData {\n+        CPD1 => count += 1,\n+    };\n+\n+    // Check that PhantomData<T> is #[structural_match] when T is.\n+    const CPD2: PhantomData<SM> = PhantomData;\n+    match PhantomData {\n+        CPD2 => count += 1,\n+    };\n+\n+    // Check that a type which has a PhantomData is `#[structural_match]`.\n+    #[derive(PartialEq, Eq, Default)]\n+    struct Foo {\n+        alpha: PhantomData<NotSM>,\n+        beta: PhantomData<SM>,\n+    }\n+\n+    const CFOO: Foo = Foo {\n+        alpha: PhantomData,\n+        beta: PhantomData,\n+    };\n+\n+    match Foo::default() {\n+        CFOO => count += 1,\n+    };\n+\n+    // Final count must be 4 now if all\n+    assert_eq!(count, 4);\n+}"}, {"sha": "ed2114b653015806cbf948b7209473f9d466a2bb", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d61837d1cf058cfbd0902b0bf79a2657b81187/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=f1d61837d1cf058cfbd0902b0bf79a2657b81187", "patch": "@@ -490,7 +490,7 @@ impl TestProps {\n             }\n \n             if !self.compile_pass {\n-                // run-pass implies must_compile_sucessfully\n+                // run-pass implies must_compile_successfully\n                 self.compile_pass = config.parse_compile_pass(ln) || self.run_pass;\n             }\n "}]}