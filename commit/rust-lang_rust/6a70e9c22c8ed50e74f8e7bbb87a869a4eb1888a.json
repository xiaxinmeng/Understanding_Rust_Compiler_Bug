{"sha": "6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNzBlOWMyMmM4ZWQ1MGU3NGY4ZTdiYmI4N2E4NjlhNGViMTg4OGE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-17T05:43:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-17T05:43:42Z"}, "message": "Merge pull request #1559 from topecongiro/poor/chain\n\nAllow the last element in chain to go multiline", "tree": {"sha": "66c15f287410ab839e56770bcac7f2a536763c40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66c15f287410ab839e56770bcac7f2a536763c40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "html_url": "https://github.com/rust-lang/rust/commit/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15323fc38b8deb761594daba97ba09728ac6a48e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15323fc38b8deb761594daba97ba09728ac6a48e", "html_url": "https://github.com/rust-lang/rust/commit/15323fc38b8deb761594daba97ba09728ac6a48e"}, {"sha": "d7b6f1199f25cde681eaa275290cac91066509a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b6f1199f25cde681eaa275290cac91066509a2", "html_url": "https://github.com/rust-lang/rust/commit/d7b6f1199f25cde681eaa275290cac91066509a2"}], "stats": {"total": 413, "additions": 194, "deletions": 219}, "files": [{"sha": "3c5f174a0c230c490005978664d15465f9d42930", "filename": "src/chains.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -174,7 +174,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let almost_total = rewrites[..rewrites.len() - 1]\n         .iter()\n         .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n-    let one_line_len = rewrites.iter().fold(0, |a, r| a + r.len()) + parent_rewrite.len();\n+    let one_line_len = rewrites.iter().fold(0, |a, r| a + first_line_width(r)) +\n+                       parent_rewrite.len();\n \n     let veto_single_line = if one_line_len > context.config.chain_one_line_max {\n         if rewrites.len() > 1 {\n@@ -248,13 +249,11 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n // True if the chain is only `?`s.\n fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n-    exprs\n-        .iter()\n-        .all(|e| if let ast::ExprKind::Try(_) = e.node {\n-                 true\n-             } else {\n-                 false\n-             })\n+    exprs.iter().all(|e| if let ast::ExprKind::Try(_) = e.node {\n+                         true\n+                     } else {\n+                         false\n+                     })\n }\n \n pub fn rewrite_try(expr: &ast::Expr,"}, {"sha": "dfe519782e1aa2a28f9701b2373a066ff7f2975b", "filename": "src/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -1028,11 +1028,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else =\n-                mk_sp(context\n-                          .codemap\n-                          .span_after(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"),\n-                      else_block.span.lo);\n+            let after_else = mk_sp(context.codemap.span_after(mk_sp(self.block.span.hi,\n+                                                                    else_block.span.lo),\n+                                                              \"else\"),\n+                                   else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n             let between_sep = match context.config.control_brace_style {"}, {"sha": "b41b6166ecaf5a8917b1e9b17f9ad6d04a3fae31", "filename": "src/items.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -457,11 +457,8 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let indent = self.block_indent;\n-        let mut result = try_opt!(field\n-                                      .node\n-                                      .attrs\n-                                      .rewrite(&self.get_context(),\n-                                               Shape::indented(indent, self.config)));\n+        let mut result = try_opt!(field.node.attrs.rewrite(&self.get_context(),\n+                                                           Shape::indented(indent, self.config)));\n         if !result.is_empty() {\n             result.push('\\n');\n             result.push_str(&indent.to_string(self.config));\n@@ -1201,9 +1198,9 @@ impl Rewrite for ast::StructField {\n \n         let name = self.ident;\n         let vis = format_visibility(&self.vis);\n-        let mut attr_str =\n-            try_opt!(self.attrs\n-                         .rewrite(context, Shape::indented(shape.indent, context.config)));\n+        let mut attr_str = try_opt!(self.attrs.rewrite(context,\n+                                                       Shape::indented(shape.indent,\n+                                                                       context.config)));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&shape.indent.to_string(context.config));\n@@ -1223,9 +1220,9 @@ impl Rewrite for ast::StructField {\n \n         let last_line_width = last_line_width(&result) + type_annotation_spacing.1.len();\n         let budget = try_opt!(shape.width.checked_sub(last_line_width));\n-        let ty_rewritten = self.ty\n-            .rewrite(context,\n-                     Shape::legacy(budget, shape.indent + last_line_width));\n+        let ty_rewritten =\n+            self.ty.rewrite(context,\n+                            Shape::legacy(budget, shape.indent + last_line_width));\n         match ty_rewritten {\n             Some(ref ty) if ty.contains('\\n') => {\n                 let new_ty = rewrite_type_in_next_line();\n@@ -1377,9 +1374,8 @@ impl Rewrite for ast::FunctionRetTy {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(self.pat\n-                                          .rewrite(context,\n-                                                   Shape::legacy(shape.width, shape.indent)));\n+            let mut result = try_opt!(self.pat.rewrite(context,\n+                                                       Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n                 if context.config.space_before_type_annotation {\n@@ -1390,10 +1386,9 @@ impl Rewrite for ast::Arg {\n                     result.push_str(\" \");\n                 }\n                 let max_width = try_opt!(shape.width.checked_sub(result.len()));\n-                let ty_str = try_opt!(self.ty\n-                                          .rewrite(context,\n-                                                   Shape::legacy(max_width,\n-                                                                 shape.indent + result.len())));\n+                let ty_str = try_opt!(self.ty.rewrite(context,\n+                                                      Shape::legacy(max_width,\n+                                                                    shape.indent + result.len())));\n                 result.push_str(&ty_str);\n             }\n \n@@ -1693,9 +1688,8 @@ fn rewrite_fn_base(context: &RewriteContext,\n         if multi_line_ret_str || ret_should_indent {\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n-            let ret_str = try_opt!(fd.output\n-                                       .rewrite(context,\n-                                                Shape::indented(ret_indent, context.config)));\n+            let ret_str = try_opt!(fd.output.rewrite(context,\n+                                                     Shape::indented(ret_indent, context.config)));\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -1985,16 +1979,14 @@ fn rewrite_generics(context: &RewriteContext,\n         .map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n \n     // Extract comments between generics.\n-    let lt_spans = lifetimes\n-        .iter()\n-        .map(|l| {\n-                 let hi = if l.bounds.is_empty() {\n-                     l.lifetime.span.hi\n-                 } else {\n-                     l.bounds[l.bounds.len() - 1].span.hi\n-                 };\n-                 mk_sp(l.lifetime.span.lo, hi)\n-             });\n+    let lt_spans = lifetimes.iter().map(|l| {\n+                                            let hi = if l.bounds.is_empty() {\n+                                                l.lifetime.span.hi\n+                                            } else {\n+                                                l.bounds[l.bounds.len() - 1].span.hi\n+                                            };\n+                                            mk_sp(l.lifetime.span.lo, hi)\n+                                        });\n     let ty_spans = tys.iter().map(span_for_ty_param);\n \n     let items = itemize_list(context.codemap,"}, {"sha": "c2e98de55ed539b57e6fc30c33203b8dc0043698", "filename": "src/lists.rs", "status": "modified", "additions": 102, "deletions": 104, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -339,116 +339,114 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     fn next(&mut self) -> Option<Self::Item> {\n         let white_space: &[_] = &[' ', '\\t'];\n \n-        self.inner\n-            .next()\n-            .map(|item| {\n-                let mut new_lines = false;\n-                // Pre-comment\n-                let pre_snippet = self.codemap\n-                    .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n-                    .unwrap();\n-                let trimmed_pre_snippet = pre_snippet.trim();\n-                let has_pre_comment = trimmed_pre_snippet.contains(\"//\") ||\n-                                      trimmed_pre_snippet.contains(\"/*\");\n-                let pre_comment = if has_pre_comment {\n-                    Some(trimmed_pre_snippet.to_owned())\n-                } else {\n-                    None\n-                };\n-\n-                // Post-comment\n-                let next_start = match self.inner.peek() {\n-                    Some(next_item) => (self.get_lo)(next_item),\n-                    None => self.next_span_start,\n-                };\n-                let post_snippet = self.codemap\n-                    .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n-                    .unwrap();\n-\n-                let comment_end = match self.inner.peek() {\n-                    Some(..) => {\n-                        let mut block_open_index = post_snippet.find(\"/*\");\n-                        // check if it realy is a block comment (and not //*)\n-                        if let Some(i) = block_open_index {\n-                            if i > 0 && &post_snippet[i - 1..i] == \"/\" {\n-                                block_open_index = None;\n-                            }\n-                        }\n-                        let newline_index = post_snippet.find('\\n');\n-                        let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                        match (block_open_index, newline_index) {\n-                            // Separator before comment, with the next item on same line.\n-                            // Comment belongs to next item.\n-                            (Some(i), None) if i > separator_index => separator_index + 1,\n-                            // Block-style post-comment before the separator.\n-                            (Some(i), None) => {\n-                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                         separator_index + 1)\n-                            }\n-                            // Block-style post-comment. Either before or after the separator.\n-                            (Some(i), Some(j)) if i < j => {\n-                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                         separator_index + 1)\n-                            }\n-                            // Potential *single* line comment.\n-                            (_, Some(j)) if j > separator_index => j + 1,\n-                            _ => post_snippet.len(),\n+        self.inner.next().map(|item| {\n+            let mut new_lines = false;\n+            // Pre-comment\n+            let pre_snippet = self.codemap\n+                .span_to_snippet(codemap::mk_sp(self.prev_span_end, (self.get_lo)(&item)))\n+                .unwrap();\n+            let trimmed_pre_snippet = pre_snippet.trim();\n+            let has_pre_comment = trimmed_pre_snippet.contains(\"//\") ||\n+                                  trimmed_pre_snippet.contains(\"/*\");\n+            let pre_comment = if has_pre_comment {\n+                Some(trimmed_pre_snippet.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            // Post-comment\n+            let next_start = match self.inner.peek() {\n+                Some(next_item) => (self.get_lo)(next_item),\n+                None => self.next_span_start,\n+            };\n+            let post_snippet = self.codemap\n+                .span_to_snippet(codemap::mk_sp((self.get_hi)(&item), next_start))\n+                .unwrap();\n+\n+            let comment_end = match self.inner.peek() {\n+                Some(..) => {\n+                    let mut block_open_index = post_snippet.find(\"/*\");\n+                    // check if it realy is a block comment (and not //*)\n+                    if let Some(i) = block_open_index {\n+                        if i > 0 && &post_snippet[i - 1..i] == \"/\" {\n+                            block_open_index = None;\n                         }\n                     }\n-                    None => {\n-                        post_snippet\n-                            .find_uncommented(self.terminator)\n-                            .unwrap_or(post_snippet.len())\n-                    }\n-                };\n-\n-                if !post_snippet.is_empty() && comment_end > 0 {\n-                    // Account for extra whitespace between items. This is fiddly\n-                    // because of the way we divide pre- and post- comments.\n-\n-                    // Everything from the separator to the next item.\n-                    let test_snippet = &post_snippet[comment_end - 1..];\n-                    let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n-                    // From the end of the first line of comments.\n-                    let test_snippet = &test_snippet[first_newline..];\n-                    let first = test_snippet\n-                        .find(|c: char| !c.is_whitespace())\n-                        .unwrap_or(test_snippet.len());\n-                    // From the end of the first line of comments to the next non-whitespace char.\n-                    let test_snippet = &test_snippet[..first];\n-\n-                    if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n-                        // There were multiple line breaks which got trimmed to nothing.\n-                        new_lines = true;\n+                    let newline_index = post_snippet.find('\\n');\n+                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n+\n+                    match (block_open_index, newline_index) {\n+                        // Separator before comment, with the next item on same line.\n+                        // Comment belongs to next item.\n+                        (Some(i), None) if i > separator_index => separator_index + 1,\n+                        // Block-style post-comment before the separator.\n+                        (Some(i), None) => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Block-style post-comment. Either before or after the separator.\n+                        (Some(i), Some(j)) if i < j => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Potential *single* line comment.\n+                        (_, Some(j)) if j > separator_index => j + 1,\n+                        _ => post_snippet.len(),\n                     }\n                 }\n-\n-                // Cleanup post-comment: strip separators and whitespace.\n-                self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-                let post_snippet = post_snippet[..comment_end].trim();\n-\n-                let post_snippet_trimmed = if post_snippet.starts_with(',') {\n-                    post_snippet[1..].trim_matches(white_space)\n-                } else if post_snippet.ends_with(',') {\n-                    post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-                } else {\n+                None => {\n                     post_snippet\n-                };\n-\n-                let post_comment = if !post_snippet_trimmed.is_empty() {\n-                    Some(post_snippet_trimmed.to_owned())\n-                } else {\n-                    None\n-                };\n-\n-                ListItem {\n-                    pre_comment: pre_comment,\n-                    item: (self.get_item_string)(&item),\n-                    post_comment: post_comment,\n-                    new_lines: new_lines,\n+                        .find_uncommented(self.terminator)\n+                        .unwrap_or(post_snippet.len())\n+                }\n+            };\n+\n+            if !post_snippet.is_empty() && comment_end > 0 {\n+                // Account for extra whitespace between items. This is fiddly\n+                // because of the way we divide pre- and post- comments.\n+\n+                // Everything from the separator to the next item.\n+                let test_snippet = &post_snippet[comment_end - 1..];\n+                let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n+                // From the end of the first line of comments.\n+                let test_snippet = &test_snippet[first_newline..];\n+                let first = test_snippet\n+                    .find(|c: char| !c.is_whitespace())\n+                    .unwrap_or(test_snippet.len());\n+                // From the end of the first line of comments to the next non-whitespace char.\n+                let test_snippet = &test_snippet[..first];\n+\n+                if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n+                    // There were multiple line breaks which got trimmed to nothing.\n+                    new_lines = true;\n                 }\n-            })\n+            }\n+\n+            // Cleanup post-comment: strip separators and whitespace.\n+            self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n+            let post_snippet = post_snippet[..comment_end].trim();\n+\n+            let post_snippet_trimmed = if post_snippet.starts_with(',') {\n+                post_snippet[1..].trim_matches(white_space)\n+            } else if post_snippet.ends_with(',') {\n+                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+            } else {\n+                post_snippet\n+            };\n+\n+            let post_comment = if !post_snippet_trimmed.is_empty() {\n+                Some(post_snippet_trimmed.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            ListItem {\n+                pre_comment: pre_comment,\n+                item: (self.get_item_string)(&item),\n+                post_comment: post_comment,\n+                new_lines: new_lines,\n+            }\n+        })\n     }\n }\n "}, {"sha": "70924b90d233fb5403d7d8e69f665e23168520bf", "filename": "src/macros.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -159,15 +159,13 @@ pub fn rewrite_macro(mac: &ast::Mac,\n             // Format macro invocation as array literal.\n             let extra_offset = macro_name.len();\n             let shape = try_opt!(shape.shrink_left(extra_offset));\n-            let rewrite = try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n-                                                 mk_sp(context\n-                                                           .codemap\n-                                                           .span_after(mac.span,\n-                                                                       original_style\n-                                                                           .opener()),\n-                                                       mac.span.hi - BytePos(1)),\n-                                                 context,\n-                                                 shape));\n+            let rewrite =\n+                try_opt!(rewrite_array(expr_vec.iter().map(|x| &**x),\n+                                       mk_sp(context.codemap.span_after(mac.span,\n+                                                                        original_style.opener()),\n+                                             mac.span.hi - BytePos(1)),\n+                                       context,\n+                                       shape));\n \n             Some(format!(\"{}{}\", macro_name, rewrite))\n         }"}, {"sha": "e83cc4d462d6048ce3c8481f640fc439a7a3c7c1", "filename": "src/missed_spans.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -158,13 +158,12 @@ impl<'a> FmtVisitor<'a> {\n                                                         self.config.max_width -\n                                                         self.block_indent.width());\n \n-                    self.buffer\n-                        .push_str(&rewrite_comment(subslice,\n-                                                   false,\n-                                                   Shape::legacy(comment_width,\n-                                                                 self.block_indent),\n-                                                   self.config)\n-                                          .unwrap());\n+                    self.buffer.push_str(&rewrite_comment(subslice,\n+                                                          false,\n+                                                          Shape::legacy(comment_width,\n+                                                                        self.block_indent),\n+                                                          self.config)\n+                                                 .unwrap());\n \n                     last_wspace = None;\n                     line_start = offset + subslice.len();"}, {"sha": "a16288886227348f1feab799d14d601485ca3b9a", "filename": "src/patterns.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -39,11 +39,10 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width = try_opt!(shape\n-                                                 .width\n-                                                 .checked_sub(prefix.len() + mut_infix.len() +\n-                                                              id_str.len() +\n-                                                              3));\n+                        let width = try_opt!(shape.width.checked_sub(prefix.len() +\n+                                                                     mut_infix.len() +\n+                                                                     id_str.len() +\n+                                                                     3));\n                         format!(\" @ {}\",\n                                 try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent))))\n                     }\n@@ -328,13 +327,11 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n fn count_wildcard_suffix_len(items: &[ListItem]) -> usize {\n     let mut suffix_len = 0;\n \n-    for item in items\n-            .iter()\n-            .rev()\n-            .take_while(|i| match i.item {\n-                            Some(ref internal_string) if internal_string == \"_\" => true,\n-                            _ => false,\n-                        }) {\n+    for item in items.iter().rev().take_while(|i| match i.item {\n+                                                  Some(ref internal_string) if internal_string ==\n+                                                                               \"_\" => true,\n+                                                  _ => false,\n+                                              }) {\n         suffix_len += 1;\n \n         if item.pre_comment.is_some() || item.post_comment.is_some() {"}, {"sha": "5cb0fc3f49dbf16a24c0fc558788ca630e3823d0", "filename": "src/types.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -163,11 +163,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n                 let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite =\n-                    try_opt!(binding\n-                                 .ty\n-                                 .rewrite(context,\n-                                          Shape::legacy(budget, shape.indent + result.len())));\n+                let rewrite = try_opt!(binding.ty.rewrite(context,\n+                                                          Shape::legacy(budget,\n+                                                                        shape.indent +\n+                                                                        result.len())));\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -563,10 +562,10 @@ impl Rewrite for ast::PolyTraitRef {\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref\n-                                        .rewrite(context,\n-                                                 Shape::legacy(max_path_width,\n-                                                               shape.indent + extra_offset)));\n+            let path_str = try_opt!(self.trait_ref.rewrite(context,\n+                                                           Shape::legacy(max_path_width,\n+                                                                         shape.indent +\n+                                                                         extra_offset)));\n \n             Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n                      format!(\"for< {} > {}\", lifetime_str, path_str)\n@@ -613,22 +612,20 @@ impl Rewrite for ast::Ty {\n                              format!(\"&{} {}{}\",\n                                      lt_str,\n                                      mut_str,\n-                                     try_opt!(mt.ty\n-                                                  .rewrite(context,\n-                                                           Shape::legacy(budget,\n-                                                                         shape.indent + 2 +\n-                                                                         mut_len +\n-                                                                         lt_len))))\n+                                     try_opt!(mt.ty.rewrite(context,\n+                                                            Shape::legacy(budget,\n+                                                                          shape.indent + 2 +\n+                                                                          mut_len +\n+                                                                          lt_len))))\n                          }\n                          None => {\n                              let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n                              format!(\"&{}{}\",\n                                      mut_str,\n-                                     try_opt!(mt.ty\n-                                                  .rewrite(context,\n-                                                           Shape::legacy(budget,\n-                                                                         shape.indent + 1 +\n-                                                                         mut_len))))\n+                                     try_opt!(mt.ty.rewrite(context,\n+                                                            Shape::legacy(budget,\n+                                                                          shape.indent + 1 +\n+                                                                          mut_len))))\n                          }\n                      })\n             }"}, {"sha": "66f7fa19cfb69d41d8501f339793faf7e579b038", "filename": "tests/system.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -303,21 +303,18 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n         .map(|line| line.expect(\"Failed getting line\"))\n         .take_while(|line| line_regex.is_match(&line))\n         .filter_map(|line| {\n-            regex\n-                .captures_iter(&line)\n-                .next()\n-                .map(|capture| {\n-                    (capture\n-                         .get(1)\n-                         .expect(\"Couldn't unwrap capture\")\n-                         .as_str()\n-                         .to_owned(),\n-                     capture\n-                         .get(2)\n-                         .expect(\"Couldn't unwrap capture\")\n-                         .as_str()\n-                         .to_owned())\n-                })\n+            regex.captures_iter(&line).next().map(|capture| {\n+                (capture\n+                     .get(1)\n+                     .expect(\"Couldn't unwrap capture\")\n+                     .as_str()\n+                     .to_owned(),\n+                 capture\n+                     .get(2)\n+                     .expect(\"Couldn't unwrap capture\")\n+                     .as_str()\n+                     .to_owned())\n+            })\n         })\n         .collect()\n }"}, {"sha": "2d3b52da72a4dfefc36ad838d5d9a500f366eb81", "filename": "tests/target/tuple.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/tests%2Ftarget%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a/tests%2Ftarget%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftuple.rs?ref=6a70e9c22c8ed50e74f8e7bbb87a869a4eb1888a", "patch": "@@ -29,14 +29,13 @@ fn b() {\n }\n \n fn issue550() {\n-    self.visitor\n-        .visit_volume(self.level.sector_id(sector),\n-                      (floor_y,\n-                       if is_sky_flat(ceil_tex) {\n-                           from_wad_height(self.height_range.1)\n-                       } else {\n-                           ceil_y\n-                       }));\n+    self.visitor.visit_volume(self.level.sector_id(sector),\n+                              (floor_y,\n+                               if is_sky_flat(ceil_tex) {\n+                                   from_wad_height(self.height_range.1)\n+                               } else {\n+                                   ceil_y\n+                               }));\n }\n \n fn issue775() {"}]}