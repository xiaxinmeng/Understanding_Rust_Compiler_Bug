{"sha": "26c05b13e11518a99f06b618b833a48851a39fbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YzA1YjEzZTExNTE4YTk5ZjA2YjYxOGI4MzNhNDg4NTFhMzlmYmU=", "commit": {"author": {"name": "Markus Klein", "email": "markus-klein@live.de", "date": "2018-09-11T22:26:07Z"}, "committer": {"name": "Markus Klein", "email": "markus-klein@live.de", "date": "2018-09-11T22:26:07Z"}, "message": "Add ty::Ty to PatternKind::Range;u128 for Const in Constructor::ConstantRange", "tree": {"sha": "5fb9be54aafac2f883597bffcf27b1efd3c1c70f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fb9be54aafac2f883597bffcf27b1efd3c1c70f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26c05b13e11518a99f06b618b833a48851a39fbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26c05b13e11518a99f06b618b833a48851a39fbe", "html_url": "https://github.com/rust-lang/rust/commit/26c05b13e11518a99f06b618b833a48851a39fbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26c05b13e11518a99f06b618b833a48851a39fbe/comments", "author": {"login": "pacman82", "id": 12252881, "node_id": "MDQ6VXNlcjEyMjUyODgx", "avatar_url": "https://avatars.githubusercontent.com/u/12252881?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pacman82", "html_url": "https://github.com/pacman82", "followers_url": "https://api.github.com/users/pacman82/followers", "following_url": "https://api.github.com/users/pacman82/following{/other_user}", "gists_url": "https://api.github.com/users/pacman82/gists{/gist_id}", "starred_url": "https://api.github.com/users/pacman82/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pacman82/subscriptions", "organizations_url": "https://api.github.com/users/pacman82/orgs", "repos_url": "https://api.github.com/users/pacman82/repos", "events_url": "https://api.github.com/users/pacman82/events{/privacy}", "received_events_url": "https://api.github.com/users/pacman82/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pacman82", "id": 12252881, "node_id": "MDQ6VXNlcjEyMjUyODgx", "avatar_url": "https://avatars.githubusercontent.com/u/12252881?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pacman82", "html_url": "https://github.com/pacman82", "followers_url": "https://api.github.com/users/pacman82/followers", "following_url": "https://api.github.com/users/pacman82/following{/other_user}", "gists_url": "https://api.github.com/users/pacman82/gists{/gist_id}", "starred_url": "https://api.github.com/users/pacman82/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pacman82/subscriptions", "organizations_url": "https://api.github.com/users/pacman82/orgs", "repos_url": "https://api.github.com/users/pacman82/repos", "events_url": "https://api.github.com/users/pacman82/events{/privacy}", "received_events_url": "https://api.github.com/users/pacman82/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "763d91aa124a4278a68207b644df8c48b39fab45", "url": "https://api.github.com/repos/rust-lang/rust/commits/763d91aa124a4278a68207b644df8c48b39fab45", "html_url": "https://github.com/rust-lang/rust/commit/763d91aa124a4278a68207b644df8c48b39fab45"}], "stats": {"total": 145, "additions": 86, "deletions": 59}, "files": [{"sha": "d07e8d0dfcaf48c1607a1e13b4a0538758b44888", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=26c05b13e11518a99f06b618b833a48851a39fbe", "patch": "@@ -70,13 +70,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatternKind::Range { lo, hi, end } => {\n+            PatternKind::Range { lo, hi, ty, end } => {\n+                assert!(ty == match_pair.pattern.ty);\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Range {\n                         lo,\n                         hi,\n-                        ty: match_pair.pattern.ty.clone(),\n+                        ty,\n                         end,\n                     },\n                 }"}, {"sha": "f67e52caf712535b2998e0ae1b690cf0c64134fa", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 77, "deletions": 54, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=26c05b13e11518a99f06b618b833a48851a39fbe", "patch": "@@ -416,7 +416,7 @@ pub enum Constructor<'tcx> {\n     /// Literal values.\n     ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(u64),\n }\n@@ -588,7 +588,12 @@ impl<'tcx> Witness<'tcx> {\n                 _ => {\n                     match *ctor {\n                         ConstantValue(value) => PatternKind::Constant { value },\n-                        ConstantRange(lo, hi, end) => PatternKind::Range { lo, hi, end },\n+                        ConstantRange(lo, hi, ty, end) => PatternKind::Range {\n+                            lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                            hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                            ty,\n+                            end,\n+                        },\n                         _ => PatternKind::Wild,\n                     }\n                 }\n@@ -648,34 +653,32 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .collect()\n         }\n         ty::Char if exhaustive_integer_patterns => {\n-            let endpoint = |c: char| {\n-                let ty = ty::ParamEnv::empty().and(cx.tcx.types.char);\n-                ty::Const::from_bits(cx.tcx, c as u128, ty)\n-            };\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange(endpoint('\\u{0000}'), endpoint('\\u{D7FF}'), RangeEnd::Included),\n-                ConstantRange(endpoint('\\u{E000}'), endpoint('\\u{10FFFF}'), RangeEnd::Included),\n+                ConstantRange('\\u{0000}' as u128,\n+                              '\\u{D7FF}' as u128,\n+                              cx.tcx.types.char,\n+                              RangeEnd::Included\n+                ),\n+                ConstantRange('\\u{E000}' as u128,\n+                              '\\u{10FFFF}' as u128,\n+                              cx.tcx.types.char,\n+                              RangeEnd::Included\n+                ),\n             ]\n         }\n         ty::Int(ity) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = (1u128 << (bits - 1)) - 1;\n-            let ty = ty::ParamEnv::empty().and(pcx.ty);\n-            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min as u128, ty),\n-                               ty::Const::from_bits(cx.tcx, max as u128, ty),\n-                               RangeEnd::Included)]\n+            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n         }\n         ty::Uint(uty) if exhaustive_integer_patterns => {\n             // FIXME(49937): refactor these bit manipulations into interpret.\n             let bits = Integer::from_attr(cx.tcx, UnsignedInt(uty)).size().bits() as u128;\n             let max = !0u128 >> (128 - bits);\n-            let ty = ty::ParamEnv::empty().and(pcx.ty);\n-            vec![ConstantRange(ty::Const::from_bits(cx.tcx, 0, ty),\n-                               ty::Const::from_bits(cx.tcx, max, ty),\n-                               RangeEnd::Included)]\n+            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -811,26 +814,18 @@ impl<'tcx> IntRange<'tcx> {\n                  ctor: &Constructor<'tcx>)\n                  -> Option<IntRange<'tcx>> {\n         match ctor {\n-            ConstantRange(lo, hi, end) => {\n-                assert_eq!(lo.ty, hi.ty);\n-                let ty = lo.ty;\n-                let env_ty = ty::ParamEnv::empty().and(ty);\n-                if let Some(lo) = lo.assert_bits(tcx, env_ty) {\n-                    if let Some(hi) = hi.assert_bits(tcx, env_ty) {\n-                        // Perform a shift if the underlying types are signed,\n-                        // which makes the interval arithmetic simpler.\n-                        let bias = IntRange::signed_bias(tcx, ty);\n-                        let (lo, hi) = (lo ^ bias, hi ^ bias);\n-                        // Make sure the interval is well-formed.\n-                        return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n-                            None\n-                        } else {\n-                            let offset = (*end == RangeEnd::Excluded) as u128;\n-                            Some(IntRange { range: lo..=(hi - offset), ty })\n-                        };\n-                    }\n+            ConstantRange(lo, hi, ty, end) => {\n+                // Perform a shift if the underlying types are signed,\n+                // which makes the interval arithmetic simpler.\n+                let bias = IntRange::signed_bias(tcx, ty);\n+                let (lo, hi) = (lo ^ bias, hi ^ bias);\n+                // Make sure the interval is well-formed.\n+                if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                    None\n+                } else {\n+                    let offset = (*end == RangeEnd::Excluded) as u128;\n+                    Some(IntRange { range: lo..=(hi - offset), ty })\n                 }\n-                None\n             }\n             ConstantValue(val) => {\n                 let ty = val.ty;\n@@ -853,7 +848,12 @@ impl<'tcx> IntRange<'tcx> {\n                 -> Option<IntRange<'tcx>> {\n         Self::from_ctor(tcx, &match pat.kind {\n             box PatternKind::Constant { value } => ConstantValue(value),\n-            box PatternKind::Range { lo, hi, end } => ConstantRange(lo, hi, end),\n+            box PatternKind::Range { lo, hi, ty, end } => ConstantRange(\n+                lo.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                hi.to_bits(tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                ty,\n+                end,\n+            ),\n             _ => return None,\n         })\n     }\n@@ -876,14 +876,12 @@ impl<'tcx> IntRange<'tcx> {\n         r: RangeInclusive<u128>,\n     ) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, ty);\n-        let ty = ty::ParamEnv::empty().and(ty);\n         let (lo, hi) = r.into_inner();\n         if lo == hi {\n+            let ty = ty::ParamEnv::empty().and(ty);\n             ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n         } else {\n-            ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n-                          ty::Const::from_bits(tcx, hi ^ bias, ty),\n-                          RangeEnd::Included)\n+            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included)\n         }\n     }\n \n@@ -1228,8 +1226,8 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// Slice patterns, however, can match slices of different lengths. For instance,\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n-/// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n+/// Returns None in case of a catch-all, which can't be specialized.\n+fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           pat: &Pattern<'tcx>,\n                           pcx: PatternContext)\n                           -> Option<Vec<Constructor<'tcx>>>\n@@ -1241,7 +1239,13 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n             Some(vec![Variant(adt_def.variants[variant_index].did)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n-        PatternKind::Range { lo, hi, end } => Some(vec![ConstantRange(lo, hi, end)]),\n+        PatternKind::Range { lo, hi, ty, end } =>\n+            Some(vec![ConstantRange(\n+                lo.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                hi.to_bits(cx.tcx, ty::ParamEnv::empty().and(ty)).unwrap(),\n+                ty,\n+                end,\n+            )]),\n         PatternKind::Array { .. } => match pcx.ty.sty {\n             ty::Array(_, length) => Some(vec![\n                 Slice(length.unwrap_usize(cx.tcx))\n@@ -1381,10 +1385,13 @@ fn slice_pat_covered_by_constructor<'tcx>(\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'_, 'tcx, 'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     if tcx.features().exhaustive_integer_patterns {\n-        if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n-            if let ty::Char | ty::Int(_) | ty::Uint(_) = value.ty.sty {\n-                return true;\n-            }\n+        let ty = match ctor {\n+            ConstantValue(value) => value.ty,\n+            ConstantRange(_, _, ty, _) => ty,\n+            _ => return false,\n+        };\n+        if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.sty {\n+            return true;\n         }\n     }\n     false\n@@ -1535,7 +1542,7 @@ fn constructor_covered_by_range<'a, 'tcx>(\n ) -> Result<bool, ErrorReported> {\n     let (from, to, end, ty) = match pat.kind {\n         box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        box PatternKind::Range { lo, hi, end } => (lo, hi, end, lo.ty),\n+        box PatternKind::Range { lo, hi, ty, end } => (lo, hi, end, ty),\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n@@ -1557,17 +1564,33 @@ fn constructor_covered_by_range<'a, 'tcx>(\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n-        ConstantRange(from, to, RangeEnd::Included) => {\n-            let to = some_or_ok!(cmp_to(to));\n+        ConstantRange(from, to, ty, RangeEnd::Included) => {\n+            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n+                tcx,\n+                to,\n+                ty::ParamEnv::empty().and(ty),\n+            )));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(from)) && end)\n+            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n+                tcx,\n+                from,\n+                ty::ParamEnv::empty().and(ty),\n+            ))) && end)\n         },\n-        ConstantRange(from, to, RangeEnd::Excluded) => {\n-            let to = some_or_ok!(cmp_to(to));\n+        ConstantRange(from, to, ty, RangeEnd::Excluded) => {\n+            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n+                tcx,\n+                to,\n+                ty::ParamEnv::empty().and(ty)\n+            )));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Excluded && to == Ordering::Equal);\n-            Ok(some_or_ok!(cmp_from(from)) && end)\n+            Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n+                tcx,\n+                from,\n+                ty::ParamEnv::empty().and(ty)))\n+            ) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),"}, {"sha": "004cc1cca9c2be281a647b879c439e28c85f915d", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c05b13e11518a99f06b618b833a48851a39fbe/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=26c05b13e11518a99f06b618b833a48851a39fbe", "patch": "@@ -101,6 +101,7 @@ pub enum PatternKind<'tcx> {\n     Range {\n         lo: &'tcx ty::Const<'tcx>,\n         hi: &'tcx ty::Const<'tcx>,\n+        ty: Ty<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -230,7 +231,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n             PatternKind::Constant { value } => {\n                 fmt_const_val(f, value)\n             }\n-            PatternKind::Range { lo, hi, end } => {\n+            PatternKind::Range { lo, hi, ty: _, end } => {\n                 fmt_const_val(f, lo)?;\n                 match end {\n                     RangeEnd::Included => write!(f, \"..=\")?,\n@@ -359,7 +360,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         match (end, cmp) {\n                             (RangeEnd::Excluded, Some(Ordering::Less)) =>\n-                                PatternKind::Range { lo, hi, end },\n+                                PatternKind::Range { lo, hi, ty, end },\n                             (RangeEnd::Excluded, _) => {\n                                 span_err!(\n                                     self.tcx.sess,\n@@ -373,7 +374,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 PatternKind::Constant { value: lo }\n                             }\n                             (RangeEnd::Included, Some(Ordering::Less)) => {\n-                                PatternKind::Range { lo, hi, end }\n+                                PatternKind::Range { lo, hi, ty, end }\n                             }\n                             (RangeEnd::Included, _) => {\n                                 let mut err = struct_span_err!(\n@@ -1017,10 +1018,12 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n             PatternKind::Range {\n                 lo,\n                 hi,\n+                ty,\n                 end,\n             } => PatternKind::Range {\n                 lo: lo.fold_with(folder),\n                 hi: hi.fold_with(folder),\n+                ty: ty.fold_with(folder),\n                 end,\n             },\n             PatternKind::Slice {"}]}