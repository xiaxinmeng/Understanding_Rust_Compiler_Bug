{"sha": "32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "node_id": "C_kwDOAAsO6NoAKDMyNDI0ZDBhYmEzZjllMjA1NzZhZmYwYTFjODllMDFhYzNhZDhiNjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-01T12:40:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-01T12:40:55Z"}, "message": "Auto merge of #14176 - lowr:fix/assoc-func-vis-in-local-impl, r=Veykril\n\nFix associated item visibility in block-local impls\n\nFixes #14046\n\nWhen we're resolving visibility of block-local items...\n\n> `self` normally refers to the containing non-block module, and `super` to its parent (etc.). However, visibilities must only refer to a module in the DefMap they're written in, so we restrict them when that happens. ([link])\n\n ...unless we're resolving visibility of associated items in block-local impls, because that impl is semantically \"hoisted\" to the nearest (non-block) module. With this PR, we skip the adjustment for such items.\n\nSince visibility representation of those items is modified, this PR also adjusts visibility rendering in `HirDisplay`.\n\n[link]: https://github.com/rust-lang/rust-analyzer/blob/a6603fc21d50b3386a488c96225b2d1fd492e533/crates/hir-def/src/nameres/path_resolution.rs#L101-L103", "tree": {"sha": "ec60bca941c682cfe7ab5cd4a43eec8f57ac6b0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec60bca941c682cfe7ab5cd4a43eec8f57ac6b0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "html_url": "https://github.com/rust-lang/rust/commit/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9d5db8571117911d8e039aed46fdff59bd65a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9d5db8571117911d8e039aed46fdff59bd65a2", "html_url": "https://github.com/rust-lang/rust/commit/ef9d5db8571117911d8e039aed46fdff59bd65a2"}, {"sha": "d4166234ef54a1019fe200adb414d0580133cd69", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4166234ef54a1019fe200adb414d0580133cd69", "html_url": "https://github.com/rust-lang/rust/commit/d4166234ef54a1019fe200adb414d0580133cd69"}], "stats": {"total": 312, "additions": 282, "deletions": 30}, "files": [{"sha": "2aab1ccd914c1ccffdc1ddb1c464ae12b9f9b6c2", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -128,7 +128,7 @@ impl ModuleId {\n     }\n }\n \n-/// An ID of a module, **local** to a specific crate\n+/// An ID of a module, **local** to a `DefMap`.\n pub type LocalModuleId = Idx<nameres::ModuleData>;\n \n #[derive(Debug)]"}, {"sha": "a7ce0360516aa0e1f6d81efa8c25050abaa3fd20", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -342,7 +342,7 @@ impl DefMap {\n     }\n \n     pub(crate) fn block_id(&self) -> Option<BlockId> {\n-        self.block.as_ref().map(|block| block.block)\n+        self.block.map(|block| block.block)\n     }\n \n     pub(crate) fn prelude(&self) -> Option<ModuleId> {\n@@ -354,7 +354,7 @@ impl DefMap {\n     }\n \n     pub fn module_id(&self, local_id: LocalModuleId) -> ModuleId {\n-        let block = self.block.as_ref().map(|b| b.block);\n+        let block = self.block.map(|b| b.block);\n         ModuleId { krate: self.krate, local_id, block }\n     }\n \n@@ -432,9 +432,9 @@ impl DefMap {\n     /// Returns the module containing `local_mod`, either the parent `mod`, or the module containing\n     /// the block, if `self` corresponds to a block expression.\n     pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n-        match &self[local_mod].parent {\n-            Some(parent) => Some(self.module_id(*parent)),\n-            None => self.block.as_ref().map(|block| block.parent),\n+        match self[local_mod].parent {\n+            Some(parent) => Some(self.module_id(parent)),\n+            None => self.block.map(|block| block.parent),\n         }\n     }\n \n@@ -444,11 +444,11 @@ impl DefMap {\n         let mut buf = String::new();\n         let mut arc;\n         let mut current_map = self;\n-        while let Some(block) = &current_map.block {\n+        while let Some(block) = current_map.block {\n             go(&mut buf, current_map, \"block scope\", current_map.root);\n             buf.push('\\n');\n             arc = block.parent.def_map(db);\n-            current_map = &*arc;\n+            current_map = &arc;\n         }\n         go(&mut buf, current_map, \"crate\", current_map.root);\n         return buf;\n@@ -472,10 +472,10 @@ impl DefMap {\n         let mut buf = String::new();\n         let mut arc;\n         let mut current_map = self;\n-        while let Some(block) = &current_map.block {\n+        while let Some(block) = current_map.block {\n             format_to!(buf, \"{:?} in {:?}\\n\", block.block, block.parent);\n             arc = block.parent.def_map(db);\n-            current_map = &*arc;\n+            current_map = &arc;\n         }\n \n         format_to!(buf, \"crate scope\\n\");"}, {"sha": "e3704bf2164b01ce0508699ce06f36e4cf74933d", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -666,8 +666,10 @@ impl DefCollector<'_> {\n         macro_: Macro2Id,\n         vis: &RawVisibility,\n     ) {\n-        let vis =\n-            self.def_map.resolve_visibility(self.db, module_id, vis).unwrap_or(Visibility::Public);\n+        let vis = self\n+            .def_map\n+            .resolve_visibility(self.db, module_id, vis, false)\n+            .unwrap_or(Visibility::Public);\n         self.def_map.modules[module_id].scope.declare(macro_.into());\n         self.update(\n             module_id,\n@@ -831,7 +833,7 @@ impl DefCollector<'_> {\n         let mut def = directive.status.namespaces();\n         let vis = self\n             .def_map\n-            .resolve_visibility(self.db, module_id, &directive.import.visibility)\n+            .resolve_visibility(self.db, module_id, &directive.import.visibility, false)\n             .unwrap_or(Visibility::Public);\n \n         match import.kind {\n@@ -1547,7 +1549,7 @@ impl ModCollector<'_, '_> {\n                 };\n             let resolve_vis = |def_map: &DefMap, visibility| {\n                 def_map\n-                    .resolve_visibility(db, self.module_id, visibility)\n+                    .resolve_visibility(db, self.module_id, visibility, false)\n                     .unwrap_or(Visibility::Public)\n             };\n \n@@ -1823,7 +1825,7 @@ impl ModCollector<'_, '_> {\n     ) -> LocalModuleId {\n         let def_map = &mut self.def_collector.def_map;\n         let vis = def_map\n-            .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+            .resolve_visibility(self.def_collector.db, self.module_id, visibility, false)\n             .unwrap_or(Visibility::Public);\n         let modules = &mut def_map.modules;\n         let origin = match definition {"}, {"sha": "25478481dd0b343afd74a5f19d7d05c3e76e4d93", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -78,6 +78,7 @@ impl DefMap {\n         // pub(path)\n         //     ^^^^ this\n         visibility: &RawVisibility,\n+        within_impl: bool,\n     ) -> Option<Visibility> {\n         let mut vis = match visibility {\n             RawVisibility::Module(path) => {\n@@ -102,7 +103,8 @@ impl DefMap {\n         // `super` to its parent (etc.). However, visibilities must only refer to a module in the\n         // DefMap they're written in, so we restrict them when that happens.\n         if let Visibility::Module(m) = vis {\n-            if self.block_id() != m.block {\n+            // ...unless we're resolving visibility for an associated item in an impl.\n+            if self.block_id() != m.block && !within_impl {\n                 cov_mark::hit!(adjust_vis_in_block_def_map);\n                 vis = Visibility::Module(self.module_id(self.root()));\n                 tracing::debug!(\"visibility {:?} points outside DefMap, adjusting to {:?}\", m, vis);"}, {"sha": "36d8b24e9c3377d1021292651419b3ee1abb3c40", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -214,10 +214,12 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         visibility: &RawVisibility,\n     ) -> Option<Visibility> {\n+        let within_impl =\n+            self.scopes().find(|scope| matches!(scope, Scope::ImplDefScope(_))).is_some();\n         match visibility {\n             RawVisibility::Module(_) => {\n                 let (item_map, module) = self.item_scope();\n-                item_map.resolve_visibility(db, module, visibility)\n+                item_map.resolve_visibility(db, module, visibility, within_impl)\n             }\n             RawVisibility::Public => Some(Visibility::Public),\n         }"}, {"sha": "c9fcaae56cf0cbf86c8d19afa15047194f9cfa46", "filename": "crates/hir-def/src/visibility.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     nameres::DefMap,\n     path::{ModPath, PathKind},\n     resolver::HasResolver,\n-    ConstId, FunctionId, HasModule, LocalFieldId, ModuleId, VariantId,\n+    ConstId, FunctionId, HasModule, LocalFieldId, LocalModuleId, ModuleId, VariantId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -120,7 +120,7 @@ impl Visibility {\n         self,\n         db: &dyn DefDatabase,\n         def_map: &DefMap,\n-        mut from_module: crate::LocalModuleId,\n+        mut from_module: LocalModuleId,\n     ) -> bool {\n         let mut to_module = match self {\n             Visibility::Module(m) => m,\n@@ -142,7 +142,8 @@ impl Visibility {\n                 arc = to_module.def_map(db);\n                 &arc\n             };\n-        let is_block_root = matches!(to_module.block, Some(_) if to_module_def_map[to_module.local_id].parent.is_none());\n+        let is_block_root =\n+            to_module.block.is_some() && to_module_def_map[to_module.local_id].parent.is_none();\n         if is_block_root {\n             to_module = to_module_def_map.containing_module(to_module.local_id).unwrap();\n         }"}, {"sha": "66bf2a2900e87e9ccec3c1190851f06826e11ff8", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -17,15 +17,23 @@ use hir_ty::{\n };\n \n use crate::{\n-    Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n-    LifetimeParam, Macro, Module, Static, Struct, Trait, TyBuilder, Type, TypeAlias,\n-    TypeOrConstParam, TypeParam, Union, Variant,\n+    Adt, AsAssocItem, AssocItemContainer, Const, ConstParam, Enum, Field, Function, GenericParam,\n+    HasCrate, HasVisibility, LifetimeParam, Macro, Module, Static, Struct, Trait, TyBuilder, Type,\n+    TypeAlias, TypeOrConstParam, TypeParam, Union, Variant,\n };\n \n impl HirDisplay for Function {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        let data = f.db.function_data(self.id);\n-        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let db = f.db;\n+        let data = db.function_data(self.id);\n+        let container = self.as_assoc_item(db).map(|it| it.container(db));\n+        let mut module = self.module(db);\n+        if let Some(AssocItemContainer::Impl(_)) = container {\n+            // Block-local impls are \"hoisted\" to the nearest (non-block) module.\n+            module = module.nearest_non_block_module(db);\n+        }\n+        let module_id = module.id;\n+        write_visibility(module_id, self.visibility(db), f)?;\n         if data.has_default_kw() {\n             f.write_str(\"default \")?;\n         }\n@@ -35,7 +43,7 @@ impl HirDisplay for Function {\n         if data.has_async_kw() {\n             f.write_str(\"async \")?;\n         }\n-        if self.is_unsafe_to_call(f.db) {\n+        if self.is_unsafe_to_call(db) {\n             f.write_str(\"unsafe \")?;\n         }\n         if let Some(abi) = &data.abi {\n@@ -50,7 +58,7 @@ impl HirDisplay for Function {\n \n         let write_self_param = |ty: &TypeRef, f: &mut HirFormatter<'_>| match ty {\n             TypeRef::Path(p) if p.is_self_type() => f.write_str(\"self\"),\n-            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n+            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner, TypeRef::Path(p) if p.is_self_type()) =>\n             {\n                 f.write_char('&')?;\n                 if let Some(lifetime) = lifetime {\n@@ -442,8 +450,15 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n \n impl HirDisplay for Const {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n-        let data = f.db.const_data(self.id);\n+        let db = f.db;\n+        let container = self.as_assoc_item(db).map(|it| it.container(db));\n+        let mut module = self.module(db);\n+        if let Some(AssocItemContainer::Impl(_)) = container {\n+            // Block-local impls are \"hoisted\" to the nearest (non-block) module.\n+            module = module.nearest_non_block_module(db);\n+        }\n+        write_visibility(module.id, self.visibility(db), f)?;\n+        let data = db.const_data(self.id);\n         f.write_str(\"const \")?;\n         match &data.name {\n             Some(name) => write!(f, \"{name}: \")?,"}, {"sha": "c64106d3afde59cab85706d592a871167e3f3851", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -46,7 +46,7 @@ use hir_def::{\n     item_tree::ItemTreeNode,\n     lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n-    nameres::{self, diagnostics::DefDiagnostic},\n+    nameres::{self, diagnostics::DefDiagnostic, ModuleOrigin},\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -488,6 +488,20 @@ impl Module {\n         Some(Module { id: def_map.module_id(parent_id) })\n     }\n \n+    /// Finds nearest non-block ancestor `Module` (`self` included).\n+    fn nearest_non_block_module(self, db: &dyn HirDatabase) -> Module {\n+        let mut id = self.id;\n+        loop {\n+            let def_map = id.def_map(db.upcast());\n+            let origin = def_map[id.local_id].origin;\n+            if matches!(origin, ModuleOrigin::BlockExpr { .. }) {\n+                id = id.containing_module(db.upcast()).expect(\"block without parent module\")\n+            } else {\n+                return Module { id };\n+            }\n+        }\n+    }\n+\n     pub fn path_to_root(self, db: &dyn HirDatabase) -> Vec<Module> {\n         let mut res = vec![self];\n         let mut curr = self;"}, {"sha": "67da5c7f27d148fd1f8958090aa0c5011dd53c8c", "filename": "crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -115,6 +115,44 @@ mod module {\n fn main(s: module::Struct) {\n     s.method();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn can_see_through_top_level_anonymous_const() {\n+        // regression test for #14046.\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) fn method(self) {}\n+            pub(crate) const A: usize = 42;\n+        }\n+    };\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) fn method2(self) {}\n+                pub(crate) const B: usize = 42;\n+                pub(super) fn private(self) {}\n+                pub(super) const PRIVATE: usize = 42;\n+            }\n+        };\n+    }\n+}\n+fn main() {\n+    S.method();\n+    S::A;\n+    S.method2();\n+    S::B;\n+    S.private();\n+  //^^^^^^^^^^^ error: function `private` is private\n+    S::PRIVATE;\n+  //^^^^^^^^^^ error: const `PRIVATE` is private\n+}\n \"#,\n         );\n     }"}, {"sha": "42f7c4339c7ee20a66e3540a4393e999bf146933", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32424d0aba3f9e20576aff0a1c89e01ac3ad8b62/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=32424d0aba3f9e20576aff0a1c89e01ac3ad8b62", "patch": "@@ -5619,3 +5619,181 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn assoc_fn_in_block_local_impl() {\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) fn foo() {}\n+        }\n+    };\n+}\n+fn test() {\n+    S::foo$0();\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(crate) fn foo()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) fn foo() {}\n+            }\n+        };\n+    };\n+}\n+fn test() {\n+    S::foo$0();\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(crate) fn foo()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(super) fn foo() {}\n+            }\n+        };\n+    }\n+\n+    fn test() {\n+        crate::S::foo$0();\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *foo*\n+\n+            ```rust\n+            test::S\n+            ```\n+\n+            ```rust\n+            pub(super) fn foo()\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn assoc_const_in_block_local_impl() {\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        impl crate::S {\n+            pub(crate) const A: () = ();\n+        }\n+    };\n+}\n+fn test() {\n+    S::A$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(crate) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    const _: () = {\n+        const _: () = {\n+            impl crate::S {\n+                pub(crate) const A: () = ();\n+            }\n+        };\n+    };\n+}\n+fn test() {\n+    S::A$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(crate) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+struct S;\n+mod m {\n+    mod inner {\n+        const _: () = {\n+            impl crate::S {\n+                pub(super) const A: () = ();\n+            }\n+        };\n+    }\n+\n+    fn test() {\n+        crate::S::A$0;\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            *A*\n+\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            pub(super) const A: () = ()\n+            ```\n+        \"#]],\n+    );\n+}"}]}