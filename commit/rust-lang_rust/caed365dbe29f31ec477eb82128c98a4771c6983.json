{"sha": "caed365dbe29f31ec477eb82128c98a4771c6983", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZWQzNjVkYmUyOWYzMWVjNDc3ZWI4MjEyOGM5OGE0NzcxYzY5ODM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T17:31:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-22T17:31:41Z"}, "message": "Refactor drop into its own module and fix Vec", "tree": {"sha": "399e7d3458b3e734e26b1693cbdbf16d5b0199e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/399e7d3458b3e734e26b1693cbdbf16d5b0199e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caed365dbe29f31ec477eb82128c98a4771c6983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caed365dbe29f31ec477eb82128c98a4771c6983", "html_url": "https://github.com/rust-lang/rust/commit/caed365dbe29f31ec477eb82128c98a4771c6983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caed365dbe29f31ec477eb82128c98a4771c6983/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ef0b0de2c8018037d2efcba547bab1b84e25419", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef0b0de2c8018037d2efcba547bab1b84e25419", "html_url": "https://github.com/rust-lang/rust/commit/3ef0b0de2c8018037d2efcba547bab1b84e25419"}], "stats": {"total": 169, "additions": 102, "deletions": 67}, "files": [{"sha": "bc37730b7143896ff0761f2238f38944fb806219", "filename": "src/terminator/drop.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/caed365dbe29f31ec477eb82128c98a4771c6983/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caed365dbe29f31ec477eb82128c98a4771c6983/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=caed365dbe29f31ec477eb82128c98a4771c6983", "patch": "@@ -0,0 +1,82 @@\n+use rustc::mir;\n+use rustc::ty::{self, Ty};\n+use rustc::ty::subst::Kind;\n+use syntax::codemap::Span;\n+\n+use error::EvalResult;\n+use eval_context::{EvalContext, StackPopCleanup};\n+use lvalue::{Lvalue, LvalueExtra};\n+use memory::Pointer;\n+use value::PrimVal;\n+use value::Value;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(crate) fn drop_lvalue(&mut self, lval: Lvalue<'tcx>, instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+        trace!(\"drop_lvalue: {:#?}\", lval);\n+        let val = match self.force_allocation(lval)? {\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Ptr(vtable)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len as u128)),\n+            Lvalue::Ptr { ptr, extra: LvalueExtra::None } => Value::ByVal(PrimVal::Ptr(ptr)),\n+            _ => bug!(\"force_allocation broken\"),\n+        };\n+        self.drop(val, instance, ty, span)\n+    }\n+    pub(crate) fn drop(&mut self, mut arg: Value, mut instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+        trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n+\n+        if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n+            trace!(\"nothing to do, aborting\");\n+            // we don't actually need to drop anything\n+            return Ok(());\n+        }\n+        let mir = match ty.sty {\n+            ty::TyDynamic(..) => {\n+                let vtable = match arg {\n+                    Value::ByValPair(_, PrimVal::Ptr(vtable)) => vtable,\n+                    _ => bug!(\"expected fat ptr, got {:?}\", arg),\n+                };\n+                match self.read_drop_type_from_vtable(vtable)? {\n+                    Some(func) => {\n+                        instance = func;\n+                        self.load_mir(func.def)?\n+                    },\n+                    // no drop fn -> bail out\n+                    None => return Ok(()),\n+                }\n+            },\n+            ty::TyArray(elem, n) => {\n+                instance.substs = self.tcx.mk_substs([\n+                    Kind::from(elem),\n+                ].iter().cloned());\n+                let ptr = match arg {\n+                    Value::ByVal(PrimVal::Ptr(src_ptr)) => src_ptr,\n+                    _ => bug!(\"expected thin ptr, got {:?}\", arg),\n+                };\n+                arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(n as u128));\n+                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+            },\n+            ty::TySlice(elem) => {\n+                instance.substs = self.tcx.mk_substs([\n+                    Kind::from(elem),\n+                ].iter().cloned());\n+                ::eval_context::MirRef::clone(&self.seq_drop_glue)\n+            },\n+            _ => self.load_mir(instance.def)?,\n+        };\n+\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            Lvalue::from_ptr(Pointer::zst_ptr()),\n+            StackPopCleanup::None,\n+        )?;\n+\n+        let mut arg_locals = self.frame().mir.args_iter();\n+        assert_eq!(self.frame().mir.arg_count, 1);\n+        let arg_local = arg_locals.next().unwrap();\n+        let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+        let arg_ty = self.tcx.mk_mut_ptr(ty);\n+        self.write_value(arg, dest, arg_ty)\n+    }\n+}"}, {"sha": "6a615689ae7ed1831009d874f5f4d36d8442acb4", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 20, "deletions": 67, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/caed365dbe29f31ec477eb82128c98a4771c6983/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caed365dbe29f31ec477eb82128c98a4771c6983/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=caed365dbe29f31ec477eb82128c98a4771c6983", "patch": "@@ -2,18 +2,18 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Kind;\n use syntax::codemap::Span;\n use syntax::attr;\n use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n-use lvalue::{Lvalue, LvalueExtra};\n+use lvalue::Lvalue;\n use memory::Pointer;\n use value::PrimVal;\n use value::Value;\n \n+mod drop;\n mod intrinsic;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -79,75 +79,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Drop { ref location, target, .. } => {\n                 trace!(\"TerminatorKind::drop: {:?}, {:?}\", location, self.substs());\n                 let lval = self.eval_lvalue(location)?;\n-                trace!(\"drop lval: {:#?}\", lval);\n                 let ty = self.lvalue_ty(location);\n                 self.goto_block(target);\n-\n                 let ty = ::eval_context::apply_param_substs(self.tcx, self.substs(), &ty);\n \n-                let mut instance = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n-\n-                if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n-                    // we don't actually need to drop anything\n-                    return Ok(());\n-                }\n-                let arg;\n-                let mir = match ty.sty {\n-                    ty::TyDynamic(..) => {\n-                        if let Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } = lval {\n-                            arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Ptr(vtable));\n-                            match self.read_drop_type_from_vtable(vtable)? {\n-                                Some(func) => {\n-                                    instance = func;\n-                                    self.load_mir(func.def)?\n-                                },\n-                                // no drop fn -> bail out\n-                                None => return Ok(()),\n-                            }\n-                        } else {\n-                            panic!(\"expected fat lvalue, got {:?}\", lval);\n-                        }\n-                    },\n-                    ty::TyArray(elem, n) => {\n-                        instance.substs = self.tcx.mk_substs([\n-                            Kind::from(elem),\n-                        ].iter().cloned());\n-                        let src_ptr = self.force_allocation(lval)?.to_ptr();\n-                        arg = Value::ByValPair(PrimVal::Ptr(src_ptr), PrimVal::Bytes(n as u128));\n-                        ::eval_context::MirRef::clone(&self.seq_drop_glue)\n-                    },\n-                    ty::TySlice(elem) => {\n-                        instance.substs = self.tcx.mk_substs([\n-                            Kind::from(elem),\n-                        ].iter().cloned());\n-                        if let Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } = lval {\n-                            arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len as u128));\n-                            ::eval_context::MirRef::clone(&self.seq_drop_glue)\n-                        } else {\n-                            panic!(\"slice without length: {:?}\", lval);\n-                        }\n-                    },\n-                    _ => {\n-                        let src_ptr = self.force_allocation(lval)?.to_ptr();\n-                        arg = Value::ByVal(PrimVal::Ptr(src_ptr));\n-                        self.load_mir(instance.def)?\n-                    },\n-                };\n-\n-                self.push_stack_frame(\n-                    instance,\n-                    terminator.source_info.span,\n-                    mir,\n-                    Lvalue::from_ptr(Pointer::zst_ptr()),\n-                    StackPopCleanup::None,\n-                )?;\n-\n-                let mut arg_locals = self.frame().mir.args_iter();\n-                assert_eq!(self.frame().mir.arg_count, 1);\n-                let arg_local = arg_locals.next().unwrap();\n-                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                let arg_ty = self.tcx.mk_mut_ptr(ty);\n-                self.write_value(arg, dest, arg_ty)?;\n+                let instance = ::eval_context::resolve_drop_in_place(self.tcx, ty);\n+                self.drop_lvalue(lval, instance, ty, terminator.source_info.span)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, .. } => {\n@@ -246,6 +183,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     span,\n                 )\n             },\n+            ty::InstanceDef::DropGlue(..) => {\n+                assert_eq!(arg_operands.len(), 1);\n+                assert_eq!(sig.abi, Abi::Rust);\n+                let val = self.eval_operand(&arg_operands[0])?;\n+                let ty = self.operand_ty(&arg_operands[0]);\n+                let (_, target) = destination.expect(\"diverging drop glue\");\n+                self.goto_block(target);\n+                // FIXME: deduplicate these matches\n+                let pointee_type = match ty.sty {\n+                    ty::TyRawPtr(ref tam) |\n+                    ty::TyRef(_, ref tam) => tam.ty,\n+                    ty::TyAdt(ref def, _) if def.is_box() => ty.boxed_ty(),\n+                    _ => bug!(\"can only deref pointer types\"),\n+                };\n+                self.drop(val, instance, pointee_type, span)\n+            }\n             _ => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", sig.abi))),\n         }\n     }"}]}