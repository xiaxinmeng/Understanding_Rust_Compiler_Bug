{"sha": "70db841aa075aed5b988ff126bf34a1f43b314f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZGI4NDFhYTA3NWFlZDViOTg4ZmYxMjZiZjM0YTFmNDNiMzE0Zjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-18T09:40:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-19T14:39:00Z"}, "message": "split maps into submodules, document", "tree": {"sha": "30eb68ea8c9c1315a9510c55d14ca69c3e5cfffd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30eb68ea8c9c1315a9510c55d14ca69c3e5cfffd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70db841aa075aed5b988ff126bf34a1f43b314f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70db841aa075aed5b988ff126bf34a1f43b314f7", "html_url": "https://github.com/rust-lang/rust/commit/70db841aa075aed5b988ff126bf34a1f43b314f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70db841aa075aed5b988ff126bf34a1f43b314f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76eac36e36e1bb4ce744c2ddd098c2a57b8f05a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/76eac36e36e1bb4ce744c2ddd098c2a57b8f05a3", "html_url": "https://github.com/rust-lang/rust/commit/76eac36e36e1bb4ce744c2ddd098c2a57b8f05a3"}], "stats": {"total": 2638, "additions": 1521, "deletions": 1117}, "files": [{"sha": "99fc94a80f7e39b8eef5b5b591d7321e4c272a4d", "filename": "src/librustc/README.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FREADME.md?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -224,7 +224,10 @@ pointers for understanding them better.\n - MIR -- the **Mid-level IR** that is created after type-checking for use by borrowck and trans.\n   Defined in the `src/librustc/mir/` module, but much of the code that manipulates it is\n   found in `src/librustc_mir`.\n-- obligation -- something that must be proven by the trait system.\n+- obligation -- something that must be proven by the trait system; see `librustc/traits`.\n+- local crate -- the crate currently being compiled.\n+- query -- perhaps some sub-computation during compilation; see `librustc/maps`.\n+- provider -- the function that executes a query; see `librustc/maps`.\n - sess -- the **compiler session**, which stores global data used throughout compilation\n - substs -- the **substitutions** for a given generic type or item\n   (e.g., the `i32, u32` in `HashMap<i32, u32>`)"}, {"sha": "8abc68d431a53df8cd43998af0341025bd03e8d7", "filename": "src/librustc/ty/maps/README.md", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2FREADME.md?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -0,0 +1,302 @@\n+# The Rust Compiler Query System\n+\n+The Compiler Query System is the key to our new demand-driven\n+organization.  The idea is pretty simple. You have various queries\n+that compute things about the input -- for example, there is a query\n+called `type_of(def_id)` that, given the def-id of some item, will\n+compute the type of that item and return it to you.\n+\n+Query execution is **memoized** -- so the first time you invoke a\n+query, it will go do the computation, but the next time, the result is\n+returned from a hashtable. Moreover, query execution fits nicely into\n+**incremental computation**; the idea is roughly that, when you do a\n+query, the result **may** be returned to you by loading stored data\n+from disk (but that's a separate topic we won't discuss further here).\n+\n+The overall vision is that, eventually, the entire compiler\n+control-flow will be query driven. There will effectively be one\n+top-level query (\"compile\") that will run compilation on a crate; this\n+will in turn demand information about that crate, starting from the\n+*end*.  For example:\n+\n+- This \"compile\" query might demand to get a list of codegen-units\n+  (i.e., modules that need to be compiled by LLVM).\n+- But computing the list of codegen-units would invoke some subquery\n+  that returns the list of all modules defined in the Rust source.\n+- That query in turn would invoke something asking for the HIR.\n+- This keeps going further and further back until we wind up doing the\n+  actual parsing.\n+\n+However, that vision is not fully realized. Still, big chunks of the\n+compiler (for example, generating MIR) work exactly like this.\n+\n+### Invoking queries\n+\n+To invoke a query is simple. The tcx (\"type context\") offers a method\n+for each defined query. So, for example, to invoke the `type_of`\n+query, you would just do this:\n+\n+```rust\n+let ty = tcx.type_of(some_def_id);\n+```\n+\n+### Cycles between queries\n+\n+Currently, cycles during query execution should always result in a\n+compilation error. Typically, they arise because of illegal programs\n+that contain cyclic references they shouldn't (though sometimes they\n+arise because of compiler bugs, in which case we need to factor our\n+queries in a more fine-grained fashion to avoid them).\n+\n+However, it is nonetheless often useful to *recover* from a cycle\n+(after reporting an error, say) and try to soldier on, so as to give a\n+better user experience. In order to recover from a cycle, you don't\n+get to use the nice method-call-style syntax. Instead, you invoke\n+using the `try_get` method, which looks roughly like this:\n+\n+```rust\n+use ty::maps::queries;\n+...\n+match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {\n+  Ok(result) => {\n+    // no cycle occurred! You can use `result`\n+  }\n+  Err(err) => {\n+    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,\n+    // meaning essentially an \"in-progress\", not-yet-reported error message.\n+    // See below for more details on what to do here.\n+  }\n+}\n+```\n+\n+So, if you get back an `Err` from `try_get`, then a cycle *did* occur. This means that\n+you must ensure that a compiler error message is reported. You can do that in two ways:\n+\n+The simplest is to invoke `err.emit()`. This will emit the cycle error to the user.\n+\n+However, often cycles happen because of an illegal program, and you\n+know at that point that an error either already has been reported or\n+will be reported due to this cycle by some other bit of code. In that\n+case, you can invoke `err.cancel()` to not emit any error. It is\n+traditional to then invoke:\n+\n+```\n+tcx.sess.delay_span_bug(some_span, \"some message\")\n+```\n+\n+`delay_span_bug()` is a helper that says: we expect a compilation\n+error to have happened or to happen in the future; so, if compilation\n+ultimately succeeds, make an ICE with the message `\"some\n+message\"`. This is basically just a precaution in case you are wrong.\n+\n+### How the compiler executes a query\n+\n+So you may be wondering what happens when you invoke a query\n+method. The answer is that, for each query, the compiler maintains a\n+cache -- if your query has already been executed, then, the answer is\n+simple: we clone the return value out of the cache and return it\n+(therefore, you should try to ensure that the return types of queries\n+are cheaply cloneable; insert a `Rc` if necessary).\n+\n+#### Providers\n+\n+If, however, the query is *not* in the cache, then the compiler will\n+try to find a suitable **provider**. A provider is a function that has\n+been defined and linked into the compiler somewhere that contains the\n+code to compute the result of the query.\n+\n+**Providers are defined per-crate.** The compiler maintains,\n+internally, a table of providers for every crate, at least\n+conceptually. Right now, there are really two sets: the providers for\n+queries about the **local crate** (that is, the one being compiled)\n+and providers for queries about **external crates** (that is,\n+dependencies of the local crate). Note that what determines the crate\n+that a query is targeting is not the *kind* of query, but the *key*.\n+For example, when you invoke `tcx.type_of(def_id)`, that could be a\n+local query or an external query, depending on what crate the `def_id`\n+is referring to (see the `self::keys::Key` trait for more information\n+on how that works).\n+\n+Providers always have the same signature:\n+\n+```rust\n+fn provider<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n+                       key: QUERY_KEY)\n+                       -> QUERY_RESULT\n+{\n+    ...\n+}\n+```\n+\n+Providers take two arguments: the `tcx` and the query key. Note also\n+that they take the *global* tcx (i.e., they use the `'tcx` lifetime\n+twice), rather than taking a tcx with some active inference context.\n+They return the result of the query.\n+\n+####  How providers are setup\n+\n+When the tcx is created, it is given the providers by its creator using\n+the `Providers` struct. This struct is generate by the macros here, but it\n+is basically a big list of function pointers:\n+\n+```rust\n+struct Providers {\n+    type_of: for<'cx, 'tcx> fn(TyCtxt<'cx, 'tcx, 'tcx>, DefId) -> Ty<'tcx>,\n+    ...\n+}\n+```\n+\n+At present, we have one copy of the struct for local crates, and one\n+for external crates, though the plan is that we may eventually have\n+one per crate.\n+\n+These `Provider` structs are ultimately created and populated by\n+`librustc_driver`, but it does this by distributing the work\n+throughout the other `rustc_*` crates. This is done by invoking\n+various `provide` functions. These functions tend to look something\n+like this:\n+\n+```rust\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        type_of,\n+        ..*providers\n+    };\n+}\n+```\n+\n+That is, they take an `&mut Providers` and mutate it in place. Usually\n+we use the formulation above just because it looks nice, but you could\n+as well do `providers.type_of = type_of`, which would be equivalent.\n+(Here, `type_of` would be a top-level function, defined as we saw\n+before.) So, if we wanted to have add a provider for some other query,\n+let's call it `fubar`, into the crate above, we might modify the `provide()`\n+function like so:\n+\n+```rust\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        type_of,\n+        fubar,\n+        ..*providers\n+    };\n+}\n+\n+fn fubar<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>, key: DefId) -> Fubar<'tcx> { .. }\n+```\n+\n+NB. Most of the `rustc_*` crate only provide **local\n+providers**. Almost all **extern providers** wind up going through the\n+`rustc_metadata` crate, which loads the information from the crate\n+metadata.  But in some cases there are crates that provide queries for\n+*both* local and external crates, in which case they define both a\n+`provide` and a `provide_extern` function that `rustc_driver` can\n+invoke.\n+\n+### Adding a new kind of query\n+\n+So suppose you want to add a new kind of query, how do you do so?\n+Well, defining a query takes place in two steps:\n+\n+1. first, you have to specify the query name and arguments; and then,\n+2. you have to supply query providers where needed.\n+\n+The specify the query name and arguments, you simply add an entry\n+to the big macro invocation in `mod.rs`. This will probably have changed\n+by the time you read this README, but at present it looks something\n+like:\n+\n+```\n+define_maps! { <'tcx>\n+    /// Records the type of every item.\n+    [] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+\n+    ...\n+}\n+```\n+\n+Each line of the macro defines one query. The name is broken up like this:\n+\n+```\n+[] fn type_of: TypeOfItem(DefId) -> Ty<'tcx>,\n+^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^\n+|     |        |          |         |\n+|     |        |          |         result type of query\n+|     |        |          query key type\n+|     |        dep-node constructor\n+|     name of query\n+query flags\n+```\n+\n+Let's go over them one by one:\n+\n+- **Query flags:** these are largely unused right now, but the intention\n+  is that we'll be able to customize various aspects of how the query is\n+  processed.\n+- **Name of query:** the name of the query method\n+  (`tcx.type_of(..)`). Also used as the name of a struct\n+  (`ty::maps::queries::type_of`) that will be generated to represent\n+  this query.\n+- **Dep-node constructor:** indicates the constructor function that\n+  connects this query to incremental compilation. Typically, this is a\n+  `DepNode` variant, which can be added by modifying the\n+  `define_dep_nodes!` macro invocation in\n+  `librustc/dep_graph/dep_node.rs`.\n+  - However, sometimes we use a custom function, in which case the\n+    name will be in snake case and the function will be defined at the\n+    bottom of the file. This is typically used when the query key is\n+    not a def-id, or just not the type that the dep-node expects.\n+- **Query key type:** the type of the argument to this query.\n+  This type must implement the `ty::maps::keys::Key` trait, which\n+  defines (for example) how to map it to a crate, and so forth.\n+- **Result type of query:** the type produced by this query. This type\n+  should (a) not use `RefCell` or other interior mutability and (b) be\n+  cheaply cloneable. Interning or using `Rc` or `Arc` is recommended for\n+  non-trivial data types.\n+  - The one exception to those rules is the `ty::steal::Steal` type,\n+    which is used to cheaply modify MIR in place. See the definition\n+    of `Steal` for more details. New uses of `Steal` should **not** be\n+    added without alerting `@rust-lang/compiler`.\n+\n+So, to add a query:\n+\n+- Add an entry to `define_maps!` using the format above.\n+- Possibly add a corresponding entry to the dep-node macro.\n+- Link the provider by modifying the appropriate `provide` method;\n+  or add a new one if needed and ensure that `rustc_driver` is invoking it.\n+\n+#### Query structs and descriptions\n+\n+For each kind, the `define_maps` macro will generate a \"query struct\"\n+named after the query. This struct is a kind of a place-holder\n+describing the query. Each such struct implements the\n+`self::config::QueryConfig` trait, which has associated types for the\n+key/value of that particular query. Basically the code generated looks something\n+like this:\n+\n+```rust\n+// Dummy struct representing a particular kind of query:\n+pub struct type_of<'tcx> { phantom: PhantomData<&'tcx ()> }\n+\n+impl<'tcx> QueryConfig for type_of<'tcx> {\n+  type Key = DefId;\n+  type Value = Ty<'tcx>;\n+}\n+```\n+\n+There is an additional trait that you may wish to implement called\n+`self::config::QueryDescription`. This trait is used during cycle\n+errors to give a \"human readable\" name for the query, so that we can\n+summarize what was happening when the cycle occurred. Implementing\n+this trait is optional if the query key is `DefId`, but if you *don't*\n+implement it, you get a pretty generic error (\"processing `foo`...\").\n+You can put new impls into the `config` module. They look something like this:\n+\n+```rust\n+impl<'tcx> QueryDescription for queries::type_of<'tcx> {\n+    fn describe(tcx: TyCtxt, key: DefId) -> String {\n+        format!(\"computing the type of `{}`\", tcx.item_path_str(key))\n+    }\n+}\n+```\n+"}, {"sha": "461b81a5c055f0f7acb2bdeee72a76817c456524", "filename": "src/librustc/ty/maps/config.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -0,0 +1,492 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n+use ty::{self, Ty, TyCtxt};\n+use ty::maps::queries;\n+use ty::subst::Substs;\n+\n+use std::hash::Hash;\n+use syntax_pos::symbol::InternedString;\n+\n+/// Query configuration and description traits.\n+\n+pub trait QueryConfig {\n+    type Key: Eq + Hash + Clone;\n+    type Value;\n+}\n+\n+pub(super) trait QueryDescription: QueryConfig {\n+    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n+}\n+\n+impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n+    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Copy`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is `Sized`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` is freeze\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` needs drop\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing layout of `{}`\", env.value)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"computing the supertraits of `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        format!(\"computing the bounds for type parameter `{}`\",\n+                tcx.hir.ty_param_name(id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n+    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n+        format!(\"coherence checking all impls of trait `{}`\",\n+                tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+    fn describe(_: TyCtxt, k: CrateNum) -> String {\n+        format!(\"all inherent impls defined in crate `{:?}`\", k)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"check for overlap between inherent impls defined in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the variances for items in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n+    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n+        format!(\"generating MIR shim for `{}`\",\n+                tcx.item_path_str(def.def_id()))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"privacy access levels\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"type-checking all item bodies\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"reachability\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n+        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        format!(\"getting a list of all mir_keys\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n+        format!(\"computing the symbol for `{}`\", instance)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"describe_def\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"def_span\")\n+    }\n+}\n+\n+\n+impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"stability\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"deprecation\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::item_attrs<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"item_attrs\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_exported_symbol<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"is_exported_symbol\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::fn_arg_names<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"fn_arg_names\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::impl_parent<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"impl_parent\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::trait_of_item<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        bug!(\"trait_of_item\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"const checking if rvalue is promotable to static `{}`\",\n+            tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking if item is mir available: `{}`\",\n+            tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"dylib dependency formats of crate\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate is_panic_runtime\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate is_compiler_builtins\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n+    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+        \"checking if the crate has_global_allocator\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n+        \"getting crate's ExternCrateData\".to_string()\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"computing the lint levels for items in this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n+        format!(\"computing whether impls specialize one another\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"traits in scope at a block\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"test whether a crate has #![no_builtins]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate's configured panic strategy\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![profiler_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"query a crate is #![sanitizer_runtime]\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the exported symbols of a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the native libraries of a linked crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the plugin registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the derive registrar for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the disambiguator a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the hash a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up the original name a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n+        format!(\"looking up implementations of a trait in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all (?) trait implementations\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up link arguments for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up a named region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"testing if a region is late boudn\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n+        format!(\"looking up lifetime defaults for a region\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a dependency looks like\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching what a crate is named\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the lang items defined in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the missing lang items in a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the visible parent map\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking at the source for a crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"generating a postorder list of CrateNums\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"looking up all possibly unused extern crates\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the stability index for the local crate\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"fetching all foreign CrateNum instances\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"exported_symbols\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"collect_and_partition_translation_items\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n+        format!(\"compile_codegen_unit\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"output_filenames\")\n+    }\n+}"}, {"sha": "e37cf6697978196c5b2c4fb0c8fbcb2429156675", "filename": "src/librustc/ty/maps/keys.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fkeys.rs?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Defines the set of legal keys that can be used in queries.\n+\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use mir::transform::{MirSuite, MirPassIndex};\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::Substs;\n+use ty::fast_reject::SimplifiedType;\n+\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::symbol::InternedString;\n+\n+/// The `Key` trait controls what types can legally be used as the key\n+/// for a query.\n+pub trait Key: Clone + Hash + Eq + Debug {\n+    /// Given an instance of this key, what crate is it referring to?\n+    /// This is used to find the provider.\n+    fn map_crate(&self) -> CrateNum;\n+\n+    /// In the event that a cycle occurs, if no explicit span has been\n+    /// given for a query with key `self`, what span should we use?\n+    fn default_span(&self, tcx: TyCtxt) -> Span;\n+}\n+\n+impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n+impl<'tcx> Key for ty::Instance<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(self.def_id())\n+    }\n+}\n+\n+impl Key for CrateNum {\n+    fn map_crate(&self) -> CrateNum {\n+        *self\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl Key for DefIndex {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl Key for DefId {\n+    fn map_crate(&self) -> CrateNum {\n+        self.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        tcx.def_span(*self)\n+    }\n+}\n+\n+impl Key for (DefId, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (CrateNum, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (DefId, SimplifiedType) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n+impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.1.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n+impl Key for (MirSuite, MirPassIndex, DefId) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.2.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.2.default_span(tcx)\n+    }\n+}\n+\n+impl<'tcx> Key for Ty<'tcx> {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    fn map_crate(&self) -> CrateNum {\n+        self.value.map_crate()\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.value.default_span(tcx)\n+    }\n+}\n+\n+impl Key for InternedString {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "c08ad68eddd06b1eab5683af66116a416ea3bfc4", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 18, "deletions": 1116, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n-use errors::{Diagnostic, DiagnosticBuilder};\n-use hir::def_id::{CrateNum, DefId, LOCAL_CRATE, DefIndex};\n+use dep_graph::{DepConstructor, DepNode};\n+use errors::DiagnosticBuilder;\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::def::{Def, Export};\n use hir::{self, TraitCandidate, ItemLocalId};\n use hir::svh::Svh;\n@@ -28,29 +28,22 @@ use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::SymbolExportLevel;\n use middle::trans::{CodegenUnit, Stats};\n use mir;\n-use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n use session::config::OutputFilenames;\n use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::layout::{Layout, LayoutError};\n-use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n-use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, DefIdMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use std::cell::{RefCell, RefMut, Cell};\n+use std::cell::{RefCell, Cell};\n \n-use std::fmt::Debug;\n-use std::hash::Hash;\n-use std::marker::PhantomData;\n-use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -60,1114 +53,19 @@ use syntax::attr;\n use syntax::ast;\n use syntax::symbol::Symbol;\n \n-pub trait Key: Clone + Hash + Eq + Debug {\n-    fn map_crate(&self) -> CrateNum;\n-    fn default_span(&self, tcx: TyCtxt) -> Span;\n-}\n-\n-impl<'tcx> Key for ty::InstanceDef<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(self.def_id())\n-    }\n-}\n-\n-impl<'tcx> Key for ty::Instance<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(self.def_id())\n-    }\n-}\n-\n-impl Key for CrateNum {\n-    fn map_crate(&self) -> CrateNum {\n-        *self\n-    }\n-    fn default_span(&self, _: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl Key for DefIndex {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl Key for DefId {\n-    fn map_crate(&self) -> CrateNum {\n-        self.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        tcx.def_span(*self)\n-    }\n-}\n-\n-impl Key for (DefId, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (CrateNum, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (DefId, SimplifiedType) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.0.default_span(tcx)\n-    }\n-}\n-\n-impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.0.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (MirSuite, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.1.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.1.default_span(tcx)\n-    }\n-}\n-\n-impl Key for (MirSuite, MirPassIndex, DefId) {\n-    fn map_crate(&self) -> CrateNum {\n-        self.2.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.2.default_span(tcx)\n-    }\n-}\n-\n-impl<'tcx> Key for Ty<'tcx> {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n-    fn map_crate(&self) -> CrateNum {\n-        self.value.map_crate()\n-    }\n-    fn default_span(&self, tcx: TyCtxt) -> Span {\n-        self.value.default_span(tcx)\n-    }\n-}\n-\n-impl Key for InternedString {\n-    fn map_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n-    }\n-    fn default_span(&self, _tcx: TyCtxt) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-trait Value<'tcx>: Sized {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx, T> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n-        tcx.sess.abort_if_errors();\n-        bug!(\"Value::from_cycle_error called without errors\");\n-    }\n-}\n-\n-impl<'tcx, T: Default> Value<'tcx> for T {\n-    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n-        T::default()\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for Ty<'tcx> {\n-    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        tcx.types.err\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        Self::empty()\n-    }\n-}\n-\n-impl<'tcx> Value<'tcx> for ty::SymbolName {\n-    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n-    }\n-}\n-\n-struct QueryMap<D: QueryDescription> {\n-    phantom: PhantomData<D>,\n-    map: FxHashMap<D::Key, QueryValue<D::Value>>,\n-}\n-\n-struct QueryValue<T> {\n-    value: T,\n-    index: DepNodeIndex,\n-    diagnostics: Option<Box<QueryDiagnostics>>,\n-}\n-\n-struct QueryDiagnostics {\n-    diagnostics: Vec<Diagnostic>,\n-    emitted_diagnostics: Cell<bool>,\n-}\n-\n-impl<M: QueryDescription> QueryMap<M> {\n-    fn new() -> QueryMap<M> {\n-        QueryMap {\n-            phantom: PhantomData,\n-            map: FxHashMap(),\n-        }\n-    }\n-}\n-\n-struct CycleError<'a, 'tcx: 'a> {\n-    span: Span,\n-    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    fn report_cycle(self, CycleError { span, cycle }: CycleError)\n-        -> DiagnosticBuilder<'a>\n-    {\n-        // Subtle: release the refcell lock before invoking `describe()`\n-        // below by dropping `cycle`.\n-        let stack = cycle.to_vec();\n-        mem::drop(cycle);\n-\n-        assert!(!stack.is_empty());\n-\n-        // Disable naming impls with types in this path, since that\n-        // sometimes cycles itself, leading to extra cycle errors.\n-        // (And cycle errors around impls tend to occur during the\n-        // collect/coherence phases anyhow.)\n-        item_path::with_forced_impl_filename_line(|| {\n-            let mut err =\n-                struct_span_err!(self.sess, span, E0391,\n-                                 \"unsupported cyclic reference between types/traits detected\");\n-            err.span_label(span, \"cyclic reference\");\n-\n-            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n-                                               stack[0].1.describe(self)));\n-\n-            for &(span, ref query) in &stack[1..] {\n-                err.span_note(span, &format!(\"...which then requires {}...\",\n-                                             query.describe(self)));\n-            }\n-\n-            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n-                              stack[0].1.describe(self)));\n-\n-            return err\n-        })\n-    }\n-\n-    fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n-                         -> Result<R, CycleError<'a, 'gcx>>\n-        where F: FnOnce() -> R\n-    {\n-        {\n-            let mut stack = self.maps.query_stack.borrow_mut();\n-            if let Some((i, _)) = stack.iter().enumerate().rev()\n-                                       .find(|&(_, &(_, ref q))| *q == query) {\n-                return Err(CycleError {\n-                    span,\n-                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n-                });\n-            }\n-            stack.push((span, query));\n-        }\n-\n-        let result = compute();\n-\n-        self.maps.query_stack.borrow_mut().pop();\n-\n-        Ok(result)\n-    }\n-}\n-\n-pub trait QueryConfig {\n-    type Key: Eq + Hash + Clone;\n-    type Value;\n-}\n-\n-trait QueryDescription: QueryConfig {\n-    fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n-}\n-\n-impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n-    default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"processing `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Copy`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is `Sized`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` is freeze\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing whether `{}` needs drop\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n-    fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n-        format!(\"computing layout of `{}`\", env.value)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"computing the supertraits of `{}`\",\n-                tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n-    fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n-        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        format!(\"computing the bounds for type parameter `{}`\",\n-                tcx.hir.ty_param_name(id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n-    fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n-        format!(\"coherence checking all impls of trait `{}`\",\n-                tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n-    fn describe(_: TyCtxt, k: CrateNum) -> String {\n-        format!(\"all inherent impls defined in crate `{:?}`\", k)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"check for overlap between inherent impls defined in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"computing the variances for items in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n-    fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n-        format!(\"generating MIR shim for `{}`\",\n-                tcx.item_path_str(def.def_id()))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"privacy access levels\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"type-checking all item bodies\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"reachability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n-    fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n-        format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"getting a list of all mir_keys\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n-        format!(\"computing the symbol for `{}`\", instance)\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"describe_def\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"def_span\")\n-    }\n-}\n-\n-\n-impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"stability\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"deprecation\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::item_attrs<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"item_attrs\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_exported_symbol<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"is_exported_symbol\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::fn_arg_names<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"fn_arg_names\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::impl_parent<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"impl_parent\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::trait_of_item<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        bug!(\"trait_of_item\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"const checking if rvalue is promotable to static `{}`\",\n-            tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"checking if item is mir available: `{}`\",\n-            tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"dylib dependency formats of crate\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate is_panic_runtime\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate is_compiler_builtins\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        \"checking if the crate has_global_allocator\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt, _: DefId) -> String {\n-        \"getting crate's ExternCrateData\".to_string()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"computing the lint levels for items in this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n-        format!(\"computing whether impls specialize one another\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"traits in scope at a block\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"test whether a crate has #![no_builtins]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate's configured panic strategy\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate is #![profiler_runtime]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"query a crate is #![sanitizer_runtime]\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the exported symbols of a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the native libraries of a linked crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the plugin registrar for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the derive registrar for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the disambiguator a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the hash a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up the original name a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n-        format!(\"looking up implementations of a trait in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up all (?) trait implementations\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up link arguments for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"looking up a named region\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"testing if a region is late boudn\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n-        format!(\"looking up lifetime defaults for a region\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching what a dependency looks like\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching what a crate is named\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the lang items map\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the lang items defined in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the missing lang items in a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the visible parent map\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if we're missing an `extern crate` item for this crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking at the source for a crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"generating a postorder list of CrateNums\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"looking up all possibly unused extern crates\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"calculating the stability index for the local crate\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"fetching all foreign CrateNum instances\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"exported_symbols\")\n-    }\n-}\n-\n-impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"collect_and_partition_translation_items\")\n-    }\n-}\n+#[macro_use]\n+mod plumbing;\n+use self::plumbing::*;\n \n-impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n-        format!(\"codegen_unit\")\n-    }\n-}\n+mod keys;\n+pub use self::keys::Key;\n \n-impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n-        format!(\"compile_codegen_unit\")\n-    }\n-}\n+mod values;\n+use self::values::Value;\n \n-impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"output_filenames\")\n-    }\n-}\n-\n-// If enabled, send a message to the profile-queries thread\n-macro_rules! profq_msg {\n-    ($tcx:expr, $msg:expr) => {\n-        if cfg!(debug_assertions) {\n-            if  $tcx.sess.profile_queries() {\n-                profq_msg($msg)\n-            }\n-        }\n-    }\n-}\n-\n-// If enabled, format a key using its debug string, which can be\n-// expensive to compute (in terms of time).\n-macro_rules! profq_key {\n-    ($tcx:expr, $key:expr) => {\n-        if cfg!(debug_assertions) {\n-            if $tcx.sess.profile_queries_and_keys() {\n-                Some(format!(\"{:?}\", $key))\n-            } else { None }\n-        } else { None }\n-    }\n-}\n-\n-macro_rules! define_maps {\n-    (<$tcx:tt>\n-     $($(#[$attr:meta])*\n-       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n-        }\n-\n-        impl<$tcx> Maps<$tcx> {\n-            pub fn new(providers: IndexVec<CrateNum, Providers<$tcx>>)\n-                       -> Self {\n-                Maps {\n-                    providers,\n-                    query_stack: RefCell::new(vec![]),\n-                    $($name: RefCell::new(QueryMap::new())),*\n-                }\n-            }\n-        }\n-\n-        #[allow(bad_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-        pub enum Query<$tcx> {\n-            $($(#[$attr])* $name($K)),*\n-        }\n-\n-        #[allow(bad_style)]\n-        #[derive(Clone, Debug, PartialEq, Eq)]\n-        pub enum QueryMsg {\n-            $($name(Option<String>)),*\n-        }\n-\n-        impl<$tcx> Query<$tcx> {\n-            pub fn describe(&self, tcx: TyCtxt) -> String {\n-                let (r, name) = match *self {\n-                    $(Query::$name(key) => {\n-                        (queries::$name::describe(tcx, key), stringify!($name))\n-                    })*\n-                };\n-                if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", r, name)\n-                } else {\n-                    r\n-                }\n-            }\n-        }\n-\n-        pub mod queries {\n-            use std::marker::PhantomData;\n-\n-            $(#[allow(bad_style)]\n-            pub struct $name<$tcx> {\n-                data: PhantomData<&$tcx ()>\n-            })*\n-        }\n-\n-        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n-            type Key = $K;\n-            type Value = $V;\n-        }\n-\n-        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n-            #[allow(unused)]\n-            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n-                use dep_graph::DepConstructor::*;\n-\n-                DepNode::new(tcx, $node(*key))\n-            }\n-\n-            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                                  mut span: Span,\n-                                  key: $K,\n-                                  f: F)\n-                                  -> Result<R, CycleError<'a, $tcx>>\n-                where F: FnOnce(&$V) -> R\n-            {\n-                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n-                       stringify!($name),\n-                       key,\n-                       span);\n-\n-                profq_msg!(tcx,\n-                    ProfileQueriesMsg::QueryBegin(\n-                        span.clone(),\n-                        QueryMsg::$name(profq_key!(tcx, key))\n-                    )\n-                );\n-\n-                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n-                    if let Some(ref d) = value.diagnostics {\n-                        if !d.emitted_diagnostics.get() {\n-                            d.emitted_diagnostics.set(true);\n-                            let handle = tcx.sess.diagnostic();\n-                            for diagnostic in d.diagnostics.iter() {\n-                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n-                                    .emit();\n-                            }\n-                        }\n-                    }\n-                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                    tcx.dep_graph.read_index(value.index);\n-                    return Ok(f(&value.value));\n-                }\n-                // else, we are going to run the provider:\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n-\n-                // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necessary to prevent a recursive loop,\n-                // default_span calls def_span query internally.\n-                if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n-                    span = key.default_span(tcx)\n-                }\n-\n-                let dep_node = Self::to_dep_node(tcx, &key);\n-                let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        if dep_node.kind.is_anon() {\n-                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n-                            })\n-                        } else {\n-                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n-                                                            key: $K)\n-                                                            -> $V {\n-                                let provider = tcx.maps.providers[key.map_crate()].$name;\n-                                provider(tcx.global_tcx(), key)\n-                            }\n-\n-                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n-                        }\n-                    })\n-                })?;\n-                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n-                let ((result, dep_node_index), diagnostics) = res;\n-\n-                tcx.dep_graph.read_index(dep_node_index);\n-\n-                let value = QueryValue {\n-                    value: result,\n-                    index: dep_node_index,\n-                    diagnostics: if diagnostics.len() == 0 {\n-                        None\n-                    } else {\n-                        Some(Box::new(QueryDiagnostics {\n-                            diagnostics,\n-                            emitted_diagnostics: Cell::new(true),\n-                        }))\n-                    },\n-                };\n-\n-                Ok(f(&tcx.maps\n-                         .$name\n-                         .borrow_mut()\n-                         .map\n-                         .entry(key)\n-                         .or_insert(value)\n-                         .value))\n-            }\n-\n-            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n-                           -> Result<$V, DiagnosticBuilder<'a>> {\n-                match Self::try_get_with(tcx, span, key, Clone::clone) {\n-                    Ok(e) => Ok(e),\n-                    Err(e) => Err(tcx.report_cycle(e)),\n-                }\n-            }\n-\n-            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n-                // Ignore dependencies, since we not reading the computed value\n-                let _task = tcx.dep_graph.in_ignore();\n-\n-                match Self::try_get_with(tcx, span, key, |_| ()) {\n-                    Ok(()) => {}\n-                    Err(e) => tcx.report_cycle(e).emit(),\n-                }\n-            }\n-        })*\n-\n-        #[derive(Copy, Clone)]\n-        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-            pub span: Span,\n-        }\n-\n-        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n-            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n-            fn deref(&self) -> &Self::Target {\n-                &self.tcx\n-            }\n-        }\n-\n-        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n-            /// Return a transparent wrapper for `TyCtxt` which uses\n-            /// `span` as the location of queries performed through it.\n-            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n-                TyCtxtAt {\n-                    tcx: self,\n-                    span\n-                }\n-            }\n-\n-            $($(#[$attr])*\n-            pub fn $name(self, key: $K) -> $V {\n-                self.at(DUMMY_SP).$name(key)\n-            })*\n-        }\n-\n-        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n-            $($(#[$attr])*\n-            pub fn $name(self, key: $K) -> $V {\n-                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n-                    e.emit();\n-                    Value::from_cycle_error(self.global_tcx())\n-                })\n-            })*\n-        }\n-\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n-            output: ()\n-        }\n-\n-        impl<$tcx> Copy for Providers<$tcx> {}\n-        impl<$tcx> Clone for Providers<$tcx> {\n-            fn clone(&self) -> Self { *self }\n-        }\n-    }\n-}\n-\n-macro_rules! define_map_struct {\n-    // Initial state\n-    (tcx: $tcx:tt,\n-     input: $input:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final output\n-    (tcx: $tcx:tt,\n-     input: (),\n-     output: ($($output:tt)*)) => {\n-        pub struct Maps<$tcx> {\n-            providers: IndexVec<CrateNum, Providers<$tcx>>,\n-            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($output)*\n-        }\n-    };\n-\n-    // Field recognized and ready to shift into the output\n-    (tcx: $tcx:tt,\n-     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)*\n-                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n-        }\n-    };\n-\n-    // No modifiers left? This is a private item.\n-    (tcx: $tcx:tt,\n-     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            ready: ([] $attrs $name),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip other modifiers\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_map_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n-}\n-\n-macro_rules! define_provider_struct {\n-    // Initial state:\n-    (tcx: $tcx:tt, input: $input:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ()\n-        }\n-    };\n-\n-    // Final state:\n-    (tcx: $tcx:tt,\n-     input: (),\n-     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n-        pub struct Providers<$tcx> {\n-            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n-        }\n-\n-        impl<$tcx> Default for Providers<$tcx> {\n-            fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n-                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n-                         stringify!($name), key);\n-                })*\n-                Providers { $($name),* }\n-            }\n-        }\n-    };\n-\n-    // Something ready to shift:\n-    (tcx: $tcx:tt,\n-     ready: ($name:tt $K:tt $V:tt),\n-     input: $input:tt,\n-     output: ($($output:tt)*)) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: $input,\n-            output: ($($output)* ($name $K $V))\n-        }\n-    };\n-\n-    // Regular queries produce a `V` only.\n-    (tcx: $tcx:tt,\n-     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            ready: ($name $K $V),\n-            input: ($($input)*),\n-            output: $output\n-        }\n-    };\n-\n-    // Skip modifiers.\n-    (tcx: $tcx:tt,\n-     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n-     output: $output:tt) => {\n-        define_provider_struct! {\n-            tcx: $tcx,\n-            input: (([$($modifiers)*] $($fields)*) $($input)*),\n-            output: $output\n-        }\n-    };\n-}\n+mod config;\n+pub use self::config::QueryConfig;\n+use self::config::QueryDescription;\n \n // Each of these maps also corresponds to a method on a\n // `Provider` trait for requesting a value of that type,\n@@ -1430,6 +328,10 @@ define_maps! { <'tcx>\n         -> Arc<OutputFilenames>,\n }\n \n+//////////////////////////////////////////////////////////////////////\n+// These functions are little shims used to find the dep-node for a\n+// given query when there is not a *direct* mapping:\n+\n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::TypeParamPredicates {\n         item_id,"}, {"sha": "87a9eef0de5329fe99f80db7d903e7eecf5e2848", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -0,0 +1,494 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The implementation of the query system itself. Defines the macros\n+//! that generate the actual methods on tcx which find and execute the\n+//! provider, manage the caches, and so forth.\n+\n+use dep_graph::{DepNodeIndex};\n+use errors::{Diagnostic, DiagnosticBuilder};\n+use ty::{TyCtxt};\n+use ty::maps::Query; // NB: actually generated by the macros in this file\n+use ty::maps::config::QueryDescription;\n+use ty::item_path;\n+\n+use rustc_data_structures::fx::{FxHashMap};\n+use std::cell::{RefMut, Cell};\n+use std::marker::PhantomData;\n+use std::mem;\n+use syntax_pos::Span;\n+\n+pub(super) struct QueryMap<D: QueryDescription> {\n+    phantom: PhantomData<D>,\n+    pub(super) map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+}\n+\n+pub(super) struct QueryValue<T> {\n+    pub(super) value: T,\n+    pub(super) index: DepNodeIndex,\n+    pub(super) diagnostics: Option<Box<QueryDiagnostics>>,\n+}\n+\n+pub(super) struct QueryDiagnostics {\n+    pub(super) diagnostics: Vec<Diagnostic>,\n+    pub(super) emitted_diagnostics: Cell<bool>,\n+}\n+\n+impl<M: QueryDescription> QueryMap<M> {\n+    pub(super) fn new() -> QueryMap<M> {\n+        QueryMap {\n+            phantom: PhantomData,\n+            map: FxHashMap(),\n+        }\n+    }\n+}\n+\n+pub(super) struct CycleError<'a, 'tcx: 'a> {\n+    span: Span,\n+    cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn report_cycle(self, CycleError { span, cycle }: CycleError)\n+        -> DiagnosticBuilder<'a>\n+    {\n+        // Subtle: release the refcell lock before invoking `describe()`\n+        // below by dropping `cycle`.\n+        let stack = cycle.to_vec();\n+        mem::drop(cycle);\n+\n+        assert!(!stack.is_empty());\n+\n+        // Disable naming impls with types in this path, since that\n+        // sometimes cycles itself, leading to extra cycle errors.\n+        // (And cycle errors around impls tend to occur during the\n+        // collect/coherence phases anyhow.)\n+        item_path::with_forced_impl_filename_line(|| {\n+            let mut err =\n+                struct_span_err!(self.sess, span, E0391,\n+                                 \"unsupported cyclic reference between types/traits detected\");\n+            err.span_label(span, \"cyclic reference\");\n+\n+            err.span_note(stack[0].0, &format!(\"the cycle begins when {}...\",\n+                                               stack[0].1.describe(self)));\n+\n+            for &(span, ref query) in &stack[1..] {\n+                err.span_note(span, &format!(\"...which then requires {}...\",\n+                                             query.describe(self)));\n+            }\n+\n+            err.note(&format!(\"...which then again requires {}, completing the cycle.\",\n+                              stack[0].1.describe(self)));\n+\n+            return err\n+        })\n+    }\n+\n+    pub(super) fn cycle_check<F, R>(self, span: Span, query: Query<'gcx>, compute: F)\n+                                    -> Result<R, CycleError<'a, 'gcx>>\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.maps.query_stack.borrow_mut();\n+            if let Some((i, _)) = stack.iter().enumerate().rev()\n+                                       .find(|&(_, &(_, ref q))| *q == query) {\n+                return Err(CycleError {\n+                    span,\n+                    cycle: RefMut::map(stack, |stack| &mut stack[i..])\n+                });\n+            }\n+            stack.push((span, query));\n+        }\n+\n+        let result = compute();\n+\n+        self.maps.query_stack.borrow_mut().pop();\n+\n+        Ok(result)\n+    }\n+}\n+\n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if  $tcx.sess.profile_queries() {\n+                profq_msg($msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n+macro_rules! define_maps {\n+    (<$tcx:tt>\n+     $($(#[$attr:meta])*\n+       [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n+        }\n+\n+        impl<$tcx> Maps<$tcx> {\n+            pub fn new(providers: IndexVec<CrateNum, Providers<$tcx>>)\n+                       -> Self {\n+                Maps {\n+                    providers,\n+                    query_stack: RefCell::new(vec![]),\n+                    $($name: RefCell::new(QueryMap::new())),*\n+                }\n+            }\n+        }\n+\n+        #[allow(bad_style)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        pub enum Query<$tcx> {\n+            $($(#[$attr])* $name($K)),*\n+        }\n+\n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(Option<String>)),*\n+        }\n+\n+        impl<$tcx> Query<$tcx> {\n+            pub fn describe(&self, tcx: TyCtxt) -> String {\n+                let (r, name) = match *self {\n+                    $(Query::$name(key) => {\n+                        (queries::$name::describe(tcx, key), stringify!($name))\n+                    })*\n+                };\n+                if tcx.sess.verbose() {\n+                    format!(\"{} [{}]\", r, name)\n+                } else {\n+                    r\n+                }\n+            }\n+        }\n+\n+        pub mod queries {\n+            use std::marker::PhantomData;\n+\n+            $(#[allow(bad_style)]\n+            pub struct $name<$tcx> {\n+                data: PhantomData<&$tcx ()>\n+            })*\n+        }\n+\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n+            type Key = $K;\n+            type Value = $V;\n+        }\n+\n+        impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n+            #[allow(unused)]\n+            fn to_dep_node(tcx: TyCtxt<'a, $tcx, 'lcx>, key: &$K) -> DepNode {\n+                use dep_graph::DepConstructor::*;\n+\n+                DepNode::new(tcx, $node(*key))\n+            }\n+\n+            fn try_get_with<F, R>(tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                                  mut span: Span,\n+                                  key: $K,\n+                                  f: F)\n+                                  -> Result<R, CycleError<'a, $tcx>>\n+                where F: FnOnce(&$V) -> R\n+            {\n+                debug!(\"ty::queries::{}::try_get_with(key={:?}, span={:?})\",\n+                       stringify!($name),\n+                       key,\n+                       span);\n+\n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        QueryMsg::$name(profq_key!(tcx, key))\n+                    )\n+                );\n+\n+                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n+                    if let Some(ref d) = value.diagnostics {\n+                        if !d.emitted_diagnostics.get() {\n+                            d.emitted_diagnostics.set(true);\n+                            let handle = tcx.sess.diagnostic();\n+                            for diagnostic in d.diagnostics.iter() {\n+                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n+                                    .emit();\n+                            }\n+                        }\n+                    }\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n+                    tcx.dep_graph.read_index(value.index);\n+                    return Ok(f(&value.value));\n+                }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n+\n+                // FIXME(eddyb) Get more valid Span's on queries.\n+                // def_span guard is necessary to prevent a recursive loop,\n+                // default_span calls def_span query internally.\n+                if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n+                    span = key.default_span(tcx)\n+                }\n+\n+                let dep_node = Self::to_dep_node(tcx, &key);\n+                let res = tcx.cycle_check(span, Query::$name(key), || {\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        if dep_node.kind.is_anon() {\n+                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            })\n+                        } else {\n+                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n+                                                            key: $K)\n+                                                            -> $V {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            }\n+\n+                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n+                        }\n+                    })\n+                })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+                let ((result, dep_node_index), diagnostics) = res;\n+\n+                tcx.dep_graph.read_index(dep_node_index);\n+\n+                let value = QueryValue {\n+                    value: result,\n+                    index: dep_node_index,\n+                    diagnostics: if diagnostics.len() == 0 {\n+                        None\n+                    } else {\n+                        Some(Box::new(QueryDiagnostics {\n+                            diagnostics,\n+                            emitted_diagnostics: Cell::new(true),\n+                        }))\n+                    },\n+                };\n+\n+                Ok(f(&tcx.maps\n+                         .$name\n+                         .borrow_mut()\n+                         .map\n+                         .entry(key)\n+                         .or_insert(value)\n+                         .value))\n+            }\n+\n+            pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)\n+                           -> Result<$V, DiagnosticBuilder<'a>> {\n+                match Self::try_get_with(tcx, span, key, Clone::clone) {\n+                    Ok(e) => Ok(e),\n+                    Err(e) => Err(tcx.report_cycle(e)),\n+                }\n+            }\n+\n+            pub fn force(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K) {\n+                // Ignore dependencies, since we not reading the computed value\n+                let _task = tcx.dep_graph.in_ignore();\n+\n+                match Self::try_get_with(tcx, span, key, |_| ()) {\n+                    Ok(()) => {}\n+                    Err(e) => tcx.report_cycle(e).emit(),\n+                }\n+            }\n+        })*\n+\n+        #[derive(Copy, Clone)]\n+        pub struct TyCtxtAt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+            pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+            pub span: Span,\n+        }\n+\n+        impl<'a, 'gcx, 'tcx> Deref for TyCtxtAt<'a, 'gcx, 'tcx> {\n+            type Target = TyCtxt<'a, 'gcx, 'tcx>;\n+            fn deref(&self) -> &Self::Target {\n+                &self.tcx\n+            }\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxt<'a, $tcx, 'lcx> {\n+            /// Return a transparent wrapper for `TyCtxt` which uses\n+            /// `span` as the location of queries performed through it.\n+            pub fn at(self, span: Span) -> TyCtxtAt<'a, $tcx, 'lcx> {\n+                TyCtxtAt {\n+                    tcx: self,\n+                    span\n+                }\n+            }\n+\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                self.at(DUMMY_SP).$name(key)\n+            })*\n+        }\n+\n+        impl<'a, $tcx, 'lcx> TyCtxtAt<'a, $tcx, 'lcx> {\n+            $($(#[$attr])*\n+            pub fn $name(self, key: $K) -> $V {\n+                queries::$name::try_get(self.tcx, self.span, key).unwrap_or_else(|mut e| {\n+                    e.emit();\n+                    Value::from_cycle_error(self.global_tcx())\n+                })\n+            })*\n+        }\n+\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: ($(([$($modifiers)*] [$name] [$K] [$V]))*),\n+            output: ()\n+        }\n+\n+        impl<$tcx> Copy for Providers<$tcx> {}\n+        impl<$tcx> Clone for Providers<$tcx> {\n+            fn clone(&self) -> Self { *self }\n+        }\n+    }\n+}\n+\n+macro_rules! define_map_struct {\n+    // Initial state\n+    (tcx: $tcx:tt,\n+     input: $input:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final output\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($($output:tt)*)) => {\n+        pub struct Maps<$tcx> {\n+            providers: IndexVec<CrateNum, Providers<$tcx>>,\n+            query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n+            $($output)*\n+        }\n+    };\n+\n+    // Field recognized and ready to shift into the output\n+    (tcx: $tcx:tt,\n+     ready: ([$($pub:tt)*] [$($attr:tt)*] [$name:ident]),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)*\n+                     $(#[$attr])* $($pub)* $name: RefCell<QueryMap<queries::$name<$tcx>>>,)\n+        }\n+    };\n+\n+    // No modifiers left? This is a private item.\n+    (tcx: $tcx:tt,\n+     input: (([] $attrs:tt $name:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            ready: ([] $attrs $name),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip other modifiers\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_map_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}\n+\n+macro_rules! define_provider_struct {\n+    // Initial state:\n+    (tcx: $tcx:tt, input: $input:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ()\n+        }\n+    };\n+\n+    // Final state:\n+    (tcx: $tcx:tt,\n+     input: (),\n+     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n+        pub struct Providers<$tcx> {\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n+                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n+        }\n+    };\n+\n+    // Something ready to shift:\n+    (tcx: $tcx:tt,\n+     ready: ($name:tt $K:tt $V:tt),\n+     input: $input:tt,\n+     output: ($($output:tt)*)) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: $input,\n+            output: ($($output)* ($name $K $V))\n+        }\n+    };\n+\n+    // Regular queries produce a `V` only.\n+    (tcx: $tcx:tt,\n+     input: (([] $name:tt $K:tt $V:tt) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            ready: ($name $K $V),\n+            input: ($($input)*),\n+            output: $output\n+        }\n+    };\n+\n+    // Skip modifiers.\n+    (tcx: $tcx:tt,\n+     input: (([$other_modifier:tt $($modifiers:tt)*] $($fields:tt)*) $($input:tt)*),\n+     output: $output:tt) => {\n+        define_provider_struct! {\n+            tcx: $tcx,\n+            input: (([$($modifiers)*] $($fields)*) $($input)*),\n+            output: $output\n+        }\n+    };\n+}"}, {"sha": "165798d19f196439adc319b40d2dfcbac3545a91", "filename": "src/librustc/ty/maps/values.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70db841aa075aed5b988ff126bf34a1f43b314f7/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fvalues.rs?ref=70db841aa075aed5b988ff126bf34a1f43b314f7", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, Ty, TyCtxt};\n+\n+use syntax::symbol::Symbol;\n+\n+pub(super) trait Value<'tcx>: Sized {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self;\n+}\n+\n+impl<'tcx, T> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        tcx.sess.abort_if_errors();\n+        bug!(\"Value::from_cycle_error called without errors\");\n+    }\n+}\n+\n+impl<'tcx, T: Default> Value<'tcx> for T {\n+    default fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> T {\n+        T::default()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for Ty<'tcx> {\n+    fn from_cycle_error<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n+        tcx.types.err\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for ty::DtorckConstraint<'tcx> {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        Self::empty()\n+    }\n+}\n+\n+impl<'tcx> Value<'tcx> for ty::SymbolName {\n+    fn from_cycle_error<'a>(_: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        ty::SymbolName { name: Symbol::intern(\"<error>\").as_str() }\n+    }\n+}\n+"}]}